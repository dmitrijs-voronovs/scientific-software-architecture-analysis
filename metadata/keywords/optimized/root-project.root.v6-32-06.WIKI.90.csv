quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance,"RecursiveRemove(obj);; 7908 }; 7909}; 7910 ; 7911////////////////////////////////////////////////////////////////////////////////; 7912/// Refresh contents of this tree and its branches from the current status on disk.; 7913///; 7914/// One can call this function in case the tree file is being; 7915/// updated by another process.; 7916 ; 7917void TTree::Refresh(); 7918{; 7919 if (!fDirectory->GetFile()) {; 7920 return;; 7921 }; 7922 fDirectory->ReadKeys();; 7923 fDirectory->Remove(this);; 7924 TTree* tree; fDirectory->GetObject(GetName(),tree);; 7925 if (!tree) {; 7926 return;; 7927 }; 7928 //copy info from tree header into this Tree; 7929 fEntries = 0;; 7930 fNClusterRange = 0;; 7931 ImportClusterRanges(tree);; 7932 ; 7933 fAutoSave = tree->fAutoSave;; 7934 fEntries = tree->fEntries;; 7935 fTotBytes = tree->GetTotBytes();; 7936 fZipBytes = tree->GetZipBytes();; 7937 fSavedBytes = tree->fSavedBytes;; 7938 fTotalBuffers = tree->fTotalBuffers.load();; 7939 ; 7940 //loop on all branches and update them; 7941 Int_t nleaves = fLeaves.GetEntriesFast();; 7942 for (Int_t i = 0; i < nleaves; i++) {; 7943 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);; 7944 TBranch* branch = (TBranch*) leaf->GetBranch();; 7945 branch->Refresh(tree->GetBranch(branch->GetName()));; 7946 }; 7947 fDirectory->Remove(tree);; 7948 fDirectory->Append(this);; 7949 delete tree;; 7950 tree = nullptr;; 7951}; 7952 ; 7953////////////////////////////////////////////////////////////////////////////////; 7954/// Record a TFriendElement that we need to warn when the chain switches to; 7955/// a new file (typically this is because this chain is a friend of another; 7956/// TChain); 7957 ; 7958void TTree::RegisterExternalFriend(TFriendElement *fe); 7959{; 7960 if (!fExternalFriends); 7961 fExternalFriends = new TList();; 7962 fExternalFriends->Add(fe);; 7963}; 7964 ; 7965 ; 7966////////////////////////////////////////////////////////////////////////////////; 7967/// Removes external friend; 7968 ; 7969void TTre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:309605,load,load,309605,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['load'],['load']
Performance,"Redraw(fLt);; 507 ; 508 //--- map slider and list view; 509 SwitchTree(fTreeIndex-1);; 510 fLVContainer->RemoveNonStatic();; 511 MapTree(fTree);; 512 fListView->Layout();; 513 SetFile();; 514}; 515////////////////////////////////////////////////////////////////////////////////; 516/// Allow geting the tree from the context menu.; 517 ; 518void TTreeViewer::SetTreeName(const char* treeName); 519{; 520 if (!treeName) return;; 521 TTree *tree = (TTree *) gROOT->FindObject(treeName);; 522 if (fTreeList) {; 523 if (fTreeList->FindObject(treeName)) {; 524 printf(""Tree found\n"");; 525 TIter next(fTreeList);; 526 Int_t index = 0;; 527 while ((tree = (TTree*)next())) {; 528 if (!strcmp(treeName, tree->GetName())) {printf(""found at index %i\n"", index);break;}; 529 index++;; 530 }; 531 SwitchTree(index);; 532 if (fTree != fMappedTree) {; 533 // switch also the global ""tree"" variable; 534 fLVContainer->RemoveNonStatic();; 535 // map it on the right panel; 536 MapTree(fTree);; 537 fListView->Layout();; 538 TGListTreeItem *base = nullptr;; 539 TGListTreeItem *parent = fLt->FindChildByName(base, ""TreeList"");; 540 TGListTreeItem *item = fLt->FindChildByName(parent, fTree->GetName());; 541 fLt->ClearHighlighted();; 542 fLt->HighlightItem(item);; 543 fClient->NeedRedraw(fLt);; 544 }; 545 return;; 546 }; 547 }; 548 if (!tree) return;; 549// ((TTreePlayer *)tree->GetPlayer())->SetViewer(this);; 550 if (fTree != tree) {; 551 fTree = tree;; 552 // load the tree via the interpreter; 553 // define a global ""tree"" variable for the same tree; 554 TString command = TString::Format(""tv__tree = (TTree *) gROOT->FindObject(\""%s\"");"", treeName);; 555 ExecuteCommand(command.Data());; 556 }; 557 //--- add the tree to the list if it is not already in; 558 if (fTreeList) fTreeList->Add(fTree);; 559 ExecuteCommand(""tv__tree_list->Add(tv__tree);"");; 560 //--- map this tree; 561 TGListTreeItem *base = nullptr;; 562 TGListTreeItem *parent = fLt->FindChildByName(base, ""TreeList"");; 563 if (!parent) parent ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:20276,load,load,20276,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['load'],['load']
Performance,"Ref! physical instance ref counting; Bool_tfRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*fScene! scene where object is stored (can be zero!); static Bool_tfgIgnoreSizeForCameraInterest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLLogicalShape(); Destroy logical shape. void AddRef(TGLPhysicalShape* phys) const; Add reference to given physical shape. void SubRef(TGLPhysicalShape* phys) const; Remove reference to given physical shape, potentially deleting; *this* object when hitting zero ref-count (if fRefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLLogicalShape.html:5426,cache,cached,5426,root/html534/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html534/TGLLogicalShape.html,2,['cache'],"['cache', 'cached']"
Performance,"RefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLLogicalShape.html:5892,cache,cache,5892,root/html528/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html,6,['cache'],['cache']
Performance,"Referenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TApplication::EStatusBitsTApplication::kProcessRemotely; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPyROOTApplication(const char* acn, Int_t* argc, char** argv, Bool_t bLoadLibs = kTRUE); Create a TApplication derived for use with interactive ROOT from python. A; set of standard, often used libs is loaded if bLoadLibs is true (default). Bool_t CreatePyROOTApplication(Bool_t bLoadLibs = kTRUE); Create a TPyROOTApplication. Returns false if gApplication is not null. Bool_t InitROOTGlobals(); Setup the basic ROOT globals gBenchmark, gStyle, gProgname, if not already; set. Always returns true. Bool_t InitROOTMessageCallback(); Install ROOT message handler which will turn ROOT error message into; python exceptions. Always returns true. void dummy(); {}. TPyROOTApplication(const char* acn, Int_t* argc, char** argv, Bool_t bLoadLibs = kTRUE); { }. » Last changed: Tue Jun 30 14:21:27 2015 » Last generated: 2015-06-30 14:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/PyROOT__TPyROOTApplication.html:14152,load,loaded,14152,root/html602/PyROOT__TPyROOTApplication.html,https://root.cern,https://root.cern/root/html602/PyROOT__TPyROOTApplication.html,1,['load'],['loaded']
Performance,"RefreshClassInfo(). void TCling::RefreshClassInfo ; (; TClass * ; cl, . const clang::NamedDecl * ; def, . bool ; alias . ). Internal function. Actually do the update of the ClassInfo when seeing. ; Definition at line 6635 of file TCling.cxx. ◆ RegisterLoadedSharedLibrary(). void TCling::RegisterLoadedSharedLibrary ; (; const char * ; name). private . Register a new shared library name with the interpreter; add it to fSharedLibs. ; Definition at line 3415 of file TCling.cxx. ◆ RegisterModule(). void TCling::RegisterModule ; (; const char * ; modulename, . const char ** ; headers, . const char ** ; includePaths, . const char * ; payloadCode, . const char * ; fwdDeclsCode, . void(*)() ; triggerFunc, . const FwdDeclArgsToKeepCollection_t & ; fwdDeclsArgToSkip, . const char ** ; classesHeaders, . Bool_t ; lateRegistration = false, . Bool_t ; hasCxxModule = false . ). finalvirtual . Inject the module named ""modulename"" into cling; load all headers. ; headers is a 0-terminated array of header files to #include after loading the module. The module is searched for in all $LD_LIBRARY_PATH entries (or PATH% on Windows). This function gets called by the static initialization of dictionary libraries. The payload code is injected ""as is"" in the interpreter. The value of 'triggerFunc' is used to find the shared library location. ; Implements TInterpreter.; Definition at line 2010 of file TCling.cxx. ◆ RegisterPrebuiltModulePath(). bool TCling::RegisterPrebuiltModulePath ; (; const std::string & ; FullPath, . const std::string & ; ModuleMapName = ""module.modulemap"" . ); const. finalvirtual . Returnstrue if the module map was loaded, false on error or if the map was already loaded. ; Implements TInterpreter.; Definition at line 1906 of file TCling.cxx. ◆ RegisterRdictForLoadPCM(). void TCling::RegisterRdictForLoadPCM ; (; const std::string & ; pcmFileNameFullPath, . llvm::StringRef * ; pcmContent . ). private . Register Rdict data for future loading by LoadPCM;. ; Definition at line",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:124989,load,loading,124989,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['load'],['loading']
Performance,"Reimplemented from TSelector.; Definition at line 129 of file TSelectorEntries.cxx. ◆ IsA(). TClass * TSelectorEntries::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TSelector.; Definition at line 60 of file TSelectorEntries.h. ◆ Notify(). bool TSelectorEntries::Notify ; (; ). overridevirtual . This function is called at the first entry of a new tree in a chain. ; Reimplemented from TSelector.; Definition at line 136 of file TSelectorEntries.cxx. ◆ Process(). bool TSelectorEntries::Process ; (; Long64_t ; entry). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either TSelectorEntries::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used. ; Reimplemented from TSelector.; Definition at line 161 of file TSelectorEntries.cxx. ◆ SetObject(). void TSelectorEntries::SetObject ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 54 of file TSelectorEntries.h. ◆ SetOption(). void TSelectorEntries::SetOption ; (; const char * ; option). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 53 of file TSelectorEntries.h. ◆ SetSelection(). void TSelectorEntries::SetSelection ; (; const char * ; selection). virtual . Set the selection expression. ; Definition at line 198 of file TSelec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelectorEntries.html:18005,load,loaded,18005,doc/master/classTSelectorEntries.html,https://root.cern,https://root.cern/doc/master/classTSelectorEntries.html,1,['load'],['loaded']
Performance,"Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TRFIOFile.html:12679,cache,cache,12679,root/html530/TRFIOFile.html,https://root.cern,https://root.cern/root/html530/TRFIOFile.html,1,['cache'],['cache']
Performance,"Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static voidSetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static voidSetOpenT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TDCacheFile.html:12033,cache,cache,12033,root/html530/TDCacheFile.html,https://root.cern,https://root.cern/root/html530/TDCacheFile.html,1,['cache'],['cache']
Performance,"Requests are; saved in a special dataset repository and must be honored by the endpoint.; This is the special PROOF-Lite re-implementation of the TProof function; and includes code originally implemented in TProofServ. Bool_t CancelStagingDataSet(const char* dataset); Cancels a dataset staging request. Returns kTRUE on success, kFALSE on; failure. Dataset not found equals to a failure. PROOF-Lite; re-implementation of the equivalent function in TProofServ. TFileCollection * GetStagingStatusDataSet(const char* dataset); Obtains a TFileCollection showing the staging status of the specified; dataset. A valid dataset manager and dataset staging requests repository; must be present on the endpoint. PROOF-Lite version of the equivalent; function from TProofServ. Int_t VerifyDataSet(const char* uri, const char* = 0); Verify if all files in the specified dataset are available.; Print a list and return the number of missing files. void ClearDataSetCache(const char* dataset = 0); Clear the content of the dataset cache, if any (matching 'dataset', if defined). void ShowDataSetCache(const char* dataset = 0); Display the content of the dataset cache, if any (matching 'dataset', if defined). void SendInputDataFile(); Make sure that the input data objects are available to the workers in a; dedicated file in the cache; the objects are taken from the dedicated list; and / or the specified file.; If the fInputData is empty the specified file is sent over.; If there is no specified file, a file named ""inputdata.root"" is created locally; with the content of fInputData and sent over to the master.; If both fInputData and the specified file are not empty, a copy of the file; is made locally and augmented with the content of fInputData. Int_t Remove(const char* ref, Bool_t all); Handle remove request. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. void FindUniqueSlaves(); Add to the fUniqueSlave list the active slaves th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:35188,cache,cache,35188,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,3,['cache'],['cache']
Performance,"Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = RooCmdArg::none(), const RooCmdArg arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:75016,perform,performed,75016,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['perform'],['performed']
Performance,"Return kTRUE is the class inherits from TObject.; 5937 ; 5938Bool_t TClass::IsTObject() const; 5939{; 5940 if (fProperty==(-1)) Property();; 5941 return TestBit(kIsTObject);; 5942}; 5943 ; 5944////////////////////////////////////////////////////////////////////////////////; 5945/// Return kTRUE is the class is Foreign (the class does not have a Streamer method).; 5946 ; 5947Bool_t TClass::IsForeign() const; 5948{; 5949 if (fProperty==(-1)) Property();; 5950 // If the property are not set and the class is a pair, hard code that; 5951 // it is a unversioned/Foreign class.; 5952 return TestBit(kIsForeign);; 5953}; 5954 ; 5955////////////////////////////////////////////////////////////////////////////////; 5956/// Do the initialization that can only be done after the CINT dictionary has; 5957/// been fully populated and can not be delayed efficiently.; 5958 ; 5959void TClass::PostLoadCheck(); 5960{; 5961 // In the case of a Foreign class (loaded class without a Streamer function); 5962 // we reset fClassVersion to be -1 so that the current TVirtualStreamerInfo will not; 5963 // be confused with a previously loaded streamerInfo.; 5964 ; 5965 if (IsLoaded() && HasInterpreterInfo() && fClassVersion==1 /*&& fStreamerInfo; 5966 && fStreamerInfo->At(1)*/ && IsForeign() ); 5967 {; 5968 SetClassVersion(-1);; 5969 }; 5970 // Note: We are careful to check the class version first because checking; 5971 // for foreign can trigger an AutoParse.; 5972 else if (IsLoaded() && HasDataMemberInfo() && fStreamerInfo && ((fClassVersion > 1) || !IsForeign())); 5973 {; 5974 R__LOCKGUARD(gInterpreterMutex);; 5975 ; 5976 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)(fStreamerInfo->At(fClassVersion));; 5977 // Here we need to check whether this TVirtualStreamerInfo (which presumably has been; 5978 // loaded from a file) is consistent with the definition in the library we just loaded.; 5979 // BuildCheck is not appropriate here since it check a streamerinfo against the; 5980 // 'current st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:228433,load,loaded,228433,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['load'],['loaded']
Performance,"Return kTRUE is the class inherits from TObject.; 6004 ; 6005Bool_t TClass::IsTObject() const; 6006{; 6007 if (fProperty==(-1)) Property();; 6008 return TestBit(kIsTObject);; 6009}; 6010 ; 6011////////////////////////////////////////////////////////////////////////////////; 6012/// Return kTRUE is the class is Foreign (the class does not have a Streamer method).; 6013 ; 6014Bool_t TClass::IsForeign() const; 6015{; 6016 if (fProperty==(-1)) Property();; 6017 // If the property are not set and the class is a pair, hard code that; 6018 // it is a unversioned/Foreign class.; 6019 return TestBit(kIsForeign);; 6020}; 6021 ; 6022////////////////////////////////////////////////////////////////////////////////; 6023/// Do the initialization that can only be done after the CINT dictionary has; 6024/// been fully populated and can not be delayed efficiently.; 6025 ; 6026void TClass::PostLoadCheck(); 6027{; 6028 // In the case of a Foreign class (loaded class without a Streamer function); 6029 // we reset fClassVersion to be -1 so that the current TVirtualStreamerInfo will not; 6030 // be confused with a previously loaded streamerInfo.; 6031 ; 6032 if (IsLoaded() && HasInterpreterInfo() && fClassVersion==1 /*&& fStreamerInfo; 6033 && fStreamerInfo->At(1)*/ && IsForeign() ); 6034 {; 6035 SetClassVersion(-1);; 6036 }; 6037 // Note: We are careful to check the class version first because checking; 6038 // for foreign can trigger an AutoParse.; 6039 else if (IsLoaded() && HasDataMemberInfo() && fStreamerInfo && ((fClassVersion > 1) || !IsForeign())); 6040 {; 6041 R__LOCKGUARD(gInterpreterMutex);; 6042 ; 6043 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)(fStreamerInfo->At(fClassVersion));; 6044 // Here we need to check whether this TVirtualStreamerInfo (which presumably has been; 6045 // loaded from a file) is consistent with the definition in the library we just loaded.; 6046 // BuildCheck is not appropriate here since it check a streamerinfo against the; 6047 // 'current st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:231184,load,loaded,231184,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['load'],['loaded']
Performance,"Return the (address of) a shared pointer to the struct holding the actual thread local gDirectory pointer and the atomic_flag for its lock. ;  ;  Protected Attributes inherited from TFile; TArchiveFile * fArchive {nullptr};  !Archive file from which we read this file ;  ; Long64_t fArchiveOffset {0};  !Offset at which file starts in archive ;  ; TFileOpenHandle * fAsyncHandle {nullptr};  !For proper automatic cleanup ;  ; EAsyncOpenStatus fAsyncOpenStatus {kAOSNotAsync};  !Status of an asynchronous open request ;  ; Long64_t fBEGIN {0};  First used byte in file. ;  ; Long64_t fBytesRead {0};  Number of bytes read from this file. ;  ; Long64_t fBytesReadExtra {0};  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Long64_t fBytesWrite {0};  Number of bytes written to this file. ;  ; TFileCacheRead * fCacheRead {nullptr};  !Pointer to the read cache (if any) ;  ; TMap * fCacheReadMap {nullptr};  !Pointer to the read cache (if any) ;  ; TFileCacheWrite * fCacheWrite {nullptr};  !Pointer to the write cache (if any) ;  ; TArrayC * fClassIndex {nullptr};  !Index of TStreamerInfo classes written to this file ;  ; Int_t fCompress {0};  Compression level and algorithm. ;  ; Int_t fD {-1};  File descriptor. ;  ; Long64_t fEND {0};  Last used byte in file. ;  ; TList * fFree {nullptr};  Free segments linked list table. ;  ; bool fGlobalRegistration = true;  ! if true, bypass use of global lists ;  ; TList * fInfoCache {nullptr};  !Cached list of the streamer infos in this file ;  ; Bool_t fInitDone {kFALSE};  !True if the file has been initialized ;  ; Bool_t fIsArchive {kFALSE};  !True if this is a pure archive file ;  ; Bool_t fIsPcmFile {kFALSE};  !True if the file is a ROOT pcm file. ;  ; Bool_t fIsRootFile {kTRUE};  !True is this is a ROOT file, raw file otherwise ;  ; Bool_t fMustFlush {kTRUE};  !True if the file buffers must be flushed ;  ; Int_t fNbytesFree {0};  Number of bytes for free segments structure. ;  ; Int_t fNbytesInfo {0};  Number of bytes ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixFile.html:36313,cache,cache,36313,doc/master/classTDavixFile.html,https://root.cern,https://root.cern/doc/master/classTDavixFile.html,9,['cache'],['cache']
Performance,"Returning maximum FCN so far (-775.389) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.72761 a1=-0.375581 mean=5.04879 nbkg=141.143 nsig=137.402 sig1frac=0.495257; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 60; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 50; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 40; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 30; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 20; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 10; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 0; [#0] WARNING:Generation -- Fit parameter 'sigma1' does not have an error. A pull distribution cannot be generated. This might be caused by the parameter being constant or because the fits were not run.; [#0] WARNING:Generation -- Fit parameter 'sigma2' does not have an error. A pull distribution cannot be generated. This might be caused by the parameter being constant or because the fits were not run.; [#1] INFO:ObjectHandling -- RooWorkspace::import() importing RooRealVar::meanpull; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pullGauss_over_pullGauss_Int[meanpull]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pullGauss_over_pullGauss_Int[meanpull]_fitParData_model) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf801_mcstudy.py. tutorialsroofitrf801_mcstudy.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8py.html:24322,optimiz,optimization,24322,doc/master/rf801__mcstudy_8py.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8py.html,2,['optimiz'],['optimization']
Performance,"ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::ResultsMulticlass::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 102 of file ResultsMulticlass.h. ◆ Clear() [1/2]. void TMVA::ResultsMulticlass::Clear ; (; Option_t * ; ). inlineoverridevirtual . Reimplemented from TObject.; Definition at line 65 of file ResultsMulticlass.h. ◆ Clear() [2/2]. virtual void TObject::Clear ; (; Option_t * ; = """"). inlinevirtual . Reimplemented from TObject.; Definition at line 119 of file TObject.h. ◆ CreateMulticlassHistos(). void TMVA::ResultsMulticlass::CreateMulticlassHistos ; (; TString ; prefix, . Int_t ; nbins, . Int_t ; nbins_high . ). this function fills the mva response histos for multiclass classification ; Definition at line 354 of file ResultsMulticlass.cxx. ◆ CreateMulticlassPerformanceHistos(). void TMVA::ResultsMulticlass::CreateMulticlassPerformanceHistos ; (; TString ; prefix). Create performance graphs for this classifier a multiclass setting. ; Requires that the method has already been evaluated (that a resultset already exists.); Currently uses the new way of calculating ROC Curves. If anything looks fishy, please contact the ROOT TMVA team. ; Definition at line 240 of file ResultsMulticlass.cxx. ◆ DeclFileName(). static const char * TMVA::ResultsMulticlass::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 102 of file ResultsMulticlass.h. ◆ EstimatorFunction(). Double_t TMVA::ResultsMulticlass::EstimatorFunction ; (; std::vector< Double_t > & ; cutvalues). overridevirtual . Implements TMVA::IFitterTarget.; Definition at line 136 of file ResultsMulticlass.cxx. ◆ GetAchievableEff() [1/2]. std::vector< Float_t > & TMVA::ResultsMulticlass::GetAchievableEff ; (; ). inline . Definition at line 75 of file ResultsMulticlass.h. ◆ GetAchievableEff() [2/2]. Float_t TMVA::ResultsMulticlass::GetAchievableEff ; (; UInt_t ; cls). inline . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1ResultsMulticlass.html:15017,perform,performance,15017,doc/master/classTMVA_1_1ResultsMulticlass.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1ResultsMulticlass.html,1,['perform'],['performance']
Performance,"ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::SdivSqrtSplusB::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::SdivSqrtSplusB::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 66 of file SdivSqrtSplusB.h. ◆ DeclFileName(). static const char * TMVA::SdivSqrtSplusB::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 66 of file SdivSqrtSplusB.h. ◆ GetSeparationGain(). Double_t TMVA::SdivSqrtSplusB::GetSeparationGain ; (; const Double_t ; nSelS, . const Double_t ; nSelB, . const Double_t ; nTotS, . const Double_t ; nTotB . ). virtual . Separation Gain: the measure of how the quality of separation of the sample increases by splitting the sample e.g. ; into a ""left-node"" and a ""right-node"" (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right) this is then the quality criterion which is optimized for when trying to increase the information in the system (making the best selection ; Reimplemented from TMVA::SeparationBase.; Definition at line 58 of file SdivSqrtSplusB.cxx. ◆ GetSeparationIndex(). Double_t TMVA::SdivSqrtSplusB::GetSeparationIndex ; (; const Double_t ; s, . const Double_t ; b . ). virtual . Index = S/sqrt(S+B) (statistical significance) ; Implements TMVA::SeparationBase.; Definition at line 44 of file SdivSqrtSplusB.cxx. ◆ IsA(). virtual TClass * TMVA::SdivSqrtSplusB::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::SeparationBase.; Definition at line 66 of file SdivSqrtSplusB.h. ◆ Streamer(). virtual void TMVA::SdivSqrtSplusB::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::SeparationBase. ◆ StreamerNVirtual(). void TMVA::SdivSqrtSplusB::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 66 of file SdivSqrtSplusB.h. Libraries for TMVA::S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1SdivSqrtSplusB.html:3678,optimiz,optimized,3678,doc/master/classTMVA_1_1SdivSqrtSplusB.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1SdivSqrtSplusB.html,1,['optimiz'],['optimized']
Performance,"Right child index = (inode+1)*2; Suppose, that the child node is stored under the index inode. Then:; Parent index = inode/2. Number of division nodes and number of terminals :; fNNodes = (fNPoints/fBucketSize). The nodes are filled always from left side to the right side:; Let inode be the index of a node, and irow - the index of a row; The TKDTree looks the following way:; Ideal case:; Number of _terminal_ nodes = 2^N, N=3. INode; irow 0 0 - 1 inode; irow 1 1 2 - 2 inodes; irow 2 3 4 5 6 - 4 inodes; irow 3 7 8 9 10 11 12 13 14 - 8 inodes. Non ideal case:; Number of _terminal_ nodes = 2^N+k, N=3 k=1. INode; irow 0 0 - 1 inode; irow 1 1 2 - 2 inodes; irow 2 3 4 5 6 - 3 inodes; irow 3 7 8 9 10 11 12 13 14 - 8 inodes; irow 4 15 16 - 2 inodes. 3b. The division algorithm:. As described above, the kd-tree is built by repeatingly dividing the given set of points into; 2 smaller sets. The cut is made on the axis with the biggest spread, and the value on the axis,; on which the cut is performed, is chosen based on the following formula:; Suppose, we want to divide n nodes into 2 groups, left and right. Then the left and right; will have the following number of nodes:. n=2^k+rest. Left = 2^k-1 + ((rest>2^k-2) ? 2^k-2 : rest); Right = 2^k-1 + ((rest>2^k-2) ? rest-2^k-2 : 0). For example, let n_nodes=67. Then, the closest 2^k=64, 2^k-1=32, 2^k-2=16.; Left node gets 32+3=35 sub-nodes, and the right node gets 32 sub-nodes. The division process continues until all the nodes contain not more than a predefined number; of points. 3c. The order of nodes in boundary-related arrays. Some kd-tree based algorithms need to know the boundaries of each node. This information can; be computed by calling the TKDTree::MakeBoundaries() function. It fills the following arrays:. fRange : array containing the boundaries of the domain:; | 1st dimension (min + max) | 2nd dimension (min + max) | ...; fBoundaries : nodes boundaries; | 1st node {1st dim * 2 elements | 2nd dim * 2 elements | ...} | 2nd n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKDTree_int_double_.html:8725,perform,performed,8725,root/html528/TKDTree_int_double_.html,https://root.cern,https://root.cern/root/html528/TKDTree_int_double_.html,12,['perform'],['performed']
Performance,Roo2DKeysPdf Two-dimensional kernel estimation p.d.f.; RooAICRegistry Registry for analytical integration codes; RooAbsAnaConvPdf Abstract Composite Convoluted PDF; RooAbsArg Abstract variable; RooAbsBinning Abstract base class for binning specification; RooAbsCache Base class for cache managers ; RooAbsCacheElement Base class for cache elements; RooAbsCachedPdf Abstract base class for cached p.d.f.s; RooAbsCachedReal Abstract base class for cached p.d.f.s; RooAbsCategory Abstract discrete variable; RooAbsCategoryLValue Abstract modifiable index variable ; RooAbsCollection Collection of RooAbsArg objects; RooAbsData Abstract data collection; RooAbsDataStore Abstract Data Storage class; RooAbsFunc Abstract real-valued function interface; RooAbsGenContext Abstract context for generating a dataset from a PDF; RooAbsHiddenReal Abstract hidden real-valued variable; RooAbsIntegrator Abstract interface for real-valued function integrators; RooAbsLValue Abstract variable; RooAbsMCStudyModule Monte Carlo study manager add-on module; RooAbsNumGenerator Abstract base class for numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract PDF with normalization support; RooAbsPdf::GenSpec ; RooAbsProxy Abstract proxy interface; RooAbsReal Abstract real-valued variable; RooAbsRealLValue Abstract modifiable real-valued object; RooAbsRootFinder Abstract interface for 1-dim real-valued function root finders; RooAbsSelfCachedPdf Abstract base class for self-caching p.d.f.s; RooAbsSelfCachedReal Abstract base class for self-caching functions; RooAbsString Abstract string-valued variable; RooAbsStudy Abstract base class for RooStudyManager modules; RooAbsTestStatistic Abstract base class for real-valued test statistics; RooAcceptReject Context for generating a dataset from a PDF; RooAdaptiveGaussKronrodIntegrator1D 1-dimensional adaptive Gauss-Kronrod numerical integration engine; RooAdaptiveIntegratorND N-dimensional a,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:24339,optimiz,optimized,24339,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,2,['optimiz'],['optimized']
Performance,RooAICRegistry Registry for analytical integration codes; RooAbsAnaConvPdf Abstract Composite Convoluted PDF; RooAbsArg Abstract variable; RooAbsBinning Abstract base class for binning specification; RooAbsCache Base class for cache managers ; RooAbsCacheElement Base class for cache elements; RooAbsCachedPdf Abstract base class for cached p.d.f.s; RooAbsCachedReal Abstract base class for cached p.d.f.s; RooAbsCategory Abstract discrete variable; RooAbsCategoryLValue Abstract modifiable index variable ; RooAbsCollection Collection of RooAbsArg objects; RooAbsData Abstract data collection; RooAbsDataStore Abstract Data Storage class; RooAbsFunc Abstract real-valued function interface; RooAbsGenContext Abstract context for generating a dataset from a PDF; RooAbsHiddenReal Abstract hidden real-valued variable; RooAbsIntegrator Abstract interface for real-valued function integrators; RooAbsLValue Abstract variable; RooAbsMCStudyModule Monte Carlo study manager add-on module; RooAbsMoment Abstract representation of moment in a RooAbsReal in a given RooRealVar; RooAbsNumGenerator Abstract base class for numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract PDF with normalization support; RooAbsPdf::GenSpec Generation specification; RooAbsProxy Abstract proxy interface; RooAbsReal Abstract real-valued variable; RooAbsRealLValue Abstract modifiable real-valued object; RooAbsRootFinder Abstract interface for 1-dim real-valued function root finders; RooAbsSelfCachedPdf Abstract base class for self-caching p.d.f.s; RooAbsSelfCachedReal Abstract base class for self-caching functions; RooAbsString Abstract string-valued variable; RooAbsStudy Abstract base class for RooStudyManager modules; RooAbsTestStatistic Abstract base class for real-valued test statistics; RooAcceptReject Context for generating a dataset from a PDF; RooAdaptiveGaussKronrodIntegrator1D 1-dimensional adaptive Gauss-Kronrod numerical inte,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:26176,optimiz,optimized,26176,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,1,['optimiz'],['optimized']
Performance,RooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerR,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDecay.html:38596,cache,cache,38596,root/html526/RooDecay.html,https://root.cern,https://root.cern/root/html526/RooDecay.html,1,['cache'],['cache']
Performance,RooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of pl,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDecay.html:38978,cache,cache,38978,root/html528/RooDecay.html,https://root.cern,https://root.cern/root/html528/RooDecay.html,3,['cache'],['cache']
Performance,"RooAbsArg object and the cache data member to communicate server redirects, operation mode changes and constant term optimization management calls. ; Definition at line 27 of file RooAbsCache.h. Public Member Functions;  RooAbsCache (const RooAbsCache &, RooAbsArg *owner=nullptr);  Copy constructor. Takes owner as argument and registers cache with owne. ;  ;  RooAbsCache (RooAbsArg *owner=nullptr);  Constructor. Takes owner as argument and register cache with owner. ;  ; virtual ~RooAbsCache ();  Destructor. Unregisters cache with owner. ;  ; virtual void findConstantNodes (const RooArgSet &, RooArgSet &, RooLinkedList &);  Interface for constant term node finding calls. ;  ; virtual TClass * IsA () const;  ; virtual void operModeHook ();  Interface for operation mode changes. ;  ; virtual void optimizeCacheMode (const RooArgSet &, RooArgSet &, RooLinkedList &);  Interface for processing of cache mode optimization calls. ;  ; virtual void printCompactTreeHook (std::ostream &, const char *);  Interface for printing of cache guts in tree mode printing. ;  ; virtual bool redirectServersHook (const RooAbsCollection &, bool, bool, bool);  Interface for server redirect calls. ;  ; void setOwner (RooAbsArg *owner);  Reset the owner, triggering the owner to register this cache in its list of caches. ;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void wireCache ();  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Attributes; RooAbsArg * _owner;  Pointer to owning RooAbsArg. ;  . #include <RooAbsCache.h>. Inheritance diagram for RooAbsCache:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooAbsCache() [1/2]. RooAbsCache::RooAbsCache ; (; RooAbsArg * ; owner = nullptr). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCache.html:1506,cache,cache,1506,doc/master/classRooAbsCache.html,https://root.cern,https://root.cern/doc/master/classRooAbsCache.html,1,['cache'],['cache']
Performance,"RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsHiddenReal.html:22854,cache,cache,22854,root/html530/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html,43,['cache'],['cache']
Performance,"RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; voidsetVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMembe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealMPFE.html:23439,cache,cache,23439,root/html530/RooRealMPFE.html,https://root.cern,https://root.cern/root/html530/RooRealMPFE.html,1,['cache'],['cache']
Performance,"RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidsetPositiveDefinite(bool flag = true); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMomen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/PiecewiseInterpolation.html:22900,cache,cache,22900,root/html530/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html530/PiecewiseInterpolation.html,1,['cache'],['cache']
Performance,"RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsCategoryLValue::setBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsCategoryLValue::setConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual Bool_tsetIndex(Int_t index, Bool_t printError = kTRUE); virtual Bool_tsetLabel(const char* label, Bool_t printError = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSuperCategory.html:15172,cache,cache,15172,root/html528/RooSuperCategory.html,https://root.cern,https://root.cern/root/html528/RooSuperCategory.html,1,['cache'],['cache']
Performance,"RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsCategoryLValue::setBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsCategoryLValue::setConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual Bool_tsetIndex(Int_t index, Bool_t printError = kTRUE); virtual Bool_tsetLabel(const char* label, Bool_t printError = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSuperCategory.html:15037,cache,cache,15037,root/html526/RooSuperCategory.html,https://root.cern,https://root.cern/root/html526/RooSuperCategory.html,1,['cache'],['cache']
Performance,"RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsCategoryLValue::setBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsCategoryLValue::setConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual Bool_tsetIndex(Int_t index, Bool_t printError = kTRUE); virtual Bool_tsetLabel(const char* label, Bool_t printError = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetRange(const char* rangeName, const char* stateNameList); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCategory.html:14857,cache,cache,14857,root/html528/RooCategory.html,https://root.cern,https://root.cern/root/html528/RooCategory.html,1,['cache'],['cache']
Performance,"RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsCategoryLValue::setBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsCategoryLValue::setConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual Bool_tsetIndex(Int_t index, Bool_t printError = kTRUE); virtual Bool_tsetLabel(const char* label, Bool_t printError = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetRange(const char* rangeName, const char* stateNameList); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual Int_tTNamed::Sizeof() const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCategory.html:14722,cache,cache,14722,root/html526/RooCategory.html,https://root.cern,https://root.cern/root/html526/RooCategory.html,1,['cache'],['cache']
Performance,"RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsCachedReal::setInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedReal.html:22351,cache,cache,22351,root/html526/RooCachedReal.html,https://root.cern,https://root.cern/root/html526/RooCachedReal.html,1,['cache'],['cache']
Performance,"RooAbsArg.h. ◆ dependsOnValue() [2/2]. bool RooAbsArg::dependsOnValue ; (; const RooAbsCollection & ; serverList, . const RooAbsArg * ; ignoreArg = nullptr . ); const. inline . Check whether this object depends on values from an element in the serverList. ; Parameters. serverListTest if one of the elements in this list serves values to this. ; ignoreArgIgnore values served by this object. . ReturnsTrue if values are served. ; Definition at line 108 of file RooAbsArg.h. ◆ expensiveObjectCache(). RooExpensiveObjectCache & RooAbsArg::expensiveObjectCache ; (; ); const. Definition at line 2324 of file RooAbsArg.cxx. ◆ fillTreeBranch(). virtual void RooAbsArg::fillTreeBranch ; (; TTree & ; t). protectedpure virtual . Implemented in RooAbsCategory, RooAbsReal, RooRealVar, and RooStringVar. ◆ findConstantNodes() [1/2]. bool RooAbsArg::findConstantNodes ; (; const RooArgSet & ; observables, . RooArgSet & ; cacheList . ). Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ; Definition at line 1859 of file RooAbsArg.cxx. ◆ findConstantNodes() [2/2]. bool RooAbsArg::findConstantNodes ; (; const RooArgSet & ; observables, . RooArgSet & ; cacheList, . RooLinkedList & ; processedNodes . ). Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ; Definition at line 1877 of file RooAbsArg.cxx. ◆ findNewServer(). RooAbsArg * RooAbsArg::findNewServer ; (; const RooAbsCollection & ; newSet, . bool ; nameChange . ); const. Find the new server in the specified set that matches the old server. ; Parameters. [in]newSetSearch this set by name for a new server. ; [in]nameChangeIf true, search for an item with the bool attribute ""ORIGNAME:<oldName>"" set. Use <object>.setAttribute(""ORIGNAME:<oldName>"") to set this attribute. . ReturnsPointer to the new server or nullptr if there's no unique match. ; Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:59597,cache,cached,59597,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['cached']
Performance,"RooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsCategory::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBinningCategory.html:16495,cache,cache,16495,root/html602/RooBinningCategory.html,https://root.cern,https://root.cern/root/html602/RooBinningCategory.html,2,['cache'],['cache']
Performance,"RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooRealProxy_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; int_l1; int_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; int_m1; int_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooLegendre.html:32984,cache,cache,32984,root/html534/RooLegendre.html,https://root.cern,https://root.cern/root/html534/RooLegendre.html,3,['cache'],['cache']
Performance,"RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_lowestOrder; static Int_tRooPrinta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPolynomial.html:41747,cache,cache,41747,root/html602/RooPolynomial.html,https://root.cern,https://root.cern/root/html602/RooPolynomial.html,2,['cache'],['cache']
Performance,"RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; TArrayD_limits; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_nBins; static Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooParametricStepFunction.html:42672,cache,cache,42672,root/html602/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html602/RooParametricStepFunction.html,2,['cache'],['cache']
Performance,RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*_dataPointer to original input dataset; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_t_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry! carry of Kahan sum in evaluatePartition; Int_t_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*_funcPointer to original input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpMode_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! Is object initialized ; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:35362,cache,cache,35362,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,1,['cache'],['cache']
Performance,RooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooRealProxy_nNumber of expected events; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooRealProxy_pdfInput p.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExtendPdf.html:38045,cache,cache,38045,root/html528/RooExtendPdf.html,https://root.cern,https://root.cern/root/html528/RooExtendPdf.html,6,['cache'],['cache']
Performance,"RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useCdfBoundariesAre c.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCachedReal.html:33665,cache,cache,33665,root/html532/RooCachedReal.html,https://root.cern,https://root.cern/root/html532/RooCachedReal.html,2,['cache'],['cache']
Performance,"RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsIntegrator*_numIntEngine! do not persist; RooAbsFunc*_numIntegrand! do not persist; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet*_params! cache for set of parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; TNamed*_rangeName; Bool_t_restartNumIntEngine! do not persist; RooArgSet_saveInt! do not persist; RooArgSet_saveSum! do not persist; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; RooListProxy_sumCat! do not persist; TIterator*_sumCatIter!; RooSetProxy_sumListSet of discrete observable over which is summed numerically; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherite",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealIntegral.html:37178,cache,cache,37178,root/html602/RooRealIntegral.html,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html,6,['cache'],['cache']
Performance,"RooAbsArg::cleanBranchName() const; virtual voidRooAbsCategoryLValue::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(RooCatType value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); Bool_tRooAbsCategoryLValue::setOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCategory.html:18118,optimiz,optimizeDirtyHook,18118,root/html526/RooCategory.html,https://root.cern,https://root.cern/root/html526/RooCategory.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"RooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction4Binding<double,double,double,double,double>&operator=(const RooCFunction4Binding<double,double,double,double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_double_.html:19964,optimiz,optimizeCacheMode,19964,root/html602/RooCFunction4Binding_double_double_double_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_double_.html,2,['optimiz'],['optimizeCacheMode']
Performance,"RooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual voidRooAbsCategoryLValue::randomize(const char* rangeName = 0); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooCategory(); RooCategory(const char* name, const char* title); RooCategory(const RooCategory& other, const char* name = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsCategoryLValue::setBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); voidRooAbsCategoryLValue::setConstant(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCategory.html:14485,cache,cache,14485,root/html602/RooCategory.html,https://root.cern,https://root.cern/root/html602/RooCategory.html,2,['cache'],['cache']
Performance,"RooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual voidRooAbsCategoryLValue::randomize(const char* rangeName = 0); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooSuperCategory(); RooSuperCategory(const RooSuperCategory& other, const char* name = 0); RooSuperCategory(const char* name, const char* title, const RooArgSet& inputCatList); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsCategoryLValue::setBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSuperCategory.html:14770,cache,cache,14770,root/html602/RooSuperCategory.html,https://root.cern,https://root.cern/root/html602/RooSuperCategory.html,2,['cache'],['cache']
Performance,"RooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual voidRooAbsCategoryLValue::randomize(const char* rangeName = 0); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsCategoryLValue::setBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsCategoryLValue::setConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCategory.html:13617,cache,cache,13617,root/html526/RooCategory.html,https://root.cern,https://root.cern/root/html526/RooCategory.html,4,['cache'],['cache']
Performance,"RooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual voidRooAbsCategoryLValue::randomize(const char* rangeName = 0); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsCategoryLValue::setBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsCategoryLValue::setConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCategory.html:13977,cache,cache,13977,root/html532/RooCategory.html,https://root.cern,https://root.cern/root/html532/RooCategory.html,2,['cache'],['cache']
Performance,"RooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual voidRooAbsCategoryLValue::randomize(const char* rangeName = 0); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsCategoryLValue::setBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); voidRooAbsCategoryLValue::setConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCategory.html:14794,cache,cache,14794,root/html534/RooCategory.html,https://root.cern,https://root.cern/root/html534/RooCategory.html,2,['cache'],['cache']
Performance,"RooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual voidRooAbsCategoryLValue::randomize(const char* rangeName = 0); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsCategoryLValue::setBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsCategoryLValue::setConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCategory.html:13905,cache,cache,13905,root/html530/RooCategory.html,https://root.cern,https://root.cern/root/html530/RooCategory.html,2,['cache'],['cache']
Performance,"RooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const char* rangeName = 0); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const RooAbsBinning& binning); virtual voidRooAbsRealLValue::setBinFast(Int_t ibin, const RooAbsBinning& binning); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidRooAbsRealLValue::setConstant(Bool_t value = kTRUE); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooLinearVar.html:28995,cache,cache,28995,root/html534/RooLinearVar.html,https://root.cern,https://root.cern/root/html534/RooLinearVar.html,3,['cache'],['cache']
Performance,"RooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const char* rangeName = 0); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const RooAbsBinning& binning); virtual voidRooAbsRealLValue::setBinFast(Int_t ibin, const RooAbsBinning& binning); voidsetBinning(const RooAbsBinning& binning, const char* name = 0); voidsetBins(Int_t nBins); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidRooAbsRealLValue::setConstant(Bool_t value = kTRUE); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetMax(Double_t value); voidsetMax(const char* name, Double_t value); voidsetMin(Double_t value); voidsetMin(const char* name, Double_t value); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetRange(Double_t min, Double_t max); voidsetRange(const char* name, Double_t min, Double_t max); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUni",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooErrorVar.html:27088,cache,cache,27088,root/html530/RooErrorVar.html,https://root.cern,https://root.cern/root/html530/RooErrorVar.html,1,['cache'],['cache']
Performance,"RooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:26864,cache,cache,26864,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,59,['cache'],['cache']
Performance,RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAICRegistry_codeReg! Registry of component analytical integration codes; Double_t*_coefCache! Transiet cache with transformed values of coefficients; Int_t_coefErrCount! Coefficient error counter; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoefFlag indicating if last PDFs coefficient was supplied in the ctor; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddPdf.html:43636,cache,cache,43636,root/html602/RooAddPdf.html,https://root.cern,https://root.cern/root/html602/RooAddPdf.html,4,['cache'],['cache']
Performance,"RooAbsCachedReal Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Member Functions |; Static Public Member Functions |; Protected Types |; Protected Member Functions |; Protected Attributes |; Private Attributes |; Friends |; List of all members ; RooAbsCachedReal Class ReferenceabstractRooFit » RooFit Core. ; Abstract base class for functions that need or want to cache their evaluate() output in a RooHistFunc defined in terms of the used observables. ; This base class manages the creation and storage of all RooHistFunc cache p.d.fs and the RooDataHists that define their shape. Implementations of RooAbsCachedReal must define member function fillCacheObject() which serves to fill an already created RooDataHist with the functions function values. In addition the member functions actualObservables() and actualParameters() must be define which report what the actual observables to be cached are for a given set of observables passed by the user to getVal() and on which parameters need to be tracked for changes to trigger a refilling of the cache histogram. ; Definition at line 24 of file RooAbsCachedReal.h. Classes; class  FuncCacheElem;  . Public Member Functions;  RooAbsCachedReal ();  ;  RooAbsCachedReal (const char *name, const char *title, Int_t ipOrder=0);  Constructor. ;  ;  RooAbsCachedReal (const RooAbsCachedReal &other, const char *name=nullptr);  Copy constructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Forward call to implementation in relevant RooHistFunc instance. ;  ; void disableCache (bool flag);  ; bool forceAnalyticalInt (const RooAbsArg &) const override;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Return analytical integration capabilities of the RooHistFunc that corresponds to the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedReal.html:991,cache,cached,991,doc/master/classRooAbsCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedReal.html,2,['cache'],"['cache', 'cached']"
Performance,"RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; TStringevalUserFunc(RooArgSet* vars); virtual voidRooAbsCategory::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); voidinitialize(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidupdateIndexList().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooGenCategory.html:17724,optimiz,optimizeDirtyHook,17724,root/html530/RooGenCategory.html,https://root.cern,https://root.cern/root/html530/RooGenCategory.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"RooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvPdf.html:44642,cache,cache,44642,root/html534/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html534/RooNumConvPdf.html,1,['cache'],['cache']
Performance,"RooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumConvPdf.html:46316,cache,cache,46316,root/html602/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html602/RooNumConvPdf.html,2,['cache'],['cache']
Performance,"RooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxydm; RooRealProxydm0; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDstD0BG.html:42585,cache,cache,42585,root/html534/RooDstD0BG.html,https://root.cern,https://root.cern/root/html534/RooDstD0BG.html,1,['cache'],['cache']
Performance,"RooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tagFlav; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBMixDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBMixDecay.html:46700,cache,cache,46700,root/html602/RooBMixDecay.html,https://root.cern,https://root.cern/root/html602/RooBMixDecay.html,2,['cache'],['cache']
Performance,"RooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; const ROOT::Math::IBaseFunctionOneDim*funcFunctor; RooRealProxyvarArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooFunctor1DPdfBinding.html:39634,cache,cache,39634,root/html528/RooFunctor1DPdfBinding.html,https://root.cern,https://root.cern/root/html528/RooFunctor1DPdfBinding.html,2,['cache'],['cache']
Performance,"RooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,unsigned int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCFunction2PdfBinding_double_unsigned_int_double_.html:39435,cache,cache,39435,root/html528/RooCFunction2PdfBinding_double_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html528/RooCFunction2PdfBinding_double_unsigned_int_double_.html,2,['cache'],['cache']
Performance,"RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tag; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBCPEffDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBCPEffDecay.html:42474,cache,cache,42474,root/html532/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html532/RooBCPEffDecay.html,2,['cache'],['cache']
Performance,"RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tag; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBCPGenDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBCPGenDecay.html:42333,cache,cache,42333,root/html532/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html532/RooBCPGenDecay.html,2,['cache'],['cache']
Performance,"RooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooExtendPdf.html:27852,cache,cache,27852,root/html530/RooExtendPdf.html,https://root.cern,https://root.cern/root/html530/RooExtendPdf.html,3,['cache'],['cache']
Performance,"RooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCoun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCachedPdf.html:28108,cache,cache,28108,root/html530/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html,1,['cache'],['cache']
Performance,"RooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetMode(const RooMomentMorph::Setting& setting); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooMomentMorph.html:27463,cache,cache,27463,root/html530/RooMomentMorph.html,https://root.cern,https://root.cern/root/html530/RooMomentMorph.html,1,['cache'],['cache']
Performance,"RooAbsReal.; Definition at line 57 of file RooGaussian.cxx. ◆ generateEvent(). void RooGaussian::generateEvent ; (; Int_t ; code). overridevirtual . Interface for generation of an event using the algorithm corresponding to the specified code. ; The meaning of each code is defined by the getGenerator() implementation. The default implementation does nothing. ; Reimplemented from RooAbsPdf.; Definition at line 103 of file RooGaussian.cxx. ◆ getAnalyticalIntegral(). Int_t RooGaussian::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 73 of file RooGaussian.cxx. ◆ getGenerator(). Int_t RooGaussian::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ; A code of zero indicates that we cannot generate any of the directVars (in this case, nothing should be added to generatedVars). Any non-zero codes will be passed to our generateEvent() implementation, but otherwise its value is arbitrary. The default implementation of this method returns zero. Subclasses will usually implement this method using the matchArgs() methods to advertise the algorithms they provide. ; Reimplemented from RooAbsPdf.; Definition at line 94 of file RooGaussian.cxx. ◆ getMean(). RooAbsReal const & RooGaussian::getMean ; (; ); con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGaussian.html:77792,perform,performed,77792,doc/master/classRooGaussian.html,https://root.cern,https://root.cern/doc/master/classRooGaussian.html,1,['perform'],['performed']
Performance,"RooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; vector<Int_t>_catRefReference valyes for categories; RooListProxy_catSetList of categories to check; TIterator*_catSetIter! do not persist; Bool_t_checkValCheck contents as well if true; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init!; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChangeTracker.html:33790,cache,cache,33790,root/html534/RooChangeTracker.html,https://root.cern,https://root.cern/root/html534/RooChangeTracker.html,3,['cache'],['cache']
Performance,"RooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooSetProxy_compSetDSet proxy for denominator components ; RooSetProxy_compSetNSet proxy for numerator components ; RooArgSet*_compSetOwnedDOwner of denominator components; RooArgSet*_compSetOwnedNOwner of numerator components ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveDDo we have a denominator term?; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooListProxy_intListMaster integrals representing numerator and denominator; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGenProdProj.html:33840,cache,cache,33840,root/html534/RooGenProdProj.html,https://root.cern,https://root.cern/root/html534/RooGenProdProj.html,1,['cache'],['cache']
Performance,"RooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooSetProxy_compSetDSet proxy for denominator components ; RooSetProxy_compSetNSet proxy for numerator components ; RooArgSet*_compSetOwnedDOwner of denominator components; RooArgSet*_compSetOwnedNOwner of numerator components ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveDDo we have a denominator term?; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooListProxy_intListMaster integrals representing numerator and denominator; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenProdProj.html:30812,cache,cache,30812,root/html526/RooGenProdProj.html,https://root.cern,https://root.cern/root/html526/RooGenProdProj.html,4,['cache'],['cache']
Performance,"RooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,double,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction3Binding_double_double_double_double_.html:32593,cache,cache,32593,root/html526/RooCFunction3Binding_double_double_double_double_.html,https://root.cern,https://root.cern/root/html526/RooCFunction3Binding_double_double_double_double_.html,2,['cache'],['cache']
Performance,"RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRecursiveFraction(); Default constructor. RooRecursiveFraction(const char* name, const char* title, const RooArgList& fracSet); Constructor of plain",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRecursiveFraction.html:34741,cache,cache,34741,root/html534/RooRecursiveFraction.html,https://root.cern,https://root.cern/root/html534/RooRecursiveFraction.html,2,['cache'],['cache']
Performance,"RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to functions whose running integral is calculated; RooRealProxyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumRunningInt.html:39106,cache,cache,39106,root/html602/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html602/RooNumRunningInt.html,2,['cache'],['cache']
Performance,"RooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* nset); Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:42536,cache,cached,42536,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,3,['cache'],"['cache', 'cached']"
Performance,"RooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:43149,cache,cached,43149,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,6,['cache'],"['cache', 'cached']"
Performance,"RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:47753,cache,cached,47753,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,3,['cache'],['cached']
Performance,"RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. void setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); Activate caching of normalization integral values in a interpolated histogram; for integrals that exceed the specified minimum number of numerically integrated; dimensions, _and_ of which the integral has at most 2 parameters. The cache is scanned with a granularity defined by a binning named ""cache"" in the; scanned integral parameters and is interpolated to given order.; The cache values are kept for the livetime of the ROOT session/application; and are persisted along with the object in case the p.d.f. is persisted; in a RooWorkspace. This feature can substantially speed up fits and improve convergence with slow; multi-dimensional integrals whose value varies slowly with the parameters so th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:44600,cache,cached,44600,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,3,['cache'],['cached']
Performance,"RooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFFTConvPdf.html:6727,cache,cacheUniqueSuffix,6727,root/html532/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html532/RooFFTConvPdf.html,1,['cache'],['cacheUniqueSuffix']
Performance,"RooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooFFTConvPdf.html:6727,cache,cacheUniqueSuffix,6727,root/html528/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html528/RooFFTConvPdf.html,2,['cache'],['cacheUniqueSuffix']
Performance,"RooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooIntegralMorph.html:5990,cache,cacheUniqueSuffix,5990,root/html534/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html534/RooIntegralMorph.html,1,['cache'],['cacheUniqueSuffix']
Performance,"RooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; const RooArgList&boundaries(); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStepFunction.html:2566,cache,cacheUniqueSuffix,2566,root/html534/RooStepFunction.html,https://root.cern,https://root.cern/root/html534/RooStepFunction.html,1,['cache'],['cacheUniqueSuffix']
Performance,"RooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; RooRealVar&var() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumConvPdf.html:32564,cache,cache,32564,root/html532/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html532/RooNumConvPdf.html,1,['cache'],['cache']
Performance,"RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual RooAbsGenContext*autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; virtual RooAbsGenContext*binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:6272,cache,cacheUniqueSuffix,6272,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,1,['cache'],['cacheUniqueSuffix']
Performance,"RooArgSet &vars, const RooFormulaVar *cutVar, const char *cutRange, Int_t nStart, Int_t nStop, const char *wgtVarName=nullptr);  ;  RooTreeDataStore (TTree *t, const RooArgSet &vars, const char *wgtVarName=nullptr);  Constructor to facilitate reading of legacy RooDataSets. ;  ;  ~RooTreeDataStore () override;  Destructor. ;  ; RooAbsArg * addColumn (RooAbsArg &var, bool adjustRange=true) override;  Add a new column to the data set which holds the pre-calculated values of 'newVar'. ;  ; void append (RooAbsDataStore &other) override;  ; void attachBuffers (const RooArgSet &extObs) override;  ; void cacheArgs (const RooAbsArg *owner, RooArgSet &varSet, const RooArgSet *nset=nullptr, bool skipZeroWeights=false) override;  Cache given RooAbsArgs with this tree: The tree is given direct write access of the args internal cache the args values is pre-calculated for all data points in this data collection. ;  ; const RooAbsArg * cacheOwner () override;  ; bool changeObservableName (const char *from, const char *to) override;  Change name of internal observable named 'from' into 'to'. ;  ; void checkInit () const override;  ; RooAbsDataStore * clone (const char *newname=nullptr) const override;  ; RooAbsDataStore * clone (const RooArgSet &vars, const char *newname=nullptr) const override;  ; void Draw (Option_t *option="""") override;  Default Draw method for all objects. ;  ; Int_t Fill ();  Interface function to TTree::Fill. ;  ; Int_t fill () override;  Interface function to TTree::Fill. ;  ; virtual const RooArgSet * get () const;  ; const RooArgSet * get (Int_t index) const override;  Load the n-th data point (n='index') in memory and return a pointer to the internal RooArgSet holding its coordinates. ;  ; virtual const RooArgSet * get (Int_t index) const=0;  ; RooAbsData::RealSpans getBatches (std::size_t first, std::size_t len) const override;  Retrieve batches for all observables in this data store. ;  ; Stat_t GetEntries () const;  Interface function to TTree::GetEntrie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:3379,cache,cacheOwner,3379,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['cache'],['cacheOwner']
Performance,"RooArgSet & ; vars, . RooAbsDataStore * ; dstore = nullptr . ). Constructor from a set of variables. ; Only fundamental elements of vars (RooRealVar,RooCategory etc) are stored as part of the dataset ; Definition at line 183 of file RooAbsData.cxx. ◆ RooAbsData() [3/3]. RooAbsData::RooAbsData ; (; const RooAbsData & ; other, . const char * ; newname = nullptr . ). Copy constructor. ; Definition at line 245 of file RooAbsData.cxx. ◆ ~RooAbsData(). RooAbsData::~RooAbsData ; (; ). override . Destructor. ; Definition at line 280 of file RooAbsData.cxx. Member Function Documentation. ◆ add(). virtual void RooAbsData::add ; (; const RooArgSet & ; row, . double ; weight = 1 . ). pure virtual . Implemented in RooDataSet, and RooDataHist. ◆ addOwnedComponent(). void RooAbsData::addOwnedComponent ; (; const char * ; idxlabel, . RooAbsData & ; data . ). Definition at line 2366 of file RooAbsData.cxx. ◆ allClientsCached(). bool RooAbsData::allClientsCached ; (; RooAbsArg * ; var, . const RooArgSet & ; cacheList . ). protected . Utility function that determines if all clients of object 'var' appear in given list of cached nodes. ; Definition at line 2319 of file RooAbsData.cxx. ◆ attachBuffers(). void RooAbsData::attachBuffers ; (; const RooArgSet & ; extObs). Definition at line 2337 of file RooAbsData.cxx. ◆ attachCache(). void RooAbsData::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). protectedvirtual . Internal method – Attach dataset copied with cache contents to copied instances of functions. ; Definition at line 363 of file RooAbsData.cxx. ◆ cacheArgs(). void RooAbsData::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; varSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = false . ). protectedvirtual . Internal method – Cache given set of functions with data. ; Definition at line 346 of file RooAbsData.cxx. ◆ canSplitFast(). bool RooAbsData::canSplitFast ; (; ); const. Definition at line 2351 of file RooAbsDa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:34080,cache,cacheList,34080,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['cache'],['cacheList']
Performance,"RooArgSet const &vars);  ; virtual void optimizeReadingWithCaching (RooAbsArg &arg, const RooArgSet &cacheList, const RooArgSet &keepObsList);  Prepare dataset for use with cached constant terms listed in 'cacheList' of expression 'arg'. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ), where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1 as function of the frames variable. ;  ; virtual RooPlot * plotEffOn (RooPlot *frame, const RooAbsCategoryLValue &effCat, PlotOpt o) const;  Create and fill a histogram with the efficiency N[1] / ( N[1] + N[0] ), where N(1/0) is the number of data points with effCat=1 and effCat=0 as function of the frames variable. ;  ; virtual RooPlot * plotOn (RooPlot *frame, PlotOpt o) const;  Create and fill a histogram of the frame's variable and append it to the frame. ;  ; virtual void resetCache ();  Internal method – Remove cached function values. ;  ; virtual void setArgStatus (const RooArgSet &set, bool active);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from RooDirItem; void appendToDir (TObject *obj, bool forceMemoryResident=false);  Append object to directory. ;  ; void removeFromDir (TObject *obj);  Remove object from directory it was added to. ;  . Protected Attributes; RooArgSet _varsNoWgt;  Vars without weight variable. ;  ; RooRealVar * _wgtVar = nullptr;  Pointer to weight variable (if set) ;  ;  Protected Attributes inherited from RooAbsData; RooArgSet _cachedVars;  ! External variables cached with this data set ;  ; std::unique_ptr< RooAbsDataStore > _dstore;  Data storage implementation. ;  ; std::unique_ptr< RooArgSet > _globalObservables;  Snapshot of global observab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataSet.html:32988,cache,cached,32988,doc/master/classRooDataSet.html,https://root.cern,https://root.cern/doc/master/classRooDataSet.html,1,['cache'],['cached']
Performance,"RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset, 				 const RooNumIntConfig* cfg, const char* rangeName); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ran",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:36259,perform,performed,36259,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,2,['perform'],['performed']
Performance,"RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Roo2DKeysPdf.html:10894,cache,cacheList,10894,root/html526/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html526/Roo2DKeysPdf.html,123,['cache'],['cacheList']
Performance,"RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBCPEffDecay.html:11620,cache,cacheList,11620,root/html528/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html528/RooBCPEffDecay.html,77,['cache'],['cacheList']
Performance,"RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxyRooAbsHiddenReal::_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; RooRealProxy_value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooUnblindOffset(); Default constructor. RooUnblindOffset(const char* name, const char* title, const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooUnblindOffset.html:35418,cache,cache,35418,root/html534/RooUnblindOffset.html,https://root.cern,https://root.cern/root/html534/RooUnblindOffset.html,2,['cache'],['cache']
Performance,"RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxyRooAbsHiddenReal::_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; RooRealProxy_value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooUnblindUniform(); Default constructor. RooUnblindUniform(const char* name, const char* title, const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooUnblindUniform.html:34745,cache,cache,34745,root/html534/RooUnblindUniform.html,https://root.cern,https://root.cern/root/html534/RooUnblindUniform.html,2,['cache'],['cache']
Performance,"RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,int>funcFunction pointer reference; RooRealProxyxArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction1Ref<VO,VI> Streamer(TBuffer& ); Custom streamer for function pointer reference object. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction1Binding_double_int_.html:35144,cache,cache,35144,root/html534/RooCFunction1Binding_double_int_.html,https://root.cern,https://root.cern/root/html534/RooCFunction1Binding_double_int_.html,2,['cache'],['cache']
Performance,"RooCFunction3Ref<double,unsigned int,unsigned int,double> ; RooCFunction4Binding<double,double,double,double,bool> ; RooCFunction4Binding<double,double,double,double,double> ; RooCFunction4Binding<double,double,double,double,int> ; RooCFunction4PdfBinding<double,double,double,double,bool> ; RooCFunction4PdfBinding<double,double,double,double,double> ; RooCFunction4PdfBinding<double,double,double,double,int> ; RooCFunction4Ref<double,double,double,double,bool> ; RooCFunction4Ref<double,double,double,double,double> ; RooCFunction4Ref<double,double,double,double,int> ; RooCacheManager<RooAbsCacheElement> ; RooCacheManager<vector<double> > ; RooCachedPdf P.d.f class that wraps another p.d.f and caches its output; RooCachedReal P.d.f class that wraps another p.d.f and caches its output; RooCatType Category state, (name,index) pair; RooCategory Discrete valued variable type; RooCategoryProxy Proxy for a RooAbsCategory object; RooCategorySharedProperties Shared properties of a RooCategory clone set; RooChangeTracker Meta object that tracks changes in set of other arguments; RooChebychev Chebychev polynomial PDF; RooChi2MCSModule MCStudy module to calculate chi2 between binned data and fit; RooChi2Var Chi^2 function of p.d.f w.r.t a binned dataset; RooChiSquarePdf Chi Square distribution (eg. the PDF ); RooCintUtils ; RooClassFactory RooFit class code and instance factory; RooCmdArg Generic named argument container; RooCmdConfig Configurable parse of RooCmdArg objects; RooComplex a non-persistent bare-bones complex class; RooCompositeDataStore Composite Data Storage class; RooConstVar Constant RooAbsReal value object; RooConstraintSum sum of -log of set of RooAbsPdf representing parameter constraints; RooConvCoefVar Auxiliary class representing the coefficient of a RooAbsAnaConvPdf as a RooAbsReal; RooConvGenContext Context for generating a dataset from a PDF; RooConvIntegrandBinding RooAbsFunc representation of convolution integrands; RooCurve 1-dimensional smooth curve for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:30047,cache,caches,30047,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['cache'],['caches']
Performance,"RooCmdArg ConditionalObservables(Args_t &&... argsOrArgSet)Create a RooCmdArg to declare conditional observables.Definition RooGlobalFunc.h:278; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; RooFit::ProjWDataRooCmdArg ProjWData(const RooAbsData &projData, bool binData=false)Definition RooGlobalFunc.cxx:179; RooFit::NormalizationRooCmdArg Normalization(double scaleFactor)Definition RooGlobalFunc.cxx:195; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf306_condpereventerrorsDefinition rf306_condpereventerrors.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_over_gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_Int[dt]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_over_gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_Int[dt]_decay_gmData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(gm1_conv_exp(-abs(@0)/@1)_dt_tau_[decay_gm]_Int[dt,dterr]) using numeric integrator RooIntegrator1D to calculate Int(dterr); [#1] INFO:Plotting -- RooAbsReal::plotOn(decay_gm) plot on dt averages using data variables (dterr); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf306_condpereventerrors.C. tutorialsroofitrf306_condpereventerrors.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf306__condpereventerrors_8C.html:7507,optimiz,optimization,7507,doc/master/rf306__condpereventerrors_8C.html,https://root.cern,https://root.cern/doc/master/rf306__condpereventerrors_8C.html,2,['optimiz'],['optimization']
Performance,"RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidmakeCoefVarList(RooArgList&) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:34503,optimiz,optimizeDirtyHook,34503,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,3,['optimiz'],['optimizeDirtyHook']
Performance,RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooAbsData*RooAbsOptTestStatistic::_origDataOriginal data ; RooAbsReal*RooAbsOptTestStatistic::_origFuncOriginal function ; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observa,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDataWeightedAverage.html:34849,cache,cache,34849,root/html532/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html532/RooDataWeightedAverage.html,1,['cache'],['cache']
Performance,"RooExpensiveObjectCache::ExpensiveObjectExpensiveObject(const RooExpensiveObjectCache::ExpensiveObject&); RooExpensiveObjectCache::ExpensiveObjectExpensiveObject(Int_t uid, const RooExpensiveObjectCache::ExpensiveObject& other); RooExpensiveObjectCache::ExpensiveObjectExpensiveObject(Int_t uid, const char* ownerName, TObject& payload, TIterator* paramIter); virtual TClass*IsA() const; Bool_tmatches(TClass* tc, const RooArgSet& params); RooExpensiveObjectCache::ExpensiveObject&operator=(const RooExpensiveObjectCache::ExpensiveObject&); const char*ownerName() const; const TObject*payload() const; TObject*payload(); voidprint(); voidsetPayload(TObject* obj); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Int_tuid() const. Data Members; protected:. map<TString,Int_t>_catRefParamsNames and values of discrete-valued reference parameters ; TString_ownerNameName of RooAbsArg object that is associated to cache contents; TObject*_payloadPayload; map<TString,Double_t>_realRefParamsNames and values of real-valued reference parameters; Int_t_uidUnique element ID ;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ExpensiveObject(Int_t uid, const char* ownerName, TObject& payload, TIterator* paramIter); Construct ExpensiveObject oject for inPayLoad and store reference values; for all RooAbsReal and RooAbsCategory parameters in params. ExpensiveObject(Int_t uid, const RooExpensiveObjectCache::ExpensiveObject& other). ~ExpensiveObject(). Bool_t matches(TClass* tc, const RooArgSet& params); Check object type ;. void print(). ExpensiveObject(); { _uid = 0 ; _payload = 0 ; }. ExpensiveObject(Int_t uid, const char* ownerName, TObject& payload, TIterator* paramIter). Int_t uid() const; { return _uid ; }. const TObject* payload() const; { return _payload ; }. TObject* payload(); { return _payload ; }. void setPayload(TObject* obj); { _payload = obj ; }. const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooExpensiveObjectCache__ExpensiveObject.html:1836,cache,cache,1836,root/html534/RooExpensiveObjectCache__ExpensiveObject.html,https://root.cern,https://root.cern/root/html534/RooExpensiveObjectCache__ExpensiveObject.html,1,['cache'],['cache']
Performance,"RooFFTConvPdf. ◆ actualParameters(). virtual RooFit::OwningPtr< RooArgSet > RooAbsCachedPdf::actualParameters ; (; const RooArgSet & ; nset); const. protectedpure virtual . Implemented in RooIntegralMorph, RooCachedPdf, and RooFFTConvPdf. ◆ analyticalIntegralWN(). double RooAbsCachedPdf::analyticalIntegralWN ; (; Int_t ; code, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Implements internal (analytical) integration capabilities. ; Call is forwarded to RooHistPdf cache p.d.f of cache that is used for given choice of observables ; Reimplemented from RooAbsReal.; Definition at line 376 of file RooAbsCachedPdf.cxx. ◆ binningName(). virtual const char * RooAbsCachedPdf::binningName ; (; ); const. inlineprotectedvirtual . Definition at line 97 of file RooAbsCachedPdf.h. ◆ cacheNameSuffix(). std::string RooAbsCachedPdf::cacheNameSuffix ; (; const RooArgSet & ; nset); const. protected . Construct string with unique suffix for cache objects based on observable names that define cache configuration. ; Definition at line 241 of file RooAbsCachedPdf.cxx. ◆ Class(). static TClass * RooAbsCachedPdf::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCachedPdf::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCachedPdf::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 137 of file RooAbsCachedPdf.h. ◆ compileForNormSet(). std::unique_ptr< RooAbsArg > RooAbsCachedPdf::compileForNormSet ; (; RooArgSet const & ; normSet, . RooFit::Detail::CompileContext & ; ctx . ); const. overridevirtual . Reimplemented from RooAbsArg.; Definition at line 410 of file RooAbsCachedPdf.cxx. ◆ createCache(). virtual PdfCacheElem * RooAbsCachedPdf::createCache ; (; const RooArgSet * ; nset); const. inlineprotectedvirtual . Reimplemented in RooIntegralMorph, and RooFFTConvPdf.; Definition at line 101",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:78728,cache,cache,78728,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,2,['cache'],['cache']
Performance,"RooFit::ConditionalRooCmdArg Conditional(const RooArgSet &pdfSet, const RooArgSet &depSet, bool depsAreCond=false)Definition RooGlobalFunc.cxx:805; RooFit::RooConstRooConstVar & RooConst(double val)Definition RooGlobalFunc.cxx:1131; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::ConditionalObservablesRooCmdArg ConditionalObservables(Args_t &&... argsOrArgSet)Create a RooCmdArg to declare conditional observables.Definition RooGlobalFunc.h:278; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf702_efficiencyfit_2DDefinition rf702_efficiencyfit_2D.py:1; ; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]) WARNING: performing accept/reject sampling on a p.d.f in 2 dimensions without prior knowledge on maximum value of p.d.f. Determining maximum value by taking 200000 trial samples. If p.d.f contains sharp peaks smaller than average distance between trial sampling points these may be missed and p.d.f. may be sampled incorrectly.; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]): WARNING: 200000 trial samples requested by p.d.f for 2-dimensional accept/reject sampling, this may take some time; [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf702__efficiencyfit__2D_8C.html:7631,perform,performing,7631,doc/master/rf702__efficiencyfit__2D_8C.html,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8C.html,1,['perform'],['performing']
Performance,"RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  Return observable in nset to be cached by RooAbsCachedPdf this is always the x observable that is integrated. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  Return the parameters of the cache created by RooAbsCachedPdf. ;  ; const char * binningName () const override;  ; FuncCacheElem * createCache (const RooArgSet *nset) const override;  Create custom cache element for running integral calculations. ;  ; double evaluate () const override;  Dummy function that is never called. ;  ; void fillCacheObject (FuncCacheElem &cacheFunc) const override;  Fill the cache object by calling its calculate() method. ;  ; const char * inputBaseName () const override;  Return unique name for RooAbsCachedPdf cache components constructed from input function name. ;  ; const char * payloadUniqueSuffix () const override;  ;  Protected Member Functions inherited from RooAbsCachedReal; TString cacheNameSuffix (const RooArgSet &nset) const;  Construct unique suffix name for cache p.d.f object. ;  ; FuncCacheElem * getCache (const RooArgSet *nset) const;  Retrieve cache corresponding to observables in nset. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumCdf.html:50963,cache,cacheNameSuffix,50963,doc/master/classRooNumCdf.html,https://root.cern,https://root.cern/doc/master/classRooNumCdf.html,4,['cache'],"['cache', 'cacheNameSuffix']"
Performance,"RooFitResult> r{model.fitTo(*data, Save(), PrintLevel(-1))};; ; // C r e a t e M V G a u s s i a n p d f o f f i t t e d p a r a m e t e r s; // ------------------------------------------------------------------------------------; ; RooAbsPdf *parabPdf = r->createHessePdf(RooArgSet(frac, mean, sigma_g2));; ; // S o m e e x e c e r c i s e s w i t h t h e p a r a m e t e r p d f; // -----------------------------------------------------------------------------; ; // Generate 100K points in the parameter space, sampled from the MVGaussian pdf; std::unique_ptr<RooDataSet> d{parabPdf->generate({mean, sigma_g2, frac}, 100000)};; ; // Sample a 3-D histogram of the pdf to be visualized as an error ellipsoid using the GLISO draw option; TH3 *hh_3d = (TH3 *)parabPdf->createHistogram(""mean,sigma_g2,frac"", 25, 25, 25);; hh_3d->SetFillColor(kBlue);; ; // Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; // The integrations corresponding to these projections are performed analytically; // by the MV Gaussian pdf; RooAbsPdf *pdf_sigmag2_frac = parabPdf->createProjection(mean);; RooAbsPdf *pdf_mean_frac = parabPdf->createProjection(sigma_g2);; RooAbsPdf *pdf_mean_sigmag2 = parabPdf->createProjection(frac);; ; // Make 2D plots of the 3 two-dimensional pdf projections; TH2 *hh_sigmag2_frac = (TH2 *)pdf_sigmag2_frac->createHistogram(""sigma_g2,frac"", 50, 50);; TH2 *hh_mean_frac = (TH2 *)pdf_mean_frac->createHistogram(""mean,frac"", 50, 50);; TH2 *hh_mean_sigmag2 = (TH2 *)pdf_mean_sigmag2->createHistogram(""mean,sigma_g2"", 50, 50);; hh_mean_frac->SetLineColor(kBlue);; hh_sigmag2_frac->SetLineColor(kBlue);; hh_mean_sigmag2->SetLineColor(kBlue);; ; // Draw the 'sigar'; new TCanvas(""rf608_fitresultaspdf_1"", ""rf608_fitresultaspdf_1"", 600, 600);; hh_3d->Draw(""iso"");; ; // Draw the 2D projections of the 3D pdf; TCanvas *c2 = new TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 600);; c2->Divide(3, 2);; c2->cd(1);; gPad->SetLeftMargin(0.15);; hh_mean_sigmag2-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html:2480,perform,performed,2480,doc/master/rf608__fitresultaspdf_8C.html,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html,1,['perform'],['performed']
Performance,"RooGaussian.h""; #include ""RooLandau.h""; #include ""RooFFTConvPdf.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf208_convolution(); {; // S e t u p c o m p o n e n t p d f s; // ---------------------------------------; ; // Construct observable; RooRealVar t(""t"", ""t"", -10, 30);; ; // Construct landau(t,ml,sl) ;; RooRealVar ml(""ml"", ""mean landau"", 5., -20, 20);; RooRealVar sl(""sl"", ""sigma landau"", 1, 0.1, 10);; RooLandau landau(""lx"", ""lx"", t, ml, sl);; ; // Construct gauss(t,mg,sg); RooRealVar mg(""mg"", ""mg"", 0);; RooRealVar sg(""sg"", ""sg"", 2, 0.1, 10);; RooGaussian gauss(""gauss"", ""gauss"", t, mg, sg);; ; // C o n s t r u c t c o n v o l u t i o n p d f; // ---------------------------------------; ; // Set #bins to be used for FFT sampling to 10000; t.setBins(10000, ""cache"");; ; // Construct landau (x) gauss; RooFFTConvPdf lxg(""lxg"", ""landau (X) gauss"", t, landau, gauss);; ; // S a m p l e , f i t a n d p l o t c o n v o l u t e d p d f; // ----------------------------------------------------------------------; ; // Sample 1000 events in x from gxlx; std::unique_ptr<RooDataSet> data{lxg.generate(t, 10000)};; ; // Fit gxlx to data; lxg.fitTo(*data, PrintLevel(-1));; ; // Plot data, landau pdf, landau (X) gauss pdf; RooPlot *frame = t.frame(Title(""landau (x) gauss convolution""));; data->plotOn(frame);; lxg.plotOn(frame);; landau.plotOn(frame, LineStyle(kDashed));; ; // Draw frame on canvas; new TCanvas(""rf208_convolution"", ""rf208_convolution"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; }; RooDataSet.h; RooFFTConvPdf.h; RooGaussian.h; RooLandau.h; RooPlot.h; RooRealVar.h; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1.h; gPad#def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf208__convolution_8C.html:1311,cache,cache,1311,doc/master/rf208__convolution_8C.html,https://root.cern,https://root.cern/doc/master/rf208__convolution_8C.html,1,['cache'],['cache']
Performance,"RooKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const char* name, const char* title, RooAbsReal& x, RooAbsReal& y, RooDataSet& data, TString options = ""a"", Double_t rho = 1.0, Double_t nSigma = 3, Bool_t rotate = kTRUE); Backward compatibility constructor for Roo2DKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const RooNDKeysPdf& other, const char* name = 0); Constructor. ~RooNDKeysPdf(). createPdf(Bool_t firstCall = kTRUE) const; evaluation order of constructor. setOptions() const; set the configuration. initialize() const; initialization. loadDataSet(Bool_t firstCall) const; copy the dataset and calculate some useful variables. mirrorDataSet() const; determine mirror dataset.; mirror points are added around the physical boundaries of the dataset; Two steps:; 1. For each entry, determine if it should be mirrored (the mirror configuration).; 2. For each mirror configuration, make the mirror points. loadWeightSet() const. calculateShell(RooNDKeysPdf::BoxInfo* bi) const; determine points in +/- nSigma shell around the box determined by the variable; ranges. These points are needed in the normalization, to determine probability; leakage in and out of the box. calculatePreNorm(RooNDKeysPdf::BoxInfo* bi) const; bi->nEventsBMSW=0.;; bi->nEventsBW=0.;. sortDataIndices(RooNDKeysPdf::BoxInfo* bi = 0) const; sort entries, as needed for loopRange(). calculateBandWidth() const. gauss(vector<Double_t>& x, vector<std::vector<Double_t> >& weights) const; loop over all closest point to x, as determined by loopRange(). loopRange(vector<Double_t>& x, map<Int_t,Bool_t>& ibMap) const; determine closest points to x, to loop over in evaluate(). boxInfoInit(RooNDKeysPdf::BoxInfo* bi, const char* rangeName, Int_t code) const. evaluate() const. getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. analyticalIntegral(Int_t code, const char* rangeName = 0) const. TObject* cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNDKeysPdf.html:49309,load,loadWeightSet,49309,root/html534/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html534/RooNDKeysPdf.html,1,['load'],['loadWeightSet']
Performance,"RooKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const char* name, const char* title, RooAbsReal& x, RooAbsReal& y, RooDataSet& data, TString options = ""a"", Double_t rho = 1.0, Double_t nSigma = 3, Bool_t rotate = kTRUE); Backward compatibility constructor for Roo2DKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const RooNDKeysPdf& other, const char* name = 0); Constructor. ~RooNDKeysPdf(). createPdf(Bool_t firstCall = kTRUE) const; evaluation order of constructor. setOptions() const; set the configuration. initialize() const; initialization. loadDataSet(Bool_t firstCall) const; copy the dataset and calculate some useful variables. mirrorDataSet() const; determine mirror dataset.; mirror points are added around the physical boundaries of the dataset; Two steps:; 1. For each entry, determine if it should be mirrored (the mirror configuration).; 2. For each mirror configuration, make the mirror points. loadWeightSet() const. calculateShell(RooNDKeysPdf::BoxInfo* bi) const; determine points in +/- nSigma shell around the box determined by the variable; ranges. These points are needed in the normalization, to determine probability; leakage in and out of the box. calculatePreNorm(RooNDKeysPdf::BoxInfo* bi) const; bi->nEventsBMSW=0.;; bi->nEventsBW=0.;. sortDataIndices(RooNDKeysPdf::BoxInfo* bi = 0) const; sort entries, as needed for loopRange(). calculateBandWidth() const. gauss(vector<Double_t>& x, vector<vector<Double_t> >& weights) const; loop over all closest point to x, as determined by loopRange(). loopRange(vector<Double_t>& x, map<Int_t,Bool_t>& ibMap) const; determine closest points to x, to loop over in evaluate(). boxInfoInit(RooNDKeysPdf::BoxInfo* bi, const char* rangeName, Int_t code) const. evaluate() const. getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. analyticalIntegral(Int_t code, const char* rangeName = 0) const. TObject* clone(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNDKeysPdf.html:45570,load,loadWeightSet,45570,root/html528/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html528/RooNDKeysPdf.html,3,['load'],['loadWeightSet']
Performance,"RooKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const char* name, const char* title, RooAbsReal& x, RooAbsReal& y, RooDataSet& data, TString options = ""a"", Double_t rho = 1.0, Double_t nSigma = 3, Bool_t rotate = kTRUE); Backward compatibility constructor for Roo2DKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const RooNDKeysPdf& other, const char* name = 0); Constructor. ~RooNDKeysPdf(). createPdf(Bool_t firstCall = kTRUE) const; evaluation order of constructor. setOptions() const; set the configuration. initialize() const; initialization. loadDataSet(Bool_t firstCall) const; copy the dataset and calculate some useful variables. mirrorDataSet() const; determine mirror dataset.; mirror points are added around the physical boundaries of the dataset; Two steps:; 1. For each entry, determine if it should be mirrored (the mirror configuration).; 2. For each mirror configuration, make the mirror points. loadWeightSet() const. calculateShell(RooNDKeysPdf::BoxInfo* bi) const; determine points in +/- nSigma shell around the box determined by the variable; ranges. These points are needed in the normalization, to determine probability; leakage in and out of the box. calculatePreNorm(RooNDKeysPdf::BoxInfo* bi) const; bi->nEventsBMSW=0.;; bi->nEventsBW=0.;. sortDataIndices(RooNDKeysPdf::BoxInfo* bi = 0) const; sort entries, as needed for loopRange(). calculateBandWidth() const. gauss(vector<Double_t>& x, vector<vector<Double_t> >& weights) const; loop over all closest point to x, as determined by loopRange(). loopRange(vector<Double_t>& x, map<Int_t,Bool_t>& ibMap); determine closest points to x, to loop over in evaluate(). boxInfoInit(RooNDKeysPdf::BoxInfo* bi, const char* rangeName, Int_t code) const. evaluate() const. getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. analyticalIntegral(Int_t code, const char* rangeName = 0) const. TObject* clone(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNDKeysPdf.html:45037,load,loadWeightSet,45037,root/html526/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html526/RooNDKeysPdf.html,1,['load'],['loadWeightSet']
Performance,"RooLinkedList_altBinning!; RooLinTransBinning_binning; set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLinearVar.html:39485,cache,cache,39485,root/html602/RooLinearVar.html,https://root.cern,https://root.cern/root/html602/RooLinearVar.html,6,['cache'],['cache']
Performance,"RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooJeffreysPrior.html:21669,optimiz,optimizeCacheMode,21669,root/html530/RooJeffreysPrior.html,https://root.cern,https://root.cern/root/html530/RooJeffreysPrior.html,4,['optimiz'],['optimizeCacheMode']
Performance,"RooNormalizedPdf.h. ◆ forceAnalyticalInt(). bool RooNormalizedPdf::forceAnalyticalInt ; (; const RooAbsArg & ; ); const. inlineoverridevirtual . Reimplemented from RooAbsReal.; Definition at line 46 of file RooNormalizedPdf.h. ◆ getAnalyticalIntegralWN(). Int_t RooNormalizedPdf::getAnalyticalIntegralWN ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const RooArgSet * ; , . const char * ; rangeName = nullptr . ); const. inlineoverridevirtual . Forward determination of analytical integration capabilities to input p.d.f. ; Reimplemented from RooAbsReal.; Definition at line 48 of file RooNormalizedPdf.h. ◆ getValV(). double RooNormalizedPdf::getValV ; (; const RooArgSet * ; nset); const. inlineoverrideprotectedvirtual . Return current value, normalized by integrating over the observables in nset. ; If nset is 0, the unnormalized value is returned. All elements of nset must be lvalues.; Unnormalized values are not cached. Doing so would be complicated as _norm->getVal() could spoil the cache and interfere with returning the cached return value. Since unnormalized calls are typically done in integration calls, there is no performance hit. ; Reimplemented from RooAbsPdf.; Definition at line 79 of file RooNormalizedPdf.h. ◆ selfNormalized(). bool RooNormalizedPdf::selfNormalized ; (; ); const. inlineoverridevirtual . Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ; Always returns false, unless a PDF overrides this function. ; Reimplemented from RooAbsPdf.; Definition at line 44 of file RooNormalizedPdf.h. ◆ translate(). void RooNormalizedPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNormalizedPdf.html:77110,cache,cache,77110,doc/master/classRooNormalizedPdf.html,https://root.cern,https://root.cern/doc/master/classRooNormalizedPdf.html,2,['cache'],"['cache', 'cached']"
Performance,"RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooListProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooUniform.html:42383,cache,cache,42383,root/html534/RooUniform.html,https://root.cern,https://root.cern/root/html534/RooUniform.html,1,['cache'],['cache']
Performance,"RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedPdf.html:45959,cache,cache,45959,root/html602/RooCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooCachedPdf.html,2,['cache'],['cache']
Performance,"RooPlot * frame(Double_t lo, Double_t hi) const; Create a new RooPlot on the heap with a drawing frame initialized for this; object, but no plot contents. Use x.frame() as the first argument to a; y.plotOn(...) method, for example. The caller is responsible for deleting; the returned object. RooPlot * frame(Int_t nbins); Create a new RooPlot on the heap with a drawing frame initialized for this; object, but no plot contents. Use x.frame() as the first argument to a; y.plotOn(...) method, for example. The caller is responsible for deleting; the returned object. The current fit range may not be open ended or empty. RooPlot * frame() const; Create a new RooPlot on the heap with a drawing frame initialized for this; object, but no plot contents. Use x.frame() as the first argument to a; y.plotOn(...) method, for example. The caller is responsible for deleting; the returned object. The current fit range may not be open ended or empty. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy cache of another RooAbsArg to our cache. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Structure printing. void randomize(const char* rangeName); Set a new value sampled from a uniform distribution over the fit range.; Prints a warning and does nothing if the fit range is not finite. void setBin(Int_t ibin, const char* rangeName); Set value to center of bin 'ibin' of binning 'rangeName' (or of; default binning if no range is specified). void setBin(Int_t ibin, const RooAbsBinning& binning); Set value to center of bin 'ibin' of binning 'binning'. void randomize(const RooAbsBinning& binning); Set a new value sampled from a uniform distribution over the fit range.; Prints a warning and does nothing if the fit range is not finite. void setBinFast(Int_t ibin, const RooAbsBinning& binning); Set value to center of bin 'ibin' of binning 'rangeName' (or of; default binning if no range is specified). Bool_t fitRangeOKForPlo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsRealLValue.html:39704,cache,cache,39704,root/html526/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsRealLValue.html,2,['cache'],['cache']
Performance,"RooRealVar& obs, const RooArgSet& normObs, Int_t order, bool central, bool takeRoot, bool intNormObs); 4035{; 4036 std::string name=Form(""%s_MOMENT_%d%s_%s"",GetName(),order,(central?""C"":""""),obs.GetName()) ;; 4037 std::string title=Form(""%sMoment of order %d of %s w.r.t %s "",(central?""Central "":""""),order,GetName(),obs.GetName()) ;; 4038 ; 4039 if (order==1) return new RooFirstMoment(name.c_str(),title.c_str(),*this,obs,normObs,intNormObs) ;; 4040 if (order==2) return new RooSecondMoment(name.c_str(),title.c_str(),*this,obs,normObs,central,takeRoot,intNormObs) ;; 4041 return new RooMoment(name.c_str(),title.c_str(),*this,obs,normObs,order,central,takeRoot,intNormObs) ;; 4042}; 4043 ; 4044 ; 4045 ; 4046////////////////////////////////////////////////////////////////////////////////; 4047///; 4048/// Return value of x (in range xmin,xmax) at which function equals yval.; 4049/// (Calculation is performed with Brent root finding algorithm); 4050 ; 4051double RooAbsReal::findRoot(RooRealVar& x, double xmin, double xmax, double yval); 4052{; 4053 double result(0) ;; 4054 RooBrentRootFinder(RooRealBinding(*this,x)).findRoot(result,xmin,xmax,yval) ;; 4055 return result ;; 4056}; 4057 ; 4058 ; 4059 ; 4060////////////////////////////////////////////////////////////////////////////////; 4061/// Perform a \f$ \chi^2 \f$ fit to given histogram. By default the fit is executed through the MINUIT; 4062/// commands MIGRAD, HESSE in succession; 4063///; 4064/// The following named arguments are supported; 4065///; 4066/// <table>; 4067/// <tr><th> <th> Options to control construction of chi2; 4068/// <tr><td> `Extended(bool flag)` <td> **Only applicable when fitting a RooAbsPdf**. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight.; 4069/// This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; 4070/// - If you don't pass this command, an extended fit will be done b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:175151,perform,performed,175151,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['perform'],['performed']
Performance,"RooRealVar::setRange(y) new range named 'SIG' created with bounds [0,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'FULL' created with bounds [-10,10]; [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'FULL' created with bounds [-10,10]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData' created with bounds [-10,10]; [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'fit_nll_model_modelData' created with bounds [-10,0]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_SB1' created with bounds [-10,10]; [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'fit_nll_model_modelData_SB1' created with bounds [-10,0]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_SB2' created with bounds [-10,0]; [#1] INFO:Eval -- RooRealVar::setRange(y) new range named 'fit_nll_model_modelData_SB2' created with bounds [0,10]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coeffic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf312__multirangefit_8C.html:6440,optimiz,optimization,6440,doc/master/rf312__multirangefit_8C.html,https://root.cern,https://root.cern/doc/master/rf312__multirangefit_8C.html,2,['optimiz'],['optimization']
Performance,RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; RooRealProxy_delMistag; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolut,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBCPGenDecay.html:38211,cache,cache,38211,root/html526/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html526/RooBCPGenDecay.html,4,['cache'],['cache']
Performance,RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; RooRealProxy_delMistag; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genFlavFrac!; Double_t_genFlavFracMix!; Double_t_genFlavFracUnmix!; Double_t_genMixFrac! do not persist; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum n,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBMixDecay.html:38194,cache,cache,38194,root/html526/RooBMixDecay.html,https://root.cern,https://root.cern/root/html526/RooBMixDecay.html,4,['cache'],['cache']
Performance,RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_errorSymmetric error associated with current value; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; static RooRealVarSharedProperties_nullPropNull property; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; static Bool_t_printScientific; static Int_t_printSigDigits; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooRealVarSharedProperties*_sharedProp! Shared properties as,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealVar.html:36684,cache,cache,36684,root/html526/RooRealVar.html,https://root.cern,https://root.cern/root/html526/RooRealVar.html,2,['cache'],['cache']
Performance,RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_errorSymmetric error associated with current value; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; static RooRealVarSharedProperties_nullPropNull property; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; static Bool_t_printScientific; static Int_t_printSigDigits; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealVar.html:37351,cache,cache,37351,root/html530/RooRealVar.html,https://root.cern,https://root.cern/root/html530/RooRealVar.html,1,['cache'],['cache']
Performance,"RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooNumRunningInt::funcProxy to functions whose running integral is calculated; RooRealProxyRooNumRunningInt::xIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumCdf(const char* name, const char* title, RooAbsPdf& _pdf, RooRealVar& _x, const char* binningName = ""cache""); Construct a cumulative distribution function from given input p.d.f over observable x.; using a numeric sampling algorithm. Use binning named 'bname' to control sampling; granularity. RooNumCdf(const RooNumCdf& other, const char* name = 0); Copy constructor. ~RooNumCdf(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill cache using running integral cache elements calculate(); method with specification of cdf-specific boundary conditions. TObject* clone(const char* newname) const; { return new RooNumCdf(*this,newname); }. » Last changed: Tue Jun 30 14:34:32 2015 » Last generated: 2015-06-30 14:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumCdf.html:39048,cache,cache,39048,root/html602/RooNumCdf.html,https://root.cern,https://root.cern/root/html602/RooNumCdf.html,4,['cache'],"['cache', 'cacheFunc']"
Performance,"SE) *; 27 **********************************************************************************/; 28 ; 29 ; 30/*! \class TMVA::DataLoader; 31\ingroup TMVA; 32 ; 33*/; 34 ; 35#include ""TTree.h""; 36#include ""TH2.h""; 37#include ""TMatrixD.h""; 38 ; 39#include ""TMVA/DataLoader.h""; 40#include ""TMVA/Config.h""; 41#include ""TMVA/CvSplit.h""; 42#include ""TMVA/Tools.h""; 43#include ""TMVA/IMethod.h""; 44#include ""TMVA/MethodBase.h""; 45#include ""TMVA/DataInputHandler.h""; 46#include ""TMVA/DataSetManager.h""; 47#include ""TMVA/DataSetInfo.h""; 48#include ""TMVA/MethodBoost.h""; 49#include ""TMVA/MethodCategory.h""; 50 ; 51#include ""TMVA/VariableInfo.h""; 52#include ""TMVA/VariableIdentityTransform.h""; 53#include ""TMVA/VariableDecorrTransform.h""; 54#include ""TMVA/VariablePCATransform.h""; 55#include ""TMVA/VariableGaussTransform.h""; 56#include ""TMVA/VariableNormalizeTransform.h""; 57#include ""TMVA/VarTransformHandler.h""; 58 ; 59ClassImp(TMVA::DataLoader);; 60 ; 61////////////////////////////////////////////////////////////////////////////////; 62/*** Create a data loader; 63 \param[in] thedlName name of DataLoader object. This name will be used as the; 64 top directory name where the training results; 65 (weights, i.e .XML and .C files) will be stored.; 66 The results will be stored by default in the `theDlName/weights`; 67 directory and relative to the current directory. If the directory is not existing,; 68 a new one will be created automatically.; 69 For using a different location (i.e. a different path to the current directory) one; 70 can set an absolute path location in `TMVA::gConfig()::GetIONames().fWeightFileDirPrefix`; 71 For example, by setting; 72~~~~~~~~~~~~~~~{.cpp}; 73 TMVA::gConfig()::GetIONames().fWeightFileDirPrefix = ""/tmp"";; 74 TMVA::gConfig()::GetIONames().fWeightFileDir = ""myTrainingResults"";; 75~~~~~~~~~~~~~~~; 76 The training results will be stored in the `/tmp/thedlName/myTrainingResults`; 77 directory.; 78**/; 79 ; 80TMVA::DataLoader::DataLoader( TString thedlName); 81: Conf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataLoader_8cxx_source.html:2194,load,loader,2194,doc/master/DataLoader_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataLoader_8cxx_source.html,1,['load'],['loader']
Performance,"SE, Bool_t isRecursionStep = kFALSE); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidregisterCache(RooAbsCache& cache); voidremoveServer(RooAbsArg& server, Bool_t force = kFALSE); voidreplaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*serverIterator() const; virtual voidserverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidsetACleanADirty(Bool_t flag); voidsetAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidsetExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidsetOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetProhibitServerRedirect(Bool_t flag); voidsetShapeDirty() const; voidsetStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidsetTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetValueDirty() const; TIterator*shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsArg.html:12309,cache,cache,12309,root/html530/RooAbsArg.html,https://root.cern,https://root.cern/root/html530/RooAbsArg.html,1,['cache'],['cache']
Performance,"SECANT; kGSL_STEFFENSON; };. private:. ROOT::Math::IRootFinderMethod*fSolvertype of algorithm to be used . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; int Solve(Function f, Derivative d, double start, int maxIter, double absTol, double relTol). RootFinder(RootFinder::EType type = RootFinder::kBRENT). Construct a Root-Finder algorithm. virtual ~RootFinder(). RootFinder(const RootFinder & ); usually copying is non trivial, so we make this unaccessible. {}. int SetMethod(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT). int SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). Provide to the solver the function and the initial search interval [xlow, xup]; for algorithms not using derivatives (bracketing algorithms); The templated function f must be of a type implementing the \a operator() method,; <em> double operator() ( double x ) </em>; Returns non zero if interval is not valid (i.e. does not contains a root). return fSolver-> SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). int Iterations() const. Return the number of iteration performed to find the Root. int Iterate(). Perform a single iteration and return the Status. double Root() const. Return the current and latest estimate of the Root. const char * Name() const. Return the current and latest estimate of the lower value of the Root-finding interval (for bracketing algorithms). double XLower() const {; return fSolver->XLower();; }. Return the current and latest estimate of the upper value of the Root-finding interval (for bracketing algorithms). double XUpper() const {; return fSolver->XUpper();; }. Get Name of the Root-finding solver algorithm. » Last changed: root/mathmore:$Id: RootFinder.h 25486 2008-09-22 12:43:03Z moneta $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__RootFinder.html:2716,perform,performed,2716,root/html526/ROOT__Math__RootFinder.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__RootFinder.html,1,['perform'],['performed']
Performance,"SHtmlStyle_t TGHtml::GetCurrentStyle ; (; ). protected . Get the current rendering style. ; In other words, get the style that is currently on the top of the style stack. ; Definition at line 41 of file TGHtmlSizer.cxx. ◆ GetDarkShadowColor(). int TGHtml::GetDarkShadowColor ; (; int ; iBgColor). protected . Given that the background color is iBgColor, figure out an appropriate color for the dark part of a 3D shadow. ; Definition at line 1692 of file TGHtml.cxx. ◆ GetFont(). TGFont * TGHtml::GetFont ; (; int ; iFont). virtual . The rendering and layout routines should call this routine in order to get a font structure. ; The iFont parameter specifies which of the N_FONT fonts should be obtained. The font is allocated if necessary. ; Definition at line 1465 of file TGHtml.cxx. ◆ GetFontName(). virtual char * TGHtml::GetFontName ; (; ). inlinevirtual . Definition at line 954 of file TGHtml.h. ◆ GetGC(). GContext_t TGHtml::GetGC ; (; int ; color, . int ; font . ). protected . Return a GC from the cache. ; As many as N_CACHE_GCs are kept valid at any one time. They are replaced using an LRU algorithm.; A value of FONT_Any (-1) for the font means ""don't care"". ; Definition at line 1047 of file TGHtml.cxx. ◆ GetHref(). const char * TGHtml::GetHref ; (; int ; x, . int ; y, . const char ** ; target = nullptr . ). This routine searches for a hyperlink beneath the coordinates x,y and returns a pointer to the HREF for that hyperlink. ; The text is held in one of the markup argv[] fields of the markup. ; Definition at line 1831 of file TGHtml.cxx. ◆ GetImage(). TGHtmlImage * TGHtml::GetImage ; (; TGHtmlImageMarkup * ; p). Given an <IMG> markup, find or create an appropriate TGHtmlImage object and return a pointer to that object. ; NULL might be returned. ; Definition at line 162 of file TGHtmlImage.cxx. ◆ GetImageAlignment(). int TGHtml::GetImageAlignment ; (; TGHtmlElement * ; p). protected . Find the alignment for an image. ; Definition at line 84 of file TGHtmlImage.cxx. ◆ Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:66652,cache,cache,66652,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['cache'],['cache']
Performance,SL random number generators For this we need to implement functions which will be called by gsl_rng. More...;  ; class  GSLRngTaus;  Tausworthe generator by L'Ecuyer see here More...;  ; class  GSLRngWrapper;  GSLRngWrapper class to wrap gsl_rng structure. More...;  ; class  GSLRootFdFSolver;  Root-Finder with derivatives implementation class using GSL. More...;  ; class  GSLRootFinder;  Base class for GSL Root-Finding algorithms for one dimensional functions which do not use function derivatives. More...;  ; class  GSLRootFinderDeriv;  Base class for GSL Root-Finding algorithms for one dimensional functions which use function derivatives. More...;  ; class  GSLRootFSolver;  Root-Finder implementation class using GSL. More...;  ; class  GSLSimAnFunc;  GSLSimAnFunc class description. More...;  ; class  GSLSimAnMinimizer;  GSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL. More...;  ; class  GSLSimAnnealing;  GSLSimAnnealing class for performing a simulated annealing search of a multidimensional function. More...;  ; struct  GSLSimAnParams;  structure holding the simulated annealing parameters More...;  ; class  GSLVegasIntegrationWorkspace;  workspace for VEGAS More...;  ; class  IBaseFunctionMultiDimTempl;  Documentation for the abstract class IBaseFunctionMultiDim. More...;  ; class  IBaseFunctionOneDim;  Interface (abstract class) for generic functions objects of one-dimension Provides a method to evaluate the function given a value (simple double) by implementing operator() (const double ). More...;  ; class  IBaseParam;  Documentation for the abstract class IBaseParam. More...;  ; class  IGradientFunctionMultiDimTempl;  Interface (abstract class) for multi-dimensional functions providing a gradient calculation. More...;  ; class  IGradientFunctionOneDim;  Interface (abstract class) for one-dimensional functions providing a gradient calculation. More...;  ; class  IGradientMultiDimTempl;  ; class  IMinimizer1D;  Interf,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:15950,perform,performing,15950,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['perform'],['performing']
Performance,"SON, TBufferSQL2, TBufferXML, TBufferSQL, and TBufferFile. ◆ WriteFloat(). virtual void TBuffer::WriteFloat ; (; Float_t ; f). pure virtual . Implemented in TBufferJSON, TBufferSQL2, TBufferXML, TBufferSQL, and TBufferFile. ◆ WriteFloat16(). virtual void TBuffer::WriteFloat16 ; (; Float_t * ; f, . TStreamerElement * ; ele = nullptr . ). pure virtual . Implemented in TBufferText, and TBufferFile. ◆ WriteInt(). virtual void TBuffer::WriteInt ; (; Int_t ; i). pure virtual . Implemented in TBufferJSON, TBufferSQL2, TBufferXML, TBufferSQL, and TBufferFile. ◆ WriteLong(). virtual void TBuffer::WriteLong ; (; Long_t ; l). pure virtual . Implemented in TBufferJSON, TBufferSQL2, TBufferXML, TBufferSQL, and TBufferFile. ◆ WriteLong64(). virtual void TBuffer::WriteLong64 ; (; Long64_t ; l). pure virtual . Implemented in TBufferJSON, TBufferSQL2, TBufferXML, TBufferSQL, and TBufferFile. ◆ WriteObject() [1/2]. template<class T > . Int_t TBuffer::WriteObject ; (; const T * ; objptr, . Bool_t ; cacheReuse = kTRUE . ). inline . Definition at line 405 of file TBuffer.h. ◆ WriteObject() [2/2]. virtual void TBuffer::WriteObject ; (; const TObject * ; obj, . Bool_t ; cacheReuse . ). pure virtual . Implemented in TBufferIO, and TBufferIO. ◆ WriteObjectAny(). virtual Int_t TBuffer::WriteObjectAny ; (; const void * ; obj, . const TClass * ; ptrClass, . Bool_t ; cacheReuse = kTRUE . ). pure virtual . Implemented in TBufferIO. ◆ WriteProcessID(). UShort_t TBuffer::WriteProcessID ; (; TProcessID * ; pid). pure virtual . Always return 0 (current processID). ; Implemented in TBufferIO, and TMessage.; Definition at line 353 of file TBuffer.cxx. ◆ WriteShort(). virtual void TBuffer::WriteShort ; (; Short_t ; s). pure virtual . Implemented in TBufferJSON, TBufferSQL2, TBufferXML, TBufferSQL, and TBufferFile. ◆ WriteStdString() [1/2]. virtual void TBuffer::WriteStdString ; (; const std::string * ; s). pure virtual . Implemented in TBufferJSON, TBufferSQL2, TBufferXML, TBufferSQL, TBufferFile, TBuf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer.html:69393,cache,cacheReuse,69393,doc/master/classTBuffer.html,https://root.cern,https://root.cern/doc/master/classTBuffer.html,1,['cache'],['cacheReuse']
Performance,"SON. void * ReadObjectAny(const TClass* clCast); Read object from buffer. Only used from TBuffer. void SkipObjectAny(); Skip any kind of object from buffer. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); read a Float16_t from the buffer. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); read a Double32_t from the buffer. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferJSON does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferJSON.html:27765,optimiz,optimize,27765,root/html534/TBufferJSON.html,https://root.cern,https://root.cern/root/html534/TBufferJSON.html,3,['optimiz'],['optimize']
Performance,"SQLFile, TXMLFile, TDavixFile, TXNetFile, TDCacheFile, TNetFile, TWebFile, and TNetXNGFile.; Definition at line 1720 of file TFile.cxx. ◆ ReadBufferAsync(). Bool_t TFile::ReadBufferAsync ; (; Long64_t ; offs, . Int_t ; len . ). virtual . Reimplemented in TDavixFile, and TXNetFile.; Definition at line 5208 of file TFile.cxx. ◆ ReadBuffers(). Bool_t TFile::ReadBuffers ; (; char * ; buf, . Long64_t * ; pos, . Int_t * ; len, . Int_t ; nbuf . ). virtual . Read the nbuf blocks described in arrays pos and len. ; The value pos[i] is the seek position of block i of length len[i]. Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer. This function is overloaded by TNetFile, TWebFile, etc. Returns kTRUE in case of failure. ; Reimplemented in TDavixFile, TXNetFile, TDCacheFile, TNetFile, TS3WebFile, TWebFile, and TNetXNGFile.; Definition at line 1821 of file TFile.cxx. ◆ ReadBufferViaCache(). Int_t TFile::ReadBufferViaCache ; (; char * ; buf, . Int_t ; len . ). protected . Read buffer via cache. ; Returns 0 if the requested block is not in the cache, 1 in case read via cache was successful, 2 in case read via cache failed. ; Definition at line 1889 of file TFile.cxx. ◆ ReadFree(). void TFile::ReadFree ; (; ). virtual . Read the FREE linked list. ; Every file has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 1925 of file TFile.cxx. ◆ ReadProcessID(). TProcessID * TFile::ReadProcessID ; (; UShort_t ; pidf). virtual . The TProcessID with number pidf is read from this file. ; If the object is not already entered in the gROOT list, it is added. ; Definition at line 1951 of file TFile.cxx. ◆ ReadStreamerInfo(). void TFile::ReadStreamerInfo ; (; ). virtual . Read the list of StreamerInfo from this file. ; The key with name holding the list of TStreamerInfo objects is read. The corresponding TClass objects are updated. Note that this",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:87570,cache,cache,87570,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,1,['cache'],['cache']
Performance,"SSUrl () const;  ; const char * GetStageOpts () const;  ; TClass * IsA () const override;  ; Int_t NotifyUpdate (const char *group, const char *user, const char *dspath, Long_t mtime, const char *checksum=0) override;  Save into the <datasetdir>/kDataSet_DataSetList file the name of the updated or created or modified dataset. ;  ; void ParseInitOpts (const char *opts) override;  Parse the input string and set the init bits accordingly Format is dir:<datasetdir> [mss:<mss-url>] [opt:<base-options>] The <datasetdir> is mandatory. ;  ; Int_t RegisterDataSet (const char *uri, TFileCollection *dataSet, const char *opt) override;  Register a dataset, perfoming quota checkings and verification, if required. ;  ; Bool_t RemoveDataSet (const char *uri) override;  Removes the indicated dataset. ;  ; Int_t ScanDataSet (const char *uri, UInt_t option=kReopen|kDebug) override;  Scans the dataset indicated by <uri> and returns the number of missing files. ;  ; Int_t ShowCache (const char *uri=0) override;  Show cached information matching uri. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t WriteDataSet (const char *group, const char *user, const char *dsName, TFileCollection *dataset, UInt_t option=0, TMD5 *checksum=0);  Writes indicated dataset. ;  ;  Public Member Functions inherited from TDataSetManager;  TDataSetManager (const char *group=0, const char *user=0, const char *options=0);  Main constructor. ;  ;  ~TDataSetManager () override;  Destructor. ;  ; virtual Long64_t GetAvgFileSize () const;  ; virtual Long64_t GetGroupQuota (const char *group);  returns the quota a group is allowed to have ;  ; virtual TMap * GetGroupQuotaMap ();  ; virtual Long64_t GetGroupUsed (const char *group);  Returns the used space of that group. ;  ; virtual TMap * GetSubDataSets (const char *uri, const char *excludeservers);  Partition dataset 'ds' accordingly to the servers. ;  ; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManagerFile.html:2618,cache,cached,2618,doc/master/classTDataSetManagerFile.html,https://root.cern,https://root.cern/doc/master/classTDataSetManagerFile.html,1,['cache'],['cached']
Performance,"STL type. The concrete types are optimized; 36for element access.; 37*/; 38 ; 39class TGenVectorProxy : public TGenCollectionProxy {; 40public:; 41 // Standard Destructor; 42 TGenVectorProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c); 43 {; 44 }; 45 // Standard Destructor; 46 ~TGenVectorProxy() override; 47 {; 48 }; 49 // Return the address of the value at index 'idx'; 50 void* At(UInt_t idx) override; 51 {; 52 if ( fEnv && fEnv->fObject ) {; 53 fEnv->fIdx = idx;; 54 switch( idx ) {; 55 case 0:; 56 return fEnv->fStart = fFirst.invoke(fEnv);; 57 default:; 58 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 59 return ((char*)fEnv->fStart) + fValDiff*idx;; 60 }; 61 }; 62 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 63 return nullptr;; 64 }; 65 // Call to delete/destruct individual item; 66 void DeleteItem(Bool_t force, void* ptr) const override; 67 {; 68 if ( force && ptr ) {; 69 if ( fVal->fProperties&kNeedDelete) {; 70 TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionProxy();; 71 TPushPop helper(proxy,ptr);; 72 proxy->Clear(""force"");; 73 }; 74 fVal->DeleteItem(ptr);; 75 }; 76 }; 77};; 78 ; 79/**; 80\class TGenVectorBoolProxy; 81\ingroup IO; 82Local optimization class.; 83 ; 84Collection proxies get copied. On copy we switch the type of the; 85proxy to the concrete STL type. The concrete types are optimized; 86for element access.; 87*/; 88class TGenVectorBoolProxy : public TGenCollectionProxy {; 89 Bool_t fLastValue;; 90 ; 91public:; 92 TGenVectorBoolProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c), fLastValue(false); 93 {; 94 // Standard Constructor.; 95 }; 96 ~TGenVectorBoolProxy() override; 97 {; 98 // Standard Destructor.; 99 }; 100 void* At(UInt_t idx) override; 101 {; 102 // Return the address of the value at index 'idx'; 103 ; 104 // However we can 'take' the address of the content of std::vector<bool>.; 105 if ( fEnv && fEnv->fObject ) {; 106 auto vec = (std::vector<bool> *)(fEnv->fObject);; 107",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:2491,optimiz,optimization,2491,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['optimiz'],['optimization']
Performance,"STLbitset: // not really an associate container but it has no real iterator.; 874 fProperties |= kIsAssociative;; 875 if (num > 3 && !inside[3].empty()) {; 876 if (! TClassEdit::IsDefAlloc(inside[3].c_str(),inside[0].c_str())) {; 877 fProperties |= kCustomAlloc;; 878 }; 879 }; 880 break;; 881 };; 882 ; 883 int slong = sizeof(void*);; 884 switch ( fSTL_type ) {; 885 case ROOT::kSTLmap:; 886 case ROOT::kSTLunorderedmap:; 887 case ROOT::kSTLmultimap:; 888 case ROOT::kSTLunorderedmultimap:; 889 nam = ""pair<""+inside[1]+"",""+inside[2];; 890 nam += (nam[nam.length()-1]=='>') ? "" >"" : "">"";; 891 ; 892 fVal = R__CreateValue(inside[2], silent);; 893 fKey = R__CreateValue(inside[1], silent);; 894 ; 895 {; 896 TInterpreter::SuspendAutoParsing autoParseRaii(gCling);; 897 TClass *paircl = TClass::GetClass(nam.c_str(), true, false, fValOffset, fValDiff);; 898 if (paircl == nullptr) {; 899 // We need to emulate the pair; 900 auto info = TVirtualStreamerInfo::Factory()->GenerateInfoForPair(inside[1], inside[2], silent, fValOffset, fValDiff);; 901 if (!info) {; 902 Fatal(""InitializeEx"",; 903 ""Could not load nor generate the dictionary for \""%s\"", some element might be missing their dictionary (eg. enums)"",; 904 nam.c_str());; 905 }; 906 } else {; 907 if ((!paircl->IsSyntheticPair() && paircl->GetState() < TClass::kInterpreted) || paircl->GetClassSize() != fValDiff) {; 908 if (paircl->GetState() >= TClass::kInterpreted); 909 Fatal(""InitializeEx"",; 910 ""The %s for %s reports a class size that is inconsistent with the one registered ""; 911 ""through the CollectionProxy for %s: %d vs %d\n"",; 912 paircl->IsLoaded() ? ""dictionary"" : ""interpreter information for"", nam.c_str(),; 913 cl->GetName(), (int)paircl->GetClassSize(), (int)fValDiff);; 914 else {; 915 gROOT->GetListOfClasses()->Remove(paircl);; 916 TClass *newpaircl = TClass::GetClass(nam.c_str(), true, false, fValOffset, fValDiff);; 917 if (!newpaircl || newpaircl == paircl || newpaircl->GetClassSize() != fValDiff); 918 Fatal(""Initialize",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:28568,load,load,28568,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance,"STLmap || fSTL_type == ROOT::kSTLmultimap ||; 1032 fSTL_type == ROOT::kSTLunorderedmap || fSTL_type == ROOT::kSTLunorderedmultimap);; 1033}; 1034 ; 1035////////////////////////////////////////////////////////////////////////////////; 1036/// Return a pointer to the TClass representing the content.; 1037 ; 1038TClass *TGenCollectionProxy::GetValueClass() const; 1039{; 1040 auto value = fValue.load(std::memory_order_relaxed);; 1041 if (!value) {; 1042 Initialize(kFALSE);; 1043 value = fValue.load(std::memory_order_relaxed);; 1044 }; 1045 return value ? (*value).fType.GetClass() : 0;; 1046}; 1047 ; 1048////////////////////////////////////////////////////////////////////////////////; 1049/// If the content is a simple numerical value, return its type (see TDataType); 1050 ; 1051EDataType TGenCollectionProxy::GetType() const; 1052{; 1053 auto value = fValue.load(std::memory_order_relaxed);; 1054 if (!value) {; 1055 Initialize(kFALSE);; 1056 value = fValue.load(std::memory_order_relaxed);; 1057 }; 1058 return value ? (*value).fKind : kNoType_t;; 1059}; 1060 ; 1061////////////////////////////////////////////////////////////////////////////////; 1062/// Return the address of the value at index 'idx'; 1063 ; 1064void* TGenCollectionProxy::At(UInt_t idx); 1065{; 1066 if ( fEnv && fEnv->fObject ) {; 1067 switch (fSTL_type) {; 1068 case ROOT::kSTLvector:; 1069 if ((*fValue).fKind == kBool_t) {; 1070 auto vec = (std::vector<bool> *)(fEnv->fObject);; 1071 fEnv->fLastValueVecBool = (*vec)[idx];; 1072 fEnv->fIdx = idx;; 1073 return &(fEnv->fLastValueVecBool);; 1074 }; 1075 // intentional fall through; 1076 case ROOT::kROOTRVec:; 1077 fEnv->fIdx = idx;; 1078 switch( idx ) {; 1079 case 0:; 1080 return fEnv->fStart = fFirst.invoke(fEnv);; 1081 default:; 1082 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 1083 return ((char*)fEnv->fStart) + fValDiff*idx;; 1084 }; 1085 case ROOT::kSTLbitset: {; 1086 switch (idx) {; 1087 case 0:; 1088 fEnv->fStart = fFirst.invoke(fEnv);; 1089 f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:34447,load,load,34447,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance,"ST]); 16662 != 1) {; 16663 mg_cry_ctx_internal(phys_ctx,; 16664 ""SSL_CTX_set_cipher_list error: %s"",; 16665 ssl_error());; 16666 }; 16667 }; 16668 ; 16669 /* SSL session caching */; 16670 ssl_cache_timeout = ((dom_ctx->config[SSL_CACHE_TIMEOUT] != NULL); 16671 ? atoi(dom_ctx->config[SSL_CACHE_TIMEOUT]); 16672 : 0);; 16673 if (ssl_cache_timeout > 0) {; 16674 SSL_CTX_set_session_cache_mode(dom_ctx->ssl_ctx, SSL_SESS_CACHE_BOTH);; 16675 /* SSL_CTX_sess_set_cache_size(dom_ctx->ssl_ctx, 10000); ... use; 16676 * default */; 16677 SSL_CTX_set_timeout(dom_ctx->ssl_ctx, (long)ssl_cache_timeout);; 16678 }; 16679 ; 16680#if defined(USE_ALPN); 16681 /* Initialize ALPN only of TLS library (OpenSSL version) supports ALPN */; 16682#if !defined(NO_SSL_DL); 16683 if (!tls_feature_missing[TLS_ALPN]); 16684#endif; 16685 {; 16686 init_alpn(phys_ctx, dom_ctx);; 16687 }; 16688#endif; 16689 ; 16690 return 1;; 16691}; 16692 ; 16693 ; 16694/* Check if SSL is required.; 16695 * If so, dynamically load SSL library; 16696 * and set up ctx->ssl_ctx pointer. */; 16697static int; 16698init_ssl_ctx(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx); 16699{; 16700 void *ssl_ctx = 0;; 16701 int callback_ret;; 16702 const char *pem;; 16703 const char *chain;; 16704 char ebuf[128];; 16705 ; 16706 if (!phys_ctx) {; 16707 return 0;; 16708 }; 16709 ; 16710 if (!dom_ctx) {; 16711 dom_ctx = &(phys_ctx->dd);; 16712 }; 16713 ; 16714 if (!is_ssl_port_used(dom_ctx->config[LISTENING_PORTS])) {; 16715 /* No SSL port is set. No need to setup SSL. */; 16716 return 1;; 16717 }; 16718 ; 16719 /* Check for external SSL_CTX */; 16720 callback_ret =; 16721 (phys_ctx->callbacks.external_ssl_ctx == NULL); 16722 ? 0; 16723 : (phys_ctx->callbacks.external_ssl_ctx(&ssl_ctx,; 16724 phys_ctx->user_data));; 16725 ; 16726 if (callback_ret < 0) {; 16727 /* Callback exists and returns <0: Initializing failed. */; 16728 mg_cry_ctx_internal(phys_ctx,; 16729 ""external_ssl_ctx callback returned error: %i"",; 16730 callback",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:495291,load,load,495291,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['load'],['load']
Performance,"ST]); 16663 != 1) {; 16664 mg_cry_ctx_internal(phys_ctx,; 16665 ""SSL_CTX_set_cipher_list error: %s"",; 16666 ssl_error());; 16667 }; 16668 }; 16669 ; 16670 /* SSL session caching */; 16671 ssl_cache_timeout = ((dom_ctx->config[SSL_CACHE_TIMEOUT] != NULL); 16672 ? atoi(dom_ctx->config[SSL_CACHE_TIMEOUT]); 16673 : 0);; 16674 if (ssl_cache_timeout > 0) {; 16675 SSL_CTX_set_session_cache_mode(dom_ctx->ssl_ctx, SSL_SESS_CACHE_BOTH);; 16676 /* SSL_CTX_sess_set_cache_size(dom_ctx->ssl_ctx, 10000); ... use; 16677 * default */; 16678 SSL_CTX_set_timeout(dom_ctx->ssl_ctx, (long)ssl_cache_timeout);; 16679 }; 16680 ; 16681#if defined(USE_ALPN); 16682 /* Initialize ALPN only of TLS library (OpenSSL version) supports ALPN */; 16683#if !defined(NO_SSL_DL); 16684 if (!tls_feature_missing[TLS_ALPN]); 16685#endif; 16686 {; 16687 init_alpn(phys_ctx, dom_ctx);; 16688 }; 16689#endif; 16690 ; 16691 return 1;; 16692}; 16693 ; 16694 ; 16695/* Check if SSL is required.; 16696 * If so, dynamically load SSL library; 16697 * and set up ctx->ssl_ctx pointer. */; 16698static int; 16699init_ssl_ctx(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx); 16700{; 16701 void *ssl_ctx = 0;; 16702 int callback_ret;; 16703 const char *pem;; 16704 const char *chain;; 16705 char ebuf[128];; 16706 ; 16707 if (!phys_ctx) {; 16708 return 0;; 16709 }; 16710 ; 16711 if (!dom_ctx) {; 16712 dom_ctx = &(phys_ctx->dd);; 16713 }; 16714 ; 16715 if (!is_ssl_port_used(dom_ctx->config[LISTENING_PORTS])) {; 16716 /* No SSL port is set. No need to setup SSL. */; 16717 return 1;; 16718 }; 16719 ; 16720 /* Check for external SSL_CTX */; 16721 callback_ret =; 16722 (phys_ctx->callbacks.external_ssl_ctx == NULL); 16723 ? 0; 16724 : (phys_ctx->callbacks.external_ssl_ctx(&ssl_ctx,; 16725 phys_ctx->user_data));; 16726 ; 16727 if (callback_ret < 0) {; 16728 /* Callback exists and returns <0: Initializing failed. */; 16729 mg_cry_ctx_internal(phys_ctx,; 16730 ""external_ssl_ctx callback returned error: %i"",; 16731 callback",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:495324,load,load,495324,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['load'],['load']
Performance,"SVector2> (0,1);; // return a slice of the second column from; // (0,1): c2[0] = m(0,1); c2[1] = m(1,1); SVector2 c2 = m.SubCol<SVector2> (1,0);. // return a sub-matrix 2x2 with the upper left corner at(1,1); SMatrix22 subM = m.Sub<SMatrix22> (1,1);. // return the diagonal element in a SVector; SVector3 diag = m.Diagonal();. // return the upper(lower) block of the matrix m; SVector6 vub = m.UpperBlock(); // vub = [ 1, 2, 3, 5, 6, 9 ]; SVector6 vlb = m.LowerBlock(); // vlb = [ 1, 4, 5, 7, 8, 9 ]; 13.13.2.3 Linear Algebra Matrix Functions (Inversion, Determinant); Only limited linear algebra functionality is available for SMatrix. It is possible for squared matrices NxN, to find the inverse or to calculate the determinant. Different inversion algorithms are used if the matrix is smaller than 6x6 or if it is symmetric. In the case of a small matrix, a faster direct inversion is used. For a large (N>6)symmetric matrix the Bunch-Kaufman diagonal pivoting method is used while for a large (N>6) general matrix an LU factorization is performed using the same algorithm as in the CERNLIB routine dinv.; // Invert a NxN matrix.; // The inverted matrix replaces the existing one if the; // result is successful; bool ret = m.Invert(); // return the inverse matrix of m. // If the inversion fails ifail is different than zero ???; int ifail = 0;; ifail = m.Inverse(ifail);. // determinant of a square matrix - calculate the determinant; // modyfing the matrix content and returns it if the calculation; // was successful; double det;; bool ret = m.Det(det);. // calculate determinant by using a temporary matrix; preserves; // matrix content; bool ret = n.Det2(det);; 13.13.3 Example: Matrix and Vector Functions and Operators; 13.13.3.1 Matrix and Vector Operators; The ROOT::Math::SVector and ROOT::Math::SMatrix classes define the following operators described below. The m1, m2, m3 are vectors or matrices of the same type (and size) and a is a scalar value:; m1 == m2 // returns whether m1 is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:760721,perform,performed,760721,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performed']
Performance,"SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); virtual voidsetBin(Int_t ibin, const RooAbsBinning& binning); virtual voidsetBinFast(Int_t ibin, const RooAbsBinning& binning); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); virtual voidsetVal(Double_t value); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsRealLValue.html:25858,cache,cache,25858,root/html526/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsRealLValue.html,1,['cache'],['cache']
Performance,"SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsCachedPdf::setInterpolationOrder(Int_t order); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedPdf.html:29778,cache,cache,29778,root/html534/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedPdf.html,6,['cache'],['cache']
Performance,"SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooSimultaneous::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__HistFactorySimultaneous.html:30786,cache,cache,30786,root/html534/RooStats__HistFactory__HistFactorySimultaneous.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__HistFactorySimultaneous.html,3,['cache'],['cache']
Performance,"Scalar ROOT::Math::DisplacementVector2D< CoordSystem, Tag >::Dot ; (; const DisplacementVector2D< OtherCoords, OtherTag > & ; ); const. private . ◆ Dot() [2/3]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherCoords > . Scalar ROOT::Math::DisplacementVector2D< CoordSystem, Tag >::Dot ; (; const DisplacementVector2D< OtherCoords, Tag > & ; v); const. inline . Return the scalar (dot) product of two displacement vectors. ; It is possible to perform the product for any type of vector coordinates, but they must have the same coordinate system tag ; Definition at line 289 of file DisplacementVector2D.h. ◆ Dot() [3/3]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherVector > . Scalar ROOT::Math::DisplacementVector2D< CoordSystem, Tag >::Dot ; (; const OtherVector & ; v); const. inline . Return the scalar (dot) product of two vectors. ; It is possible to perform the product for any classes implementing x() and y() member functions ; Definition at line 298 of file DisplacementVector2D.h. ◆ GetCoordinates(). template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . void ROOT::Math::DisplacementVector2D< CoordSystem, Tag >::GetCoordinates ; (; Scalar & ; a, . Scalar & ; b . ); const. inline . get internal data into 2 Scalar numbers. ; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector ; Definition at line 170 of file DisplacementVector2D.h. ◆ Mag2(). template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . Scalar ROOT::Math::DisplacementVector2D< CoordSystem, Tag >::Mag2 ; (; ); const. inline . Magnitute squared ( r^2 in spherical coordinate) ; Definition at line 231 of file DisplacementVector2D.h. ◆ mag2(). template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . Scalar ROOT::Math::DisplacementVector2D< CoordSystem, Tag >::mag2 ; (; ); const. inline . Definition at line 388 of file DisplacementVector2D.h. ◆ operator!=(). t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1DisplacementVector2D.html:12911,perform,perform,12911,doc/master/classROOT_1_1Math_1_1DisplacementVector2D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1DisplacementVector2D.html,1,['perform'],['perform']
Performance,"Scalar aj = s1 * fAxis.Y();; 157 const Scalar ak = s1 * fAxis.Z();; 158 Scalar c = rz.CosAngle();; 159 if ( c > 1 ) c = 1;; 160 if ( c < -1 ) c = -1;; 161 Scalar qu = std::sqrt( .5*(1+c) );; 162 Scalar qk = std::sqrt( .5*(1-c) );; 163 if ( rz.SinAngle() < 0 ) qk = -qk;; 164 Scalar aqu = au*qu - ak*qk;; 165 Scalar aqi = ai*qu + aj*qk;; 166 Scalar aqj = aj*qu - ai*qk;; 167 Scalar aqk = ak*qu + au*qk;; 168 Scalar r = std::sqrt(aqi*aqi + aqj*aqj + aqk*aqk);; 169 if (r > 1) r = 1;; 170 if (aqu < 0) { aqu = - aqu; aqi = - aqi; aqj = - aqj, aqk = - aqk; }; 171 const Scalar angle = 2*asin ( r );; 172 DisplacementVector3D< Cartesian3D<double> > axis ( aqi, aqj, aqk );; 173 if ( r == 0 ) {; 174 axis.SetCoordinates(0,0,1);; 175 } else {; 176 axis /= r;; 177 }; 178 return AxisAngle ( axis, angle );; 179}; 180 ; 181AxisAngle operator*( RotationX const & r, AxisAngle const & a ) {; 182 return AxisAngle(r) * a; // TODO: improve performance; 183}; 184 ; 185AxisAngle operator*( RotationY const & r, AxisAngle const & a ) {; 186 return AxisAngle(r) * a; // TODO: improve performance; 187}; 188 ; 189AxisAngle operator*( RotationZ const & r, AxisAngle const & a ) {; 190 return AxisAngle(r) * a; // TODO: improve performance; 191}; 192 ; 193 ; 194} //namespace Math; 195} //namespace ROOT; EulerAnglesfwd.h; AxisAngle.h; Cartesian3D.h; Quaternion.h; RotationX.h; RotationY.h; RotationZ.h; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; s1#define s1(x)Definition RSha256.hxx:91; e#define e(i)Definition RSha256.hxx:103; Rotation3Dfwd.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; angleOption_t Option_t TPoint TPoint angleDefinition TGWin32VirtualXProxy.cxx:68; qfloat * qDefinition THbookFile.cxx:89; ROOT::Math::AxisAngleAxisAngle class describing rotation rep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/AxisAngleXother_8cxx_source.html:6107,perform,performance,6107,doc/master/AxisAngleXother_8cxx_source.html,https://root.cern,https://root.cern/doc/master/AxisAngleXother_8cxx_source.html,3,['perform'],['performance']
Performance,"Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:20461,perform,perform,20461,root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,1,['perform'],['perform']
Performance,"Scan; 72 ; 73 - Fumili (class TFumiliMinimizer); 74 ; 75 - GSLMultiMin (class ROOT::Math::GSLMinimizer) available when ROOT is built with `mathmore` support; 76 - BFGS2 (Default); 77 - BFGS; 78 - ConjugateFR; 79 - ConjugatePR; 80 - SteepestDescent; 81 ; 82 - GSLMultiFit (class ROOT::Math::GSLNLMinimizer) available when ROOT is built `mathmore` support; 83 ; 84 - GSLSimAn (class ROOT::Math::GSLSimAnMinimizer) available when ROOT is built with `mathmore` support; 85 ; 86 - Genetic (class ROOT::Math::GeneticMinimizer); 87 ; 88 - RMinimizer (class ROOT::Math::RMinimizer) available when ROOT is built with `r` support; 89 - BFGS (default); 90 - L-BFGS-S; 91 - Nelder-Mead; 92 - CG; 93 - and more methods, see the Details in the documentation of the function `optimix` of the [optmix R package](https://cran.r-project.org/web/packages/optimx/optimx.pdf); 94 ; 95 ; 96 The Minimizer class provides the interface to perform the minimization including; 97 ; 98 ; 99 In addition to provide the API for function minimization (via ROOT::Math::Minimizer::Minimize) the Minimizer class provides:; 100 - the interface for setting the function to be minimized. The objective function passed to the Minimizer must implement the multi-dimensional generic interface; 101 ROOT::Math::IBaseFunctionMultiDim. If the function provides gradient calculation (e.g. implementing the ROOT::Math::IGradientFunctionMultiDim interface); 102 the gradient will be used by the Minimizer class, when needed. There are convenient classes for the users to wrap their own functions in this required interface for minimization.; 103 These are the `ROOT::Math::Functor` class and the `ROOT::Math::GradFunctor` class for wrapping functions providing both evaluation and gradient. Some methods, like Fumili, Fumili2 and GSLMultiFit are; 104 specialized method for least-square and also likelihood minimizations. They require then that the given function implements in addition; 105 the `ROOT::Math::FitMethodFunction` interface.; 106 - ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Minimizer_8h_source.html:3204,perform,perform,3204,doc/master/Minimizer_8h_source.html,https://root.cern,https://root.cern/doc/master/Minimizer_8h_source.html,1,['perform'],['perform']
Performance,"SceneBase::fDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); TGLContextIdentity*TGLScene::fGLCtxIdentity; Bool_tTGLScene::fInSmartRefresh!; Bool_tfInternalPIDs! using internal physical IDs; Short_tTGLSceneBase::fLODScene-lod.; Float_tTGLScene::fLastLineWidthScale; UInt_tfLastPID! last physical ID that was processed in AddObject(); Float_tTGLScene::fLastPointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; TGLScene::LogicalShapeMap_tTGLScene::fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; UInt_tfNextInternalPID! next internal physical ID (from 1 - 0 reserved); Float_tTGLSceneBase::fOLLineWScene outline line-width.; TVirtualPad*fPad; TGLScene::PhysicalShapeMap_tTGLScene::fPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; Bool_tfSmartRefresh! cache logicals during scene rebuilds; TGLScene::LogicalShapeMap_tTGLScene::fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneBase::fTimeStampCounter increased on every update.; TStringTGLSceneBase::fTitleObject title.; TGLSceneBase::ViewerList_tTGLSceneBase::fViewers; Float_tTGLSceneBase::fWFLineWScene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScenePad(TVirtualPad* pad); Constructor. void AddHistoPhysical(TGLLogicalShape* log, const Float_t* histColor = 0); Scale and rotate a histo object to mimic placement in canvas. void SubPadPaint(TVirtualPad* pad); Iterate over pad-primitves and import them. void ObjectPaint(TObject* obj, Option_t* opt = """"); Override of virtual TVirtualViewer3D::ObjectPaint().; Special handling of 2D/3D histograms to activate Timur's; histo-painters. void PadPaintFromViewer(TGLViewer* viewer); Entry point for requesting update of scene's contents from; gl-viewer. void PadPaint(TVirtualPad* pad); Entry point for updatin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLScenePad.html:13507,cache,cache,13507,root/html602/TGLScenePad.html,https://root.cern,https://root.cern/root/html602/TGLScenePad.html,2,['cache'],['cache']
Performance,"Searching...; No Matches. TMVA_SOFIE_Keras.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example for the parsing of Keras .h5 file into RModel object and further generating the .hxx header files for inference. ; ; using namespace TMVA::Experimental;; ; TString pythonSrc = ""\; import os\n\; os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n\; \n\; import numpy as np\n\; from tensorflow.keras.models import Model\n\; from tensorflow.keras.layers import Input,Dense,Activation,ReLU\n\; from tensorflow.keras.optimizers import SGD\n\; \n\; input=Input(shape=(64,),batch_size=4)\n\; x=Dense(32)(input)\n\; x=Activation('relu')(x)\n\; x=Dense(16,activation='relu')(x)\n\; x=Dense(8,activation='relu')(x)\n\; x=Dense(4)(x)\n\; output=ReLU()(x)\n\; model=Model(inputs=input,outputs=output)\n\; \n\; randomGenerator=np.random.RandomState(0)\n\; x_train=randomGenerator.rand(4,64)\n\; y_train=randomGenerator.rand(4,4)\n\; \n\; model.compile(loss='mean_squared_error', optimizer=SGD(learning_rate=0.01))\n\; model.fit(x_train, y_train, epochs=5, batch_size=4)\n\; model.save('KerasModel.h5')\n"";; ; ; void TMVA_SOFIE_Keras(const char * modelFile = nullptr, bool printModelInfo = true){; ; //Running the Python script to generate Keras .h5 file; TMVA::PyMethodBase::PyInitialize();; ; if (modelFile == nullptr) {; TMacro m;; m.AddLine(pythonSrc);; m.SaveSource(""make_keras_model.py"");; gSystem->Exec(TMVA::Python_Executable() + "" make_keras_model.py"");; modelFile = ""KerasModel.h5"";; }; ; //Parsing the saved Keras .h5 file into RModel object; SOFIE::RModel model = SOFIE::PyKeras::Parse(modelFile);; ; ; //Generating inference code; model.Generate();; // generate output header. By default it will be modelName.hxx; model.OutputGenerated();; ; if (!printModelInfo) return;; ; //Printing required input tensors; std::cout<<""\n\n"";; model.PrintRequiredInputTensors();; ; //Printing initialized tensors (weights); std::cout<<""\n\n"";; model.PrintInitializedTensors();; ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html:1116,optimiz,optimizer,1116,doc/master/TMVA__SOFIE__Keras_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html,1,['optimiz'],['optimizer']
Performance,"Sec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the given include file correspond to a class that has; been loaded through a compiled dictionnary. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). Int_t LoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Check if class ""classname"" is known to the interpreter (in fact,; this check is not needed anymore, so classname is ignored). If; not it will load library ""libname"". If the library name does; not start with ""lib"", ""lib"" will be prepended and a search will; be made in the DynamicPath (see .rootrc). If not found a search; will be made on libname (without ""lib"" prepended) and if not found; a direct try of libname will be made (in case it contained an; absolute path).; If check is true it will only check if libname exists and is; readable.; Returns 0 on successful loading, -1 in case libname does not; exist or in case of error and -2 in case of version mismatch. void ls(Option_t* option = """") const; To list all objects of the application.; Loop on all objects created in the ROOT linked lists.; Objects may be files and windows or any other object directly; attached to the ROOT linked list. Int_t LoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); Load a macro in the interpreter's memory. Equivalent to the command line; command "".L filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:26775,load,load,26775,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['load'],['load']
Performance,"Segura; Diego worked as technical student on CINT dictionary optimizations.; Eddy Offermann; Eddy joined the ROOT team during a sabbatical to work on making the ROOT matrix package the fastest and most versatile in the industry.; Ilka Antcheva; Ilka has been working from 2002 to 2008 in the ROOT team. She was responsible for the GUI system and designed many high level user interfaces and widgets, like found in many modern graphics applications: ROOT graphics editor (GED) and various object editors, Fit Panel, Style manager, a tool for automatic C++ code generation of any widget and the capability for widgets to save themselves. In addition Ilka took care of the ROOT Users Guide and contributed the chapter ‘Writing a Graphical User Interface’.; Gerardo Ganis; Gerri was a team member for more than ten years; among many other contributions he was in charge of PROOF for many years.; Jan Iwaszkiewicz; Jan was working in the context of a Ph.D. on scheduling and load-balancing of distributed processing in the Parallel ROOT Facility (PROOF).; Leandro Franco; Leo worked a Marie-Curie fellow in the ROOT team from 2005-2008. He worked on a number of widely different topics, from parallel sockets, I/O read-ahead, CINT dictionary, etc.; Maarten Ballintijn; Maarten's initial dab into ROOT was porting it to Linux in 1995. Later he worked on the PROOF system, bringing into production for the RHIC experiments in Brookhaven.; Marek Biskup; Marek worked as technical student on various aspects of PROOF, notably integrating the TChain::Draw() command into PROOF.; Masaharu Goto; Masa is the father of CINT. Without the indefatigable support by Masa we would never have succeeded with the tight integration of CINT in ROOT. Masa is now managing a large division in Agilent and cannot spend as much time on CINT as he would like.; Matevž Tadel; Matevž Tadel is the main developer of 3D graphics and event-visualization packages. He holds a Ph.D. in experimental high-energy physics, obtained in 20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/previous-developers.html:4012,load,load-balancing,4012,d/previous-developers.html,https://root.cern,https://root.cern/d/previous-developers.html,1,['load'],['load-balancing']
Performance,"SelectCompGlobal activation switch for component selection; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_mode; static Int_tRooPrintable::_nameLength; RooAbsIntegrator*_numIntEngine! do not persist; RooAbsFunc*_numIntegrand! do not persist; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet*_params! cache for set of parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; TNamed*_rangeName; Bool_t_restartNumIntEngine! do not persist; RooArgSet_saveInt! do not persist; RooArgSet_saveSum! do not persist ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooListProxy_sumCat! do not persist ; TIterator*_sumCatIter!; RooSetProxy_sumListSet of discrete observable over which is summed numerically;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealIntegral.html:32298,cache,cache,32298,root/html526/RooRealIntegral.html,https://root.cern,https://root.cern/root/html526/RooRealIntegral.html,1,['cache'],['cache']
Performance,"SelectCompGlobal activation switch for component selection; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_mode; static Int_tRooPrintable::_nameLength; RooAbsIntegrator*_numIntEngine! do not persist; RooAbsFunc*_numIntegrand! do not persist; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet*_params! cache for set of parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; TNamed*_rangeName; Bool_t_restartNumIntEngine! do not persist; RooArgSet_saveInt! do not persist; RooArgSet_saveSum! do not persist ; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooListProxy_sumCat! do not persist ; TIterator*_s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealIntegral.html:32917,cache,cache,32917,root/html528/RooRealIntegral.html,https://root.cern,https://root.cern/root/html528/RooRealIntegral.html,2,['cache'],['cache']
Performance,"SelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction3Binding_double_unsigned_int_double_double_.html:33403,cache,cache,33403,root/html530/RooCFunction3Binding_double_unsigned_int_double_double_.html,https://root.cern,https://root.cern/root/html530/RooCFunction3Binding_double_unsigned_int_double_double_.html,1,['cache'],['cache']
Performance,"Send retrieve request for the query specified by ref. ; If path is defined save it to path. Generic method working for all queries known by the server. ; Definition at line 5967 of file TProof.cxx. ◆ Retrieve() [2/2]. Int_t TProof::Retrieve ; (; Int_t ; qry, . const char * ; path = 0 . ). Send retrieve request for the qry-th query in fQueries. ; If path is defined save it to path. ; Definition at line 5948 of file TProof.cxx. ◆ SaveActiveList(). void TProof::SaveActiveList ; (; ). private . Save current list of active workers. ; Definition at line 11542 of file TProof.cxx. ◆ SaveInputData(). Int_t TProof::SaveInputData ; (; TQueryResult * ; qr, . const char * ; cachedir, . TString & ; emsg . ). staticprotected . Save input data file from 'cachedir' into the sandbox or create a the file with input data objects. ; Definition at line 12311 of file TProof.cxx. ◆ SavePerfTree(). Int_t TProof::SavePerfTree ; (; const char * ; pf = 0, . const char * ; ref = 0 . ). Save performance information from TPerfStats to file 'pf'. ; If 'ref' is defined, do it for query 'ref'. Return 0 on sucecss, -1 in case of any error ; Definition at line 12646 of file TProof.cxx. ◆ SaveWorkerInfo(). void TProof::SaveWorkerInfo ; (; ). protectedvirtual . Save information about the worker set in the file .workers in the working dir. ; Called each time there is a change in the worker setup, e.g. by TProof::MarkBad(). ; Definition at line 11808 of file TProof.cxx. ◆ SendCommand(). Int_t TProof::SendCommand ; (; const char * ; cmd, . ESlaves ; list = kActive . ). private . Send command to be executed on the PROOF master and/or slaves. ; Command can be any legal command line command, however commands like "".x file.C"" or "".L file.C"" will not cause the file.C to be transfered to the PROOF cluster. In that case use TProof::Exec(). Returns the status send by the remote server as part of the kPROOF_LOGDONE message. Typically this is the return code of the command on the remote side. Returns -1 in case of er",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:135956,perform,performance,135956,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['perform'],['performance']
Performance,"Send(const TMessage& mess); Send interfaces. Int_t Send(Int_t kind); { return TSocket::Send(kind); }. Int_t Send(Int_t status, Int_t kind); { return TSocket::Send(status, kind); }. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); { return TSocket::Send(mess, kind); }. Int_t SendRaw(const void* buf, Int_t len, ESendRecvOptions opt = kDontBlock). Int_t Recv(TMessage*& mess); Recv interfaces. Int_t Recv(Int_t& status, Int_t& kind); { return TSocket::Recv(status, kind); }. Int_t Recv(char* mess, Int_t max); { return TSocket::Recv(mess, max); }. Int_t Recv(char* mess, Int_t max, Int_t& kind); { return TSocket::Recv(mess, max, kind); }. Int_t RecvRaw(void* buf, Int_t len, ESendRecvOptions opt = kDefault); Interrupts. Int_t GetInterrupt(Bool_t& forward). void SendUrgent(Int_t type, Int_t int1, Int_t int2); Urgent message. void SetInterrupt(Bool_t i = kTRUE); Interrupt the low level socket. Bool_t IsInterrupt(); Set / Check async msg queue waiting status. { R__LOCKGUARD(fAMtx); return fRDInterrupt; }. void SetAWait(Bool_t w = kTRUE); { R__LOCKGUARD(fAMtx); fAWait = w; }. Bool_t IsAWait(); { R__LOCKGUARD(fAMtx); return fAWait; }. Int_t Flush(); Flush the asynchronous queue. Bool_t Ping(const char* ord = 0); Ping the counterpart. void RemoteTouch(); Request remote touch of the admin file associated with this connection. void CtrlC(); Propagate a Ctrl-C. Int_t SetOption(ESockOptions , Int_t ); Standard options cannot be set. { return 0; }. void DisableTimeout(); Disable / Enable read timeout. { fDontTimeout = kTRUE; }. void EnableTimeout(); { fDontTimeout = kFALSE; }. Int_t Reconnect(); Try reconnection after error. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXSocket.h 38538 2011-03-21 14:13:29Z ganis $ » Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXSocket.html:15272,queue,queue,15272,root/html530/TXSocket.html,https://root.cern,https://root.cern/root/html530/TXSocket.html,1,['queue'],['queue']
Performance,"Send(const TMessage& mess); Send interfaces. Int_t Send(Int_t kind); { return TSocket::Send(kind); }. Int_t Send(Int_t status, Int_t kind); { return TSocket::Send(status, kind); }. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); { return TSocket::Send(mess, kind); }. Int_t SendRaw(const void* buf, Int_t len, ESendRecvOptions opt = kDontBlock). Int_t Recv(TMessage*& mess); Recv interfaces. Int_t Recv(Int_t& status, Int_t& kind); { return TSocket::Recv(status, kind); }. Int_t Recv(char* mess, Int_t max); { return TSocket::Recv(mess, max); }. Int_t Recv(char* mess, Int_t max, Int_t& kind); { return TSocket::Recv(mess, max, kind); }. Int_t RecvRaw(void* buf, Int_t len, ESendRecvOptions opt = kDefault); Interrupts. Int_t GetInterrupt(Bool_t& forward). void SendUrgent(Int_t type, Int_t int1, Int_t int2); Urgent message. void SetInterrupt(Bool_t i = kTRUE); Interrupt the low level socket. Bool_t IsInterrupt(); Set / Check async msg queue waiting status. { R__LOCKGUARD(fAMtx); return fRDInterrupt; }. void SetAWait(Bool_t w = kTRUE); { R__LOCKGUARD(fAMtx); fAWait = w; }. Bool_t IsAWait(); { R__LOCKGUARD(fAMtx); return fAWait; }. Int_t Flush(); Flush the asynchronous queue. Bool_t Ping(const char* ord = 0); Ping the counterpart. void RemoteTouch(); Request remote touch of the admin file associated with this connection. void CtrlC(); Propagate a Ctrl-C. Int_t SetOption(ESockOptions , Int_t ); Standard options cannot be set. { return 0; }. void DisableTimeout(); Disable / Enable read timeout. { fDontTimeout = kTRUE; }. void EnableTimeout(); { fDontTimeout = kFALSE; }. Int_t Reconnect(); Try reconnection after error. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXSocket.h 38538 2011-03-21 14:13:29Z ganis $ » Last generated: 2011-12-02 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXSocket.html:15272,queue,queue,15272,root/html532/TXSocket.html,https://root.cern,https://root.cern/root/html532/TXSocket.html,1,['queue'],['queue']
Performance,"SeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . Private Member Functions;  TList (const TList &)=delete;  ; TList & operator= (const TList &)=delete;  . Friends; class TListIter;  . #include <TList.h>. Inheritance diagram for TList:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Iterator_t. typedef TListIter TList::Iterator_t. Definition at line 70 of file TList.h. ◆ TObjLinkPtr_t. using TList::TObjLinkPtr_t = std::shared_ptr<TObjLink>. protected . Definition at line 43 of file TList.h. ◆ TObjLinkWeakPtr_t. using TList::TObjLinkWeakPtr_t = std::weak_ptr<TObjLink>. protected . Definition at line 44 of file TList.h. Constructor & Destructor Documentation. ◆ TList() [1/4]. TList::TList ; (; const TList & ; ). privatedelete . ◆ TList() [2/4]. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTList.html:21449,cache,cache,21449,doc/master/classTList.html,https://root.cern,https://root.cern/doc/master/classTList.html,1,['cache'],['cache']
Performance,"SequenceType (TString &type) const;  Fill type with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; TClass * IsA () const override;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ;  ; void ls (Option_t *option="""") const override;  Print the content of the element. ;  ; virtual void SetMaxIndex (Int_t dim, Int_t max);  set maximum index for array with dimension dim ;  ; virtual void SetNewClass (TClass *cl);  ; virtual void SetNewType (Int_t dtype);  ; virtual void SetOffset (Int_t offset);  ; virtual void SetSize (Int_t dsize);  ; virtual void SetStreamer (TMemberStreamer *streamer);  set pointer to Streamer function for this element ;  ; virtual void SetTObjectOffset (Int_t tobjoffset);  ; virtual void SetType (Int_t dtype);  ; virtual void SetTypeName (const char *name);  ; void Streamer (TBuffer &) override;  Stream an object of class TStreamerElement. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerBasicPointer.html:3883,cache,cache,3883,doc/master/classTStreamerBasicPointer.html,https://root.cern,https://root.cern/doc/master/classTStreamerBasicPointer.html,1,['cache'],['cache']
Performance,"Server, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooConstVar.html:23002,cache,cache,23002,root/html532/RooConstVar.html,https://root.cern,https://root.cern/root/html532/RooConstVar.html,3,['cache'],['cache']
Performance,"Server, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; voidsetVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClien",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealMPFE.html:23839,cache,cache,23839,root/html532/RooRealMPFE.html,https://root.cern,https://root.cern/root/html532/RooRealMPFE.html,1,['cache'],['cache']
Performance,"Server, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetParamConst(Int_t, Bool_t = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ParamHistFunc.html:23510,cache,cache,23510,root/html532/ParamHistFunc.html,https://root.cern,https://root.cern/root/html532/ParamHistFunc.html,1,['cache'],['cache']
Performance,"ServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. void doClearObsList(Bool_t flag); { _clearObsList = flag ; }. Bool_t clearObsList(); { return _clearObsList ; }. » Last changed: Fri Dec 2 14:26:56 2011 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooObjCacheManager.html:5199,cache,cache,5199,root/html532/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html532/RooObjCacheManager.html,11,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"ServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. void doClearObsList(Bool_t flag); { _clearObsList = flag ; }. Bool_t clearObsList(); { return _clearObsList ; }. » Last changed: Mon Jul 4 15:23:37 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooObjCacheManager.html:4863,cache,cache,4863,root/html530/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html530/RooObjCacheManager.html,11,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"ServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; RooRealVar&var() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumConvolution.html:27170,cache,cache,27170,root/html532/RooNumConvolution.html,https://root.cern,https://root.cern/root/html532/RooNumConvolution.html,1,['cache'],['cache']
Performance,"Set & ; cachedVars . ). overridevirtual . Initialize cache of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ; Implements RooAbsDataStore.; Definition at line 982 of file RooVectorDataStore.cxx. ◆ cache(). const RooVectorDataStore * RooVectorDataStore::cache ; (; ); const. inline . Definition at line 171 of file RooVectorDataStore.h. ◆ cacheArgs(). void RooVectorDataStore::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; newVarSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = true . ). overridevirtual . Cache given RooAbsArgs: The tree is given direct write access of the args internal cache the args values is pre-calculated for all data points in this data collection. ; Upon a get() call, the internal cache of 'newVar' will be loaded with the precalculated value and it's dirty flag will be cleared. ; Implements RooAbsDataStore.; Definition at line 764 of file RooVectorDataStore.cxx. ◆ cacheOwner(). const RooAbsArg * RooVectorDataStore::cacheOwner ; (; ). inlineoverridevirtual . Implements RooAbsDataStore.; Definition at line 163 of file RooVectorDataStore.h. ◆ catStoreList(). std::vector< CatVector * > & RooVectorDataStore::catStoreList ; (; ). inline . Definition at line 542 of file RooVectorDataStore.h. ◆ changeObservableName(). bool RooVectorDataStore::changeObservableName ; (; const char * ; from, . const char * ; to . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 595 of file RooVectorDataStore.cxx. ◆ Class(). static TClass * RooVectorDataStore::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooVectorDataStore::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooVectorDataStore::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 591 of file RooVectorDataStore.h. ◆ clone() [1/2]. RooAbsDataStore * RooVectorDataStore::clone ; (; const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:27701,cache,cacheOwner,27701,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,1,['cache'],['cacheOwner']
Performance,"Set & ; row, . double ; weight = 1 . ). pure virtual . Implemented in RooDataSet, and RooDataHist. ◆ addOwnedComponent(). void RooAbsData::addOwnedComponent ; (; const char * ; idxlabel, . RooAbsData & ; data . ). Definition at line 2366 of file RooAbsData.cxx. ◆ allClientsCached(). bool RooAbsData::allClientsCached ; (; RooAbsArg * ; var, . const RooArgSet & ; cacheList . ). protected . Utility function that determines if all clients of object 'var' appear in given list of cached nodes. ; Definition at line 2319 of file RooAbsData.cxx. ◆ attachBuffers(). void RooAbsData::attachBuffers ; (; const RooArgSet & ; extObs). Definition at line 2337 of file RooAbsData.cxx. ◆ attachCache(). void RooAbsData::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). protectedvirtual . Internal method – Attach dataset copied with cache contents to copied instances of functions. ; Definition at line 363 of file RooAbsData.cxx. ◆ cacheArgs(). void RooAbsData::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; varSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = false . ). protectedvirtual . Internal method – Cache given set of functions with data. ; Definition at line 346 of file RooAbsData.cxx. ◆ canSplitFast(). bool RooAbsData::canSplitFast ; (; ); const. Definition at line 2351 of file RooAbsData.cxx. ◆ changeObservableName(). bool RooAbsData::changeObservableName ; (; const char * ; from, . const char * ; to . ). virtual . Definition at line 303 of file RooAbsData.cxx. ◆ checkInit(). void RooAbsData::checkInit ; (; ); const. Definition at line 2392 of file RooAbsData.cxx. ◆ Class(). static TClass * RooAbsData::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsData::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsData::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:34704,cache,cacheArgs,34704,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['cache'],['cacheArgs']
Performance,"Set the parameter values. ;  . Private Member Functions; virtual T DoEval (const T *x) const;  Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. ;  ; virtual T DoEvalPar (const T *x, const double *p) const =0;  Implementation of the evaluation function using the x values and the parameters. ;  . #include <Math/IParamFunction.h>. Inheritance diagram for ROOT::Math::IParametricFunctionMultiDimTempl< T >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ BaseFunc. template<class T > . typedef IBaseFunctionMultiDimTempl<T> ROOT::Math::IParametricFunctionMultiDimTempl< T >::BaseFunc. Definition at line 111 of file IParamFunction.h. Member Function Documentation. ◆ DoEval(). template<class T > . virtual T ROOT::Math::IParametricFunctionMultiDimTempl< T >::DoEval ; (; const T * ; x); const. inlineprivatevirtual . Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. ; Implements ROOT::Math::IBaseFunctionMultiDimTempl< T >.; Reimplemented in ROOT::Math::WrappedParamFunctionGen< FuncPtr >, ROOT::Math::WrappedMultiTF1Templ< T >, and ROOT::Math::IParametricGradFunctionMultiDimTempl< T >.; Definition at line 143 of file IParamFunction.h. ◆ DoEvalPar(). template<class T > . virtual T ROOT::Math::IParametricFunctionMultiDimTempl< T >::DoEvalPar ; (; const T * ; x, . const double * ; p . ); const. privatepure virtual . Implementation of the evaluation function using the x values and the parameters. ; Must be implemented by derived classes ; Implemented in ROOT::Math::MultiDimParamFunctionAdapter, ROOT::Math::WrappedParamFunction< FuncPtr >, ROOT::Math::WrappedParamFunctionGen< FuncPtr >, ROOT::Math::WrappedMultiTF1Templ< T >, and ROOT::Math::IParametricGradFunctionMultiDimTempl< T >. ◆ operator()() [1/2]. template<class T > . T ROOT::Math::IParametricFunctionMultiDimTempl< T >::operator() ; (; const T * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricFunctionMultiDimTempl.html:3241,cache,cached,3241,doc/master/classROOT_1_1Math_1_1IParametricFunctionMultiDimTempl.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricFunctionMultiDimTempl.html,1,['cache'],['cached']
Performance,"Set!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooRealProxy_nllInput -log(L) function; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; map<string,bool>_paramFixedParameter constant status at last time of use; RooAbsPdf*_pdf; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; set<string>_statUncertParams; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooBarlowBeestonLL(); _obs(""paramOfInterest"",""Parameters of interest"",this),;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__RooBarlowBeestonLL.html:36696,cache,cache,36696,root/html602/RooStats__HistFactory__RooBarlowBeestonLL.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__RooBarlowBeestonLL.html,4,['cache'],['cache']
Performance,"Set& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; static RooAbsData::StorageTypeRooAbsData::defaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files) ; TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const TTree * GetTree() const; { return _tree; }. » Last changed: Tue Mar 10 17:21:00 2015 » Last generated: 2015-03-10 17:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooTreeData.html:15123,cache,cached,15123,root/html534/RooTreeData.html,https://root.cern,https://root.cern/root/html534/RooTreeData.html,2,['cache'],['cached']
Performance,"Set*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tag; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBCPEffDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBCPEffDecay.html:42067,cache,cache,42067,root/html530/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html530/RooBCPEffDecay.html,2,['cache'],['cache']
Performance,"Set*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tag; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBCPGenDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBCPGenDecay.html:41926,cache,cache,41926,root/html530/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html530/RooBCPGenDecay.html,2,['cache'],['cache']
Performance,"Set*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxyalpha; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym; RooRealProxym0; RooRealProxyn; RooRealProxysigma.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCBShape.html:40068,cache,cache,40068,root/html532/RooCBShape.html,https://root.cern,https://root.cern/root/html532/RooCBShape.html,2,['cache'],['cache']
Performance,"Set*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxyRooAbsHiddenReal::_stateProxy to hiding state category; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; RooRealProxy_valueHolder of the blind value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooUnblindPrecision(); Default constructor. RooUnblindPrecision(const char* name, const char* title",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindPrecision.html:37100,cache,cache,37100,root/html602/RooUnblindPrecision.html,https://root.cern,https://root.cern/root/html602/RooUnblindPrecision.html,4,['cache'],['cache']
Performance,"Set2() const; const RooNameSet&nameSet1() const; const RooNameSet&nameSet2() const; RooNormSetCache&operator=(const RooNormSetCache&); RooNormSetCache(ULong_t max = 32); RooNormSetCache(const RooNormSetCache&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. ULong_t_max!; RooNameSet_name1!; RooNameSet_name2!; ULong_t_next!; RooNormSetCache::PairIdxMapType_pairToIdx!; RooNormSetCache::PairVectType_pairs!; TNamed*_set2RangeName!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNormSetCache(ULong_t max = 32). ~RooNormSetCache(); Destructor. void clear(); Clear contents. void add(const RooArgSet* set1, const RooArgSet* set2 = 0); Add given pair of RooArgSet pointers to our store. Bool_t autoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); If RooArgSets set1 and set2 or sets with similar contents have; been seen by this cache manager before return kFALSE If not,; return kTRUE. If sets have not been seen and doRefill is true,; update cache reference to current input sets. RooNormSetCache(ULong_t max = 32). Int_t index(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); Match range name first. Bool_t contains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); { return (index(set1,set2,set2RangeName) >= 0); }. Bool_t containsSet1(const RooArgSet* set1). const RooArgSet* lastSet1() const; { return _pairs.empty()?0:_pairs.back().first; }. const RooArgSet* lastSet2() const; { return _pairs.empty()?0:_pairs.back().second; }. const RooNameSet& nameSet1() const; { return _name1; }. const RooNameSet& nameSet2() const; { return _name2; }. Int_t entries() const; { return _pairs.size(); }. void initialize(const RooNormSetCache& other); { clear(); *this = other; }.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNormSetCache.html:2808,cache,cache,2808,root/html602/RooNormSetCache.html,https://root.cern,https://root.cern/root/html602/RooNormSetCache.html,2,['cache'],['cache']
Performance,"SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidSetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodANNBase.html:11530,tune,tuneParameters,11530,root/html530/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodANNBase.html,2,['tune'],['tuneParameters']
Performance,"SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz). void SetCldirChecked(Double_t* dir); void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}. {memcpy(fCldirChecked, dir, 3*sizeof(Double_t));}. void LocalToMaster(const Double_t* local, Double_t* master) const; --- point/vector reference frame conversion. {fCache->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {fCache->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalBomb(master, local);}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}; --- stack manipulation. {return fCache;}. Int_t PushPath(Int_t startlevel = 0); {return fCache->PushState(fCurrentOverlapping, startlevel, fNmany);}. Bool_t PopPath(); {fCurrentOverlapping=fCache->PopState(fNmany); fCurrentNode=fCache->GetNode(); fLevel=fCache->GetLevel();fGlobalMatrix=fCache->GetCurrentMatrix();return fCurrentOverlapping;}. Bool_t PopPath(Int_t index); {fCurrentOverlapping=fCache->PopState(fNmany,index); fCurrentNode=fCache->GetNode(); fLevel=fCache->GetLevel();fGlobalMatrix=fCache->GetCurrentMatrix();return fCurrentOverlapping;}. Int_t PushPoint(Int_t startlevel = 0); {return fCache->PushState(fCurrentOverlapping, startlevel,fNmany,fPoint);}. Bool_t PopPoint(); {fCurrentOverlapping=fCache->PopState(fNmany,fPoint); fCurrentNode=fCache->GetNode(); fLevel=fCache->GetLevel(); fGlobalMatrix=fCache->GetCurrentMatrix();return fCurrentOverlapping;}. Bool_t PopPoint(Int_t index); {fCurrentOverlapping=fCache->PopState(fNmany,index, f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNavigator.html:22835,cache,cache,22835,root/html528/TGeoNavigator.html,https://root.cern,https://root.cern/root/html528/TGeoNavigator.html,2,['cache'],['cache']
Performance,"SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); xframe2.GetYaxis().SetTitleOffset(1.4); xframe2.Draw(); ; c.SaveAs(""rf103_interprfuncs.png""); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(genpdf_over_genpdf_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_genpdf_over_genpdf_Int[x]_genpdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(g2_over_g2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_g2_over_g2_Int[x]_g1Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2551.39, estimated distance to minimum: 4.39288e-06; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf103__interprfuncs_8py.html:3788,optimiz,optimization,3788,doc/master/rf103__interprfuncs_8py.html,https://root.cern,https://root.cern/doc/master/rf103__interprfuncs_8py.html,4,['optimiz'],['optimization']
Performance,"SetModel(const RooStats::ModelConfig& ); set the model. ~NeymanConstruction(); default constructor; if(fOwnsWorkspace && fWS) delete fWS;; if(fConfBelt) delete fConfBelt;. ConfInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::SetInterval. TList* GenSamplingDistribution(const char* asciiFilePat = 0) const; This method generates the sampling distribution for each point of the study. If a file path; is provided, the distribution is saved in a root file. Returns the list of the distributions; for each point. ConfInterval* GetIntervalUsingList() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::PointSetInterval. ConfInterval* GetInterval(const char* asciiFilePat) const; This method returns a confidence interval exactly like GetInterval(), but; instead of generating the sampling disribution (long computation) it takes; the distribution from the file provided. ConfInterval* Run(TList* SamplingList) const; Main method to perform the interval calculation. NeymanConstruction(). void SetTestStatSampler(RooStats::TestStatSampler& distCreator); in addition to interface we also need:; Set the TestStatSampler (eg. ToyMC or FFT, includes choice of TestStatistic). {fTestStatSampler = &distCreator;}. void SetLeftSideTailFraction(Double_t leftSideFraction = 0.); fLeftSideTailFraction*fSize defines lower edge of acceptance region.; Unified limits use 0, central limits use 0.5,; for upper/lower limits it is 0/1 depends on sign of test statistic w.r.t. parameter. {fLeftSideFraction = leftSideFraction;}. void SetParameterPointsToTest(RooAbsData& pointsToTest); User-defined set of points to test. Double_t Size() const; This class can make regularly spaced scans based on range stored in RooRealVars.; Choose number of steps for a rastor scan (common for each dimension); void SetNumSteps(Int_t);; This class can make regularly spaced scans based on range stored in RooRealVars.; Choose number of steps for a r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__NeymanConstruction.html:10519,perform,perform,10519,root/html526/RooStats__NeymanConstruction.html,https://root.cern,https://root.cern/root/html526/RooStats__NeymanConstruction.html,1,['perform'],['perform']
Performance,"SetName (const char *name) override;  Change the name of this tree. ;  ; virtual void SetNotify (TObject *obj);  Sets the address of the object to be notified when the tree is loaded. ;  ; virtual void SetObject (const char *name, const char *title);  Change the name and title of this tree. ;  ; virtual void SetParallelUnzip (bool opt=true, Float_t RelSize=-1);  Enable or disable parallel unzipping of Tree buffers. ;  ; virtual void SetPerfStats (TVirtualPerfStats *perf);  Set perf stats. ;  ; virtual void SetScanField (Int_t n=50);  ; void SetTargetMemoryRatio (Float_t ratio);  ; virtual void SetTimerInterval (Int_t msec=333);  ; virtual void SetTreeIndex (TVirtualIndex *index);  The current TreeIndex is replaced by the new index. ;  ; virtual void SetUpdate (Int_t freq=0);  ; virtual void Show (Long64_t entry=-1, Int_t lenmax=20);  Print values of all active leaves for entry. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this tree. ;  ; virtual Int_t StopCacheLearningPhase ();  Stop the cache learning phase. ;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual Int_t UnbinnedFit (const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Unbinned fit of one or more variable(s) from a tree. ;  ; void UseCurrentStyle () override;  Replace current attributes by current style. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write this object to the current directory. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:27956,cache,cache,27956,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,1,['cache'],['cache']
Performance,"SetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; bool _cdfBoundaries = false;  Use boundary conditions for CDFs. ;  ; RooAICRegistry _codeReg;  ! Auxiliary class keeping tracking of analytical integration code ;  ; RooDataHist * _dataHist = nullptr;  Unowned pointer to underlying histogram. ;  ; RooArgSet _histObsList;  List of observables defining dimensions of histogram. ;  ; Int_t _intOrder = 0;  Interpolation order. ;  ; std::unique_ptr< RooDataHist > _ownedDataHist;  ! Owned pointer to underlying histogram ;  ; RooSetProxy _pdfObsList;  List of observables mapped onto histogram observables. ;  ; double _totVolume = 0.0;  ! Total volume of space (product of ranges of observables) ;  ; bool _unitNorm = false;  Assume contents is unit normalized (for use as pdf cache) ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistPdf.html:69478,cache,cache,69478,doc/master/classRooHistPdf.html,https://root.cern,https://root.cern/doc/master/classRooHistPdf.html,1,['cache'],['cache']
Performance,"SetTminTmax(tmin, tmax);; // without arguments resets the time range to the maximum value; TGeoManager::SetTminTmaxvoid SetTminTmax(Double_t tmin=0, Double_t tmax=999)Set time cut interval for drawing tracks.Definition TGeoManager.cxx:4242; Once set, the time range will be active both for individual or global track drawing. For animation, this range is divided to the desired number of frames and will be automatically updated at each frame in order to get the animation effect.; The option provided to all track-drawing methods can trigger different track selections:; default:A track (or all primary tracks) drawn without daughters; /D: Track and first level descendents only are drawn; /*: Track and all descendents are drawn; /Ntype: All tracks having name=type are drawn; Generally several options can be concatenated in the same string (E.g. ""/D /Npion-"").; For animating tracks, additional options can be added:; /G:Geometry animate. Generally when drawing or animating tracks, one has to first perform a normal drawing of the geometry as convenient. The tracks will be drawn over the geometry. The geometry itself will be animated (camera moving and rotating in order to ""catch"" the majority of current track segments.); /S:Save all frames in gif format in the current folder. This option allows creating a movie based on individual frames. Checking the Geometry; Several checking methods are accessible from the context menu of volume objects or of the manager class. They generally apply only to the visible parts of the drawn geometry in order to ease geometry checking, and their implementation is in the TGeoChecker class. The checking package contains an overlap checker and several utility methods that generally have visualization outputs. The Overlap Checker; An overlap is any region in the Euclidian space being contained by more than one positioned volume. Due to the containment scheme used by the modeller, all points inside a volume have to be also contained by the mother the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:98248,perform,perform,98248,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['perform']
Performance,"SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddModel.html:33045,cache,cache,33045,root/html534/RooAddModel.html,https://root.cern,https://root.cern/root/html534/RooAddModel.html,5,['cache'],['cache']
Performance,"Setting::EAlgorithm ; algorithm, . int ; compressionLevel . ). ◆ CompressionSettings() [2/2]. int ROOT::CompressionSettings ; (; ROOT::ECompressionAlgorithm ; algorithm, . int ; compressionLevel . ). Deprecated name, do not use: . ◆ CreateClass() [1/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5634 of file TClass.cxx. ◆ CreateClass() [2/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5619 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 597 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v620/namespaceROOT.html:18822,multi-thread,multi-threading,18822,doc/v620/namespaceROOT.html,https://root.cern,https://root.cern/doc/v620/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"Setting::EAlgorithm ; algorithm, . int ; compressionLevel . ). ◆ CompressionSettings() [2/2]. int ROOT::CompressionSettings ; (; ROOT::ECompressionAlgorithm ; algorithm, . int ; compressionLevel . ). Deprecated name, do not use: . ◆ CreateClass() [1/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5663 of file TClass.cxx. ◆ CreateClass() [2/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5648 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 596 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:18730,multi-thread,multi-threading,18730,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"Setting::EAlgorithm ; algorithm, . int ; compressionLevel . ). ◆ CompressionSettings() [2/2]. int ROOT::CompressionSettings ; (; ROOT::ECompressionAlgorithm ; algorithm, . int ; compressionLevel . ). Deprecated name, do not use: . ◆ CreateClass() [1/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5847 of file TClass.cxx. ◆ CreateClass() [2/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5832 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 543 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:19420,multi-thread,multi-threading,19420,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"Setting::EAlgorithm ; algorithm, . int ; compressionLevel . ). ◆ CompressionSettings() [2/2]. int ROOT::CompressionSettings ; (; ROOT::ECompressionAlgorithm ; algorithm, . int ; compressionLevel . ). Deprecated name, do not use: . ◆ CreateClass() [1/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5861 of file TClass.cxx. ◆ CreateClass() [2/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5846 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 542 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:19459,multi-thread,multi-threading,19459,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"Setting::EAlgorithm ; algorithm, . int ; compressionLevel . ). ◆ CompressionSettings() [2/2]. int ROOT::CompressionSettings ; (; ROOT::ECompressionAlgorithm ; algorithm, . int ; compressionLevel . ). Deprecated name, do not use: . ◆ CreateClass() [1/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5870 of file TClass.cxx. ◆ CreateClass() [2/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5855 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 544 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:22478,multi-thread,multi-threading,22478,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"Settings > & ParamsSettings ();  get the vector of parameter settings (non-const method) ;  ; const std::vector< ROOT::Fit::ParameterSettings > & ParamsSettings () const;  get the vector of parameter settings (const method) ;  ; std::vector< double > ParamsValues () const;  return a vector of stored parameter values (i.e initial fit parameters) ;  ; ParameterSettings & ParSettings (unsigned int i);  get the parameter settings for the i-th parameter (non-const method) ;  ; const ParameterSettings & ParSettings (unsigned int i) const;  get the parameter settings for the i-th parameter (const method) ;  ; void SetFromFitResult (const FitResult &rhs);  ; void SetMinimizer (const char *type, const char *algo=nullptr);  set minimizer type ;  ; void SetMinimizerOptions (const ROOT::Math::MinimizerOptions &minopt);  set all the minimizer options using class MinimizerOptions ;  ; void SetMinosErrors (bool on=true);  set Minos errors computation to be performed after fitting ;  ; void SetMinosErrors (const std::vector< unsigned int > &paramInd);  set parameter indices for running Minos this can be used for running Minos on a subset of parameters - otherwise is run on all of them if MinosErrors() is set ;  ; void SetNormErrors (bool on=true);  set the option to normalize the error on the result according to chi2/ndf ;  ; void SetParabErrors (bool on=true);  set parabolic errors ;  ; void SetParamsSettings (const std::vector< ROOT::Fit::ParameterSettings > &pars);  ; void SetParamsSettings (unsigned int npar, const double *params, const double *vstep=nullptr);  set the parameter settings from number of parameters and a vector of values and optionally step values. ;  ; void SetUpdateAfterFit (bool on=true);  Update configuration after a fit using the FitResult. ;  ; void SetWeightCorrection (bool on=true);  apply the weight correction for error matrix computation ;  ; bool UpdateAfterFit () const;  Update configuration after a fit using the FitResult. ;  ; bool UseWeightCorrecti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitConfig.html:2839,perform,performed,2839,doc/master/classROOT_1_1Fit_1_1FitConfig.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitConfig.html,1,['perform'],['performed']
Performance,"Set _cloneSet;  Clone of all nodes of input p.d.f. ;  ; Int_t _code;  Internal generation code. ;  ; RooArgSet _directVars;  ; std::unique_ptr< RooAbsNumGenerator > _generator;  MC sampling generation engine. ;  ; double _maxProb {0.};  ; std::unique_ptr< RooRealVar > _maxVar;  Variable holding maximum value of p.d.f. ;  ; double _norm {0.};  Maximum probability, p.d.f area and normalization. ;  ; RooArgSet _otherVars;  List of observables generated internally, randomly, and by accept/reject sampling. ;  ; RooAbsPdf * _pdfClone = nullptr;  Clone of input p.d.f. ;  ; RooArgSet _uniformVars;  ; Int_t _updateFMaxPerEvent;  If true, maximum p.d.f value needs to be recalculated for each event. ;  ;  Protected Attributes inherited from RooAbsGenContext; UInt_t _expectedEvents;  Number of expected events from extended p.d.f. ;  ; RooAbsPdf::ExtendMode _extendMode;  Extended mode capabilities of p.d.f. ;  ; RooDataSet * _genData = nullptr;  ! Data being generated ;  ; bool _isValid;  Is context in valid state? ;  ; Int_t _nextProtoIndex;  Next prototype event to load according to LUT. ;  ; TString _normRange;  Normalization range of pdf. ;  ; std::vector< Int_t > _protoOrder;  LUT with traversal order of prototype data. ;  ; const RooDataSet * _prototype;  Pointer to prototype dataset. ;  ; RooArgSet _protoVars;  Prototype observables. ;  ; RooArgSet _theEvent;  Pointer to observable event being generated. ;  ; bool _verbose;  Verbose messaging? ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 ))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGenContext.html:16106,load,load,16106,doc/master/classRooGenContext.html,https://root.cern,https://root.cern/doc/master/classRooGenContext.html,1,['load'],['load']
Performance,ShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; RooListProxy_funcListList of component FUNCs; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoef; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normIntMgrThe integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_oper,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealSumPdf.html:39232,cache,cache,39232,root/html532/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html532/RooRealSumPdf.html,2,['cache'],['cache']
Performance,"Size = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter = tree->GetClusterIterator(entry);; 5462/// Long64_t clusterStart;; 5463/// while( (clusterStart = clusterIter()) < tree->GetEntries() ) {; 5464/// printf(""The cluster starts at %lld and ends at %lld (inclusive)\n"",clusterStart,clusterIter.GetNextEntry()-1);; 5465/// }; 5466/// ~~~; 5467 ; 5468TTree::TClusterIterator TTree::GetClusterIterator(Long64_t firstentry); 5469{; 5470 // create cache if wanted; 5471 if (fCacheDoAutoInit); 5472 SetCacheSizeAux();; 5473 ; 5474 return TClusterIterator(this,firstentry);; 5475}; 5476 ; 5477////////////////////////////////////////////////////////////////////////////////; 5478/// Return pointer to the current file.; 5479 ; 5480TFile* TTree::GetCurrentFile() const; 5481{; 5482 if (!fDirectory || fDirectory==gROOT) {; 5483 return nullptr;; 5484 }; 5485 return fDirectory->GetFile();; 5486}; 5487 ; 5488////////////////////////////////////////////////////////////////////////////////; 5489/// Return the number of entries matching the selection.; 5490/// Return -1 in case of errors.; 5491///; 5492/// If the selection uses any arrays or containers, we return the number; 5493/// of entries where at least one element match the selection.; 5494/// GetEntries is implemented using the selector class TSelectorEntries,; 5495/// which can be used directly (see code in TTreePlayer::GetEntries) for; 5496/// additional option.; 5497/// If SetEventList was used on the TTree or TChain, only that subset; 5498/// ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:216534,cache,cache,216534,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"Size) const override;  Calculate chi^2 in partition from firstEvent to lastEvent using given stepSize Throughout the calculation, we use Kahan's algorithm for summing to prevent loss of precision - this is a factor four more expensive than straight addition, but since evaluating the PDF is usually much more expensive than that, we tolerate the additional cost... ;  ;  Protected Member Functions inherited from RooAbsOptTestStatistic; virtual bool allowFunctionCache ();  ; void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true) override;  Driver function to propagate constant term optimizations in test statistic. ;  ; void initSlave (RooAbsReal &real, RooAbsData &indata, const RooArgSet &projDeps, const char *rangeName, const char *addCoefRangeName);  ; void optimizeCaching ();  This method changes the value caching logic for all nodes that depends on any of the observables as defined by the given dataset. ;  ; void optimizeConstantTerms (bool, bool=true);  Driver function to activate global constant term optimization. ;  ; void printCompactTreeHook (std::ostream &os, const char *indent="""") override;  Catch print hook function and forward to function clone. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursive) override;  Catch server redirect calls and forward to internal clone of function. ;  ; virtual RooArgSet requiredExtraObservables () const;  ; void runRecalculateCache (std::size_t firstEvent, std::size_t lastEvent, std::size_t stepSize) const override;  ; bool setDataSlave (RooAbsData &data, bool cloneData=true, bool ownNewDataAnyway=false) override;  Change dataset that is used to given one. ;  ;  Protected Member Functions inherited from RooAbsTestStatistic; double evaluate () const override;  Calculate and return value of test statistic. ;  ; virtual double getCarry () const;  ; bool initialize ();  One-time initialization of the test statistic. ;  ; void initMPM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:50831,optimiz,optimizeConstantTerms,50831,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,2,['optimiz'],"['optimization', 'optimizeConstantTerms']"
Performance,"Size. ;  ; virtual TTree * CloneTree (Long64_t nentries=-1, Option_t *option="""");  Create a clone of this tree and copy nentries. ;  ; virtual void CopyAddresses (TTree *, bool undo=false);  Set branch addresses of passed tree equal to ours. ;  ; virtual Long64_t CopyEntries (TTree *tree, Long64_t nentries=-1, Option_t *option="""", bool needCopyAddresses=false);  Copy nentries from given tree to this tree. ;  ; virtual TTree * CopyTree (const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Copy a tree with selection. ;  ; virtual TBasket * CreateBasket (TBranch *);  Create a basket for this tree and given branch. ;  ; Int_t Debug () const;  ; void Delete (Option_t *option="""") override;  Delete this tree from memory or/and disk. ;  ; void Draw (Option_t *opt) override;  Default Draw method for all objects. ;  ; virtual void DropBaskets ();  Remove some baskets from memory. ;  ; virtual Int_t DropBranchFromCache (const char *bname, bool subbranches=false);  Remove the branch with name 'bname' from the Tree cache. ;  ; virtual Int_t DropBranchFromCache (TBranch *branch, bool subbranches=false);  Remove the branch b from the Tree cache. ;  ; virtual void DropBuffers (Int_t nbytes);  Drop branch buffers to accommodate nbytes below MaxVirtualsize. ;  ; bool EnableCache ();  Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ;  ; virtual Int_t Fit (const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Option_t *goption="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Fit a projected item(s) from a tree. ;  ; virtual Int_t FlushBaskets (bool create_cluster=true) const;  Write to disk all the basket that have not yet been individually written and create an event cluster boundary (by default). ;  ; UInt_t GetAllocationCount () const;  ; virtual Long64_t GetAutoFlush () const;  ; virtual Long64_t GetAutoSave () const;  ; virtual TBranchRef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:17212,cache,cache,17212,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,3,['cache'],['cache']
Performance,"SmallVectorTemplateCommon::getFirstEl() is; 503/// well-defined.; 504template <typename T>; 505struct alignas(T) SmallVectorStorage<T, 0> {; 506};; 507 ; 508/// The size of the inline storage of an RVec.; 509/// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); 510/// unless the size of the buffer with 8 elements would be over a certain maximum size.; 511template <typename T>; 512struct RVecInlineStorageSize {; 513private:; 514#ifdef R__HAS_HARDWARE_INTERFERENCE_SIZE; 515 static constexpr std::size_t cacheLineSize = std::hardware_destructive_interference_size;; 516#else; 517 // safe bet: assume the typical 64 bytes; 518 static constexpr std::size_t cacheLineSize = 64;; 519#endif; 520 static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);; 521 static constexpr unsigned maxInlineByteSize = 1024;; 522 ; 523public:; 524 static constexpr unsigned value =; 525 elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8);; 526};; 527 ; 528// A C++14-compatible implementation of std::uninitialized_value_construct; 529template <typename ForwardIt>; 530void UninitializedValueConstruct(ForwardIt first, ForwardIt last); 531{; 532#if __cplusplus < 201703L; 533 for (; first != last; ++first); 534 new (static_cast<void *>(std::addressof(*first))) typename std::iterator_traits<ForwardIt>::value_type();; 535#else; 536 std::uninitialized_value_construct(first, last);; 537#endif; 538}; 539 ; 540/// An unsafe function to reset the buffer for which this RVec is acting as a view.; 541///; 542/// \note This is a low-level method that _must_ be called on RVecs that are already non-owning:; 543/// - it does not put the RVec in ""non-owning mode"" (fCapacity == -1); 544/// - it does not free any owned buffer; 545template <typename T>; 546void ResetView(RVec<T> &v, T* addr, std::size_t sz); 547{; 548 v.fBeginX = addr;; 549 v.fSize = sz;; 550}; 551 ; 552} // namespace VecOp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:18961,cache,cacheLineSize,18961,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,3,['cache'],['cacheLineSize']
Performance,"Smoothing11""; ""BackSmoothing13""; ""BackSmoothing15""; ""Compton"" if selected the estimation of Compton edge; will be included.; ""same"" : if this option is specified, the resulting background; histogram is superimposed on the picture in the current pad.; . NOTE that the background is only evaluated in the current range of h.; ie, if h has a bin range (set via h->GetXaxis()->SetRange(binmin,binmax),; the returned histogram will be created with the same number of bins; as the input histogram h, but only bins from binmin to binmax will be filled; with the estimated background.; ; . void Print(Option_t* option = """") const. Print the array of positions.; ; . Int_t Search(const TH1* hist, Double_t sigma = 2, Option_t* option = """", Double_t threshold = 0.050000000000000003). One-dimensional peak search function. This function searches for peaks in source spectrum in hin; The number of found peaks and their positions are written into; the members fNpeaks and fPositionX.; The search is performed in the current histogram range.; ; Function parameters:; ; hin: pointer to the histogram of source spectrum; sigma: sigma of searched peaks, for details we refer to manual; threshold: (default=0.05) peaks with amplitude less than; threshold*highest_peak are discarded. 0; By default, the background is removed before deconvolution.; Specify the option ""nobackground"" to not remove the background.; ; By default the ""Markov"" chain algorithm is used.; Specify the option ""noMarkov"" to disable this algorithm; Note that by default the source spectrum is replaced by a new spectrum; ; By default a polymarker object is created and added to the list of; functions of the histogram. The histogram is drawn with the specified; option and the polymarker object drawn on top of the histogram.; The polymarker coordinates correspond to the npeaks peaks found in; the histogram.; ; A pointer to the polymarker object can be retrieved later via:; ; TList *functions = hin->GetListOfFunctions();; TPolyMarker *pm = (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum.html:12682,perform,performed,12682,root/html602/TSpectrum.html,https://root.cern,https://root.cern/root/html602/TSpectrum.html,2,['perform'],['performed']
Performance,"Source Class ReferenceabstractDataframe. ; RDataSource defines an API that RDataFrame can use to read arbitrary data formats. ; A concrete RDataSource implementation (i.e. a class that inherits from RDataSource and implements all of its pure methods) provides an adaptor that RDataFrame can leverage to read any kind of tabular data formats. RDataFrame calls into RDataSource to retrieve information about the data, retrieve (thread-local) readers or ""cursors"" for selected columns and to advance the readers to the desired data entry.; The sequence of calls that RDataFrame (or any other client of a RDataSource) performs is the following:. SetNSlots() : inform RDataSource of the desired level of parallelism; GetColumnReaders() : retrieve from RDataSource per-thread readers for the desired columns; Initialize() : inform RDataSource that an event-loop is about to start; GetEntryRanges() : retrieve from RDataSource a set of ranges of entries that can be processed concurrently; InitSlot() : inform RDataSource that a certain thread is about to start working on a certain range of entries; SetEntry() : inform RDataSource that a certain thread is about to start working on a certain entry; FinalizeSlot() : inform RDataSource that a certain thread finished working on a certain range of entries; Finalize() : inform RDataSource that an event-loop finished. RDataSource implementations must support running multiple event-loops consecutively (although sequentially) on the same dataset.; SetNSlots() is called once per RDataSource object, typically when it is associated to a RDataFrame.; GetColumnReaders() can be called several times, potentially with the same arguments, also in-between event-loops, but not during an event-loop.; GetEntryRanges() will be called several times, including during an event loop, as additional ranges are needed. It will not be called concurrently.; Initialize() and Finalize() are called once per event-loop, right before starting and right after finishing.; InitS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RDataSource.html:1235,concurren,concurrently,1235,doc/master/classROOT_1_1RDF_1_1RDataSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RDataSource.html,1,['concurren'],['concurrently']
Performance,"Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TIsAProxy. class TIsAProxy: public TVirtualIsAProxy. TClass. TIsAProxy implementation class. Function Members (Methods); public:. virtual~TIsAProxy(); virtual TClass*operator()(const void* obj); virtual voidSetClass(TClass* cl); TIsAProxy(const type_info& typ). protected:. TIsAProxy&operator=(const TIsAProxy&); TIsAProxy(const TIsAProxy&). private:. void*CacheSubType(const type_info*, TClass*); void*FindSubType(const type_info*) const. Data Members; private:. Atomic_t<TClass*>fClassActual TClass; Atomic_t<Bool_t>fInitInitialization flag; Atomic_t<void*>fLastpoints into fSubTypes map for last used values; Char_tfSubTypes[72]map of known sub-types; Atomic_t<UInt_t>fSubTypesReadersnumber of readers of fSubTypes; Atomic_t<Bool_t>fSubTypesWriteLockTakenTrue if there is a writer; const type_info*fTypeActual typeid of the proxy; Bool_tfVirtualFlag if class is virtual. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TIsAProxy(const std::type_info& typ); Standard initializing constructor. ~TIsAProxy(); Standard destructor. void SetClass(TClass* cl); Set class pointer; This method is not thread safe. TClass* operator()(const void* obj); IsA callback. void* FindSubType(const type_info* ) const; See if we have already cached the TClass that correspond to this type_info. void* CacheSubType(const type_info* , TClass* ); Record the TClass found for a type_info, so that we can retrieved it faster. TIsAProxy(const TIsAProxy& ). TIsAProxy& operator=(const TIsAProxy& ). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-30 15:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TIsAProxy.html:1513,cache,cached,1513,root/html602/TIsAProxy.html,https://root.cern,https://root.cern/root/html602/TIsAProxy.html,1,['cache'],['cached']
Performance,"Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TIsAProxy. class TIsAProxy: public TVirtualIsAProxy. TClass. TIsAProxy implementation class. Function Members (Methods); public:. virtual~TIsAProxy(); virtual TClass*operator()(const void* obj); virtual voidSetClass(TClass* cl); TIsAProxy(const type_info& typ). protected:. TIsAProxy&operator=(const TIsAProxy&); TIsAProxy(const TIsAProxy&). private:. void*CacheSubType(const type_info*, TClass*); void*FindSubType(const type_info*) const. Data Members; private:. Atomic_t<TClass*>fClassActual TClass; Atomic_t<Bool_t>fInitInitialization flag; Atomic_t<void*>fLastpoints into fSubTypes map for last used values; Char_tfSubTypes[72]map of known sub-types; Atomic_t<UInt_t>fSubTypesReadersnumber of readers of fSubTypes; Atomic_t<Bool_t>fSubTypesWriteLockTakenTrue if there is a writer; const type_info*fTypeActual typeid of the proxy; Bool_tfVirtualFlag if class is virtual. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TIsAProxy(const std::type_info& typ); Standard initializing constructor. ~TIsAProxy(); Standard destructor. void SetClass(TClass* cl); Set class pointer; This method is not thread safe. TClass* operator()(const void* obj); IsA callback. void* FindSubType(const type_info* ) const; See if we have already cached the TClass that correspond to this type_info. void* CacheSubType(const type_info* , TClass* ); Record the TClass found for a type_info, so that we can retrieved it faster. TIsAProxy(const TIsAProxy& ). TIsAProxy& operator=(const TIsAProxy& ). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TIsAProxy.html:1513,cache,cached,1513,root/html604/TIsAProxy.html,https://root.cern,https://root.cern/root/html604/TIsAProxy.html,1,['cache'],['cached']
Performance,"Sparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ; The script calculates the bandwidth for filling and retrieving bin contents (in million entries per second) for these two histogramming techniques, where ""seconds"" is CPU and real time.; The first line of the plots contains the bandwidth based on the CPU time (THnSpase, TH1/2/3/nF*, ratio), the second line shows the plots for real time, and the third line shows the fraction of filled bins and memory used by THnSparse vs. TH1/2/3/nF.; The timing depends on the distribution and the amount of entries in the histograms; here, a Gaussian distribution (center is contained in the histograms) is used to fill each histogram with 1000 entries. The filling and reading is repeated until enough statistics have been collected.; tutorials/tree/drawsparse.C shows an example for visualizing a THnSparse. It creates a TTree which is then drawn using TParallelCoord.; This macro should be run in compiled mode due to the many nested loops that force CLING to disable its optimization. If run interpreted one would not benchmark THnSparse but CLING.; Run as: root[0] .L $ROOTSYS/tutorials/hist/sparsehist.C+; root[1] sparsehist(); ; #include ""TH1.h""; #include ""TH2.h""; #include ""TH3.h""; #include ""THn.h""; #include ""THnSparse.h""; #include ""TStopwatch.h""; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TFile.h""; #include ""TStyle.h""; #include ""TSystem.h""; ; #ifndef INT_MAX; #define INT_MAX std::numeric_limits<int>::max(); #endif; ; class TTimeHists {; public:; enum EHist { kHist, kSparse, kNumHist };; enum ETime { kReal, kCPU, kNumTime };; TTimeHists(Int_t dim, Int_t bins, Long_t num):; fValue(nullptr), fDim(dim), fBins(bins), fNum(num),; fSparse(nullptr), fHist(nullptr), fHn(nullptr) {}; ~TTimeHists();; bool Run();; Double_t GetTime(EHist hist, ETime time) const {; if (time == kReal) return fTime[hist][0];; return fTime[hist][1]; }; static void SetDebug(Int_t lvl) { fgDebug = lvl; }; THnSparse* GetSparse() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/sparsehist_8C.html:1293,optimiz,optimization,1293,doc/master/sparsehist_8C.html,https://root.cern,https://root.cern/doc/master/sparsehist_8C.html,1,['optimiz'],['optimization']
Performance,"Specialization of TContext menu. ; Provide a window manager hint that ensures proper placement of popup on Cocoa. ; Definition at line 430 of file TEveWindow.h. Public Member Functions;  TEveContextMenu (const char *name, const char *title=""Eve context menu"");  Constructor. ;  ; TClass * IsA () const override;  ; void SetupAndPopup (TGWindow *button, TObject *obj);  Position the popup below given button and show context menu for object obj. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TContextMenu;  TContextMenu (const char *name, const char *title=""Context sensitive popup menu"");  Create a context menu. ;  ; virtual ~TContextMenu ();  Destroy a context menu. ;  ; virtual void Action (TClassMenuItem *classmenuitem);  Action to be performed when this menu item is selected. ;  ; void Action (TMethod *method);  ; virtual void Action (TObject *object, TMethod *method);  Action to be performed when this menu item is selected. ;  ; virtual void Action (TObject *object, TToggle *toggle);  Action to be performed when this toggle menu item is selected. ;  ; void Action (TToggle *toggle);  ; virtual const char * CreateArgumentTitle (TMethodArg *argument);  Create string describing argument (for use in dialog box). ;  ; virtual const char * CreateDialogTitle (TObject *object, TFunction *method);  Create title for dialog box retrieving argument values. ;  ; virtual const char * CreatePopupTitle (TObject *object);  Create title for popup menu. ;  ; void Execute (const char *method, const char *params, Int_t *error=nullptr) override;  Execute method on this object with the given parameter string, e.g. ;  ; void Execute (const char *params);  ; void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr) override;  Execute method on this object with parameters stored in the TObjArray. ;  ; void Execute (TObjArray *params);  ; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveContextMenu.html:1335,perform,performed,1335,doc/master/classTEveContextMenu.html,https://root.cern,https://root.cern/doc/master/classTEveContextMenu.html,1,['perform'],['performed']
Performance,"Standard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsCategory; static const decltype(_stateNames) ::value_type & invalidCategory ();  A category state to signify an invalid category. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooBinningCategory.h>. Inheritance diagram for RooBinningCategory:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooBinningCategory() [1/3]. RooBinningCategory::RooBinningCategory ; (; ). default . ◆ RooBinningCategory() [2/3]. RooBinningCategory::RooBinningCategory ; (; const char * ; name, . const char * ; title, . RooAbsRealLValue & ; inputVar, . const char * ; binningName = nullptr, . const char * ; catTypeName = nullptr . ). Constructor with input function to be mapped and name and index of default output state of unmapped values. ; Definition at line 40 of file RooBinningCategory.cxx. ◆ RooBinningCategory() [3/3]. RooBinningCategory::RooBinningCategory ; (; const RooBinningCategory & ; other, .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinningCategory.html:44460,cache,cache,44460,doc/master/classRooBinningCategory.html,https://root.cern,https://root.cern/doc/master/classRooBinningCategory.html,1,['cache'],['cache']
Performance,"Standard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsCategory; static const decltype(_stateNames) ::value_type & invalidCategory ();  A category state to signify an invalid category. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooMappedCategory.h>. Inheritance diagram for RooMappedCategory:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooMappedCategory() [1/3]. RooMappedCategory::RooMappedCategory ; (; ). Definition at line 82 of file RooMappedCategory.cxx. ◆ RooMappedCategory() [2/3]. RooMappedCategory::RooMappedCategory ; (; const char * ; name, . const char * ; title, . RooAbsCategory & ; inputCat, . const char * ; defCatName = ""NotMapped"", . Int_t ; defCatIdx = NoCatIdx . ). Definition at line 84 of file RooMappedCategory.cxx. ◆ RooMappedCategory() [3/3]. RooMappedCategory::RooMappedCategory ; (; const RooMappedCategory & ; other, . const char * ; name = nullptr . ). Definition at line 96 of file RooMappedCategory.cxx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMappedCategory.html:44942,cache,cache,44942,doc/master/classRooMappedCategory.html,https://root.cern,https://root.cern/doc/master/classRooMappedCategory.html,1,['cache'],['cache']
Performance,"Standard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsCategory; static const decltype(_stateNames) ::value_type & invalidCategory ();  A category state to signify an invalid category. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooMultiCategory.h>. Inheritance diagram for RooMultiCategory:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooMultiCategory() [1/3]. RooMultiCategory::RooMultiCategory ; (; ). inline . Definition at line 31 of file RooMultiCategory.h. ◆ RooMultiCategory() [2/3]. RooMultiCategory::RooMultiCategory ; (; const char * ; name, . const char * ; title, . const RooArgSet & ; inputCategories . ). Construct a product of the given set of input RooAbsCategories in inInputCatList. ; The state names of this product category are {S1;S2,S3,...Sn} where Si are the state names of the input categories. ; Definition at line 55 of file RooMultiCategory.cxx. ◆ RooMultiCategory() [3/3]. RooMultiCategory::RooMultiCategory",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMultiCategory.html:44658,cache,cache,44658,doc/master/classRooMultiCategory.html,https://root.cern,https://root.cern/doc/master/classRooMultiCategory.html,1,['cache'],['cache']
Performance,"Standard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsCategory; static const decltype(_stateNames) ::value_type & invalidCategory ();  A category state to signify an invalid category. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooThresholdCategory.h>. Inheritance diagram for RooThresholdCategory:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooThresholdCategory() [1/3]. RooThresholdCategory::RooThresholdCategory ; (; ). inline . Definition at line 28 of file RooThresholdCategory.h. ◆ RooThresholdCategory() [2/3]. RooThresholdCategory::RooThresholdCategory ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; inputVar, . const char * ; defCatName = ""Default"", . Int_t ; defCatIdx = 0 . ). Constructor with input function to be mapped and name and index of default output state of unmapped values. ; Definition at line 45 of file RooThresholdCategory.cxx. ◆ RooThresholdCategory() [3/3]. RooThresholdCategory::RooThr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooThresholdCategory.html:44246,cache,cache,44246,doc/master/classRooThresholdCategory.html,https://root.cern,https://root.cern/doc/master/classRooThresholdCategory.html,1,['cache'],['cache']
Performance,"Standard; , kAnnihilate; };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TEveElement; static const char * ToString (Bool_t b);  Convert Bool_t to string - kTRUE or kFALSE. ;  . #include <TEveCalo.h>. Inheritance diagram for TEveCaloViz:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TEveCaloViz() [1/2]. TEveCaloViz::TEveCaloViz ; (; const TEveCaloViz & ; ). privatedelete . ◆ TEveCaloViz() [2/2]. TEveCaloViz::TEveCaloViz ; (; TEveCaloData * ; data = nullptr, . const char * ; n = ""TEveCaloViz"", . const char * ; t = """" . ). Definition at line 39 of file TEveCalo.cxx. ◆ ~TEveCaloViz(). TEveCaloViz::~TEveCaloViz ; (; ). override . Destructor. ; Definition at line 78 of file TEveCalo.cxx. Member Function Documentation. ◆ AssertCellIdCache(). Bool_t TEveCaloViz::AssertCellIdCache ; (; ); const. Assert cell id cache is ok. ; Returns true if the cache has been updated. ; Definition at line 293 of file TEveCalo.cxx. ◆ AssertPalette(). TEveRGBAPalette * TEveCaloViz::AssertPalette ; (; ). Make sure the TEveRGBAPalette pointer is not null. ; If it is not set, a new one is instantiated and the range is set to current min/max signal values. ; Definition at line 378 of file TEveCalo.cxx. ◆ AssignCaloVizParameters(). void TEveCaloViz::AssignCaloVizParameters ; (; TEveCaloViz * ; cv). protected . Assign parameters from given model. ; Definition at line 321 of file TEveCalo.cxx. ◆ BuildCellIdCache(). virtual void TEveCaloViz::BuildCellIdCache ; (; ). protectedpure virtual . Implemented in TEveCalo3D, TEveCalo2D, and TEveCaloLego. ◆ CellInEtaPhiRng(). Bool_t TEveCaloViz::CellInEtaPhiRng ; (; TEveCaloData::CellData_t & ; cellData); const. Returns true if given cell is in the ceta phi range. ; Definition at line 307 of file TEveCalo.cxx. ◆ CellSelectionChanged(). virtual void TEveCaloViz::CellSelectionC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCaloViz.html:38596,cache,cache,38596,doc/master/classTEveCaloViz.html,https://root.cern,https://root.cern/doc/master/classTEveCaloViz.html,1,['cache'],['cache']
Performance,"Standard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t*_map! Super-index to generic-index map; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGenCategory.html:20961,cache,cache,20961,root/html534/RooGenCategory.html,https://root.cern,https://root.cern/root/html534/RooGenCategory.html,3,['cache'],"['cache', 'caches']"
Performance,"Start the TTreeViewer on this tree.; 9456///; 9457/// - ww is the width of the canvas in pixels; 9458/// - wh is the height of the canvas in pixels; 9459 ; 9460void TTree::StartViewer(); 9461{; 9462 GetPlayer();; 9463 if (fPlayer) {; 9464 fPlayer->StartViewer(600, 400);; 9465 }; 9466}; 9467 ; 9468////////////////////////////////////////////////////////////////////////////////; 9469/// Stop the cache learning phase; 9470///; 9471/// Returns:; 9472/// - 0 learning phase stopped or not active; 9473/// - -1 on error; 9474 ; 9475Int_t TTree::StopCacheLearningPhase(); 9476{; 9477 if (!GetTree()) {; 9478 if (LoadTree(0)<0) {; 9479 Error(""StopCacheLearningPhase"",""Could not load a tree"");; 9480 return -1;; 9481 }; 9482 }; 9483 if (GetTree()) {; 9484 if (GetTree() != this) {; 9485 return GetTree()->StopCacheLearningPhase();; 9486 }; 9487 } else {; 9488 Error(""StopCacheLearningPhase"", ""No tree is available. Could not stop cache learning phase"");; 9489 return -1;; 9490 }; 9491 ; 9492 TFile *f = GetCurrentFile();; 9493 if (!f) {; 9494 Error(""StopCacheLearningPhase"", ""No file is available. Could not stop cache learning phase"");; 9495 return -1;; 9496 }; 9497 TTreeCache *tc = GetReadCache(f,true);; 9498 if (!tc) {; 9499 Error(""StopCacheLearningPhase"", ""No cache is available. Could not stop learning phase"");; 9500 return -1;; 9501 }; 9502 tc->StopLearningPhase();; 9503 return 0;; 9504}; 9505 ; 9506////////////////////////////////////////////////////////////////////////////////; 9507/// Set the fTree member for all branches and sub branches.; 9508 ; 9509static void TBranch__SetTree(TTree *tree, TObjArray &branches); 9510{; 9511 Int_t nb = branches.GetEntriesFast();; 9512 for (Int_t i = 0; i < nb; ++i) {; 9513 TBranch* br = (TBranch*) branches.UncheckedAt(i);; 9514 br->SetTree(tree);; 9515 ; 9516 Int_t writeBasket = br->GetWriteBasket();; 9517 for (Int_t j = writeBasket; j >= 0; --j) {; 9518 TBasket *bk = (TBasket*)br->GetListOfBaskets()->UncheckedAt(j);; 9519 if (bk) {; 9520 tree->In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:365021,cache,cache,365021,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. RooSimWSTool(RooWorkspace& ws); virtual~RooSimWSTool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); RooSimultaneous*build(const char* simPdfName, RooSimWSTool::BuildConfig& bc, Bool_t verbose = kTRUE); RooSimultaneous*build(const char* simPdfName,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimWSTool.html:2976,perform,performed,2976,root/html526/RooSimWSTool.html,https://root.cern,https://root.cern/root/html526/RooSimWSTool.html,5,['perform'],['performed']
Performance,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~BuildConfig(); RooSimWSTool::BuildConfigBuildConfig(const RooArgSet& legacyBuildConfig); RooSimWSTool::BuildConfigBuildConfig(const RooSimWSTool::BuildConfig&); RooSimWSTool::BuildConfigBuildConfig(const char* pdfName, RooSimWSTool::SplitRule& sr); RooSimWSTool::BuildConfigBuildConfig(const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimWSTool__BuildConfig.html:2979,perform,performed,2979,root/html526/RooSimWSTool__BuildConfig.html,https://root.cern,https://root.cern/root/html526/RooSimWSTool__BuildConfig.html,7,['perform'],['performed']
Performance,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~MultiBuildConfig(); voidaddPdf(const char* miStateList, const char* pdfName, RooSimWSTool::SplitRule& sr); voidaddPdf(const char* miStateList, const char* pdfName, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimWSTool__MultiBuildConfig.html:3028,perform,performed,3028,root/html526/RooSimWSTool__MultiBuildConfig.html,https://root.cern,https://root.cern/root/html526/RooSimWSTool__MultiBuildConfig.html,7,['perform'],['performed']
Performance,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjBuildConfig(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjBuildConfigObjBuildConfig(); RooSimWSTool::ObjBuildConfigObjBuildConfig(const RooSimWSTool::ObjBuildConfig&); RooSimWSTool::ObjBuildConfig&operator=(const RooSimWSTool::ObjBuildConfig&); voidprint(); virtual voidShowMembers(TMemberInspector& insp) const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html:2985,perform,performed,2985,root/html602/RooSimWSTool__ObjBuildConfig.html,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjBuildConfig.html,2,['perform'],['performed']
Performance,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjBuildConfig(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjBuildConfigObjBuildConfig(); RooSimWSTool::ObjBuildConfigObjBuildConfig(const RooSimWSTool::ObjBuildConfig&); RooSimWSTool::ObjBuildConfig&operator=(const RooSimWSTool::ObjBuildConfig&); voidprint(); virtual voidShowMembers(TMemberInspector& insp); virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSimWSTool__ObjBuildConfig.html:2988,perform,performed,2988,root/html528/RooSimWSTool__ObjBuildConfig.html,https://root.cern,https://root.cern/root/html528/RooSimWSTool__ObjBuildConfig.html,3,['perform'],['performed']
Performance,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjBuildConfig(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjBuildConfigObjBuildConfig(); RooSimWSTool::ObjBuildConfigObjBuildConfig(const RooSimWSTool::ObjBuildConfig&); RooSimWSTool::ObjBuildConfig&operator=(const RooSimWSTool::ObjBuildConfig&); voidprint(); virtual voidShowMembers(TMemberInspector& insp, char* parent)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimWSTool__ObjBuildConfig.html:2988,perform,performed,2988,root/html526/RooSimWSTool__ObjBuildConfig.html,https://root.cern,https://root.cern/root/html526/RooSimWSTool__ObjBuildConfig.html,1,['perform'],['performed']
Performance,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjBuildConfig(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjBuildConfigObjBuildConfig(); RooSimWSTool::ObjBuildConfigObjBuildConfig(const RooSimWSTool::ObjBuildConfig&); RooSimWSTool::ObjBuildConfig&operator=(const RooSimWSTool::ObjBuildConfig&); voidprint(); virtual voidShowMembers(TMemberInspector&); virtual voidStrea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSimWSTool__ObjBuildConfig.html:2985,perform,performed,2985,root/html534/RooSimWSTool__ObjBuildConfig.html,https://root.cern,https://root.cern/root/html534/RooSimWSTool__ObjBuildConfig.html,1,['perform'],['performed']
Performance,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjSplitRule(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjSplitRuleObjSplitRule(); RooSimWSTool::ObjSplitRuleObjSplitRule(const RooSimWSTool::ObjSplitRule&); RooSimWSTool::ObjSplitRule&operator=(const RooSimWSTool::ObjSplitRule&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html:2979,perform,performed,2979,root/html602/RooSimWSTool__ObjSplitRule.html,https://root.cern,https://root.cern/root/html602/RooSimWSTool__ObjSplitRule.html,2,['perform'],['performed']
Performance,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjSplitRule(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjSplitRuleObjSplitRule(); RooSimWSTool::ObjSplitRuleObjSplitRule(const RooSimWSTool::ObjSplitRule&); RooSimWSTool::ObjSplitRule&operator=(const RooSimWSTool::ObjSplitRule&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSimWSTool__ObjSplitRule.html:2982,perform,performed,2982,root/html528/RooSimWSTool__ObjSplitRule.html,https://root.cern,https://root.cern/root/html528/RooSimWSTool__ObjSplitRule.html,3,['perform'],['performed']
Performance,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjSplitRule(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjSplitRuleObjSplitRule(); RooSimWSTool::ObjSplitRuleObjSplitRule(const RooSimWSTool::ObjSplitRule&); RooSimWSTool::ObjSplitRule&operator=(const RooSimWSTool::ObjSplitRule&); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimWSTool__ObjSplitRule.html:2982,perform,performed,2982,root/html526/RooSimWSTool__ObjSplitRule.html,https://root.cern,https://root.cern/root/html526/RooSimWSTool__ObjSplitRule.html,1,['perform'],['performed']
Performance,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjSplitRule(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjSplitRuleObjSplitRule(); RooSimWSTool::ObjSplitRuleObjSplitRule(const RooSimWSTool::ObjSplitRule&); RooSimWSTool::ObjSplitRule&operator=(const RooSimWSTool::ObjSplitRule&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSimWSTool__ObjSplitRule.html:2979,perform,performed,2979,root/html534/RooSimWSTool__ObjSplitRule.html,https://root.cern,https://root.cern/root/html534/RooSimWSTool__ObjSplitRule.html,1,['perform'],['performed']
Performance,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~RooSimWSTool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); RooSimultaneous*build(const char* simPdfName, RooSimWSTool::BuildConfig& bc, Bool_t verbose = kTRUE); RooSimultaneous*build(const char* simPdfName, const char* protoPdfName, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimWSTool.html:2973,perform,performed,2973,root/html602/RooSimWSTool.html,https://root.cern,https://root.cern/root/html602/RooSimWSTool.html,2,['perform'],['performed']
Performance,"State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'master' splitting category. To specify these configurations; an intermediate MultiBuildConfig must be composed with all; the necessary specifications. For example, this code. RooSimWSTool::MultiBuildConfig mbc(""mc"") ;; mbc.addPdf(""I"",""G"",SplitParam(""m,s"",""c"")) ;; mbc.addPdf(""II,III"",""F"",SplitParam(""a"",""c,d"")) ;. configures a build with two prototype p.d.f.s G and F.; Prototype G is used for state ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~SplitRule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimWSTool__SplitRule.html:2988,perform,performed,2988,root/html526/RooSimWSTool__SplitRule.html,https://root.cern,https://root.cern/root/html526/RooSimWSTool__SplitRule.html,7,['perform'],['performed']
Performance,Static flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! do not persist; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenCon,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:40139,cache,cache,40139,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,1,['cache'],['cache']
Performance,Static flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! do not persist; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumConvPdf.html:40521,cache,cache,40521,root/html528/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html528/RooNumConvPdf.html,1,['cache'],['cache']
Performance,Static flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! do not persist; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPd,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumConvPdf.html:40990,cache,cache,40990,root/html530/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html530/RooNumConvPdf.html,1,['cache'],['cache']
Performance,Static flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! do not persist; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooA,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumConvPdf.html:41393,cache,cache,41393,root/html532/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html532/RooNumConvPdf.html,1,['cache'],['cache']
Performance,Static flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; TArrayD_limits; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; Int_t_nBins; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigN,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooParametricStepFunction.html:38583,cache,cache,38583,root/html526/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html526/RooParametricStepFunction.html,1,['cache'],['cache']
Performance,Static flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; TArrayD_limits; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; Int_t_nBins; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC genera,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooParametricStepFunction.html:38965,cache,cache,38965,root/html528/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html528/RooParametricStepFunction.html,1,['cache'],['cache']
Performance,Static flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; TArrayD_limits; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; Int_t_nBins; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculatin,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooParametricStepFunction.html:39434,cache,cache,39434,root/html530/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html530/RooParametricStepFunction.html,1,['cache'],['cache']
Performance,Static flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; TArrayD_limits; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; Int_t_nBins; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalcul,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooParametricStepFunction.html:39837,cache,cache,39837,root/html532/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html532/RooParametricStepFunction.html,1,['cache'],['cache']
Performance,"Statsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?. private:. TList*fActivenodes with unfinished files; Float_tfBaseLocalPreferenceindicates how much more likely the nodes will be; Bool_tfCachePacketSynccontrol synchronization of cache and packet sizes; TList*fFileNodesnodes with files; TSortedList*fFilesToProcessGlobal list of files (TFileStat) to be processed; Bool_tfForceLocalif 1 - eliminate the remote processing; Float_tfFractionOfRemoteFilesfraction of TDSetElements that are on non-workers; Double_tfMaxEntriesRatiomax file entries to avg allowed ratio for cache-to-packet sync; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Long64_tfNEventsOnRemLocnumber of events in currently; Int_tfPacketAsAFractionused to calculate the packet size; TList*fPartitionslist of partitions on nodes; Int_tfStrategy0 means the classic and 1 (default) - the adaptive strategy; Int_tfTryReassignControls attempts to reassign packets (0 == no reassignment); TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPacketizerAdaptive.html:10777,cache,cache,10777,root/html530/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html530/TPacketizerAdaptive.html,9,"['cache', 'perform']","['cache', 'cache-to-packet', 'performance']"
Performance,StatusBitsTObject::kMustCleanup; static TTree::ESetBranchAddressStatusTTree::kNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave bytes produced; Bool_tfBranchChecked; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfCurrentEntry; TStringfDB; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeSQL.html:23027,cache,cache,23027,root/html602/TTreeSQL.html,https://root.cern,https://root.cern/root/html602/TTreeSQL.html,2,['cache'],['cache']
Performance,"StatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTProofBenchRun::fParListList of PARs to be loaded; TProof*TProofBenchRun::fProofProof; TStringTProofBenchRun::fSelNameName of the selector to be run; TStringTProofBenchRun::fSelOptionOption field for processing the selector. private:. TCanvas*fCanvascanvas for performance plots; Int_tfDebugdebug switch; TDirectory*fDirProofBenchdirectory for proof outputs; Int_tfDrawdraw switch; TPBHistType*fHistTypehistogram type; TH2*fHist_perfstat_event; TList*fListPerfPlotslist of performance plots; Long64_tfNEventsnumber of events to generate; Int_tfNHistsnumber of histograms; Int_tfNTriesnumber of tries; TStringfNamename of CPU run; TProofNodes*fNodesnode information; TLegend*fNormLegendLegend for norms; TProfile*fNorm_perfstat_evtmax; TProfile*fNorm_queryresult_event; TLegend*fProfLegendLegend for profiles; TProfile*fProfile_cpu_eff; TProfile*fProfile_perfstat_event; TProfile*fProfile_perfstat_evtmax; TProfile*fProfile_queryresult_event; Int_tfStartstart number of workers to scan; Int_tfSteptest to be performed every fStep workers; Int_tfStopstop number of workers to scan. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBenchRunCPU(TPBHistType* histtype = 0, Int_t nhists = 16, TDirectory* dirproofbench = 0, TProof* proof = 0, TProofNodes* nodes = 0, Long64_t nevents = 1000000, Int_t ntries = 2, Int_t start = 1, Int_t stop = -1, Int_t step = 1, Int_t draw = 0, Int_t debug = 0); Default constructor. ~TProofBenchRunCPU(); Destructor. void BuildHistos(Int_t start, Int_t stop, Int_t step, Bool_t nx); Build histograms, profiles and graphs needed for this run. void Run(Long64_t nevents, Int_t start",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofBenchRunCPU.html:7549,perform,performance,7549,root/html602/TProofBenchRunCPU.html,https://root.cern,https://root.cern/root/html602/TProofBenchRunCPU.html,6,['perform'],"['performance', 'performed']"
Performance,"Statusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const; True if fit successful, otherwise false. { return fValid; }. bool IsEmpty() const; True if a fit result does not exist (even invalid) with parameter values. { return (fParams.size() == 0); }. double MinFcnValue() const; Return value of the objective function (chi2 or likelihood) used in the fit. { return fVal; }. unsigned int NCalls() const; Number of function calls to find minimum. { return fNCalls; }. double Edm() const; Expected distance from minimum. { return fEdm; }. unsigned int NTotalParameters() const; get total number of parameters. { return fParams.size(); }. unsigned int NPar() const; total number of parameters (abbreviation). { return NTotalParameters(); }. unsigned int NFreeParameters() const; get total",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Fit__FitResult.html:5551,perform,performed,5551,root/html530/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html530/ROOT__Fit__FitResult.html,2,['perform'],['performed']
Performance,"Store(RooAbsDataStore& store); virtual voidRooAbsReal::attachToTree(TTree& t, Int_t bufSize = 32000); virtual voidRooAbsReal::attachToVStore(RooVectorDataStore& vstore); virtual const char*binningName() const; TStringcacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidclearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); virtual RooAbsCachedReal::FuncCacheElem*createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooAbsReal::evaluate() const; virtual voidfillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; RooAbsCachedReal::FuncCacheElem*getCache(const RooArgSet* nset) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedReal.html:28837,cache,cache,28837,root/html602/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html,2,['cache'],['cache']
Performance,"Store(RooAbsDataStore& store); virtual voidRooAbsReal::attachToTree(TTree& t, Int_t bufSize = 32000); virtual voidRooAbsReal::attachToVStore(RooVectorDataStore& vstore); virtual const char*binningName() const; TStringcacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidclearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); virtual RooAbsCachedReal::FuncCacheElem*createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooAbsReal::evaluate() const; virtual voidfillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; RooAbsCachedReal::FuncCacheElem*getCache(const RooArgSet* nset) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedReal.html:28702,cache,cache,28702,root/html534/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html,1,['cache'],['cache']
Performance,Streamer(). void RooMomentMorph::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooMomentMorph::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 98 of file RooMomentMorph.h. ◆ sumPdf(). RooAbsPdf * RooMomentMorph::sumPdf ; (; const RooArgSet * ; nset). Definition at line 330 of file RooMomentMorph.cxx. ◆ useHorizontalMorphing(). void RooMomentMorph::useHorizontalMorphing ; (; bool ; val). inline . Definition at line 45 of file RooMomentMorph.h. Friends And Related Symbol Documentation. ◆ CacheElem. friend class CacheElem. friend . Current normalization set. ; Definition at line 76 of file RooMomentMorph.h. Member Data Documentation. ◆ _cacheMgr. RooObjCacheManager RooMomentMorph::_cacheMgr. mutableprotected . Definition at line 73 of file RooMomentMorph.h. ◆ _curNormSet. RooArgSet* RooMomentMorph::_curNormSet = nullptr. mutableprotected . The cache manager. ; Definition at line 74 of file RooMomentMorph.h. ◆ _M. TMatrixD* RooMomentMorph::_M = nullptr. mutableprotected . Definition at line 92 of file RooMomentMorph.h. ◆ _mref. TVectorD* RooMomentMorph::_mref = nullptr. mutableprotected . Definition at line 90 of file RooMomentMorph.h. ◆ _pdfList. RooListProxy RooMomentMorph::_pdfList. protected . Definition at line 89 of file RooMomentMorph.h. ◆ _setting. Setting RooMomentMorph::_setting. protected . Definition at line 94 of file RooMomentMorph.h. ◆ _useHorizMorph. bool RooMomentMorph::_useHorizMorph = true. protected . Definition at line 96 of file RooMomentMorph.h. ◆ _varList. RooSetProxy RooMomentMorph::_varList. protected . Definition at line 88 of file RooMomentMorph.h. ◆ m. RooRealProxy RooMomentMorph::m. protected . Definition at line 87 of file RooMomentMorph.h. Libraries for RooMomentMorph:. [legend]; The documentation for this class was generated from the following files:; roofit/roofit/inc/RooMomentMorph.h; roofit/roof,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMomentMorph.html:79566,cache,cache,79566,doc/master/classRooMomentMorph.html,https://root.cern,https://root.cern/doc/master/classRooMomentMorph.html,1,['cache'],['cache']
Performance,"StreamerElement::kWrite@ kWriteDefinition TStreamerElement.h:80; TStreamerElement::kRepeat@ kRepeatDefinition TStreamerElement.h:78; TStreamerElement::kCache@ kCacheDefinition TStreamerElement.h:77; TStreamerElement::kDoNotDelete@ kDoNotDeleteDefinition TStreamerElement.h:81; TStreamerElement::SetNewTypevirtual void SetNewType(Int_t dtype)Definition TStreamerElement.h:140; TStreamerElement::SetMaxIndexvirtual void SetMaxIndex(Int_t dim, Int_t max)set maximum index for array with dimension dimDefinition TStreamerElement.cxx:490; TStreamerElement::HasCountervirtual Bool_t HasCounter() constDefinition TStreamerElement.h:129; TStreamerElement::GetSequenceTypevoid GetSequenceType(TString &type) constFill type with the string representation of sequence information including 'cached',...Definition TStreamerElement.cxx:356; TStreamerInfoActions::TActionSequence::fActionsActionContainer_t fActionsDefinition TStreamerInfoActions.h:212; TStreamerInfo::TCompInfo::Updatevoid Update(const TClass *oldcl, TClass *newcl)Update the TClass pointer cached in this object.Definition TStreamerInfo.cxx:5644; TStreamerInfo::TCompInfo::fTypeInt_t fTypeDefinition TStreamerInfo.h:47; TStreamerInfo::TCompInfo::fClassTClass * fClassNot Owned.Definition TStreamerInfo.h:53; TStreamerInfo::TCompInfo::fOffsetInt_t fOffsetDefinition TStreamerInfo.h:49; TStreamerInfo::TCompInfo::fElemTStreamerElement * fElemNot Owned.Definition TStreamerInfo.h:51; TStreamerInfo::TCompInfo::fClassNameTString fClassNameDefinition TStreamerInfo.h:55; TStreamerInfo::TCompInfo::fMethodULongptr_t fMethodDefinition TStreamerInfo.h:52; TStreamerInfo::TCompInfo::fNewTypeInt_t fNewTypeDefinition TStreamerInfo.h:48; TStreamerInfo::TCompInfo::fLengthInt_t fLengthDefinition TStreamerInfo.h:50; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStreamerInfo::fNVirtualInfoLocInt_t fNVirtualInfoLoc! Number of virtual info location to update.Definition TStreamerInfo.h:102; TStreamerInfo::fOnFileClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:275019,cache,cached,275019,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['cache'],['cached']
Performance,"StreamerObjectAnyPointer. TStreamerObjectPointer. TStreamerSTL.  [more...]. Function documentation; TStreamerElement(); Default ctor. TStreamerElement(const char* name, const char* title, Int_t offset, Int_t dtype, const char* typeName); Create a TStreamerElement object. ~TStreamerElement(); TStreamerElement dtor. Bool_t CannotSplit() const; Returns true if the element cannot be split, false otherwise.; An element cannot be split if the corresponding class member has; the special characters ""||"" as the first characters in the; comment field. TClass * GetClassPointer() const; Returns a pointer to the TClass of this element. Int_t GetExecID() const; Returns the TExec id for the EXEC instruction in the comment field; of a TRef data member. const char * GetFullName() const; Return element name including dimensions, if any; Note that this function stores the name into a static array.; You should copy the result. void GetSequenceType(TString& type) const; Fill type with the string representation of sequence; information including 'cached','repeat','write' or; 'nodelete'. Int_t GetSize() const; Returns size of this element in bytes. TMemberStreamer * GetStreamer() const; Return the local streamer object. const char * GetTypeNameBasic() const; Return type name of this element; in case the type name is not a standard basic type, return; the basic type name known to CINT. void Init(TObject* obj = 0); Initliaze the element. Bool_t IsOldFormat(const char* newTypeName); The early 3.00/00 and 3.01/01 versions used to store; dm->GetTypeName instead of dm->GetFullTypename; if this case is detected, the element type name is modified. Bool_t IsBase() const; Return kTRUE if the element represent a base class. Bool_t IsTransient() const; Return kTRUE if the element represent an entity that is not written; to the disk (transient members, cache allocator/deallocator, etc.). void ls(Option_t* option = """") const; Print the content of the element. void SetArrayDim(Int_t dim); Set number of a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStreamerElement.html:10301,cache,cached,10301,root/html602/TStreamerElement.html,https://root.cern,https://root.cern/root/html602/TStreamerElement.html,2,['cache'],['cached']
Performance,"Streaming mechanism ensures that only one copy of each object in the tree/graph is written to the output buffer to avoid circular dependencies.; However if the object event is split into several files or into several branches of one or more Trees, normal C++ pointers cannot be used because each I/O operation will write the referenced objects.; When a TRef is used to point to a TObject *robj, for example in a class with TRef fRef;; TRefPersistent Reference link to a TObject A TRef is a lightweight object pointing to any TObject.Definition TRef.h:32; one can do: fRef = robj; //to set the pointer; This TRef and robj can be written with two different I/O calls in the same or different files, in the same or different branches of a Tree.; If the TRef is read and the referenced object has not yet been read, the TRef will return a null pointer. As soon as the referenced object will be read, the TRef will point to it. If the referenced object is contained in a TTree it can be auto-loaded using the TBranchRef mechanism, which is set up by simply calling TTree::BranchRef().; TRef also supports the complex situation where a TFile is updated multiple times on the same machine or a different machine. How does it work; A TRef is itself a TObject with an additional transient pointer fPID. When the statement fRef = robj is executed, the following actions happen:. The pointer fPID is set to the current TProcessID.; The current ObjectNumber (see below) is incremented by one.; robj::fUniqueID is set to ObjectNumber.; In the fPID object, the element fObjects[ObjectNumber] is set to robj; ref::fUniqueID is also set to ObjectNumber. After having set fRef, one can immediately return the value of robj using fRef.GetObject(). This function returns directly fObjects[fUniqueID] from the fPID object.; When the TRef is written, the process id number pidf of fPID is written in addition to the TObject part of TRef (fBits,fUniqueID).; When the TRef is read, its pointer fPID is set to the value store",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRef.html:1727,load,loaded,1727,doc/master/classTRef.html,https://root.cern,https://root.cern/doc/master/classTRef.html,1,['load'],['loaded']
Performance,"String & ; file, . EAccessMode ; mode = kFileExists . ). virtual . Find location of file in a search path. ; Return value points to TString for compatibility with Which(const char *, const char *, EAccessMode). Returns 0 in case file is not found. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1538 of file TSystem.cxx. ◆ FindHelper(). TSystem * TSystem::FindHelper ; (; const char * ; path, . void * ; dirptr = nullptr . ). protected . Create helper TSystem to handle file and directory operations that might be special for remote file access. ; Definition at line 746 of file TSystem.cxx. ◆ FreeDirectory(). void TSystem::FreeDirectory ; (; void * ; dirp). virtual . Free a directory. ; Reimplemented in TDavixSystem, TUnixSystem, TWinNTSystem, TDCacheSystem, TWebSystem, TNetXNGSystem, and TNetSystem.; Definition at line 845 of file TSystem.cxx. ◆ GetAclicMode(). TSystem::EAclicMode TSystem::GetAclicMode ; (; ); const. virtual . AclicMode indicates whether the library should be built in debug mode or optimized. ; The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library . Definition at line 3947 of file TSystem.cxx. ◆ GetAclicProperties(). Int_t TSystem::GetAclicProperties ; (; ); const. virtual . Return the ACLiC properties field. ; See EAclicProperties for details on the semantic of each bit. ; Definition at line 3867 of file TSystem.cxx. ◆ GetBeepDefaults(). void TSystem::GetBeepDefaults ; (; Int_t & ; freq, . Int_t & ; duration . ); const. inline . Definition at line 360 of file TSystem.h. ◆ GetBuildArch(). const char * TSystem::GetBuildArch ; (; ); const. virtual . Return the build architecture. ; Definition at line 3875 of file TSystem.cxx. ◆ GetBuildCompiler(). const char * TSystem::GetBuildCompiler ; (; ); const. virtual . Return the build compiler. ; Definition at line 3883 of file TSystem.cxx. ◆ GetBuildCompilerVersion(). const char * TSystem::G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:53326,optimiz,optimized,53326,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['optimiz'],['optimized']
Performance,"StringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxyalpha; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym; RooRealProxym0; RooRealProxyn; RooRealProxysigma.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCBShape.html:44165,cache,cache,44165,root/html602/RooCBShape.html,https://root.cern,https://root.cern/root/html602/RooCBShape.html,2,['cache'],['cache']
Performance,"StringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCFunction2PdfBinding_double_double_double_.html:39383,cache,cache,39383,root/html528/RooCFunction2PdfBinding_double_double_double_.html,https://root.cern,https://root.cern/root/html528/RooCFunction2PdfBinding_double_double_double_.html,2,['cache'],['cache']
Performance,"StringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumConvPdf.html:47104,cache,cache,47104,root/html602/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html602/RooNumConvPdf.html,2,['cache'],['cache']
Performance,"StringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static Long64_tTFile::fgBytesReadNumber of bytes read by all TFile objects; static Long64_tTFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TDCacheFile.html:21307,cache,cache,21307,root/html526/TDCacheFile.html,https://root.cern,https://root.cern/root/html526/TDCacheFile.html,26,['cache'],"['cache', 'cached']"
Performance,"Study::run: sample 110; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 105; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 100; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 95; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 90; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 85; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 80; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 75; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 70; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 65; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 60; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 55; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 50; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 45; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 40; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 35; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 30; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 25; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 20; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 15; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 10; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 5; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 0; [#1] INFO:ObjectHandling -- RooWorkspace::import() importing RooRealVar::fpull; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pullGauss_over_pullGauss_Int[fpull]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pullGauss_over_pullGauss_Int[fpull]_fitParData_sumc) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf804_mcstudy_constr.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf804__mcstudy__constr_8C.html:11184,optimiz,optimization,11184,doc/master/rf804__mcstudy__constr_8C.html,https://root.cern,https://root.cern/doc/master/rf804__mcstudy__constr_8C.html,2,['optimiz'],['optimization']
Performance,"Style="":""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf503_wspaceread"", ""rf503_wspaceread"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); ; c.SaveAs(""rf503_wspaceread.png""); 0x8fdb600 RooAddPdf::model = 1/1 [Auto,Clean] ; 0x91994b0/V- RooChebychev::bkg = 1 [Auto,Dirty] ; 0x880af10/V- RooRealVar::x = 5; 0x27be9c0/V- RooRealVar::a0 = 0.5; 0x2765460/V- RooRealVar::a1 = 0; 0x9279200/V- RooRealVar::bkgfrac = 0.5; 0x926e430/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x91f8100/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x880af10/V- RooRealVar::x = 5; 0x87e28d0/V- RooRealVar::mean = 5; 0x4735f60/V- RooRealVar::sigma1 = 0.5; 0x4735b70/V- RooRealVar::sig1frac = 0.8; 0x9205290/V- RooGaussian::sig2 = 1 [Auto,Dirty] ; 0x880af10/V- RooRealVar::x = 5; 0x87e28d0/V- RooRealVar::mean = 5; 0x873e5a0/V- RooRealVar::sigma2 = 1; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf503_wspaceread.py. tutorialsroofitrf503_wspaceread.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf503__wspaceread_8py.html:2739,optimiz,optimization,2739,doc/master/rf503__wspaceread_8py.html,https://root.cern,https://root.cern/doc/master/rf503__wspaceread_8py.html,2,['optimiz'],['optimization']
Performance,"StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet*_ccdCloneSet; Bool_t_ccdRefresh; RooSuperCategory*_ccdSuperSuperCategory of Common category dependents; Double_t*_ccdTable; RooArgSet_commonCatsCommon category dependents; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; TIterator*_gcIter! Iterator over gcList; TList_gcListList of component generator contexts; RooDataSet*RooAbsGenContext::_genData! Data being generated; Bool_tRooAbsGenContext::_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; RooArgSet_ownedMultiProdsOwned auxilary multi-term product PDFs; const RooProdPdf*_pdfOriginal PDF; RooRealIntegral*_pdfCcdInt; RooAbsPdf*_pdfClone; RooArgSet*_pdfCloneSet; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; TIterator*_uniIterIterator over uniform observables; RooArgSet_uniObsObservable to be generated with flat distribution; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProdGenContext(const RooProdPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). ~RooProdGenContext(); Destructor. Delete all owned subgenerator contexts. void attach(const RooArgSet& params); Attach generator to given event buffer. void initGenerator(const RooArgSet& theEve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProdGenContext.html:8116,load,load,8116,root/html528/RooProdGenContext.html,https://root.cern,https://root.cern/root/html528/RooProdGenContext.html,2,['load'],['load']
Performance,Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tTTree::fPacketSize! Number of entries in one packet for parallel root; TVirtualPerfStats*TTree::fPerfStats! pointer to the current perf stats object; TVirtualTreePlayer*TTree::fPlayer! Pointer to current Tree player; TStringfQuery; Long64_tTTree::fReadEntry! Number of the entry being processed; TSQLResult*fResult; TSQLRow*fRow; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; TSQLServer*fServer; TStringfTable; Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeSQL.html:24258,load,loading,24258,root/html534/TTreeSQL.html,https://root.cern,https://root.cern/root/html534/TTreeSQL.html,3,['load'],['loading']
Performance,"Stylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for plotting; Int_tTF1::fNDFNumber of degrees of freedom in the fit; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTF1::fNpfitsNumber of points used in the fit; Int_tTF1::fNpxNumber of points used for the graphical representation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TF1::fParErrors[fNpar] Array of errors of the fNpar parameters; Double_t*TF1::fParM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF12.html:19703,optimiz,optimization,19703,root/html528/TF12.html,https://root.cern,https://root.cern/root/html528/TF12.html,4,['optimiz'],['optimization']
Performance,"Stylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for plotting; Int_tTF1::fNDFNumber of degrees of freedom in the fit; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTF1::fNpfitsNumber of points used in the fit; Int_tTF1::fNpxNumber of points used for the graphical representation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); TFormula::TFuncGTFormula::fOptimal!pointer to optimal function; Double_t*TF1::fParErrors[fNpar] Array of errors of the fNpar parameters; Double_t*TF1::f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF12.html:20209,optimiz,optimization,20209,root/html602/TF12.html,https://root.cern,https://root.cern/root/html602/TF12.html,1,['optimiz'],['optimization']
Performance,"Suffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBukinPdf.html:2122,cache,cacheUniqueSuffix,2122,root/html534/RooBukinPdf.html,https://root.cern,https://root.cern/root/html534/RooBukinPdf.html,10,['cache'],['cacheUniqueSuffix']
Performance,"Suffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvPdf.html:4339,cache,cacheUniqueSuffix,4339,root/html534/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html534/RooNumConvPdf.html,1,['cache'],['cacheUniqueSuffix']
Performance,"Suffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DKeysPdf.html:2173,cache,cacheUniqueSuffix,2173,root/html534/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html534/Roo2DKeysPdf.html,1,['cache'],['cacheUniqueSuffix']
Performance,"Sum() [3/3]. UInt_t TClass::GetCheckSum ; (; ECheckSum ; code = kCurrentCheckSum); const. Call GetCheckSum with validity check. ; Definition at line 6505 of file TClass.cxx. ◆ GetClass() [1/6]. template<typename T > . TClass * TClass::GetClass ; (; Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Definition at line 655 of file TClass.h. ◆ GetClass() [2/6]. TClass * TClass::GetClass ; (; ClassInfo_t * ; info, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Static method returning pointer to TClass of the specified ClassInfo. ; If load is true an attempt is made to obtain the class by loading the appropriate shared library (directed by the rootmap file). If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members) Returns 0 in case class is not found. ; Definition at line 3351 of file TClass.cxx. ◆ GetClass() [3/6]. TClass * TClass::GetClass ; (; const char * ; name, . Bool_t ; load, . Bool_t ; silent, . size_t ; hint_pair_offset, . size_t ; hint_pair_size . ). static . Definition at line 2973 of file TClass.cxx. ◆ GetClass() [4/6]. TClass * TClass::GetClass ; (; const char * ; name, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Static method returning pointer to TClass of the specified class name. ; If load is true, an attempt is made to obtain the class by loading the appropriate shared library (directed by the rootmap file). If silent is 'true', do not warn about missing dictionary for the class. (typically used for classes that are used only for transient members) Returns nullptr in case class is not found. ; Definition at line 2968 of file TClass.cxx. ◆ GetClass() [5/6]. TClass * TClass::GetClass ; (; const std::type_info & ; typeinfo, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE, . size_t ; hint_pair_offset = 0, . size_t ; hint_pair_size = 0 . ). static . Return pointer to class with name. ; Definition at line 3254 of file TC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:73539,load,load,73539,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['load']
Performance,"Sum() [3/3]. UInt_t TClass::GetCheckSum ; (; ECheckSum ; code = kCurrentCheckSum); const. Call GetCheckSum with validity check. ; Definition at line 6572 of file TClass.cxx. ◆ GetClass() [1/6]. template<typename T > . TClass * TClass::GetClass ; (; Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Definition at line 655 of file TClass.h. ◆ GetClass() [2/6]. TClass * TClass::GetClass ; (; ClassInfo_t * ; info, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Static method returning pointer to TClass of the specified ClassInfo. ; If load is true an attempt is made to obtain the class by loading the appropriate shared library (directed by the rootmap file). If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members) Returns 0 in case class is not found. ; Definition at line 3418 of file TClass.cxx. ◆ GetClass() [3/6]. TClass * TClass::GetClass ; (; const char * ; name, . Bool_t ; load, . Bool_t ; silent, . size_t ; hint_pair_offset, . size_t ; hint_pair_size . ). static . Definition at line 3040 of file TClass.cxx. ◆ GetClass() [4/6]. TClass * TClass::GetClass ; (; const char * ; name, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Static method returning pointer to TClass of the specified class name. ; If load is true, an attempt is made to obtain the class by loading the appropriate shared library (directed by the rootmap file). If silent is 'true', do not warn about missing dictionary for the class. (typically used for classes that are used only for transient members) Returns nullptr in case class is not found. ; Definition at line 3035 of file TClass.cxx. ◆ GetClass() [5/6]. TClass * TClass::GetClass ; (; const std::type_info & ; typeinfo, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE, . size_t ; hint_pair_offset = 0, . size_t ; hint_pair_size = 0 . ). static . Return pointer to class with name. ; Definition at line 3321 of file TC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:73540,load,load,73540,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['load']
Performance,"Sum; }; 160 UInt_t GetCheckSum(TClass::ECheckSum code) const;; 161 Int_t GetClassVersion() const override { return fClassVersion; }; 162 Int_t GetDataMemberOffset(TDataMember *dm, TMemberStreamer *&streamer) const;; 163 TObjArray *GetElements() const override {return fElements;}; 164 TStreamerElement *GetElem(Int_t id) const override { return fComp[id].fElem; } // Return the element for the list of optimized elements (max GetNdata()); 165 TStreamerElement *GetElement(Int_t id) const override {return (TStreamerElement*)fElements->At(id);} // Return the element for the complete list of elements (max GetElements()->GetEntries()); 166 Int_t GetElementOffset(Int_t id) const override {return fCompFull[id]->fOffset;}; 167 TStreamerInfoActions::TActionSequence *GetReadMemberWiseActions(Bool_t forCollection) { return forCollection ? fReadMemberWiseVecPtr : fReadMemberWise; }; 168 TStreamerInfoActions::TActionSequence *GetReadObjectWiseActions() { return fReadObjectWise; }; 169 TStreamerInfoActions::TActionSequence *GetReadTextActions() { return fReadText; }; 170 TStreamerInfoActions::TActionSequence *GetWriteMemberWiseActions(Bool_t forCollection) { return forCollection ? fWriteMemberWiseVecPtr : fWriteMemberWise; }; 171 TStreamerInfoActions::TActionSequence *GetWriteObjectWiseActions() { return fWriteObjectWise; }; 172 TStreamerInfoActions::TActionSequence *GetWriteTextActions() { return fWriteText; }; 173 Int_t GetNdata() const {return fNdata;}; 174 Int_t GetNelement() const { return fElements->GetEntriesFast(); }; 175 Int_t GetNumber() const override { return fNumber; }; 176 Int_t GetLength(Int_t id) const {return fComp[id].fLength;}; 177 ULongptr_t GetMethod(Int_t id) const {return fComp[id].fMethod;}; 178 Int_t GetNewType(Int_t id) const {return fComp[id].fNewType;}; 179 Int_t GetOffset(const char *) const override;; 180 Int_t GetOffset(Int_t id) const override {return fComp[id].fOffset;}; 181 Version_t GetOldVersion() const override {return fOldVersion;}; 182 Int_t GetO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8h_source.html:8239,optimiz,optimized,8239,doc/master/TStreamerInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html,1,['optimiz'],['optimized']
Performance,"SumUniform (const RooArgSet &paramSet, double lo, double hi);  Request uniform smearing of sum of parameters in paramSet uniform smearing in range [lo,hi] in RooMCStudy generation cycle. ;  ; void sampleUniform (RooRealVar &param, double lo, double hi);  Request uniform smearing of param in range [lo,hi] in RooMCStudy generation cycle. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsMCStudyModule;  RooAbsMCStudyModule (const char *name, const char *title);  Constructor. ;  ;  RooAbsMCStudyModule (const RooAbsMCStudyModule &other);  Copy constructor. ;  ; bool doInitializeInstance (RooMCStudy &);  Initializer method called upon attachment to given RooMCStudy object. ;  ; virtual bool processAfterFit (Int_t);  Method called after fit has been performed. ;  ; virtual bool processBetweenGenAndFit (Int_t);  Method called after generation of toy data sample and resetting of fit parameters to initial values and before actual fit is performed. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns titl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRandomizeParamMCSModule.html:3400,perform,performed,3400,doc/master/classRooRandomizeParamMCSModule.html,https://root.cern,https://root.cern/doc/master/classRooRandomizeParamMCSModule.html,1,['perform'],['performed']
Performance,"SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3114 TClassEdit::GetNormalizedName(normalizedName, name);; 3115 }; 3116 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3117 }; 3118 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone);; 3119 if (e); 3120 return nullptr;; 3121 // Maybe this was a typedef: let's try to see if this is the case; 3122 if (!loadedcl && !ispair && !ispairbase) {; 3123 if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){; 3124 // We have a typedef: we get the name of the underlying type; 3125 auto underlyingTypeName = theDataType->GetTypeName();; 3126 // We see if we can bootstrap a class with it; 3127 auto underlyingTypeDict = TClassTable::GetDictNorm(underlyingTypeName.Data());; 3128 if (underlyingTypeDict){; 3129 loadedcl = underlyingTypeDict();; 3130 }; 3131 ; 3132 }; 3133 }; 3134 }; 3135 if (loadedcl) return loadedcl;; 3136 ; 3137 // See if the TClassGenerator can produce the TClass we need.; 3138 loadedcl = LoadClassCustom(normalizedName.c_str(),silent);; 3139 if (loadedcl) return loadedcl;; 3140 ; 3141 // We have not been able to find a loaded TClass, return the Emulated; 3142 // TClass if we have one.; 3143 if (cl) return cl;; 3144 ; 3145 if (ispair) {; 3146 if (hint_pair_offset && hint_pair_size) {; 3147 auto pairinfo = TVirtualStreamerInfo::Factory()->GenerateInfoForPair(normalizedName, silent, hint_pair_offset, hint_pair_size);; 3148 // Fall-through to allow TClass to be created when known by the interpreter; 3149 // This is used in the case where TStreamerInfo can not handle them.; 3150 if (pairinfo); 3151 return pairinfo->GetClass();; 3152 } else {; 3153 // Check if we have an STL container that might provide it.; 3154 static const size_t slen = strlen(""pair"");; 3155 static const char *associativeContainer[] = { ""map"", ""unordered_map"", ""multimap"",; 3156 ""unordered_multimap"", ""set"", ""unordered_set"", ""multiset"", ""unordered_multiset"" };; 3157 for(auto contname : associativeContainer) {; 3158",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:118982,load,loadedcl,118982,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loadedcl']
Performance,"SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3181 TClassEdit::GetNormalizedName(normalizedName, name);; 3182 }; 3183 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3184 }; 3185 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone);; 3186 if (e); 3187 return nullptr;; 3188 // Maybe this was a typedef: let's try to see if this is the case; 3189 if (!loadedcl && !ispair && !ispairbase) {; 3190 if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){; 3191 // We have a typedef: we get the name of the underlying type; 3192 auto underlyingTypeName = theDataType->GetTypeName();; 3193 // We see if we can bootstrap a class with it; 3194 auto underlyingTypeDict = TClassTable::GetDictNorm(underlyingTypeName.Data());; 3195 if (underlyingTypeDict){; 3196 loadedcl = underlyingTypeDict();; 3197 }; 3198 ; 3199 }; 3200 }; 3201 }; 3202 if (loadedcl) return loadedcl;; 3203 ; 3204 // See if the TClassGenerator can produce the TClass we need.; 3205 loadedcl = LoadClassCustom(normalizedName.c_str(),silent);; 3206 if (loadedcl) return loadedcl;; 3207 ; 3208 // We have not been able to find a loaded TClass, return the Emulated; 3209 // TClass if we have one.; 3210 if (cl) return cl;; 3211 ; 3212 if (ispair) {; 3213 if (hint_pair_offset && hint_pair_size) {; 3214 auto pairinfo = TVirtualStreamerInfo::Factory()->GenerateInfoForPair(normalizedName, silent, hint_pair_offset, hint_pair_size);; 3215 // Fall-through to allow TClass to be created when known by the interpreter; 3216 // This is used in the case where TStreamerInfo can not handle them.; 3217 if (pairinfo); 3218 return pairinfo->GetClass();; 3219 } else {; 3220 // Check if we have an STL container that might provide it.; 3221 static const size_t slen = strlen(""pair"");; 3222 static const char *associativeContainer[] = { ""map"", ""unordered_map"", ""multimap"",; 3223 ""unordered_multimap"", ""set"", ""unordered_set"", ""multiset"", ""unordered_multiset"" };; 3224 for(auto contname : associativeContainer) {; 3225",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:121733,load,loadedcl,121733,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loadedcl']
Performance,"System, Tag>& SetX (Scalar a) {; 248 fCoordinates.SetX(a);; 249 return *this;; 250 }; 251 ; 252 /**; 253 Change Y - Cartesian2D coordinates only; 254 */; 255 DisplacementVector2D<CoordSystem, Tag>& SetY (Scalar a) {; 256 fCoordinates.SetY(a);; 257 return *this;; 258 }; 259 ; 260 ; 261 /**; 262 Change R - Polar2D coordinates only; 263 */; 264 DisplacementVector2D<CoordSystem, Tag>& SetR (Scalar a) {; 265 fCoordinates.SetR(a);; 266 return *this;; 267 }; 268 ; 269 ; 270 /**; 271 Change Phi - Polar2D coordinates; 272 */; 273 DisplacementVector2D<CoordSystem, Tag>& SetPhi (Scalar ang) {; 274 fCoordinates.SetPhi(ang);; 275 return *this;; 276 }; 277 ; 278 ; 279 ; 280 // ------ Operations combining two vectors ------; 281 // -- need to have the specialized version in order to avoid; 282 ; 283 /**; 284 Return the scalar (dot) product of two displacement vectors.; 285 It is possible to perform the product for any type of vector coordinates,; 286 but they must have the same coordinate system tag; 287 */; 288 template< class OtherCoords >; 289 Scalar Dot( const DisplacementVector2D<OtherCoords,Tag> & v) const {; 290 return X()*v.X() + Y()*v.Y();; 291 }; 292 /**; 293 Return the scalar (dot) product of two vectors.; 294 It is possible to perform the product for any classes; 295 implementing x() and y() member functions; 296 */; 297 template< class OtherVector >; 298 Scalar Dot( const OtherVector & v) const {; 299 return X()*v.x() + Y()*v.y();; 300 }; 301 ; 302 ; 303 ; 304 /**; 305 Self Addition with a displacement vector.; 306 */; 307 template <class OtherCoords>; 308 DisplacementVector2D & operator+=; 309 (const DisplacementVector2D<OtherCoords,Tag> & v) {; 310 SetXY( X() + v.X(), Y() + v.Y() );; 311 return *this;; 312 }; 313 ; 314 /**; 315 Self Difference with a displacement vector.; 316 */; 317 template <class OtherCoords>; 318 DisplacementVector2D & operator-=; 319 (const DisplacementVector2D<OtherCoords,Tag> & v) {; 320 SetXY( x() - v.x(), y() - v.y() );; 321 return *this;; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2DisplacementVector2D_8h_source.html:8327,perform,perform,8327,doc/master/GenVector_2DisplacementVector2D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector2D_8h_source.html,1,['perform'],['perform']
Performance,"System.h. ◆ IsAbsoluteFileName(). Bool_t TWinNTSystem::IsAbsoluteFileName ; (; const char * ; dir). overridevirtual . Return true if dir is an absolute pathname. ; Reimplemented from TSystem.; Definition at line 2500 of file TWinNTSystem.cxx. ◆ IsPathLocal(). Bool_t TWinNTSystem::IsPathLocal ; (; const char * ; path). overridevirtual . Returns TRUE if the url in 'path' points to the local file system. ; This is used to avoid going through the NIC card for local operations. ; Reimplemented from TSystem.; Definition at line 2584 of file TWinNTSystem.cxx. ◆ Link(). int TWinNTSystem::Link ; (; const char * ; from, . const char * ; to . ). overridevirtual . Create a link from file1 to file2. ; Reimplemented from TSystem.; Definition at line 2768 of file TWinNTSystem.cxx. ◆ Load(). int TWinNTSystem::Load ; (; const char * ; module, . const char * ; entry = """", . Bool_t ; system = kFALSE . ). overridevirtual . Load a shared library. ; Returns 0 on successful loading, 1 in case lib was already loaded and -1 in case lib does not exist or in case of error. ; Reimplemented from TSystem.; Definition at line 4141 of file TWinNTSystem.cxx. ◆ LookupSID(). Long_t TWinNTSystem::LookupSID ; (; const char * ; lpszAccountName, . int ; what, . int & ; groupIdx, . int & ; memberIdx . ). private . Take the name and look up a SID so that we can get full domain/user information. ; Definition at line 3310 of file TWinNTSystem.cxx. ◆ MakeDirectory(). int TWinNTSystem::MakeDirectory ; (; const char * ; name). overridevirtual . Make a WinNT file system directory. ; Returns 0 in case of success and -1 if the directory could not be created (either already exists or illegal path name). ; Reimplemented from TSystem.; Definition at line 1913 of file TWinNTSystem.cxx. ◆ mkdir(). int TWinNTSystem::mkdir ; (; const char * ; name, . Bool_t ; recursive = kFALSE . ). overridevirtual . Make a file system directory. ; Returns 0 in case of success and -1 if the directory could not be created (either already e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:61510,load,loading,61510,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,2,['load'],"['loaded', 'loading']"
Performance,"SystemDefinition TSystem.h:561; TThread.h; TTimer.h; TUrl.h; mime_typeconst char * mime_typeDefinition civetweb.c:8027; ext_lensize_t ext_lenDefinition civetweb.c:8026; free#define freeDefinition civetweb.c:1539; extensionconst char * extensionDefinition civetweb.c:8025; builtin_mime_typesstatic const struct @142 builtin_mime_types[]; malloc#define mallocDefinition civetweb.c:1536; TCivetwebTHttpEngine implementation, based on civetweb embedded server.Definition TCivetweb.h:21; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TFastCgiTHttpEngine implementation, based on fastcgi package.Definition TFastCgi.h:20; THttpCallArgContains arguments for single HTTP call.Definition THttpCallArg.h:27; THttpCallArg::Set404void Set404()mark reply as 404 error - page/request not exists or refusedDefinition THttpCallArg.h:163; THttpCallArg::kZipAlways@ kZipAlwaysDefinition THttpCallArg.h:38; THttpEngineAbstract class for implementing http protocol for THttpServer.Definition THttpEngine.h:19; THttpEngine::SetServervoid SetServer(THttpServer *serv)Definition THttpEngine.h:27; THttpEngine::Createvirtual Bool_t Create(const char *)Method to create all components of engine.Definition THttpEngine.h:37; THttpLongPollEngineEmulation of websocket with long poll requests.Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:55722,load,load,55722,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['load'],['load']
Performance,"T *previous_grad, T *previous_g2, T *previous_gstep) const;  In some cases, the gradient algorithm will use information from the previous step, these can be passed in with this overload. ;  ; bool HasGradient () const;  ; virtual bool returnsInMinuit2ParameterSpace () const;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionMultiDimTempl< T >; virtual ~IBaseFunctionMultiDimTempl ()=default;  ; T operator() (const T *x) const;  Evaluate the function at a point x[]. ;  . Private Member Functions;  MinimTransformFunction (const MinimTransformFunction &);  ; double DoDerivative (const double *x, unsigned int icoord) const override;  calculate derivatives ;  ; double DoEval (const double *x) const override;  function evaluation ;  ; MinimTransformFunction & operator= (const MinimTransformFunction &);  . Private Attributes; const IMultiGradFunction * fFunc;  user function ;  ; std::vector< unsigned int > fIndex;  vector with external indices for internal variables ;  ; std::vector< MinimTransformVariable > fVariables;  vector of variable settings and transformation function ;  ; std::vector< double > fX;  internal cached of external values ;  . #include <Math/MinimTransformFunction.h>. Inheritance diagram for ROOT::Math::MinimTransformFunction:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ BaseFunc. typedef ROOT::Math::IMultiGradFunction::BaseFunc ROOT::Math::MinimTransformFunction::BaseFunc. Definition at line 46 of file MinimTransformFunction.h. ◆ BaseGradFunc. typedef ROOT::Math::IMultiGradFunction ROOT::Math::MinimTransformFunction::BaseGradFunc. Definition at line 45 of file MinimTransformFunction.h. Constructor & Destructor Documentation. ◆ MinimTransformFunction() [1/2]. ROOT::Math::MinimTransformFunction::MinimTransformFunction ; (; const IMultiGradFunction * ; f, . const std::vector< ROOT::Math::EMinimVariableType > & ; types, . const std::vector< double > & ; valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimTransformFunction.html:4886,cache,cached,4886,doc/master/classROOT_1_1Math_1_1MinimTransformFunction.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimTransformFunction.html,1,['cache'],['cached']
Performance,"T > ; Int_t SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr);  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T *add, TBranch **ptr=nullptr);  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr=nullptr);  Change branch address, dealing with clone trees properly. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual void SetBranchStatus (const char *bname, bool status=true, UInt_t *found=nullptr);  Set branch status to Process or DoNotProcess. ;  ; virtual Int_t SetCacheEntryRange (Long64_t first, Long64_t last);  interface to TTreeCache to set the cache entry range ;  ; virtual void SetCacheLearnEntries (Int_t n=10);  Interface to TTreeCache to set the number of entries for the learning phase. ;  ; virtual Int_t SetCacheSize (Long64_t cachesize=-1);  Set maximum size of the file cache . ;  ; virtual void SetChainOffset (Long64_t offset=0);  ; virtual void SetCircular (Long64_t maxEntries);  Enable/Disable circularity for this tree. ;  ; virtual void SetClusterPrefetch (bool enabled);  ; virtual void SetDebug (Int_t level=1, Long64_t min=0, Long64_t max=9999999);  Set the debug level and the debug range. ;  ; virtual void SetDefaultEntryOffsetLen (Int_t newdefault, bool updateExisting=false);  Update the default value for the branch's fEntryOffsetLen. ;  ; virtual void SetDirectory (TDirectory *dir);  Change the tree's directory. ;  ; virtual Long64_t SetEntries (Long64_t n=-1);  Change number of entries in the tree. ;  ; virtual void SetEntryList (TEntryList *list, Option_t *opt="""");  Set an EntryList. ;  ; virtual void SetEstimate (Long64_t nentri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:38678,cache,cache,38678,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,5,['cache'],['cache']
Performance,"T > ; Int_t SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr);  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T *add, TBranch **ptr=nullptr);  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr=nullptr);  Change branch address, dealing with clone trees properly. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual void SetBranchStatus (const char *bname, bool status=true, UInt_t *found=nullptr);  Set branch status to Process or DoNotProcess. ;  ; virtual Int_t SetCacheEntryRange (Long64_t first, Long64_t last);  interface to TTreeCache to set the cache entry range ;  ; virtual void SetCacheLearnEntries (Int_t n=10);  Interface to TTreeCache to set the number of entries for the learning phase. ;  ; virtual Int_t SetCacheSize (Long64_t cachesize=-1);  Set maximum size of the file cache . ;  ; virtual void SetChainOffset (Long64_t offset=0);  ; virtual void SetCircular (Long64_t maxEntries);  Enable/Disable circularity for this tree. ;  ; virtual void SetClusterPrefetch (bool enabled);  ; virtual void SetDebug (Int_t level=1, Long64_t min=0, Long64_t max=9999999);  Set the debug level and the debug range. ;  ; virtual void SetDefaultEntryOffsetLen (Int_t newdefault, bool updateExisting=false);  Update the default value for the branch's fEntryOffsetLen. ;  ; virtual void SetDirectory (TDirectory *dir);  Change the tree's directory. ;  ; virtual void SetEntryList (TEntryList *list, Option_t *opt="""");  Set an EntryList. ;  ; virtual void SetEstimate (Long64_t nentries=1000000);  Set number of entries to estimate variable limits. ;  ; virtual void SetEve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHbookTree.html:21281,cache,cache,21281,doc/master/classTHbookTree.html,https://root.cern,https://root.cern/doc/master/classTHbookTree.html,1,['cache'],['cache']
Performance,"T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; UInt_t GetImplicitMTPoolSize ();  Returns the size of the pool used for implicit multi-threading. ;  ; TString & GetMacroPath ();  ; TROOT * GetROOT ();  ; void GetRuleIncludes (std::list< std::string > &result);  Get the list of includes specified in the shema rules. ;  ; UInt_t GetThreadPoolSize ();  Returns the size of ROOT's thread pool. ;  ; bool HasValidDataMembers (SchemaRuleMap_t &rule, MembersTypeMap_t &members, std::string &error_string);  Check if given rule contains references to valid data members. ;  ; Bool_t IsImplicitMTEnabled ();  Returns true if the implicit multi-threading in ROOT is enabled. ;  ; template<class T > ; TSeq< T > MakeSeq (T begin, T end, T step=1);  ; template<class T > ; TSeq< T > MakeSeq (T end);  ; bool ParseRule (std::string command, ROOT::Internal::MembersMap_t &result, std::string &error_string);  Parse the schema rule as specified in the LinkDef file. ;  ; void ProcessReadPragma (const char *args, std::string &error_string);  I am being called when a read pragma is encountered. ;  ; void ProcessReadRawPragma (const char *args, std::string &error_string);  I am being called then a readraw pragma is encountered. ;  ; TNamed * RegisterClassTemplate (const char *name, const char *file, Int_t line);  Global function to register the implementation file and line of a class template (i.e. ;  ; void RemoveClass (const char *cname);  Global function called by the dtor of a class's init class (see the ClassImp macro). ;  ; void ResetClassVersion (TClass *, const char *, Short_t);  Global function to update the v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:9316,multi-thread,multi-threading,9316,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; UInt_t GetImplicitMTPoolSize ();  Returns the size of the pool used for implicit multi-threading. ;  ; TString & GetMacroPath ();  ; TROOT * GetROOT ();  ; void GetRuleIncludes (std::list< std::string > &result);  Get the list of includes specified in the shema rules. ;  ; UInt_t GetThreadPoolSize ();  Returns the size of ROOT's thread pool. ;  ; bool HasValidDataMembers (SchemaRuleMap_t &rule, MembersTypeMap_t &members, std::string &error_string);  Check if given rule contains references to valid data members. ;  ; Bool_t IsImplicitMTEnabled ();  Returns true if the implicit multi-threading in ROOT is enabled. ;  ; template<class T > ; TSeq< T > MakeSeq (T begin, T end, T step=1);  ; template<class T > ; TSeq< T > MakeSeq (T end);  ; bool ParseRule (std::string command, ROOT::Internal::MembersMap_t &result, std::string &error_string);  Parse the schema rule as specified in the LinkDef file. ;  ; void ProcessReadPragma (const char *args, std::string &error_string);  I am being called when a read pragma is encountered. ;  ; void ProcessReadRawPragma (const char *args, std::string &error_string);  I am being called then a readraw pragma is encountered. ;  ; template<typename T , typename Range_t > ; RRangeCast< T, true, Range_t > RangeDynCast (Range_t &&coll);  Takes any collection that can be used in range-based loops and applies dynamic_cast<T> to each element. ;  ; template<typename T , typename U , std::size_t N> ; RRangeCast< T, true, std::span< U > > RangeDynCast (U(&arr)[N]);  ; template<typename T , typename Range_t > ; RRangeCast< T, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:10632,multi-thread,multi-threading,10632,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"T file in such a way that its inspection can be done outside the job that generated it. Example of use: {; TFile *f = TFile::Open(""RelValMinBias-GEN-SIM-RECO.root"");; T = (TTree*)f->Get(""Events"");; Long64_t nentries = T->GetEntries();; T->SetCacheSize(10000000);; T->SetCacheEntryRange(0,nentries);; T->AddBranchToCache(""*"");; //; TTreePerfStats *ps= new TTreePerfStats(""ioperf"",T);; //; for (Int_t i=0;i<nentries;i++) {; T->GetEntry(i);; }; ps->SaveAs(""cmsperf.root"");; }; f#define f(i)Definition RSha256.hxx:104; Long64_tlong long Long64_tDefinition RtypesCore.h:69; nentriesint nentriesDefinition THbookFile.cxx:91; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TTreePerfStatsTTree I/O performance measurement.Definition TTreePerfStats.h:38; TTreePerfStats::SaveAsvoid SaveAs(const char *filename="""", Option_t *option="""") const overrideSave this object to filename.Definition TTreePerfStats.cxx:647; TTreePerfStats::TTreePerfStatsTTreePerfStats()default constructor (used when reading an object only)Definition TTreePerfStats.cxx:107; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; int; then, in a root interactive session, one can do: root > TFile f(""cmsperf.root"");; root > ioperf->Draw();; root > ioperf->Print();; The Draw or Print functions print the following information:; TreeCache = TTree cache size in MBytes; N leaves = Number of leaves in the TTree; ReadTotal = Total number of zipped bytes read; ReadUnZip = Total number of unzipped bytes read; ReadCalls = Total number of disk reads; ReadSize = Average read size in KBytes; Readahead = Readahead size in KBytes; Readextra = Readahead overhead in percent; Real Time = Real Time in seconds; CPU Time ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePerfStats.html:1816,perform,performance,1816,doc/master/classTTreePerfStats.html,https://root.cern,https://root.cern/doc/master/classTTreePerfStats.html,1,['perform'],['performance']
Performance,"T object that you own through its associated TClass:; myobject.IsA().Destructor(myobject); which will send out the deletion notification to the system (thus you do not need to care anymore at this point about Python reference counting, the object will go, even if it’s reference count it non-zero), and free the memory.; 19.1.7 Performance; The performance of PyROOT when programming with ROOT in Python is similar to that of Cling. Differences occur mainly because of differences in the respective languages: C++ is much harder to parse, but once parsed, it is much easier to optimize. Consequently, individual calls to ROOT are typically faster from PyROOT, whereas loops are typically slower.; When programming in Python, the modus operandi is to consider performance generally “good enough” on the outset, and when it turns out that, it is not good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masses in Python, use TLorentzVector instead. Moreover, before you start optimizing, make sure that you have run a profiler to find out where the bottlenecks are. Some performance, without cost in terms of programmer effort, may be gained by using psyco, see the next link: http://psyco.sourceforge.net, a Python just in time compiler (JIT). Note, however, that psyco is limited to Intel i386 CPUs. Since psyco optimizes Python, not PyROOT calls; it generally does not improve performance that much if most of your code consists of ROOT API calls. Mathematical computations in Python, on the other hand, benefit a lot.; Every c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1063397,optimiz,optimization,1063397,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimization']
Performance,T-10936] - Build fails with cuDNN 8; [ROOT-10942] - [DF] Regression in recognition of nested branch names; [ROOT-10944] - hadd: wrong TH2 sum with x-labels only; [ROOT-10946] - Error messages from RooMomentMorphND; [ROOT-10956] - New jupyroot missing jupyterlab fixes in pyroot_legacy - Causes jsroot to fail in jupyterlab; [ROOT-10962] - Uncaught exceptions from RDataFrame operations exit root prompt.; [ROOT-10963] - [Tree] TLeaf::GetName and TLeaf::GetFullName disagree on leaf name; [ROOT-10964] - README/INSTALL should point to web; [ROOT-10969] - Can not compile ROOT macro on Win10: picking up paths to other SW; [ROOT-10982] - ODR Violation in TMVA; [ROOT-10987] - RooFit’s caching can lead to wrong results when batch computations used.; [ROOT-10993] - ROOT fails in loading nlohmann/json; [ROOT-10994] - TFormula::DoEval and DoEvalVec have a thread safety issue; [ROOT-10995] - Possible data race in TFormula::TFormula() constructor; [ROOT-11000] - rootcling fails for Gaudi classes; [ROOT-11001] - unable to create TChain on ROOT file; [ROOT-11005] - ROOT crashes when creating a TCanvas with gDebug=1; [ROOT-11009] - RDataFrame Silent “bugs” with assignment in Filter expressions; [ROOT-11013] - “Impossible code path” in TGenCollectionProxy.cxx when using rootcling; [ROOT-11015] - OpenGL rendering is incorrect for “pgon - pgon”; [ROOT-10830] - vector<string> behaviour in loops in PyROOT 6.20 vs 6.22; [ROOT-9559] - [DF] Treat indexed Friend trees; [ROOT-10832] - Make TH1::GetCumulative account for underflows and overflows; [ROOT-8013] - equalising roofit tutorials for easier digestion; [ROOT-8142] - Provide corrupt line when XML parsing fails; [ROOT-10022] - [DF] Add support for TBranchObjects (e.g. branches containing TH2F); [ROOT-10781] - Performance penalty from RooRealVar not allowing to use hash table on RooLinkedList member; [#6408] - Creating RooDataSet causes SegFault; [#6529] - segfault in RooWorkspace::import; [#6489] - Test Issue; [#6540] - Crash message should p,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:37496,load,loading,37496,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['load'],['loading']
Performance,"T->GetListOfClassGenerators());; 5807 TClassGenerator *gen;; 5808 while ((gen = (TClassGenerator*) next())) {; 5809 TClass *cl = gen->GetClass(requestedname, kTRUE, silent);; 5810 if (cl) {; 5811 cl->PostLoadCheck();; 5812 return cl;; 5813 }; 5814 }; 5815 return nullptr;; 5816}; 5817 ; 5818////////////////////////////////////////////////////////////////////////////////; 5819/// Try to load the ClassInfo if available. This function may require parsing; 5820/// the header file and/or loading data from the clang pcm. If further calls to; 5821/// this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set; 5822/// to false.; 5823 ; 5824void TClass::LoadClassInfo() const; 5825{; 5826 R__LOCKGUARD(gInterpreterMutex);; 5827 ; 5828 // Return if another thread already loaded the info; 5829 // while we were waiting for the lock; 5830 if (!fCanLoadClassInfo || TestBit(kLoading)); 5831 return;; 5832 ; 5833 bool autoParse = !gInterpreter->IsAutoParsingSuspended();; 5834 ; 5835 if (autoParse); 5836 gInterpreter->AutoParse(GetName());; 5837 ; 5838 if (!fClassInfo); 5839 gInterpreter->SetClassInfo(const_cast<TClass *>(this));; 5840 ; 5841 if (autoParse && !fClassInfo) {; 5842 if (fImplFileLine == -1 && fClassVersion == 0) {; 5843 // We have a 'transient' class with a ClassDefInline and apparently no interpreter; 5844 // information. Since it is transient, it is more than likely that the lack; 5845 // will be harmles.; 5846 } else {; 5847 ::Error(""TClass::LoadClassInfo"", ""no interpreter information for class %s is available""; 5848 "" even though it has a TClass initialization routine."",; 5849 fName.Data());; 5850 }; 5851 return;; 5852 }; 5853 ; 5854 fCanLoadClassInfo = false;; 5855}; 5856 ; 5857////////////////////////////////////////////////////////////////////////////////; 5858/// Store class description on I/O buffer.; 5859 ; 5860void TClass::Store(TBuffer &b) const; 5861{; 5862 b.WriteString(GetName());; 5863}; 5864 ; 5865/////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:223276,load,loaded,223276,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"T->GetListOfClassGenerators());; 5874 TClassGenerator *gen;; 5875 while ((gen = (TClassGenerator*) next())) {; 5876 TClass *cl = gen->GetClass(requestedname, kTRUE, silent);; 5877 if (cl) {; 5878 cl->PostLoadCheck();; 5879 return cl;; 5880 }; 5881 }; 5882 return nullptr;; 5883}; 5884 ; 5885////////////////////////////////////////////////////////////////////////////////; 5886/// Try to load the ClassInfo if available. This function may require parsing; 5887/// the header file and/or loading data from the clang pcm. If further calls to; 5888/// this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set; 5889/// to false.; 5890 ; 5891void TClass::LoadClassInfo() const; 5892{; 5893 R__LOCKGUARD(gInterpreterMutex);; 5894 ; 5895 // Return if another thread already loaded the info; 5896 // while we were waiting for the lock; 5897 if (!fCanLoadClassInfo || TestBit(kLoading)); 5898 return;; 5899 ; 5900 bool autoParse = !gInterpreter->IsAutoParsingSuspended();; 5901 ; 5902 if (autoParse); 5903 gInterpreter->AutoParse(GetName());; 5904 ; 5905 if (!fClassInfo); 5906 gInterpreter->SetClassInfo(const_cast<TClass *>(this));; 5907 ; 5908 if (autoParse && !fClassInfo) {; 5909 if (fImplFileLine == -1 && fClassVersion == 0) {; 5910 // We have a 'transient' class with a ClassDefInline and apparently no interpreter; 5911 // information. Since it is transient, it is more than likely that the lack; 5912 // will be harmles.; 5913 } else {; 5914 ::Error(""TClass::LoadClassInfo"", ""no interpreter information for class %s is available""; 5915 "" even though it has a TClass initialization routine."",; 5916 fName.Data());; 5917 }; 5918 return;; 5919 }; 5920 ; 5921 fCanLoadClassInfo = false;; 5922}; 5923 ; 5924////////////////////////////////////////////////////////////////////////////////; 5925/// Store class description on I/O buffer.; 5926 ; 5927void TClass::Store(TBuffer &b) const; 5928{; 5929 b.WriteString(GetName());; 5930}; 5931 ; 5932/////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:226027,load,loaded,226027,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"T. ; Definition at line 37 of file RBrowserData.hxx. Public Member Functions;  RBrowserData ();  Default constructor. ;  ;  RBrowserData (std::shared_ptr< Browsable::RElement > elem);  ; virtual ~RBrowserData ();  Destructor. ;  ; void ClearCache ();  Clear internal objects cache. ;  ; void CreateDefaultElements ();  Create default elements shown in the RBrowser. ;  ; Browsable::RElementPath_t DecomposePath (const std::string &path, bool relative_to_work_element);  Decompose path to elements Returns array of names for each element in the path, first element either ""/"" or ""."" If returned array empty - it is error. ;  ; std::shared_ptr< Browsable::RElement > GetElement (const std::string &str);  Returns element with path, specified as string. ;  ; std::shared_ptr< Browsable::RElement > GetElementFromTop (const Browsable::RElementPath_t &path);  Returns element with path, specified as Browsable::RElementPath_t. ;  ; std::shared_ptr< Browsable::RElement > GetSubElement (const Browsable::RElementPath_t &path);  Returns sub-element starting from top, using cached data. ;  ; const Browsable::RElementPath_t & GetWorkingPath () const;  ; std::string ProcessRequest (const RBrowserRequest &request);  Process browser request, returns string with JSON of RBrowserReply data. ;  ; bool RemoveFromCache (const Browsable::RElementPath_t &path);  Remove path (and all sub-paths) from cache Returns true if any element was removed. ;  ; bool RemoveFromCache (void *obj);  Remove object from cache If nullptr specified - removes no-longer-valid elements Returns true if any element was removed. ;  ; void SetTopElement (std::shared_ptr< Browsable::RElement > elem);  set top element for browsing ;  ; void SetWorkingPath (const Browsable::RElementPath_t &path);  set working directory relative to top element ;  . Private Member Functions; bool ProcessBrowserRequest (const RBrowserRequest &request, RBrowserReply &reply);  Process browser request. ;  ; void ResetLastRequestData (bool with_element)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RBrowserData.html:1435,cache,cached,1435,doc/v632/classROOT_1_1RBrowserData.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RBrowserData.html,2,['cache'],['cached']
Performance,"T2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs resources that are taken by using the default error handler.Definition TErrorDefaultHandler.cxx:47; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::GetMacroPathTString & GetMacroPath()Definition TROOT.cxx:476; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; ROOT::EnableThreadSafetyvoid EnableThreadSafety()Enable support for multi-threading within the ROOT code in particular, enables the global mutex to ma...Definition TROOT.cxx:501; ROOT::GetROOTTROOT * GetROOT()Definition TROOT.cxx:472; ROOT::DisableImplicitMTvoid DisableImplicitMT()Disables the implicit multi-threading in ROOT (see EnableImplicitMT).Definition TROOT.cxx:556; TClassEdit::GetNormalizedNamevoid GetNormalizedName(std::string &norm_name, std::string_view name)Return the normalized name.Definition TClassEdit.cxx:854; v@ vDefinition rootcling_impl.cxx:3699; FileStat_tDefinition TSystem.h:122; FileStat_t::fModeInt_t fModeDefinition TSystem.h:125; socketDefinition civetweb.c:1893; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4. corebasesrcTROOT.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:07 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:173534,multi-thread,multi-threading,173534,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['multi-thread'],['multi-threading']
Performance,"T::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:21277,perform,perform,21277,root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,1,['perform'],['perform']
Performance,"T::Math::IBaseParam&); ROOT::Math::IParametricFunctionMultiDimIParametricFunctionMultiDim(); ROOT::Math::IParametricFunctionMultiDimIParametricFunctionMultiDim(ROOT::Math::IParametricFunctionMultiDim&&); ROOT::Math::IParametricFunctionMultiDimIParametricFunctionMultiDim(const ROOT::Math::IParametricFunctionMultiDim&); virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT::Math::IParametricFunctionMultiDim&); ROOT::Math::IParametricFunctionMultiDim&operator=(ROOT::Math::IParametricFunctionMultiDim&&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(const double* x) const; virtual doubleDoEvalPar(const double* x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. return DoEvalPar(x, p). double DoEval(const double* x) const. Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IParametricFunctionMultiDim.html:3062,cache,cached,3062,root/html602/ROOT__Math__IParametricFunctionMultiDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IParametricFunctionMultiDim.html,1,['cache'],['cached']
Performance,"T::Math::IBaseParam&); ROOT::Math::IParametricFunctionMultiDimIParametricFunctionMultiDim(); ROOT::Math::IParametricFunctionMultiDimIParametricFunctionMultiDim(ROOT::Math::IParametricFunctionMultiDim&&); ROOT::Math::IParametricFunctionMultiDimIParametricFunctionMultiDim(const ROOT::Math::IParametricFunctionMultiDim&); virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT::Math::IParametricFunctionMultiDim&); ROOT::Math::IParametricFunctionMultiDim&operator=(ROOT::Math::IParametricFunctionMultiDim&&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(const double* x) const; virtual doubleDoEvalPar(const double* x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. return DoEvalPar(x, p). double DoEval(const double* x) const. Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__IParametricFunctionMultiDim.html:3062,cache,cached,3062,root/html604/ROOT__Math__IParametricFunctionMultiDim.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__IParametricFunctionMultiDim.html,1,['cache'],['cached']
Performance,"T::RWebWindow::GetYint GetY() constreturns configured window Y position (-1 - default)Definition RWebWindow.hxx:290; ROOT::RWebWindow::fNativeOnlyConnbool fNativeOnlyConn! only native connection are allowed, created by Show() methodDefinition RWebWindow.hxx:154; ROOT::RWebWindow::GetManagerstd::shared_ptr< RWebWindowsManager > GetManager() constReturns window manager.Definition RWebWindow.hxx:251; ROOT::RWebWindow::fConnConnectionsList_t fConn! list of all accepted connectionsDefinition RWebWindow.hxx:150; ROOT::RWebWindow::fConnCallbackWebWindowConnectCallback_t fConnCallback! callback for connect eventDefinition RWebWindow.hxx:157; ROOT::RWebWindow::CheckPendingConnectionsvoid CheckPendingConnections()Check if started process(es) establish connection.Definition RWebWindow.cxx:624; ROOT::RWebWindow::fClearOnClosestd::shared_ptr< void > fClearOnClose! entry which is cleared when last connection is closedDefinition RWebWindow.hxx:176; ROOT::RWebWindow::fInputQueueMutexstd::mutex fInputQueueMutex! mutex to protect input queueDefinition RWebWindow.hxx:165; ROOT::RWebWindow::_MakeSendHeaderstd::string _MakeSendHeader(std::shared_ptr< WebConn > &conn, bool txt, const std::string &data, int chid)Internal method to prepare text part of send data Should be called under locked connection mutex.Definition RWebWindow.cxx:1107; ROOT::RWebWindow::timestamp_tstd::chrono::time_point< std::chrono::system_clock > timestamp_tDefinition RWebWindow.hxx:60; ROOT::RWebWindow::SetMaxQueueLengthvoid SetMaxQueueLength(unsigned len=10)configures maximal queue length of data which can be held by windowDefinition RWebWindow.hxx:300; ROOT::RWebWindow::ProcessWSbool ProcessWS(THttpCallArg &arg)Processing of websockets call-backs, invoked from RWebWindowWSHandler Method invoked from http server...Definition RWebWindow.cxx:736; ROOT::RWebWindow::HasConnectionbool HasConnection(unsigned connid=0, bool only_active=true) constreturns true if specified connection id existsDefinition RWebWindow.cxx:141",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:40005,queue,queueDefinition,40005,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['queue'],['queueDefinition']
Performance,"T::RWebWindow::GetYint GetY() constreturns configured window Y position (-1 - default)Definition RWebWindow.hxx:293; ROOT::RWebWindow::fNativeOnlyConnbool fNativeOnlyConn! only native connection are allowed, created by Show() methodDefinition RWebWindow.hxx:157; ROOT::RWebWindow::GetManagerstd::shared_ptr< RWebWindowsManager > GetManager() constReturns window manager.Definition RWebWindow.hxx:254; ROOT::RWebWindow::fConnConnectionsList_t fConn! list of all accepted connectionsDefinition RWebWindow.hxx:153; ROOT::RWebWindow::fConnCallbackWebWindowConnectCallback_t fConnCallback! callback for connect eventDefinition RWebWindow.hxx:160; ROOT::RWebWindow::CheckPendingConnectionsvoid CheckPendingConnections()Check if started process(es) establish connection.Definition RWebWindow.cxx:625; ROOT::RWebWindow::fClearOnClosestd::shared_ptr< void > fClearOnClose! entry which is cleared when last connection is closedDefinition RWebWindow.hxx:179; ROOT::RWebWindow::fInputQueueMutexstd::mutex fInputQueueMutex! mutex to protect input queueDefinition RWebWindow.hxx:168; ROOT::RWebWindow::_MakeSendHeaderstd::string _MakeSendHeader(std::shared_ptr< WebConn > &conn, bool txt, const std::string &data, int chid)Internal method to prepare text part of send data Should be called under locked connection mutex.Definition RWebWindow.cxx:1140; ROOT::RWebWindow::timestamp_tstd::chrono::time_point< std::chrono::system_clock > timestamp_tDefinition RWebWindow.hxx:62; ROOT::RWebWindow::SetMaxQueueLengthvoid SetMaxQueueLength(unsigned len=10)configures maximal queue length of data which can be held by windowDefinition RWebWindow.hxx:303; ROOT::RWebWindow::ProcessWSbool ProcessWS(THttpCallArg &arg)Processing of websockets call-backs, invoked from RWebWindowWSHandler Method invoked from http server...Definition RWebWindow.cxx:737; ROOT::RWebWindow::HasConnectionbool HasConnection(unsigned connid=0, bool only_active=true) constreturns true if specified connection id existsDefinition RWebWindow.cxx:145",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:40150,queue,queueDefinition,40150,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['queue'],['queueDefinition']
Performance,"T::TMetaUtils::Info(nullptr, ""Using linkdef file: %s\n"", linkdefFilename.c_str());; 4751 file.close();; 4752 } else {; 4753 ROOT::TMetaUtils::Error(nullptr, ""Linkdef file %s couldn't be opened!\n"", linkdefFilename.c_str());; 4754 }; 4755 ; 4756 selectionRules.SetSelectionFileType(SelectionRules::kLinkdefFile);; 4757 }; 4758 // If there is no linkdef file, we added the 'default' #pragma to; 4759 // interpPragmaSource and we still need to process it.; 4760 ; 4761 LinkdefReader ldefr(interp, constructorTypes);; 4762 clingArgs.push_back(""-Ietc/cling/cint""); // For multiset and multimap; 4763 ; 4764 if (!ldefr.Parse(selectionRules, interpPragmaSource, clingArgs,; 4765 llvmResourceDir.c_str())) {; 4766 ROOT::TMetaUtils::Error(nullptr, ""Parsing #pragma failed %s\n"", linkdefFilename.c_str());; 4767 rootclingRetCode += 1;; 4768 } else {; 4769 ROOT::TMetaUtils::Info(nullptr, ""#pragma successfully parsed.\n"");; 4770 }; 4771 ; 4772 if (!ldefr.LoadIncludes(extraIncludes)) {; 4773 ROOT::TMetaUtils::Error(nullptr, ""Error loading the #pragma extra_include.\n"");; 4774 return 1;; 4775 }; 4776 ; 4777 } else if (isSelXML) {; 4778 ; 4779 selectionRules.SetSelectionFileType(SelectionRules::kSelectionXMLFile);; 4780 ; 4781 std::ifstream file(linkdefFilename.c_str());; 4782 if (file.is_open()) {; 4783 ROOT::TMetaUtils::Info(nullptr, ""Selection XML file\n"");; 4784 ; 4785 XMLReader xmlr(interp);; 4786 if (!xmlr.Parse(linkdefFilename.c_str(), selectionRules)) {; 4787 ROOT::TMetaUtils::Error(nullptr, ""Parsing XML file %s\n"", linkdefFilename.c_str());; 4788 return 1; // Return here to propagate the failure up to the build system; 4789 } else {; 4790 ROOT::TMetaUtils::Info(nullptr, ""XML file successfully parsed\n"");; 4791 }; 4792 file.close();; 4793 } else {; 4794 ROOT::TMetaUtils::Error(nullptr, ""XML file %s couldn't be opened!\n"", linkdefFilename.c_str());; 4795 }; 4796 ; 4797 } else {; 4798 ; 4799 ROOT::TMetaUtils::Error(nullptr, ""Unrecognized selection file: %s\n"", linkdefFilename.c_str());; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:195858,load,loading,195858,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['load'],['loading']
Performance,"TAbsolute Deviation BDT Loss Function ;  CAbsValue;  CBDTEventWrapper;  CBinarySearchTreeA simple Binary search tree including a volume search method ;  CBinarySearchTreeNodeNode for the BinarySearch or Decision Trees ;  CBinaryTreeBase class for BinarySearch and Decision Trees ;  CCCPrunerA helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) ;  ►CCCTreeWrapper;  CCCTreeNode;  CClassificationClass to perform two class classification ;  CClassificationResultClass to save the results of the classifier ;  CClassifierFactoryThis is the MVA factory ;  CClassInfoClass that contains all the information of a class ;  Ccompose_binary_t;  Ccompose_unary_t;  ►CConfigSingleton class for global configuration settings used by TMVA ;  CIONames;  CVariablePlotting;  CConfigurable;  CConvergenceTestCheck for convergence ;  CCostComplexityPruneToolA class to prune a decision tree using the Cost Complexity method ;  CCrossEntropyImplementation of the CrossEntropy as separation criterion ;  CCrossValidationClass to perform cross validation, splitting the dataloader into folds ;  CCrossValidationResultClass to save the results of cross validation, the metric for the classification ins ROC and you can ROC curves ROC integrals, ROC average and ROC standard deviation ;  CDataInputHandlerClass that contains all the data information ;  CDataLoader;  CDataSetClass that contains all the data information ;  ►CDataSetFactoryClass that contains all the data information ;  CEventStats;  CDataSetInfoClass that contains all the data information ;  CDataSetManagerClass that contains all the data information ;  CDecisionTreeImplementation of a Decision Tree ;  CDecisionTreeNode;  CDeleteFunctor_t;  CDTNodeTrainingInfo;  CEnvelopeAbstract base class for all high level ml algorithms, you can book ml methods like BDT, MLP ;  CEvent;  CExpectedErrorPruneToolA helper class to prune a decision tree using the expected error (C4.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:77225,perform,perform,77225,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['perform'],['perform']
Performance,"TAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tTTree::fFlushedBytesNumber of autoflushed bytes; UInt_tTTree::fFriendLockStatus! Record which method is locking the friend recursion; TList*TTree::fFriendspointer to list of friend elements; TArrayITTree::fIndexIndex of sorted values; TArrayDTTree::fIndexValuesSorted index values; TObjArrayTTree::fLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tTChain::fNtreesNumber of trees; Int_tTTree::fPacketSize! Number of entries in one packet for parallel root; TVirtualTreePlayer*TTree::fPlayer! Pointer to current Tree player; TChain*TChain::fProofChain! chain proxy when going to be processed by PROOF; Long64_tTTree::fReadEntry! Number of the entry being processed; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; TDSet*fSetTDSet; TList*TChain::fStatus-> List of active/inactive branches (TChainElement, owned); Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TTree*TChain::fTree! Pointer to current tree (Note: We do *not* own this tree.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofChain.html:24191,load,loading,24191,root/html528/TProofChain.html,https://root.cern,https://root.cern/root/html528/TProofChain.html,1,['load'],['loading']
Performance,"TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:18381,cache,cache,18381,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,2,['cache'],['cache']
Performance,"TBranch.cxx. ◆ GetFile(). TFile * TBranch::GetFile ; (; Int_t ; mode = 0). virtual . Return pointer to the file where branch buffers reside, returns 0 in case branch buffers reside in the same file as tree header. ; If mode is 1 the branch buffer file is recreated. ; Definition at line 1853 of file TBranch.cxx. ◆ GetFileName(). const char * TBranch::GetFileName ; (; ); const. inline . Definition at line 234 of file TBranch.h. ◆ GetFirstEntry(). Long64_t TBranch::GetFirstEntry ; (; ); const. inline . Definition at line 243 of file TBranch.h. ◆ GetFreshBasket(). TBasket * TBranch::GetFreshBasket ; (; Int_t ; basketnumber, . TBuffer * ; user_buffer . ). protected . Return a fresh basket by either reusing an existing basket that needs to be drop (according to TTree::MemoryFull) or create a new one. ; If the user_buffer argument is non-null, then the memory in the user-provided buffer will be utilized by the underlying basket.; The basket number is used to estimate the required buffer size and try to optimize memory usage and number of memory allocation. ; Definition at line 1894 of file TBranch.cxx. ◆ GetFreshCluster(). TBasket * TBranch::GetFreshCluster ; (; TBuffer * ; user_buffer). protected . Drops the cluster two behind the current cluster and returns a fresh basket by either reusing or creating a new one. ; Definition at line 1953 of file TBranch.cxx. ◆ GetFullName(). TString TBranch::GetFullName ; (; ); const. virtual . Return the 'full' name of the branch. ; In particular prefix the mother's name when it does not end in a trailing dot and thus is not part of the branch name ; Reimplemented in TBranchElement.; Definition at line 2031 of file TBranch.cxx. ◆ GetIconName(). const char * TBranch::GetIconName ; (; ); const. overridevirtual . Return icon name depending on type of branch. ; Reimplemented from TObject.; Reimplemented in TBranchElement.; Definition at line 1332 of file TBranch.cxx. ◆ GetIOFeatures(). ROOT::TIOFeatures TBranch::GetIOFeatures ; (; ); const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:51834,optimiz,optimize,51834,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,1,['optimiz'],['optimize']
Performance,"TBranch.cxx. ◆ IsFolder(). bool TBranch::IsFolder ; (; ); const. overridevirtual . Return true if more than one leaf or browsables, false otherwise. ; Reimplemented from TObject.; Reimplemented in TBranchClones, TBranchElement, TBranchObject, and TBranchSTL.; Definition at line 2271 of file TBranch.cxx. ◆ KeepCircular(). void TBranch::KeepCircular ; (; Long64_t ; maxEntries). virtual . keep a maximum of fMaxEntries in memory ; Definition at line 2283 of file TBranch.cxx. ◆ LoadBaskets(). Int_t TBranch::LoadBaskets ; (; ). virtual . Baskets associated to this branch are forced to be in memory. ; You can call TTree::SetMaxVirtualSize(maxmemory) to instruct the system that the total size of the imported baskets does not exceed maxmemory bytes.; The function returns the number of baskets that have been put in memory. This method may be called to force all baskets of one or more branches in memory when random access to entries in this branch is required. See also TTree::LoadBaskets to load all baskets of all branches in memory. ; Definition at line 2309 of file TBranch.cxx. ◆ operator=(). TBranch & TBranch::operator= ; (; const TBranch & ; ). privatedelete . ◆ Print(). void TBranch::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print TBranch parameters. ; If options contains ""basketsInfo"" print the entry number, location and size of each baskets. ; Reimplemented from TObject.; Reimplemented in TBranchSTL, TBranchClones, TBranchElement, TBranchObject, and TBranchRef.; Definition at line 2341 of file TBranch.cxx. ◆ PrintCacheInfo(). void TBranch::PrintCacheInfo ; (; ); const. Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ; Definition at line 2445 of file TBranch.cxx. ◆ ReadBasket(). void TBranch::ReadBasket ; (; TBuffer & ; b). virtual . Loop on all leaves of this branch to read Basket buffer. ; Definition at line 2453 of file TBranch.cxx. ◆ ReadLeaves0Impl(). void TBranch::Read",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:57889,load,load,57889,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,1,['load'],['load']
Performance,"TBranch::GetBasket. ;  ; virtual void Enable ();  ; virtual bool FillBuffer ();  Fill the cache buffer with the branches in the cache. ;  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:13961,cache,cache,13961,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,4,['cache'],['cache']
Performance,"TCanvas(""rf102_dataimport"", ""rf102_dataimport"", 800, 800); c.Divide(3, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.4); frame3.Draw(); c.cd(5); ROOT.gPad.SetLeftMargin(0.15); frame4.GetYaxis().SetTitleOffset(1.4); frame4.Draw(); c.cd(6); ROOT.gPad.SetLeftMargin(0.15); frame4.GetYaxis().SetTitleOffset(1.4); frame5.Draw(); ; c.SaveAs(""rf102_dataimport.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_dh) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #0 because y cannot accommodate the value 14.424; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #3 because y cannot accommodate the value -12.0022; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #5 because y cannot accommodate the value 13.8261; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #6 because y cannot accommodate the value -14.9925; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 36 out-of-range events; [#1] INFO:DataHandling -- RooDataSet::read: reading file rf102_testData.txt; [#1] INFO:DataHandling -- RooDataSet::r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf102__dataimport_8py.html:6414,optimiz,optimization,6414,doc/master/rf102__dataimport_8py.html,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8py.html,3,"['load', 'optimiz']","['loadValues', 'optimization']"
Performance,"TCanvas.h:135; TCanvas::IsWebBool_t IsWeb() const overrideIs web canvas.Definition TCanvas.cxx:1496; TCanvas::SetBatchvoid SetBatch(Bool_t batch=kTRUE) overrideToggle batch mode.Definition TCanvas.cxx:1957; TCanvas::UseGLBool_t UseGL() constDefinition TCanvas.h:228; TCanvas::OpaqueResizingBool_t OpaqueResizing() const overrideDefinition TCanvas.h:181; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetListOfMethodsTList * GetListOfMethods(Bool_t load=kTRUE)Return list containing the TMethods of a class.Definition TClass.cxx:3879; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4640; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4621; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::GetListOfBasesTList * GetListOfBases()Return list containing the TBaseClass(es) of a class.Definition TClass.cxx:3703; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::Browsevoid Browse(TBrowser *b) overrideBrowse this collection (called by TBrowser).Definition TCollection.cxx:248; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TColorThe color creation and management class.Definition TColor.h:21; TColor::SaveColorstatic Bool_t SaveColor(std::ostream &out, Int_t ci)Save a color with index > 228 as a C++ statement(s) on output stream out.Definition TColor.cxx:2543; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:274742,load,load,274742,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['load'],['load']
Performance,"TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TGTextEditCommand; TGTextEdit * fEdit;  ; TGLongPosition fPos;  . Inheritance diagram for TInsCharCom:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TInsCharCom(). TInsCharCom::TInsCharCom ; (; TGTextEdit * ; te, . char ; ch . ). inline . Definition at line 98 of file TGTextEdit.cxx. Member Function Documentation. ◆ Notify(). Bool_t TInsCharCom::Notify ; (; ). inlineoverridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 101 of file TGTextEdit.cxx. gui/gui/src/TGTextEdit.cxx. TInsCharCom. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:52 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTInsCharCom.html:10420,load,load,10420,doc/master/classTInsCharCom.html,https://root.cern,https://root.cern/doc/master/classTInsCharCom.html,2,['load'],['load']
Performance,"TClass describing this class . ◆ Class_Name(). static const char * RooCachedPdf::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooCachedPdf::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 51 of file RooCachedPdf.h. ◆ clone(). TObject * RooCachedPdf::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 26 of file RooCachedPdf.h. ◆ DeclFileName(). static const char * RooCachedPdf::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 51 of file RooCachedPdf.h. ◆ evaluate(). double RooCachedPdf::evaluate ; (; ); const. inlineoverrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 39 of file RooCachedPdf.h. ◆ fillCacheObject(). void RooCachedPdf::fillCacheObject ; (; RooAbsCachedPdf::PdfCacheElem & ; cache); const. overrideprotectedvirtual . Update contents of cache histogram by resampling the input p.d.f. ; Note that the cache is filled with normalized p.d.f values so that the RooHistPdf that represents the cache contents can be explicitly declared as self normalized eliminating the need for superfluous numeric calculations of unit normalization.s ; Implements RooAbsCachedPdf.; Definition at line 92 of file RooCachedPdf.cxx. ◆ inputBaseName(). const char * RooCachedPdf::inputBaseName ; (; ); const. inlineoverrideprotectedvirtual . Return the base name for cache objects, in this case the name of the cached p.d.f. ; Implements RooAbsCachedPdf.; Definition at line 33 of file RooCachedPdf.h. ◆ IsA(). TClass * RooCachedPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsCachedPdf.; Definition at line 51 of file RooCachedPdf.h. ◆ payloadUniqueSuffix(). const char * RooCachedPdf::payloadUniqueSuf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:81092,cache,cache,81092,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,1,['cache'],['cache']
Performance,"TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; TEveStraightLineSetGL(); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveStraightLineSetGL.html:1872,cache,cached,1872,root/html602/TEveStraightLineSetGL.html,https://root.cern,https://root.cern/root/html602/TEveStraightLineSetGL.html,2,['cache'],['cached']
Performance,TClass::GetDeclFileLine ; (; ); const. inline . Definition at line 429 of file TClass.h. ◆ GetDeclFileName(). const char * TClass::GetDeclFileName ; (; ); const. Return name of the file containing the declaration of this class. ; Definition at line 3463 of file TClass.cxx. ◆ GetDeclIdMap(). DeclIdMap_t * TClass::GetDeclIdMap ; (; ). staticprivate . Definition at line 480 of file TClass.cxx. ◆ GetDelete(). ROOT::DelFunc_t TClass::GetDelete ; (; ); const. Return the wrapper around delete ThiObject. ; Definition at line 7463 of file TClass.cxx. ◆ GetDeleteArray(). ROOT::DelArrFunc_t TClass::GetDeleteArray ; (; ); const. Return the wrapper around delete [] ThiObject. ; Definition at line 7471 of file TClass.cxx. ◆ GetDestructor(). ROOT::DesFunc_t TClass::GetDestructor ; (; ); const. Return the wrapper around the destructor. ; Definition at line 7479 of file TClass.cxx. ◆ GetDict() [1/2]. DictFuncPtr_t TClass::GetDict ; (; const char * ; cname). static . Return a pointer to the dictionary loading function generated by rootcint. ; Definition at line 3422 of file TClass.cxx. ◆ GetDict() [2/2]. DictFuncPtr_t TClass::GetDict ; (; const std::type_info & ; info). static . Return a pointer to the dictionary loading function generated by rootcint. ; Definition at line 3431 of file TClass.cxx. ◆ GetDirectoryAutoAdd(). ROOT::DirAutoAdd_t TClass::GetDirectoryAutoAdd ; (; ); const. Return the wrapper around the directory auto add function. ; Definition at line 7487 of file TClass.cxx. ◆ GetFunctionTemplate(). TFunctionTemplate * TClass::GetFunctionTemplate ; (; const char * ; name). Definition at line 3607 of file TClass.cxx. ◆ GetHeapInstanceCount(). UInt_t TClass::GetHeapInstanceCount ; (; ); const. inline . Definition at line 467 of file TClass.h. ◆ GetIdMap(). IdMap_t * TClass::GetIdMap ; (; ). staticprivate . Definition at line 469 of file TClass.cxx. ◆ GetImplFileLine(). Short_t TClass::GetImplFileLine ; (; ); const. inline . Definition at line 457 of file TClass.h. ◆ GetImplFi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:79387,load,loading,79387,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['loading']
Performance,TClass::GetDeclFileLine ; (; ); const. inline . Definition at line 429 of file TClass.h. ◆ GetDeclFileName(). const char * TClass::GetDeclFileName ; (; ); const. Return name of the file containing the declaration of this class. ; Definition at line 3530 of file TClass.cxx. ◆ GetDeclIdMap(). DeclIdMap_t * TClass::GetDeclIdMap ; (; ). staticprivate . Definition at line 480 of file TClass.cxx. ◆ GetDelete(). ROOT::DelFunc_t TClass::GetDelete ; (; ); const. Return the wrapper around delete ThiObject. ; Definition at line 7530 of file TClass.cxx. ◆ GetDeleteArray(). ROOT::DelArrFunc_t TClass::GetDeleteArray ; (; ); const. Return the wrapper around delete [] ThiObject. ; Definition at line 7538 of file TClass.cxx. ◆ GetDestructor(). ROOT::DesFunc_t TClass::GetDestructor ; (; ); const. Return the wrapper around the destructor. ; Definition at line 7546 of file TClass.cxx. ◆ GetDict() [1/2]. DictFuncPtr_t TClass::GetDict ; (; const char * ; cname). static . Return a pointer to the dictionary loading function generated by rootcint. ; Definition at line 3489 of file TClass.cxx. ◆ GetDict() [2/2]. DictFuncPtr_t TClass::GetDict ; (; const std::type_info & ; info). static . Return a pointer to the dictionary loading function generated by rootcint. ; Definition at line 3498 of file TClass.cxx. ◆ GetDirectoryAutoAdd(). ROOT::DirAutoAdd_t TClass::GetDirectoryAutoAdd ; (; ); const. Return the wrapper around the directory auto add function. ; Definition at line 7554 of file TClass.cxx. ◆ GetFunctionTemplate(). TFunctionTemplate * TClass::GetFunctionTemplate ; (; const char * ; name). Definition at line 3674 of file TClass.cxx. ◆ GetHeapInstanceCount(). UInt_t TClass::GetHeapInstanceCount ; (; ); const. inline . Definition at line 467 of file TClass.h. ◆ GetIdMap(). IdMap_t * TClass::GetIdMap ; (; ). staticprivate . Definition at line 469 of file TClass.cxx. ◆ GetImplFileLine(). Short_t TClass::GetImplFileLine ; (; ); const. inline . Definition at line 457 of file TClass.h. ◆ GetImplFi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:79388,load,loading,79388,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['loading']
Performance,"TClass::fConvStreamerFuncClassConvStreamerFunc_t fConvStreamerFuncDefinition TClass.h:242; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2031; TClass::SetRuntimePropertiesvoid SetRuntimeProperties()Internal routine to set calculate the class properties that can only be known at run-time,...Definition TClass.cxx:6194; TClass::BuildEmulatedRealDatavoid BuildEmulatedRealData(const char *name, Longptr_t offset, TClass *cl, Bool_t isTransient=kFALSE)Build the list of real data for an emulated class.Definition TClass.cxx:2112; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5749; TClass::fSharedLibsTString fSharedLibsDefinition TClass.h:227; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3770; TClass::ENewTypeENewTypeDefinition TClass.h:107; TClass::kClassNew@ kClassNewDefinition TClass.h:107; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::kDummyNew@ kDummyNewDefinition TClass.h:107; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4327; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6922; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:58967,load,load,58967,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['load'],['load']
Performance,"TClass::fConvStreamerFuncClassConvStreamerFunc_t fConvStreamerFuncDefinition TClass.h:242; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2031; TClass::SetRuntimePropertiesvoid SetRuntimeProperties()Internal routine to set calculate the class properties that can only be known at run-time,...Definition TClass.cxx:6194; TClass::BuildEmulatedRealDatavoid BuildEmulatedRealData(const char *name, Longptr_t offset, TClass *cl, Bool_t isTransient=kFALSE)Build the list of real data for an emulated class.Definition TClass.cxx:2112; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5749; TClass::fSharedLibsTString fSharedLibsDefinition TClass.h:227; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3770; TClass::ENewTypeENewTypeDefinition TClass.h:107; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4327; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6922; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5704; TClass::SetCurrentStreamerInfo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:324434,load,load,324434,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"TClass::fConvStreamerFuncClassConvStreamerFunc_t fConvStreamerFuncDefinition TClass.h:242; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::SetRuntimePropertiesvoid SetRuntimeProperties()Internal routine to set calculate the class properties that can only be known at run-time,...Definition TClass.cxx:6261; TClass::BuildEmulatedRealDatavoid BuildEmulatedRealData(const char *name, Longptr_t offset, TClass *cl, Bool_t isTransient=kFALSE)Build the list of real data for an emulated class.Definition TClass.cxx:2179; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::fSharedLibsTString fSharedLibsDefinition TClass.h:227; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::ENewTypeENewTypeDefinition TClass.h:107; TClass::kClassNew@ kClassNewDefinition TClass.h:107; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::kDummyNew@ kDummyNewDefinition TClass.h:107; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4394; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6989; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:58795,load,load,58795,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['load'],['load']
Performance,"TClass::fConvStreamerFuncClassConvStreamerFunc_t fConvStreamerFuncDefinition TClass.h:242; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::SetRuntimePropertiesvoid SetRuntimeProperties()Internal routine to set calculate the class properties that can only be known at run-time,...Definition TClass.cxx:6261; TClass::BuildEmulatedRealDatavoid BuildEmulatedRealData(const char *name, Longptr_t offset, TClass *cl, Bool_t isTransient=kFALSE)Build the list of real data for an emulated class.Definition TClass.cxx:2179; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::fSharedLibsTString fSharedLibsDefinition TClass.h:227; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::ENewTypeENewTypeDefinition TClass.h:107; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4394; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6989; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5771; TClass::SetCurrentStreamerInfo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:327072,load,load,327072,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"TClassTable::GetDictNorm(name);; 3034 if (dict) {; 3035 // The name is normalized, so the result of the first search is; 3036 // authoritative.; 3037 if (!cl && !load) return nullptr;; 3038 ; 3039 TClass *loadedcl = (dict)();; 3040 if (loadedcl) {; 3041 loadedcl->PostLoadCheck();; 3042 return loadedcl;; 3043 }; 3044 ; 3045 // We should really not fall through to here, but if we do, let's just; 3046 // continue as before ...; 3047 }; 3048 ; 3049 std::string normalizedName;; 3050 Bool_t checkTable = kFALSE;; 3051 ; 3052 if (!cl) {; 3053 {; 3054 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3055 TClassEdit::GetNormalizedName(normalizedName, name);; 3056 }; 3057 // Try the normalized name.; 3058 if (normalizedName != name) {; 3059 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(normalizedName.c_str());; 3060 ; 3061 if (cl) {; 3062 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3063 ; 3064 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3065 load = kTRUE;; 3066 }; 3067 checkTable = kTRUE;; 3068 }; 3069 } else {; 3070 normalizedName = cl->GetName(); // Use the fact that all TClass names are normalized.; 3071 checkTable = load && (normalizedName != name);; 3072 }; 3073 ; 3074 if (!load) return nullptr;; 3075 ; 3076// This assertion currently fails because of; 3077// TClass *c1 = TClass::GetClass(""basic_iostream<char,char_traits<char> >"");; 3078// TClass *c2 = TClass::GetClass(""std::iostream"");; 3079// where the TClassEdit normalized name of iostream is basic_iostream<char>; 3080// i.e missing the addition of the default parameter. This is because TClingLookupHelper; 3081// uses only 'part' of TMetaUtils::GetNormalizedName.; 3082 ; 3083// if (!cl) {; 3084// TDataType* dataType = (TDataType*)gROOT->GetListOfTypes()->FindObject(name);; 3085// TClass *altcl = dataType ? (TClass*)gROOT->GetListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;; 3086// if (altcl && normalizedName != altcl->GetName()); 3087// ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:115399,load,load,115399,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"TClassTable::GetDictNorm(name);; 3101 if (dict) {; 3102 // The name is normalized, so the result of the first search is; 3103 // authoritative.; 3104 if (!cl && !load) return nullptr;; 3105 ; 3106 TClass *loadedcl = (dict)();; 3107 if (loadedcl) {; 3108 loadedcl->PostLoadCheck();; 3109 return loadedcl;; 3110 }; 3111 ; 3112 // We should really not fall through to here, but if we do, let's just; 3113 // continue as before ...; 3114 }; 3115 ; 3116 std::string normalizedName;; 3117 Bool_t checkTable = kFALSE;; 3118 ; 3119 if (!cl) {; 3120 {; 3121 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3122 TClassEdit::GetNormalizedName(normalizedName, name);; 3123 }; 3124 // Try the normalized name.; 3125 if (normalizedName != name) {; 3126 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(normalizedName.c_str());; 3127 ; 3128 if (cl) {; 3129 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3130 ; 3131 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3132 load = kTRUE;; 3133 }; 3134 checkTable = kTRUE;; 3135 }; 3136 } else {; 3137 normalizedName = cl->GetName(); // Use the fact that all TClass names are normalized.; 3138 checkTable = load && (normalizedName != name);; 3139 }; 3140 ; 3141 if (!load) return nullptr;; 3142 ; 3143// This assertion currently fails because of; 3144// TClass *c1 = TClass::GetClass(""basic_iostream<char,char_traits<char> >"");; 3145// TClass *c2 = TClass::GetClass(""std::iostream"");; 3146// where the TClassEdit normalized name of iostream is basic_iostream<char>; 3147// i.e missing the addition of the default parameter. This is because TClingLookupHelper; 3148// uses only 'part' of TMetaUtils::GetNormalizedName.; 3149 ; 3150// if (!cl) {; 3151// TDataType* dataType = (TDataType*)gROOT->GetListOfTypes()->FindObject(name);; 3152// TClass *altcl = dataType ? (TClass*)gROOT->GetListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;; 3153// if (altcl && normalizedName != altcl->GetName()); 3154// ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:118150,load,load,118150,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"TCling.h. ◆ GetRootMapFiles(). TObjArray * TCling::GetRootMapFiles ; (; ); const. inlinefinalvirtual . Implements TInterpreter.; Definition at line 223 of file TCling.h. ◆ GetSecurityError(). int TCling::GetSecurityError ; (; ); const. finalvirtual . Interface to cling function. ; Reimplemented from TInterpreter.; Definition at line 7487 of file TCling.cxx. ◆ GetSharedLibDeps(). const char * TCling::GetSharedLibDeps ; (; const char * ; lib, . bool ; useDyld = false . ). finalvirtual . Get the list a libraries on which the specified lib depends. ; The returned string contains as first element the lib itself. Returns 0 in case the lib does not exist or does not have any dependencies. If useDyld is true, we iterate through all available libraries and try to construct the dependency chain by resolving each symbol. ; Implements TInterpreter.; Definition at line 7289 of file TCling.cxx. ◆ GetSharedLibs(). const char * TCling::GetSharedLibs ; (; ). finalvirtual . Return the list of shared libraries loaded into the process. ; Implements TInterpreter.; Definition at line 6989 of file TCling.cxx. ◆ GetSTLIncludePath(). const char * TCling::GetSTLIncludePath ; (; ); const. finalvirtual . Return the directory containing CINT's stl cintdlls. ; Reimplemented from TInterpreter.; Definition at line 7401 of file TCling.cxx. ◆ GetTopLevelMacroName(). const char * TCling::GetTopLevelMacroName ; (; ); const. finalvirtual . Return the file name of the current un-included interpreted file. ; See the documentation for GetCurrentMacroName(). ; Reimplemented from TInterpreter.; Definition at line 5416 of file TCling.cxx. ◆ GetUsingNamespaces(). std::vector< std::string > TCling::GetUsingNamespaces ; (; ClassInfo_t * ; cl); const. finalvirtual . Get the scopes representing using declarations of namespace. ; Implements TInterpreter.; Definition at line 4478 of file TCling.cxx. ◆ HandleNewDecl(). void TCling::HandleNewDecl ; (; const void * ; DV, . bool ; isDeserialized, . std::set< TClass * > ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:105552,load,loaded,105552,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['load'],['loaded']
Performance,"TCling::UpdateListOfLoadedSharedLibrariesvoid UpdateListOfLoadedSharedLibraries()Definition TCling.cxx:3348; TCling::TypedefInfo_Titleconst char * TypedefInfo_Title(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9530; TCling::CallFunc_SetFuncProtovoid CallFunc_SetFuncProto(CallFunc_t *func, ClassInfo_t *info, const char *method, const char *proto, Longptr_t *Offset, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) const finalInterface to cling function.Definition TCling.cxx:8065; TCling::InitRootmapFilevoid InitRootmapFile(const char *name)Create a resource table and read the (possibly) three resource files, i.e.Definition TCling.cxx:5655; TCling::AutoParseInt_t AutoParse(const char *cls) finalParse the headers relative to the class Returns 1 in case of success, 0 in case of failure.Definition TCling.cxx:6523; TCling::FunctionDeclId_IsMethodbool FunctionDeclId_IsMethod(DeclId_t fdeclid) constDefinition TCling.cxx:9595; TCling::LoadPCMvoid LoadPCM(std::string pcmFileNameFullPath)Tries to load a rdict PCM, issues diagnostics if it fails.Definition TCling.cxx:1811; TCling::UpdateListOfMethodsvoid UpdateListOfMethods(TClass *cl) const finalUpdate the list of pointers to method for TClass cl This is now a nop.Definition TCling.cxx:4507; TCling::~TClingvirtual ~TCling()Destroy the interpreter interface.Definition TCling.cxx:1618; TCling::AddFriendToClassvoid AddFriendToClass(clang::FunctionDecl *, clang::CXXRecordDecl *) constInject function as a friend into klass.Definition TCling.cxx:7767; TCling::PrintIntrovoid PrintIntro() finalNo-op; see TRint instead.Definition TCling.cxx:2648; TCling::fCxxModulesEnabledBool_t fCxxModulesEnabledDefinition TCling.h:128; TCling::BaseClassInfo_Nextint BaseClassInfo_Next(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8492; TCling::RefreshClassInfovoid RefreshClassInfo(TClass *cl, const clang::NamedDecl *def, bool alias)Internal function. Actually do the update of the ClassInfo when seeing.Definition TCling.cxx:66",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:424721,load,load,424721,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['load'],['load']
Performance,"TCollectionPropertyBrowsable. class TCollectionPropertyBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TCollectionPropertyBrow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCollectionPropertyBrowsable.html:1198,cache,cached,1198,root/html526/TCollectionPropertyBrowsable.html,https://root.cern,https://root.cern/root/html526/TCollectionPropertyBrowsable.html,10,['cache'],['cached']
Performance,"TCollectionPropertyBrowsable. class TCollectionPropertyBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TCollectionProp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCollectionPropertyBrowsable.html:1198,cache,cached,1198,root/html602/TCollectionPropertyBrowsable.html,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html,4,['cache'],['cached']
Performance,"TDictionary::kUnorderedMultiset; static TDictionary::ESTLTypeTDictionary::kUnorderedSet; static TDictionary::ESTLTypeTDictionary::kVector; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. DataMemberInfo_t*fInfo!pointer to CINT data member info. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGlobal(DataMemberInfo_t* info = 0); Default TGlobal ctor. TGlobal(const TGlobal& ); Copy constructor. TGlobal & operator=(const TGlobal& ); Assignment operator. ~TGlobal(); TGlobal dtor deletes adopted CINT DataMemberInfo object. void * GetAddress() const; Return address of global. Int_t GetArrayDim() const; Return number of array dimensions. TDictionary::DeclId_t GetDeclId() const. Int_t GetMaxIndex(Int_t dim) const; Return maximum index for array dimension ""dim"". const char * GetTypeName() const; Get type of global variable, e,g.: ""class TDirectory*"" -> ""TDirectory"".; Result needs to be used or copied immediately. const char * GetFullTypeName() const; Get full type description of global variable, e,g.: ""class TDirectory*"". Bool_t IsValid(); Return true if this global object is pointing to a currently; loaded global. If a global is unloaded after the TGlobal; is created, the TGlobal will be set to be invalid. Long_t Property() const; Get property description word. For meaning of bits see EProperty. Bool_t Update(DataMemberInfo_t* info); Update the TFunction to reflect the new info. This can be used to implement unloading (info == 0) and then reloading; (info being the 'new' decl address). » Author: Rene Brun 13/11/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 16:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGlobal.html:8463,load,loaded,8463,root/html604/TGlobal.html,https://root.cern,https://root.cern/root/html604/TGlobal.html,1,['load'],['loaded']
Performance,"TDictionaryprivate; fUsingDataTClassprivate; fVersionUsedTClassmutableprivate; GetActualClass(const void *object) constTClass; GetAttributeMap() constTDictionaryinline; GetBaseClass(const char *classname)TClass; GetBaseClass(const TClass *base)TClass; GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)TClass; GetBaseClassOffsetRecurse(const TClass *toBase)TClassprivate; GetBaseDataMember(const char *datamember)TClass; GetCheckSum(ECheckSum code=kCurrentCheckSum) constTClass; GetCheckSum(Bool_t &isvalid) constTClass; GetCheckSum(ECheckSum code, Bool_t &isvalid) constTClass; GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)TClassstatic; GetClass(const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size)TClassstatic; GetClass(const std::type_info &typeinfo, Bool_t load=kTRUE, Bool_t silent=kFALSE, size_t hint_pair_offset=0, size_t hint_pair_size=0)TClassstatic; GetClass(ClassInfo_t *info, Bool_t load=kTRUE, Bool_t silent=kFALSE)TClassstatic; GetClass(Bool_t load=kTRUE, Bool_t silent=kFALSE)TClassstatic; GetClass(DeclId_t id, std::vector< TClass * > &classes)TClassstatic; GetClassInfo() constTClassinline; GetClassMethod(Longptr_t faddr)TClassprivate; GetClassMethod(const char *name, const char *params, Bool_t objectIsConst=kFALSE)TClass; GetClassMethodWithPrototype(const char *name, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)TClass; GetClassSize() constTClassinline; GetClassVersion() constTClassinline; GetCollectionProxy() constTClass; GetCollectionType() constTClass; GetContextMenuTitle() constTClassinline; GetConversionStreamerInfo(const char *onfile_classname, Int_t version) constTClass; GetConversionStreamerInfo(const TClass *onfile_cl, Int_t version) constTClass; GetConvStreamerFunc() constTClass; GetCurrentStreamerInfo()TClassinline; GetDataMember(const char *datamember) constTClass; GetDataMemberOffset(const char *me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass-members.html:7424,load,load,7424,doc/master/classTClass-members.html,https://root.cern,https://root.cern/doc/master/classTClass-members.html,1,['load'],['load']
Performance,"TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; static const char**&GetExtraInterpreterArgs(); virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TFunctionTemplate*GetFunctionTemplate(const char* name); TObject*GetGeometry(const char* name) const; const char*GetGitBranch() const; const char*GetGitCommit() const; const char*GetGitDate(); TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfClosedObjects() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TCollection*GetListOfEnums(Bool_t load = kFALSE); TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctionOverloads(const char* name) const; TCollection*GetListOfFunctions() const; TCollection*GetListOfFunctionTemplates(); TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:6409,load,load,6409,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['load'],['load']
Performance,"TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); virtual voidResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMemFile.html:12144,cache,cache,12144,root/html532/TMemFile.html,https://root.cern,https://root.cern/root/html532/TMemFile.html,1,['cache'],['cache']
Performance,"TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); virtual voidResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMemFile.html:12223,cache,cache,12223,root/html534/TMemFile.html,https://root.cern,https://root.cern/root/html534/TMemFile.html,3,['cache'],['cache']
Performance,"TEntryList; void GetFileName (const char *filename, TString &fn, bool *=nullptr);  To be able to re-localize the entry-list we identify the file by just the name and the anchor, i.e. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Long64_t fEntry;  the entry number, when the list is used for subentries ;  ; TEntryListArray * fLastSubListQueried;  ! last sublist checked by GetSubListForEntry ;  ; TIter * fSubListIter;  ! to iterate over fSubLists and keep last one checked ;  ; TList * fSubLists;  a list of underlying entry lists for each event of a TEntryList ;  ;  Protected Attributes inherited from TEntryList; TObjArray * fBlocks;  blocks with indices of passing events (TEntryListBlocks) ;  ; TEntryList * fCurrent;  ! currently filled entry list ;  ; TDirectory * fDirectory;  ! Pointer to directory holding this tree ;  ; Long64_t fEntriesToProcess;  used on proof to set the number of entries to process in a packet ;  ; TString fFileName;  name of the file, where the tree is ;  ; Long64_t fLastIndexQueried;  ! used to optimize GetEntry() function from a loop ;  ; Long64_t fLastIndexReturned;  ! used to optimize GetEntry() function from a loop ;  ; TList * fLists;  a list of underlying entry lists for each tree of a chain ;  ; Long64_t fN;  number of entries in the list ;  ; Int_t fNBlocks;  number of TEntryListBlocks ;  ; bool fReapply;  If true, TTree::Draw will 'reapply' the original cut. ;  ; bool fShift;  ! true when some sub-lists don't correspond to trees (when the entry list is used as input in TChain) ;  ; ULong_t fStringHash;  ! Hash value of a string of treename and filename ;  ; TString fTreeName;  name of the tree ;  ; Int_t fTreeNumber;  ! the index of the tree in the chain (used when the entry list is used as input (TTree::SetEntryList()) ;  ;  Protected Attributes i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryListArray.html:20997,optimiz,optimize,20997,doc/master/classTEntryListArray.html,https://root.cern,https://root.cern/doc/master/classTEntryListArray.html,2,['optimiz'],['optimize']
Performance,"TEveDigitSetGL::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidDLCacheDrop(); virtual voidDLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTEveDigitSetGL::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTEveDigitSetGL::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidRender(TGLRnrCtx& rnrCtx); virtual voidTEveDigitSetGL::SetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTEveDigitSetGL::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveBoxSetGL.html:1856,cache,cached,1856,root/html528/TEveBoxSetGL.html,https://root.cern,https://root.cern/root/html528/TEveBoxSetGL.html,3,['cache'],['cached']
Performance,"TF1.h:233; TF1::SetParLimitsvirtual void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax)Set lower and upper limits for parameter ipar.Definition TF1.cxx:3507; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; 1, 2 and 3 Dimensional fits are supported. See also TTree::Fit. Return status; The function return the status of the fit in the following form fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via mytree.GetSelectedRows();. If the number of selected entries is null the function returns -1. new implementation using new Fitter classes ; Implements TVirtualTreePlayer.; Definition at line 3068 of file TTreePlayer.cxx. ◆ UpdateFormulaLeaves(). void TTreePlayer::UpdateFormulaLeaves ; (; ). overridevirtual . this function is called by TChain::LoadTree when a new Tree is loaded. ; Because Trees in a TChain may have a different list of leaves, one must update the leaves numbers in the TTreeFormula used by the TreePlayer. ; Implements TVirtualTreePlayer.; Definition at line 3165 of file TTreePlayer.cxx. Member Data Documentation. ◆ fDimension. Int_t TTreePlayer::fDimension. protected . Dimension of the current expression. ; Definition at line 47 of file TTreePlayer.h. ◆ fFormulaList. TList* TTreePlayer::fFormulaList. protected . ! Pointer to a list of coordinated list TTreeFormula (used by Scan and Query) ; Definition at line 54 of file TTreePlayer.h. ◆ fHistogram. TH1* TTreePlayer::fHistogram. protected . ! Pointer to histogram used for the projection ; Definition at line 49 of file TTreePlayer.h. ◆ fInput. TList* TTreePlayer::fInput. protected . ! input list to the selector ; Definition at line 53 of file TTreePlayer.h. ◆ fScanFileName. const char* TTreePlayer::fScanFileName. protected . Name of the file where Scan is redire",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:53318,load,loaded,53318,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,1,['load'],['loaded']
Performance,"TF3& operator=(const TF3& rhs); Operator =. ~TF3(); F3 default destructor. TF3(const TF3& f3); Copy constructor. void Copy(TObject& f3) const; Copy this F3 to a new F3. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a function. Compute the closest distance of approach from point px,py to this function.; The distance is computed in pixels units. void Draw(Option_t* option = """"); Draw this function with its current attributes. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a F3 is clicked with the locator. Double_t FindMinMax(Double_t* x, bool findmax) const; return minimum/maximum value of the function; To find the minimum on a range, first set this range via the SetRange function; If a vector x of coordinate is passed it will be used as starting point for the minimum.; In addition on exit x will contain the coordinate values at the minimuma; If x is NULL or x is inifinity or NaN, first, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided into fNpx and fNpy; sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; by SetNpx and SetNpy functions; Then, a minimization is used with starting values found by the grid search; The minimizer algorithm used (by default Minuit) can be changed by callinga; ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); Other option for the minimizer can be set using the static method of the MinimizerOptions class. Double_t GetMinimumXYZ(Double_t& x, Double_t& y, Double_t& z); Compute the X, Y and Z values corresponding to the minimum value of the function; on its range. Return the function value at the minimum; To find the minimum on a subrange, use the SetRange() function first.; Method:; First, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided; into fNpx,fNpy and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF3.html:33756,perform,performed,33756,root/html602/TF3.html,https://root.cern,https://root.cern/root/html602/TF3.html,1,['perform'],['performed']
Performance,"TFPBlock * ; block, . Bool_t & ; inCache . ). Read one block and insert it in prefetchBuffers list. ; Definition at line 106 of file TFilePrefetch.cxx. ◆ ReadBlock(). void TFilePrefetch::ReadBlock ; (; Long64_t * ; offset, . Int_t * ; len, . Int_t ; nblock . ). Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. ; Definition at line 214 of file TFilePrefetch.cxx. ◆ ReadBuffer(). Bool_t TFilePrefetch::ReadBuffer ; (; char * ; buf, . Long64_t ; offset, . Int_t ; len . ). Return a prefetched element. ; Definition at line 178 of file TFilePrefetch.cxx. ◆ ReadListOfBlocks(). void TFilePrefetch::ReadListOfBlocks ; (; ). Get blocks specified in prefetchBlocks. ; Definition at line 128 of file TFilePrefetch.cxx. ◆ SaveBlockInCache(). void TFilePrefetch::SaveBlockInCache ; (; TFPBlock * ; block). Save the block content in cache. ; Definition at line 474 of file TFilePrefetch.cxx. ◆ SetCache(). Bool_t TFilePrefetch::SetCache ; (; const char * ; path). Set the path of the cache directory. ; Definition at line 526 of file TFilePrefetch.cxx. ◆ SetFile(). void TFilePrefetch::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). Change the file. ; When prefetching is enabled we also need to:; make sure the async thread is not doing any work; clear all blocks from prefetching and read list; reset the file pointer . Definition at line 317 of file TFilePrefetch.cxx. ◆ Streamer(). void TFilePrefetch::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TFilePrefetch::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 84 of file TFilePrefetch.h. ◆ SumHex(). Int_t TFilePrefetch::SumHex ; (; const char * ; hex). Sum up individual hex values to obtain a decimal value. ; Definition at line 381 of file TFilePrefetch.cxx. ◆ ThreadProc(). TThread::VoidRtnFunc_t TFilePrefetch::ThreadProc ; (; void * ; arg). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFilePrefetch.html:17595,cache,cache,17595,doc/master/classTFilePrefetch.html,https://root.cern,https://root.cern/doc/master/classTFilePrefetch.html,1,['cache'],['cache']
Performance,"TFile *Open(TFileOpenHandle *handle);; 310 ; 311 static EFileType GetType(const char *name, Option_t *option = """", TString *prefix = nullptr);; 312 ; 313 static EAsyncOpenStatus GetAsyncOpenStatus(const char *name);; 314 static EAsyncOpenStatus GetAsyncOpenStatus(TFileOpenHandle *handle);; 315 static const TUrl *GetEndpointUrl(const char *name);; 316 ; 317 static Long64_t GetFileBytesRead();; 318 static Long64_t GetFileBytesWritten();; 319 static Int_t GetFileReadCalls();; 320 static Int_t GetReadaheadSize();; 321 ; 322 static void SetFileBytesRead(Long64_t bytes = 0);; 323 static void SetFileBytesWritten(Long64_t bytes = 0);; 324 static void SetFileReadCalls(Int_t readcalls = 0);; 325 static void SetReadaheadSize(Int_t bufsize = 256000);; 326 static void SetReadStreamerInfo(Bool_t readinfo=kTRUE);; 327 static Bool_t GetReadStreamerInfo();; 328 ; 329 static Long64_t GetFileCounter();; 330 static void IncrementFileCounter();; 331 ; 332 static Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected = kTRUE,; 333 Bool_t forceCacheread = kFALSE);; 334 static const char *GetCacheFileDir();; 335 static Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0);; 336 static Bool_t Cp(const char *src, const char *dst, Bool_t progressbar = kTRUE,; 337 UInt_t buffersize = 1000000);; 338 ; 339 static UInt_t SetOpenTimeout(UInt_t timeout); // in ms; 340 static UInt_t GetOpenTimeout(); // in ms; 341 static Bool_t SetOnlyStaged(Bool_t onlystaged);; 342 static Bool_t GetOnlyStaged();; 343 ; 344 ClassDefOverride(TFile,8) //ROOT file; 345};; 346 ; 347#define gFile (TFile::CurrentFile()); 348 ; 349/**; 350\class TFileOpenHandle; 351\ingroup IO; 352Class holding info about the file being opened; 353*/; 354class TFileOpenHandle : public TNamed {; 355 ; 356friend class TFile;; 357 ; 358private:; 359 TString fOpt; ///< Options; 360 Int_t fCompress{0}; ///< Compression level and algorithm; 361 Int_t fNetOpt{0}; ///< Network options; 362 TFile *fFile{null",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:16651,cache,cacheDir,16651,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['cache'],['cacheDir']
Performance,"TFile *f = TFile::Open(""RelValMinBias-GEN-SIM-RECO.root"");; 32 T = (TTree*)f->Get(""Events"");; 33 Long64_t nentries = T->GetEntries();; 34 T->SetCacheSize(10000000);; 35 T->SetCacheEntryRange(0,nentries);; 36 T->AddBranchToCache(""*"");; 37//; 38 TTreePerfStats *ps= new TTreePerfStats(""ioperf"",T);; 39//; 40 for (Int_t i=0;i<nentries;i++) {; 41 T->GetEntry(i);; 42 }; 43 ps->SaveAs(""cmsperf.root"");; 44}; 45~~~; 46then, in a root interactive session, one can do:; 47~~~{.cpp}; 48 root > TFile f(""cmsperf.root"");; 49 root > ioperf->Draw();; 50 root > ioperf->Print();; 51~~~; 52The Draw or Print functions print the following information:; 53 - TreeCache = TTree cache size in MBytes; 54 - N leaves = Number of leaves in the TTree; 55 - ReadTotal = Total number of zipped bytes read; 56 - ReadUnZip = Total number of unzipped bytes read; 57 - ReadCalls = Total number of disk reads; 58 - ReadSize = Average read size in KBytes; 59 - Readahead = Readahead size in KBytes; 60 - Readextra = Readahead overhead in percent; 61 - Real Time = Real Time in seconds; 62 - CPU Time = CPU Time in seconds; 63 - Disk Time = Real Time spent in pure raw disk IO; 64 - Disk IO = Raw disk IO speed in MBytes/second; 65 - ReadUZRT = Unzipped MBytes per RT second; 66 - ReadUZCP = Unipped MBytes per CP second; 67 - ReadRT = Zipped MBytes per RT second; 68 - ReadCP = Zipped MBytes per CP second; 69 ; 70 ### NOTE 1 :; 71The ReadTotal value indicates the effective number of zipped bytes; 72returned to the application. The physical number of bytes read; 73from the device (as measured for example with strace) is; 74ReadTotal +ReadTotal*Readextra/100. Same for ReadSize.; 75 ; 76 ### NOTE 2 :; 77A consequence of NOTE1, the Disk I/O speed corresponds to the effective; 78number of bytes returned to the application per second.; 79The Physical disk speed is DiskIO + DiskIO*ReadExtra/100.; 80*/; 81 ; 82#include ""TTreePerfStats.h""; 83#include ""TROOT.h""; 84#include ""TSystem.h""; 85#include ""TFile.h""; 86#include ""TTree.h"";",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:1988,cache,cache,1988,doc/master/TTreePerfStats_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html,1,['cache'],['cache']
Performance,"TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:20373,cache,cache,20373,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['cache'],['cache']
Performance,"TFile object should not be saved. We try to proceed anyway."");; 2470 return const_cast<TFile*>(this)->Write(n, opt, bufsize);; 2471}; 2472 ; 2473////////////////////////////////////////////////////////////////////////////////; 2474/// Write a buffer to the file. This is the basic low level write operation.; 2475/// Returns kTRUE in case of failure.; 2476 ; 2477Bool_t TFile::WriteBuffer(const char *buf, Int_t len); 2478{; 2479 if (IsOpen() && fWritable) {; 2480 ; 2481 Int_t st;; 2482 if ((st = WriteBufferViaCache(buf, len))) {; 2483 if (st == 2); 2484 return kTRUE;; 2485 return kFALSE;; 2486 }; 2487 ; 2488 ssize_t siz;; 2489 gSystem->IgnoreInterrupt();; 2490 while ((siz = SysWrite(fD, buf, len)) < 0 && GetErrno() == EINTR) // NOLINT: silence clang-tidy warnings; 2491 ResetErrno(); // NOLINT: silence clang-tidy warnings; 2492 gSystem->IgnoreInterrupt(kFALSE);; 2493 if (siz < 0) {; 2494 // Write the system error only once for this file; 2495 SetBit(kWriteError); SetWritable(kFALSE);; 2496 SysError(""WriteBuffer"", ""error writing to file %s (%ld)"", GetName(), (Long_t)siz);; 2497 return kTRUE;; 2498 }; 2499 if (siz != len) {; 2500 SetBit(kWriteError);; 2501 Error(""WriteBuffer"", ""error writing all requested bytes to file %s, wrote %ld of %d"",; 2502 GetName(), (Long_t)siz, len);; 2503 return kTRUE;; 2504 }; 2505 fBytesWrite += siz;; 2506 fgBytesWrite += siz;; 2507 ; 2508 if (gMonitoringWriter); 2509 gMonitoringWriter->SendFileWriteProgress(this);; 2510 ; 2511 return kFALSE;; 2512 }; 2513 return kTRUE;; 2514}; 2515 ; 2516////////////////////////////////////////////////////////////////////////////////; 2517/// Write buffer via cache. Returns 0 if cache is not active, 1 in case; 2518/// write via cache was successful, 2 in case write via cache failed.; 2519 ; 2520Int_t TFile::WriteBufferViaCache(const char *buf, Int_t len); 2521{; 2522 if (!fCacheWrite) return 0;; 2523 ; 2524 Int_t st;; 2525 Long64_t off = GetRelOffset();; 2526 if ((st = fCacheWrite->WriteBuffer(buf, off, len))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:89286,cache,cache,89286,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"TFile::ReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); static voidSetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static voidSetOpenTimeout(UInt_t secs); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TDCacheFile.html:11817,cache,cache,11817,root/html526/TDCacheFile.html,https://root.cern,https://root.cern/root/html526/TDCacheFile.html,1,['cache'],['cache']
Performance,"TFile::ReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static voidSetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static voidSetOpenTimeout(UInt_t secs); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 25",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDCacheFile.html:11875,cache,cache,11875,root/html528/TDCacheFile.html,https://root.cern,https://root.cern/root/html528/TDCacheFile.html,1,['cache'],['cache']
Performance,"TFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); Long64_tfTotalUnzipBytes! The total sum of the currently unzipped blks; TTree*TTreeCache::fTree! pointer to the current Tree; Long64_tfUnzipBufferSize! Max Size for the ready unzipped blocks (default is 2*fBufferSize); char**fUnzipChunks! [fNseek] Individual unzipped chunks. Their summed size is kept under control.; TCondition*fUnzipDoneConditionUsed to wait for an unzip tour to finish. Gives the Async feel.; Int_t*fUnzipLen! [fNseek] Length of the unzipped buffers; TCondition*fUnzipStartConditionUsed to signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; Long64_tTTreeCache::fZipBytes! Total compressed size of branches in cache; static Int_tTTreeCache::fgLearnEntriesNumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:11609,cache,cache,11609,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"TFormLeafInfo &orig);  Exception safe assignment operator. ;  ; virtual Int_t ReadCounterValue (char *where);  Return the size of the underlying array for the current entry in the TTree. ;  ; template<typename T > ; T ReadTypedValue (char *where, Int_t instance=0);  ; virtual Double_t ReadValue (char *where, Int_t instance=0);  ; template<typename T > ; T ReadValueImpl (char *where, Int_t instance=0);  Read the value at the given memory location. ;  ; virtual Long64_t ReadValueLong64 (char *where, Int_t instance=0);  ; virtual LongDouble_t ReadValueLongDouble (char *where, Int_t instance=0);  ; virtual void SetBranch (TBranch *br);  ; virtual void SetPrimaryIndex (Int_t index);  Set the primary index value. ;  ; virtual void SetSecondaryIndex (Int_t index);  Set the primary index value. ;  ; virtual void SetSize (Int_t index, Int_t val);  Set the current size of the arrays. ;  ; void Swap (TFormLeafInfo &other);  ; virtual bool Update ();  We reloading all cached information in case the underlying class information has changed (for example when changing from the 'emulated' class to the real class. ;  ; virtual void UpdateSizes (TArrayI *garr);  Set the current sizes of the arrays. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object bel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFormLeafInfo.html:6176,cache,cached,6176,doc/master/classTFormLeafInfo.html,https://root.cern,https://root.cern/doc/master/classTFormLeafInfo.html,1,['cache'],['cached']
Performance,"TFormula::(anonymous)kLinear; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static ROOT::v5::TFormula::(anonymous)kNormalized; static TObject::(anonymous)TObject::kNotDeleted; static ROOT::v5::TFormula::(anonymous)kNotGlobal; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TBitsfAlreadyFound! cache for information; Double_t*fConst[fNconst] Array of fNconst formula constants; TString*fExpr[fNoper] List of expressions; TString*fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfFunctionsArray of function calls to make; TObjArrayfLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_tfNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*fNames[fNpar] Array of parameter names; Int_tfNconstNumber of constants; Int_tfNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNoperNumber of operators; Int_tfNparNumber of parameters; Int_tfNstringNumber of different constants character strings; Int_tfNumberformula number identifier; Int_tfNvalNumber of different variables in expression; ROOT::v5::TOperOffset*fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); ROOT::v5::TFormula::TFuncGfOptimal!pointer to optimal function; Double_t*fParams[fNpar] Array of fNpar parameters; ROOT::v5::TFormulaPrimitive**fPredefined![fNPar] predefined function; TStringTNamed::fTitleobject title; static ROOT::v5::TFormula::(anonymous)kAdd; static ROOT::v5::TFormula::(anonymous)kAnd; static ROOT::v5::TFormula::(anonymous)kBinary; static ROOT::v5::TFormula::(anonymous)kBitAnd; static ROOT::v5::TFormula::(anonymous)kBitOr; static ROOT::v5::TFormula::(anonym",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__v5__TFormula.html:12636,cache,cache,12636,root/html604/ROOT__v5__TFormula.html,https://root.cern,https://root.cern/root/html604/ROOT__v5__TFormula.html,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,TGFrame::fgWhitePixel. private:. Bool_tfAutoFitwhen true canvas container keeps same size as canvas; Int_tfButtoncurrently pressed button; TRootContainer*fCanvasContainercontainer in canvas widget; Int_tfCanvasIDindex in fWindows array of TGX11; TGLayoutHints*fCanvasLayoutlayout for canvas widget; TGCanvas*fCanvasWindowcanvas widget; TGLayoutHints*fDockLayoutlayout hints for dockable frame widget; TGPopupMenu*fEditClearMenuclear cascade submenu; TGPopupMenu*fEditMenuedit menu; TVirtualPadEditor*fEditorpointer to currently loaded pad editor; TGCompositeFrame*fEditorFrameside frame for current pad editor; TGLayoutHints*fEditorLayoutlayout for editor frame; TGPopupMenu*fFileMenufile menu; TGPopupMenu*fFileSaveMenusave cascade submenu; TGPopupMenu*fHelpMenuhelp menu; TGHorizontal3DLine*fHorizontal1toolbar sepatator; TGLayoutHints*fHorizontal1Layoutlayout hints for separator; const TGPicture*fIconPicicon picture; TGCompositeFrame*fMainFramemain frame containing canvas and side frame; TGLayoutHints*fMainFrameLayoutlayout for main frame; TGMenuBar*fMenuBarmenubar; TGLayoutHints*fMenuBarHelpLayoutlayout hint for help menu in menubar; TGLayoutHints*fMenuBarItemLayoutlayout hints for menu in menubar; TGLayoutHints*fMenuBarLayoutmenubar layout hints; TGPopupMenu*fOptionMenuoption menu; TGStatusBar*fStatusBarstatusbar widget; TGLayoutHints*fStatusBarLayoutlayout hints for statusbar; TGToolBar*fToolBaricon button toolbar; TGLayoutHints*fToolBarLayoutlayout for toolbar widget; TGHorizontal3DLine*fToolBarSeptoolbar separator; TGDockableFrame*fToolDockdockable frame holding the toolbar; TGToolTip*fToolTiptooltip for object info; TGPopupMenu*fToolsMenutools menu; TGVertical3DLine*fVertical1toolbar vertical separator; TGLayoutHints*fVertical1Layoutlayout hints for separator; TGVertical3DLine*fVertical2toolbar vertical separator; TGLayoutHints*fVertical2Layoutlayout hints for separator; TGPopupMenu*fViewMenuview menu; TGPopupMenu*fViewWithMenuview with... cascade submenu. Class Charts,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRootCanvas.html:23634,load,loaded,23634,root/html528/TRootCanvas.html,https://root.cern,https://root.cern/root/html528/TRootCanvas.html,3,['load'],['loaded']
Performance,"TGWindow::EEditModeTGWindow::kEditDisableResize; static TGWindow::EEditModeTGWindow::kEditDisableWidth; static TGWindow::EEditModeTGWindow::kEditEnable; static TObject::EStatusBitsTObject::kHasUUID; static TGView::(anonymous)TGView::kHorizontal; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TGView::(anonymous)TGView::kNoHSB; static TGView::(anonymous)TGView::kNoVSB; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TGView::(anonymous)TGView::kVertical; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TGFont*fAFont[71]Information about all screen fonts; GcCache_tfAGcCache[32]A cache of GCs for general use; intfAddEndTagsTRUE if we add /LI etc.; intfAnchorFlagsStyle flags associated with <A>...</A>; TGHtmlAnchor*fAnchorStartMost recent <a href=...>; ColorStruct_t*fApColor[32]Information about all colors; Pixel_tTGFrame::fBackgroundframe background color; ColorStruct_t*fBgColorBackground color of the HTML document; TImage*fBgImageBackground image; Int_tTGFrame::fBorderWidthframe border width; TGViewFrame*TGView::fCanvasframe containing the text; TGClient*TGObject::fClientConnection to display server; Atom_tTGView::fClipboardclipboard property; Long_tfColorUsedbit N is 1 if color N is in use. Only; TStringTGWidget::fCommandcommand to be executed; Cursor_tfCursorCurrent cursor for window, or None.; Int_tTGFrame::fDNDStateEDNDFlags; intfDirtyBottomBottom right corner of region to redraw; intfDirtyLeftTop left corner of region to redraw. These; intfDirtyRightBottom right corner of region to redraw; intfDirtyTopTop left corner of region to redraw. These; UInt_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGHtml.html:24517,cache,cache,24517,root/html602/TGHtml.html,https://root.cern,https://root.cern/root/html602/TGHtml.html,2,['cache'],['cache']
Performance,"TGenCollectionProxy::Insert(const void *data, void *container, size_t size); 1270{; 1271 fFeed((void*)data,container,size);; 1272}; 1273 ; 1274////////////////////////////////////////////////////////////////////////////////; 1275/// Commit the change.; 1276 ; 1277void TGenCollectionProxy::Commit(void* from); 1278{; 1279 if (fProperties & kIsAssociative) {; 1280// case ROOT::kSTLmap:; 1281// case ROOT::kSTLmultimap:; 1282// case ROOT::kSTLset:; 1283// case ROOT::kSTLmultiset:; 1284 if ( from ) {; 1285 TStaging *s = (TStaging*) from;; 1286 if ( s->GetTarget() ) {; 1287 fFeed(s->GetContent(),s->GetTarget(),s->GetSize());; 1288 }; 1289 fDestruct(s->GetContent(),s->GetSize());; 1290 s->SetTarget(0);; 1291 fStaged.push_back(s);; 1292 }; 1293 }; 1294}; 1295 ; 1296////////////////////////////////////////////////////////////////////////////////; 1297/// Add an object.; 1298 ; 1299void TGenCollectionProxy::PushProxy(void *objstart); 1300{; 1301 if ( !fValue.load(std::memory_order_relaxed) ) Initialize(kFALSE);; 1302 if ( !fProxyList.empty() ) {; 1303 EnvironBase_t* back = fProxyList.back();; 1304 if ( back->fObject == objstart ) {; 1305 ++back->fRefCount;; 1306 fProxyList.push_back(back);; 1307 fEnv = back;; 1308 return;; 1309 }; 1310 }; 1311 EnvironBase_t* e = 0;; 1312 if ( fProxyKept.empty() ) {; 1313 e = (EnvironBase_t*)fCreateEnv.invoke();; 1314 e->fTemp = 0;; 1315 e->fUseTemp = kFALSE;; 1316 }; 1317 else {; 1318 e = fProxyKept.back();; 1319 fProxyKept.pop_back();; 1320 }; 1321 e->fSize = 0;; 1322 e->fRefCount = 1;; 1323 e->fObject = objstart;; 1324 e->fStart = 0;; 1325 e->fIdx = 0;; 1326 // ::memset(e->buff,0,sizeof(e->buff));; 1327 fProxyList.push_back(e);; 1328 fEnv = e;; 1329}; 1330 ; 1331////////////////////////////////////////////////////////////////////////////////; 1332/// Remove the last object.; 1333 ; 1334void TGenCollectionProxy::PopProxy(); 1335{; 1336 if ( !fProxyList.empty() ) {; 1337 EnvironBase_t* e = fProxyList.back();; 1338 if ( --e->fRefCount <= 0 ) {; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:41801,load,load,41801,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance,"TGeoHMatrix*fMatrix! current matrix; TGeoHMatrix**fMatrixBranchcurrent branch of global matrices; TGeoNode*fNode! current node; TGeoNode**fNodeBranchcurrent branch of nodes; Int_t*fNodeIdArray! array of node id's; TGeoStateInfo*fPWInfo! State info for the parallel world; TStringfPathpath for current branch; TObjArray*fStackstack of cache states; Int_tfStackLevelcurrent level in the stack; TGeoNode*fToptop node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNodeCache(); Dummy constructor. TGeoNodeCache(TGeoNode* top, Bool_t nodeid = kFALSE, Int_t capacity = 30); Default constructor. ~TGeoNodeCache(); Destructor. void BuildIdArray(); Builds node id array. void BuildInfoBranch(); Bulds info branch. Navigation is possible only after this step. TGeoStateInfo * GetMakePWInfo(Int_t nd); Get the PW info, if none create one. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Bool_t CdDown(Int_t index); Make daughter INDEX of current node the active state. Compute global matrix. Bool_t CdDown(TGeoNode* node); Make daughter INDEX of current node the active state. Compute global matrix. void CdUp(); Make mother of current node the active state. Int_t GetCurrentNodeId() const; Returns a fixed ID for current physical node. Int_t GetNodeId() const; Get unique node id. void GetBranchNames(Int_t* names) const; Fill names with current branch volume names (4 char - used by GEANT3 interface). void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill copy numbers of current branch nodes. void GetBranchOnlys(Int_t* isonly) const; Fill copy numbers of current branch nodes. TGeoStateInfo * GetInfo(); Get next state info pointer. void ReleaseInfo(); Release last used state info pointer. const char * GetPath(); Returns the current geometry path. Int_t PushState(Bool_t ovlp, Int_t ntmany = 0, Int_t startlevel = 0, D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoNodeCache.html:8343,perform,performance,8343,root/html534/TGeoNodeCache.html,https://root.cern,https://root.cern/root/html534/TGeoNodeCache.html,2,['perform'],['performance']
Performance,"TGeoNodeCache ; (; ). override . Destructor. ; Definition at line 104 of file TGeoCache.cxx. Member Function Documentation. ◆ BuildIdArray(). void TGeoNodeCache::BuildIdArray ; (; ). Builds node id array. ; Definition at line 131 of file TGeoCache.cxx. ◆ BuildInfoBranch(). void TGeoNodeCache::BuildInfoBranch ; (; ). Builds info branch. Navigation is possible only after this step. ; Definition at line 150 of file TGeoCache.cxx. ◆ CdDown() [1/2]. Bool_t TGeoNodeCache::CdDown ; (; Int_t ; index). Make daughter INDEX of current node the active state. Compute global matrix. ; Definition at line 219 of file TGeoCache.cxx. ◆ CdDown() [2/2]. Bool_t TGeoNodeCache::CdDown ; (; TGeoNode * ; node). Make daughter INDEX of current node the active state. Compute global matrix. ; Definition at line 245 of file TGeoCache.cxx. ◆ CdNode(). void TGeoNodeCache::CdNode ; (; Int_t ; nodeid). Change current path to point to the node having this id. ; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons) ; Definition at line 176 of file TGeoCache.cxx. ◆ CdTop(). void TGeoNodeCache::CdTop ; (; ). inline . Definition at line 92 of file TGeoCache.h. ◆ CdUp(). void TGeoNodeCache::CdUp ; (; ). Make mother of current node the active state. ; Definition at line 271 of file TGeoCache.cxx. ◆ Class(). static TClass * TGeoNodeCache::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoNodeCache::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoNodeCache::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 145 of file TGeoCache.h. ◆ DeclFileName(). static const char * TGeoNodeCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 145 of file TGeoCache.h. ◆ FillIdBranch(). void TGeoNodeCache::FillIdBranch ; (; const Int_t * ; br, . Int_t ; startlevel = 0 . ). inline . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNodeCache.html:15761,perform,performance,15761,doc/master/classTGeoNodeCache.html,https://root.cern,https://root.cern/doc/master/classTGeoNodeCache.html,1,['perform'],['performance']
Performance,"TGeoPainter.; TEveGeoTopNodeEditor Editor for TEveGeoTopNode class.; TEveGridStepper Provide discrete position coordinates for placement of objects on regular grids.; TEveGridStepperEditor Editor for TEveGridStepper class.; TEveGridStepperSubEditor Sub-editor for TEveGridStepper class.; TEveHit Monte Carlo hit (also used in VSD).; TEveJetCone Short description.; TEveJetConeEditor GUI editor for TEveJetCone.; TEveJetConeGL GL renderer class for TEveJetCone.; TEveLegoEventHandler A GL event handler class. Swiches perspective or orthographic camera.; TEveLine An arbitrary polyline with fixed line and marker attributes.; TEveLineEditor Editor for TEveLine class.; TEveLineGL GL-renderer for TEveLine class.; TEveLineProjected Projected replica of a TEveLine.; TEveListTreeItem Special llist-tree-item for Eve.; TEveMCRecCrossRef Cross-reference of sim/rec data per particle (also used in VSD).; TEveMCTrack Monte Carlo track (also used in VSD).; TEveMacro TMacro wrapper (attempting to fix issues with different macro loading and execution schemes).; TEveMagField Abstract interface to magnetic field; TEveMagFieldConst Interface to constant magnetic field.; TEveMagFieldDuo Interface to magnetic field with two different values depending of radius.; TEveManager Eve application manager.; TEveManager::TExceptionHandler Exception handler for Eve exceptions.; TEveManager::TRedrawDisabler Exception-safe EVE redraw-disabler.; TEvePad Internal TEveUtil pad class (sub-class of TPad) overriding handling of updates and 3D-viewers.; TEvePadHolder Exception-safe wrapper for temporary setting of gPad variable.; TEveParamList Eve element to store generic configuration information.; TEveParamList::BoolConfig_t ; TEveParamList::FloatConfig_t ; TEveParamList::IntConfig_t ; TEveParamListEditor GUI editor for TEveParamList.; TEvePathMark Special-point on track: position/momentum reference, daughter creation or decay (also used in VSD).; TEvePlot3D Short description.; TEvePlot3DGL GL renderer class fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:60346,load,loading,60346,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['load'],['loading']
Performance,"TGeoPainter.; TEveGeoTopNodeEditor Editor for TEveGeoTopNode class.; TEveGridStepper Provide discrete position coordinates for placement of objects on regular grids.; TEveGridStepperEditor Editor for TEveGridStepper class.; TEveGridStepperSubEditor Sub-editor for TEveGridStepper class.; TEveHit Monte Carlo hit (also used in VSD).; TEveJetCone Short description.; TEveJetConeEditor GUI editor for TEveJetCone.; TEveJetConeGL GL renderer class for TEveJetCone.; TEveLegoEventHandler A GL event handler class. Swiches perspective or orthographic camera.; TEveLine An arbitrary polyline with fixed line and marker attributes.; TEveLineEditor Editor for TEveLine class.; TEveLineGL GL-renderer for TEveLine class.; TEveLineProjected Projected replica of a TEveLine.; TEveListTreeItem Special llist-tree-item for Eve.; TEveMCRecCrossRef Cross-reference of sim/rec data per particle (also used in VSD).; TEveMCTrack Monte Carlo track (also used in VSD).; TEveMacro TMacro wrapper (attempting to fix issues with different macro loading and execution schemes).; TEveMagField Abstract interface to magnetic field; TEveMagFieldConst Interface to constant magnetic field.; TEveMagFieldDuo Interface to magnetic field with two different values depending of radius.; TEveManager Eve application manager.; TEveManager::TExceptionHandler Exception handler for Eve exceptions.; TEvePad Internal TEveUtil pad class (sub-class of TPad) overriding handling of updates and 3D-viewers.; TEvePadHolder Exception-safe wrapper for temporary setting of gPad variable.; TEveParamList Eve element to store generic configuration information.; TEveParamList::BoolConfig_t ; TEveParamList::FloatConfig_t ; TEveParamList::IntConfig_t ; TEveParamListEditor GUI editor for TEveParamList.; TEvePathMark Special-point on track: position/momentum reference, daughter creation or decay (also used in VSD).; TEvePointSelector TSelector for direct extraction of point-like data from a Tree.; TEvePointSelectorConsumer Virtual base for clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:58777,load,loading,58777,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['load'],['loading']
Performance,"TGeoTranslation *other)Subtracting a translation from this one.Definition TGeoMatrix.cxx:742. Rotations (TGeoRotation class) represent a pure rotation. Data members are Double_t fRotationMatrix[3*3]. Rotations can be defined either by Euler angles, either, by GEANT3 angles:. TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi,theta,psi); // all angles in degrees; This represents the composition of: first a rotation about Z axis with angle phi, then a rotation with theta about the rotated X axis, and finally a rotation with psi about the new Z axis.; r1->SetAngles(th1,phi1,th2,phi2,th3,phi3); th3auto * th3Definition textalign.C:22; th2auto * th2Definition textalign.C:18; th1auto * th1Definition textalign.C:14; This is a rotation defined in GEANT3 style. Theta and phi are the spherical angles of each axis of the rotated coordinate system with respect to the initial one. This construction allows definition of malformed rotations, e.g. not orthogonal. A check is performed and an error message is issued in this case.; Specific utilities: determinant, inverse. Scale transformations (TGeoScale class) - represent a scaled shrinking/enlargement, possibly different on all axes. Data members: Double_t fScale[3]. Not implemented yet.; Combined transformations - represent a rotation followed by a translation. Data members: Double_t fTranslation[3], TGeoRotation *fRotation. TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;; ...; TGeoCombiTrans *c1 = new TGeoCombiTrans(trans,rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). General transformations: (TGeoHMatrix class) represent combined transformations in any order.; Identity transformation: (TGeoIdentity class) is a generic identity transformation represented by a singleton class object gGeoIdentity. Ownership of Geometry Objects; The class TGeoManager class contains the entire API needed for building and tracking geometry. It defines a global pointer gGeoManager in order t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:62935,perform,performed,62935,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['performed']
Performance,"TGeoVolume *vol = (TGeoVolume *)obj;; 1064 vol->SetVisibility(vis);; 1065 } else {; 1066 if (obj->InheritsFrom(TGeoNode::Class())) {; 1067 TGeoNode *node = (TGeoNode *)obj;; 1068 node->SetVisibility(vis);; 1069 } else; 1070 return;; 1071 }; 1072 GetGeomPainter()->ModifiedPad(kTRUE);; 1073}; 1074 ; 1075////////////////////////////////////////////////////////////////////////////////; 1076/// Get the new 'bombed' translation vector according current exploded view mode.; 1077 ; 1078void TGeoManager::BombTranslation(const Double_t *tr, Double_t *bombtr); 1079{; 1080 if (fPainter); 1081 fPainter->BombTranslation(tr, bombtr);; 1082 return;; 1083}; 1084 ; 1085////////////////////////////////////////////////////////////////////////////////; 1086/// Get the new 'unbombed' translation vector according current exploded view mode.; 1087 ; 1088void TGeoManager::UnbombTranslation(const Double_t *tr, Double_t *bombtr); 1089{; 1090 if (fPainter); 1091 fPainter->UnbombTranslation(tr, bombtr);; 1092 return;; 1093}; 1094 ; 1095////////////////////////////////////////////////////////////////////////////////; 1096/// Backup the current state without affecting the cache stack.; 1097 ; 1098void TGeoManager::DoBackupState(); 1099{; 1100 GetCurrentNavigator()->DoBackupState();; 1101}; 1102 ; 1103////////////////////////////////////////////////////////////////////////////////; 1104/// Restore a backed-up state without affecting the cache stack.; 1105 ; 1106void TGeoManager::DoRestoreState(); 1107{; 1108 GetCurrentNavigator()->DoRestoreState();; 1109}; 1110 ; 1111////////////////////////////////////////////////////////////////////////////////; 1112/// Register a matrix to the list of matrices. It will be cleaned-up at the; 1113/// destruction TGeoManager.; 1114 ; 1115void TGeoManager::RegisterMatrix(const TGeoMatrix *matrix); 1116{; 1117 return TGeoBuilder::Instance(this)->RegisterMatrix((TGeoMatrix *)matrix);; 1118}; 1119 ; 1120//////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:39525,cache,cache,39525,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['cache'],['cache']
Performance,"TH3 as color boxes; The supported option is:. ""GLCOL"" ; H3 is drawn using semi-transparent colored boxes.; See $ROOTSYS/tutorials/gl/glvox1.C. TH3 as boxes (spheres); The supported options are:. GLBOX"" ; TH3 as a set of boxes, size of box is proportional to bin content. GLBOX1""; The same as ""glbox"", but spheres are drawn instead of boxes. TH3 as iso-surface(s); The supported option is:. ""GLISO"" ; TH3 is drawn using iso-surfaces. TF3 (implicit function); The supported option is:. GLTF3"" ; Draw a TF3. Parametric surfaces; $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric; equations and visualize the surface.; Interaction with the plots; All the interactions are implemented via standard methods; DistancetoPrimitive() and ExecuteEvent(). That's why all the; interactions with the OpenGL plots are possible only when the mouse cursor is; in the plot's area (the plot's area is the part of a the pad occupied by; gl-produced picture). If the mouse cursor is not above gl-picture, the standard; pad interaction is performed.; Selectable parts; Different parts of the plot can be selected:. xoz, yoz, xoy back planes:; When such a plane selected, it's highlighted in green if the; dynamic slicing by this plane is supported, and it's; highlighted in red, if the dynamic slicing is not supported.; The plot itself:; On surfaces, the selected surface is outlined in red. (TF3 and; ISO are not outlined). On lego plots, the selected bin is; highlighted. The bin number and content are displayed in pad's; status bar. In box plots, the box or sphere is highlighted and; the bin info is displayed in pad's status bar. Rotation and zooming. Rotation:; When the plot is selected, it can be rotated by pressing and; holding the left mouse button and move the cursor.; Zoom/Unzoom:; Mouse wheel or 'j', 'J', 'k', 'K' keys. Panning; The selected plot can be moved in a pad's area by pressing and; holding the left mouse button and the shift key.; Box cut; Surface, iso, box, TF3 and parametr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THistPainter.html:76691,perform,performed,76691,root/html534/THistPainter.html,https://root.cern,https://root.cern/root/html534/THistPainter.html,2,['perform'],['performed']
Performance,"TH3D, and TProfile3D.; Definition at line 208 of file TH3.cxx. ◆ DeclFileName(). static const char * TH3::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 152 of file TH3.h. ◆ DoFillProfileProjection(). void TH3::DoFillProfileProjection ; (; TProfile2D * ; p2, . const TAxis & ; a1, . const TAxis & ; a2, . const TAxis & ; a3, . Int_t ; bin1, . Int_t ; bin2, . Int_t ; bin3, . Int_t ; inBin, . Bool_t ; useWeights . ); const. protected . internal function to fill the bins of the projected profile 2D histogram called from DoProjectProfile2D ; Definition at line 2550 of file TH3.cxx. ◆ DoProject1D() [1/3]. TH1D * TH3::DoProject1D ; (; const char * ; name, . const char * ; title, . const TAxis * ; projAxis, . const TAxis * ; axis1, . const TAxis * ; axis2, . bool ; computeErrors, . bool ; originalRange, . bool ; useUF, . bool ; useOF . ); const. protectedvirtual . internal methdod performing the projection to 1D histogram called from other TH3::DoProject1D ; Definition at line 1889 of file TH3.cxx. ◆ DoProject1D() [2/3]. TH1D * TH3::DoProject1D ; (; const char * ; name, . const char * ; title, . int ; imin1, . int ; imax1, . int ; imin2, . int ; imax2, . const TAxis * ; projAxis, . const TAxis * ; axis1, . const TAxis * ; axis2, . Option_t * ; option . ); const. protectedvirtual . internal method performing the projection to 1D histogram called from TH3::Project3D ; Definition at line 1829 of file TH3.cxx. ◆ DoProject1D() [3/3]. TH1D * TH3::DoProject1D ; (; const TH3 & ; h, . const char * ; name, . const char * ; title, . const TAxis * ; projX, . bool ; computeErrors, . bool ; originalRange, . bool ; useUF, . bool ; useOF . ). staticprotected . static methdod performing the projection to 1D histogram ; Definition at line 3504 of file TH3.cxx. ◆ DoProject2D() [1/2]. TH2D * TH3::DoProject2D ; (; const char * ; name, . const char * ; title, . const TAxis * ; projX, . const TAxis * ; projY, . bool ; computeErrors,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:66626,perform,performing,66626,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,1,['perform'],['performing']
Performance,"TMVA is not build with GPU or CPU multi-thread support. Cannot use TMVA Deep Learning for CNN"");; useTMVACNN = false;; #endif; #endif; ; bool writeOutputFile = true;; ; #ifdef R__USE_IMT; int num_threads = 4; // use by default 4 threads if value is not set before; // switch off MT in OpenBLAS to avoid conflict with tbb; gSystem->Setenv(""OMP_NUM_THREADS"", ""1"");; ; // do enable MT running; if (num_threads >= 0) {; ROOT::EnableImplicitMT(num_threads);; }; #endif; ; TMVA::Tools::Instance();; ; ; std::cout << ""Running with nthreads = "" << ROOT::GetThreadPoolSize() << std::endl;; ; #ifdef R__HAS_PYMVA; gSystem->Setenv(""KERAS_BACKEND"", ""tensorflow"");; // for using Keras; TMVA::PyMethodBase::PyInitialize();; #else; useKerasCNN = false;; usePyTorchCNN = false;; #endif; ; TFile *outputFile = nullptr;; if (writeOutputFile); outputFile = TFile::Open(""TMVA_CNN_ClassificationOutput.root"", ""RECREATE"");; ; /***; ## Create TMVA Factory; ; Create the Factory class. Later you can choose the methods; whose performance you'd like to investigate.; ; The factory is the major TMVA object you have to interact with. Here is the list of parameters you need to pass; ; - The first argument is the base of the name of all the output; weight files in the directory weight/ that will be created with the; method parameters; ; - The second argument is the output file for the training results; ; - The third argument is a string option defining some general configuration for the TMVA session.; For example all TMVA output can be suppressed by removing the ""!"" (not) in front of the ""Silent"" argument in the; option string; ; - note that we disable any pre-transformation of the input variables and we avoid computing correlations between; input variables; ***/; ; TMVA::Factory factory(; ""TMVA_CNN_Classification"", outputFile,; ""!V:ROC:!Silent:Color:AnalysisType=Classification:Transformations=None:!Correlations"");; ; /***; ; ## Declare DataLoader(s); ; The next step is to declare the DataLoader class that deals",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:49349,perform,performance,49349,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['perform'],['performance']
Performance,"TMVA::MethodMLP::fSamplingEpoch. private . fraction of epochs where sampling is used ; Definition at line 177 of file MethodMLP.h. ◆ fSamplingFraction. Float_t TMVA::MethodMLP::fSamplingFraction. private . fraction of events which is sampled for training ; Definition at line 176 of file MethodMLP.h. ◆ fSamplingTesting. Bool_t TMVA::MethodMLP::fSamplingTesting. private . The testing sample is sampled. ; Definition at line 180 of file MethodMLP.h. ◆ fSamplingTraining. Bool_t TMVA::MethodMLP::fSamplingTraining. private . The training sample is sampled. ; Definition at line 179 of file MethodMLP.h. ◆ fSamplingWeight. Float_t TMVA::MethodMLP::fSamplingWeight. private . changing factor for event weights when sampling is turned on ; Definition at line 178 of file MethodMLP.h. ◆ fTau. Double_t TMVA::MethodMLP::fTau. private . line search variable ; Definition at line 184 of file MethodMLP.h. ◆ fTestRate. Int_t TMVA::MethodMLP::fTestRate. private . test for overtraining performed at each #th epochs ; Definition at line 193 of file MethodMLP.h. ◆ fTrainingMethod. ETrainingMethod TMVA::MethodMLP::fTrainingMethod. private . method of training, BP or GA ; Definition at line 173 of file MethodMLP.h. ◆ fTrainMethodS. TString TMVA::MethodMLP::fTrainMethodS. private . training method option param ; Definition at line 174 of file MethodMLP.h. ◆ fUpdateLimit. Int_t TMVA::MethodMLP::fUpdateLimit. private . zjh ; Definition at line 171 of file MethodMLP.h. ◆ fUseRegulator. bool TMVA::MethodMLP::fUseRegulator. private . zjh ; Definition at line 164 of file MethodMLP.h. ◆ fWeightRange. Float_t TMVA::MethodMLP::fWeightRange. private . suppress outliers for the estimator calculation ; Definition at line 206 of file MethodMLP.h. Libraries for TMVA::MethodMLP:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/MethodMLP.h; tmva/tmva/src/MethodMLP.cxx. TMVAMethodMLP. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:36 (GVA Time",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:53690,perform,performed,53690,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['perform'],['performed']
Performance,"TMVA::OptimizeConfigParameters::GetSeparation ; (; ). private . return the separation between the signal and background MVA ouput distribution ; Definition at line 434 of file OptimizeConfigParameters.cxx. ◆ GetSigEffAtBkgEff(). Double_t TMVA::OptimizeConfigParameters::GetSigEffAtBkgEff ; (; Double_t ; bkgEff = 0.1). private . calculate the signal efficiency for a given background efficiency ; Definition at line 509 of file OptimizeConfigParameters.cxx. ◆ IsA(). virtual TClass * TMVA::OptimizeConfigParameters::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::IFitterTarget.; Definition at line 100 of file OptimizeConfigParameters.h. ◆ Log(). MsgLogger & TMVA::OptimizeConfigParameters::Log ; (; ); const. inlineprivate . Definition at line 98 of file OptimizeConfigParameters.h. ◆ optimize(). std::map< TString, Double_t > TMVA::OptimizeConfigParameters::optimize ; (; ). Definition at line 127 of file OptimizeConfigParameters.cxx. ◆ optimizeFit(). void TMVA::OptimizeConfigParameters::optimizeFit ; (; ). private . Definition at line 242 of file OptimizeConfigParameters.cxx. ◆ optimizeScan(). void TMVA::OptimizeConfigParameters::optimizeScan ; (; ). private . do the actual optimization using a simple scan method, i.e. ; calculate the FOM for different tuning paraemters and remember which one is gave the best FOM ; Definition at line 164 of file OptimizeConfigParameters.cxx. ◆ Streamer(). virtual void TMVA::OptimizeConfigParameters::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::IFitterTarget. ◆ StreamerNVirtual(). void TMVA::OptimizeConfigParameters::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 100 of file OptimizeConfigParameters.h. Member Data Documentation. ◆ fAlreadyTrainedParCombination. std::map< std::vector<Double_t> , Double_t> TMVA::OptimizeConfigParameters::fAlreadyTrainedParCombination. private . save parameters for which the FOM is already known (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:9332,optimiz,optimizeFit,9332,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['optimiz'],['optimizeFit']
Performance,"TMVA::Types::kBDT, ""BDTD"",; ""!H:!V:NTrees=400:MinNodeSize=5%:MaxDepth=3:BoostType=AdaBoost:SeparationType=GiniIndex:nCuts=20:VarTransform=Decorrelate"" );; ; if (Use[""BDTF""]) // Allow Using Fisher discriminant in node splitting for (strong) linearly correlated variables; factory->BookMethod( dataloader, TMVA::Types::kBDT, ""BDTF"",; ""!H:!V:NTrees=50:MinNodeSize=2.5%:UseFisherCuts:MaxDepth=3:BoostType=AdaBoost:AdaBoostBeta=0.5:SeparationType=GiniIndex:nCuts=20"" );; ; // RuleFit -- TMVA implementation of Friedman's method; if (Use[""RuleFit""]); factory->BookMethod( dataloader, TMVA::Types::kRuleFit, ""RuleFit"",; ""H:!V:RuleFitModule=RFTMVA:Model=ModRuleLinear:MinImp=0.001:RuleMinDist=0.001:NTrees=20:fEventsMin=0.01:fEventsMax=0.5:GDTau=-1.0:GDTauPrec=0.01:GDStep=0.01:GDNSteps=10000:GDErrScale=1.02"" );; ; // For an example of the category classifier usage, see: TMVAClassificationCategory; //; // --------------------------------------------------------------------------------------------------; // Now you can optimize the setting (configuration) of the MVAs using the set of training events; // STILL EXPERIMENTAL and only implemented for BDT's !; //; // factory->OptimizeAllMethods(""SigEffAtBkg0.01"",""Scan"");; // factory->OptimizeAllMethods(""ROCIntegral"",""FitGA"");; //; // --------------------------------------------------------------------------------------------------; ; // Now you can tell the factory to train, test, and evaluate the MVAs; //; // Train MVAs using the set of training events; factory->TrainAllMethods();; ; // Evaluate all MVAs using the set of test events; factory->TestAllMethods();; ; // Evaluate and compare performance of all configured MVAs; factory->EvaluateAllMethods();; ; // --------------------------------------------------------------; ; // Save the output; outputFile->Write();; ; std::cout << ""==> Wrote root file: "" << outputFile->GetName() << std::endl;; std::cout << ""==> TMVAClassification is done!"" << std::endl;; ; // Launch the GUI for the root macro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:103364,optimiz,optimize,103364,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['optimiz'],['optimize']
Performance,"TMVA_Classification_Keras.root', 'RECREATE'); 26factory = TMVA.Factory('TMVAClassification', output,; 27 '!V:!Silent:Color:DrawProgressBar:Transformations=D,G:AnalysisType=Classification'); 28 ; 29# Load data; 30if not isfile('tmva_class_example.root'):; 31 call(['curl', '-L', '-O', 'http://root.cern/files/tmva_class_example.root']); 32 ; 33data = TFile.Open('tmva_class_example.root'); 34signal = data.Get('TreeS'); 35background = data.Get('TreeB'); 36 ; 37dataloader = TMVA.DataLoader('dataset'); 38for branch in signal.GetListOfBranches():; 39 dataloader.AddVariable(branch.GetName()); 40 ; 41dataloader.AddSignalTree(signal, 1.0); 42dataloader.AddBackgroundTree(background, 1.0); 43dataloader.PrepareTrainingAndTestTree(TCut(''),; 44 'nTrain_Signal=4000:nTrain_Background=4000:SplitMode=Random:NormMode=NumEvents:!V'); 45 ; 46# Generate model; 47 ; 48# Define model; 49model = Sequential(); 50model.add(Dense(64, activation='relu', input_dim=4)); 51model.add(Dense(2, activation='softmax')); 52 ; 53# Set loss and optimizer; 54model.compile(loss='categorical_crossentropy',; 55 optimizer=SGD(learning_rate=0.01), weighted_metrics=['accuracy', ]); 56 ; 57# Store model to file; 58model.save('modelClassification.h5'); 59model.summary(); 60 ; 61# Book methods; 62factory.BookMethod(dataloader, TMVA.Types.kFisher, 'Fisher',; 63 '!H:!V:Fisher:VarTransform=D,G'); 64factory.BookMethod(dataloader, TMVA.Types.kPyKeras, 'PyKeras',; 65 'H:!V:VarTransform=D,G:FilenameModel=modelClassification.h5:FilenameTrainedModel=trainedModelClassification.h5:NumEpochs=20:BatchSize=32'); 66 ; 67# Run training, test and evaluation; 68factory.TrainAllMethods(); 69factory.TestAllMethods(); 70factory.EvaluateAllMethods(); TCutA specialized string object used for TTree selections.Definition TCut.h:25; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ClassificationKeras_8py_source.html:1872,optimiz,optimizer,1872,doc/master/ClassificationKeras_8py_source.html,https://root.cern,https://root.cern/doc/master/ClassificationKeras_8py_source.html,1,['optimiz'],['optimizer']
Performance,TMVA_Higgs_Classification_Likelihood.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_Fisher.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_BDT.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_DNN_CPU.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_PyKeras.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: Likelihood for Classification performance; : ; Likelihood : [dataset] : Evaluation of Likelihood on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0107 sec ; Factory : Test method: Fisher for Classification performance; : ; Fisher : [dataset] : Evaluation of Fisher on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.00276 sec ; : Dataset[dataset] : Evaluation of Fisher on testing sample; Factory : Test method: BDT for Classification performance; : ; BDT : [dataset] : Evaluation of BDT on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0472 sec ; Factory : Test method: DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : m_jj: 0.017919 1.0069 [ -3.3498 3.4247 ]; : m_jjj: 0.020352 1.0044 [ -3.2831 3.3699 ]; : m_lv: 0.016356 0.99266 [ -3.2339 3.3958 ]; : m_jlv: -0.018431 0.98242 [ -3.0632 5.7307 ]; : m_bb: 0.0069564 0.98851 [ -2.9734 3.3513 ]; : m_wbb: -0.010633 0.99340 [ -3.2442 3.2244 ]; : m_wwbb: -0.012669 0.99259 [ -3.1871 5.7307 ]; : -----------------------------------------------------------; DNN_CPU : [dataset] : Evaluation of DNN_CPU on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0995 sec ; Factory : Test method: PyKeras for Classification performance; : ; : Setting up tf.kera,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:49749,perform,performance,49749,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['perform'],['performance']
Performance,"TMacro ; (; const TMacro & ; macro). Copy constructor. ; Definition at line 98 of file TMacro.cxx. ◆ TMacro() [3/3]. TMacro::TMacro ; (; const char * ; name, . const char * ; title = """" . ). Create a macro with a name and a title. ; If name contains a '.' it is assumed to be the name of a file, and; the macro is automatically filled by reading all the lines in the file,; if the title is empty, it will be set to the name of the file,; the name will be set to the filename without path or extension. . Definition at line 75 of file TMacro.cxx. ◆ ~TMacro(). TMacro::~TMacro ; (; ). virtual . Delete this macro. ; Definition at line 111 of file TMacro.cxx. Member Function Documentation. ◆ AddLine(). TObjString * TMacro::AddLine ; (; const char * ; text). virtual . Add line with text in the list of lines of this macro. ; Definition at line 138 of file TMacro.cxx. ◆ Browse(). void TMacro::Browse ; (; TBrowser * ; b). overridevirtual . When clicking in the browser, the following action is performed on this macro, depending the content of the variable TMacro.Browse. ; TMacro.Browse can be set in the system.rootrc or .rootrc file like: TMacro.Browse : Action; TMacro::Browsevoid Browse(TBrowser *b) overrideWhen clicking in the browser, the following action is performed on this macro, depending the content ...Definition TMacro.cxx:171; or set via gEnv->SetValue, eg gEnv->SetValue(""TMacro.Browse"",""Print"");; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; TEnv::SetValuevirtual void SetValue(const char *name, const char *value, EEnvLevel level=kEnvChange, const char *type=nullptr)Set the value of a resource or create a new resource.Definition TEnv.cxx:736; By default TMacro.Browse="""" -if TMacro.Browse ="""" the macro is executed -if TMacro.Browse =""Print"" the macro is printed in stdout -if TMacro.Browse is of the form ""mymacro.C"" the macro void mymacro.C(TMacro *m) is called where m=this macro An example of macro.C saving the macro into a file and viewing it with emacs is shown below: v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacro.html:15383,perform,performed,15383,doc/master/classTMacro.html,https://root.cern,https://root.cern/doc/master/classTMacro.html,1,['perform'],['performed']
Performance,"TMatrixT<Element> c(a, TMatrixT::kMult, b);; 161/// Supported operations are: kMult (a*b), kTransposeMult (a'*b), kInvMult (a^(-1)*b);; 162/// Whenever kInvMult is invoked and b is not squared, additional memory is allocated for a^(-1); 163 ; 164template <class Element>; 165TMatrixT<Element>::TMatrixT(const TMatrixT<Element> &a, EMatrixCreatorsOp2 op, const TMatrixT<Element> &b); 166{; 167 R__ASSERT(a.IsValid());; 168 R__ASSERT(b.IsValid());; 169 ; 170 switch (op) {; 171 case kMult:; 172 Allocate(a.GetNrows(), b.GetNcols(), a.GetRowLwb(), b.GetColLwb(), 1);; 173 Mult(a, b);; 174 break;; 175 ; 176 case kTransposeMult:; 177 Allocate(a.GetNcols(), b.GetNcols(), a.GetColLwb(), b.GetColLwb(), 1);; 178 TMult(a, b);; 179 break;; 180 ; 181 case kMultTranspose:; 182 Allocate(a.GetNrows(), b.GetNrows(), a.GetRowLwb(), b.GetRowLwb(), 1);; 183 MultT(a, b);; 184 break;; 185 ; 186 case kInvMult: {; 187 Allocate(a.GetNrows(), b.GetNcols(), a.GetRowLwb(), b.GetColLwb(), 1);; 188 // if size(a) == size(b), perform in place computation; 189 if (a.GetNrows() == b.GetNcols()) {; 190 *this = a;; 191 const Element oldTol = this->SetTol(std::numeric_limits<Element>::min());; 192 this->Invert();; 193 this->SetTol(oldTol);; 194 *this *= b;; 195 } else {; 196 TMatrixT<Element> ainv = a;; 197 const Element oldTol = ainv.SetTol(std::numeric_limits<Element>::min());; 198 ainv.Invert();; 199 ainv.SetTol(oldTol);; 200 Mult(ainv, b);; 201 }; 202 break;; 203 }; 204 ; 205 case kPlus: {; 206 Allocate(a.GetNrows(), a.GetNcols(), a.GetRowLwb(), a.GetColLwb(), 1);; 207 Plus(a, b);; 208 break;; 209 }; 210 ; 211 case kMinus: {; 212 Allocate(a.GetNrows(), a.GetNcols(), a.GetRowLwb(), a.GetColLwb(), 1);; 213 Minus(a, b);; 214 break;; 215 }; 216 ; 217 default: Error(""TMatrixT(EMatrixCreatorOp2)"", ""operation %d not yet implemented"", op);; 218 }; 219}; 220 ; 221////////////////////////////////////////////////////////////////////////////////; 222/// Constructor of matrix applying a specific operation to two prot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMatrixT_8cxx_source.html:7045,perform,perform,7045,doc/master/TMatrixT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html,1,['perform'],['perform']
Performance,"TOP is invisible; root[] top->Draw();; kMagenta@ kMagentaDefinition Rtypes.h:66; TGeoManager::SetTopVisiblevoid SetTopVisible(Bool_t vis=kTRUE)make top volume visible on screenDefinition TGeoManager.cxx:2396. Example 2: A Geometrical Hierarchy Look and Feel; Before going further, let us get a look and feel of interacting with the modeller. For this, we will use one of the examples illustrating the geometry package. To get an idea on the geometry structure created in this example, just look at rootgeom.C. You will notice that this is a bit more complex that just creating the ""world"" since several other volumes are created and put together in a hierarchy. The purpose here is just to learn how to interact with a geometry that is already built, but just few hints on the building steps in this example might be useful. The geometry here represents the word ROOT that is replicated in some symmetric manner. You might for instance ask some questions after having a first look:; Q: ""OK, I understand the first lines that load the libGeom library and create; a geometry manager object. I also recognize from the previous example the following; lines creating some materials and media, but what about the geometrical transformations below?""; A: As explained before, the model that we are trying to create is a hierarchy of volumes based on ""containment"". This is accomplished by ""positioning"" some volumes ""inside"" others. Any volume is an un-positioned object in the sense that it defines only a ""local frame"" (matching the one of its ""shape""). In order to fully define the mother-daughter relationship between two volumes one has to specify how the daughter will be positioned inside. This is accomplished by defining a ""local geometrical transformation"" of the daughter with respect to the mother coordinate system. These transformations will be subsequently used in the example.; Q: ""I see the lines defining the top level volume as in the previous example,; but what about the other volumes na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:8177,load,load,8177,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['load'],['load']
Performance,"TOP_1), but none of the daughters of volume B does. After finding out the node containing the particle, one can check if the geometry state is different compared to the last located point:; Bool_t *TGeoManager::IsSameLocation(); The algorithm for finding where a point is located in geometry is presented in the figure 17-36.; It always starts by checking if the last computed modeller state is the answer. This optimizes the search when continuously tracking a particle. The main actions performed are:. moving up and down in the logical node tree while updating the current node and its global matrix; converting the global position into the local frame of the current node/volume; checking whether the local position lies within the geometrical shape of the current volume - if this is the case continue the search downwards for the daughters of the current node, otherwise search upwards its containers until the top level is reached.; the number of candidate nodes to be checked at a given level is minimized by an additional optimization structure: voxels. This is effective even in case there is only one daughter of the current volume.; in case the current node is declared as possibly overlapping, the method FindInCluster() is invoked. This method checks all different possibilities within the cluster of overlapping candidates. One of the candidates is prioritized if one of the following conditions id fulfilled (in order):; Is declared as non-overlapping (these are anyway searched first); Has at least one daughter that contains the current point; Was already declared as containing the point at a previous step. Finding the location of a point in the geometry hierarchy. 18.10.2 Finding the Distance to Next Crossed Boundary; The most important feature provided by the modeller related to track propagation is the computation of the distance to the next boundary along a straight line.; The relevant state parameters used for this task are:. Current particle position and direction (x,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1024755,optimiz,optimization,1024755,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimization']
Performance,"TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. private:. THashList(const THashList&); THashList&operator=(const THashList&). Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*fTableHashtable used for quick lookup of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashList object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehash is the value at which a rehash will be triggered. I.e. when the; average size of the linked lists at a slot becomes longer than rehash; then the hashtable will be resized and refilled to reduce the collision; rate to about 1. The higher the collision rate, i.e. the longer the; linked lists, the longer lookup will take. If rehash=0 the table will; NOT automatically be rehashed. Use Rehash() for manual rehashin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THashList.html:9971,cache,cache,9971,root/html528/THashList.html,https://root.cern,https://root.cern/root/html528/THashList.html,4,['cache'],['cache']
Performance,"TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidPrintCollectionHeader(Option_t* option) const. private:. TQCommand&operator=(const TQCommand&). Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfNRargsnumber of redo arguments; Int_tfNUargsnumber of undo arguments; TStringfNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tfNewDeletekTRUE if Redo/Undo methods are new/delete; void*fObjectobject to which undo/redo actions applied; TQConnection*fRedodo/redo action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQCommand.html:16623,cache,cache,16623,root/html534/TQCommand.html,https://root.cern,https://root.cern/root/html534/TQCommand.html,1,['cache'],['cache']
Performance,"TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; TString fJobID;  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . Additional Inherited Members;  Public Types inherited from TList; typedef TListIter Iterator_t;  ;  Public Types inherited from TCollection; enum  { kInitCapacity = 16; , kInitHashTableCapacity = 17; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1UL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGridJobStatusList.html:16274,cache,cache,16274,doc/master/classTGridJobStatusList.html,https://root.cern,https://root.cern/doc/master/classTGridJobStatusList.html,1,['cache'],['cache']
Performance,"TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum { kActivated; kShowRanges; };; enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. private:. TStringfTitleTitle of the selection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParallelCoordSelect(); Default constructor. TParallelCoordSelect(const char* title); Normal constructor. ~TParallelCoordSelect(); Destructor. void SetActivated(Bool_t on); Activate the selection. void SetShowRanges(Bool_t s); Show the ranges niddles. const char* GetTitle() const; {return fTitle.Data();}. void SetTitle(const char* title); {fTitle = title;}. » Author: Bastien Dalla Piazza 02/08/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/treeviewer:$Id$ » Last generated: 2015-03-14 16:46; This page has been automaticall",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TParallelCoordSelect.html:10532,cache,cache,10532,root/html534/TParallelCoordSelect.html,https://root.cern,https://root.cern/root/html534/TParallelCoordSelect.html,1,['cache'],['cache']
Performance,"TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum { kActivated; kShowRanges; };; enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. private:. TStringfTitleTitle of the selection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParallelCoordSelect(); Default constructor. TParallelCoordSelect(const char* title); Normal constructor. ~TParallelCoordSelect(); Destructor. void SetActivated(Bool_t on); Activate the selection. void SetShowRanges(Bool_t s); Show the ranges niddles. const char* GetTitle() const; {return fTitle.Data();}. void SetTitle(const char* title); {fTitle = title;}. » Author: Bastien Dalla Piazza 02/08/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/treeviewer:$Id: TParallelCoordRange.h 20882 2007-11-19 11:31:26Z rdm $ » Last gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TParallelCoordSelect.html:10440,cache,cache,10440,root/html530/TParallelCoordSelect.html,https://root.cern,https://root.cern/root/html530/TParallelCoordSelect.html,2,['cache'],['cache']
Performance,"TObject* obj, const char* keyname); virtual Int_tRecover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tSetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidSetCacheRead(TFileCacheRead* cache); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionAlgorithm(Int_t algorithm = 0); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tSetOnlyStaged(Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFile.html:13137,cache,cacheDir,13137,root/html532/TFile.html,https://root.cern,https://root.cern/root/html532/TFile.html,1,['cache'],['cacheDir']
Performance,"TObject* obj, const char* keyname); virtual Int_tRecover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tSetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidSetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionAlgorithm(Int_t algorithm = 0); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFile.html:13209,cache,cacheDir,13209,root/html534/TFile.html,https://root.cern,https://root.cern/root/html534/TFile.html,3,['cache'],['cacheDir']
Performance,"TObject::(anonymous)TObject::kSingleKey; static TDictionary::ESTLTypeTDictionary::kVector; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TClass*fClass!owning class; THashListfConstantListlist of constants the enum type; void*fInfo!interpreter implementation provided declaration; stringfQualNamefully qualified type name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEnum(const char* name, void* info, TClass* cls); Constructor for TEnum class.; It take the name of the TEnum type, specification if it is global; and interpreter info.; Constant List is owner if enum not on global scope (thus constants not; in TROOT::GetListOfGlobals). ~TEnum(); Destructor. void AddConstant(TEnumConstant* constant); Add a EnumConstant to the list of constants of the Enum Type. Bool_t IsValid(); Return true if this enum object is pointing to a currently; loaded enum. If a enum is unloaded after the TEnum; is created, the TEnum will be set to be invalid. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void Update(TDictionary::DeclId_t id). TEnum * GetEnum(const std::type_info &ti, ESearchAction sa). TEnum * GetEnum(const char* enumName, TEnum::ESearchAction sa = kALoadAndInterpLookup); Static function to retrieve enumerator from the ROOT's typesystem.; It has no side effect, except when the load flag is true. In this case,; the load of the library containing the scope of the enumerator is attempted.; There are two top level code paths: the enumerator is scoped or isn't.; If it is not, a lookup in the list of global enums is performed.; If it is, two lookups are carried out for its scope: one in the list of; classes and one in the list of protoclasses. If a scope with the desired name; is found, the enum is searched. If the scope is not found, and the load flag i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEnum.html:8128,load,loaded,8128,root/html602/TEnum.html,https://root.cern,https://root.cern/root/html602/TEnum.html,1,['load'],['loaded']
Performance,"TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooArgSet*_ccdCloneSet; Bool_t_ccdRefresh; RooSuperCategory*_ccdSuperSuperCategory of Common category dependents; Double_t*_ccdTable; RooArgSet_commonCatsCommon category dependents; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; list<RooAbsGenContext*>_gcListList of component generator contexts; RooDataSet*RooAbsGenContext::_genData! Data being generated; Bool_tRooAbsGenContext::_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; RooArgSet_ownedMultiProdsOwned auxilary multi-term product PDFs; const RooProdPdf*_pdfOriginal PDF; RooRealIntegral*_pdfCcdInt; RooAbsPdf*_pdfClone; RooArgSet*_pdfCloneSet; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; TIterator*_uniIterIterator over uniform observables; RooArgSet_uniObsObservable to be generated with flat distribution; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProdGenContext(const RooProdPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). ~RooProdGenContext(); Destructor. Delete all owned subgenerator contexts. void attach(const RooArgSet& params); Attach generator to given event buffer. void initGenerator(const RooArgSet& theEvent); One-ti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProdGenContext.html:9430,load,load,9430,root/html602/RooProdGenContext.html,https://root.cern,https://root.cern/root/html602/RooProdGenContext.html,2,['load'],['load']
Performance,"TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObjArray*TEntryList::fBlocksblocks with indices of passing events (TEntryListBlocks); TEntryList*TEntryList::fCurrent! currently filled entry list; TDirectory*TEntryList::fDirectory! Pointer to directory holding this tree; Long64_tTEntryList::fEntriesToProcessused on proof to set the number of entries to process in a packet; Long64_tfEntrythe entry number, when the list is used for subentries; TStringTEntryList::fFileNamename of the file, where the tree is; Long64_tTEntryList::fLastIndexQueried! used to optimize GetEntry() function from a loop; Long64_tTEntryList::fLastIndexReturned! used to optimize GetEntry() function from a loop; TEntryListArray*fLastSubListQueried! last sublist checked by GetSubListForEntry; TList*TEntryList::fListsa list of underlying entry lists for each tree of a chain; Long64_tTEntryList::fNnumber of entries in the list; Int_tTEntryList::fNBlocksnumber of TEntryListBlocks; TStringTNamed::fNameobject identifier; Bool_tTEntryList::fReapplyIf true, TTree::Draw will 'reapply' the original cut; Bool_tTEntryList::fShift! true when some sub-lists don't correspond to trees; ULong_tTEntryList::fStringHash! Hash value of a string of treename and filename; TIter*fSubListIter! to iterate over fSubLists and keep last one checked; TList*fSubListsa list of underlying entry lists for each event of a TEntryList; TStringTNamed::fTitleobject title; TStringTEntryList::fTreeNamename of the tree; Int_tTEntryList::fTreeNumber! the index of the tree in the chain (used when the entry. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(); Initialize data members, called by Reset. TEntryListArray(); default c-tor. TEntryListArray(const char* name, const char* title); c-tor with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEntryListArray.html:11725,optimiz,optimize,11725,root/html602/TEntryListArray.html,https://root.cern,https://root.cern/root/html602/TEntryListArray.html,4,['optimiz'],['optimize']
Performance,"TObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TKey*TDirectory::FindKey(const char*) const; virtual TKey*TDirectory::FindKeyAny(const char*) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*TDirectory::FindObjectAnyFile(const char*) const; const char*FindObjectClassName(const char* name) const; const char*FindObjectPathName(const TObject* obj) const; TObject*FindSpecialObject(const char* name, void*& where); TClass*FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; voidForceStyle(Bool_t force = kTRUE); Bool_tFromPopUp() const; virtual TObject*TDirectory::Get(const char* namecycle); TApplication*GetApplication() const; virtual Int_tTDirectory::GetBufferSize() const; Int_tGetBuiltDate() const; Int_tGetBuiltTime() const; TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TObject*GetGeometry(const char* name) const; TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:4901,load,load,4901,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['load'],['load']
Performance,"TObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfParListList of PARs to be loaded; TProof*fProofProof; TStringfSelNameName of the selector to be run; TStringfSelOptionOption field for processing the selector. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBenchRun(TProof* proof = 0, const char* sel = 0); Constructor: check PROOF and load selectors PAR. ~TProofBenchRun(); destructor. TProofBenchRun(TProof* proof = 0, const char* sel = 0). const char * GetSelName(); { return fSelName; }. const char * GetParList(); { return fParList; }. void SetSelName(const char* sel); { fSelName = sel; }. void SetParList(const char* pars); { fParList = pars; }. void SetSelOption(const char* opt); { fSelOption = opt; }. void Run(Long64_t nevents, Int_t start = -1, Int_t stop = -1, Int_t step = -1, Int_t ntries = -1, Int_t debug = -1, Int_t draw = -1). void Print(Option_t* option = """") const. » Author: Sangsu Ryu 22/06/2010 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-02 16:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofBenchRun.html:6627,load,load,6627,root/html604/TProofBenchRun.html,https://root.cern,https://root.cern/root/html604/TProofBenchRun.html,1,['load'],['load']
Performance,"TObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfParListList of PARs to be loaded; TProof*fProofProof; TStringfSelNameName of the selector to be run; TStringfSelOptionOption field for processing the selector. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBenchRun(TProof* proof = 0, const char* sel = 0); Constructor: check PROOF and load selectors PAR. ~TProofBenchRun(); destructor. TProofBenchRun(TProof* proof = 0, const char* sel = 0). const char * GetSelName(); { return fSelName; }. const char * GetParList(); { return fParList; }. void SetSelName(const char* sel); { fSelName = sel; }. void SetParList(const char* pars); { fParList = pars; }. void SetSelOption(const char* opt); { fSelOption = opt; }. void Run(Long64_t nevents, Int_t start = -1, Int_t stop = -1, Int_t step = -1, Int_t ntries = -1, Int_t debug = -1, Int_t draw = -1). void Print(Option_t* option = """") const. » Author: Sangsu Ryu 22/06/2010 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-30 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofBenchRun.html:6627,load,load,6627,root/html602/TProofBenchRun.html,https://root.cern,https://root.cern/root/html602/TProofBenchRun.html,1,['load'],['load']
Performance,TObject::kMustCleanup; static TTree::ESetBranchAddressStatusTTree::kNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Float_t*fArgs! [fNvar] Array of variables; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTree::fEventList! Po,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNtuple.html:23537,cache,cache,23537,root/html602/TNtuple.html,https://root.cern,https://root.cern/root/html602/TNtuple.html,2,['cache'],['cache']
Performance,"TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd, Int_t nwk = 1); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary | kForward | kCp | kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidTProof::SendInputDataFile(); voidTProof::SetDSet(TDSet* dset); voidTProof::SetFeedback(TString& opt, TString& optfb, Int_t action); voidTProof::SetPlayer(TVirtualProofPlayer* player); static void*TProof::SlaveStartupThread(void* arg); virtual Bool_tStartSlaves(Bool_t); static voidTProof::SystemCmd(const char* cmd, Int_t fdout); voidTProof::UpdateDialog(); virtual voidValidateDSet(TDSet* dset); Int_tTProof::VerifyDataSetParallel(const char* uri, const char* optStr).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofSuperMaster.html:22487,cache,cachedir,22487,root/html602/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html602/TProofSuperMaster.html,1,['cache'],['cachedir']
Performance,"TQClass.h. ◆ DefineBehavior() [2/2]. const TInitBehavior * ROOT::Internal::DefineBehavior ; (; void * ; , . void * ;  . ). Definition at line 44 of file TGenericClassInfo.cxx. ◆ DeleteChangesMemory(). bool ROOT::Internal::DeleteChangesMemory ; (; ). Definition at line 127 of file TObject.cxx. ◆ DeleteChangesMemoryImpl(). bool ROOT::Internal::DeleteChangesMemoryImpl ; (; ). Definition at line 76 of file TObject.cxx. ◆ DisableParBranchProcessing(). void ROOT::Internal::DisableParBranchProcessing ; (; ). Globally disables the IMT use case of parallel branch processing, deactivating the corresponding locks. ; Definition at line 434 of file TROOT.cxx. ◆ EmptyCollection(). const TCollection & ROOT::Internal::EmptyCollection ; (; ). Return an empty collection for use with nullptr TRangeCast. ; Definition at line 822 of file TCollection.cxx. ◆ EnableParBranchProcessing(). void ROOT::Internal::EnableParBranchProcessing ; (; ). Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in ROOT, activating the required locks. ; This IMT use case, implemented in TTree::GetEntry, spawns a task for each branch of the tree. Therefore, a task takes care of the reading, decompression and deserialisation of a given branch. ; Definition at line 420 of file TROOT.cxx. ◆ GenericShowMembers(). void ROOT::Internal::GenericShowMembers ; (; const char * ; topClassName, . void * ; obj, . TMemberInspector & ; R__insp, . bool ; transientMember . ). inline . Definition at line 24 of file RtypesImp.h. ◆ GetArrayType(). TString ROOT::Internal::GetArrayType ; (; TStreamerElement * ; element, . const char * ; subtype, . TTreeProxyGenerator::EContainer ; container . ). Definition at line 131 of file TTreeProxyGenerator.cxx. ◆ GetClassHelper() [1/2]. template<typename T > . TClass * ROOT::Internal::GetClassHelper ; (; Bool_t ; load, . Bool_t ; silent, . std::false_type ;  . ). Definition at line 646 of file TClass.h. ◆ GetClassHelper() [2/2]. template<typename T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html:32444,multi-thread,multi-threading,32444,doc/v632/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html,1,['multi-thread'],['multi-threading']
Performance,"TQClass.h. ◆ DefineBehavior() [2/2]. const TInitBehavior * ROOT::Internal::DefineBehavior ; (; void * ; , . void * ;  . ). Definition at line 45 of file TGenericClassInfo.cxx. ◆ DeleteChangesMemory(). bool ROOT::Internal::DeleteChangesMemory ; (; ). Definition at line 133 of file TObject.cxx. ◆ DeleteChangesMemoryImpl(). bool ROOT::Internal::DeleteChangesMemoryImpl ; (; ). Definition at line 76 of file TObject.cxx. ◆ DisableParBranchProcessing(). void ROOT::Internal::DisableParBranchProcessing ; (; ). Globally disables the IMT use case of parallel branch processing, deactivating the corresponding locks. ; Definition at line 434 of file TROOT.cxx. ◆ EmptyCollection(). const TCollection & ROOT::Internal::EmptyCollection ; (; ). Return an empty collection for use with nullptr TRangeCast. ; Definition at line 822 of file TCollection.cxx. ◆ EnableParBranchProcessing(). void ROOT::Internal::EnableParBranchProcessing ; (; ). Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in ROOT, activating the required locks. ; This IMT use case, implemented in TTree::GetEntry, spawns a task for each branch of the tree. Therefore, a task takes care of the reading, decompression and deserialisation of a given branch. ; Definition at line 420 of file TROOT.cxx. ◆ EvalParMultiDim(). void ROOT::Internal::EvalParMultiDim ; (; TF1 * ; func, . Double_t * ; out, . const Double_t * ; x, . std::size_t ; size, . std::size_t ; rows, . Double_t * ; params . ). inline . Definition at line 796 of file TF1.h. ◆ GenericShowMembers(). void ROOT::Internal::GenericShowMembers ; (; const char * ; topClassName, . void * ; obj, . TMemberInspector & ; R__insp, . bool ; transientMember . ). inline . Definition at line 24 of file RtypesImp.h. ◆ GetArrayType(). TString ROOT::Internal::GetArrayType ; (; TStreamerElement * ; element, . const char * ; subtype, . TTreeProxyGenerator::EContainer ; container . ). Definition at line 131 of file TTreeProxyGenerator.cxx. ◆ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:32786,multi-thread,multi-threading,32786,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,1,['multi-thread'],['multi-threading']
Performance,"TQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); Int_tTProof::Exec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* uri); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofLite.html:5836,load,loadopts,5836,root/html602/TProofLite.html,https://root.cern,https://root.cern/root/html602/TProofLite.html,2,['load'],['loadopts']
Performance,"TQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); Int_tTProof::Exec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tTProof::ExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofCondor.html:6063,load,loadopts,6063,root/html602/TProofCondor.html,https://root.cern,https://root.cern/root/html602/TProofCondor.html,4,['load'],['loadopts']
Performance,"TRING ,; 5816 ""s"" , ""selection_file"" ,; 5817 ROOT::option::FullArg::Required,; 5818 selectionFilenameUsage; 5819 },; 5820 ; 5821 {; 5822 ROOTMAP,; 5823 STRING ,; 5824 """" , ""rootmap"" ,; 5825 ROOT::option::FullArg::Required,; 5826 rootmapUsage; 5827 },; 5828 ; 5829 {; 5830 ROOTMAPLIB,; 5831 STRING ,; 5832 """" , ""rootmap-lib"" ,; 5833 ROOT::option::FullArg::Required,; 5834 rootmapLibUsage; 5835 },; 5836 ; 5837 {; 5838 INTERPRETERONLY,; 5839 NOTYPE,; 5840 """" , ""interpreteronly"",; 5841 ROOT::option::Arg::None,; 5842 ""--interpreteronly\tDo not generate I/O related information.\n""; 5843 "" Generate minimal dictionary required for interactivity.\n""; 5844 },; 5845 ; 5846 {; 5847 SPLIT,; 5848 NOTYPE,; 5849 """" , ""split"",; 5850 ROOT::option::Arg::None,; 5851 ""--split\tSplit the dictionary\n""; 5852 "" Split in two the dictionary, isolating the part with\n""; 5853 "" ClassDef related functions in a separate file.\n""; 5854 },; 5855 ; 5856 {; 5857 PCMFILENAME,; 5858 STRING ,; 5859 ""m"" , """" ,; 5860 ROOT::option::FullArg::Required,; 5861 ""-m \tPcm file loaded before any header (option can be repeated).\n""; 5862 },; 5863 ; 5864 {; 5865 VERBOSE,; 5866 NOTYPE ,; 5867 ""-v"" , ""verbose"",; 5868 ROOT::option::Arg::None,; 5869 ""-v, --verbose\tPrint some debug information.\n""; 5870 },; 5871 ; 5872 {; 5873 DEBUG,; 5874 NOTYPE ,; 5875 """" , ""debug"",; 5876 ROOT::option::Arg::None,; 5877 ""--debug\tPrint all debug information.\n""; 5878 },; 5879 ; 5880 {; 5881 QUIET,; 5882 NOTYPE ,; 5883 """" , ""quiet"",; 5884 ROOT::option::Arg::None,; 5885 ""--quiet\tPrint only warnings and errors (default).\n""; 5886 },; 5887 ; 5888 {; 5889 SILENT,; 5890 NOTYPE ,; 5891 """" , ""silent"",; 5892 ROOT::option::Arg::None,; 5893 ""--silent\tPrint no information at all.\n""; 5894 },; 5895 ; 5896 {; 5897 WRITEEMPTYROOTPCM,; 5898 NOTYPE ,; 5899 """" , ""writeEmptyPCM"",; 5900 ROOT::option::Arg::None,; 5901 ""--writeEmptyPCM\tWrite an empty ROOT pcm.\n""; 5902 },; 5903 ; 5904 {; 5905 CXXMODULE,; 5906 NOTYPE ,; 5907 """" , ""cxxmodule"",; 5908 ROOT::op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:233666,load,loaded,233666,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['load'],['loaded']
Performance,"TROOT.cxx:1718; TROOT::GetListOfBrowsersTSeqCollection * GetListOfBrowsers() constDefinition TROOT.h:245; TROOT::ReadingObjectBool_t ReadingObject() constDeprecated (will be removed in next release).Definition TROOT.cxx:2460; TROOT::fStylesTSeqCollection * fStylesList of styles.Definition TROOT.h:150; TROOT::fVersionDateInt_t fVersionDateDate of ROOT version (ex 951226)Definition TROOT.h:116; TROOT::GetListOfColorsTSeqCollection * GetListOfColors() constDefinition TROOT.h:232; TROOT::MacroLongptr_t Macro(const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE)Execute a macro in the interpreter.Definition TROOT.cxx:2316; TROOT::fBuiltTimeInt_t fBuiltTimeTime of ROOT built.Definition TROOT.h:119; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the interpreter construction.Definition TROOT.cxx:2952; TROOT::GetClassTClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE) constReturn pointer to class with name. Obsolete, use TClass::GetClass directly.Definition TROOT.cxx:1518; TROOT::fSelectPadTVirtualPad * fSelectPadCurrently selected pad.Definition TROOT.h:139; TROOT::fFilesTSeqCollection * fFilesList of files.Definition TROOT.h:146; TROOT::Browsevoid Browse(TBrowser *b) overrideAdd browsable objects to TBrowser.Definition TROOT.cxx:1056; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2979; TROOT::GetGlobalFunctionsTListOfFunctions * GetGlobalFunctions()Internal routine returning, and creating if necessary, the list of global function.Definition TROOT.cxx:1663; TROOT::fInterruptBool_t fInterruptTrue if macro should be interrupted.Definition TROOT.h:134; TROOT::fMustCleanBool_t fMustCleanTrue if object destructor scans canvases.Definition TROOT.h:132; TROOT::LoadClassInt_t LoadClass(const char *classname, const char *libname, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:156989,load,load,156989,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['load'],['load']
Performance,"TROOT.cxx:1718; TROOT::GetListOfBrowsersTSeqCollection * GetListOfBrowsers() constDefinition TROOT.h:245; TROOT::ReadingObjectBool_t ReadingObject() constDeprecated (will be removed in next release).Definition TROOT.cxx:2460; TROOT::fStylesTSeqCollection * fStylesList of styles.Definition TROOT.h:150; TROOT::fVersionDateInt_t fVersionDateDate of ROOT version (ex 951226)Definition TROOT.h:116; TROOT::GetListOfColorsTSeqCollection * GetListOfColors() constDefinition TROOT.h:232; TROOT::MacroLongptr_t Macro(const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE)Execute a macro in the interpreter.Definition TROOT.cxx:2316; TROOT::fBuiltTimeInt_t fBuiltTimeTime of ROOT built.Definition TROOT.h:119; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the interpreter construction.Definition TROOT.cxx:2956; TROOT::GetClassTClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE) constReturn pointer to class with name. Obsolete, use TClass::GetClass directly.Definition TROOT.cxx:1518; TROOT::fSelectPadTVirtualPad * fSelectPadCurrently selected pad.Definition TROOT.h:139; TROOT::fFilesTSeqCollection * fFilesList of files.Definition TROOT.h:146; TROOT::Browsevoid Browse(TBrowser *b) overrideAdd browsable objects to TBrowser.Definition TROOT.cxx:1056; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2983; TROOT::GetGlobalFunctionsTListOfFunctions * GetGlobalFunctions()Internal routine returning, and creating if necessary, the list of global function.Definition TROOT.cxx:1663; TROOT::fInterruptBool_t fInterruptTrue if macro should be interrupted.Definition TROOT.h:134; TROOT::fMustCleanBool_t fMustCleanTrue if object destructor scans canvases.Definition TROOT.h:132; TROOT::LoadClassInt_t LoadClass(const char *classname, const char *libname, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:157165,load,load,157165,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['load'],['load']
Performance,"TROOT::GetGitDateconst char * GetGitDate()Return date/time make was run.Definition TROOT.cxx:2474; TROOT::GetUUIDsTProcessUUID * GetUUIDs() constDefinition TROOT.h:275; TROOT::SetEditorModevoid SetEditorMode(const char *mode="""")Set editor mode.Definition TROOT.cxx:2704; TROOT::GetListOfStreamerInfoTSeqCollection * GetListOfStreamerInfo() constDefinition TROOT.h:249; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3115; TROOT::~TROOTvirtual ~TROOT()Clean up and free resources used by ROOT (files, network sockets, shared memory segments,...Definition TROOT.cxx:867; TROOT::fColorsTSeqCollection * fColorsList of colors.Definition TROOT.h:153; TROOT::GetBuiltDateInt_t GetBuiltDate() constDefinition TROOT.h:221; TROOT::GetListOfFunctionsTCollection * GetListOfFunctions() constDefinition TROOT.h:242; TROOT::GetGlobalFunctionWithPrototypeTFunction * GetGlobalFunctionWithPrototype(const char *name, const char *proto=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1718; TROOT::GetForceStyleBool_t GetForceStyle() constDefinition TROOT.h:220; TROOT::GetRootFolderTFolder * GetRootFolder() constDefinition TROOT.h:274; TROOT::GetListOfBrowsersTSeqCollection * GetListOfBrowsers() constDefinition TROOT.h:245; TROOT::ReadingObjectBool_t ReadingObject() constDeprecated (will be removed in next release).Definition TROOT.cxx:2460; TROOT::fStylesTSeqCollection * fStylesList of styles.Definition TROOT.h:150; TROOT::GetListOfProofsTSeqCollection * GetListOfProofs() constDefinition TROOT.h:253; TROOT::GetEditHistogramsBool_t GetEditHistograms() constDefinition TROOT.h:218; TROOT::fVersionDateInt_t fVersionDateDate of ROOT version (ex 951226)Definition TROOT.h:116; TROOT::GetListOfColorsTSeqCollection * GetListOfColors() constDefinition TROOT.h:232; TROOT::MacroLongptr_t Macro(const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE)Exe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:40768,load,load,40768,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,1,['load'],['load']
Performance,"TROOT::GetGitDateconst char * GetGitDate()Return date/time make was run.Definition TROOT.cxx:2474; TROOT::GetUUIDsTProcessUUID * GetUUIDs() constDefinition TROOT.h:275; TROOT::SetEditorModevoid SetEditorMode(const char *mode="""")Set editor mode.Definition TROOT.cxx:2704; TROOT::GetListOfStreamerInfoTSeqCollection * GetListOfStreamerInfo() constDefinition TROOT.h:249; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3119; TROOT::~TROOTvirtual ~TROOT()Clean up and free resources used by ROOT (files, network sockets, shared memory segments,...Definition TROOT.cxx:867; TROOT::fColorsTSeqCollection * fColorsList of colors.Definition TROOT.h:153; TROOT::GetBuiltDateInt_t GetBuiltDate() constDefinition TROOT.h:221; TROOT::GetListOfFunctionsTCollection * GetListOfFunctions() constDefinition TROOT.h:242; TROOT::GetGlobalFunctionWithPrototypeTFunction * GetGlobalFunctionWithPrototype(const char *name, const char *proto=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1718; TROOT::GetForceStyleBool_t GetForceStyle() constDefinition TROOT.h:220; TROOT::GetRootFolderTFolder * GetRootFolder() constDefinition TROOT.h:274; TROOT::GetListOfBrowsersTSeqCollection * GetListOfBrowsers() constDefinition TROOT.h:245; TROOT::ReadingObjectBool_t ReadingObject() constDeprecated (will be removed in next release).Definition TROOT.cxx:2460; TROOT::fStylesTSeqCollection * fStylesList of styles.Definition TROOT.h:150; TROOT::GetListOfProofsTSeqCollection * GetListOfProofs() constDefinition TROOT.h:253; TROOT::GetEditHistogramsBool_t GetEditHistograms() constDefinition TROOT.h:218; TROOT::fVersionDateInt_t fVersionDateDate of ROOT version (ex 951226)Definition TROOT.h:116; TROOT::GetListOfColorsTSeqCollection * GetListOfColors() constDefinition TROOT.h:232; TROOT::MacroLongptr_t Macro(const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE)Exe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:40767,load,load,40767,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,1,['load'],['load']
Performance,"TROOT::GetGlobalFunctionWithPrototype(const char *function,; 1719 const char *proto, Bool_t load); 1720{; 1721 if (!proto) {; 1722 R__LOCKGUARD(gROOTMutex);; 1723 return (TFunction *)GetListOfGlobalFunctions(load)->FindObject(function);; 1724 } else {; 1725 if (!fInterpreter); 1726 Fatal(""GetGlobalFunctionWithPrototype"", ""fInterpreter not initialized"");; 1727 ; 1728 R__LOCKGUARD(gROOTMutex);; 1729 TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithPrototype(nullptr,; 1730 function, proto);; 1731 ; 1732 if (!decl) return nullptr;; 1733 ; 1734 TFunction *f = GetGlobalFunctions()->Get(decl);; 1735 if (f) return f;; 1736 ; 1737 Error(""GetGlobalFunctionWithPrototype"",; 1738 ""\nDid not find matching TFunction <%s> with \""%s\""."",; 1739 function,proto);; 1740 return nullptr;; 1741 }; 1742}; 1743 ; 1744////////////////////////////////////////////////////////////////////////////////; 1745/// Return pointer to Geometry with name; 1746 ; 1747TObject *TROOT::GetGeometry(const char *name) const; 1748{; 1749 return GetListOfGeometries()->FindObject(name);; 1750}; 1751 ; 1752////////////////////////////////////////////////////////////////////////////////; 1753 ; 1754TCollection *TROOT::GetListOfEnums(Bool_t load /* = kTRUE */); 1755{; 1756 if(!fEnums.load()) {; 1757 R__LOCKGUARD(gROOTMutex);; 1758 // Test again just in case, another thread did the work while we were; 1759 // waiting.; 1760 if (!fEnums.load()) fEnums = new TListOfEnumsWithLock(nullptr);; 1761 }; 1762 if (load) {; 1763 R__LOCKGUARD(gROOTMutex);; 1764 (*fEnums).Load(); // Refresh the list of enums.; 1765 }; 1766 return fEnums.load();; 1767}; 1768 ; 1769////////////////////////////////////////////////////////////////////////////////; 1770 ; 1771TCollection *TROOT::GetListOfFunctionTemplates(); 1772{; 1773 R__LOCKGUARD(gROOTMutex);; 1774 if(!fFuncTemplate) {; 1775 fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1776 }; 1777 return fFuncTemplate;; 1778}; 1779 ; 1780/////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:67446,load,load,67446,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['load']
Performance,"TROOTinline; GetCutClassName() constTROOTinline; GetDataDir()TROOTstatic; GetDefCanvasName() constTROOTinline; GetDirectory(const char *namecycle, Bool_t printError=false, const char *funcname=""GetDirectory"")TDirectoryvirtual; GetDirLevel()TROOTstatic; GetDocDir()TROOTstatic; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetEditHistograms() constTROOTinline; GetEditorMode() constTROOTinline; GetEtcDir()TROOTstatic; GetExtraInterpreterArgs()TROOTstatic; GetFile() const overrideTROOTinlinevirtual; GetFile(const char *name) constTROOT; GetForceStyle() constTROOTinline; GetFunction(const char *name) constTROOT; GetFunctionTemplate(const char *name)TROOT; GetGeometry(const char *name) constTROOT; GetGitBranch() constTROOTinline; GetGitCommit() constTROOTinline; GetGitDate()TROOT; GetGlobal(const char *name, Bool_t load=kFALSE) constTROOT; GetGlobal(const TObject *obj, Bool_t load=kFALSE) constTROOT; GetGlobalFunction(const char *name, const char *params=nullptr, Bool_t load=kFALSE)TROOT; GetGlobalFunctions()TROOTprotected; GetGlobalFunctionWithPrototype(const char *name, const char *proto=nullptr, Bool_t load=kFALSE)TROOT; GetIconName() constTObjectvirtual; GetIconPath()TROOTstatic; GetIncludeDir()TROOTstatic; GetInterpreter() constTROOTinline; GetKey(const char *, Short_t=9999) constTDirectoryinlinevirtual; GetLibDir()TROOTstatic; GetList() constTDirectoryinlinevirtual; GetListOfBrowsables() constTROOTinline; GetListOfBrowsers() constTROOTinline; GetListOfCanvases() constTROOTinline; GetListOfClasses() constTROOTinline; GetListOfClassGenerators() constTROOTinline; GetListOfCleanups() constTROOTinline; GetListOfClosedObjects() constTROOTinline; GetListOfColors() constTROOTinline; GetListOfDataSets() constTROOTinline; GetListOfEnums(Bool_t load=kFALSE)TROOT; GetListOfFiles() constTROOTinline; GetListOfFunctionOverloads(const char *name) constTROOT; GetListOfFunctions() constTROOTinline; GetListOfFunctionTemplates()TROOT; GetListOfGeometries() constTROOTi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT-members.html:7512,load,load,7512,doc/master/classTROOT-members.html,https://root.cern,https://root.cern/doc/master/classTROOT-members.html,1,['load'],['load']
Performance,"TRUE in case of failure.; 1821 ; 1822Bool_t TFile::ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf); 1823{; 1824 // called with buf=0, from TFileCacheRead to pass list of readahead buffers; 1825 if (!buf) {; 1826 for (Int_t j = 0; j < nbuf; j++) {; 1827 if (ReadBufferAsync(pos[j], len[j])) {; 1828 return kTRUE;; 1829 }; 1830 }; 1831 return kFALSE;; 1832 }; 1833 ; 1834 Int_t k = 0;; 1835 Bool_t result = kTRUE;; 1836 TFileCacheRead *old = fCacheRead;; 1837 fCacheRead = nullptr;; 1838 Long64_t curbegin = pos[0];; 1839 Long64_t cur;; 1840 char *buf2 = nullptr;; 1841 Int_t i = 0, n = 0;; 1842 while (i < nbuf) {; 1843 cur = pos[i]+len[i];; 1844 Bool_t bigRead = kTRUE;; 1845 if (cur -curbegin < fgReadaheadSize) {n++; i++; bigRead = kFALSE;}; 1846 if (bigRead || (i>=nbuf)) {; 1847 if (n == 0) {; 1848 //if the block to read is about the same size as the read-ahead buffer; 1849 //we read the block directly; 1850 Seek(pos[i]);; 1851 result = ReadBuffer(&buf[k], len[i]);; 1852 if (result) break;; 1853 k += len[i];; 1854 i++;; 1855 } else {; 1856 //otherwise we read all blocks that fit in the read-ahead buffer; 1857 Seek(curbegin);; 1858 if (!buf2) buf2 = new char[fgReadaheadSize];; 1859 //we read ahead; 1860 Long64_t nahead = pos[i-1]+len[i-1]-curbegin;; 1861 result = ReadBuffer(buf2, nahead);; 1862 if (result) break;; 1863 //now copy from the read-ahead buffer to the cache; 1864 Int_t kold = k;; 1865 for (Int_t j=0;j<n;j++) {; 1866 memcpy(&buf[k],&buf2[pos[i-n+j]-curbegin],len[i-n+j]);; 1867 k += len[i-n+j];; 1868 }; 1869 Int_t nok = k-kold;; 1870 Long64_t extra = nahead-nok;; 1871 fBytesReadExtra += extra;; 1872 fBytesRead -= extra;; 1873 fgBytesRead -= extra;; 1874 n = 0;; 1875 }; 1876 curbegin = i < nbuf ? pos[i] : 0;; 1877 }; 1878 }; 1879 if (buf2) delete [] buf2;; 1880 fCacheRead = old;; 1881 return result;; 1882}; 1883 ; 1884////////////////////////////////////////////////////////////////////////////////; 1885/// Read buffer via cache.; 1886///; 1887/// Retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:67174,cache,cache,67174,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,['cache'],['cache']
Performance,"TRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidsetExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidsetOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetProhibitServerRedirect(Bool_t flag); voidsetShapeDirty() const; voidsetStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidsetTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetValueDirty() const; TIterator*shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&transientAttributes() const; voidtreeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidunRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*valueClientIterator() const; static voidverboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:13472,cache,cache,13472,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,2,['cache'],['cache']
Performance,"TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7460; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::GetActualClassTClass * GetActualClass(const void *object) constReturn a pointer to the real class of the object.Definition TClass.cxx:2674; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::GetUInt_t Get() constReturn raw date/time as encoded by TDatime.Definition TDatime.cxx:240; TDatime::FillBuffervoid FillBuffer(char *&buffer)Encode Date/Time into buffer, used by I/O system.Definition TDatime.cxx:229; TDatime::SizeofInt_t Sizeof() constDefinition TDatime.h:81; TDatime::Streamervirtual void Streamer(TBuffer &)Stream a object of type TDatime.Definition TDatime.cxx:416; TDatime::Setvoid Set()Set Date/Time to current time as reported by the system.Definition TDatime.cxx:289; TDatime::ReadBuffervoid ReadBuffer(char *&buffer)Decode Date/Time from output buffer, used by I/O system.Definition TDatime.cxx:278; TDirectoryFileA ROOT file is structured in Directories (like a file s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:60858,load,load,60858,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,1,['load'],['load']
Performance,"TSelector::fAbortAbort status; Int_tfDimensionDimension of the current expression; TStringfInitialExp; TList*TSelector::fInputList of objects available during processing; TTreeFormulaManager*fManager; Int_tfMultiplicityIndicator of the variability of the size of entries; Bool_tfObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObject!Current object if processing object (vs. TTree); TStringTSelector::fOptionOption given to TTree::Process; TSelectorList*TSelector::fOutput!List of objects created during processing; TTreeFormula*fSelectPointer to selection formula; TStringfSelection; TStatus*fStatus; Long64_tTSelector::fStatusSelector status; TTree*fTree; TTreeDrawArgsParserfTreeDrawArgsParser; TTreeFormula*fVar[4]Pointer to variable formula; Double_tfWeightGlobal weight for fill actions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TProofDraw(); Destructor. void Init(TTree* ); Init the tree. Bool_t Notify(); Called when a new tree is loaded. void Begin(TTree* ); Executed by the client before processing. void SlaveBegin(TTree* ); Executed by each slave before processing. void FillWeight(); Get weight from input list, if any. Bool_t ProcessSingle(Long64_t , Int_t ); Processes a single variable from an entry. Bool_t Process(Long64_t ); Executed for each entry. void SlaveTerminate(void); Executed by each slave after the processing has finished,; before returning the results to the client. void Terminate(void); Executed by the client after getting the processing retults. void ClearFormula(); Delete internal buffers. void SetCanvas(const char* objname); Move to a canvas named <name>_canvas; create the canvas if not existing.; Used to avoid screwing up existing plots when non default names are used; for the final objects. void SetDrawAtt(TObject* o); Set the drawing attributes from the input list. void SetError(const char* sub, const char* mesg); Sets the error status. Bool_t CompileVariables(); Compiles",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofDraw.html:7673,load,loaded,7673,root/html534/TProofDraw.html,https://root.cern,https://root.cern/root/html534/TProofDraw.html,1,['load'],['loaded']
Performance,"TSeqCollection * GetListOfMappedFiles () const;  ; TSeqCollection * GetListOfMessageHandlers () const;  ; TSeqCollection * GetListOfProofs () const;  ; TSeqCollection * GetListOfSecContexts () const;  ; TSeqCollection * GetListOfSockets () const;  ; TSeqCollection * GetListOfSpecials () const;  ; TSeqCollection * GetListOfStreamerInfo () const;  ; TSeqCollection * GetListOfStyles () const;  ; TSeqCollection * GetListOfTasks () const;  ; TCollection * GetListOfTypes (Bool_t load=kFALSE);  Return a dynamic list giving access to all TDataTypes (typedefs) currently defined. ;  ; Int_t GetNclasses () const;  Get number of classes. ;  ; Int_t GetNtypes () const;  Get number of types. ;  ; TPluginManager * GetPluginManager () const;  ; TFolder * GetRootFolder () const;  ; TVirtualPad * GetSelectedPad () const;  ; const TObject * GetSelectedPrimitive () const;  ; TStyle * GetStyle (const char *name) const;  Return pointer to style with name. ;  ; TDataType * GetType (const char *name, Bool_t load=kFALSE) const;  Return pointer to type with name. ;  ; TProcessUUID * GetUUIDs () const;  ; const char * GetVersion () const;  ; Int_t GetVersionCode () const;  ; Int_t GetVersionDate () const;  ; Int_t GetVersionInt () const;  ; Int_t GetVersionTime () const;  ; const TString & GetWebDisplay () const;  ; void Idle (UInt_t idleTimeInSec, const char *command=nullptr);  Execute command when system has been idle for idleTimeInSec seconds. ;  ; Int_t IgnoreInclude (const char *fname, const char *expandedfname);  Return 1 if the name of the given include file corresponds to a class that is known to ROOT, e.g. ;  ; TClass * IsA () const override;  ; Bool_t IsBatch () const;  ; Bool_t IsEscaped () const;  ; Bool_t IsExecutingMacro () const;  ; Bool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; Bool_t IsInterrupted () const;  ; Bool_t IsLineProcessing () const;  ; Bool_t IsProofServ () const;  ; Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:8941,load,load,8941,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,2,['load'],['load']
Performance,"TString &);  ; const Event * GetTrainingEvent (Long64_t ievt) const;  ; virtual const std::vector< Float_t > & GetTrainingHistory (const char *);  ; UInt_t GetTrainingROOTVersionCode () const;  ; TString GetTrainingROOTVersionString () const;  calculates the ROOT version string from the training version code on the fly ;  ; UInt_t GetTrainingTMVAVersionCode () const;  ; TString GetTrainingTMVAVersionString () const;  calculates the TMVA version string from the training version code on the fly ;  ; Double_t GetTrainTime () const;  ; TransformationHandler & GetTransformationHandler (Bool_t takeReroutedIfAvailable=true);  ; const TransformationHandler & GetTransformationHandler (Bool_t takeReroutedIfAvailable=true) const;  ; TString GetWeightFileName () const;  retrieve weight file name ;  ; Double_t GetXmax (Int_t ivar) const;  ; Double_t GetXmin (Int_t ivar) const;  ; Bool_t HasMVAPdfs () const;  ; virtual void Init ()=0;  ; void InitIPythonInteractive ();  ; Bool_t IsModelPersistence () const;  ; virtual Bool_t IsSignalLike ();  uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation) for a quick determination if an event would be selected as signal or background ;  ; virtual Bool_t IsSignalLike (Double_t mvaVal);  uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation) for a quick determination if an event with this mva output value would be selected as signal or background ;  ; Bool_t IsSilentFile () const;  ; virtual void MakeClass (const TString &classFileName=TString("""")) const;  create reader class for method (classification only at present) ;  ; TDirectory * MethodBaseDir () const;  returns the ROOT directory where all instances of the corresponding MVA method are stored ;  ; virtual std::map< TString, Double_t > OptimizeTuningParameters (TString fomType=""ROCIntegral"", TString fitType=""FitGA"");  call the Optimizer with the set of parameters and ranges that are meant to be tuned.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodANNBase.html:10589,tune,tuned,10589,doc/master/classTMVA_1_1MethodANNBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodANNBase.html,2,['tune'],['tuned']
Performance,"TString::Format(""sourceClass=%s targetClass=%s"",GetName(),newname.Data()));; 4751 } else {; 4752 Error(""GetStreamerInfoAbstractEmulated"", ""could not create TVirtualStreamerInfo"");; 4753 }; 4754 }; 4755 }; 4756 return sinfo;; 4757}; 4758 ; 4759////////////////////////////////////////////////////////////////////////////////; 4760/// For the case where the requestor class is emulated and this class is abstract,; 4761/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4762/// representation whether or not the class is loaded.; 4763///; 4764/// If the object does not exist, it is created; 4765///; 4766/// Warning: If we create a new streamer info, whether or not the build; 4767/// optimizes is controlled externally to us by a global variable!; 4768/// Don't call us unless you have set that variable properly; 4769/// with TStreamer::Optimize()!; 4770///; 4771 ; 4772TVirtualStreamerInfo* TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; 4773{; 4774 TVirtualStreamerInfo *sinfo = nullptr;; 4775 ; 4776 TString newname(GetName());; 4777 newname += ""@@emulated"";; 4778 ; 4779 R__LOCKGUARD(gInterpreterMutex);; 4780 ; 4781 TClass *emulated = TClass::GetClass(newname);; 4782 ; 4783 if (emulated); 4784 sinfo = emulated->FindStreamerInfo(checksum);; 4785 ; 4786 if (!sinfo) {; 4787 // The emulated version of the streamerInfo is explicitly requested and has; 4788 // not been built yet.; 4789 ; 4790 sinfo = (TVirtualStreamerInfo*) FindStreamerInfo(checksum);; 4791 ; 4792 if (!sinfo && (checksum != fCheckSum)) {; 4793 // When the requested version does not exist we return; 4794 // the TVirtualStreamerInfo for the currently loaded class version.; 4795 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4796 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4797 }; 4798 ; 4799 if (!sinfo) {; 4800 // Let's take the first available StreamerInfo as a start; 4801 Int_t ninfos = fStreamerInfo->Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:181111,optimiz,optimizes,181111,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['optimiz'],['optimizes']
Performance,"TString::Format(""sourceClass=%s targetClass=%s"",GetName(),newname.Data()));; 4818 } else {; 4819 Error(""GetStreamerInfoAbstractEmulated"", ""could not create TVirtualStreamerInfo"");; 4820 }; 4821 }; 4822 }; 4823 return sinfo;; 4824}; 4825 ; 4826////////////////////////////////////////////////////////////////////////////////; 4827/// For the case where the requestor class is emulated and this class is abstract,; 4828/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4829/// representation whether or not the class is loaded.; 4830///; 4831/// If the object does not exist, it is created; 4832///; 4833/// Warning: If we create a new streamer info, whether or not the build; 4834/// optimizes is controlled externally to us by a global variable!; 4835/// Don't call us unless you have set that variable properly; 4836/// with TStreamer::Optimize()!; 4837///; 4838 ; 4839TVirtualStreamerInfo* TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; 4840{; 4841 TVirtualStreamerInfo *sinfo = nullptr;; 4842 ; 4843 TString newname(GetName());; 4844 newname += ""@@emulated"";; 4845 ; 4846 R__LOCKGUARD(gInterpreterMutex);; 4847 ; 4848 TClass *emulated = TClass::GetClass(newname);; 4849 ; 4850 if (emulated); 4851 sinfo = emulated->FindStreamerInfo(checksum);; 4852 ; 4853 if (!sinfo) {; 4854 // The emulated version of the streamerInfo is explicitly requested and has; 4855 // not been built yet.; 4856 ; 4857 sinfo = (TVirtualStreamerInfo*) FindStreamerInfo(checksum);; 4858 ; 4859 if (!sinfo && (checksum != fCheckSum)) {; 4860 // When the requested version does not exist we return; 4861 // the TVirtualStreamerInfo for the currently loaded class version.; 4862 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4863 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4864 }; 4865 ; 4866 if (!sinfo) {; 4867 // Let's take the first available StreamerInfo as a start; 4868 Int_t ninfos = fStreamerInfo->Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:183862,optimiz,optimizes,183862,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['optimiz'],['optimizes']
Performance,"TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxysigma; RooRealProxywidth; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooVoigtian.html:43019,cache,cache,43019,root/html534/RooVoigtian.html,https://root.cern,https://root.cern/root/html534/RooVoigtian.html,1,['cache'],['cache']
Performance,"TStringfPictureFileName! default file-name for SavePicture(); Float_tfPointScale! size scale for points; TGLViewer::EPushActionfPushAction; TGLRedrawTimer*fRedrawTimer! timer for triggering redraws; Bool_tfReferenceOn! reference marker on?; TGLVertex3fReferencePos! reference position; Bool_tfResetCamerasOnNextUpdatereposition camera on next update; Bool_tfResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; TGLViewerBase::SceneInfoList_tTGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordfSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordfSelRec! select record from last select (should go to context); TGLManipSet*fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfSmartRefresh! cache logicals during scene rebuilds; Bool_tfSmoothLines! smooth line edge rendering; Bool_tfSmoothPoints! smooth point edge rendering; Bool_tfStereo! use stereo rendering; Float_tfStereoEyeOffsetFac!; Float_tfStereoFrustumAsymFac!; Bool_tfStereoQuadBuf! draw quad buffer or left/right stereo in left/right half of window; Float_tfStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectfViewport! viewport - drawn area; TGLViewerBase::SceneInfoVec_tTGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetfgDefaultColorSet! a shared, default color-set; static Bool_tfgUseDefaultColorSetForNewViewers! name says it all. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLViewer(TVirtualPad* pad, Int_t x, Int_t y, Int_t width, Int_t height); Construct the viewer object, wit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLViewer.html:23456,cache,cache,23456,root/html604/TGLViewer.html,https://root.cern,https://root.cern/root/html604/TGLViewer.html,1,['cache'],['cache']
Performance,"TSystem.cxx. ◆ SetFPEMask(). Int_t TSystem::SetFPEMask ; (; Int_t ; mask = kDefaultMask). virtual . Set which conditions trigger a floating point exception. ; Return the previous set of conditions. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 642 of file TSystem.cxx. ◆ SetIncludePath(). void TSystem::SetIncludePath ; (; const char * ; includePath). virtual . IncludePath should contain the list of compiler flags to indicate where to find user defined header files. ; It is used to expand $IncludePath in the directives given to SetMakeSharedLib() and SetMakeExe(), e.g.: gSystem->SetInclude(""-I$ROOTSYS/include -Imydirectory/include"");; the default value of IncludePath on Unix is: ""-I$ROOTSYS/include ""; and on Windows: ""/I%ROOTSYS%/include "". Definition at line 4194 of file TSystem.cxx. ◆ SetLinkdefSuffix(). void TSystem::SetLinkdefSuffix ; (; const char * ; suffix). virtual . The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual additional linkdef information that ACLiC should used to produce the dictionary. ; So by default, when doing .L MyScript.cxx, ACLiC will look for a file name MyScript_linkdef and having one of the .h (.hpp, etc.) extensions. If such a file exist, it will be added to the end of the linkdef file used to created the ACLiC dictionary. This effectively enable the full customization of the creation of the dictionary. It should be noted that the file is intended as a linkdef fragment, so usually you would not list the typical: #pragma link off .... Definition at line 4227 of file TSystem.cxx. ◆ SetLinkedLibs(). void TSystem::SetLinkedLibs ; (; const char * ; linkedLibs). virtual . LinkedLibs should contain the library directory and list of libraries needed to recreate the current executable. ; It is used to expand $LinkedLibs in the directives given to SetMakeSharedLib() and SetMakeExe() The default value on Unix is: root-config --glibs ; Definition at line 4205 of file TSystem.cxx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:86437,load,loaded,86437,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['load'],['loaded']
Performance,"TSystem::SetIncludePath(). A good default will be provided so that a typical user session should be at most: root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::SetIncludePathvirtual void SetIncludePath(const char *includePath)IncludePath should contain the list of compiler flags to indicate where to find user defined header f...Definition TSystem.cxx:4194; The user may sometimes try to compile a script before it has loaded all the needed shared libraries. In this case we want to be helpful and output a list of the unresolved symbols. So if the loading of the created shared library fails, we will try to build a executable that contains the script. The linker should then output a list of missing symbols.; To support this we provide a TSystem::SetMakeExe() function, that sets the directive telling how to create an executable. The loader will need to be informed of all the libraries available. The information about the libraries that has been loaded by .L and TSystem::Load() is accessible to the script compiler. However, the information about the libraries that have been selected at link time by the application builder (like the root libraries for root.exe) are not available and need to be explicitly listed in fLinkedLibs (either by default or by a call to TSystem::SetLinkedLibs()).; To simplify customization we could also add to the .rootrc support for the variables Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; ; Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; I#define I(x, y, z); And also support for MakeSharedLibs() and MakeExe().; (the ... have to be replaced by the actual values and are here only to shorten this comment).; Note that the default behavior is to remove libraries when closing ROOT, ie TSystem::CleanCompiledMacros",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:45282,load,loader,45282,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['load'],['loader']
Performance,"TTree represents a columnar dataset.Definition TTree.h:79; double; RooFit::IndexRooCmdArg Index(RooCategory &icat)Definition RooGlobalFunc.cxx:386; RooFit::ImportRooCmdArg Import(const char *state, TH1 &histo)Definition RooGlobalFunc.cxx:390; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; TMVA_SOFIE_GNN_Parser.treetreeDefinition TMVA_SOFIE_GNN_Parser.py:169; rf401_importttreethxDefinition rf401_importttreethx.py:1; ; RooDataHist::dh[c,x] = 300 bins (2964 weights); RooDataHist::dh[c,x] = 300 bins (2964 weights); [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 35 out-of-range events; RooDataSet::ds[x,y] = 65 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #14 because y cannot acc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8C.html:7119,load,loadValues,7119,doc/master/rf401__importttreethx_8C.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8C.html,1,['load'],['loadValues']
Performance,"TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFrien",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:35791,cache,cache,35791,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['cache'],['cache']
Performance,"TTree.h:125; TTree::GetAutoSavevirtual Long64_t GetAutoSave() constDefinition TTree.h:448; TTree::StopCacheLearningPhasevirtual Int_t StopCacheLearningPhase()Stop the cache learning phase.Definition TTree.cxx:9474; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::fSortedBranchesstd::vector< std::pair< Long64_t, TBranch * > > fSortedBranches! Branches to be processed in parallel when IMT is on, sorted by average task timeDefinition TTree.h:144; TTree::SetCircularvirtual void SetCircular(Long64_t maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTree::GetEstimatevirtual Long64_t GetEstimate() constDefinition TTree.h:507; TTree::GetDebugMaxLong64_t GetDebugMax() constDefinition TTree.h:460; TTree::fSavedBytesLong64_t fSavedBytesNumber of autosaved bytes.Definition TTree.h:88; TTree::AddBranchToCachevirtual Int_t AddBranchToCache(const char *bname, bool subbranches=false)Add branch with name bname to the Tree cache.Definition TTree.cxx:1059; TTree::GetMedianClusterSizeLong64_t GetMedianClusterSize()Estimate the median cluster size for the TTree.Definition TTree.cxx:8297; TTree::GetClusterIteratorvirtual TClusterIterator GetClusterIterator(Long64_t firstentry)Return an iterator over the cluster of baskets starting at firstentry.Definition TTree.cxx:5467; TTree::ResetBranchAddressvirtual void ResetBranchAddress(TBranch *)Tell all of our branches to set their addresses to zero.Definition TTree.cxx:8065; TTree::fCacheUserSetbool fCacheUserSet! true if the cache setting was explicitly given by userDefinition TTree.h:141; TTree::GetNewlineValuechar GetNewlineValue(std::istream &inputStream)Determine which newline this file is using.Definition TTree.cxx:7588; TTree::BranchTBranch * Branch(const char *name, T **addobj, Int_t bufsize=32000, Int_t splitlevel=99)Add a new branch, and infer the data type from the array addobj being pass",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:56980,cache,cache,56980,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['cache'],['cache']
Performance,"TTree::SetAlias(const char* aliasName, const char* aliasFormula); virtual voidTTree::SetAutoFlush(Long64_t autof = -30000000); virtual voidTTree::SetAutoSave(Long64_t autos = -300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual Int_tTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual Int_tTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tSetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidSetHbookFile(THb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THbookTree.html:16770,cache,cachesize,16770,root/html604/THbookTree.html,https://root.cern,https://root.cern/root/html604/THbookTree.html,1,['cache'],['cachesize']
Performance,"TTree::SetAlias(const char* aliasName, const char* aliasFormula); virtual voidTTree::SetAutoFlush(Long64_t autof = -30000000); virtual voidTTree::SetAutoSave(Long64_t autos = -300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual Int_tTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual Int_tTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TNtuple.html:16242,cache,cachesize,16242,root/html604/TNtuple.html,https://root.cern,https://root.cern/root/html604/TNtuple.html,3,['cache'],['cachesize']
Performance,"TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:3842,cache,cache,3842,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"TTreeCache.h. ◆ Disable(). virtual void TTreeCache::Disable ; (; ). inlinevirtual . Definition at line 136 of file TTreeCache.h. ◆ DropBranch() [1/2]. Int_t TTreeCache::DropBranch ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 586 of file TTreeCache.cxx. ◆ DropBranch() [2/2]. Int_t TTreeCache::DropBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 541 of file TTreeCache.cxx. ◆ Enable(). virtual void TTreeCache::Enable ; (; ). inlinevirtual . Definition at line 137 of file TTreeCache.h. ◆ FillBuffer(). bool TTreeCache::FillBuffer ; (; ). virtual . Fill the cache buffer with the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 1114 of file TTreeCache.cxx. ◆ FillMissCache(). bool TTreeCache::FillMissCache ; (; ). private . Fill the miss cache from the current set of active branches. . ◆ FindBranchBasketPos(). TTreeCache::IOPos TTreeCache::FindBranchBasketPos ; (; TBranch & ; b, . Long64_t ; entry . ). private . Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ; For the event currently being fetched into the miss cache, find the IO (offset / length tuple) to pull in the current basket for a given branch.; Returns:; IO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:38819,cache,cache,38819,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,TTreeCacheUnzip::fCycle. protected . Definition at line 83 of file TTreeCacheUnzip.h. ◆ fEmpty. bool TTreeCacheUnzip::fEmpty. protected . Definition at line 82 of file TTreeCacheUnzip.h. ◆ fgParallel. TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::fgParallel = TTreeCacheUnzip::kDisable. staticprotected . Indicate if we want to activate the parallelism. ; Definition at line 88 of file TTreeCacheUnzip.h. ◆ fgRelBuffSize. Double_t TTreeCacheUnzip::fgRelBuffSize = .5. staticprotected . This is the percentage of the TTreeCacheUnzip that will be used. ; Definition at line 100 of file TTreeCacheUnzip.h. ◆ fIOMutex. std::unique_ptr<TMutex> TTreeCacheUnzip::fIOMutex. protected . Definition at line 86 of file TTreeCacheUnzip.h. ◆ fNFound. Int_t TTreeCacheUnzip::fNFound. protected . ! number of blocks that were found in the cache ; Definition at line 103 of file TTreeCacheUnzip.h. ◆ fNMissed. Int_t TTreeCacheUnzip::fNMissed. protected . ! number of blocks that were not found in the cache and were unzipped ; Definition at line 104 of file TTreeCacheUnzip.h. ◆ fNseekMax. Int_t TTreeCacheUnzip::fNseekMax. protected . ! fNseek can change so we need to know its max size ; Definition at line 96 of file TTreeCacheUnzip.h. ◆ fNStalls. Int_t TTreeCacheUnzip::fNStalls. protected . ! number of hits which caused a stall ; Definition at line 105 of file TTreeCacheUnzip.h. ◆ fNUnzip. Int_t TTreeCacheUnzip::fNUnzip. protected . ! number of blocks that were unzipped ; Definition at line 106 of file TTreeCacheUnzip.h. ◆ fParallel. bool TTreeCacheUnzip::fParallel. protected . Indicate if we want to activate the parallelism (for this instance) ; Definition at line 84 of file TTreeCacheUnzip.h. ◆ fUnzipBufferSize. Long64_t TTreeCacheUnzip::fUnzipBufferSize. protected . ! Max Size for the ready unzipped blocks (default is 2*fBufferSize) ; Definition at line 98 of file TTreeCacheUnzip.h. ◆ fUnzipGroupSize. Int_t TTreeCacheUnzip::fUnzipGroupSize. protected . ! Min accumulated size of a group of bas,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:40106,cache,cache,40106,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,2,['cache'],['cache']
Performance,"TTreeFormulaManager* TTreeFormula::fManager. protected . ! The dimension coordinator. ; Definition at line 124 of file TTreeFormula.h. ◆ fMethods. TObjArray TTreeFormula::fMethods. protected . ! List of leaf method calls ; Definition at line 105 of file TTreeFormula.h. ◆ fMultiplicity. Int_t TTreeFormula::fMultiplicity. protected . Indicator of the variability of the formula. ; Definition at line 100 of file TTreeFormula.h. ◆ fNcodes. Int_t TTreeFormula::fNcodes. protected . Number of leaves referenced in formula. ; Definition at line 98 of file TTreeFormula.h. ◆ fNdata. Int_t TTreeFormula::fNdata[kMAXCODES]. protected . ! This caches the physical number of element in the leaf or data member. ; Definition at line 97 of file TTreeFormula.h. ◆ fNdimensions. Int_t TTreeFormula::fNdimensions[kMAXCODES]. protected . Number of array dimensions in each leaf. ; Definition at line 113 of file TTreeFormula.h. ◆ fNeedLoading. bool TTreeFormula::fNeedLoading. protected . ! If true, the current entry has not been loaded yet. ; Definition at line 111 of file TTreeFormula.h. ◆ fNindex. Int_t TTreeFormula::fNindex. protected . Size of fIndex. ; Definition at line 101 of file TTreeFormula.h. ◆ fQuickLoad. bool TTreeFormula::fQuickLoad. protected . ! If true, branch GetEntry is only called when the entry number changes. ; Definition at line 110 of file TTreeFormula.h. ◆ fRealInstanceCache. RealInstanceCache TTreeFormula::fRealInstanceCache. protected . ! Cache accelerating the GetRealInstance function ; Definition at line 132 of file TTreeFormula.h. ◆ fTree. TTree* TTreeFormula::fTree. protected . ! Pointer to Tree ; Definition at line 95 of file TTreeFormula.h. ◆ fVarIndexes. TTreeFormula* TTreeFormula::fVarIndexes[kMAXCODES][kMAXFORMDIM]. protected . Pointer to a variable index. ; Definition at line 120 of file TTreeFormula.h. Libraries for TTreeFormula:. [legend]; The documentation for this class was generated from the following files:; tree/treeplayer/inc/TTreeFormula.h; tree/tre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormula.html:55256,load,loaded,55256,doc/master/classTTreeFormula.html,https://root.cern,https://root.cern/doc/master/classTTreeFormula.html,1,['load'],['loaded']
Performance,"TVectorD r1(3,data); //create a new Linear Algebra vector; //copying the data; In the case of transformations, constructor and method to set/get components exist with linear algebra matrices. The requisite is that the matrix data are stored, for example in the case of a Lorentz rotation, from (0,0) thru (3,3); TMatrixD(4,4) m;; LorentzRotation r(m); //create Lorentz r; 13.12.6.2 Connection to Other Vector Classes; The 3D and 4D vectors of the GenVector package can be constructed and assigned from any vector which satisfies the following requisites:. for 3D vectors implementing the x(), y() and z() methods; for Lorentz vectors implementing the x(), y(), z() and t() methods. CLHEP::Hep3Vector hv;; XYZVector v1(hv); //create 3D vector from; //CLHEP 3D Vector; HepGeom::Point3D hp;; XYZPoint p1(hp); //create a 3D p; 13.13 Linear Algebra: SMatrix Package; The ROOT Linear algebra package is documented in a separate chapter (see “Linear Algebra in ROOT”). SMatrix is a C++ package, for high performance vector and matrix computations. It has been introduced in ROOT v5.08. It is optimized for describing small matrices and vectors and It can be used only in problems when the size of the matrices is known at compile time, like in the tracking reconstruction of physics experiments. It is based on a C++ technique, called expression templates, to achieve an high level optimization. The C++ templates can be used to implement vector and matrix expressions such that these expressions can be transformed at compile time to code which is equivalent to hand optimized code in a low-level language like FORTRAN or C (see for example T. Veldhuizen, Expression Templates, C++ Report, 1995).; The SMatrix has been developed initially by T. Glebe in Max-Planck-Institut, Heidelberg, as part of the HeraB analysis framework. A subset of the original package has been now incorporated in the ROOT distribution, with the aim to provide a stand-alone and high performance matrix package. The API of the curr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:747862,perform,performance,747862,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performance']
Performance,"TVectorD*_frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; TVectorD*_mref; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Roo1DMomentMorphFunction::Setting_setting; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; TIterator*_varItr! do not persist; RooSetProxy_varList; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo1DMomentMorphFunction.html:33356,cache,cache,33356,root/html532/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html532/Roo1DMomentMorphFunction.html,1,['cache'],['cache']
Performance,"TVirtualStreamerInfo* sinfo = subBranch->GetInfoImp();; 3269 if (!sinfo) {; 3270 Warning(""InitializeOffsets"", ""No streamer info for branch: %s subbranch: %s"", GetName(), subBranch->GetName());; 3271 fBranchOffset[subBranchIdx] = TStreamerInfo::kMissing;; 3272 continue;; 3273 }; 3274 if (!sinfo->IsCompiled()) {; 3275 Warning(""InitializeOffsets"", ""No elements array for branch: %s subbranch: %s"", GetName(), subBranch->GetName());; 3276 fBranchOffset[subBranchIdx] = TStreamerInfo::kMissing;; 3277 continue;; 3278 }; 3279 // FIXME: Make sure subBranch->fID is in range.; 3280 TStreamerElement* subBranchElement = sinfo->GetElement(subBranch->fID);; 3281 if (!subBranchElement) {; 3282 Warning(""InitializeOffsets"", ""No streamer element for branch: %s subbranch: %s"", GetName(), subBranch->GetName());; 3283 fBranchOffset[subBranchIdx] = TStreamerInfo::kMissing;; 3284 continue;; 3285 } else if (subBranchElement->TestBit(TStreamerElement::kRepeat)) {; 3286 // If we have a repeating streamerElement, use the next; 3287 // one as it actually hold the 'real' data member('s offset); 3288 if (sinfo->GetElement(subBranch->fID+1)) {; 3289 subBranchElement = sinfo->GetElement(subBranch->fID+1);; 3290 }; 3291 } else if (subBranchElement->TestBit(TStreamerElement::kCache)) {; 3292 // We have a cached item which is not a repeated but we might still; 3293 // have some Actions triggered by a rule that affect real; 3294 // data member(s).; 3295 if (subBranch->fReadActionSequence && subBranch->fReadActionSequence->fActions.size() > 1) {; 3296 typedef TStreamerInfoActions::ActionContainer_t::iterator iterator;; 3297 iterator end = subBranch->fReadActionSequence->fActions.end();; 3298 for(iterator iter = subBranch->fReadActionSequence->fActions.begin();; 3299 iter != end; ++iter) {; 3300 TStreamerInfoActions::TConfiguration *config = iter->fConfiguration;; 3301 UInt_t id = config->fElemId;; 3302 TStreamerElement *e = (TStreamerElement*)config->fInfo->GetElements()->At(id);; 3303 if (e && !e->TestBit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:118283,cache,cached,118283,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['cache'],['cached']
Performance,"TVirtualX.cxx. ◆ Instance(). TVirtualX *& TVirtualX::Instance ; (; ). static . Returns gVirtualX global. ; Definition at line 57 of file TVirtualX.cxx. ◆ InternAtom(). Atom_t TVirtualX::InternAtom ; (; const char * ; atom_name, . Bool_t ; only_if_exist . ). virtual . Returns the atom identifier associated with the specified ""atom_name"" string. ; If ""only_if_exists"" is False, the atom is created if it does not exist. If the atom name is not in the Host Portable Character Encoding, the result is implementation dependent. Uppercase and lowercase matter; the strings ""thing"", ""Thing"", and ""thinG"" all designate different atoms. ; Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 1280 of file TVirtualX.cxx. ◆ IntersectRegion(). void TVirtualX::IntersectRegion ; (; Region_t ; rega, . Region_t ; regb, . Region_t ; result . ). virtual . Computes the intersection of two regions. ; Parameters. [in]rega,regbspecify the two regions with which you want to perform the computation ; [in]resultreturns the result of the computation . Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 2189 of file TVirtualX.cxx. ◆ IsA(). TClass * TVirtualX::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 334 of file TVirtualX.h. ◆ IsCmdThread(). virtual Bool_t TVirtualX::IsCmdThread ; (; ); const. inlinevirtual . Reimplemented in TGCocoa, TGWin32, and TGWin32VirtualXProxy.; Definition at line 328 of file TVirtualX.h. ◆ IsDNDAware(). Bool_t TVirtualX::IsDNDAware ; (; Window_t ; win, . Atom_t * ; typelist . ). virtual . Checks if the Window is DND aware, and knows any of the DND formats passed in argument. ; Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 2480 of file TVirtualX.cxx. ◆ KeysymToKeycode(). Int_t TVirtualX::KeysymToKeycode ; (; UInt_t ; keysym). virtual . Converts the ""keysym"" to the appropriate ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:97900,perform,perform,97900,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['perform'],['perform']
Performance,"T_TTREECACHE_SIZE.; The resource variable TTreeCache.Prefill sets the default TTreeCache prefilling type. The prefill type may be: 0 for no prefilling and 1 to prefill all the branches. It can be overridden by the environment variable ROOT_TTREECACHE_PREFILL; In particular the default can be set back to the same as in version 5 by setting TTreeCache.Size (or ROOT_TTREECACHE_SIZE) and TTreeCache.Prefill (or ROOT_TTREECACHE_PREFILL) both to zero.; TTree methods which are expected to modify a cache, like AddBranchToCache, will attempt to setup a cache of default size if one does not exist, irrespective of whether the auto cache creation is enabled. Additionally several methods giving control of the cache have changed return type from void to Int_t, to be able to return a code to indicate if there was an error.; Usually TTree::SetCacheSize will no longer reset the list of branches to be cached (either set or previously learnt) nor restart the learning phase. The learning phase is restarted when a new cache is created, e.g. after having removed a cache with SetCacheSize(0).; TSelectorDraw; The axis titles in case of a x:y:z plot with the option COLZ were not correct.; TParallelCoordVar; Change the format used to print the variables limit for ||-Coord to %g. It was %6.4f before.; Histogram Libraries; TFormula. New version of the TFormula class based on Cling. Formula expressions are now used to create functions which are passed to Cling to be Just In Time compiled. The expression is therefore compiled using Clang/LLVVM which will give execution time as compiled code and in addition correctness of the result obtained.; This class is not 100% backward compatible with the old TFormula class, which is still available in ROOT as =ROOT::v5::TFormula=. Some of the TFormula member funtions available in version 5, such as =Analyze= and =AnalyzeFunction= are not available in the new TFormula class. On the other hand formula expressions which were valid in version 5 are still valid ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:14093,cache,cache,14093,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['cache'],['cache']
Performance,"TensorBatch();; 1930 auto inputTensor = batch.GetInput();; 1931 ; 1932 auto xInput = batch.GetInput();; 1933 // make the prediction; 1934 deepNet.Prediction(yHat, xInput, fOutputFunction);; 1935 for (size_t i = 0; i < batchSize; ++i) {; 1936 double value = yHat(i,0);; 1937 mvaValues[ievt + i] = (TMath::IsNaN(value)) ? -999. : value;; 1938 }; 1939 }; 1940 else {; 1941 // case of remaining events: compute prediction by single event !; 1942 for (Long64_t i = ievt; i < lastEvt; ++i) {; 1943 Data()->SetCurrentEvent(i);; 1944 mvaValues[i] = GetMvaValue();; 1945 }; 1946 }; 1947 }; 1948 ; 1949 if (logProgress) {; 1950 Log() << kINFO; 1951 << ""Elapsed time for evaluation of "" << nEvents << "" events: ""; 1952 << timer.GetElapsedTime() << "" "" << Endl;; 1953 }; 1954 ; 1955 return mvaValues;; 1956}; 1957 ; 1958//////////////////////////////////////////////////////////////////////////; 1959/// Get the regression output values for a single event; 1960//////////////////////////////////////////////////////////////////////////; 1961const std::vector<Float_t> & TMVA::MethodDL::GetRegressionValues(); 1962{; 1963 ; 1964 FillInputTensor ();; 1965 ; 1966 // perform the network prediction; 1967 fNet->Prediction(*fYHat, fXInput, fOutputFunction);; 1968 ; 1969 size_t nTargets = DataInfo().GetNTargets();; 1970 R__ASSERT(nTargets == fYHat->GetNcols());; 1971 ; 1972 std::vector<Float_t> output(nTargets);; 1973 for (size_t i = 0; i < nTargets; i++); 1974 output[i] = (*fYHat)(0, i);; 1975 ; 1976 // ned to transform back output values; 1977 if (fRegressionReturnVal == NULL); 1978 fRegressionReturnVal = new std::vector<Float_t>(nTargets);; 1979 R__ASSERT(fRegressionReturnVal->size() == nTargets);; 1980 ; 1981 // N.B. one should cache here temporary event class; 1982 Event *evT = new Event(*GetEvent());; 1983 for (size_t i = 0; i < nTargets; ++i) {; 1984 evT->SetTarget(i, output[i]);; 1985 }; 1986 const Event *evT2 = GetTransformationHandler().InverseTransform(evT);; 1987 for (size_t i = 0; i < nTarg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:78164,perform,perform,78164,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['perform'],['perform']
Performance,"TermInput ();  ; virtual void Hide ();  ; virtual void Iconify ();  ; virtual void Init ();  ; void InitializeGraphics (Bool_t only_web=kFALSE);  Initialize the graphics environment. ;  ; TObjArray * InputFiles () const;  ; TClass * IsA () const override;  ; virtual Bool_t IsCmdThread ();  ; Bool_t IsRunning () const;  ; virtual void KeyPressed (Int_t key);  Emit signal when console keyboard key was pressed. ;  ; virtual void LineProcessed (const char *line);  Emit signal when a line has been processed. ;  ; virtual void Lower ();  ; void ls (Option_t *option="""") const override;  Show available sessions. ;  ; Bool_t NoLogoOpt () const;  ; Bool_t NoLogOpt () const;  ; virtual void Open ();  ; void OpenForumTopic (const TString &type);  It opens a Forum topic in a web browser with prefilled ROOT version. ;  ; void OpenGitHubIssue (const TString &type);  It opens a GitHub issue in a web browser with prefilled ROOT version. ;  ; void OpenInBrowser (const TString &url);  The function generates and executes a command that loads the Doxygen URL in a browser. ;  ; void OpenReferenceGuideFor (const TString &strippedClass);  It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator. ;  ; virtual Longptr_t ProcessFile (const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE);  Process a file containing a C++ macro. ;  ; virtual Longptr_t ProcessLine (const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr);  Process a single command line, either a C++ statement or an interpreter command starting with a ""."". ;  ; Bool_t QuitOpt () const;  ; virtual void Raise ();  ; virtual void RemoveIdleTimer ();  Remove idle timer. Normally called via TROOT::Idle(0). ;  ; Bool_t ReturnFromRun () const;  ; virtual void ReturnPressed (char *text);  Emit signal when return key was pressed. ;  ; virtual void Run (Bool_t retrn=kFALSE);  Main application eventloop. Calls system dep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplication.html:3934,load,loads,3934,doc/master/classTApplication.html,https://root.cern,https://root.cern/doc/master/classTApplication.html,1,['load'],['loads']
Performance,"TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Int_tDeleteParameters(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidFillPerfStatPerfPlots(TTree* t, Int_t nactive); voidTObject::MakeZombie(); Int_tSetParameters(). private:. voidBuildHistos(Int_t start, Int_t stop, Int_t step, Bool_t nx). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTProofBenchRun::fParListList of PARs to be loaded; TProof*TProofBenchRun::fProofProof; TStringTProofBenchRun::fSelNameName of the selector to be run. private:. TCanvas*fCanvascanvas for performance plots; Int_tfDebugdebug switch; TDirectory*fDirProofBenchdirectory for proof outputs; Int_tfDrawdraw switch; TPBHistType*fHistTypehistogram type; TH2*fHist_perfstat_event; TList*fListPerfPlotslist of performance plots; Long64_tfNEventsnumber of events to generate; Int_tfNHistsnumber of histograms; Int_tfNTriesnumber of tries ; TStringfNamename of CPU run; TProofNodes*fNodesnode information; TLegend*fNormLegendLegend for norms; TProfile*fNorm_perfstat_evtmax; TProfile*fNorm_queryresult_event; TLegend*fProfLegendLegend for profiles; TProfile*fProfile_cpu_eff; TProfile*fProfile_perfstat_event; TProfile*fProfile_perfstat_evtmax; TProfile*fProfile_queryresult_event; Int_tfStartstart number of workers to scan; Int_tfSteptest to be performed every fStep workers; Int_tfStopstop number of workers to scan. Class Charts. Inheritance; Inherited Members; Includes; Libraries",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofBenchRunCPU.html:6811,load,loaded,6811,root/html534/TProofBenchRunCPU.html,https://root.cern,https://root.cern/root/html534/TProofBenchRunCPU.html,1,['load'],['loaded']
Performance,"TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Int_tDeleteParameters(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidFillPerfStatPerfPlots(TTree* t, Int_t nactive); voidTObject::MakeZombie(); Int_tSetParameters(). private:. voidBuildHistos(Int_t start, Int_t stop, Int_t step, Bool_t nx). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTProofBenchRun::fParListList of PARs to be loaded; TProof*TProofBenchRun::fProofProof; TStringTProofBenchRun::fSelNameName of the selector to be run. private:. TCanvas*fCanvascanvas for performance plots; Int_tfDebugdebug switch; TDirectory*fDirProofBenchdirectory for proof outputs; Int_tfDrawdraw switch; TPBHistType*fHistTypehistogram type; TH2*fHist_perfstat_event; TList*fListPerfPlotslist of performance plots; Long64_tfNEventsnumber of events to generate; Int_tfNHistsnumber of histograms; Int_tfNTriesnumber of tries ; TStringfNamename of CPU run; TProofNodes*fNodesnode information; TProfile*fNorm_queryresult_event; TProfile*fProfile_perfstat_event; TProfile*fProfile_queryresult_event; Int_tfStartstart number of workers to scan; Int_tfSteptest to be performed every fStep workers; Int_tfStopstop number of workers to scan. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBenchRunCPU(TPBHistType* histtype = 0, Int_t nhists = 16, TDirectory* dirproofbench = 0, TProof* proof = 0, TProofNodes* nodes = 0, Long64_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofBenchRunCPU.html:6792,load,loaded,6792,root/html530/TProofBenchRunCPU.html,https://root.cern,https://root.cern/root/html530/TProofBenchRunCPU.html,2,['load'],['loaded']
Performance,TestInverterOriginal.C 'Hypothesis Test Inversion' RooStats tutorial macro #801 ;  rs_bernsteinCorrection.C 'Bernstein Correction' RooStats tutorial macro ;  rs_numberCountingCombination.C 'Number Counting Example' RooStats tutorial macro #100 ;  rs_numbercountingutils.C 'Number Counting Utils' RooStats tutorial ;  StandardBayesianMCMCDemo.C Standard demo of the Bayesian MCMC calculator ;  StandardBayesianNumericalDemo.C Standard demo of the numerical Bayesian calculator ;  StandardFeldmanCousinsDemo.C Standard demo of the Feldman-Cousins calculator StandardFeldmanCousinsDemo ;  StandardFrequentistDiscovery.C StandardFrequentistDiscovery ;  StandardHistFactoryPlotsWithCategories.C StandardHistFactoryPlotsWithCategories ;  StandardHypoTestDemo.C Standard tutorial macro for hypothesis test (for computing the discovery significance) using all RooStats hypotheiss tests calculators and test statistics ;  StandardHypoTestInvDemo.C Standard tutorial macro for performing an inverted hypothesis test for computing an interval ;  StandardProfileInspectorDemo.C Standard demo of the ProfileInspector class StandardProfileInspectorDemo ;  StandardProfileLikelihoodDemo.C Standard demo of the Profile Likelihood calculator StandardProfileLikelihoodDemo ;  StandardTestStatDistributionDemo.C StandardTestStatDistributionDemo.C ;  TestNonCentral.C ;  TwoSidedFrequentistUpperLimitWithBands.C TwoSidedFrequentistUpperLimitWithBands ;  Zbi_Zgamma.C Demonstrate Z_Bi = Z_Gamma ;  ► spectrum;  Background_compton.C Example to illustrate the background estimator (class TSpectrum) including Compton edges ;  Background_decr.C Example to illustrate the background estimator (class TSpectrum) ;  Background_incr.C Example to illustrate the background estimator (class TSpectrum) ;  Background_order.C Example to illustrate the influence of the clipping filter difference order on the estimated background ;  Background_smooth.C Example to illustrate the background estimator (class TSpectrum) including Compt,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:150019,perform,performing,150019,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['perform'],['performing']
Performance,"The cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxysigma; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGaussian.html:42403,cache,cache,42403,root/html534/RooGaussian.html,https://root.cern,https://root.cern/root/html534/RooGaussian.html,2,['cache'],['cache']
Performance,"The cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxywidth; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBreitWigner.html:42546,cache,cache,42546,root/html534/RooBreitWigner.html,https://root.cern,https://root.cern/root/html534/RooBreitWigner.html,1,['cache'],['cache']
Performance,"The cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDecay.html:41011,cache,cache,41011,root/html528/RooDecay.html,https://root.cern,https://root.cern/root/html528/RooDecay.html,2,['cache'],['cache']
Performance,"The current state includes: the current working directory, etc.; Returns the number of active slaves. Returns -1 in case of error. Int_t SendInitialState(); Transfer the initial (i.e. current) state of the master to all; slave servers. Currently the initial state includes: log level.; Returns the number of active slaves. Returns -1 in case of error. Bool_t CheckFile(const char* file, TSlave* sl, Long_t modtime, Int_t cpopt = (kCp|kCpBin)); Check if a file needs to be send to the slave. Use the following; algorithm:; - check if file appears in file map; - if yes, get file's modtime and check against time in map,; if modtime not same get md5 and compare against md5 in map,; if not same return kTRUE.; - if no, get file's md5 and modtime and store in file map, ask; slave if file exists with specific md5, if yes return kFALSE,; if no return kTRUE.; The options 'cpopt' define if to copy things from cache to sandbox and what.; To retrieve from the cache the binaries associated with the file TProof::kCpBin; must be set in cpopt; the default is copy everything.; Returns kTRUE in case file needs to be send, returns kFALSE in case; file is already on remote node. Int_t SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); Send a file to master or slave servers. Returns number of slaves; the file was sent to, maybe 0 in case master and slaves have the same; file system image, -1 in case of error.; If defined, send to worker 'wrk' only.; If defined, the full path of the remote path will be rfile.; If rfile = ""cache"" the file is copied to the remote cache instead of the sandbox; (to copy to the cache on a different name use rfile = ""cache:newname"").; The mask 'opt' is an or of ESendFileOpt:. kAscii (0x0) if set true ascii file transfer is used; kBinary (0x1) if set true binary file transfer is used; kForce (0x2) if not set an attempt is done to find out; whether the file really needs to be downloaded; (a valid copy may alrea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:55810,cache,cache,55810,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,4,['cache'],['cache']
Performance,"The ls function lists the contents of a class on stdout. Ls output; 577/// is typically much less verbose then Dump().; 578 ; 579void TObject::ls(Option_t *option) const; 580{; 581 TROOT::IndentLevel();; 582 std::cout <<""OBJ: "" << IsA()->GetName() << ""\t"" << GetName() << ""\t"" << GetTitle() << "" : "";; 583 std::cout << Int_t(TestBit(kCanDelete));; 584 if (option && strstr(option,""noaddr"")==nullptr) {; 585 std::cout <<"" at: ""<< this ;; 586 }; 587 std::cout << std::endl;; 588}; 589 ; 590////////////////////////////////////////////////////////////////////////////////; 591/// This method must be overridden to handle object notification (the base implementation is no-op).; 592///; 593/// Different objects in ROOT use the `Notify` method for different purposes, in coordination; 594/// with other objects that call this method at the appropriate time.; 595///; 596/// For example, `TLeaf` uses it to load class information; `TBranchRef` to load contents of; 597/// referenced branches `TBranchRef`; most notably, based on `Notify`, `TChain` implements a; 598/// callback mechanism to inform interested parties when it switches to a new sub-tree.; 599Bool_t TObject::Notify(); 600{; 601 return kFALSE;; 602}; 603 ; 604////////////////////////////////////////////////////////////////////////////////; 605/// This method must be overridden if a class wants to paint itself.; 606/// The difference between Paint() and Draw() is that when a object; 607/// draws itself it is added to the display list of the pad in; 608/// which it is drawn (and automatically redrawn whenever the pad is; 609/// redrawn). While paint just draws the object without adding it to; 610/// the pad display list.; 611 ; 612void TObject::Paint(Option_t *); 613{; 614 // AbstractMethod(""Paint"");; 615}; 616 ; 617////////////////////////////////////////////////////////////////////////////////; 618/// Pop on object drawn in a pad to the top of the display list. I.e. it; 619/// will be drawn last and on top of all other primit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:21159,load,load,21159,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,2,['load'],['load']
Performance,"The only data member is: Double_t fTranslation[3]. Translations can be added or subtracted. TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. Rotations (TGeoRotation class) represent a pure rotation. Data members are Double_t fRotationMatrix[3*3]. Rotations can be defined either by Euler angles, either, by GEANT3 angles:. TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi,theta,psi); // all angles in degrees; This represents the composition of: first a rotation about Z axis with angle phi, then a rotation with theta about the rotated X axis, and finally a rotation with psiabout the new Z axis.; r1->SetAngles(th1,phi1,th2,phi2,th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical angles of each axis of the rotated coordinate system with respect to the initial one. This construction allows definition of malformed rotations, e.g. not orthogonal. A check is performed and an error message is issued in this case.; Specific utilities: determinant, inverse. Scale transformations (TGeoScale class) - represent a scaled shrinking/enlargement, possibly different on all axes. Data members: Double_t fScale[3]. Not implemented yet.; Combined transformations - represent a rotation followed by a translation. Data members: Double_t fTranslation[3],TGeoRotation *fRotation. TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;; ...; TGeoCombiTrans *c1 = new TGeoCombiTrans(trans,rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). General transformations: (TGeoHMatrix class) represent combined transformations in any order.; Identity transformation: (TGeoIdentity class) is a generic identity transformation represented by a singleton class object gGeoIdentity. 18.4.4 Ownership of Geometry Objects; The class TGeoManager class contains the entire API needed for building and tracking geometry. It defines a global pointer gGeoManager in o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:967995,perform,performed,967995,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performed']
Performance,The result will be appended in the fit result class; 414 Optionally a vector of parameter indices can be passed for selecting; 415 the parameters to analyse using FitConfig::SetMinosErrors; 416 */; 417 bool CalculateMinosErrors();; 418 ; 419 /**; 420 access to the fit configuration (const method); 421 */; 422 const FitConfig & Config() const { return fConfig; }; 423 ; 424 /**; 425 access to the configuration (non const method); 426 */; 427 FitConfig & Config() { return fConfig; }; 428 ; 429 /**; 430 query if fit is binned. In cse of false the fit can be unbinned; 431 or is not defined (like in case of fitting through a ROOT::Fit::Fitter::FitFCN); 432 */; 433 bool IsBinFit() const { return fBinFit; }; 434 ; 435 /**; 436 return pointer to last used minimizer; 437 (is NULL in case fit is not yet done); 438 This pointer is guaranteed to be valid as far as the fitter class is valid and a new fit is not redone.; 439 To be used only after fitting.; 440 The pointer should not be stored and will be invalided after performing a new fitting.; 441 In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; 442 obtained calling again GetMinimizer(); 443 */; 444 ROOT::Math::Minimizer * GetMinimizer() const { return fMinimizer.get(); }; 445 ; 446 /**; 447 return pointer to last used objective function; 448 (is NULL in case fit is not yet done); 449 This pointer will be valid as far as the fitter class; 450 has not been deleted. To be used after the fitting.; 451 The pointer should not be stored and will be invalided after performing a new fitting.; 452 In this case a new instance of the function pointer will be re-created and can be; 453 obtained calling again GetFCN(); 454 */; 455 ROOT::Math::IMultiGenFunction * GetFCN() const {; 456 return fObjFunction.get();; 457 }; 458 ; 459 ; 460 /**; 461 apply correction in the error matrix for the weights for likelihood fits; 462 This method can be called only after a fit. The; 463 passed function (loglw2) is a log-l,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:17735,perform,performing,17735,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['perform'],['performing']
Performance,"These provide the infrastructure for building likelihood models. . Classes; class  RooFit::Evaluator;  Evaluates a RooAbsReal object in other ways than recursive graph traversal. More...;  ; class  Roo1DTable;  One-dimensional table. More...;  ; class  RooAbsAnaConvPdf;  Base class for PDFs that represent a physics model that can be analytically convolved with a resolution model. More...;  ; class  RooAbsArg;  Common abstract base class for objects that represent a value and a ""shape"" in RooFit. More...;  ; class  RooAbsBinning;  Abstract base class for RooRealVar binning definitions. More...;  ; class  RooAbsCache;  Abstract base class for data members of RooAbsArgs that cache other (composite) RooAbsArg expressions. More...;  ; class  RooAbsCachedPdf;  Abstract base class for p.d.f.s that need or want to cache their evaluate() output in a RooHistPdf defined in terms of the used observables. More...;  ; class  RooAbsCachedReal;  Abstract base class for functions that need or want to cache their evaluate() output in a RooHistFunc defined in terms of the used observables. More...;  ; class  RooAbsCacheElement;  Abstract base class for objects to be stored in RooAbsCache cache manager objects. More...;  ; class  RooAbsCategory;  A space to attach TBranches. More...;  ; class  RooAbsCategoryLValue;  Abstract base class for objects that represent a discrete value that can be set from the outside, i.e. More...;  ; class  RooAbsCollection;  Abstract container object that can hold multiple RooAbsArg objects. More...;  ; class  RooAbsData;  Abstract base class for binned and unbinned datasets. More...;  ; class  RooAbsDataStore;  Abstract base class for a data collection. More...;  ; class  RooAbsFunc;  Abstract interface for evaluating a real-valued function of one real variable and performing numerical algorithms on it. More...;  ; class  RooAbsGenContext;  Abstract base class for generator contexts of RooAbsPdf objects. More...;  ; class  RooAbsHiddenReal;  Base class fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Roofitcore.html:1153,cache,cache,1153,doc/master/group__Roofitcore.html,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html,1,['cache'],['cache']
Performance,"This also has the side-effect of allowing the extension of the concept ‘base class that prevent its derived class from being split’ to any user class. This fixes ROOT-7972.; TTree. Do not automatically setup read cache during TTree::Fill(). This fixes ROOT-8031.; Fast Cloning We added a cache specifically for the fast option of the TTreeCloner to significantly reduce the run-time when fast-cloning remote files to address ROOT-5078. It can be controlled from the TTreeCloner, TTree::CopyEntries or hadd interfaces. The new cache is enabled by default, to update the size of the cache or disable it from TTreeCloner use: TTreeCloner::SetCacheSize. To do the same from TTree::CopyEntries add to the option string “cachesize=SIZE”. To update the size of the cache or disable it from hadd, use the command line option -cachesize SIZE. SIZE shouyld be given in number bytes and can be expressed in ‘human readable form’ (number followed by size unit like MB, MiB, GB or GiB, etc. or SIZE can be set zero to disable the cache. Histogram Libraries. Protect access to TROOT::GetListOfGlobalFunctions in TFormula. Math. Update MixMax random number generator for 32 bit architectures. TColor. Import TColor from master to make sure the high quality palettes are defined only ones. This was requested here. PyROOT. Fix case where c++ exception in a constructor were not propagated to python ROOT-7864; Fix case where PyROOT was unable to call copy constructor ROOT-7783; Fix handling of vector<enums> ROOT-7916; Fix the wrong return value when calling a c++ function returning short, or when retuning a char with a negative value ROOT-7872; Added a new configuration option (ROOT.PyConfig.DisableRootLogon) to disable processing of the rootlogon[.py|C] macro in addition to the -n option in the command arguments. Bug Fixes and Tasks. [ROOT-7426] - Cannot print elements of vector on Mac; [ROOT-7739] - TVectorD times double returns a TH1 on ROOT command line; [ROOT-7825] - wrong value passed to function ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:26265,cache,cache,26265,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['cache'],['cache']
Performance,"Title*/,; 104 TString /*methodOption*/,; 105 TMVA::Types::EMVA /*theComposite*/,; 106 TString /*compositeOption = """"*/ ) { return nullptr; }; 107 ; 108 // optimize all booked methods (well, if desired by the method); 109 std::map<TString,Double_t> OptimizeAllMethods (TString fomType=""ROCIntegral"", TString fitType=""FitGA"");; 110 void OptimizeAllMethodsForClassification(TString fomType=""ROCIntegral"", TString fitType=""FitGA"") { OptimizeAllMethods(fomType,fitType); }; 111 void OptimizeAllMethodsForRegression (TString fomType=""ROCIntegral"", TString fitType=""FitGA"") { OptimizeAllMethods(fomType,fitType); }; 112 ; 113 // training for all booked methods; 114 void TrainAllMethods ();; 115 void TrainAllMethodsForClassification( void ) { TrainAllMethods(); }; 116 void TrainAllMethodsForRegression ( void ) { TrainAllMethods(); }; 117 ; 118 // testing; 119 void TestAllMethods();; 120 ; 121 // performance evaluation; 122 void EvaluateAllMethods( void );; 123 void EvaluateAllVariables(DataLoader *loader, TString options = """" );; 124 ; 125 TH1F* EvaluateImportance( DataLoader *loader,VIType vitype, Types::EMVA theMethod, TString methodTitle, const char *theOption = """" );; 126 ; 127 // delete all methods and reset the method vector; 128 void DeleteAllMethods( void );; 129 ; 130 // accessors; 131 IMethod* GetMethod( const TString& datasetname, const TString& title ) const;; 132 Bool_t HasMethod( const TString& datasetname, const TString& title ) const;; 133 ; 134 Bool_t Verbose( void ) const { return fVerbose; }; 135 void SetVerbose( Bool_t v=kTRUE );; 136 ; 137 // make ROOT-independent C++ class for classifier response; 138 // (classifier-specific implementation); 139 // If no classifier name is given, help messages for all booked; 140 // classifiers are printed; 141 virtual void MakeClass(const TString& datasetname , const TString& methodTitle = """" ) const;; 142 ; 143 // prints classifier-specific help messages, dedicated to; 144 // help with the optimisation and configuration optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:4906,load,loader,4906,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,1,['load'],['loader']
Performance,"Tool::SplitRule: public TNamed. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'maste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimWSTool__SplitRule.html:1291,perform,performed,1291,root/html526/RooSimWSTool__SplitRule.html,https://root.cern,https://root.cern/root/html526/RooSimWSTool__SplitRule.html,4,['perform'],['performed']
Performance,"Tracks[3]"");; tree->Draw(""theGoodTrack.fPx""); // same as ""event.fTracks[3].fPx"". void SetAutoFlush(Long64_t autof = 30000000); This function may be called at the start of a program to change; the default value for fAutoFlush. CASE 1 : autof > 0. autof is the number of consecutive entries after which TTree::Fill will; flush all branch buffers to disk. CASE 2 : autof < 0. When filling the Tree the branch buffers will be flushed to disk when; more than autof bytes have been written to the file. At the first FlushBaskets; TTree::Fill will replace fAutoFlush by the current value of fEntries. Calling this function with autof<0 is interesting when it is hard to estimate; the size of one entry. This value is also independent of the Tree. The Tree is initialized with fAutoFlush=-30000000, ie that, by default,; the first AutoFlush will be done when 30 MBytes of data are written to the file. CASE 3 : autof = 0. The AutoFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk. The value of autoflush determine a size in number of entries of; a cluster of baskets. If the value of autoflush is changed over time (this happens in; particular when fast merge files), we record the previous values; in the arrays fClusterRangeEnd and fClusterSize.; A range of entries where the size of the cluster of basket is; the same (i.e the value of AutoFlush was constant) is called; a ClusterRange. The 2 arrays have fNClusterRange active values and have; fMaxClusterRange allocated entries. fClusterRangeEnd contains the last entries number of a cluster range.; In particular this means that the 'next' cluster starts at fClusterRangeEnd[]+1; fClusterSize contains the size in number of entries of all the cluster; within the given range.; The last range (and the only one if fNClusterRange is zero) start at; fNClusterRange[fNClusterRange-1]+1 and ends at the end of the TTree. The; size of the cluster in this range is given by the valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:120098,optimiz,optimize,120098,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,1,['optimiz'],['optimize']
Performance,"Tracks[3]"");; tree->Draw(""theGoodTrack.fPx""); // same as ""event.fTracks[3].fPx"". void SetAutoFlush(Long64_t autof = 30000000); This function may be called at the start of a program to change; the default value for fAutoFlush. CASE 1 : autof > 0. autof is the number of consecutive entries after which TTree::Fill will; flush all branch buffers to disk. CASE 2 : autof < 0. When filling the Tree the branch buffers will be flushed to disk when; more than autof bytes have been written to the file. At the first FlushBaskets; TTree::Fill will replace fAutoFlush by the current value of fEntries. Calling this function with autof<0 is interesting when it is hard to estimate; the size of one entry. This value is also independent of the Tree. The Tree is initialized with fAutoFlush=-30000000, ie that, by default,; the first AutoFlush will be done when 30 MBytes of data are written to the file. CASE 3 : autof = 0. The AutoFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk. void SetAutoSave(Long64_t autos = 300000000); This function may be called at the start of a program to change; the default value for fAutoSave(300000000, ie 300 MBytes).; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when more than fAutoSave bytes have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, Int_t buffsize = 16000); Set a branch's basket size. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; buffsize = branc basket size. Int_t SetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:115659,optimiz,optimize,115659,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['optimiz'],['optimize']
Performance,"Transient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooCategoryProxy_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimultaneous.html:42757,cache,cache,42757,root/html602/RooSimultaneous.html,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html,4,['cache'],['cache']
Performance,"Transient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_nNumber of expected events; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExtendedTerm.html:41768,cache,cache,41768,root/html602/RooExtendedTerm.html,https://root.cern,https://root.cern/root/html602/RooExtendedTerm.html,8,['cache'],['cache']
Performance,"TransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:37073,cache,cache,37073,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,2,['cache'],['cache']
Performance,"Tree (default is 30 MBytes). The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8683 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8711 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 649 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.; NOTE 1:; Circular Trees are interesting in online real time environments to store the results of the last maxEntries events. NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before merging circular Trees that have been saved on files. NOTE 3:; SetCircular with maxEntries <= 0 is automatically called by TChain::Merge NOTE 4:; A circular Tree can still be saved in a file. When read back, it i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:211276,cache,cache,211276,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['cache'],['cache']
Performance,"Tree can be retrieved by typing rootls -lt myfile.root at a command line. Distributed Snapshot; The Snapshot operation behaves slightly differently when executed distributedly. First off, it requires the path supplied to the Snapshot call to be accessible from any worker of the cluster and from the client machine (in general it should be provided as an absolute path). Another important difference is that n separate files will be produced, where n is the number of dataset partitions. As with local RDataFrame, the result of a Snapshot on a distributed RDataFrame is another distributed RDataFrame on which we can define a new computation graph and run more distributed computations. Distributed RunGraphs; Submitting multiple distributed RDataFrame executions is supported through the RunGraphs function. Similarly to its local counterpart, the function expects an iterable of objects representing an RDataFrame action. Each action will be triggered concurrently to send multiple computation graphs to a distributed cluster at the same time:; import ROOT; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; RunGraphs = ROOT.RDF.Experimental.Distributed.RunGraphs; ; # Create 3 different dataframes and book an histogram on each one; histoproxies = [; RDataFrame(100); .Define(""x"", ""rdfentry_""); .Histo1D((""name"", ""title"", 10, 0, 100), ""x""); for _ in range(4); ]; ; # Execute the 3 computation graphs; RunGraphs(histoproxies); # Retrieve all the histograms in one go; histos = [histoproxy.GetValue() for histoproxy in histoproxies]; Every distributed backend supports this feature and graphs belonging to different backends can be still triggered with a single call to RunGraphs (e.g. it is possible to send a Spark job and a Dask job at the same time). Histogram models in distributed mode; When calling a Histo*D operation in distributed mode, remember to pass to the function the model of the histogram to be computed, e.g. the axis range and the number of bins:; import ROOT; RData",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:41232,concurren,concurrently,41232,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['concurren'],['concurrently']
Performance,"Tree::Draw for explanation of the other parameters. The created object is named ""principal"" and a reference to it; is added to the list of specials Root objects.; you can retrieve a pointer to the created object via:; TPrincipal *principal =; (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");. void Print(Option_t* option = """") const; Print a summary of the tree contents. If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed. Wildcarding can be used to print only a subset of the branches, e.g.,; T.Print(""Elec*"") will print all branches with name starting with ""Elec"". void PrintCacheStats(Option_t* option = """") const; print statistics about the TreeCache for this tree, like; ******TreeCache statistics for file: cms2.root ******; Reading 73921562 bytes in 716 transactions; Average transaction = 103.242405 Kbytes; Number of blocks in current cache: 202, total size : 6001193. if option = ""a"" the list of blocks in the cache is printed. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called everytime a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:106777,cache,cache,106777,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['cache'],['cache']
Performance,"TreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLearnPrefill() const; {return fPrefillType;}. TTree * GetTree() const; {return fTree;}. Bool_t IsAutoCreated() const; {return fAutoCreated;}. Bool_t IsEnabled() const; {return fEnabled;}. Bool_t IsLearning() const; {return fIsLearning;}. void SetAutoCreated(Bool_t val); {fAutoCreated = val;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last genera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:26994,cache,cache,26994,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,2,['cache'],['cache']
Performance,TreeCacheUnzip.; Definition at line 2210 of file TTreeCache.cxx. Member Data Documentation. ◆ fAutoCreated. bool TTreeCache::fAutoCreated {false}. protected . ! true if cache was automatically created ; Definition at line 66 of file TTreeCache.h. ◆ fBranches. TObjArray* TTreeCache::fBranches {nullptr}. protected . ! List of branches to be stored in the cache ; Definition at line 51 of file TTreeCache.h. ◆ fBrNames. TList* TTreeCache::fBrNames {nullptr}. protected . ! list of branch names in the cache ; Definition at line 52 of file TTreeCache.h. ◆ fCurrentClusterStart. Long64_t TTreeCache::fCurrentClusterStart {-1}. protected . ! Start of the cluster(s) where the current content was picked out ; Definition at line 42 of file TTreeCache.h. ◆ fEnabled. bool TTreeCache::fEnabled {true}. protected . ! cache enabled for cached reading ; Definition at line 63 of file TTreeCache.h. ◆ fEntryCurrent. Long64_t TTreeCache::fEntryCurrent {-1}. protected . ! current lowest entry number in the cache ; Definition at line 40 of file TTreeCache.h. ◆ fEntryMax. Long64_t TTreeCache::fEntryMax {1}. protected . ! last entry in the cache ; Definition at line 39 of file TTreeCache.h. ◆ fEntryMin. Long64_t TTreeCache::fEntryMin {0}. protected . ! first entry in the cache ; Definition at line 38 of file TTreeCache.h. ◆ fEntryNext. Long64_t TTreeCache::fEntryNext {-1}. protected . ! next entry number where cache must be filled ; Definition at line 41 of file TTreeCache.h. ◆ fFillTimes. Int_t TTreeCache::fFillTimes {0}. protected . ! how many times we can fill the current buffer ; Definition at line 59 of file TTreeCache.h. ◆ fFirstBuffer. bool TTreeCache::fFirstBuffer {true}. protected . ! true if first buffer is used for prefetching ; Definition at line 56 of file TTreeCache.h. ◆ fFirstEntry. Long64_t TTreeCache::fFirstEntry {-1}. protected . ! save the value of the first entry ; Definition at line 61 of file TTreeCache.h. ◆ fFirstMiss. Long64_t TTreeCache::fFirstMiss {-1}. protected . ! set,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:52733,cache,cache,52733,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['cache'],['cache']
Performance,TreeCacheUnzip.; Definition at line 2211 of file TTreeCache.cxx. Member Data Documentation. ◆ fAutoCreated. bool TTreeCache::fAutoCreated {false}. protected . ! true if cache was automatically created ; Definition at line 66 of file TTreeCache.h. ◆ fBranches. TObjArray* TTreeCache::fBranches {nullptr}. protected . ! List of branches to be stored in the cache ; Definition at line 51 of file TTreeCache.h. ◆ fBrNames. TList* TTreeCache::fBrNames {nullptr}. protected . ! list of branch names in the cache ; Definition at line 52 of file TTreeCache.h. ◆ fCurrentClusterStart. Long64_t TTreeCache::fCurrentClusterStart {-1}. protected . ! Start of the cluster(s) where the current content was picked out ; Definition at line 42 of file TTreeCache.h. ◆ fEnabled. bool TTreeCache::fEnabled {true}. protected . ! cache enabled for cached reading ; Definition at line 63 of file TTreeCache.h. ◆ fEntryCurrent. Long64_t TTreeCache::fEntryCurrent {-1}. protected . ! current lowest entry number in the cache ; Definition at line 40 of file TTreeCache.h. ◆ fEntryMax. Long64_t TTreeCache::fEntryMax {1}. protected . ! last entry in the cache ; Definition at line 39 of file TTreeCache.h. ◆ fEntryMin. Long64_t TTreeCache::fEntryMin {0}. protected . ! first entry in the cache ; Definition at line 38 of file TTreeCache.h. ◆ fEntryNext. Long64_t TTreeCache::fEntryNext {-1}. protected . ! next entry number where cache must be filled ; Definition at line 41 of file TTreeCache.h. ◆ fFillTimes. Int_t TTreeCache::fFillTimes {0}. protected . ! how many times we can fill the current buffer ; Definition at line 59 of file TTreeCache.h. ◆ fFirstBuffer. bool TTreeCache::fFirstBuffer {true}. protected . ! true if first buffer is used for prefetching ; Definition at line 56 of file TTreeCache.h. ◆ fFirstEntry. Long64_t TTreeCache::fFirstEntry {-1}. protected . ! save the value of the first entry ; Definition at line 61 of file TTreeCache.h. ◆ fFirstMiss. Long64_t TTreeCache::fFirstMiss {-1}. protected . ! set,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:52803,cache,cache,52803,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['cache'],['cache']
Performance,"TreeCacheUnzip.; Definition at line 446 of file TTreeCache.cxx. ◆ AddBranch() [2/2]. Int_t TTreeCache::AddBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ; The branch is added even if we are outside of the training phase. Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 376 of file TTreeCache.cxx. ◆ CalculateMissCache(). bool TTreeCache::CalculateMissCache ; (; ). private . Calculate the appropriate miss cache to fetch; helper function for FillMissCache. . ◆ CalculateMissEntries(). TBranch * TTreeCache::CalculateMissEntries ; (; Long64_t ; pos, . int ; len, . bool ; all . ). private . Given an file read, try to determine the corresponding branch. ; Given a particular IO description (offset / length) representing a 'miss' of the TTreeCache's primary cache, calculate all the corresponding IO that should be performed.; all indicates that this function should search the set of all branches in this TTree. When set to false, we only search through branches that have previously incurred a miss.; Returns:; TBranch pointer corresponding to the basket that will be retrieved by this IO operation.; If no corresponding branch could be found (or an error occurs), this returns nullptr. . Definition at line 790 of file TTreeCache.cxx. ◆ CheckMissCache(). bool TTreeCache::CheckMissCache ; (; char * ; buf, . Long64_t ; pos, . int ; len . ). private . Check the miss cache for a particular buffer, fetching if deemed necessary. ; Given an IO operation (pos, len) that was a cache miss in the primary TTC, try the operation again with the miss cache.; Returns true if the IO operation was successful and the contents of buf were populated with the requested data. ; Definition at line 921 of file TTreeCache.cxx. ◆ Class(). static TClass ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:36298,cache,cache,36298,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,4,"['cache', 'perform']","['cache', 'performed']"
Performance,"TreeCloner &)=delete;  ;  TTreeCloner (TTree *from, TTree *to, TDirectory *newdirectory, Option_t *method, UInt_t options=kNone);  Constructor implementation. ;  ; void CreateCache ();  Create a TFileCacheRead if it was requested. ;  ; UInt_t FillCache (UInt_t from);  Fill the file cache with the next set of basket. ;  ; void ImportClusterRanges ();  Set the entries and import the cluster range of the. ;  ; TTreeCloner & operator= (const TTreeCloner &)=delete;  ; void RestoreCache ();  Restore the TFileCacheRead to its previous value. ;  . Private Attributes; UInt_t * fBasketBranchNum;  [fMaxBaskets] Index of the branch(es) of the basket. ;  ; Long64_t * fBasketEntry;  [fMaxBaskets] list of basket start entries. ;  ; UInt_t * fBasketIndex;  [fMaxBaskets] ordered list of basket indices to be written. ;  ; UInt_t * fBasketNum;  [fMaxBaskets] index of the basket within the branch. ;  ; Long64_t * fBasketSeek;  [fMaxBaskets] list of basket position to be read. ;  ; Long64_t fCacheSize;  Requested size of the file cache. ;  ; UInt_t fCloneMethod;  Indicates which cloning method was selected. ;  ; TFileCacheRead * fFileCache;  File Cache used to reduce the number of individual reads. ;  ; TObjArray fFromBranches;  ; TTree * fFromTree;  ; bool fIsValid;  ; UInt_t fMaxBaskets;  ; Option_t * fMethod;  ; bool fNeedConversion;  True if the fast merge is not possible but a slow merge might possible. ;  ; UInt_t fOptions;  ; UShort_t fPidOffset;  Offset to be added to the copied key/basket. ;  ; TFileCacheRead * fPrevCache;  Cache that set before the TTreeCloner ctor for the 'from' TTree if any. ;  ; TObjArray fToBranches;  ; TDirectory * fToDirectory;  ; TFile * fToFile;  ; Long64_t fToStartEntries;  Number of entries in the target tree before any addition. ;  ; TTree * fToTree;  ; TString fWarningMsg;  Text of the error message lead to an 'invalid' state. ;  . Friends; class CompareEntry;  ; class CompareSeek;  . #include <TTreeCloner.h>; Member Enumeration Documentation. ◆ ECl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCloner.html:3654,cache,cache,3654,doc/master/classTTreeCloner.html,https://root.cern,https://root.cern/doc/master/classTTreeCloner.html,1,['cache'],['cache']
Performance,"TreeName ; (; const char * ; dataset, . const char * ; treename . ). overridevirtual . Set/Change the name of the default tree. ; The tree name may contain subdir specification in the form ""subdir/name"". Returns 0 on success, -1 otherwise. ; Reimplemented from TProof.; Definition at line 2002 of file TProofLite.cxx. ◆ SetProofServEnv(). Int_t TProofLite::SetProofServEnv ; (; const char * ; ord). private . Create environment files for worker 'ord'. ; Definition at line 684 of file TProofLite.cxx. ◆ SetQueryRunning(). void TProofLite::SetQueryRunning ; (; TProofQueryResult * ; pq). protected . Set query in running state. ; Definition at line 1025 of file TProofLite.cxx. ◆ SetupWorkers(). Int_t TProofLite::SetupWorkers ; (; Int_t ; opt = 0, . TList * ; wrks = 0 . ). protected . Start up PROOF workers. ; Definition at line 489 of file TProofLite.cxx. ◆ ShowCache(). void TProofLite::ShowCache ; (; Bool_t ; all = kFALSE). overridevirtual . List contents of file cache. ; If all is true show all caches also on slaves. If everything is ok all caches are to be the same. ; Reimplemented from TProof.; Definition at line 1508 of file TProofLite.cxx. ◆ ShowData(). void TProofLite::ShowData ; (; ). overridevirtual . List contents of the data directory in the sandbox. ; This is the place where files produced by the client queries are kept ; Reimplemented from TProof.; Definition at line 2479 of file TProofLite.cxx. ◆ ShowDataDir(). void TProofLite::ShowDataDir ; (; const char * ; dirname). private . List contents of the data directory 'dirname'. ; Definition at line 2495 of file TProofLite.cxx. ◆ ShowDataSetCache(). void TProofLite::ShowDataSetCache ; (; const char * ; dataset = 0). overridevirtual . Display the content of the dataset cache, if any (matching 'dataset', if defined). ; Reimplemented from TProof.; Definition at line 2292 of file TProofLite.cxx. ◆ ShowDataSets(). void TProofLite::ShowDataSets ; (; const char * ; uri = """", . const char * ; opt = 0 . ). overridevirtual . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:66375,cache,caches,66375,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['cache'],['caches']
Performance,"TreePerfStats object can be saved in a ROOT file in such a way that; its inspection can be done outside the job that generated it. Example of use; {; TFile *f = TFile::Open(""RelValMinBias-GEN-SIM-RECO.root"");; T = (TTree*)f->Get(""Events"");; Long64_t nentries = T->GetEntries();; T->SetCacheSize(10000000);; T->SetCacheEntryRange(0,nentries);; T->AddBranchToCache(""*"");. TTreePerfStats *ps= new TTreePerfStats(""ioperf"",T);. for (Int_t i=0;i<nentries;i++) {; T->GetEntry(i);; }; ps->SaveAs(""cmsperf.root"");; }. then, in a root interactive session, one can do:; root > TFile f(""cmsperf.root"");; root > ioperf->Draw();; root > ioperf->Print();. The Draw or Print functions print the following information:; TreeCache = TTree cache size in MBytes; N leaves = Number of leaves in the TTree; ReadTotal = Total number of zipped bytes read; ReadUnZip = Total number of unzipped bytes read; ReadCalls = Total number of disk reads; ReadSize = Average read size in KBytes; Readahead = Readahead size in KBytes; Readextra = Readahead overhead in percent; Real Time = Real Time in seconds; CPU Time = CPU Time in seconds; Disk Time = Real Time spent in pure raw disk IO; Disk IO = Raw disk IO speed in MBytes/second; ReadUZRT = Unzipped MBytes per RT second; ReadUZCP = Unipped MBytes per CP second; ReadRT = Zipped MBytes per RT second; ReadCP = Zipped MBytes per CP second. NOTE1 : The ReadTotal value indicates the effective number of zipped bytes; returned to the application. The physical number of bytes read; from the device (as measured for example with strace) is; ReadTotal +ReadTotal*Readextra/100. Same for ReadSize. NOTE2 : A consequence of NOTE1, the Disk I/O speed corresponds to the effective; number of bytes returned to the application per second.; The Physical disk speed is DiskIO + DiskIO*ReadExtra/100. Function Members (Methods); public:. TTreePerfStats(); TTreePerfStats(const TTreePerfStats&); TTreePerfStats(const char* name, TTree* T); virtual~TTreePerfStats(); voidTObject::AbstractMetho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePerfStats.html:1495,cache,cache,1495,root/html528/TTreePerfStats.html,https://root.cern,https://root.cern/root/html528/TTreePerfStats.html,4,['cache'],['cache']
Performance,"TreePerfStats object can be saved in a ROOT file in such a way that; its inspection can be done outside the job that generated it. Example of use; {; TFile *f = TFile::Open(""RelValMinBias-GEN-SIM-RECO.root"");; T = (TTree*)f->Get(""Events"");; Long64_t nentries = T->GetEntries();; T->SetCacheSize(10000000);; T->SetCacheEntryRange(0,nentries);; T->AddBranchToCache(""*"");. TTreePerfStats *ps= new TTreePerfStats(""ioperf"",T);. for (Int_t i=0;i<nentries;i++) {; T->GetEntry(i);; }; ps->SaveAs(""cmsperf.root"");; }. then, in a root interactive session, one can do:; root > TFile f(""cmsperf.root"");; root > ioperf->Draw();; root > ioperf->Print();. The Draw or Print functions print the following information:; TreeCache = TTree cache size in MBytes; N leaves = Number of leaves in the TTree; ReadTotal = Total number of zipped bytes read; ReadUnZip = Total number of unzipped bytes read; ReadCalls = Total number of disk reads; ReadSize = Average read size in KBytes; Readahead = Readahead size in KBytes; Readextra = Readahead overhead in percent; Real Time = Real Time in seconds; CPU Time = CPU Time in seconds; Disk Time = Real Time spent in pure raw disk IO; Disk IO = Raw disk IO speed in MBytes/second; ReadUZRT = Unzipped MBytes per RT second; ReadUZCP = Unipped MBytes per CP second; ReadRT = Zipped MBytes per RT second; ReadCP = Zipped MBytes per CP second. NOTE1 : The ReadTotal value indicates the effective number of zipped bytes; returned to the application. The physical number of bytes read; from the device (as measured for example with strace) is; ReadTotal +ReadTotal*Readextra/100. Same for ReadSize. NOTE2 : A consequence of NOTE1, the Disk I/O speed corresponds to the effective; number of bytes returned to the application per second.; The Physical disk speed is DiskIO + DiskIO*ReadExtra/100. Function Members (Methods); public:. virtual~TTreePerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrows",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreePerfStats.html:1519,cache,cache,1519,root/html602/TTreePerfStats.html,https://root.cern,https://root.cern/root/html602/TTreePerfStats.html,2,['cache'],['cache']
Performance,"Ts are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 525 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 494 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:21636,concurren,concurrent,21636,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['concurren'],['concurrent']
Performance,"Ts are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 526 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 495 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:21597,concurren,concurrent,21597,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['concurren'],['concurrent']
Performance,"Ts are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 579 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 548 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 50 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:20907,concurren,concurrent,20907,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,1,['concurren'],['concurrent']
Performance,"Ts are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 580 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 549 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v620/namespaceROOT.html:20999,concurren,concurrent,20999,doc/v620/namespaceROOT.html,https://root.cern,https://root.cern/doc/v620/namespaceROOT.html,1,['concurren'],['concurrent']
Performance,"TupleImporter object.; auto importer = RNTupleImporter::Create(kTreeFileName, kTreeName, kNTupleFileName);; ; // Begin importing.; importer->Import();; ; // Inspect the schema of the written RNTuple.; auto file = std::unique_ptr<TFile>(TFile::Open(kNTupleFileName));; if (!file || file->IsZombie()) {; std::cerr << ""cannot open "" << kNTupleFileName << std::endl;; return;; }; auto ntpl = std::unique_ptr<ROOT::RNTuple>(file->Get<ROOT::RNTuple>(""Events""));; auto reader = RNTupleReader::Open(*ntpl);; reader->PrintInfo();; ; ROOT::RDataFrame df(""Events"", kNTupleFileName);; df.Histo1D({""Jet_pt"", ""Jet_pt"", 100, 0, 0}, ""Jet_pt"")->DrawCopy();; }; RNTupleDS.hxx; RNTupleImporter.hxx; RNTupleReader.hxx; RPageStorageFile.hxx; TFile.h; TROOT.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; ROOT::Experimental::RNTupleImporterConverts a TTree into an RNTuple.Definition RNTupleImporter.hxx:103; ROOT::Experimental::RNTupleReaderAn RNTuple that is used to read data from storage.Definition RNTupleReader.hxx:71; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RNTupleRepresentation of an RNTuple data set in a ROOT file.Definition RNTuple.hxx:69; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; DateDecember 2022 ; AuthorThe ROOT Team ; Definition in file ntpl008_import.C. tutorialsv7ntuplentpl008_import.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ntpl008__import_8C.html:3162,multi-thread,multi-threading,3162,doc/master/ntpl008__import_8C.html,https://root.cern,https://root.cern/doc/master/ntpl008__import_8C.html,1,['multi-thread'],['multi-threading']
Performance,"Tutorials. Detailed Description; Addition and convolution: working with a pdf with a convolution operator in terms of a parameter ; This tutorial requires FFT3 to be enabled. ; #include ""RooRealVar.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""RooGenericPdf.h""; #include ""RooFormulaVar.h""; #include ""RooFFTConvPdf.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH2.h""; using namespace RooFit;; ; void rf211_paramconv(); {; // S e t u p c o m p o n e n t p d f s; // ---------------------------------------; ; // Gaussian g(x ; mean,sigma); RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar mean(""mean"", ""mean"", -3, 3);; RooRealVar sigma(""sigma"", ""sigma"", 0.5, 0.1, 10);; RooGaussian modelx(""gx"", ""gx"", x, mean, sigma);; ; // Block function in mean; RooRealVar a(""a"", ""a"", 2, 1, 10);; RooGenericPdf model_mean(""model_mean"", ""abs(mean)<a"", RooArgList(mean, a));; ; // Convolution in mean parameter model = g(x,mean,sigma) (x) block(mean); x.setBins(1000, ""cache"");; mean.setBins(50, ""cache"");; RooFFTConvPdf model(""model"", ""model"", mean, modelx, model_mean);; ; // Configure convolution to construct a 2-D cache in (x,mean); // rather than a 1-d cache in mean that needs to be recalculated; // for each value of x; model.setCacheObservables(x);; model.setBufferFraction(1.0);; ; // Integrate model over mean projModel = Int model dmean; RooAbsPdf *projModel = model.createProjection(mean);; ; // Generate 1000 toy events; std::unique_ptr<RooDataHist> d{projModel->generateBinned(x, 1000)};; ; // Fit pdf to toy data; projModel->fitTo(*d, Verbose(), PrintLevel(-1));; ; // Plot data and fitted pdf; RooPlot *frame = x.frame(Bins(25));; d->plotOn(frame);; projModel->plotOn(frame);; ; // Make 2d histogram of model(x;mean); TH1 *hh = model.createHistogram(""hh"", x, Binning(50), YVar(mean, Binning(50)), ConditionalObservables(mean));; hh->SetTitle(""histogram of model(x|mean)"");; hh->SetLineColor(kBlue);; ; // Draw frame on canvas; TCanvas *c = new TCanvas(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf211__paramconv_8C.html:1191,cache,cache,1191,doc/master/rf211__paramconv_8C.html,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8C.html,1,['cache'],['cache']
Performance,"Type(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); Bool_tRooAbsCategoryLValue::setOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); Bool_tsetType(const RooCatType* type, Bool_t prinError = kTRUE); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidupdateIndexList().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSuperCategory.html:18701,optimiz,optimizeDirtyHook,18701,root/html528/RooSuperCategory.html,https://root.cern,https://root.cern/root/html528/RooSuperCategory.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"TypedValueClones (TClonesArray *clones, Int_t i, Int_t j, Int_t k, Int_t eoffset) const;  ; template<typename T > ; T GetTypedValueSTL (TVirtualCollectionProxy *cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const;  Return value of element i in object number j in a TClonesArray and eventually element k in a sub-array. ;  ; template<typename T > ; T GetTypedValueSTLP (TVirtualCollectionProxy *cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const;  Return value of element i in object number j in a TClonesArray and eventually element k in a sub-array. ;  ; Double_t GetValue (char *pointer, Int_t i, Int_t j, Int_t len) const;  ; Double_t GetValueClones (TClonesArray *clones, Int_t i, Int_t j, Int_t k, Int_t eoffset) const;  ; Double_t GetValueSTL (TVirtualCollectionProxy *cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const;  ; Double_t GetValueSTLP (TVirtualCollectionProxy *cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const;  ; TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions (Bool_t forCollection);  ; TStreamerInfoActions::TActionSequence * GetWriteObjectWiseActions ();  ; TStreamerInfoActions::TActionSequence * GetWriteTextActions ();  ; TClass * IsA () const override;  ; void ls (Option_t *option="""") const override;  List the TStreamerElement list and also the precomputed tables if option contains the string ""incOrig"", also prints the original (non-optimized elements in the list of compiled elements. ;  ; Bool_t MatchLegacyCheckSum (UInt_t checksum) const;  Return true if the checksum passed as argument is one of the checksum value produced by the older checksum calculation algorithm. ;  ; void * New (void *obj=nullptr) override;  An emulated object is created at address obj, if obj is null we allocate memory for the object. ;  ; void * NewArray (Long_t nElements, void *ary=nullptr) override;  An array of emulated objects is created at address ary, if ary is null, we allocate memory for the array. ;  ; TVirtualStreamerInfo * NewInfo (TClass *cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerInfo.html:10637,optimiz,optimized,10637,doc/master/classTStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTStreamerInfo.html,1,['optimiz'],['optimized']
Performance,"UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooSetProxy_compSetDSet proxy for denominator components; RooSetProxy_compSetNSet proxy for numerator components; RooArgSet*_compSetOwnedDOwner of denominator components; RooArgSet*_compSetOwnedNOwner of numerator components; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveDDo we have a denominator term?; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooListProxy_intListMaster integrals representing numerator and denominator; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenProdProj.html:35358,cache,cache,35358,root/html602/RooGenProdProj.html,https://root.cern,https://root.cern/root/html602/RooGenProdProj.html,2,['cache'],['cache']
Performance,"UE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. By default this is 75% of the; read cache size. But specific TFile implementations may need to change it. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. EAsyncOpenStatus GetAsyncOpenStatus(); { return fAsyncOpenStatus; }. Long64_t DirCreateEntry(TDirectory* ); Interface for text-based TDirectory I/O. { return 0; }. Int_t DirReadKeys(TDirectory* ); { return 0; }. void DirWriteKeys(TDirectory* ); {}. void DirWriteHeader(TDirectory* ); {}. void operator=(const TFile& ). void Copy(TObject& ) const; { MayNotUse(""Copy(TObject &)""); }. TArchiveFile * GetArchive() const; { return fArchive; }. Long64_t GetArchiveOffset() const; { return fArchiveOffset; }. TArrayC * GetClassIndex() const; { return fClassIndex; }. Long64_t GetEND() const; { return fEND; }. Int_t GetFd() const; { return fD; }. const TUrl * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFile.html:54420,load,loading,54420,root/html532/TFile.html,https://root.cern,https://root.cern/root/html532/TFile.html,8,"['cache', 'load']","['cache', 'loading']"
Performance,"UID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kLinear; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kNormalized; static TObject::(anonymous)TObject::kNotDeleted; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kNotGlobal; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObjArrayfAliases! List of TTreeFormula for each alias used.; vector<string>fAliasesUsed! List of aliases used during the parsing of the expression.; TBitsROOT::v5::TFormula::fAlreadyFound! cache for information; TAxis*fAxis! pointer to histogram axis if this is a string; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Int_tfCodes[500]List of leaf numbers referenced in formula; Double_t*ROOT::v5::TFormula::fConst[fNconst] Array of fNconst formula constants; LongDouble_t*fConstLDlocal version of fConsts able to store bigger numbers; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*ROOT::v5::TFormula::fExpr[fNoper] List of expressions; TString*ROOT::v5::TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeFormula.html:15261,cache,cache,15261,root/html604/TTreeFormula.html,https://root.cern,https://root.cern/root/html604/TTreeFormula.html,1,['cache'],['cache']
Performance,"UIDs; TStringfVersionROOT version (from CMZ VERSQQ) ex 0.05/01; Int_tfVersionCodeROOT version code as used in RVersion.h; Int_tfVersionDateDate of ROOT version (ex 951226); Int_tfVersionIntROOT version in integer format (501); Int_tfVersionTimeTime of ROOT version (ex 1152); static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory. private:. Int_tfLineIsProcessingTo synchronize multi-threads; static Int_tfgDirLevelIndentation level for ls(); static Bool_tfgMemCheckTurn on memory leak checker; static Bool_tfgRootInitSingleton initialization flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TROOT(); Clean up and free resources used by ROOT (files, network sockets,; shared memory segments, etc.). void AddClass(TClass* cl); Add a class to the list and map of classes. void AddClassGenerator(TClassGenerator* gen); Add a class generator. This generator will be called by TClass::GetClass; in case its does not find a loaded rootcint dictionary to request the; creation of a TClass object. void Browse(TBrowser* b); Add browsable objects to TBrowser. Bool_t ClassSaved(TClass* cl); return class status bit kClassSaved for class cl; This function is called by the SavePrimitive functions writing; the C++ code for an object. TObject * FindObject(const TObject* obj) const; Find an object in one Root folder. TObject * FindObject(const char* name) const; Returns address of a ROOT object if it exists. If name contains at least one ""/"" the function calls FindObjectany; else; This function looks in the following order in the ROOT lists:; - List of files; - List of memory mapped files; - List of functions; - List of geometries; - List of canvases; - List of styles; - List of specials; - List of materials in current geometry; - List of shapes in current geometry; - List of matrices in current geometry; - List of Nodes in current geometry; - Current Directory in memory; - Current Directory on file. TObject * Fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:19957,load,loaded,19957,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['load'],['loaded']
Performance,"UIDs; TStringfVersionROOT version (from CMZ VERSQQ) ex 0.05/01; Int_tfVersionCodeROOT version code as used in RVersion.h; Int_tfVersionDateDate of ROOT version (ex 951226); Int_tfVersionIntROOT version in integer format (501); Int_tfVersionTimeTime of ROOT version (ex 1152); static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory. private:. Int_tfLineIsProcessingTo synchronize multi-threads; static Int_tfgDirLevelIndentation level for ls(); static Bool_tfgMemCheckTurn on memory leak checker; static Bool_tfgRootInitSingleton initialization flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TROOT(); Clean up and free resources used by ROOT (files, network sockets,; shared memory segments, etc.). void AddClass(TClass* cl); Add a class to the list and map of classes. void AddClassGenerator(TClassGenerator* gen); Add a class generator. This generator will be called by TClass::GetClass; in case its does not find a loaded rootcint dictionary to request the; creation of a TClass object. void Browse(TBrowser* b); Add browsable objects to TBrowser. Bool_t ClassSaved(TClass* cl); return class status bit kClassSaved for class cl; This function is called by the SavePrimitive functions writing; the C++ code for an object. void CloseFiles(); Close any files and sockets that gROOT knows about.; This can be used to insures that the files and sockets are closed before any library is unloaded!. TObject * FindObject(const TObject* obj) const; Find an object in one Root folder. TObject * FindObject(const char* name) const; Returns address of a ROOT object if it exists. If name contains at least one ""/"" the function calls FindObjectany; else; This function looks in the following order in the ROOT lists:; - List of files; - List of memory mapped files; - List of functions; - List of geometries; - List of canvases; - List of styles; - List of specials; - List of materials in current geometry; - List of shapes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TROOT.html:20209,load,loaded,20209,root/html530/TROOT.html,https://root.cern,https://root.cern/root/html530/TROOT.html,1,['load'],['loaded']
Performance,"UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidTMVA::MethodANNBase::SetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodMLP.html:12063,tune,tuneParameters,12063,root/html534/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodMLP.html,1,['tune'],['tuneParameters']
Performance,"UNINIT_END \; 539 R__DO_PRAGMA(GCC diagnostic pop); 540#else; 541# define R__INTENTIONALLY_UNINIT_BEGIN; 542# define R__INTENTIONALLY_UNINIT_END; 543 ; 544#endif; 545 ; 546#ifdef R__HAS_ATTRIBUTE_ALWAYS_INLINE; 547#define R__ALWAYS_INLINE inline __attribute__((always_inline)); 548#else; 549#if defined(_MSC_VER); 550#define R__ALWAYS_INLINE __forceinline; 551#else; 552#define R__ALWAYS_INLINE inline; 553#endif; 554#endif; 555 ; 556// See also https://nemequ.github.io/hedley/api-reference.html#HEDLEY_NEVER_INLINE; 557// for other platforms.; 558#ifdef R__HAS_ATTRIBUTE_NOINLINE; 559#define R__NEVER_INLINE inline __attribute__((noinline)); 560#else; 561#if defined(_MSC_VER); 562#define R__NEVER_INLINE inline __declspec(noinline); 563#else; 564#define R__NEVER_INLINE inline; 565#endif; 566#endif; 567 ; 568/*---- unlikely / likely expressions -----------------------------------------*/; 569// These are meant to use in cases like:; 570// if (R__unlikely(expression)) { ... }; 571// in performance-critical sections. R__unlikely / R__likely provide hints to; 572// the compiler code generation to heavily optimize one side of a conditional,; 573// causing the other branch to have a heavy performance cost.; 574//; 575// It is best to use this for conditionals that test for rare error cases or; 576// backward compatibility code.; 577 ; 578#if (__GNUC__ >= 3) || defined(__INTEL_COMPILER); 579#if !defined(R__unlikely); 580 #define R__unlikely(expr) __builtin_expect(!!(expr), 0); 581#endif; 582#if !defined(R__likely); 583 #define R__likely(expr) __builtin_expect(!!(expr), 1); 584#endif; 585#else; 586 #define R__unlikely(expr) expr; 587 #define R__likely(expr) expr; 588#endif; 589 ; 590// Setting this define causes ROOT to keep statistics about memory buffer allocation; 591// time within the TTree. Given that this is a ""hot-path"", we provide a mechanism; 592// for enabling / disabling this at compile time by developers; default is disabled.; 593#ifndef R__TRACK_BASKET_ALLOC_TIME; 594/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RConfig_8hxx_source.html:16070,perform,performance-critical,16070,doc/master/RConfig_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RConfig_8hxx_source.html,1,['perform'],['performance-critical']
Performance,"UnzipState. enum TTreeCacheUnzip::EUnzipState. EnumeratorkUntouched ; kProgress ; kFinished . Definition at line 43 of file TTreeCacheUnzip.h. Constructor & Destructor Documentation. ◆ TTreeCacheUnzip() [1/3]. TTreeCacheUnzip::TTreeCacheUnzip ; (; const TTreeCacheUnzip & ; ). privatedelete . ◆ TTreeCacheUnzip() [2/3]. TTreeCacheUnzip::TTreeCacheUnzip ; (; ). Definition at line 159 of file TTreeCacheUnzip.cxx. ◆ TTreeCacheUnzip() [3/3]. TTreeCacheUnzip::TTreeCacheUnzip ; (; TTree * ; tree, . Int_t ; buffersize = 0 . ). Constructor. ; Definition at line 178 of file TTreeCacheUnzip.cxx. ◆ ~TTreeCacheUnzip(). TTreeCacheUnzip::~TTreeCacheUnzip ; (; ). override . Destructor. (in general called by the TFile destructor) ; Definition at line 235 of file TTreeCacheUnzip.cxx. Member Function Documentation. ◆ AddBranch() [1/2]. Int_t TTreeCacheUnzip::AddBranch ; (; const char * ; branch, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: . 0 branch added or already included; -1 on error . Reimplemented from TTreeCache.; Definition at line 260 of file TTreeCacheUnzip.cxx. ◆ AddBranch() [2/2]. Int_t TTreeCacheUnzip::AddBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: . 0 branch added or already included; -1 on error . Reimplemented from TTreeCache.; Definition at line 248 of file TTreeCacheUnzip.cxx. ◆ Class(). static TClass * TTreeCacheUnzip::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTreeCacheUnzip::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCacheUnzip::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ CreateTasks(). Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:27399,cache,cache,27399,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,2,['cache'],['cache']
Performance,"Up() constTROOTinline; fRootFolderTROOTprotected; fSecContextsTROOTprotected; fSelectPadTROOTprotected; fSocketsTROOTprotected; fSpecialsTROOTprotected; fSpinLockTDirectorymutableprotected; fStreamerInfoTROOTprotected; fStylesTROOTprotected; fTasksTROOTprotected; fTimerTROOTprotected; fTitleTNamedprotected; fTypesTROOTprotected; fUniqueIDTObjectprivate; fUUIDTDirectoryprotected; fUUIDsTROOTprotected; fVersionTROOTprotected; fVersionCodeTROOTprotected; fVersionDateTROOTprotected; fVersionIntTROOTprotected; fVersionTimeTROOTprotected; FwdDeclArgsToKeepCollection_t typedefTROOT; fWebDisplayTROOTprotected; Get(const char *namecycle)TDirectoryvirtual; Get(const char *namecycle)TDirectoryinline; GetApplication() constTROOTinline; GetBinDir()TROOTstatic; GetBufferSize() constTDirectoryinlinevirtual; GetBuiltDate() constTROOTinline; GetBuiltTime() constTROOTinline; GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE) constTROOT; GetClass(const std::type_info &typeinfo, Bool_t load=kTRUE, Bool_t silent=kFALSE) constTROOT; GetClipboard() constTROOTinline; GetColor(Int_t color) constTROOT; GetConfigFeatures() constTROOTinline; GetConfigOptions() constTROOTinline; GetCutClassName() constTROOTinline; GetDataDir()TROOTstatic; GetDefCanvasName() constTROOTinline; GetDirectory(const char *namecycle, Bool_t printError=false, const char *funcname=""GetDirectory"")TDirectoryvirtual; GetDirLevel()TROOTstatic; GetDocDir()TROOTstatic; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetEditHistograms() constTROOTinline; GetEditorMode() constTROOTinline; GetEtcDir()TROOTstatic; GetExtraInterpreterArgs()TROOTstatic; GetFile() const overrideTROOTinlinevirtual; GetFile(const char *name) constTROOT; GetForceStyle() constTROOTinline; GetFunction(const char *name) constTROOT; GetFunctionTemplate(const char *name)TROOT; GetGeometry(const char *name) constTROOT; GetGitBranch() constTROOTinline; GetGitCommit() constTROOTinline; GetGitDate()TROOT; GetGlobal(const char *n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT-members.html:6339,load,load,6339,doc/master/classTROOT-members.html,https://root.cern,https://root.cern/doc/master/classTROOT-members.html,1,['load'],['load']
Performance,"User-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataHist& data, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none()); RooChi2Var ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChi2Var.html:42856,cache,cache,42856,root/html534/RooChi2Var.html,https://root.cern,https://root.cern/root/html534/RooChi2Var.html,1,['cache'],['cache']
Performance,"VA::BinaryTree::Log() const. private:. Double_tSamplePurity(TMVA::DecisionTree::EventList eventSample). Data Members; public:. static TMVA::DecisionTree::EPruneMethodkCostComplexityPruning; static TMVA::DecisionTree::EPruneMethodkExpectedErrorPruning; static TMVA::DecisionTree::EPruneMethodkNoPruning. protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree. private:. TMVA::Types::EAnalysisTypefAnalysisTypekClassification(=0=false) or kRegression(=1=true); TMVA::DataSetInfo*fDataSetInfo; UInt_tfMaxDepthmax depth; Double_tfMinLinCorrForFisherthe minimum linear correlation between two variables demanded for use in fisher criterium in node splitting; Double_tfMinNodeSizemin fraction of training events in node; Double_tfMinSepGainmin number of separation gain to perform node splitting; Double_tfMinSizemin number of events in node; TRandom3*fMyTrandomrandom number generator for randomised trees; Int_tfNCutsnumber of grid point in variable cut scans; Int_tfNNodesBeforePruningremember this one (in case of pruning, it allows to monitor the before/after; Double_tfNodePurityLimitpurity limit to decide whether a node is signal; UInt_tfNvarsnumber of variables used to separate S and B; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreechoose at each node splitting a random set of variables; TMVA::RegressionVariance*fRegTypethe separation crition used in Regression; TMVA::SeparationBase*fSepTypethe separation crition; UInt_tfSigClassclass which is treated as signal when building the tree; Int_tfTreeIDjust an ID number given to the tree.. makes debugging easier as tree knows who he is.; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__DecisionTree.html:6960,perform,perform,6960,root/html602/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html602/TMVA__DecisionTree.html,2,['perform'],['perform']
Performance,"VA::DNN::TCpuBuffer< AFloat >::TCpuBuffer ; (; ). default . ◆ TCpuBuffer() [3/4]. template<typename AFloat > . TMVA::DNN::TCpuBuffer< AFloat >::TCpuBuffer ; (; const TCpuBuffer< AFloat > & ; ). default . ◆ TCpuBuffer() [4/4]. template<typename AFloat > . TMVA::DNN::TCpuBuffer< AFloat >::TCpuBuffer ; (; TCpuBuffer< AFloat > && ; ). default . Member Function Documentation. ◆ begin(). template<typename AFloat > . FakeIteratorBegin TMVA::DNN::TCpuBuffer< AFloat >::begin ; (; ). inline . Definition at line 80 of file CpuBuffer.h. ◆ CopyFrom(). template<typename AReal > . void TMVA::DNN::TCpuBuffer< AReal >::CopyFrom ; (; const TCpuBuffer< AFloat > & ; other). Copy data from another buffer. ; No real copying is performed, only the data pointers are swapped. ; Definition at line 57 of file CpuBuffer.cxx. ◆ CopyTo(). template<typename AReal > . void TMVA::DNN::TCpuBuffer< AReal >::CopyTo ; (; TCpuBuffer< AFloat > & ; other); const. Copy data to another buffer. ; No real copying is performed, only the data pointers are swapped. ; Definition at line 65 of file CpuBuffer.cxx. ◆ data(). template<typename AFloat > . AFloat * TMVA::DNN::TCpuBuffer< AFloat >::data ; (; ); const. inline . Definition at line 68 of file CpuBuffer.h. ◆ GetSize(). template<typename AFloat > . size_t TMVA::DNN::TCpuBuffer< AFloat >::GetSize ; (; ); const. inline . copy pointer from an external ; Definition at line 103 of file CpuBuffer.h. ◆ GetSubBuffer(). template<typename AReal > . TCpuBuffer< AReal > TMVA::DNN::TCpuBuffer< AReal >::GetSubBuffer ; (; size_t ; offset, . size_t ; start . ); const. Return sub-buffer of size start starting at element offset. ; Definition at line 47 of file CpuBuffer.cxx. ◆ GetUseCount(). template<typename AFloat > . size_t TMVA::DNN::TCpuBuffer< AFloat >::GetUseCount ; (; ); const. inline . Definition at line 105 of file CpuBuffer.h. ◆ operator AFloat *(). template<typename AFloat > . TMVA::DNN::TCpuBuffer< AFloat >::operator AFloat * ; (; ); const. inline . Definition at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCpuBuffer.html:3426,perform,performed,3426,doc/master/classTMVA_1_1DNN_1_1TCpuBuffer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCpuBuffer.html,1,['perform'],['performed']
Performance,VA::RuleFitParams::fNTLinCoeff. protected . GD path: linear coefficients. ; Definition at line 244 of file RuleFitParams.h. ◆ fNTNuval. Double_t TMVA::RuleFitParams::fNTNuval. protected . GD path: value of nu. ; Definition at line 240 of file RuleFitParams.h. ◆ fNTOffset. Double_t TMVA::RuleFitParams::fNTOffset. protected . GD path: model offset. ; Definition at line 242 of file RuleFitParams.h. ◆ fNTRisk. Double_t TMVA::RuleFitParams::fNTRisk. protected . GD path: risk. ; Definition at line 238 of file RuleFitParams.h. ◆ fPathIdx1. UInt_t TMVA::RuleFitParams::fPathIdx1. protected . first event index for path search ; Definition at line 197 of file RuleFitParams.h. ◆ fPathIdx2. UInt_t TMVA::RuleFitParams::fPathIdx2. protected . last event index for path search ; Definition at line 198 of file RuleFitParams.h. ◆ fPerfIdx1. UInt_t TMVA::RuleFitParams::fPerfIdx1. protected . first event index for performance evaluation ; Definition at line 199 of file RuleFitParams.h. ◆ fPerfIdx2. UInt_t TMVA::RuleFitParams::fPerfIdx2. protected . last event index for performance evaluation ; Definition at line 200 of file RuleFitParams.h. ◆ fRuleEnsemble. RuleEnsemble* TMVA::RuleFitParams::fRuleEnsemble. protected . rule ensemble ; Definition at line 189 of file RuleFitParams.h. ◆ fRuleFit. RuleFit* TMVA::RuleFitParams::fRuleFit. protected . rule fit ; Definition at line 188 of file RuleFitParams.h. ◆ fsigave. Double_t TMVA::RuleFitParams::fsigave. protected . Sigma of current signal score function F(sig) ; Definition at line 246 of file RuleFitParams.h. ◆ fsigrms. Double_t TMVA::RuleFitParams::fsigrms. protected . Rms of F(sig) ; Definition at line 247 of file RuleFitParams.h. Libraries for TMVA::RuleFitParams:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/RuleFitParams.h; tmva/tmva/src/RuleFitParams.cxx. TMVARuleFitParams. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:42 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:26505,perform,performance,26505,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['perform'],['performance']
Performance,"VAClassification_FDA_GA.weights.xml␛[0m; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_MLPBNN.weights.xml␛[0m; MLPBNN : Building Network. ; : Initializing weights; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_DNN_CPU.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_SVM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_BDT.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_RuleFit.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: Cuts for Classification performance; : ; Cuts : [dataset] : Evaluation of Cuts on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00226 sec ; Factory : Test method: CutsD for Classification performance; : ; CutsD : [dataset] : Evaluation of CutsD on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00756 sec ; Factory : Test method: Likelihood for Classification performance; : ; Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0108 sec ; Factory : Test method: LikelihoodPCA for Classification performance; : ; LikelihoodPCA : [dataset] : Evaluation of LikelihoodPCA on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0197 sec ; Factory : Test method: PDERS for Classification performance; : ; PDERS : [dataset] : Evaluation of PDERS on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.937 sec ; Factory : Test method: PDEFoam for Classification performance; : ; PDEFoam : [dataset] : Evaluation of PDEFoam on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.072 sec ; Factory : Test method: KNN for Classification per",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:65514,perform,performance,65514,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['performance']
Performance,VAClassification_RuleFit.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: Cuts for Classification performance; : ; Cuts : [dataset] : Evaluation of Cuts on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00226 sec ; Factory : Test method: CutsD for Classification performance; : ; CutsD : [dataset] : Evaluation of CutsD on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00756 sec ; Factory : Test method: Likelihood for Classification performance; : ; Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0108 sec ; Factory : Test method: LikelihoodPCA for Classification performance; : ; LikelihoodPCA : [dataset] : Evaluation of LikelihoodPCA on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0197 sec ; Factory : Test method: PDERS for Classification performance; : ; PDERS : [dataset] : Evaluation of PDERS on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.937 sec ; Factory : Test method: PDEFoam for Classification performance; : ; PDEFoam : [dataset] : Evaluation of PDEFoam on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.072 sec ; Factory : Test method: KNN for Classification performance; : ; KNN : [dataset] : Evaluation of KNN on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.2 sec ; Factory : Test method: LD for Classification performance; : ; LD : [dataset] : Evaluation of LD on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00474 sec ; : Dataset[dataset] : Evaluation of LD on testing sample; Factory : Test method: FDA_GA for Classification performance; : ; FDA_GA : [dataset] : Evaluation of FDA_GA on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00327 sec ; Factory : Test method: MLPBNN for Classificati,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:66151,perform,performance,66151,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['performance']
Performance,"VAMulticlass(methodList);; return 0;; }; ; DataLoader.h; mainint main()Definition Prototype.cxx:12; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; TFile.h; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; TMVAMultiClassGui.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TString.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTree.h; Tools.h; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddTreevoid AddTree(TTree *tree, const TString &className, Double_t weight=1.0, const TCut &cut="""", Types::ETreeType tt=Types::kMaxTreeType)Definition DataLoader.cxx:351; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:38906,cache,cacheDir,38906,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,2,['cache'],"['cache', 'cacheDir']"
Performance,"VAll contents are RRV; Bool_t_defShapeServer; Bool_t_defValueServer; TIterator*_iter! do not persist; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsProxy::_nset! Normalization set to be used for evaluation of RooAbsPdf contents; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; RooAbsArg*_owner; static char*RooArgSet::_poolBegin! Start of memory pool; static char*RooArgSet::_poolCur! Next free slot in memory pool; static char*RooArgSet::_poolEnd! End of memory pool; TNamed*RooAbsCollection::_structureTag! Structure tag; TNamed*RooAbsCollection::_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void* operator new(size_t bytes); Overload new operator must be implemented because it is overloaded; in the RooArgSet base class. Perform standard memory allocation; here instead of memory pool management performed in RooArgSet. void operator delete(void* ptr). RooSetProxy(const char* name, const char* desc, RooAbsArg* owner, Bool_t defValueServer = kTRUE, Bool_t defShapeServer = kFALSE); Construct proxy with given name and description, with given owner; The default value and shape dirty propagation of the set contents; to the set owner is controlled by flags defValueServer and defShapeServer. RooSetProxy(const char* name, RooAbsArg* owner, const RooSetProxy& other); Copy constructor. ~RooSetProxy(); Destructor. Bool_t add(const RooAbsArg& var, Bool_t valueServer, Bool_t shapeServer, Bool_t silent); Overloaded RooArgSet::add() method insert object into set; and registers object as server to owner with given value; and shape dirty flag propagation requests. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Overloaded RooArgSet::addOwned() method insert object into owning set; and registers object as server to owner with default value; and shape dirty flag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSetProxy.html:14627,perform,performed,14627,root/html602/RooSetProxy.html,https://root.cern,https://root.cern/root/html602/RooSetProxy.html,2,['perform'],['performed']
Performance,"VAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfBalanceDepthnumber of binary tree levels used for balancing tree; TMVA::kNN::EventVecfEvent! (untouched) events used for learning; TStringfKernel=""Gaus"",""Poln"" - kernel type for smoothing; TMVA::LDAfLDA! Experimental feature for local knn analysis; TMVA::kNN::ModulekNN*fModule! module where all work is done; Float_tfScaleFracfraction of events used to compute variable width; Float_tfSigmaFactscale factor for Gaussian sigma in Gaus. kernel; Double_tfSumOfWeightsBsum-of-weights for background training events; Double_tfSumOfWeightsSsum-of-weights for signal training events; Int_tfTreeOptDepthnumber of binary tree levels used for optimization; Bool_tfTrimset equal number of signal and background events; Bool_tfUseKerneluse polynomial kernel weight function; Bool_tfUseLDAuse local linear discriminat analysis to compute MVA; Bool_tfUseWeightuse weights to count kNN; Int_tfnkNNnumber of k-nearest neighbors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodKNN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""KNN"", TDirectory* theTargetDir = __null); standard constructor. MethodKNN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. ~MethodKNN(); destructor. void DeclareOptions(); MethodKNN options. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); process the options specified by the user. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodKNN.html:18212,optimiz,optimization,18212,root/html602/TMVA__MethodKNN.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodKNN.html,2,['optimiz'],['optimization']
Performance,"VNodeGraphviz node; Double_tfHNode height; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TStringTNamed::fNameobject identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; Double_tfWNode width; Double_tfXNode's center X coordinate; Double_tfYNode's center Y coordinate. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraphNode(); Graph node default constructor. TGraphNode(const char* name, const char* title = """"); Graph node normal constructor. ~TGraphNode(); Graph Node default destructor. void CreateGVNode(GVizAgraph_t* gv); Create the GraphViz node into the GraphViz data structure gv. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a node. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. void Layout(); Layout this node in the GraphViz space. This is done after gvLayout; has been performed. void Paint(Option_t* option = """"); Paint this node with its current attributes. void SavePrimitive(ostream& , Option_t* ); Save primitive as a C++ statement(s) on output stream out. void SaveAttributes(ostream& ); Save attributes as a C++ statement(s) on output stream out; called by TGraphStruct::SavePrimitive. void Streamer(TBuffer& ). TGraphNode(). void SetGVNode(GVizAgnode_t* gvn); {fGVNode = gvn;}. void SetTextAngle(Float_t ); {;}. GVizAgnode_t * GetGVNode(); {return fGVNode;}. » Author: Olivier Couet 13/07/09 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphNode.html:9098,perform,performed,9098,root/html534/TGraphNode.html,https://root.cern,https://root.cern/root/html534/TGraphNode.html,1,['perform'],['performed']
Performance,"VNodeGraphviz node; Double_tfHNode height; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TStringTNamed::fNameobject identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; Double_tfWNode width; Double_tfXNode's center X coordinate; Double_tfYNode's center Y coordinate. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraphNode(); Graph node default constructor. TGraphNode(const char* name, const char* title = """"); Graph node normal constructor. ~TGraphNode(); Graph Node default destructor. void CreateGVNode(GVizAgraph_t* gv); Create the GraphViz node into the GraphViz data structure gv. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a node. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. void Layout(); Layout this node in the GraphViz space. This is done after gvLayout; has been performed. void Paint(Option_t* option = """"); Paint this node with its current attributes. void SavePrimitive(ostream& , Option_t* ); Save primitive as a C++ statement(s) on output stream out. void SaveAttributes(ostream& ); Save attributes as a C++ statement(s) on output stream out; called by TGraphStruct::SavePrimitive. void Streamer(TBuffer& ). TGraphNode(). void SetGVNode(GVizAgnode_t* gvn); {fGVNode = gvn;}. void SetTextAngle(Float_t ); {;}. GVizAgnode_t * GetGVNode(); {return fGVNode;}. » Author: Olivier Couet 13/07/09 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-02 16:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGraphNode.html:9559,perform,performed,9559,root/html604/TGraphNode.html,https://root.cern,https://root.cern/root/html604/TGraphNode.html,1,['perform'],['performed']
Performance,"VNodeGraphviz node; Double_tfHNode height; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TStringTNamed::fNameobject identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; Double_tfWNode width; Double_tfXNode's center X coordinate; Double_tfYNode's center Y coordinate. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraphNode(); Graph node default constructor. TGraphNode(const char* name, const char* title = """"); Graph node normal constructor. ~TGraphNode(); Graph Node default destructor. void CreateGVNode(GVizAgraph_t* gv); Create the GraphViz node into the GraphViz data structure gv. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a node. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. void Layout(); Layout this node in the GraphViz space. This is done after gvLayout; has been performed. void Paint(Option_t* option = """"); Paint this node with its current attributes. void SavePrimitive(ostream& , Option_t* ); Save primitive as a C++ statement(s) on output stream out. void SaveAttributes(ostream& ); Save attributes as a C++ statement(s) on output stream out; called by TGraphStruct::SavePrimitive. void Streamer(TBuffer& ). TGraphNode(). void SetGVNode(GVizAgnode_t* gvn); {fGVNode = gvn;}. void SetTextAngle(Float_t ); {;}. GVizAgnode_t * GetGVNode(); {return fGVNode;}. » Author: Olivier Couet 13/07/09 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-30 15:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphNode.html:9559,perform,performed,9559,root/html602/TGraphNode.html,https://root.cern,https://root.cern/root/html602/TGraphNode.html,1,['perform'],['performed']
Performance,"Value! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of input fractions; TIterator*_setIter1! Iterator over set of input fractions; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFracRemainder.html:31992,cache,cache,31992,root/html526/RooFracRemainder.html,https://root.cern,https://root.cern/root/html526/RooFracRemainder.html,2,['cache'],['cache']
Performance,"Value& x, const char* rangeName); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRangeBoolean.html:24070,cache,cache,24070,root/html602/RooRangeBoolean.html,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html,2,['cache'],['cache']
Performance,"Value(); // trigger another event loop; std::cout << df.GetNRuns() << std::endl; // prints ""2"". Definition at line 402 of file RInterfaceBase.cxx. ◆ GetNSlots(). unsigned int ROOT::RDF::RInterfaceBase::GetNSlots ; (; ); const. Gets the number of data processing slots. ; ReturnsThe number of data processing slots used by this RDataFrame instance; This method returns the number of data processing slots used by this RDataFrame instance. This number is influenced by the global switch ROOT::EnableImplicitMT().; Example usage: ROOT::EnableImplicitMT(6); ROOT::RDataFrame df(1);; std::cout << df.GetNSlots() << std::endl; // prints ""6""; ROOT::RDF::RInterfaceBase::GetNSlotsunsigned int GetNSlots() constGets the number of data processing slots.Definition RInterfaceBase.cxx:383; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539. Definition at line 383 of file RInterfaceBase.cxx. ◆ GetValidatedColumnNames(). ColumnNames_t ROOT::RDF::RInterfaceBase::GetValidatedColumnNames ; (; const unsigned int ; nColumns, . const ColumnNames_t & ; columns . ). inlineprotected . Definition at line 130 of file RInterfaceBase.hxx. ◆ GetVariations(). ROOT::RDF::RVariationsDescription ROOT::RDF::RInterfaceBase::GetVariations ; (; ); const. Return a descriptor for the systematic variations registered in this branch of the computation graph. ; This is not an action nor a transformation, just a simple utility to inspect the systematic variations that have been registered with Vary() up to this node. When called on the root node, it returns an empty descriptor. Example usage:; auto variations = d.GetVariations();; variations.Print();. Definition at line 334 of file RInterfaceBase.cxx. ◆ HasColumn(). bool ROOT::RDF::RInterf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterfaceBase.html:12199,multi-thread,multi-threading,12199,doc/master/classROOT_1_1RDF_1_1RInterfaceBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterfaceBase.html,1,['multi-thread'],['multi-threading']
Performance,"ValueChange; };; enum OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>_boolAttribBoolean attributes; set<std::string>_boolAttribTransient! Transient boolean attributes (not copied in ctor); deque<RooAbsCache*>_cacheListlist of caches; RooRefCountList_clientListlist of client objects; RooRefCountList_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountList_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*_clientShapeIter! Iterator over _clientListShape ; TIterator*_clientValueIter! Iterator over _clientListValue ; Bool_t_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*_eocachePointer to global cache manager for any expensive components created by this object; Bool_t_fastAllow fast access mode in getVal() and proxies; static Bool_t_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; static Int_tRooPrintable::_nameLength; TNamed*_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperMode_operModeDirty state propagation mode; RooArgSet*_ownedComponents! Set of owned component; Bool_t_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArray_proxyListlist of proxies; RooRefCountList_serverListlist of server objects; Bool_t_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>_stringAttribString attributes; Bool_t_valueDirtyFlag set if value needs recalculating b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsArg.html:16429,cache,caches,16429,root/html532/RooAbsArg.html,https://root.cern,https://root.cern/root/html532/RooAbsArg.html,2,['cache'],"['cache', 'caches']"
Performance,"ValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; RooRealVar&var() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvPdf.html:34162,cache,cache,34162,root/html534/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html534/RooNumConvPdf.html,1,['cache'],['cache']
Performance,"Var& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooNonCPEigenDecay&operator=(const RooNonCPEigenDecay&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNonCPEigenDecay.html:24091,optimiz,optimizeCacheMode,24091,root/html602/RooNonCPEigenDecay.html,https://root.cern,https://root.cern/root/html602/RooNonCPEigenDecay.html,4,['optimiz'],['optimizeCacheMode']
Performance,"VariablePlotting()).fTimesRMS = 8.0;; // (TMVA::gConfig().GetIONames()).fWeightFileDir = ""myWeightDirectory"";; ; // Define the input variables that shall be used for the MVA training; // note that you may also use variable expressions, such as: ""3*var1/var2*abs(var3)""; // [all types of expressions that can also be parsed by TTree::Draw( ""expression"" )]; dataloader->AddVariable( ""var1"", ""Variable 1"", ""units"", 'F' );; dataloader->AddVariable( ""var2"", ""Variable 2"", ""units"", 'F' );; ; // You can add so-called ""Spectator variables"", which are not used in the MVA training,; // but will appear in the final ""TestTree"" produced by TMVA. This TestTree will contain the; // input variables, the response values of all trained MVAs, and the spectator variables; dataloader->AddSpectator( ""spec1:=var1*2"", ""Spectator 1"", ""units"", 'F' );; dataloader->AddSpectator( ""spec2:=var1*3"", ""Spectator 2"", ""units"", 'F' );; ; // Add the variable carrying the regression target; dataloader->AddTarget( ""fvalue"" );; ; // It is also possible to declare additional targets for multi-dimensional regression, ie:; // factory->AddTarget( ""fvalue2"" );; // BUT: this is currently ONLY implemented for MLP; ; // Read training and test data (see TMVAClassification for reading ASCII files); // load the signal and background event samples from ROOT trees; TFile *input(0);; TString fname = ""./tmva_reg_example.root"";; if (!gSystem->AccessPathName( fname )) {; input = TFile::Open( fname ); // check if file in local directory exists; }; else {; TFile::SetCacheFileDir(""."");; input = TFile::Open(""http://root.cern/files/tmva_reg_example.root"", ""CACHEREAD""); // if not: download from ROOT server; }; if (!input) {; std::cout << ""ERROR: could not open data file"" << std::endl;; exit(1);; }; std::cout << ""--- TMVARegression : Using input file: "" << input->GetName() << std::endl;; ; // Register the regression tree; ; TTree *regTree = (TTree*)input->Get(""TreeR"");; ; // global event weights per tree (see below for setting event-w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:139326,load,load,139326,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['load'],['load']
Performance,"VariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. unsigned int NDim() const; number of dimensions. { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem). unsigned int NPar() const; total number of parameter defined. { return fValues.size(); }. const ROOT::Math::IMultiGenFunction * ObjFunction() const; return pointer to used objective function. { return fObjFunc; }. const ROOT::Math::IMultiGradFunction * GradObjFunction() const; return pointer to used gradient object function (NULL if gradient is not supported). void PrintResult() const; print result of minimization. const double * StepSizes() const; accessor methods. { return &fSteps.front(); }. bool CheckDimension() const. bool CheckObjFunction() const. MinimTransformFunction * CreateTransformation(vector<double>& startValues, const ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:8960,perform,perform,8960,root/html534/ROOT__Math__BasicMinimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html,3,['perform'],['perform']
Performance,"Vars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tisValidReal(Double_t value, Bool_t printError) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenericPdf.html:36148,optimiz,optimizeDirtyHook,36148,root/html602/RooGenericPdf.html,https://root.cern,https://root.cern/root/html602/RooGenericPdf.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"Vector to the Next Crossed Surface at Crossing Point; Supposing we have found out that a particle will cross a boundary during the next step, it is sometimes useful to compute the normal to the crossed surface. The modeller uses the following convention: we define as normal (\(\vec{n}\)) the unit vector perpendicular to a surface in the next crossing point, having the orientation such that: \(\vec{n}.\vec{d}>0\). Here \(\vec{d}\) represents the current direction. The next crossing point represents the point where a ray shot from the current point along the current direction crosses the surface.; Double_t *TGeoManager::FindNormal(Bool_t forward=kTRUE);; The method above computes the normal to the next crossed surface in forward or backward direction (i.e. the current one), assuming the state corresponding to a current arbitrary point is initialized. An example of usage of normal computation is ray tracing.; The two most important features of the geometrical modeller concerning tracking are scalability and performance as function of the total number of physical nodes. The first refers to the possibility to make use of the available memory resources and at the same time be able to resolve any geometrical query, while the second defines the capability of the modeller to respond quickly even for huge geometries. These parameters can become critical when simulating big experiments like those at LHC.; 18.5.8 Creating and Visualizing Tracks; In case the modeller is interfaced with a tracking engine, one might consider quite useful being able to store and visualize at least a part of the tracks in the context of the geometry. The base class TVirtualGeoTrack provides this functionality. It currently has one implementation inside the drawing package (TGeoTrack class). A track can be defined like:; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; Where: id is user-defined id of the track, pdg - pdg code, parent - a pointer to parent track,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:992406,scalab,scalability,992406,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['perform', 'scalab']","['performance', 'scalability']"
Performance,"Vector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:24698,perform,perform,24698,root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,1,['perform'],['perform']
Performance,"Verbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooArgSet_allVarsPdfAll pdf variables; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; Double_t*_fracThresh[_numPdf] Fraction threshold array; vector<int>_gcIndexIndex value corresponding to component; vector<RooAbsGenContext*>_gcListList of component generator contexts; RooDataSet*RooAbsGenContext::_genData! Data being generated; Bool_t_haveIdxProtoFlag set if generation of index is requested; RooAbsCategoryLValue*_idxCatClone of index category; TString_idxCatNameName of index category; RooArgSet*_idxCatSetOwner of index category components; Bool_tRooAbsGenContext::_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; Int_t_numPdfNumber of generated PDFs; const RooSimultaneous*_pdfOriginal PDF; RooDataSet*_protoData! Prototype dataset; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*_prototypePrototype data set; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; TIterator*_proxyIterIterator over pdf proxies; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooSimGenContext(const RooSimultaneous& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor of specialized generator context for RooSimultaneous p.d.f.s. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimGenContext.html:9515,load,load,9515,root/html602/RooSimGenContext.html,https://root.cern,https://root.cern/root/html602/RooSimGenContext.html,2,['load'],['load']
Performance,"Version<6) || !previous || /* In version of TStreamerInfo less than 6, the Double32_t were merged even if their annotation (aka factor) were different */; 3100 ((element->GetFactor() == previous->GetFactor()); 3101 && (element->GetXmin() == previous->GetXmin()); 3102 && (element->GetXmax() == previous->GetXmax()); 3103 ); 3104 ); 3105 && (element->TestBit(TStreamerElement::kCache) == previous->TestBit(TStreamerElement::kCache)); 3106 && (element->TestBit(TStreamerElement::kWrite) == previous->TestBit(TStreamerElement::kWrite)); 3107 // kWholeObject and kDoNotDelete do not apply to numerical elements.; 3108 ); 3109 {; 3110 if (!previousOptimized) {; 3111 // The element was not yet optimized we first need to copy it into; 3112 // the set of original copies.; 3113 fComp[fNslots - (++optiOut) ] = fComp[keep]; // Copy the optimized out elements.; 3114 fCompFull[fNfulldata-1] = &(fComp[fNslots - optiOut]); // Reset the pointer in the full list.; 3115 }; 3116 fComp[fNslots - (++optiOut) ] = fComp[fNdata]; // Copy the optimized out elements.; 3117 fCompFull[fNfulldata] = &(fComp[fNslots - optiOut]);; 3118 ; 3119 R__ASSERT( keep < (fNslots - optiOut) );; 3120 ; 3121 if (fComp[keep].fLength == 0) {; 3122 fComp[keep].fLength++;; 3123 }; 3124 fComp[keep].fLength++;; 3125 fComp[keep].fType = element->GetType() + kRegrouped;; 3126 isOptimized = kTRUE;; 3127 previousOptimized = kTRUE;; 3128 } else if (element->GetType() < 0) {; 3129 ; 3130 // -- Deal with an ignored TObject base class.; 3131 // Note: The only allowed negative value here is -1,; 3132 // and signifies that Build() has found a TObject; 3133 // base class and TClass::IgnoreTObjectStreamer() was; 3134 // called. In this case the compiled version of the; 3135 // elements omits the TObject base class element,; 3136 // which has to be compensated for by TTree::Bronch(); 3137 // when it is making branches for a split object.; 3138 fComp[fNslots - (++optiOut) ] = fComp[fNdata]; // Copy the 'ignored' element.; 3139 fCompFull[",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:136504,optimiz,optimized,136504,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"VolumeMulti will be created. Whenever positioned inside a mother volume, this will create a normal TGeoVolume object having as shape a box with dz fitting the corresponding dzof the mother shape. Generally, this type of parameterization is used when positioning volumes in containers having a matching shape, but it works also for most reasonable combinations.; 18.4 Geometry Creation; A given geometry can be built in various ways, but one has to follow some mandatory steps. Even if we might use some terms that will be explained later, here are few general rules:. Volumes need media and shapes in order to be created.; Both containers and contained volumes must be created before linking them together, and the relative transformation matrix must be provided.; Any volume have to be positioned somewhere otherwise it will not be considered as part of the geometry.; Visibility or tracking properties of volumes can be provided both at build time or after geometry is closed, but global visualization settings (see section: “The Drawing Package”) should not be provided at build time, otherwise the drawing package will be loaded. There is also a list of specific rules:. Positioned volumes should not extrude their container or intersect with others within this unless it is specified (see section: Overlapping Volumes).; The top volume (containing all geometry trees) must be specified before closing the geometry and must not be positioned - it represents the global reference frame.; After building the full geometry tree, the geometry must be closed (see the method TGeoManager::CloseGeometry()). Voxelization can be redone per volume after this process. The list is much bigger and we will describe in more detail the geometry creation procedure in the following sections. Provided that geometry was successfully built and closed, the TGeoManager class will register itself to ROOT and the logical/physical structures will become immediately browsable.; 18.4.1 The Volume Hierarchy; The basic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:928713,load,loaded,928713,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance,"WebWindow.hxx. ◆ fMgr. std::shared_ptr<RWebWindowsManager> ROOT::RWebWindow::fMgr. private . ! display manager ; Definition at line 136 of file RWebWindow.hxx. ◆ fNativeOnlyConn. bool ROOT::RWebWindow::fNativeOnlyConn {false}. private . ! only native connection are allowed, created by Show() method ; Definition at line 154 of file RWebWindow.hxx. ◆ fOperationTmout. float ROOT::RWebWindow::fOperationTmout {50.}. private . ! timeout in seconds to perform synchronous operation, default 50s ; Definition at line 168 of file RWebWindow.hxx. ◆ fPanelName. std::string ROOT::RWebWindow::fPanelName. private . ! panel name which should be shown in the window ; Definition at line 140 of file RWebWindow.hxx. ◆ fPendingConn. ConnectionsList_t ROOT::RWebWindow::fPendingConn. private . ! list of pending connection with pre-assigned keys ; Definition at line 149 of file RWebWindow.hxx. ◆ fProcessMT. bool ROOT::RWebWindow::fProcessMT {false}. private . ! if window event processing performed in dedicated thread ; Definition at line 144 of file RWebWindow.hxx. ◆ fProtocol. std::string ROOT::RWebWindow::fProtocol. private . ! protocol ; Definition at line 174 of file RWebWindow.hxx. ◆ fProtocolCnt. int ROOT::RWebWindow::fProtocolCnt {-1}. private . ! counter for protocol recording ; Definition at line 171 of file RWebWindow.hxx. ◆ fProtocolConnId. unsigned ROOT::RWebWindow::fProtocolConnId {0}. private . ! connection id, which is used for writing protocol ; Definition at line 172 of file RWebWindow.hxx. ◆ fProtocolFileName. std::string ROOT::RWebWindow::fProtocolFileName. private . ! local file where communication protocol will be written ; Definition at line 170 of file RWebWindow.hxx. ◆ fProtocolPrefix. std::string ROOT::RWebWindow::fProtocolPrefix. private . ! prefix for created files names ; Definition at line 173 of file RWebWindow.hxx. ◆ fRequireAuthKey. bool ROOT::RWebWindow::fRequireAuthKey {true}. private . ! defines if authentication key always required when connect to the wid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:57732,perform,performed,57732,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['perform'],['performed']
Performance,"WebWindow.hxx. ◆ fMgr. std::shared_ptr<RWebWindowsManager> ROOT::RWebWindow::fMgr. private . ! display manager ; Definition at line 139 of file RWebWindow.hxx. ◆ fNativeOnlyConn. bool ROOT::RWebWindow::fNativeOnlyConn {false}. private . ! only native connection are allowed, created by Show() method ; Definition at line 157 of file RWebWindow.hxx. ◆ fOperationTmout. float ROOT::RWebWindow::fOperationTmout {50.}. private . ! timeout in seconds to perform synchronous operation, default 50s ; Definition at line 171 of file RWebWindow.hxx. ◆ fPanelName. std::string ROOT::RWebWindow::fPanelName. private . ! panel name which should be shown in the window ; Definition at line 143 of file RWebWindow.hxx. ◆ fPendingConn. ConnectionsList_t ROOT::RWebWindow::fPendingConn. private . ! list of pending connection with pre-assigned keys ; Definition at line 152 of file RWebWindow.hxx. ◆ fProcessMT. bool ROOT::RWebWindow::fProcessMT {false}. private . ! if window event processing performed in dedicated thread ; Definition at line 147 of file RWebWindow.hxx. ◆ fProtocol. std::string ROOT::RWebWindow::fProtocol. private . ! protocol ; Definition at line 177 of file RWebWindow.hxx. ◆ fProtocolCnt. int ROOT::RWebWindow::fProtocolCnt {-1}. private . ! counter for protocol recording ; Definition at line 174 of file RWebWindow.hxx. ◆ fProtocolConnId. unsigned ROOT::RWebWindow::fProtocolConnId {0}. private . ! connection id, which is used for writing protocol ; Definition at line 175 of file RWebWindow.hxx. ◆ fProtocolFileName. std::string ROOT::RWebWindow::fProtocolFileName. private . ! local file where communication protocol will be written ; Definition at line 173 of file RWebWindow.hxx. ◆ fProtocolPrefix. std::string ROOT::RWebWindow::fProtocolPrefix. private . ! prefix for created files names ; Definition at line 176 of file RWebWindow.hxx. ◆ fRequireAuthKey. bool ROOT::RWebWindow::fRequireAuthKey {true}. private . ! defines if authentication key always required when connect to the wid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:56616,perform,performed,56616,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['perform'],['performed']
Performance,"WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM:CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|1|300"" [The Layout of the input]; : Layout: ""DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Model: ""sequential""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:10188,perform,perform,10188,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['perform'],['perform']
Performance,"WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM:CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|1|300"" [The Layout of the input]; : Layout: ""DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Running with nthrea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:5652,perform,perform,5652,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['perform'],['perform']
Performance,"When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. By default this is 75% of the; read cache size. But specific TFile implementations may need to change it. EAsyncOpenStatus GetAsyncOpenStatus(); { return fAsyncOpenStatus; }. Long64_t DirCreateEntry(TDirectory* ); Interface for text-based TDirectory I/O. { return 0; }. Int_t DirReadKeys(TDirectory* ); { return 0; }. void DirWriteKeys(TDirectory* ); {}. void DirWriteHeader(TDirectory* ); {}. void operator=(const TFile& ). void Copy(TObject& ) const; { MayNotUse(""Copy(TObject &)""); }. TArchiveFile * GetArchive() const; { return fArchive; }. TArrayC * GetClassIndex() const; { return fClassIndex; }. Int_t GetCompressionLevel() const; { return fCompress; }. Long64_t GetEND() const; { return fEND; }. Int_t GetFd() const; { return fD; }. const TUrl * GetEndpointUrl() const; { return &fUrl; }. TObjArray * GetListOfProcessIDs() const; {return fProcessIDs;}. TList * Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:51454,load,loading,51454,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,2,"['cache', 'load']","['cache', 'loading']"
Performance,"When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. By default this is 75% of the; read cache size. But specific TFile implementations may need to change it. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. EAsyncOpenStatus GetAsyncOpenStatus(); { return fAsyncOpenStatus; }. Long64_t DirCreateEntry(TDirectory* ); Interface for text-based TDirectory I/O. { return 0; }. Int_t DirReadKeys(TDirectory* ); { return 0; }. void DirWriteKeys(TDirectory* ); {}. void DirWriteHeader(TDirectory* ); {}. void operator=(const TFile& ). void Copy(TObject& ) const; { MayNotUse(""Copy(TObject &)""); }. TArchiveFile * GetArchive() const; { return fArchive; }. TArrayC * GetClassIndex() const; { return fClassIndex; }. Long64_t GetEND() const; { return fEND; }. Int_t GetFd() const; { return fD; }. const TUrl * GetEndpointUrl() const; { return &fUrl; }. TObjArray * GetListO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFile.html:52884,load,loading,52884,root/html530/TFile.html,https://root.cern,https://root.cern/root/html530/TFile.html,2,"['cache', 'load']","['cache', 'loading']"
Performance,"Win32VirtualXProxy::InitWindow ; (; ULongptr_t ; window). overridevirtual . Creates a new window and return window number. ; Returns -1 if window initialization fails. ; Reimplemented from TVirtualX. ◆ InternAtom(). Atom_t TGWin32VirtualXProxy::InternAtom ; (; const char * ; atom_name, . Bool_t ; only_if_exist . ). overridevirtual . Returns the atom identifier associated with the specified ""atom_name"" string. ; If ""only_if_exists"" is False, the atom is created if it does not exist. If the atom name is not in the Host Portable Character Encoding, the result is implementation dependent. Uppercase and lowercase matter; the strings ""thing"", ""Thing"", and ""thinG"" all designate different atoms. ; Reimplemented from TVirtualX. ◆ IntersectRegion(). void TGWin32VirtualXProxy::IntersectRegion ; (; Region_t ; rega, . Region_t ; regb, . Region_t ; result . ). overridevirtual . Computes the intersection of two regions. ; Parameters. [in]rega,regbspecify the two regions with which you want to perform the computation ; [in]resultreturns the result of the computation . Reimplemented from TVirtualX. ◆ IsCmdThread(). Bool_t TGWin32VirtualXProxy::IsCmdThread ; (; ); const. overridevirtual . Return kTRUE if we are inside cmd/server thread. ; Reimplemented from TVirtualX.; Definition at line 328 of file TGWin32VirtualXProxy.cxx. ◆ IsDNDAware(). Bool_t TGWin32VirtualXProxy::IsDNDAware ; (; Window_t ; win, . Atom_t * ; typelist . ). overridevirtual . Checks if the Window is DND aware, and knows any of the DND formats passed in argument. ; Reimplemented from TVirtualX. ◆ IsTransparent(). Bool_t TGWin32VirtualXProxy::IsTransparent ; (; ); const. overridevirtual . Reimplemented from TAttFill. ◆ KeysymToKeycode(). Int_t TGWin32VirtualXProxy::KeysymToKeycode ; (; UInt_t ; keysym). overridevirtual . Converts the ""keysym"" to the appropriate keycode. ; For example, keysym is a letter and keycode is the matching keyboard key (which is dependent on the current keyboard mapping). If the specified ""ke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:91411,perform,perform,91411,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,1,['perform'],['perform']
Performance,"Window ; (; std::shared_ptr< RWebWindow > ; window, . unsigned ; connid, . int ; channel . ). private . Add embed window. ; Definition at line 1846 of file RWebWindow.cxx. ◆ AddMasterConnection(). void RWebWindow::AddMasterConnection ; (; std::shared_ptr< RWebWindow > ; window, . unsigned ; connid, . int ; channel . ). private . Add new master connection If there are many connections - only same master is allowed. ; Definition at line 310 of file RWebWindow.cxx. ◆ AssignThreadId(). void RWebWindow::AssignThreadId ; (; ). Assign thread id which has to be used for callbacks WARNING!!! only for expert use Automatically done at the moment when any callback function is invoked Can be invoked once again if window Run method will be invoked from other thread Normally should be invoked before Show() method is called. ; Definition at line 1645 of file RWebWindow.cxx. ◆ CanSend(). bool RWebWindow::CanSend ; (; unsigned ; connid, . bool ; direct = true . ); const. Returns true if sending via specified connection can be performed. ; Parameters. connidconnection id, when 0 - all existing connections are checked ; directwhen true, checks if direct sending (without queuing) is possible . Definition at line 1484 of file RWebWindow.cxx. ◆ CheckDataToSend() [1/2]. void RWebWindow::CheckDataToSend ; (; bool ; only_once = false). private . Checks if new data can be send (internal use only) If necessary, provide credits to the client. ; Parameters. only_onceif true, data sending performed once or until there is no data to send . Definition at line 1216 of file RWebWindow.cxx. ◆ CheckDataToSend() [2/2]. bool RWebWindow::CheckDataToSend ; (; std::shared_ptr< WebConn > & ; conn). private . Checks if one should send data for specified connection Returns true when send operation was performed. ; Definition at line 1158 of file RWebWindow.cxx. ◆ CheckInactiveConnections(). void RWebWindow::CheckInactiveConnections ; (; ). private . Check if there are connection which are inactive for longer ti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:25338,perform,performed,25338,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['perform'],['performed']
Performance,"Window ; (; std::shared_ptr< RWebWindow > ; window, . unsigned ; connid, . int ; channel . ). private . Add embed window. ; Definition at line 1888 of file RWebWindow.cxx. ◆ AddMasterConnection(). void RWebWindow::AddMasterConnection ; (; std::shared_ptr< RWebWindow > ; window, . unsigned ; connid, . int ; channel . ). private . Add new master connection If there are many connections - only same master is allowed. ; Definition at line 311 of file RWebWindow.cxx. ◆ AssignThreadId(). void RWebWindow::AssignThreadId ; (; ). Assign thread id which has to be used for callbacks WARNING!!! only for expert use Automatically done at the moment when any callback function is invoked Can be invoked once again if window Run method will be invoked from other thread Normally should be invoked before Show() method is called. ; Definition at line 1687 of file RWebWindow.cxx. ◆ CanSend(). bool RWebWindow::CanSend ; (; unsigned ; connid, . bool ; direct = true . ); const. Returns true if sending via specified connection can be performed. ; Parameters. connidconnection id, when 0 - all existing connections are checked ; directwhen true, checks if direct sending (without queuing) is possible . Definition at line 1526 of file RWebWindow.cxx. ◆ CheckDataToSend() [1/2]. void RWebWindow::CheckDataToSend ; (; bool ; only_once = false). private . Checks if new data can be send (internal use only) If necessary, provide credits to the client. ; Parameters. only_onceif true, data sending performed once or until there is no data to send . Definition at line 1249 of file RWebWindow.cxx. ◆ CheckDataToSend() [2/2]. bool RWebWindow::CheckDataToSend ; (; std::shared_ptr< WebConn > & ; conn). private . Checks if one should send data for specified connection Returns true when send operation was performed. ; Definition at line 1191 of file RWebWindow.cxx. ◆ CheckInactiveConnections(). void RWebWindow::CheckInactiveConnections ; (; ). private . Check if there are connection which are inactive for longer ti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:24941,perform,performed,24941,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['perform'],['performed']
Performance,"WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TRandom2.h; WrappedMultiTF1.h; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitResult::Printvoid Print(std::ostream &os, bool covmat=false) constprint the result and optionally covariance matrix and correlationsDefinition FitResult.cxx:389; ROOT::Fit::FitResult::Probdouble Prob() constp value of the fit (chi2 probability)Definition FitResult.cxx:320; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::Resultconst FitResult & Result() constget fit resultDefinition Fitter.h:394; ROOT::Fit::Fitter::Fitbool Fit(const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)fit a data set using any generic model function If data set is binned a least square fit is performed...Definition Fitter.h:144; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Math::WrappedMultiTF1TemplClass to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions...Definition WrappedMultiTF1.h:48; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::SetFitResultvirtual void SetFitResult(const ROOT::Fit::FitResult &result, const Int_t *indpar=nullptr)Set the result from the fit parameter values, errors, chi2, etc... Optionally a pointer to a vector (...Definition TF1.cxx:3355; TF3A 3-Dim function with parameters.Definition TF3.h:28; TRandom2Random number generator class based on the maximally quidistributed combined Tau",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/exampleFit3D_8C.html:3921,perform,performed,3921,doc/master/exampleFit3D_8C.html,https://root.cern,https://root.cern/doc/master/exampleFit3D_8C.html,1,['perform'],['performed']
Performance,"WindowSlot ;  CTEveWindowTabEncapsulates TGTab into an eve-window ;  CTExecTExec is a utility class that can be used to execute a C++ command when some event happens in a pad ;  ►CTExMapThis class stores a (key,value) pair using an external hash ;  CAssoc_t;  CTExMapIter;  ►CTF11-Dim function class ;  CTF1FunctionPointer;  CTF1FunctionPointerImpl;  CTF12A projection of a TF2 along X or Y ;  CTF1ConvolutionClass wrapping convolution of two functions ;  CTF1Editor;  CTF1NormSumClass adding two functions: c1*f1+c2*f2 ;  CTF1ParametersTF1 Parameters class ;  CTF2A 2-Dim function with parameters ;  CTF2GLGL renderer for TF2 ;  CTF3A 3-Dim function with parameters ;  CTFastCgi;  CTFeldmanCousinsClass to calculate the CL upper limit using the Feldman-Cousins method as described in PRD V57 #7, p3873-3889 ;  CTFFTComplex;  CTFFTComplexReal;  CTFFTReal;  CTFFTRealComplex;  CTFileA ROOT file is a suite of consecutive data records (TKey instances) with a well defined format ;  CTFileCacheReadA cache when reading files over the network ;  CTFileCacheWriteA cache when writing files over the network ;  CTFileCollectionClass that contains a list of TFileInfo's and accumulated meta data information about its entries ;  CTFileDrawMapThis class is automatically called by TFile::DrawMap ;  CTFileHandler;  CTFileInfoClass describing a generic file including meta information ;  CTFileInfoMeta;  CTFileIter;  CTFileMergeInfo;  CTFileMergerThis class provides file copy and merging services ;  CTFileOpenHandleClass holding info about the file being opened ;  CTFilePrefetchThe prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a block of tree entries ;  CTFileSet;  CTFileStager;  ►CTFitEditor;  CFuncParamData_tTF1Convolution object ;  CTFitParametersDialog;  CTFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O ;  CTFitResultPtrProvides an indirection to the TFitResult class and with a semantics iden",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:143721,cache,cache,143721,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['cache'],['cache']
Performance,"WindowTabEncapsulates TGTab into an eve-window ;  CTExecTExec is a utility class that can be used to execute a C++ command when some event happens in a pad ;  ►CTExMapThis class stores a (key,value) pair using an external hash ;  CAssoc_t;  CTExMapIter;  ►CTF11-Dim function class ;  CTF1FunctorPointer;  CTF1FunctorPointerImpl;  CTF12A projection of a TF2 along X or Y ;  CTF1AbsComposition;  CTF1ConvolutionClass wrapping convolution of two functions ;  CTF1Editor;  CTF1NormSumClass adding two functions: c1*f1+c2*f2 ;  CTF1ParametersTF1 Parameters class ;  CTF2A 2-Dim function with parameters ;  CTF2GLGL renderer for TF2 ;  CTF3A 3-Dim function with parameters ;  CTFastCgi;  CTFeldmanCousinsClass to calculate the CL upper limit using the Feldman-Cousins method as described in PRD V57 #7, p3873-3889 ;  CTFFTComplex;  CTFFTComplexReal;  CTFFTReal;  CTFFTRealComplex;  CTFileA ROOT file is a suite of consecutive data records (TKey instances) with a well defined format ;  CTFileCacheReadA cache when reading files over the network ;  CTFileCacheWriteA cache when writing files over the network ;  CTFileCollectionClass that contains a list of TFileInfo's and accumulated meta data information about its entries ;  CTFileDrawMapThis class is automatically called by TFile::DrawMap ;  CTFileHandler;  CTFileInfoClass describing a generic file including meta information ;  CTFileInfoMeta;  CTFileIter;  CTFileMergeInfo;  CTFileMergerThis class provides file copy and merging services ;  CTFileOpenHandleClass holding info about the file being opened ;  CTFilePrefetchThe prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a block of tree entries ;  CTFileSet;  CTFileStager;  ►CTFitEditor;  CFuncParamData_tTF1Convolution object ;  CTFitParametersDialog;  CTFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O ;  CTFitResultPtrProvides an indirection to the TFitResult class and with a semantics iden",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:150738,cache,cache,150738,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['cache'],['cache']
Performance,"WrappedTF1 () override;  Destructor (no operations). ;  ; WrappedTF1 & operator= (const WrappedTF1 &rhs);  Assignment operator. ;  ; interface inherited from IFunction; ROOT::Math::IGenFunction * Clone () const override;  Clone the wrapper but not the original function. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricGradFunctionOneDim;  ~IParametricGradFunctionOneDim () override;  Virtual Destructor (no operations) ;  ; double ParameterDerivative (const double *x, const double *p, unsigned int ipar=0) const;  Partial derivative with respect a parameter Compatibility interface with multi-dimensional functions. ;  ; double ParameterDerivative (const double *x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values (multi-dim like interface) ;  ; double ParameterDerivative (double x, const double *p, unsigned int ipar=0) const;  Partial derivative with respect a parameter. ;  ; double ParameterDerivative (double x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values. ;  ; void ParameterGradient (const double *x, const double *p, double *grad) const;  Compatibility interface with multi-dimensional functions. ;  ; void ParameterGradient (const double *x, double *grad) const;  Evaluate all derivatives using cached parameter values (multi-dim like interface) ;  ; void ParameterGradient (double x, double *grad) const;  Evaluate all derivatives using cached parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionOneDim; double operator() (const double *x, const double *p) const;  multidim-like interface ;  ; double operator() (double x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; double operator() (const double *x) const;  Evaluate the function at a point x[]. ;  ; double operator() (double x)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedTF1.html:2715,cache,cached,2715,doc/master/classROOT_1_1Math_1_1WrappedTF1.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedTF1.html,1,['cache'],['cached']
Performance,Wrapper around this class custom conversion Streamer member function.; TClass::ConvSIMap_tfConversionStreamerInfoArray of the streamer infos derived from another class.; atomic<TVirtualStreamerInfo*>fCurrentInfo!cached current streamer info.; TListOfDataMembers*fDatalinked list for data members; Short_tfDeclFileLineline of class declaration; const char*fDeclFileNamename of class declaration file; ROOT::DelFunc_tfDeletepointer to a function deleting one object.; ROOT::DelArrFunc_tfDeleteArraypointer to a function deleting an array of objects.; ROOT::DesFunc_tfDestructorpointer to a function call an object's destructor.; ROOT::DirAutoAdd_tfDirAutoAddpointer which implements the Directory Auto Add feature for this class.']'; atomic<TListOfEnums*>fEnumslinked list for the enums; TListOfFunctionTemplates*fFuncTemplatelinked list for function templates [Not public until implemented as active list]; IsAGlobalFunc_tfGlobalIsApointer to a global IsA function.; atomic<Bool_t>fHasRootPcmInfo!Whether info was loaded from a root pcm.; Short_tfImplFileLineline of class implementation; const char*fImplFileNamename of class implementation file; UInt_tfInstanceCountnumber of instances of this class; TVirtualIsAProxy*fIsA!pointer to the class's IsA proxy.; atomic<TMethodCall*>fIsAMethod!saved info to call a IsA member function; atomic<Bool_t>fIsOffsetStreamerSet!saved remember if fOffsetStreamer has been set.; atomic<TVirtualStreamerInfo*>fLastReadInfo!cached streamer info used in the last read.; ROOT::MergeFunc_tfMergepointer to a function implementing Merging objects of this class.; atomic<TListOfFunctions*>fMethodlinked list for methods; ROOT::NewFunc_tfNewpointer to a function newing one object.; ROOT::NewArrFunc_tfNewArraypointer to a function newing an array of objects.; static TClass::TDeclNameRegistryfNoInfoOrEmuOrFwdDeclNameRegistryStore the decl names of the forwardd and no info instances; Long_tfOffsetStreamer!saved info to call Streamer; UInt_tfOnHeapnumber of instances o,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:21413,load,loaded,21413,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['load'],['loaded']
Performance,"WrapperPdf::evaluate ; (; ); const. inlineoverrideprivatevirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 113 of file RooWrapperPdf.h. ◆ forceAnalyticalInt(). bool RooWrapperPdf::forceAnalyticalInt ; (; const RooAbsArg & ; dep); const. inlineoverridevirtual . Reimplemented from RooAbsReal.; Definition at line 56 of file RooWrapperPdf.h. ◆ getAnalyticalIntegral(). Int_t RooWrapperPdf::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. inlineoverridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 63 of file RooWrapperPdf.h. ◆ getAnalyticalIntegralWN(). Int_t RooWrapperPdf::getAnalyticalIntegralWN ; (; RooArgSet & ; allDeps, . RooArgSet & ; analDeps, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. inlineoverridevirtual . Variant of getAnalyticalIntegral that is also passed the normalization set that should be applied to the integrand of which the integral is requested. ; For certain operator p.d.f it is useful to overload this function rather than analyticalIntegralWN() as the additional normalization information may be useful in determining a more efficient decomposition of the requested integral. ; Reimplemented from RooAbsReal.; Definition at line 59 of file RooWrapperPdf.h. ◆ getMaxVal(). Int_t RooWrapperPdf::getMaxVal ; (; const RooArgSet & ; vars); const. inlineoverridevirtual . Get specialised generator. Since the underlying function is not a PDF, this will ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWrapperPdf.html:78326,perform,performed,78326,doc/master/classRooWrapperPdf.html,https://root.cern,https://root.cern/doc/master/classRooWrapperPdf.html,1,['perform'],['performed']
Performance,"WriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>_ioReadStackreading stack ; static const UInt_tfnv1a32start; static const ULong64_tfnv1a64start. protected:. set<std::string>_boolAttribBoolean attributes; set<std::string>_boolAttribTransient! Transient boolean attributes (not copied in ctor); deque<RooAbsCache*>_cacheListlist of caches; RooRefCountList_clientListlist of client objects; RooRefCountList_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountList_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*_clientShapeIter! Iterator over _clientListShape ; TIterator*_clientValueIter! Iterator over _clientListValue ; Bool_t_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*_eocachePointer to global cache manager for any expensive components created by this object; Bool_t_fastAllow fast access mode in getVal() and proxies; static Bool_t_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_isConstant! Cached isConstant status ; Bool_t_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperMode_operModeDirty state propagation mode; RooArgSet*_ownedComponents! Set of owned component; Bool_t_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArray_proxyListlist of proxies; RooRefCountList_serverListlist of server objects; Bool_t_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>_stringAttribString attribut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:17393,cache,caches,17393,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,2,['cache'],"['cache', 'caches']"
Performance,"WriteFastArrayDouble32 (const Double_t *d, Long64_t n, TStreamerElement *ele=nullptr) final;  Write array of Double32_t to buffer. ;  ; void WriteFastArrayFloat16 (const Float_t *d, Long64_t n, TStreamerElement *ele=nullptr) final;  Write array of Float16_t to buffer. ;  ; void WriteFloat16 (Float_t *f, TStreamerElement *ele=nullptr) final;  write a Float16_t to the buffer ;  ; void WriteString (const char *) final;  ; UInt_t WriteVersionMemberWise (const TClass *, Bool_t=kFALSE) final;  ;  Public Member Functions inherited from TBufferIO;  ~TBufferIO () override;  destructor ;  ; Bool_t CheckObject (const TObject *obj) override;  Check if the specified object is already in the buffer. ;  ; Bool_t CheckObject (const void *obj, const TClass *ptrClass) override;  Check if the specified object of the specified class is already in the buffer. ;  ; void ForceWriteInfo (TVirtualStreamerInfo *info, Bool_t force) override;  force writing the TStreamerInfo to the file ;  ; void ForceWriteInfoClones (TClonesArray *a) override;  Make sure TStreamerInfo is not optimized, otherwise it will not be possible to support schema evolution in read mode. ;  ; Int_t GetBufferDisplacement () const override;  ; TProcessID * GetLastProcessID (TRefTable *reftable) const override;  Return the last TProcessID in the file. ;  ; Int_t GetMapCount () const override;  ; void GetMappedObject (UInt_t tag, void *&ptr, TClass *&ClassPtr) const override;  Retrieve the object stored in the buffer's object map at 'tag' Set ptr and ClassPtr respectively to the address of the object and a pointer to its TClass. ;  ; UShort_t GetPidOffset () const override;  ; UInt_t GetTRefExecId () override;  Return the exec id stored in the current TStreamerInfo element. ;  ; Int_t GetVersionOwner () const override;  Return the version number of the owner file. ;  ; void InitMap () override;  Create the fMap container and initialize them with the null object. ;  ; void MapObject (const TObject *obj, UInt_t offset=1) overr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:25602,optimiz,optimized,25602,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,4,['optimiz'],['optimized']
Performance,"X2=0.000000 Y2=0.000000; TLine X1=3.000000 Y1=4.000000 X2=0.000000 Y2=0.000000; TLine X1=4.000000 Y1=5.000000 X2=0.000000 Y2=0.000000; root [] .q; Here we note:. A multi-line command starts with a { and ends with a }.; Inside continuation, every line has to be correctly terminated with a ; (like in ""real’’ C++).; All objects are created in global scope.; There is no way to back up; you are better off writing a script.; Use .q to exit root. 7.2 Feeding Sources Files To ROOT: C++ Scripts; ROOT script files (often called “Macros”) contain pure C++ code. They can contain a simple sequence of statements like in the multi command line example given above, but also arbitrarily complex class and function definitions.; The most frequent interaction with the ROOT prompt uses .x to “run” a file:; root [] .x myScript.C; This loads myScript.C into the interpreter and calls the function myScript(). You can pass arguments using .x myScript.C(12, ""A String"").; Alternatively you can load the script and then run a function explicitly:; root [] .L myScript.C; root [] myScript(); The above is equivalent to .x myScript.C.; In a named script, the objects created on the stack are deleted when the function exits. In a common scenario you create a histogram in a named script on the stack. You draw the histogram, but when the function exits the canvas is empty and the histogram has disappeared. To avoid the histogram from disappearing you can create it on the heap (by using new). This will leave the histogram object intact, but the pointer in the named script scope will be “gone”. Since histograms (and trees) are added to the list of objects in the current directory, you can always retrieve them to delete them if needed.; root[] TH1F *h = (TH1F*)gDirectory->Get(""myHist""); // or; root[] TH1F *h = (TH1F*)gDirectory->GetList()->FindObject(""myHist"");; In addition, histograms and trees are automatically deleted when the current directory is closed. This will automatically take care of the clean u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:263599,load,load,263599,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['load']
Performance,"XNGFile;  CTNetXNGFileStager;  CTNetXNGSystem;  CTNeuron;  CTNewChainDlg;  CTNewQueryDlg;  CTNodeTNode description ;  CTNodeDivDescription of parameters to divide a 3-D geometry object ;  CTNonCopyable;  CTNonSplitBrowsableAllows a TBrowser to browse non-split branches as if they were split ;  CTNtupleA simple TTree restricted to a list of float variables only ;  CTNtupleDA simple TTree restricted to a list of double variables only ;  CTObjArrayAn array of TObjects ;  CTObjArrayIterIterator of object array ;  CTObjectMother of all ROOT objects ;  CTObjectRefSpy;  CTObjectSet;  CTObjectSpyMonitors objects for deletion and reflects the deletion by reverting the internal pointer to zero ;  CTObjectTableThis class registers all instances of TObject and its derived classes in a hash table ;  CTObjLinkWrapper around a TObject so it can be stored in a TList ;  CTObjOptLink;  CTObjStringCollectable string class ;  CTOCCToStep;  CTODBCResult;  CTODBCRow;  CTODBCServer;  ►CTODBCStatement;  CODBCBufferRec_t;  CToolBarData_t;  CTOptionListItem;  CTOracleResult;  CTOracleRow;  CTOracleServer;  ►CTOracleStatement;  CTBufferRec;  CTOrdCollectionOrdered collection ;  CTOrdCollectionIterIterator of ordered collection ;  CTOutputListSelectorDataMapSet the selector's data members to the corresponding elements of the output list ;  CTPackageDescription;  CTPacketizerThis class generates packets to be processed on PROOF worker servers ;  CTPacketizerAdaptiveThis packetizer is based on TPacketizer but uses different load-balancing algorithms and data structures ;  CTPacketizerFileThis packetizer generates packets which contain a single file path to be used in process ;  CTPacketizerMultiThis class allows to do multiple runs in the same query; each run can be a, for example, different dataset or the same dataset with entry list ;  CTPacketizerUnitThis packetizer generates packets of generic units, representing the number of times an operation cycle has to be repeated by the worker node, e.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:173075,load,load-balancing,173075,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,['load'],['load-balancing']
Performance,"XTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::AddNavigatorTGeoNavigator * AddNavigator()Add a navigator in the list of navigators.Definition TGeoManager.cxx:789; TGeoManager::SetCurrentNavigatorBool_t SetCurrentNavigator(Int_t index)Switch to another existing navigator for the calling thread.Definition TGeoManager.cxx:849; TGeoNavigatorClass providing navigation API for TGeo geometries.Definition TGeoNavigator.h:32; TGeoNavigator::TGeoNavigatorTGeoNavigator()global mode is caching enabled for parallel world safety callsDefinition TGeoNavigator.cxx:57; int; .... and then switch back to the default navigator:; gGeoManager->SetCurrentNavigator(0);. Definition at line 32 of file TGeoNavigator.h. Public Member Functions;  TGeoNavigator ();  global mode is caching enabled for parallel world safety calls ;  ;  TGeoNavigator (TGeoManager *geom);  Constructor. ;  ;  ~TGeoNavigator () override;  Destructor. ;  ; void BuildCache (Bool_t dummy=kFALSE, Bool_t nodeid=kFALSE);  Builds the cache for physical nodes and global matrices. ;  ; Bool_t cd (const char *path="""");  Browse the tree of nodes starting from top node according to pathname. ;  ; void CdDown (Int_t index);  Make a daughter of current node current. ;  ; void CdDown (TGeoNode *node);  Make a daughter of current node current. ;  ; void CdNext ();  Do a cd to the node found next by FindNextBoundary. ;  ; void CdNode (Int_t nodeid);  Change current path to point to the node having this id. ;  ; void CdTop ();  Make top level node the current node. ;  ; void CdUp ();  Go one level up in geometry. ;  ; Bool_t CheckPath (const char *path) const;  Check if a geometry path is valid without changing the state of the navigator. ;  ; TGeoNode * CrossBoundaryAndLocate (Bool_t downwards, TGeoNode *skipnode);  Cross next boundary and locate within current node The current point must be on the boundary of fCurrentNode. ;  ; void DoBackupState ();  Backup the current state without affecting the cache sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:1769,cache,cache,1769,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['cache'],['cache']
Performance,XWindow_t *gCws; // gCws: pointer to the current window; 82static XWindow_t *gTws; // gTws: temporary pointer; 83 ; 84const Int_t kBIGGEST_RGB_VALUE = 65535;; 85 ; 86//; 87// Primitives Graphic Contexts global for all windows; 88//; 89const int kMAXGC = 7;; 90static GC gGClist[kMAXGC];; 91static GC *gGCline = &gGClist[0]; // PolyLines; 92static GC *gGCmark = &gGClist[1]; // PolyMarker; 93static GC *gGCfill = &gGClist[2]; // Fill areas; 94static GC *gGCtext = &gGClist[3]; // Text; 95static GC *gGCinvt = &gGClist[4]; // Inverse text; 96static GC *gGCdash = &gGClist[5]; // Dashed lines; 97static GC *gGCpxmp = &gGClist[6]; // Pixmap management; 98 ; 99static GC gGCecho; // Input echo; 100 ; 101static Int_t gFillHollow; // Flag if fill style is hollow; 102static Pixmap gFillPattern = 0; // Fill pattern; 103 ; 104//; 105// Text management; 106//; 107const Int_t kMAXFONT = 4;; 108static struct {; 109 XFontStruct *id;; 110 char name[80]; // Font name; 111} gFont[kMAXFONT]; // List of fonts loaded; 112 ; 113static XFontStruct *gTextFont; // Current font; 114static Int_t gCurrentFontNumber = 0; // Current font number in gFont[]; 115 ; 116//; 117// Markers; 118//; 119const Int_t kMAXMK = 100;; 120static struct {; 121 int type;; 122 int n;; 123 XPoint xy[kMAXMK];; 124} gMarker; // Point list to draw marker; 125static int gMarkerLineWidth = 0;; 126static int gMarkerLineStyle = LineSolid;; 127static int gMarkerCapStyle = CapRound;; 128static int gMarkerJoinStyle = JoinRound;; 129 ; 130//; 131// Keep style values for line GC; 132//; 133static int gLineWidth = 0;; 134static int gLineStyle = LineSolid;; 135static int gCapStyle = CapButt;; 136static int gJoinStyle = JoinMiter;; 137static char gDashList[10];; 138static int gDashLength = 0;; 139static int gDashOffset = 0;; 140static int gDashSize = 0;; 141 ; 142//; 143// Event masks; 144//; 145static ULong_t gMouseMask = ButtonPressMask | ButtonReleaseMask |; 146 EnterWindowMask | LeaveWindowMask |; 147 PointerMotionMask | KeyPressMask ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:3718,load,loaded,3718,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['load'],['loaded']
Performance,"Yaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf208_convolutionDefinition rf208_convolution.py:1; ; [#1] INFO:Eval -- RooRealVar::setRange(t) new range named 'refrange_fft_lxg' created with bounds [-10,30]; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lxg) creating new cache 0x56539f82d770 with pdf lx_CONV_gauss_CACHE_Obs[t]_NORM_t for nset (t) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lxg_over_lxg_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lxg_over_lxg_Int[t]_lxgData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lxg) creating new cache 0x56539fd9f650 with pdf lx_CONV_gauss_CACHE_Obs[t] for nset () with code 1 from preexisting content.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lxg) creating new cache 0x56539fcccee0 with pdf lx_CONV_gauss_CACHE_Obs[t]_NORM_t for nset (t) with code 0; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf208_convolution.C. tutorialsroofitrf208_convolution.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf208__convolution_8C.html:3845,cache,cache,3845,doc/master/rf208__convolution_8C.html,https://root.cern,https://root.cern/doc/master/rf208__convolution_8C.html,5,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"Zombie(); Int_tSetParameters(). private:. voidBuildHistos(Int_t start, Int_t stop, Int_t step, Bool_t nx). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTProofBenchRun::fParListList of PARs to be loaded; TProof*TProofBenchRun::fProofProof; TStringTProofBenchRun::fSelNameName of the selector to be run. private:. TCanvas*fCPerfProfilescanvas for performance profile histograms; TProofBenchDataSet*fDSdataset operations handler; Int_tfDebugdebug switch; TDirectory*fDirProofBenchdirectory for proof outputs; Int_tfFilesPerWrk# of files to be processed per worker; TH2*fHist_perfstat_IO; TH2*fHist_perfstat_event; TList*fListPerfPlotslist of performance plots; Long64_tfNEventsnumber of events per file; Int_tfNTriesnumber of tries; TStringfNamename of this run; TProofNodes*fNodeslist of nodes information; TProfile*fNorm_queryresult_IO; TProfile*fNorm_queryresult_event; TProfile*fProfile_perfstat_IO; TProfile*fProfile_perfstat_event; TProfile*fProfile_queryresult_IO; TProfile*fProfile_queryresult_event; TProof*fProofpointer to proof; TPBReadType*fReadTyperead type; Int_tfStartstart number of workers; Int_tfSteptest to be performed every fStep workers; Int_tfStopstop number of workers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBenchRunDataRead(TProofBenchDataSet* pbds, TPBReadType* readtype = 0, TDirectory* dirproofbench = 0, TProof* proof = 0, TProofNodes* nodes = 0, Long64_t nevents = -1, Int_t ntries = 2, Int_t start = 1, Int_t stop = -1, Int_t step = 1, Int_t debug = 0). ~TProofBenchRunDataRead(); Destructor. void Run(const char* dset, Int_t start, Int_t stop, Int_t step, Int_t ntries, Int_t debug, Int_t ); Run benchmark; Input parameters; dset: Dataset on which to run; start: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofBenchRunDataRead.html:7121,perform,performance,7121,root/html530/TProofBenchRunDataRead.html,https://root.cern,https://root.cern/root/html530/TProofBenchRunDataRead.html,6,['perform'],"['performance', 'performed']"
Performance,"Zombie. protected:. TStringTNamed::fNameobject identifier; Double_tfScale[3]scale (x, y, z); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoScale(); default constructor. TGeoScale(const TGeoScale& other); Copy constructor. TGeoScale(Double_t sx, Double_t sy, Double_t sz); default constructor. TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); default constructor. ~TGeoScale(); destructor. TGeoScale & operator=(const TGeoScale& other); Assignment operator. TGeoMatrix& Inverse() const; Return a temporary inverse of this. void SetScale(Double_t sx, Double_t sy, Double_t sz); scale setter. void LocalToMaster(const Double_t* local, Double_t* master) const; Convert a local point to the master frame. Double_t LocalToMaster(Double_t dist, const Double_t* dir = 0) const; Convert the local distance along unit vector DIR to master frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void MasterToLocal(const Double_t* master, Double_t* local) const; Convert a global point to local frame. Double_t MasterToLocal(Double_t dist, const Double_t* dir = 0) const; Convert the distance along unit vector DIR to local frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void ReflectX(Bool_t , Bool_t ). void ReflectY(Bool_t , Bool_t ). void ReflectZ(Bool_t , Bool_t ). » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoScale.html:16339,perform,perform,16339,root/html604/TGeoScale.html,https://root.cern,https://root.cern/root/html604/TGeoScale.html,1,['perform'],['perform']
Performance,"Zombie. protected:. TStringTNamed::fNameobject identifier; Double_tfScale[3]scale (x, y, z); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoScale(); default constructor. TGeoScale(const TGeoScale& other); Copy constructor. TGeoScale(Double_t sx, Double_t sy, Double_t sz); default constructor. TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); default constructor. ~TGeoScale(); destructor. TGeoScale & operator=(const TGeoScale& other); Assignment operator. TGeoMatrix& Inverse() const; Return a temporary inverse of this. void SetScale(Double_t sx, Double_t sy, Double_t sz); scale setter. void LocalToMaster(const Double_t* local, Double_t* master) const; Convert a local point to the master frame. Double_t LocalToMaster(Double_t dist, const Double_t* dir = 0) const; Convert the local distance along unit vector DIR to master frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void MasterToLocal(const Double_t* master, Double_t* local) const; Convert a global point to local frame. Double_t MasterToLocal(Double_t dist, const Double_t* dir = 0) const; Convert the distance along unit vector DIR to local frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void ReflectX(Bool_t , Bool_t ). void ReflectY(Bool_t , Bool_t ). void ReflectZ(Bool_t , Bool_t ). » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoScale.html:16339,perform,perform,16339,root/html602/TGeoScale.html,https://root.cern,https://root.cern/root/html602/TGeoScale.html,1,['perform'],['perform']
Performance,"Zombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooDataHist_dh; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooParamHistFunc.html:34063,cache,cache,34063,root/html602/RooParamHistFunc.html,https://root.cern,https://root.cern/root/html602/RooParamHistFunc.html,12,['cache'],"['cache', 'caches']"
Performance,"[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -1002.2262595660759; Edm = 2.95538313214564806e-09; Nfcn = 251; a1 = -0.498159 +/- 0.0227242 (limited); a2 = 0.198316 +/- 0.00564906 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 0, estimated distance to minimum: 0; covariance matrix quality: Not calculated at all; Status : MINIMIZE=-1 HESSE=302 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 1.0000e+01 +/- 0.00e+00; a2 -1.0000e+00 +/- 0.00e+00; ; ; RooFitResult: minimized FCN value: 29650.9, estimated distance to minimum: 2.95925e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 -4.9816e-01 +/- 2.27e-02; a2 1.9832e-01 +/- 5.65e-03; ; ; ; ; -------------- Starting second fit ---------------; ; ; Without recovery, the fitter encountered 23 invalid function values. The parameters are unchanged.; ; With recovery, the fitter encountered 23 invalid function values, but the parameters are fitted.; ; DateJune 2021 ; AuthorHarshal Shende, Stephan Hageboeck (C++ version) ; Definition in file rf612_recoverFromInvalidParameters.py. tutorialsroofitrf612_recoverFromI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:7117,optimiz,optimization,7117,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['optimiz'],['optimization']
Performance,"[-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model0_over_model0_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model0_over_model0_Int[x]_sumData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2388.31039421315518; Edm = 3.25299757922590944e-06; Nfcn = 60; Abkg = 0.0614547 +/- 0.00211669 (limited); Asig = 0.833778 +/- 0.1898 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (hc_sig,hc_bkg); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (Abkg,Asig,p_ph_bkg_gamma_bin_0,p_ph_bkg_gamma_bin_1,p_ph_bkg_gamma_bin_10,p_ph_bkg_gamma_bin_11,p_ph_bkg_gamma_bin_12,p_ph_bkg_gamma_bin_13,p_ph_bkg_gamma_bin_14,p_ph_bkg_gamma_bin_15,p_ph_bkg_gamma_bin_16,p_ph_bkg_gamma_bin_17,p_ph_bkg_gamma_bin_18,p_ph_bkg_gamma_bin_19,p_ph_bkg_gamma_bin_2,p_ph_bkg_gamma_bin_20,p_ph_bkg_gamma_bin_21,p_ph_bkg_gamma_bin_22,p_ph_bkg_gamma_bin_23,p_ph_bkg_gamma_bin_24,p_ph_bkg_gamma_bin_3,p_ph_bkg_gamma_bin_4,p_ph_bkg_gamma_bin_5,p_ph_bkg_gamma_bin_6,p_ph_bkg_gamma_bin_7,p_ph_bkg_gamma_bin_8,p_ph_bkg_gamma_bin_9,p_ph_sig_gamma_bin_0,p_ph_sig_gamma_bin_1,p_ph_sig_gamma_bin_10,p_ph_sig_gamm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:12567,optimiz,optimization,12567,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,2,['optimiz'],['optimization']
Performance,"[0]=20:NSmoothBkg[1]=10"",; NSmooth=1,; NAvEvtPerBin=50,; ); ; # Use a kernel density estimator to approximate the PDFs; if useLikelihoodKDE:; factory.BookMethod(; loader,; TMVA.Types.kLikelihood,; ""LikelihoodKDE"",; H=False,; V=False,; TransformOutput=False,; PDFInterpol=""KDE"",; KDEtype=""Gauss"",; KDEiter=""Adaptive"",; KDEFineFactor=0.3,; KDEborder=None,; NAvEvtPerBin=50,; ); ; # Fisher discriminant (same as LD); if useFischer:; factory.BookMethod(; loader,; TMVA.Types.kFisher,; ""Fisher"",; H=True,; V=False,; Fisher=True,; VarTransform=None,; CreateMVAPdfs=True,; PDFInterpolMVAPdf=""Spline2"",; NbinsMVAPdf=50,; NsmoothMVAPdf=10,; ); ; # Boosted Decision Trees; if useBDT:; factory.BookMethod(; loader,; TMVA.Types.kBDT,; ""BDT"",; V=False,; NTrees=200,; MinNodeSize=""2.5%"",; MaxDepth=2,; BoostType=""AdaBoost"",; AdaBoostBeta=0.5,; UseBaggedBoost=True,; BaggedSampleFraction=0.5,; SeparationType=""GiniIndex"",; nCuts=20,; ); ; # Multi-Layer Perceptron (Neural Network); if useMLP:; factory.BookMethod(; loader,; TMVA.Types.kMLP,; ""MLP"",; H=False,; V=False,; NeuronType=""tanh"",; VarTransform=""N"",; NCycles=100,; HiddenLayers=""N+5"",; TestRate=5,; UseRegulator=False,; ); ; ## Here we book the new DNN of TMVA if we have support in ROOT. We will use GPU version if ROOT is enabled with GPU; ; ; ## Booking Deep Neural Network; ; # Here we define the option string for building the Deep Neural network model.; ; #### 1. Define DNN layout; ; # The DNN configuration is defined using a string. Note that whitespaces between characters are not allowed.; ; # We define first the DNN layout:; ; # - **input layout** : this defines the input data format for the DNN as ``input depth | height | width``.; # In case of a dense layer as first layer the input layout should be ``1 | 1 | number of input variables`` (features); # - **batch layout** : this defines how are the input batch. It is related to input layout but not the same.; # If the first layer is dense it should be ``1 | batch size ! number of variables",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:62311,load,loader,62311,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['load'],['loader']
Performance,"[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : Boosted Decision Trees are a collection of individual decision; : trees which form a multivariate classifier by (weighted) majority ; : vote of the individual trees. Consecutive decision trees are ; : trained using the original training data set with re-weighted ; : events. By default, the AdaBoost method is employed, which gives ; : events that were misclassified in the previous tree a larger ; : weight in the training of the following tree.; : ; : Decision trees are a sequence of binary splits of the data sample; : using a single discriminant variable at a time. A test event ; : ending up after the sequence of left-right splits in a final ; : (""leaf"") node is classified as either signal or background; : depending on the majority type of training events in that node.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : By the nature of the binary splits performed on the individual; : variables, decision trees do not deal well with linear correlations; : between variables (they need to approximate the linear split in; : the two dimensional space by a sequence of splits on the two ; : variables individually). Hence decorrelation could be useful ; : to optimise the BDT performance.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The two most important parameters in the configuration are the ; : minimal number of events requested by a leaf node as percentage of the ; : number of training events (option ""MinNodeSize"" replacing the actual number ; : of events ""nEventsMin"" as given in earlier versions; : If this number is too large, detailed features ; : in the parameter space are hard to be modelled. If it is too small, ; : the risk to overtrain rises and boosting seems to be less effective; : typical values from our current experience for best performance ; : are between 0.5(%) and 10(%) ; : ; : The default minimal number is currently set to ; : max(20, (N_training_events / N_variables^2 / 10)) ; : ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:31442,perform,performed,31442,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['perform'],['performed']
Performance,"[1] * dir[1] +; 1623 fScale[2] * fScale[2] * dir[2] * dir[2];; 1624 scale = TMath::Sqrt(scale);; 1625 }; 1626 return scale * dist;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Make a clone of this matrix.; 1631 ; 1632TGeoMatrix *TGeoScale::MakeClone() const; 1633{; 1634 TGeoMatrix *matrix = new TGeoScale(*this);; 1635 return matrix;; 1636}; 1637 ; 1638////////////////////////////////////////////////////////////////////////////////; 1639/// Convert a global point to local frame.; 1640 ; 1641void TGeoScale::MasterToLocal(const Double_t *master, Double_t *local) const; 1642{; 1643 local[0] = master[0] / fScale[0];; 1644 local[1] = master[1] / fScale[1];; 1645 local[2] = master[2] / fScale[2];; 1646}; 1647 ; 1648////////////////////////////////////////////////////////////////////////////////; 1649/// Convert the distance along unit vector DIR to local frame. If DIR; 1650/// is not specified perform a conversion such as the returned distance is the; 1651/// the minimum for all possible directions.; 1652 ; 1653Double_t TGeoScale::MasterToLocal(Double_t dist, const Double_t *dir) const; 1654{; 1655 Double_t scale;; 1656 if (!dir) {; 1657 scale = TMath::Abs(fScale[0]);; 1658 if (TMath::Abs(fScale[1]) > scale); 1659 scale = TMath::Abs(fScale[1]);; 1660 if (TMath::Abs(fScale[2]) > scale); 1661 scale = TMath::Abs(fScale[2]);; 1662 scale = 1. / scale;; 1663 } else {; 1664 scale = (dir[0] * dir[0]) / (fScale[0] * fScale[0]) + (dir[1] * dir[1]) / (fScale[1] * fScale[1]) +; 1665 (dir[2] * dir[2]) / (fScale[2] * fScale[2]);; 1666 scale = TMath::Sqrt(scale);; 1667 }; 1668 return scale * dist;; 1669}; 1670 ; 1671/** \class TGeoCombiTrans; 1672\ingroup Geometry_classes; 1673Class describing rotation + translation. Most frequently used in the description; 1674of TGeoNode 's; 1675*/; 1676 ; 1677ClassImp(TGeoCombiTrans);; 1678 ; 1679////////////////////////////////////////////////////////////////////////////////; 1680/// dumm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:58401,perform,perform,58401,doc/master/TGeoMatrix_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html,1,['perform'],['perform']
Performance,"[1m--- Short description:␛[0m; : ; : Linear discriminants select events by distinguishing the mean ; : values of the signal and background distributions in a trans- ; : formed variable space where linear correlations are removed.; : The LD implementation here is equivalent to the ""Fisher"" discriminant; : for classification, but also provides linear regression.; : ; : (More precisely: the ""linear discriminator"" determines; : an axis in the (correlated) hyperspace of the input ; : variables such that, when projecting the output classes ; : (signal and background) upon this axis, they are pushed ; : as far as possible away from each other, while events; : of a same class are confined in a close vicinity. The ; : linearity property of this classifier is reflected in the ; : metric with which ""far apart"" and ""close vicinity"" are ; : determined: the covariance matrix of the discriminating; : variable space.); : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Optimal performance for the linear discriminant is obtained for ; : linearly correlated Gaussian-distributed variables. Any deviation; : from this ideal reduces the achievable separation power. In ; : particular, no discrimination at all is achieved for a variable; : that has the same sample mean for signal and background, even if ; : the shapes of the distributions are very different. Thus, the linear ; : discriminant often benefits from a suitable transformation of the ; : input variables. For example, if a variable x in [-1,1] has a ; : a parabolic signal distributions, and a uniform background; : distributions, their mean value is zero in both cases, leading ; : to no separation. The simple transformation x -> |x| renders this ; : variable powerful for the use in a linear discriminant.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : <None>; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:36346,perform,performance,36346,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['performance']
Performance,"[7] h = 0.000244141 , s = 3.9375; [8] h = 6.10352e-05 , s = 4.03125; [9] h = 1.52588e-05 , s = 3.98438; [10] h = 3.8147e-06 , s = 4.00781; [11] h = 9.53674e-07 , s = 3.99609; [12] h = 2.38419e-07 , s = 4.00195; [13] h = 5.96046e-08 , s = 3.99902; [14] h = 1.49012e-08 , s = 4.00049; [15] h = 3.72529e-09 , s = 3.99976; [16] h = 9.31323e-10 , s = 4.00012; [17] h = 2.32831e-10 , s = 3.99994; [18] h = 5.82077e-11 , s = 4.00003; [19] h = 1.45519e-11 , s = 3.99998; [20] h = 3.63798e-12 , s = 4.00001; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x56161eb090f0 with pdf gx_CONV_model_mean_CACHE_Obs[x,mean]_NORM_x_mean for nset (x,mean) with code 1; [#0] WARNING:Eval -- The FFT convolution 'model' will run with 50 bins. A decent accuracy for difficult convolutions is typically only reached with n >= 1000. Suggest to increase the number of bins of the observable 'mean'.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x56161eb090f0 with pdf gx_CONV_model_mean_CACHE_Obs[x,mean]_NORM_x_mean for nset (x,mean) with code 1 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_Int[mean]_Norm[mean,x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_Int[mean]_Norm[mean,x]_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a: using 0.5; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for mean: using 0.6; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma: using 0.2; sigma=0.5, [#0] WARNING:Eval -- The FFT convolution",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf211__paramconv_8C.html:9278,cache,cache,9278,doc/master/rf211__paramconv_8C.html,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8C.html,1,['cache'],['cache']
Performance,"[] new TGeoManager(""world"", ""the simplest geometry"");; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; We can finally make our volume having a box shape. Note that the world volume does not need to be a box - it can be any other shape. Generally, boxes and tubes are the most recommendable shapes for this purpose due to their fast navigation algorithms.; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; The default units are in centimeters. Now we want to make this volume our world. We have to do this operation before closing the geometry.; root[] gGeoManager->SetTopVolume(top);; This should be enough, but it is not since always after defining some geometry hierarchy, TGeo needs to build some optimization structures and perform some checks. Note the messages posted after the statement is executed. We will describe the corresponding operations later.; root[] gGeoManager->CloseGeometry();; Now we are really done with geometry building stage, but we would like to see our simple world:; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; 18.1.2 Example 2: A Geometrical Hierarchy Look and Feel; Before going further, let us get a look and feel of interacting with the modeller. For this, we will use one of the examples illustrating the geometry package. To get an idea on the geometry structure created in this example, just look at the link: http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html. You will notice that this is a bit more complex that just creating the “world” since several other volumes are created and put together in a hierarchy. The purpos",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:878322,optimiz,optimization,878322,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"[fNseek] Position of sorted blocks in fBuffer; Int_tfSeekSizeAllocated size of fSeek; Long64_t*fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheRead(); Default Constructor. TFileCacheRead(TFile* file, Int_t buffersize); Creates a TFileCacheRead data structure. ~TFileCacheRead(); Destructor. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFileCacheRead(const TFileCacheRead& ). TFileCacheRead& operator=(const TFileCacheRead& ). void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileCacheRead.html:7988,cache,cache,7988,root/html528/TFileCacheRead.html,https://root.cern,https://root.cern/root/html528/TFileCacheRead.html,1,['cache'],['cache']
Performance,"[p].Filter(""trigP""); ; # Find two good muons with tight ID, pt > 25 GeV and not in the transition region between barrel and encap; df[p] = df[p].Define(""goodphotons"", ""photon_isTightID && (photon_pt > 25000) && (abs(photon_eta) < 2.37) && ((abs(photon_eta) < 1.37) || (abs(photon_eta) > 1.52))"")\; .Filter(""Sum(goodphotons) == 2""); ; # Take only isolated photons; df[p] = df[p].Filter(""Sum(photon_ptcone30[goodphotons] / photon_pt[goodphotons] < 0.065) == 2"")\; .Filter(""Sum(photon_etcone20[goodphotons] / photon_pt[goodphotons] < 0.065) == 2""); ; # Compile a function to compute the invariant mass of the diphoton system; ROOT.gInterpreter.Declare(; """"""; using namespace ROOT;; float ComputeInvariantMass(RVecF pt, RVecF eta, RVecF phi, RVecF e) {; ROOT::Math::PtEtaPhiEVector p1(pt[0], eta[0], phi[0], e[0]);; ROOT::Math::PtEtaPhiEVector p2(pt[1], eta[1], phi[1], e[1]);; return (p1 + p2).mass() / 1000.0;; }; """"""); ; # Define a new column with the invariant mass and perform final event selection; hists = {}; for p in processes:; # Make four vectors and compute invariant mass; df[p] = df[p].Define(""m_yy"", ""ComputeInvariantMass(photon_pt[goodphotons], photon_eta[goodphotons], photon_phi[goodphotons], photon_E[goodphotons])""); ; # Make additional kinematic cuts and select mass window; df[p] = df[p].Filter(""photon_pt[goodphotons][0] / 1000.0 / m_yy > 0.35"")\; .Filter(""photon_pt[goodphotons][1] / 1000.0 / m_yy > 0.25"")\; .Filter(""m_yy > 105 && m_yy < 160""); ; # Book histogram of the invariant mass with this selection; hists[p] = df[p].Histo1D(; ROOT.RDF.TH1DModel(p, ""Diphoton invariant mass; m_{#gamma#gamma} [GeV];Events"", 30, 105, 160),; ""m_yy"", ""weight""); ; # Run the event loop; ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([hists[s] fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html:2897,perform,perform,2897,doc/master/df104__HiggsToTwoPhotons_8py.html,https://root.cern,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html,1,['perform'],['perform']
Performance,"[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const TGClient*fClientclient for which we keep icon pool; TStringfPathicon search path; THashTable*fPicListhash table containing the icons. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGPicturePool(const TGPicturePool& ); copy constructor. TGPicturePool& operator=(const TGPicturePool& ); assignment operator. const TGPicture * GetPicture(const char* name); Get a picture from the picture pool. Picture must be freed using; TGPicturePool::FreePicture(). If picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, UInt_t new_width, UInt_t new_height); Get picture with specified size from pool (picture will be scaled if; necessary). Picture must be freed using TGPicturePool::FreePicture(). If; picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, Pixmap_t pxmap, Pixmap_t mask = 0); Get picture with specified pixmap and mask from pool.; Picture must be freed using TGPicturePool::FreePicture().; If picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, char** xpm); Create picture from XPM data.; Picture must be freed using TGPicturePool::FreePicture().; If picture creation failed 0 is returned. void FreePicture(const TGPicture* pic); Remove picture from cache if nobody is using it anymore. ~TGPicturePool(); Delete picture cache. void Print(Option_t* option = """") const; List all pictures in the pool. TGPicturePool(const TGPicturePool& ). const char * GetPath() const; { return fPath; }. » Author: Fons Rademakers 01/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGPicture.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGPicturePool.html:6930,cache,cache,6930,root/html528/TGPicturePool.html,https://root.cern,https://root.cern/root/html528/TGPicturePool.html,2,['cache'],['cache']
Performance,"[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const TGClient*fClientclient for which we keep icon pool; TStringfPathicon search path; THashTable*fPicListhash table containing the icons. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGPicturePool(const TGPicturePool& ); copy constructor. TGPicturePool& operator=(const TGPicturePool& ); assignment operator. const TGPicture * GetPicture(const char* name); Get a picture from the picture pool. Picture must be freed using; TGPicturePool::FreePicture(). If picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, UInt_t new_width, UInt_t new_height); Get picture with specified size from pool (picture will be scaled if; necessary). Picture must be freed using TGPicturePool::FreePicture(). If; picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, Pixmap_t pxmap, Pixmap_t mask = 0); Get picture with specified pixmap and mask from pool.; Picture must be freed using TGPicturePool::FreePicture().; If picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, char** xpm); Create picture from XPM data.; Picture must be freed using TGPicturePool::FreePicture().; If picture creation failed 0 is returned. void FreePicture(const TGPicture* pic); Remove picture from cache if nobody is using it anymore. ~TGPicturePool(); Delete picture cache. void Print(Option_t* option = """") const; List all pictures in the pool. TGPicturePool(const TGPicturePool& ). const char * GetPath() const; { return fPath; }. » Author: Fons Rademakers 01/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGPicture.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGPicturePool.html:6999,cache,cache,6999,root/html530/TGPicturePool.html,https://root.cern,https://root.cern/root/html530/TGPicturePool.html,2,['cache'],['cache']
Performance,"[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const TGClient*fClientclient for which we keep icon pool; TStringfPathicon search path; THashTable*fPicListhash table containing the icons. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGPicturePool(const TGPicturePool& ); copy constructor. TGPicturePool& operator=(const TGPicturePool& ); assignment operator. const TGPicture * GetPicture(const char* name); Get a picture from the picture pool. Picture must be freed using; TGPicturePool::FreePicture(). If picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, UInt_t new_width, UInt_t new_height); Get picture with specified size from pool (picture will be scaled if; necessary). Picture must be freed using TGPicturePool::FreePicture(). If; picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, Pixmap_t pxmap, Pixmap_t mask = 0); Get picture with specified pixmap and mask from pool.; Picture must be freed using TGPicturePool::FreePicture().; If picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, char** xpm); Create picture from XPM data.; Picture must be freed using TGPicturePool::FreePicture().; If picture creation failed 0 is returned. void FreePicture(const TGPicture* pic); Remove picture from cache if nobody is using it anymore. ~TGPicturePool(); Delete picture cache. void Print(Option_t* option = """") const; List all pictures in the pool. TGPicturePool(const TGPicturePool& ). const char * GetPath() const; { return fPath; }. » Author: Fons Rademakers 01/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGPicture.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-11-03 20:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGPicturePool.html:6999,cache,cache,6999,root/html532/TGPicturePool.html,https://root.cern,https://root.cern/root/html532/TGPicturePool.html,2,['cache'],['cache']
Performance,"[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. stringRooAbsTestStatistic::_addCoefRangeNameName of reference to be used for RooAddPdf components; list<RooAbsBinning*>_binList! Bin ranges; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_t_extendedIs the input function and extended p.d.f.; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooXYChi2Var.html:31793,cache,cache,31793,root/html526/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html526/RooXYChi2Var.html,9,['cache'],"['cache', 'caches']"
Performance,"\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfEnums(Bool_t load = kFALSE). TCollection * GetListOfFunctionTemplates(). TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return a dynamic list giving access to all TDataTypes (typedefs); currently defined. The list is populated on demand. Calling; gROOT->GetListOfTypes()->FindObject(nameoftype);; will return the TDataType corresponding to 'nameoftype'. If the; TDataType is not already in the list itself and the type does exist,; a new TDataType will be created and added to the list. Calling; gROOT->GetListOfTypes()->ls(); // or Print(); list only the typedefs that have been previously accessed throught the; list (plus the builtins types). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:28649,load,load,28649,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['load'],['load']
Performance,"\; 1059 The class %s transitioned from not having a specified class version\n\; 1060 to having a specified class version (the current class version is %d).\n\; 1061 However too many different non-versioned layouts of the class have been\n\; 1062 loaded so far. This prevent the proper reading of objects written with\n\; 1063 the class layout version %d, in particular from the file:\n\; 1064 %s.\n\; 1065 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1066 GetName(),fClass->GetClassVersion(),fClassVersion,file->GetName());; 1067 } else {; 1068 Warning(""BuildCheck"", ""\n\; 1069 The class %s transitioned from not having a specified class version\n\; 1070 to having a specified class version (the current class version is %d).\n\; 1071 However too many different non-versioned layouts of the class have been\n\; 1072 loaded so far. This prevent the proper reading of objects written with\n\; 1073 the class layout version %d.\n\; 1074 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1075 GetName(),fClass->GetClassVersion(),fClassVersion);; 1076 }; 1077 } else {; 1078 if (file) {; 1079 if (done) {; 1080 Warning(""BuildCheck"", ""\n\; 1081 The StreamerInfo for version %d of class %s read from the file %s\n\; 1082 has a different checksum than the previously loaded StreamerInfo.\n\; 1083 Reading objects of type %s from the file %s \n\; 1084 (and potentially other files) might not work correctly.\n\; 1085 Most likely the version number of the class was not properly\n\; 1086 updated [See ClassDef(%s,%d)]."",; 1087 fClassVersion, GetName(), file->GetName(), GetName(), file->GetName(), GetName(), fClassVersion);; 1088 } else {; 1089 Warning(""BuildCheck"", ""\n\; 1090 The StreamerInfo from %s does not match existing one (%s:%d)\n\; 1091 The existing one has not been used yet and will be discarded.\n\; 1092 Reading the file %s will work properly, however writing object of\n\; 1093 type %s will not work properly. Most likely the versi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:40292,load,load,40292,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['load'],['load']
Performance,"\a SmallVectorTemplateCommon::getFirstEl() is; 503/// well-defined.; 504template <typename T>; 505struct alignas(T) SmallVectorStorage<T, 0> {; 506};; 507 ; 508/// The size of the inline storage of an RVec.; 509/// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); 510/// unless the size of the buffer with 8 elements would be over a certain maximum size.; 511template <typename T>; 512struct RVecInlineStorageSize {; 513private:; 514#ifdef R__HAS_HARDWARE_INTERFERENCE_SIZE; 515 constexpr std::size_t cacheLineSize = std::hardware_destructive_interference_size;; 516#else; 517 // safe bet: assume the typical 64 bytes; 518 static constexpr std::size_t cacheLineSize = 64;; 519#endif; 520 static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);; 521 static constexpr unsigned maxInlineByteSize = 1024;; 522 ; 523public:; 524 static constexpr unsigned value =; 525 elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8);; 526};; 527 ; 528// A C++14-compatible implementation of std::uninitialized_value_construct; 529template <typename ForwardIt>; 530void UninitializedValueConstruct(ForwardIt first, ForwardIt last); 531{; 532#if __cplusplus < 201703L; 533 for (; first != last; ++first); 534 new (static_cast<void *>(std::addressof(*first))) typename std::iterator_traits<ForwardIt>::value_type();; 535#else; 536 std::uninitialized_value_construct(first, last);; 537#endif; 538}; 539 ; 540/// An unsafe function to reset the buffer for which this RVec is acting as a view.; 541///; 542/// \note This is a low-level method that _must_ be called on RVecs that are already non-owning:; 543/// - it does not put the RVec in ""non-owning mode"" (fCapacity == -1); 544/// - it does not free any owned buffer; 545template <typename T>; 546void ResetView(RVec<T> &v, T* addr, std::size_t sz); 547{; 548 v.fBeginX = addr;; 549 v.fSize = sz;; 550}; 551 ; 552} // namespace VecOps; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RVec_8hxx_source.html:18953,cache,cacheLineSize,18953,doc/v632/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RVec_8hxx_source.html,3,['cache'],['cacheLineSize']
Performance,"\param[in] columns Names of the columns/branches in input to the producer function (excluding slot and entry).; 482 /// \return the first node of the computation graph for which the new quantity is defined.; 483 ///; 484 /// This alternative implementation of `Define` is meant as a helper in writing entry-specific, thread-safe custom; 485 /// columns. The expression must be a callable of signature R(unsigned int, ULong64_t, T1, T2, ...) where `T1, T2...`; 486 /// are the types of the columns that the expression takes as input. The first parameter is reserved for an unsigned; 487 /// integer representing a ""slot number"". RDataFrame guarantees that different threads will invoke the expression with; 488 /// different slot numbers - slot numbers will range from zero to ROOT::GetThreadPoolSize()-1. The second parameter; 489 /// is reserved for a `ULong64_t` representing the current entry being processed by the current thread.; 490 ///; 491 /// The following two `Define`s are equivalent, although `DefineSlotEntry` is slightly more performant:; 492 /// ~~~{.cpp}; 493 /// int function(unsigned int, ULong64_t, double, double);; 494 /// Define(""x"", function, {""rdfslot_"", ""rdfentry_"", ""column1"", ""column2""}); 495 /// DefineSlotEntry(""x"", function, {""column1"", ""column2""}); 496 /// ~~~; 497 ///; 498 /// See Define() for more information.; 499 template <typename F>; 500 RInterface<Proxied, DS_t> DefineSlotEntry(std::string_view name, F expression, const ColumnNames_t &columns = {}); 501 {; 502 return DefineImpl<F, RDFDetail::ExtraArgsForDefine::SlotAndEntry>(name, std::move(expression), columns,; 503 ""DefineSlotEntry"");; 504 }; 505 // clang-format on; 506 ; 507 ////////////////////////////////////////////////////////////////////////////; 508 /// \brief Define a new column.; 509 /// \param[in] name The name of the defined column.; 510 /// \param[in] expression An expression in C++ which represents the defined value; 511 /// \return the first node of the computation graph for which t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:25406,perform,performant,25406,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['perform'],['performant']
Performance,"\sqrt{(P_{\mathrm{ext}} - a + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& a - 1 + \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}\]; Upper bound \(b\):; \[\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(b - P_{\mathrm{ext}} + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& b + 1 - \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}\]; The transformation of course also affects the parameter error matrix, so M does a transformation of the error matrix (and the “parabolic” parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in the last chapter.; 2.4 M strategy; At many places in the analysis of the \(\mbox{FCN}\) (the user provided function), M must decide whether to be “safe” and waste a few function calls in order to know where it is, or to be “fast” and attempt to get the requested results with the fewest possible calls at a certain risk of not obtaining the precision desired by the user. In order to allow the user to influence these decisions, there is a M class MnStrategy (see [api:strategy]) which the user can use to put different settings. In the current release, this MnStrategy can be instantiated with three different minimization quality levels for low (0), medium (1) and high (2) quality. Default settings for iteration cycles and tolerances are initialized then. The default setting is set for medium quality. Value 0 (low) indicates to M that i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:16247,perform,perform,16247,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,4,['perform'],['perform']
Performance,"\sum_{i=1}^{N}; \frac{y_i-f(i,a^{(t)})}{y_i}; \frac{\partial f(i,a^t)}{\partial a_k}=; \sum_{j=1}^{M}\sum_{i=1}^{N}; \frac{\partial f(i,a^{(t)})}{\partial a_j}; \frac{\partial f(i,a^{(t)})}{\partial a_k}; \Delta a_j^{(t)} \]. in gamma-ray spectra we have to fit together tens, hundreds of peaks simultaneously that sometimes represent thousands of parameters.; the calculation of the inversion matrix of such a size is practically impossible.; the awmi method is based on the assumption that the off-diagonal terms in the matrix A are equal to zero. \[; \Delta a_{k}^{(t+1)} = \alpha^{(t)}; \frac{; \sum_{i=1}^{N} \frac{e_{i}^{(t)}}{y_i}\frac{\partial f(i,a^{(t)})}{\partial a_k}; }{; \sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}; }; \]; where the error in the channel i is \(e_{i}^{(t)} = y_i-f(i,a^{(t)}); k=1,2,...,M\) and \(\alpha^{(t)}=1\) if the process is convergent or \(\alpha^{(t)}=0.5 \alpha^{(t-1)}\) if it is divergent. Another possibility is to optimize this coefficient.; The error of k-th parameter estimate is; \[; \Delta a_k^{(e)}=; \sqrt{\frac; {\sum_{i=1}^{N}\frac{e_i^2}{y_i}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}}; }; \]; Algorithm with higher powers w=1,2,3...:; \[; \Delta a_{k,w}^{(t+1)}=; \alpha^{(t)}; \frac; {\sum_{i=1}^{N} \frac{e_i}{y_i}\left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w-1}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w}\frac{1}{y_i}}; \]; We have implemented the non-symmetrical semi-empirical peak shape function. It contains the symmetrical Gaussian as well as non-symmetrical terms:; \[; f(i,a) =; \sum_{i=1}^{M} A(j); \left\{; exp\left[\frac{-(i-p(j))^2}{2\sigma^2}\right]; +\frac{1}{2}T.exp\left[\frac{(i-p(j))}{B\sigma}\right]; .erfc\left[\frac{(i-p(j))}{\sigma}+\frac{1}{2B}\right]; +\frac{1}{2}S.erfc\left[\frac{(i-p(j))}{\sigma}\right]; \right\}; \]; where T, S are relative amplitudes and B is a slope.; De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:37397,optimiz,optimize,37397,root/htmldoc/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html,1,['optimiz'],['optimize']
Performance,"] = -1;; 341 }; 342 ; 343 DeclareOptionRef( fCutRangeMin, GetNvar(), ""CutRangeMin"", ""Minimum of allowed cut range (set per variable)"" );; 344 DeclareOptionRef( fCutRangeMax, GetNvar(), ""CutRangeMax"", ""Maximum of allowed cut range (set per variable)"" );; 345 ; 346 fAllVarsI = new TString[GetNvar()];; 347 ; 348 for (UInt_t i=0; i<GetNvar(); i++) fAllVarsI[i] = ""NotEnforced"";; 349 ; 350 DeclareOptionRef(fAllVarsI, GetNvar(), ""VarProp"", ""Categorisation of cuts"");; 351 AddPreDefVal(TString(""NotEnforced""));; 352 AddPreDefVal(TString(""FMax""));; 353 AddPreDefVal(TString(""FMin""));; 354 AddPreDefVal(TString(""FSmart""));; 355}; 356 ; 357////////////////////////////////////////////////////////////////////////////////; 358/// process user options.; 359///; 360/// sanity check, do not allow the input variables to be normalised, because this; 361/// only creates problems when interpreting the cuts; 362 ; 363void TMVA::MethodCuts::ProcessOptions(); 364{; 365 if (IsNormalised()) {; 366 Log() << kWARNING << ""Normalisation of the input variables for cut optimisation is not"" << Endl;; 367 Log() << kWARNING << ""supported because this provides intransparent cut values, and no"" << Endl;; 368 Log() << kWARNING << ""improvement in the performance of the algorithm."" << Endl;; 369 Log() << kWARNING << ""Please remove \""Normalise\"" option from booking option string"" << Endl;; 370 Log() << kWARNING << ""==> Will reset normalisation flag to \""False\"""" << Endl;; 371 SetNormalised( kFALSE );; 372 }; 373 ; 374 if (IgnoreEventsWithNegWeightsInTraining()) {; 375 Log() << kFATAL << ""Mechanism to ignore events with negative weights in training not yet available for method: ""; 376 << GetMethodTypeName(); 377 << "" --> Please remove \""IgnoreNegWeightsInTraining\"" option from booking string.""; 378 << Endl;; 379 }; 380 ; 381 if (fFitMethodS == ""MC"" ) fFitMethod = kUseMonteCarlo;; 382 else if (fFitMethodS == ""MCEvents"") fFitMethod = kUseMonteCarloEvents;; 383 else if (fFitMethodS == ""GA"" ) fFitMethod = kUseGenet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:13155,perform,performance,13155,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['perform'],['performance']
Performance,"] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; With the mhs3 example, you should be able to see a canvas with two pads on it. Both pads keep histograms updated and filled by three different threads. With the CalcPi example, you should be able to see two threads calculating Pi with the given number of intervals as precision.; 23.2.4 TThread in More Details; Cling is not thread safe yet, and it will block the execution of the threads until it has finished executing.; 23.2.4.1 Asynchronous Actions; Different threads can work simultaneously with the same object. Some actions can be dangerous. For example, when two threads create a histogram object, ROOT allocates memory and puts them to the same collection. If it happens at the same time, the results are undetermined. To avoid this problem, the user has to synchronize these actions with:; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; The code between Lock() and UnLock() will be performed uninterrupted. No other threads can perform actions or access objects/collections while it is being executed. The methods TThread::Lock()and TThread::UnLock() internally use a global TMutex instance for locking.; The user may also define their own TMutex MyMutex instance and may locally protect their asynchronous actions by calling MyMutex.Lock() and MyMutex.UnLock().; 23.2.4.2 Synchronous Actions: TCondition; To synchronize the actions of different threads you can use the TCondition class, which provides a signaling mechanism. The TCondition instance must be accessible by all threads that need to use it, i.e. it should be a global object (or a member of the class which owns the threaded methods, see below). To create a TCondition object, a TMutex instance is required for the Wait and TimedWait locking methods. One can pass the address of an external mutex to the TCondition constructor:; TMutex MyMutex;; TCondition MyCondition(&MyMutex);; If zero is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1107713,perform,performed,1107713,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performed']
Performance,"], &fEXlow[ibegin], n);; 328 memmove(&fEXhigh[obegin], &fEXhigh[ibegin], n);; 329 memmove(&fEYlow[obegin], &fEYlow[ibegin], n);; 330 memmove(&fEYhigh[obegin], &fEYhigh[ibegin], n);; 331 memmove(&fEXlowd[obegin], &fEXlowd[ibegin], n);; 332 memmove(&fEXhighd[obegin], &fEXhighd[ibegin], n);; 333 memmove(&fEYlowd[obegin], &fEYlowd[ibegin], n);; 334 memmove(&fEYhighd[obegin], &fEYhighd[ibegin], n);; 335 }; 336 return kTRUE;; 337 } else {; 338 return kFALSE;; 339 }; 340}; 341 ; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Should be called from ctors after `fNpoints` has been set.; 345 ; 346Bool_t TGraphBentErrors::CtorAllocate(); 347{; 348 if (!fNpoints) {; 349 fEXlow = fEYlow = fEXhigh = fEYhigh = nullptr;; 350 fEXlowd = fEYlowd = fEXhighd = fEYhighd = nullptr;; 351 return kFALSE;; 352 }; 353 fEXlow = new Double_t[fMaxSize];; 354 fEYlow = new Double_t[fMaxSize];; 355 fEXhigh = new Double_t[fMaxSize];; 356 fEYhigh = new Double_t[fMaxSize];; 357 fEXlowd = new Double_t[fMaxSize];; 358 fEYlowd = new Double_t[fMaxSize];; 359 fEXhighd = new Double_t[fMaxSize];; 360 fEYhighd = new Double_t[fMaxSize];; 361 return kTRUE;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Protected function to perform the merge operation of a graph with asymmetric errors.; 366 ; 367Bool_t TGraphBentErrors::DoMerge(const TGraph *g); 368{; 369 if (g->GetN() == 0) return kFALSE;; 370 ; 371 Double_t *exl = g->GetEXlow();; 372 Double_t *exh = g->GetEXhigh();; 373 Double_t *eyl = g->GetEYlow();; 374 Double_t *eyh = g->GetEYhigh();; 375 ; 376 Double_t *exld = g->GetEXlowd();; 377 Double_t *exhd = g->GetEXhighd();; 378 Double_t *eyld = g->GetEYlowd();; 379 Double_t *eyhd = g->GetEYhighd();; 380 ; 381 if (!exl || !exh || !eyl || !eyh ||; 382 !exld || !exhd || !eyld || !eyhd) {; 383 if (g->IsA() != TGraph::Class() ); 384 Warning(""DoMerge"", ""Merging a %s is not compatible with a TGraphBentErrors - error",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:12102,perform,perform,12102,doc/master/TGraphBentErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html,1,['perform'],['perform']
Performance,"];; }; };; ; // The accumulator is initialized at this value by every thread.; double initValue = 1.;; ; // Multiplies all elements of the column ""x""; auto result = d.Aggregate(aggregator, merger, ""x"", initValue);; d#define d(i)Definition RSha256.hxx:102; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; ROOT::TSeqA pseudo container class which is a generator of indices.Definition TSeq.hxx:67; xDouble_t x[n]Definition legend1.C:17; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539. Definition at line 2879 of file RInterface.hxx. ◆ Aggregate() [2/2]. template<typename Proxied , typename DataSource = void> . template<typename AccFun , typename MergeFun , typename R = typename TTraits::CallableTraits<AccFun>::ret_type, typename ArgTypes = typename TTraits::CallableTraits<AccFun>::arg_types, typename U = TTraits::TakeFirstParameter_t<ArgTypes>, typename T = TTraits::TakeFirstParameter_t<TTraits::RemoveFirstParameter_t<ArgTypes>>> . RResultPtr< U > ROOT::RDF::RInterface< Proxied, DataSource >::Aggregate ; (; AccFun ; aggregator, . MergeFun ; merger, . std::string_view ; columnName = """" . ). inline . Execute a user-defined accumulation operation on the processed column values in each processing slot. ; Template Parameters. FThe type of the aggregator callable. Automatically deduced. ; UThe type of the aggregator variable. Must be default-constructible, copy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:34570,multi-thread,multi-threading,34570,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['multi-thread'],['multi-threading']
Performance,"^"" << nbits << Endl;; 2263 }; 2264 uint64_t range = static_cast<uint64_t>(pow(2, nbits));; 2265 ; 2266 ; 2267 // vector to save importances; 2268 std::vector<Double_t> importances(nbits);; 2269 // vector to save ROC; 2270 std::vector<Double_t> ROC(range);; 2271 ROC[0] = 0.5;; 2272 for (int i = 0; i < nbits; i++); 2273 importances[i] = 0;; 2274 ; 2275 Double_t SROC, SSROC; // computed ROC value; 2276 for (x = 1; x < range; x++) {; 2277 ; 2278 std::bitset<VIBITS> xbitset(x);; 2279 if (x == 0); 2280 continue; // data loader need at least one variable; 2281 ; 2282 // creating loader for seed; 2283 TMVA::DataLoader *seedloader = new TMVA::DataLoader(xbitset.to_string());; 2284 ; 2285 // adding variables from seed; 2286 for (int index = 0; index < nbits; index++) {; 2287 if (xbitset[index]); 2288 seedloader->AddVariable(varNames[index], 'F');; 2289 }; 2290 ; 2291 DataLoaderCopy(seedloader, loader);; 2292 seedloader->PrepareTrainingAndTestTree(loader->GetDataSetInfo().GetCut(""Signal""),; 2293 loader->GetDataSetInfo().GetCut(""Background""),; 2294 loader->GetDataSetInfo().GetSplitOptions());; 2295 ; 2296 // Booking Seed; 2297 BookMethod(seedloader, theMethod, methodTitle, theOption);; 2298 ; 2299 // Train/Test/Evaluation; 2300 TrainAllMethods();; 2301 TestAllMethods();; 2302 EvaluateAllMethods();; 2303 ; 2304 // getting ROC; 2305 ROC[x] = GetROCIntegral(xbitset.to_string(), methodTitle);; 2306 ; 2307 // cleaning information to process sub-seeds; 2308 TMVA::MethodBase *smethod = dynamic_cast<TMVA::MethodBase *>(fMethodsMap[xbitset.to_string().c_str()][0][0]);; 2309 TMVA::ResultsClassification *sresults = (TMVA::ResultsClassification *)smethod->Data()->GetResults(; 2310 smethod->GetMethodName(), Types::kTesting, Types::kClassification);; 2311 delete sresults;; 2312 delete seedloader;; 2313 this->DeleteAllMethods();; 2314 ; 2315 fMethodsMap.clear();; 2316 // removing global result because it is requiring a lot of RAM for all seeds; 2317 }; 2318 ; 2319 for (x = 0; x < range; x++) {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:96481,load,loader,96481,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"_CO_2. We will; 189want now to place symmetrically 1000 chambers on a pad, following a pattern; 190of 20 rows and 50 columns. One way to do this will be to replicate our chamber; 191by positioning it 1000 times in different positions of the pad. Unfortunately,; 192this is far from being the optimal way of doing what we want.; 193Imagine that we would like to find out which of the 1000 chambers is containing; 194a (x,y,z) point defined in the pad reference. You will never have to do that,; 195since the modeller will take care of it for you, but let's guess what it has; 196to do. The most simple algorithm will just loop over all daughters, convert; 197the point from mother to local reference and check if the current chamber; 198contains the point or not. This might be efficient for pads with few chambers,; 199but definitely not for 1000. Fortunately the modeler is smarter than that and; 200create for each volume some optimization structures called voxels (see Voxelization); 201to minimize the penalty having too many daughters, but if you have 100 pads like; 202this in your geometry you will anyway loose a lot in your tracking performance.; 203 ; 204 The way out when volumes can be arranged according to simple patterns is the; 205usage of divisions. We will describe them in detail later on. Let's think now; 206at a different situation : instead of 1000 chambers of the same type, we may; 207have several types of chambers. Let's say all chambers are cylindrical and have; 208a wire inside, but their dimensions are different. However, we would like all; 209to be represented by a single volume family, since they have the same properties.; 210*/; 211 ; 212/** \class TGeoVolumeMulti; 213\ingroup Geometry_classes; 214 ; 215Volume families; 216 ; 217A volume family is represented by the class TGeoVolumeMulti. It represents; 218a class of volumes having the same shape type and each member will be; 219identified by the same name and volume ID. Any operation applied to a; 220TGeoVo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:10933,optimiz,optimization,10933,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"_EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOT::Internal::DisableParBranchProcessingvoid DisableParBranchProcessing()Globally disables the IMT use case of parallel branch processing, deactivating the corresponding lock...Definition TROOT.cxx:434; ROOT::Internal::EnableParBranchProcessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROOT.cxx:420; ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal::GetROOT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::RequiresCleanupBool_t RequiresCleanup(TObject &obj)Definition TROOT.h:386; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; ROOT::EnableThreadSafetyvoid EnableThreadSafety()Enable support for multi-threading within the ROOT code in particular, enables the global mutex to ma...Definition TROOT.cxx:501; ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; ROOT::GetROOTTROOT * GetROOT()Definition TROOT.cxx:472; ROOT::DisableImplicitMTvoid DisableImplicitMT()Disables the implicit multi-threading in ROOT (see EnableImplicitMT).Definition TROOT.cxx:556; v@ vDefinition rootcling_impl.cxx:3687; lTLine lDefinition texta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:52852,multi-thread,multi-threading,52852,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,1,['multi-thread'],['multi-threading']
Performance,"_EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOT::Internal::DisableParBranchProcessingvoid DisableParBranchProcessing()Globally disables the IMT use case of parallel branch processing, deactivating the corresponding lock...Definition TROOT.cxx:434; ROOT::Internal::EnableParBranchProcessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROOT.cxx:420; ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal::GetROOT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::RequiresCleanupBool_t RequiresCleanup(TObject &obj)Definition TROOT.h:386; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; ROOT::EnableThreadSafetyvoid EnableThreadSafety()Enable support for multi-threading within the ROOT code in particular, enables the global mutex to ma...Definition TROOT.cxx:501; ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; ROOT::GetROOTTROOT * GetROOT()Definition TROOT.cxx:472; ROOT::DisableImplicitMTvoid DisableImplicitMT()Disables the implicit multi-threading in ROOT (see EnableImplicitMT).Definition TROOT.cxx:556; v@ vDefinition rootcling_impl.cxx:3699; lTLine lDefinition texta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:52851,multi-thread,multi-threading,52851,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,1,['multi-thread'],['multi-threading']
Performance,"_LATER() [3/5]. ROOT::TBufferMerger::_R__DEPRECATED_LATER ; (; ""The queuing mechanism in TBufferMerger was removed in ROOT v6.32"" ; ); const. inline . Definition at line 71 of file TBufferMerger.hxx. ◆ _R__DEPRECATED_LATER() [4/5]. ROOT::TBufferMerger::_R__DEPRECATED_LATER ; (; ""The queuing mechanism in TBufferMerger was removed in ROOT v6.32"" ; ). inline . Definition at line 83 of file TBufferMerger.hxx. ◆ _R__DEPRECATED_LATER() [5/5]. ROOT::TBufferMerger::_R__DEPRECATED_LATER ; (; ""The queuing mechanism in TBufferMerger was removed in ROOT v6.32"" ; ). ◆ GetFile(). std::shared_ptr< TBufferMergerFile > ROOT::TBufferMerger::GetFile ; (; ). Returns a TBufferMergerFile to which data can be written. ; At the end, all TBufferMergerFiles get merged into the output file. The user is responsible to ""cd"" into the file to associate objects such as histograms or trees to it.; After the creation of this file, the user must reset the kMustCleanup bit on any objects attached to it and take care of their deletion, as there is a possibility that a race condition will happen that causes a crash if ROOT manages these objects. ; Definition at line 56 of file TBufferMerger.cxx. ◆ GetMergeOptions(). const char * ROOT::TBufferMerger::GetMergeOptions ; (; ). Returns the current merge options. ; Definition at line 65 of file TBufferMerger.cxx. ◆ GetNotrees(). Bool_t ROOT::TBufferMerger::GetNotrees ; (; ); const. inline . Returns whether the file has been marked as not containing any TTree objects and thus that steps that are specific to TTree can be skipped. ; Definition at line 102 of file TBufferMerger.hxx. ◆ Init(). void ROOT::TBufferMerger::Init ; (; std::unique_ptr< TFile > ; output). private . Definition at line 36 of file TBufferMerger.cxx. ◆ Merge(). void ROOT::TBufferMerger::Merge ; (; ROOT::TBufferMergerFile * ; memfile). private . Definition at line 76 of file TBufferMerger.cxx. ◆ operator=(). TBufferMerger & ROOT::TBufferMerger::operator= ; (; const TBufferMerger & ; ). private ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TBufferMerger.html:5353,race condition,race condition,5353,doc/v632/classROOT_1_1TBufferMerger.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TBufferMerger.html,2,['race condition'],['race condition']
Performance,"_MACOSX; 3306 ; 3307#if defined (R__LINUX) || defined (R__FBSD); 3308 ; 3309////////////////////////////////////////////////////////////////////////////////; 3310/// Callback for dl_iterate_phdr(), see `man dl_iterate_phdr`.; 3311/// Collects opened libraries.; 3312 ; 3313static int callback_for_dl_iterate_phdr(struct dl_phdr_info *info, size_t size, void *data); 3314{; 3315 // This function is called through UpdateListOfLoadedSharedLibraries() which is locked.; 3316 static std::unordered_set<decltype(info->dlpi_addr)> sKnownLoadedLibBaseAddrs;; 3317 ; 3318 auto newLibs = static_cast<std::vector<std::string>*>(data);; 3319 if (!sKnownLoadedLibBaseAddrs.count(info->dlpi_addr)) {; 3320 // Skip \0, """", and kernel pseudo-libs linux-vdso.so.1 or linux-gate.so.1; 3321 if (info->dlpi_name && info->dlpi_name[0]; 3322#if defined(R__FBSD); 3323 //skip the executable (with null addr); 3324 && info->dlpi_addr; 3325 //has no path; 3326 && strncmp(info->dlpi_name, ""[vdso]"", 6); 3327 //the linker does not like to be mmapped; 3328 //causes a crash in cling::DynamicLibraryManager::loadLibrary()); 3329 //with error message ""mmap of entire address space failed: Cannot allocate memory""; 3330 && strncmp(info->dlpi_name, ""/libexec/ld-elf.so.1"", 20); 3331#endif; 3332 && strncmp(info->dlpi_name, ""linux-vdso.so"", 13); 3333 && strncmp(info->dlpi_name, ""linux-vdso32.so"", 15); 3334 && strncmp(info->dlpi_name, ""linux-vdso64.so"", 15); 3335 && strncmp(info->dlpi_name, ""linux-gate.so"", 13)); 3336 newLibs->emplace_back(info->dlpi_name);; 3337 sKnownLoadedLibBaseAddrs.insert(info->dlpi_addr);; 3338 }; 3339 // No matter what the doc says, return != 0 means ""stop the iteration"".; 3340 return 0;; 3341}; 3342 ; 3343#endif // R__LINUX || R__FBSD; 3344 ; 3345 ; 3346////////////////////////////////////////////////////////////////////////////////; 3347 ; 3348void TCling::UpdateListOfLoadedSharedLibraries(); 3349{; 3350#if defined(R__WIN32) || defined(__CYGWIN__); 3351 HMODULE hModules[1024];; 3352 void *hPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:128737,load,loadLibrary,128737,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loadLibrary']
Performance,"______________________; 4615void TFile::SetFileReadCalls(Int_t readcalls) { fgReadCalls = readcalls; }; 4616 ; 4617//______________________________________________________________________________; 4618Long64_t TFile::GetFileCounter() { return fgFileCounter; }; 4619 ; 4620//______________________________________________________________________________; 4621void TFile::IncrementFileCounter() { fgFileCounter++; }; 4622 ; 4623////////////////////////////////////////////////////////////////////////////////; 4624/// Sets the directory where to locally stage/cache remote files.; 4625/// If the directory is not writable by us return kFALSE.; 4626 ; 4627Bool_t TFile::SetCacheFileDir(std::string_view cachedir, Bool_t operatedisconnected,; 4628 Bool_t forcecacheread ); 4629{; 4630 TString cached{cachedir};; 4631 if (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 4636 gSystem->mkdir(cached, kTRUE);; 4637 if (gSystem->AccessPathName(cached, kFileExists)) {; 4638 ::Error(""TFile::SetCacheFileDir"", ""no sufficient permissions on cache directory %s or cannot create it"", TString(cachedir).Data());; 4639 fgCacheFileDir = """";; 4640 return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCacheFileDir(); 4656{; 4657 return fgCacheFileDir;; 4658}; 4659 ; 4660////////////////////////////////////////////////////////////////////////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the min",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:169345,cache,cached,169345,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,6,['cache'],"['cache', 'cached', 'cachedir']"
Performance,"___________________________________________________________; 3677//; 3678// Command RESTORE; 3679//; 3680 if( !strncmp(comd.Data(),""RES"",3) ) {; 3681 Printf("" ***>REStore [code]"");; 3682 Printf("" If no [code] is specified, this command restores all previously"");; 3683 Printf("" FIXed parameters to variable status. If [code]=1, then only"");; 3684 Printf("" the last parameter FIXed is restored to variable status."");; 3685 Printf("" If code is neither zero nor one, the command is ignored."");; 3686 goto L99;; 3687 }; 3688//______________________________________________________________________________; 3689//; 3690// Command RETURN; 3691//; 3692 if( !strncmp(comd.Data(),""RET"",3) ) {; 3693 Printf("" ***>RETURN"");; 3694 Printf("" Signals the end of a data block, and instructs Minuit to return"");; 3695 Printf("" to the program which called it. The RETurn command first"");; 3696 Printf("" causes Minuit to CALL FCN with IFLAG=3, in order to allow FCN"");; 3697 Printf("" to perform any calculations associated with the final fitted"");; 3698 Printf("" parameter values, unless a CALL FCN 3 command has already been"");; 3699 Printf("" executed at the current FCN value."");; 3700 goto L99;; 3701 }; 3702//______________________________________________________________________________; 3703//; 3704// Command SAVE; 3705//; 3706 if( !strncmp(comd.Data(),""SAV"",3) ) {; 3707 Printf("" ***>SAVe"");; 3708 Printf("" Causes the current parameter values to be saved on a file in"");; 3709 Printf("" such a format that they can be read in again as Minuit"");; 3710 Printf("" parameter definitions. If the covariance matrix exists, it is"");; 3711 Printf("" also output in such a format. The unit number is by default 7,"");; 3712 Printf("" or that specified by the user in their call to MINTIO or"");; 3713 Printf("" MNINIT. The user is responsible for opening the file previous"");; 3714 Printf("" to issuing the [SAVe] command (except where this can be done"");; 3715 Printf("" interactively)."");; 3716 goto L99;; 3717 }; 3718//_______",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:120829,perform,perform,120829,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['perform'],['perform']
Performance,"_anaIntCache!; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TMatrixDSym_cov; TMatrixDSym_covI; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Double_t_det; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; map<int,GenData>_genCache!; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooListProxy_mu; TVectorD_muVec! Do not persist; static Int_tRooPrintable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMultiVarGaussian.html:39168,cache,cache,39168,root/html532/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html532/RooMultiVarGaussian.html,1,['cache'],['cache']
Performance,"_anaIntCache!; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TMatrixDSym_cov; TMatrixDSym_covI; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Double_t_det; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; map<int,GenData>_genCache!; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooListProxy_mu; TVectorD_muVec! Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMultiVarGaussian.html:37074,cache,cache,37074,root/html526/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html526/RooMultiVarGaussian.html,3,['cache'],['cache']
Performance,"_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedReal::_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_nameP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedReal.html:34695,cache,cache,34695,root/html534/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedReal.html,3,['cache'],['cache']
Performance,"_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TF1*_func; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTFnPdfBinding.html:41637,cache,cache,41637,root/html602/RooTFnPdfBinding.html,https://root.cern,https://root.cern/root/html602/RooTFnPdfBinding.html,4,['cache'],['cache']
Performance,"_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_flatSFInt; Bool_t_flip; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGExpModel.html:43288,cache,cache,43288,root/html534/RooGExpModel.html,https://root.cern,https://root.cern/root/html534/RooGExpModel.html,2,['cache'],['cache']
Performance,"_ci;  ; typedef Set_t::iterator Set_i;  ; typedef std::set< TEveElement * > Set_t;  ; typedef sLTI_t::iterator sLTI_i;  ; typedef sLTI_t::reverse_iterator sLTI_ri;  ; typedef std::set< TEveListTreeInfo > sLTI_t;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TEveCaloData (const char *n=""TEveCalData"", const char *t="""");  ;  ~TEveCaloData () override;  ; virtual void CellSelectionChanged ();  Tell users (TEveCaloViz instances using this data) that cell selection has changed and they should update selection cache if necessary. ;  ; virtual void DataChanged ();  Tell users (TEveCaloViz instances using this data) that data has changed and they should update the limits/scales etc. ;  ; Bool_t Empty () const;  ; void FillImpliedSelectedSet (Set_t &impSelSet) override;  Populate set impSelSet with derived / dependant elements. ;  ; virtual void GetCellData (const CellId_t &id, CellData_t &data) const =0;  ; virtual void GetCellList (Float_t etaMin, Float_t etaMax, Float_t phi, Float_t phiRng, vCellId_t &out) const =0;  ; vCellId_t & GetCellsHighlighted ();  ; vCellId_t & GetCellsSelected ();  ; virtual Float_t GetEps () const;  ; virtual TAxis * GetEtaBins () const;  ; virtual void GetEtaLimits (Double_t &min, Double_t &max) const =0;  ; TString GetHighlightTooltip () override;  ; virtual Float_t GetMaxVal (Bool_t et) const;  ; Int_t GetNSlices () const;  ; virtual T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCaloData.html:2749,cache,cache,2749,doc/master/classTEveCaloData.html,https://root.cern,https://root.cern/doc/master/classTEveCaloData.html,1,['cache'],['cache']
Performance,"_class);  There is special streamer for the class. ;  ; static void StreamerInstrumented (const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class);  Case of instrumented class with a library. ;  ; static void StreamerStreamerInfo (const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class);  Case of where we should directly use the StreamerInfo. ;  ; static void StreamerTObject (const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class);  Case of TObjects. ;  ; static void StreamerTObjectEmulated (const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class);  Case of TObjects when we do not have the library defining the class. ;  ; static void StreamerTObjectInitialized (const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class);  Case of TObjects when fIsOffsetStreamerSet is known to have been set. ;  . Private Attributes; TViewPubDataMembers * fAllPubData;  ; TViewPubFunctions * fAllPubMethod;  ; std::atomic< TList * > fBase;  ; std::atomic< Bool_t > fCanLoadClassInfo;  Whether info was loaded from a root pcm. ;  ; std::atomic< Char_t > fCanSplit;  ; std::atomic< UInt_t > fCheckSum;  ; ClassInfo_t * fClassInfo;  ; TList * fClassMenuList;  ; Long_t fClassProperty;  Property See TClass::Property() for details. ;  ; Version_t fClassVersion;  ; TVirtualCollectionProxy * fCollectionProxy;  ; TString fContextMenuTitle;  ; ConvSIMap_t fConversionStreamerInfo;  ; ClassConvStreamerFunc_t fConvStreamerFunc;  ; std::atomic< TVirtualStreamerInfo * > fCurrentInfo;  Current 'state' of the class (Emulated,Interpreted,Loaded) ;  ; std::atomic< TListOfDataMembers * > fData;  ; Short_t fDeclFileLine;  ; const char * fDeclFileName;  ; ROOT::DelFunc_t fDelete;  ; ROOT::DelArrFunc_t fDeleteArray;  ; ROOT::DesFunc_t fDestructor;  ; ROOT::DirAutoAdd_t fDirAutoAdd;  ; std::atomic< TListOfEnums * > fEnums;  ; TListOfFunctionTemplates * fFuncTemplate;  ; IsAGlobalFunc_t fGlobalIsA;  pointer to the class's IsA pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:43412,load,loaded,43412,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,2,['load'],['loaded']
Performance,_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsReal*_cloneModelPointer to cloned model; RooAbsReal*_clonePdfPointer to cloned PDF ; RooAbsReal*_cloneVarPointer to cloned convolution variable; RooNumIntConfig_convIntConfigConfiguration of numeric convolution integral ;; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_t_doProfSwitch to activate profiling option; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; RooConvIntegrandBinding*_integrand! Binding of Convolution Integrand function; RooAbsIntegrator*_integrator! Numeric integrator of convolution integrand; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet_ownedClonedModelSetOwning set of cloned model components; RooArgSet_ownedClonedPdfSet,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvolution.html:33394,cache,cache,33394,root/html526/RooNumConvolution.html,https://root.cern,https://root.cern/root/html526/RooNumConvolution.html,4,['cache'],['cache']
Performance,"_connections;; 20976 int max_active_connections = (int)ctx->max_active_connections;; 20977 int total_connections = (int)ctx->total_connections;; 20978 if (active_connections > max_active_connections) {; 20979 max_active_connections = active_connections;; 20980 }; 20981 if (active_connections > total_connections) {; 20982 total_connections = active_connections;; 20983 }; 20984 ; 20985 /* Connections information */; 20986 mg_snprintf(NULL,; 20987 NULL,; 20988 block,; 20989 sizeof(block),; 20990 "",%s\""connections\"" : {%s""; 20991 ""\""active\"" : %i,%s""; 20992 ""\""maxActive\"" : %i,%s""; 20993 ""\""total\"" : %i%s""; 20994 ""}"",; 20995 eol,; 20996 eol,; 20997 active_connections,; 20998 eol,; 20999 max_active_connections,; 21000 eol,; 21001 total_connections,; 21002 eol);; 21003 context_info_length += mg_str_append(&buffer, end, block);; 21004 ; 21005 /* Queue information */; 21006#if !defined(ALTERNATIVE_QUEUE); 21007 mg_snprintf(NULL,; 21008 NULL,; 21009 block,; 21010 sizeof(block),; 21011 "",%s\""queue\"" : {%s""; 21012 ""\""length\"" : %i,%s""; 21013 ""\""filled\"" : %i,%s""; 21014 ""\""maxFilled\"" : %i,%s""; 21015 ""\""full\"" : %s%s""; 21016 ""}"",; 21017 eol,; 21018 eol,; 21019 ctx->sq_size,; 21020 eol,; 21021 ctx->sq_head - ctx->sq_tail,; 21022 eol,; 21023 ctx->sq_max_fill,; 21024 eol,; 21025 (ctx->sq_blocked ? ""true"" : ""false""),; 21026 eol);; 21027 context_info_length += mg_str_append(&buffer, end, block);; 21028#endif; 21029 ; 21030 /* Requests information */; 21031 mg_snprintf(NULL,; 21032 NULL,; 21033 block,; 21034 sizeof(block),; 21035 "",%s\""requests\"" : {%s""; 21036 ""\""total\"" : %lu%s""; 21037 ""}"",; 21038 eol,; 21039 eol,; 21040 (unsigned long)ctx->total_requests,; 21041 eol);; 21042 context_info_length += mg_str_append(&buffer, end, block);; 21043 ; 21044 /* Data information */; 21045 total_data_read =; 21046 mg_atomic_add64((volatile int64_t *)&ctx->total_data_read, 0);; 21047 total_data_written =; 21048 mg_atomic_add64((volatile int64_t *)&ctx->total_data_written, 0);; 21049 mg_snprintf(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:627579,queue,queue,627579,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['queue'],['queue']
Performance,"_connections;; 20977 int max_active_connections = (int)ctx->max_active_connections;; 20978 int total_connections = (int)ctx->total_connections;; 20979 if (active_connections > max_active_connections) {; 20980 max_active_connections = active_connections;; 20981 }; 20982 if (active_connections > total_connections) {; 20983 total_connections = active_connections;; 20984 }; 20985 ; 20986 /* Connections information */; 20987 mg_snprintf(NULL,; 20988 NULL,; 20989 block,; 20990 sizeof(block),; 20991 "",%s\""connections\"" : {%s""; 20992 ""\""active\"" : %i,%s""; 20993 ""\""maxActive\"" : %i,%s""; 20994 ""\""total\"" : %i%s""; 20995 ""}"",; 20996 eol,; 20997 eol,; 20998 active_connections,; 20999 eol,; 21000 max_active_connections,; 21001 eol,; 21002 total_connections,; 21003 eol);; 21004 context_info_length += mg_str_append(&buffer, end, block);; 21005 ; 21006 /* Queue information */; 21007#if !defined(ALTERNATIVE_QUEUE); 21008 mg_snprintf(NULL,; 21009 NULL,; 21010 block,; 21011 sizeof(block),; 21012 "",%s\""queue\"" : {%s""; 21013 ""\""length\"" : %i,%s""; 21014 ""\""filled\"" : %i,%s""; 21015 ""\""maxFilled\"" : %i,%s""; 21016 ""\""full\"" : %s%s""; 21017 ""}"",; 21018 eol,; 21019 eol,; 21020 ctx->sq_size,; 21021 eol,; 21022 ctx->sq_head - ctx->sq_tail,; 21023 eol,; 21024 ctx->sq_max_fill,; 21025 eol,; 21026 (ctx->sq_blocked ? ""true"" : ""false""),; 21027 eol);; 21028 context_info_length += mg_str_append(&buffer, end, block);; 21029#endif; 21030 ; 21031 /* Requests information */; 21032 mg_snprintf(NULL,; 21033 NULL,; 21034 block,; 21035 sizeof(block),; 21036 "",%s\""requests\"" : {%s""; 21037 ""\""total\"" : %lu%s""; 21038 ""}"",; 21039 eol,; 21040 eol,; 21041 (unsigned long)ctx->total_requests,; 21042 eol);; 21043 context_info_length += mg_str_append(&buffer, end, block);; 21044 ; 21045 /* Data information */; 21046 total_data_read =; 21047 mg_atomic_add64((volatile int64_t *)&ctx->total_data_read, 0);; 21048 total_data_written =; 21049 mg_atomic_add64((volatile int64_t *)&ctx->total_data_written, 0);; 21050 mg_snprintf(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:627612,queue,queue,627612,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['queue'],['queue']
Performance,"_fft_Mf' created with bounds [0,3.14159]; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x77ddb60 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7953590 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7b5fca0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(Mf_over_Mf_Int[psi]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_Mf_over_Mf_Int[psi]_MfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7caf5a0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi] for nset () with code 1 from preexisting content.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7ef8390 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf210__angularconv_8py.html:5173,optimiz,optimization,5173,doc/master/rf210__angularconv_8py.html,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8py.html,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,_foams.root␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAMulticlass_DL_CPU.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: BDTG for Multiclass classification performance; : ; : Dataset[dataset] : Create results for testing; : Dataset[dataset] : Multiclass evaluation of BDTG on testing sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 1.01 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : Test method: MLP for Multiclass classification performance; : ; : Dataset[dataset] : Create results for testing; : Dataset[dataset] : Multiclass evaluation of MLP on testing sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.0114 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : Test method: PDEFoam for Multiclass classification performance; : ; : Dataset[dataset] : Create results for testing; : Dataset[dataset] : Multiclass evaluation of PDEFoam on testing sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.122 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : Test method: DL_CPU for Multiclass classification performance; : ; : Dataset[dataset] : Create results for testing; : Dataset[dataset] : Multiclass evaluation of DL_CPU on testing sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.105 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : ␛[1mEvaluate all methods␛[0m; : Evaluate multiclass classification method: BDTG; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_BDTG : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:20131,perform,performance,20131,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['perform'],['performance']
Performance,_fold2.weights.xml; : Reading weight file: datasetcv/weights/TMVACrossValidation_BDTG_fold2.weights.xml; : ; : ; : ========================================; : ========================================; : ; <HEADER> Factory : Booking method: Fisher_fold1; : ; <HEADER> Fisher_fold1 : Results for Fisher coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : x: +0.449; : y: +0.436; : (offset): +0.019; : -----------------------; : Elapsed time for training with 1000 events: 0.000364 sec ; <HEADER> Fisher_fold1 : [datasetcv] : Evaluation of Fisher_fold1 on training sample (1000 events); : Elapsed time for evaluation of 1000 events: 7.51e-05 sec ; : Creating xml weight file: datasetcv/weights/TMVACrossValidation_Fisher_fold1.weights.xml; : Creating standalone class: datasetcv/weights/TMVACrossValidation_Fisher_fold1.class.C; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: Fisher_fold1 for Classification performance; : ; <HEADER> Fisher_fold1 : [datasetcv] : Evaluation of Fisher_fold1 on testing sample (998 events); : Elapsed time for evaluation of 998 events: 0.000121 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: Fisher_fold1; : ; <HEADER> Fisher_fold1 : [datasetcv] : Loop over test events and fill histograms with classifier response...; : ; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : datasetcv Fisher_fold1 : 0.976; : -------------------------------------------------------------------------------------------------------------------; : ; : Testing efficiency compared to training efficiency (overtraining check); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA Signal efficiency: from test sample (fr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:9324,perform,performance,9324,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['perform'],['performance']
Performance,"_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,double,unsigned int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html:32697,cache,cache,32697,root/html526/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html,https://root.cern,https://root.cern/root/html526/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html,2,['cache'],['cache']
Performance,"_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,unsigned int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html:32697,cache,cache,32697,root/html526/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html526/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html,2,['cache'],['cache']
Performance,"_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,int>funcFunction pointer reference; RooRealProxyxArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction1Binding_double_int_.html:33524,cache,cache,33524,root/html532/RooCFunction1Binding_double_int_.html,https://root.cern,https://root.cern/root/html532/RooCFunction1Binding_double_int_.html,1,['cache'],['cache']
Performance,_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramsEffective parameters of this p.d.f.; RooRealProxy_pdf1First input p.d.f; RooRealProxy_pdf2Second input p.d.f; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist o,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFFTConvPdf.html:49776,cache,cache,49776,root/html602/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html602/RooFFTConvPdf.html,2,['cache'],['cache']
Performance,"_higgs, ""Higgs MC"", ""f""); 277legend.AddEntry(h_zz, ""ZZ MC"", ""f""); 278legend.AddEntry(h_other, ""Other MC"", ""f""); 279legend.AddEntry(h_weight_down, ""Total MC Variations Down"", ""l""); 280legend.AddEntry(h_weight_up, ""Total MC Variations Up"", ""l""); 281legend.AddEntry(h_nominal, ""Total MC Uncertainty"", ""f""); 282legend.Draw(); 283 ; 284text = ROOT.TLatex(); 285text.SetTextFont(72); 286text.SetTextSize(0.04); 287text.DrawLatexNDC(0.19, 0.85, ""ATLAS""); 288text.SetTextFont(42); 289text.DrawLatexNDC(0.19 + 0.15, 0.85, ""Open Data""); 290text.SetTextSize(0.035); 291text.DrawLatexNDC(0.21, 0.80, ""#sqrt{s} = 13 TeV, 10 fb^{-1}""); 292 ; 293c1.Update(); 294 ; 295# Save the plot; 296c1.SaveAs(""df106_HiggsToFourLeptons_python.png""); 297print(""Saved figure to df106_HiggsToFourLeptons_python.png""); SetFillStyleOption_t Option_t SetFillStyleDefinition TGWin32VirtualXProxy.cxx:46; SetLineColorOption_t Option_t SetLineColorDefinition TGWin32VirtualXProxy.cxx:54; SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; ROOT::RDF::Experimental::FromSpecROOT::RDataFrame FromSpec(const std::string &jsonFile)Factory method to create an RDataFrame from a JSON specification file.Definition RDataFrame.cxx:1906; ROOT::RDF::Experimental::VariationsForRResultMap< T > VariationsFor(RResultPtr< T > resPtr)Produce all required systematic variations for the given result.Definition RDFHelpers.hxx:219; ROOT::RDF::Experimental::AddProgressBarvoid AddProgressBar(ROOT::RDF::RNode df)Add ProgressBar to a ROOT::RDF::RNode.Definition RDFHelpers.cxx:373; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::RDF::TH1DModelA struct which stores the parameters of a TH1D.Definition HistoModels.hxx:30. tutorialsdataframedf106_HiggsToFourLeptons.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:07 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:13760,multi-thread,multi-threading,13760,doc/master/df106__HiggsToFourLeptons_8py_source.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html,1,['multi-thread'],['multi-threading']
Performance,"_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; int_m1; int_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLegendre(). RooLegendre(const char* name, const char* title, RooAbsReal& ctheta, int l, int m = 0); TODO: for now, we assume that ctheta has a range [-1,1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLegendre.html:35999,cache,cache,35999,root/html602/RooLegendre.html,https://root.cern,https://root.cern/root/html602/RooLegendre.html,4,['cache'],['cache']
Performance,"_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction2Ref<VO,VI1,VI2> Streamer(TBuffer& ); Custom streamer for function",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction2Binding_double_double_double_.html:35262,cache,cache,35262,root/html534/RooCFunction2Binding_double_double_double_.html,https://root.cern,https://root.cern/root/html534/RooCFunction2Binding_double_double_double_.html,2,['cache'],['cache']
Performance,"_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; vector<Double_t>_realRefReference values for reals; RooListProxy_realSetList of reals to track ; TIterator*_realSetIter! do not persist; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooChangeTracker(); Default constructor. RooChangeTracker(const char* name, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChangeTracker.html:35412,cache,cache,35412,root/html534/RooChangeTracker.html,https://root.cern,https://root.cern/root/html534/RooChangeTracker.html,2,['cache'],['cache']
Performance,"_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderDerivation order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; ROOT::Math::RichardsonDerivator*_rd! Derivator; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooDerivative(); Default constructor. RooDerivative(const char* name, const char* t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDerivative.html:36544,cache,cache,36544,root/html602/RooDerivative.html,https://root.cern,https://root.cern/root/html602/RooDerivative.html,4,['cache'],['cache']
Performance,"_localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static RooCategory * _dummyBlindState = nullptr;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsHiddenReal.html:58199,cache,cache,58199,doc/master/classRooAbsHiddenReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsHiddenReal.html,1,['cache'],['cache']
Performance,"_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; TString_sigCatNameName of accept state of accept/reject category; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooEfficiency.html:39148,cache,cache,39148,root/html526/RooEfficiency.html,https://root.cern,https://root.cern/root/html526/RooEfficiency.html,2,['cache'],['cache']
Performance,"_normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooKeysPdf.html:45421,cache,cache,45421,root/html602/RooKeysPdf.html,https://root.cern,https://root.cern/root/html602/RooKeysPdf.html,6,['cache'],['cache']
Performance,"_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfItr!; RooListProxy_pdfList; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooMomentMorph::Setting_setting; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; TIterator*_varItr! do not persist; RooSetProxy_varList; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMomentMorph.html:39407,cache,cache,39407,root/html526/RooMomentMorph.html,https://root.cern,https://root.cern/root/html526/RooMomentMorph.html,2,['cache'],['cache']
Performance,"_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxysigma; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGaussian.html:39011,cache,cache,39011,root/html528/RooGaussian.html,https://root.cern,https://root.cern/root/html528/RooGaussian.html,4,['cache'],['cache']
Performance,"_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxywidth; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBreitWigner.html:39139,cache,cache,39139,root/html528/RooBreitWigner.html,https://root.cern,https://root.cern/root/html528/RooBreitWigner.html,2,['cache'],['cache']
Performance,"_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction3PdfBinding_double_unsigned_int_double_double_.html:40492,cache,cache,40492,root/html532/RooCFunction3PdfBinding_double_unsigned_int_double_double_.html,https://root.cern,https://root.cern/root/html532/RooCFunction3PdfBinding_double_unsigned_int_double_double_.html,2,['cache'],['cache']
Performance,"_ownedComponents! Set of owned component; TIterator*_pdfIter! Iterator of PDF list; RooListProxy_pdfListList of PDF components; RooLinkedList_pdfNSetListList of PDF component normalization sets; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; TNamed*_refRangeNameReference range name for interpretation of conditional products; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; Bool_t_selfNormIs self-normalized; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useDefaultGenUse default or distributed event generator; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProdPdf.html:43354,cache,cache,43354,root/html528/RooProdPdf.html,https://root.cern,https://root.cern/root/html528/RooProdPdf.html,2,['cache'],['cache']
Performance,"_paramsEffective parameters of this p.d.f.; RooRealProxy_pdf1First input p.d.f; RooRealProxy_pdf2Second input p.d.f; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Double_t_shift1; Double_t_shift2; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_xConvolution observable; RooRealProxy_xprimeInput function representing value of convolution observable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFFTConvPdf(const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFFTConvPdf.html:50575,cache,cache,50575,root/html602/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html602/RooFFTConvPdf.html,4,['cache'],['cache']
Performance,"_ptr< std::atomic< TDirectory * > >;  Pointer to a list of TContext object pointing to this TDirectory. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TFile; virtual Long64_t DirCreateEntry (TDirectory *);  ; virtual Int_t DirReadKeys (TDirectory *);  ; virtual void DirWriteHeader (TDirectory *);  ; virtual void DirWriteKeys (TDirectory *);  ; Bool_t FlushWriteCache ();  Flush the write cache if active. ;  ; virtual EAsyncOpenStatus GetAsyncOpenStatus ();  ; virtual InfoListRet GetStreamerInfoListImpl (bool lookupSICache);  See documentation of GetStreamerInfoList for more details. ;  ; Int_t MakeProjectParMake (const char *packname, const char *filename);  Create makefile at 'filemake' for PAR package 'pack'. ;  ; Int_t MakeProjectParProofInf (const char *packname, const char *proofinfdir);  Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'. ;  ; Int_t ReadBufferViaCache (char *buf, Int_t len);  Read buffer via cache. ;  ; virtual Int_t SysClose (Int_t fd);  Interface to system close. All arguments like in POSIX close(). ;  ; virtual Int_t SysOpen (const char *pathname, Int_t flags, UInt_t mode);  Interface to system open. All arguments like in POSIX open(). ;  ; virtual Int_t SysRead (Int_t fd, void *buf, Int_t len);  Interface to system read. All arguments like in POSIX read(). ;  ; virtual Long64_t SysSeek (Int_t fd, Long64_t offset, Int_t whence);  Interface to system lseek. ;  ; virtual Int_t SysStat (Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime);  Return file stat information. ;  ; virtual Int_t SysSync (Int_t fd);  Interface to system fsync. All arguments like in POSIX fsync(). ;  ; virtual Int_t SysWrite (Int_t fd, const void *buf, Int_t len);  Interface to system write. All arguments like in POSIX write(). ;  ; Int_t WriteBufferViaCache (const char *buf, Int_t len);  Write buffer via cache. ;  ;  Protected Member Functions inhe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixFile.html:32810,cache,cache,32810,doc/master/classTDavixFile.html,https://root.cern,https://root.cern/doc/master/classTDavixFile.html,2,['cache'],['cache']
Performance,"_t &columnList); 1472 {; 1473 // Early return: if the list of columns is empty, just return an empty RDF; 1474 // If we proceed, the jitted call will not compile!; 1475 if (columnList.empty()) {; 1476 auto nEntries = *this->Count();; 1477 RInterface<RLoopManager> emptyRDF(std::make_shared<RLoopManager>(nEntries));; 1478 return emptyRDF;; 1479 }; 1480 ; 1481 std::stringstream cacheCall;; 1482 auto upcastNode = RDFInternal::UpcastNode(fProxiedPtr);; 1483 RInterface<TTraits::TakeFirstParameter_t<decltype(upcastNode)>> upcastInterface(fProxiedPtr, *fLoopManager,; 1484 fColRegister);; 1485 // build a string equivalent to; 1486 // ""(RInterface<nodetype*>*)(this)->Cache<Ts...>(*(ColumnNames_t*)(&columnList))""; 1487 RInterface<RLoopManager> resRDF(std::make_shared<ROOT::Detail::RDF::RLoopManager>(0));; 1488 cacheCall << ""*reinterpret_cast<ROOT::RDF::RInterface<ROOT::Detail::RDF::RLoopManager>*>(""; 1489 << RDFInternal::PrettyPrintAddr(&resRDF); 1490 << "") = reinterpret_cast<ROOT::RDF::RInterface<ROOT::Detail::RDF::RNodeBase>*>(""; 1491 << RDFInternal::PrettyPrintAddr(&upcastInterface) << "")->Cache<"";; 1492 ; 1493 const auto columnListWithoutSizeColumns = RDFInternal::FilterArraySizeColNames(columnList, ""Cache"");; 1494 ; 1495 const auto validColumnNames =; 1496 GetValidatedColumnNames(columnListWithoutSizeColumns.size(), columnListWithoutSizeColumns);; 1497 const auto colTypes = GetValidatedArgTypes(validColumnNames, fColRegister, fLoopManager->GetTree(), fDataSource,; 1498 ""Cache"", /*vector2RVec=*/false);; 1499 for (const auto &colType : colTypes); 1500 cacheCall << colType << "", "";; 1501 if (!columnListWithoutSizeColumns.empty()); 1502 cacheCall.seekp(-2, cacheCall.cur); // remove the last "",; 1503 cacheCall << "">(*reinterpret_cast<std::vector<std::string>*>("" // vector<string> should be ColumnNames_t; 1504 << RDFInternal::PrettyPrintAddr(&columnListWithoutSizeColumns) << ""));"";; 1505 ; 1506 // book the code to jit with the RLoopManager and trigger the event loop; 1507 fLoopM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:82811,cache,cacheCall,82811,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['cache'],['cacheCall']
Performance,"_t *mode)TFilevirtual; ResetAfterMerge(TFileMergeInfo *)TDirectoryFilevirtual; ResetBit(UInt_t f)TObjectinline; ResetErrno() constTFilevirtual; rmdir(const char *name) overrideTDirectoryFilevirtual; Save() overrideTDirectoryFilevirtual; SaveAs(const char *filename="""", Option_t *option="""") constTObjectvirtual; SaveObjectAs(const TObject *obj, const char *filename="""", Option_t *option="""") const overrideTDirectoryFilevirtual; SavePrimitive(std::ostream &out, Option_t *option="""")TObjectvirtual; SaveSelf(Bool_t force=kFALSE) overrideTDirectoryFilevirtual; Seek(Long64_t offset, ERelativeTo pos=kBeg)TFilevirtual; SetBit(UInt_t f, Bool_t set)TObject; SetBit(UInt_t f)TObjectinline; SetBufferSize(Int_t bufsize) overrideTDirectoryFilevirtual; SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)TFilestatic; SetCacheRead(TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect)TFilevirtual; SetCacheWrite(TFileCacheWrite *cache)TFilevirtual; SetCompressionAlgorithm(Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal)TFilevirtual; SetCompressionLevel(Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin)TFilevirtual; SetCompressionSettings(Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault)TFilevirtual; SetDrawOption(Option_t *option="""")TObjectvirtual; SetDtorOnly(void *obj)TObjectstatic; SetEND(Long64_t last)TFileinlinevirtual; SetFileBytesRead(Long64_t bytes=0)TFilestatic; SetFileBytesWritten(Long64_t bytes=0)TFilestatic; SetFileReadCalls(Int_t readcalls=0)TFilestatic; SetModified() overrideTDirectoryFileinlinevirtual; SetMother(TObject *mother)TDirectoryinlinevirtual; SetName(const char *newname) overrideTDirectoryvirtual; SetNameTitle(const char *name, const char *title)TNamedvirtual; SetObjectStat(Bool_t stat)TObjectstatic; SetOffset(Long64_t offset, ERelativeTo pos=kBeg)TFilevirtual; SetOnlyStaged(Bool_t onlystaged)TFilestatic; SetOpenTimeout(UInt_t timeout)TFilest",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFile-members.html:17007,cache,cache,17007,doc/master/classTFile-members.html,https://root.cern,https://root.cern/doc/master/classTFile-members.html,1,['cache'],['cache']
Performance,"_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of entries in a particular bin,; 1875/// the fit woul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:52971,cache,cache,52971,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,2,['cache'],['cache']
Performance,"_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub;; 2041 npfit++;; 2042 cache += fPointSize;; 2043 }; 2044 f *= 2;; 2045 f1->SetNumberFitPoints(n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:58441,cache,cache,58441,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,2,['cache'],['cache']
Performance,"_t * ; info, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Static method returning pointer to TClass of the specified ClassInfo. ; If load is true an attempt is made to obtain the class by loading the appropriate shared library (directed by the rootmap file). If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members) Returns 0 in case class is not found. ; Definition at line 3351 of file TClass.cxx. ◆ GetClass() [3/6]. TClass * TClass::GetClass ; (; const char * ; name, . Bool_t ; load, . Bool_t ; silent, . size_t ; hint_pair_offset, . size_t ; hint_pair_size . ). static . Definition at line 2973 of file TClass.cxx. ◆ GetClass() [4/6]. TClass * TClass::GetClass ; (; const char * ; name, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Static method returning pointer to TClass of the specified class name. ; If load is true, an attempt is made to obtain the class by loading the appropriate shared library (directed by the rootmap file). If silent is 'true', do not warn about missing dictionary for the class. (typically used for classes that are used only for transient members) Returns nullptr in case class is not found. ; Definition at line 2968 of file TClass.cxx. ◆ GetClass() [5/6]. TClass * TClass::GetClass ; (; const std::type_info & ; typeinfo, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE, . size_t ; hint_pair_offset = 0, . size_t ; hint_pair_size = 0 . ). static . Return pointer to class with name. ; Definition at line 3254 of file TClass.cxx. ◆ GetClass() [6/6]. Bool_t TClass::GetClass ; (; DeclId_t ; id, . std::vector< TClass * > & ; classes . ). static . Definition at line 3404 of file TClass.cxx. ◆ GetClassInfo(). ClassInfo_t * TClass::GetClassInfo ; (; ); const. inline . Definition at line 433 of file TClass.h. ◆ GetClassMethod() [1/2]. TMethod * TClass::GetClassMethod ; (; const char * ; name, . const char * ; params, . Bool_t ; obje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:73891,load,load,73891,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,2,['load'],"['load', 'loading']"
Performance,"_t * ; info, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Static method returning pointer to TClass of the specified ClassInfo. ; If load is true an attempt is made to obtain the class by loading the appropriate shared library (directed by the rootmap file). If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members) Returns 0 in case class is not found. ; Definition at line 3418 of file TClass.cxx. ◆ GetClass() [3/6]. TClass * TClass::GetClass ; (; const char * ; name, . Bool_t ; load, . Bool_t ; silent, . size_t ; hint_pair_offset, . size_t ; hint_pair_size . ). static . Definition at line 3040 of file TClass.cxx. ◆ GetClass() [4/6]. TClass * TClass::GetClass ; (; const char * ; name, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Static method returning pointer to TClass of the specified class name. ; If load is true, an attempt is made to obtain the class by loading the appropriate shared library (directed by the rootmap file). If silent is 'true', do not warn about missing dictionary for the class. (typically used for classes that are used only for transient members) Returns nullptr in case class is not found. ; Definition at line 3035 of file TClass.cxx. ◆ GetClass() [5/6]. TClass * TClass::GetClass ; (; const std::type_info & ; typeinfo, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE, . size_t ; hint_pair_offset = 0, . size_t ; hint_pair_size = 0 . ). static . Return pointer to class with name. ; Definition at line 3321 of file TClass.cxx. ◆ GetClass() [6/6]. Bool_t TClass::GetClass ; (; DeclId_t ; id, . std::vector< TClass * > & ; classes . ). static . Definition at line 3471 of file TClass.cxx. ◆ GetClassInfo(). ClassInfo_t * TClass::GetClassInfo ; (; ); const. inline . Definition at line 433 of file TClass.h. ◆ GetClassMethod() [1/2]. TMethod * TClass::GetClassMethod ; (; const char * ; name, . const char * ; params, . Bool_t ; obje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:73892,load,load,73892,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,2,['load'],"['load', 'loading']"
Performance,"_t TCling::HandleNewTransaction(const cling::Transaction &T); 3666{; 3667 R__LOCKGUARD(gInterpreterMutex);; 3668 ; 3669 if ((std::distance(T.decls_begin(), T.decls_end()) != 1); 3670 || T.deserialized_decls_begin() != T.deserialized_decls_end(); 3671 || T.macros_begin() != T.macros_end(); 3672 || ((!T.getFirstDecl().isNull()) && ((*T.getFirstDecl().begin()) != T.getWrapperFD()))) {; 3673 fTransactionCount++;; 3674 return true;; 3675 }; 3676 return false;; 3677}; 3678 ; 3679////////////////////////////////////////////////////////////////////////////////; 3680/// Delete object from cling symbol table so it can not be used anymore.; 3681/// cling objects are always on the heap.; 3682 ; 3683void TCling::RecursiveRemove(TObject* obj); 3684{; 3685 // NOTE: When replacing the mutex by a ReadWrite mutex, we **must**; 3686 // put in place the Read/Write part here. Keeping the write lock; 3687 // here is 'catasptrophic' for scaling as it means that ALL calls; 3688 // to RecursiveRemove will take the write lock and performance; 3689 // of many threads trying to access the write lock at the same; 3690 // time is relatively bad.; 3691 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 3692 // Note that fgSetOfSpecials is supposed to be updated by TClingCallbacks::tryFindROOTSpecialInternal; 3693 // (but isn't at the moment).; 3694 if (obj->IsOnHeap() && fgSetOfSpecials && !((std::set<TObject*>*)fgSetOfSpecials)->empty()) {; 3695 std::set<TObject*>::iterator iSpecial = ((std::set<TObject*>*)fgSetOfSpecials)->find(obj);; 3696 if (iSpecial != ((std::set<TObject*>*)fgSetOfSpecials)->end()) {; 3697 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3698 DeleteGlobal(obj);; 3699 ((std::set<TObject*>*)fgSetOfSpecials)->erase(iSpecial);; 3700 }; 3701 }; 3702}; 3703 ; 3704////////////////////////////////////////////////////////////////////////////////; 3705/// Pressing Ctrl+C should forward here. In the case where we have had; 3706/// continuation requested we must reset it.; 3707 ; 3708void TCling::Reset(); 370",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:143039,perform,performance,143039,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['perform'],['performance']
Performance,_t TMVA::MethodBDT::fBoostWeight. private . ntuple var: boost weight ; Definition at line 266 of file MethodBDT.h. ◆ fBoostWeights. std::vector<double> TMVA::MethodBDT::fBoostWeights. private . the weights applied in the individual boosts ; Definition at line 213 of file MethodBDT.h. ◆ fCbb. Double_t TMVA::MethodBDT::fCbb. private . Cost factor. ; Definition at line 272 of file MethodBDT.h. ◆ fCss. Double_t TMVA::MethodBDT::fCss. private . Cost factor. ; Definition at line 269 of file MethodBDT.h. ◆ fCtb_ss. Double_t TMVA::MethodBDT::fCtb_ss. private . Cost factor. ; Definition at line 271 of file MethodBDT.h. ◆ fCts_sb. Double_t TMVA::MethodBDT::fCts_sb. private . Cost factor. ; Definition at line 270 of file MethodBDT.h. ◆ fDoBoostMonitor. Bool_t TMVA::MethodBDT::fDoBoostMonitor. private . create control plot with ROC integral vs tree number ; Definition at line 260 of file MethodBDT.h. ◆ fDoPreselection. Bool_t TMVA::MethodBDT::fDoPreselection. private . do or do not perform automatic pre-selection of 100% eff. cuts ; Definition at line 274 of file MethodBDT.h. ◆ fErrorFraction. Double_t TMVA::MethodBDT::fErrorFraction. private . ntuple var: misclassification error fraction ; Definition at line 267 of file MethodBDT.h. ◆ fEventSample. std::vector<const TMVA::Event*> TMVA::MethodBDT::fEventSample. private . the training events ; Definition at line 206 of file MethodBDT.h. ◆ fForest. std::vector<DecisionTree*> TMVA::MethodBDT::fForest. private . the collection of decision trees ; Definition at line 212 of file MethodBDT.h. ◆ fFValidationEvents. Double_t TMVA::MethodBDT::fFValidationEvents. private . fraction of events to use for pruning ; Definition at line 247 of file MethodBDT.h. ◆ fgDebugLevel. const Int_t TMVA::MethodBDT::fgDebugLevel = 0. staticprivate . debug level determining some printout/control plots etc. ; Definition at line 302 of file MethodBDT.h. ◆ fHighBkgCut. std::vector<Double_t> TMVA::MethodBDT::fHighBkgCut. private . Definition at line 287 of fil,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:62409,perform,perform,62409,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['perform'],['perform']
Performance,"_t bufSize = 32000); virtual voidRooAbsReal::attachToVStore(RooVectorDataStore& vstore); virtual const char*RooAbsCachedPdf::binningName() const; TStringRooAbsCachedPdf::cacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidRooAbsCachedPdf::clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); virtual RooAbsCachedPdf::PdfCacheElem*createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voidRooAbsCachedPdf::disableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tevaluate() const; virtual voidfillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; static Bool_tRooAbsArg::flipAClean(); virtual RooAbsGenContext*RooAbsPdf::genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE) const; RooAbsCachedPdf::PdfCacheElem*RooAbsCachedPdf::getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooIntegralMorph.html:36029,cache,cache,36029,root/html532/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html532/RooIntegralMorph.html,1,['cache'],['cache']
Performance,"_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const. protected:. voidRooAbsArg::attachToStore(RooAbsDataStore& store); virtual voidattachToTree(TTree& t, Int_t bufSize = 32000); virtual voidattachToVStore(RooVectorDataStore&); TStringRooAbsArg::cleanBranchName() const; virtual voidcopyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = kTRUE); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual TStringevaluate() const; virtual voidfillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual Bool_tisValid() const; virtual Bool_tisValidString(const char*, Bool_t printError = kFALSE) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidsetTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidsyncCache(const RooArgSet* nset = 0); const char*traceEval() const; virtual Bool_ttraceEvalHook(const char* value) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsString.html:17008,optimiz,optimizeDirtyHook,17008,root/html534/RooAbsString.html,https://root.cern,https://root.cern/root/html534/RooAbsString.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"_t bufsize); Increment statistics for buffer sizes of objects in this file. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. Bool_t WriteBuffer(const char* buf, Int_t len); Write a buffer to the file. This is the basic low level write operation.; Returns kTRUE in case of failure. Int_t WriteBufferViaCache(const char* buf, Int_t len); Write buffer via cache. Returns 0 if cache is not active, 1 in case; write via cache was successful, 2 in case write via cache failed. void WriteFree(); Write FREE linked list on the file.; The linked list of FREE segments (fFree) is written as a single data; record. void WriteHeader(); Write File Header. void MakeProject(const char* dirname, const char* classes = ""*"", Option_t* option = ""new""); Generate code in directory dirname for all classes specified in; argument classes If classes = ""*"" (default and currently the; only supported value), the function generates an include file; for each class in the StreamerInfo list for which a TClass; object does not exist. The code generated includes:; dirnameProjectHeaders.h // contains one #include statement per generated header file; dirnameProjectSource.cxx // contains all the constructors and destructors implementation.; and one header per class that is not nested inside another class.; The header file name is the fully qualified name of the class after all the special characters; ""<>,:"" are replaced by underscored. F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFile.html:42735,cache,cache,42735,root/html602/TFile.html,https://root.cern,https://root.cern/root/html602/TFile.html,6,['cache'],['cache']
Performance,"_t dx, Int_t dy, Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Combines an image with a rectangle of the specified drawable. ;  ; void PutPixel (Drawable_t wid, Int_t x, Int_t y, ULong_t pixel) override;  Overwrites the pixel in the image with the specified pixel value. ;  ; void QueryColor (Colormap_t cmap, ColorStruct_t &color) override;  Returns the current RGB value for the pixel in the ""color"" structure. ;  ; void QueryPointer (Int_t &x, Int_t &y) override;  Returns the pointer position. ;  ; void QueryPointer (Window_t wid, Window_t &rootw, Window_t &childw, Int_t &root_x, Int_t &root_y, Int_t &win_x, Int_t &win_y, UInt_t &mask) override;  Returns the root window the pointer is logically on and the pointer coordinates relative to the root window's origin. ;  ; void RaiseWindow (Window_t wid) override;  Raises the specified window to the top of the stack so that no sibling window obscures it. ;  ; Pixmap_t ReadGIF (Int_t x0, Int_t y0, const char *file, Window_t wid) override;  If id is NULL - loads the specified gif file at position [x0,y0] in the current window. ;  ; Bool_t ReadPictureDataFromFile (const char *filename, char ***ret_data) override;  Reads picture data from file ""filename"" and store it in ""ret_data"". ;  ; void ReconfigureDisplay ();  ; void RemoveWindow (ULong_t qwid) override;  Removes the created by Qt window ""qwid"". ;  ; void ReparentChild (Window_t wid, Window_t pid, Int_t x, Int_t y);  ; void ReparentTopLevel (Window_t wid, Window_t pid, Int_t x, Int_t y);  ; void ReparentWindow (Window_t wid, Window_t pid, Int_t x, Int_t y) override;  If the specified window is mapped, ReparentWindow automatically performs an UnmapWindow request on it, removes it from its current position in the hierarchy, and inserts it as the child of the specified parent. ;  ; Int_t RequestLocator (Int_t mode, Int_t ctyp, Int_t &x, Int_t &y) override;  Requests Locator position. ;  ; Int_t RequestString (Int_t x, Int_t y, char *text) override;  Requests string: text ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:20511,load,loads,20511,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,2,['load'],['loads']
Performance,"_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAddPdf::CacheElem*getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddPdf.html:36912,optimiz,optimizeDirtyHook,36912,root/html534/RooAddPdf.html,https://root.cern,https://root.cern/root/html534/RooAddPdf.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; const RooAbsReal*getProjection(const RooArgSet* iset, const RooArgSet* nset, const char* rangeName, int& code) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProjectedPdf.html:36117,optimiz,optimizeDirtyHook,36117,root/html534/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html534/RooProjectedPdf.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tHandle(const char* dset, TObject* type); voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TProof*fProofproof. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBenchDataSet(TProof* proof = 0); Constructor. Int_t ReleaseCache(const char* dset); Release memory cache for dataset 'dset'; Return 0 on success, -1 on error. Int_t RemoveFiles(const char* dset); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. Int_t CopyFiles(const char* dset, const char* destdir); Copy the files of dataset 'dset' to another directory; Return 0 on success, -1 on error. Int_t Handle(const char* dset, TObject* type); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. TProofBenchDataSet(TProof* proof = 0). virtual ~TProofBenchDataSet(); { }. Bool_t IsProof(TProof* p); { return (p == fProof) ? kTRUE : kFALSE; }. » Author: Sangsu Ryu 22/06/2010 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TProofBenchDataSet.h 38091 2011-02-16 12:12:04Z ganis $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofBenchDataSet.html:5647,cache,cache,5647,root/html530/TProofBenchDataSet.html,https://root.cern,https://root.cern/root/html530/TProofBenchDataSet.html,1,['cache'],['cache']
Performance,"_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tHandle(const char* dset, TObject* type); voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TProof*fProofproof. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBenchDataSet(TProof* proof = 0); Constructor. Int_t ReleaseCache(const char* dset); Release memory cache for dataset 'dset'; Return 0 on success, -1 on error. Int_t RemoveFiles(const char* dset); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. Int_t CopyFiles(const char* dset, const char* destdir); Copy the files of dataset 'dset' to another directory; Return 0 on success, -1 on error. Int_t Handle(const char* dset, TObject* type); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. TProofBenchDataSet(TProof* proof = 0). virtual ~TProofBenchDataSet(); { }. Bool_t IsProof(TProof* p); { return (p == fProof) ? kTRUE : kFALSE; }. » Author: Sangsu Ryu 22/06/2010 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TProofBenchDataSet.h 38091 2011-02-16 12:12:04Z ganis $ » Last generated: 2011-11-03 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofBenchDataSet.html:5647,cache,cache,5647,root/html532/TProofBenchDataSet.html,https://root.cern,https://root.cern/root/html532/TProofBenchDataSet.html,1,['cache'],['cache']
Performance,"_t f); virtual voidresetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFAL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddPdf.html:29279,cache,cache,29279,root/html532/RooAddPdf.html,https://root.cern,https://root.cern/root/html532/RooAddPdf.html,1,['cache'],['cache']
Performance,"_t f); virtual voidresetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetGeneratorConfig(); voidsetGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidsetNormRange(const char* rangeName); voidsetNormRangeOverride(const char* rangeName); voidsetNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidsetTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf.html:31119,cache,cache,31119,root/html532/RooAbsPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf.html,1,['cache'],['cache']
Performance,"_t fCompressCompression level and algorithm.Definition TFile.h:360; TFileOpenHandle::GetOptconst char * GetOpt() constDefinition TFile.h:379; TFileOpenHandle::TFileOpenHandleTFileOpenHandle(const TFileOpenHandle &)=delete; TFileOpenHandle::MatchesBool_t Matches(const char *name)Return kTRUE if this async request matches the open request specified by 'url'.Definition TFile.cxx:4790; TFileOpenHandle::~TFileOpenHandle~TFileOpenHandle() overrideDefinition TFile.h:375; TFileOpenHandle::GetCompressInt_t GetCompress() constDefinition TFile.h:380; TFilePrefetchThe prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a bloc...Definition TFilePrefetch.h:33; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::fgBytesReadstatic std::atomic< Long64_t > fgBytesReadNumber of bytes read by all TFile objects.Definition TFile.h:131; TFile::fReadCallsInt_t fReadCallsNumber of read calls ( not counting the cache calls )Definition TFile.h:89; TFile::SetFileBytesWrittenstatic void SetFileBytesWritten(Long64_t bytes=0)Definition TFile.cxx:4611; TFile::fgCacheFileForcestatic Bool_t fgCacheFileForceIndicates, to force all READ to CACHEREAD.Definition TFile.h:126; TFile::fBytesReadLong64_t fBytesReadNumber of bytes read from this file.Definition TFile.h:76; TFile::GetSeekFreevirtual Long64_t GetSeekFree() constDefinition TFile.h:252; TFile::ReadProcessIDvirtual TProcessID * ReadProcessID(UShort_t pidf)The TProcessID with number pidf is read from this file.Definition TFile.cxx:1951; TFile::lsvoid ls(Option_t *option="""") const overrideList file contents.Definition TFile.cxx:1457; TFile::Seekvirtual void Seek(Long64_t offset, ERelativeTo pos=kBeg)Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd.Definition TFile.cxx:2274; TFile::GetOnlyStagedstatic Bool_t GetOnlyStaged()Returns staged only flag.Definition TFile.cxx:4754; TFile::IncrementFileCounter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:26432,cache,cache,26432,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['cache'],['cache']
Performance,"_t fGeneric;; 106 Ctor_t fCtor;; 107 Dtor_t fDtor;; 108 };; 109 };; 110 ; 111 class SuspendAutoParsing {; 112 TInterpreter *fInterp;; 113 Bool_t fPrevious;; 114 public:; 115 SuspendAutoParsing(TInterpreter *where, Bool_t value = kTRUE) : fInterp(where), fPrevious(fInterp->SetSuspendAutoParsing(value)) {}; 116 ~SuspendAutoParsing() { fInterp->SetSuspendAutoParsing(fPrevious); }; 117 };; 118 virtual Bool_t IsAutoParsingSuspended() const = 0;; 119 ; 120 class SuspendAutoLoadingRAII {; 121 TInterpreter *fInterp = nullptr;; 122 bool fOldValue;; 123 ; 124 public:; 125 SuspendAutoLoadingRAII(TInterpreter *interp) : fInterp(interp); 126 {; 127 fOldValue = fInterp->SetClassAutoLoading(false);; 128 }; 129 ~SuspendAutoLoadingRAII() { fInterp->SetClassAutoLoading(fOldValue); }; 130 };; 131 ; 132 typedef int (*AutoLoadCallBack_t)(const char*);; 133 typedef std::vector<std::pair<std::string, int> > FwdDeclArgsToKeepCollection_t;; 134 ; 135 TInterpreter() { } // for Dictionary; 136 TInterpreter(const char *name, const char *title = ""Generic Interpreter"");; 137 virtual ~TInterpreter() { }; 138 ; 139 virtual void AddIncludePath(const char *path) = 0;; 140 virtual void *SetAutoLoadCallBack(void* /*cb*/) { return nullptr; }; 141 virtual void *GetAutoLoadCallBack() const { return nullptr; }; 142 virtual Int_t AutoLoad(const char *classname, Bool_t knowDictNotLoaded = kFALSE) = 0;; 143 virtual Int_t AutoLoad(const std::type_info& typeinfo, Bool_t knowDictNotLoaded = kFALSE) = 0;; 144 virtual Int_t AutoParse(const char* cls) = 0;; 145 virtual void ClearFileBusy() = 0;; 146 virtual void ClearStack() = 0; // Delete existing temporary values; 147 virtual Bool_t Declare(const char* code) = 0;; 148 virtual void EndOfLineAction() = 0;; 149 virtual TClass *GetClass(const std::type_info& typeinfo, Bool_t load) const = 0;; 150 virtual Int_t GetExitCode() const = 0;; 151 virtual TEnv *GetMapfile() const { return nullptr; }; 152 ///\brief Returns whether the interpreter is waiting for more input, i.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TInterpreter_8h_source.html:4865,load,load,4865,doc/master/TInterpreter_8h_source.html,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html,1,['load'],['load']
Performance,"_t first, Long64_t last);  Mark unused bytes on the file. ;  ; virtual void MakeProject (const char *dirname, const char *classes=""*"", Option_t *option=""new"");  Generate source code necessary to access the objects stored in the file. ;  ; virtual void Map ();  ; virtual void Map (Option_t *opt);  List the contents of a file sequentially. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; virtual Bool_t ReadBufferAsync (Long64_t offs, Int_t len);  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from this file. ;  ; virtual void ReadStreamerInfo ();  Read the list of StreamerInfo from this file. ;  ; virtual Int_t Recover ();  Attempt to recover file if not correctly closed. ;  ; virtual void ResetErrno () const;  Method resetting the errno. ;  ; virtual void SetCacheRead (TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect);  Set a pointer to the read cache. ;  ; virtual void SetCacheWrite (TFileCacheWrite *cache);  Set a pointer to the write cache. ;  ; virtual void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Used to specify the compression level and algorithm. ;  ; virtual void SetEND (Long64_t last);  ; virtual void SetOffset (Long64_t offset, ERelativeTo pos=kBeg);  Set position from where to start reading. ;  ; virtual void SetOption (Option_t *option="">"");  ; virtual void SetReadCalls (Int_t readcalls=0);  ; virtual void ShowStreamerInfo ();  Show the StreamerInfo of all classes written to this file. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:7974,cache,cache,7974,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,2,['cache'],['cache']
Performance,"_t firstentry=0) override; // *MENU*; 145 virtual void SetAutoDelete(bool autodel=true);; 146 Int_t SetBranchAddress(const char *bname,void *add, TBranch **ptr = nullptr) override;; 147 Int_t SetBranchAddress(const char *bname,void *add, TBranch **ptr, TClass *realClass, EDataType datatype, bool isptr) override;; 148 Int_t SetBranchAddress(const char *bname,void *add, TClass *realClass, EDataType datatype, bool isptr) override;; 149 template <class T> Int_t SetBranchAddress(const char *bname, T **add, TBranch **ptr = nullptr) {; 150 return TTree::SetBranchAddress<T>(bname, add, ptr);; 151 }; 152#ifndef R__NO_CLASS_TEMPLATE_SPECIALIZATION; 153 // This can only be used when the template overload resolution can distinguish between; 154 // T* and T**; 155 template <class T> Int_t SetBranchAddress(const char *bname, T *add, TBranch **ptr = nullptr) {; 156 return TTree::SetBranchAddress<T>(bname, add, ptr);; 157 }; 158#endif; 159 ; 160 void SetBranchStatus(const char *bname, bool status = true, UInt_t *found = nullptr) override;; 161 Int_t SetCacheSize(Long64_t cacheSize = -1) override;; 162 void SetDirectory(TDirectory *dir) override;; 163 void SetEntryList(TEntryList *elist, Option_t *opt="""") override;; 164 virtual void SetEntryListFile(const char *filename="""", Option_t *opt="""");; 165 void SetEventList(TEventList *evlist) override;; 166 void SetMakeClass(Int_t make) override { TTree::SetMakeClass(make); if (fTree) fTree->SetMakeClass(make);}; 167 void SetName(const char *name) override;; 168 virtual void SetPacketSize(Int_t size = 100);; 169 virtual void SetProof(bool on = true, bool refresh = false, bool gettreeheader = false);; 170 void SetWeight(Double_t w=1, Option_t *option="""") override;; 171 virtual void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0);; 172 ; 173 ClassDefOverride(TChain,5) //A chain of TTrees; 174};; 175 ; 176#endif // ROOT_TChain; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Int_tint Int_tDefinition RtypesCore.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8h_source.html:8495,cache,cacheSize,8495,doc/master/TChain_8h_source.html,https://root.cern,https://root.cern/doc/master/TChain_8h_source.html,1,['cache'],['cacheSize']
Performance,"_t flag); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistPdf.html:31918,cache,cache,31918,root/html602/RooHistPdf.html,https://root.cern,https://root.cern/root/html602/RooHistPdf.html,2,['cache'],['cache']
Performance,"_t maxM, Float_t minQ, Float_t maxQ); static voidLoadMacro(const char* mac); static voidMacro(const char* mac); TEveUtil&operator=(const TEveUtil&); static voidSetColorBrightness(Float_t value, Bool_t full_redraw = kFALSE); static voidSetupEnvironment(); static voidSetupGUI(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TEveUtil(); TEveUtil(const TEveUtil&). Data Members; private:. static TObjArray*fgDefaultColors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupEnvironment(); Setup Include and Macro paths.; Since inclusion into ROOT this does nothing but could; potentially be reactivated if some common macros are established; and shipped with binary ROOT (in macros/eve). For example, these; might be used to spawn specific GUI / GL configurations. void SetupGUI(); Setup icon pictures and mime-types. Bool_t CheckMacro(const char* mac); Checks if macro 'mac' is loaded. void AssertMacro(const char* mac); Load and execute macro 'mac' if it has not been loaded yet. void Macro(const char* mac); Execute macro 'mac'. Do not reload the macro. void LoadMacro(const char* mac); Makes sure that macro 'mac' is loaded, but do not reload it. void ColorFromIdx(Color_t ci, UChar_t[4] col, Bool_t alpha = kTRUE); Fill col with RGBA values corresponding to index ci. If alpha; is true, set alpha component of col to 255.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Color_t ci, UChar_t[4] col, Char_t transparency); Fill col with RGBA values corresponding to index ci and transparency.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2, UChar_t[4] col, Bool_t alpha = kTRUE); Fill col with weighted RGBA values corresponding to; color-indices c1 and c2. If alpha is true, set alpha component; of col to 255. Color_t* FindColorVar(TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveUtil.html:2316,load,loaded,2316,root/html602/TEveUtil.html,https://root.cern,https://root.cern/root/html602/TEveUtil.html,2,['load'],['loaded']
Performance,"_t nToProcess): where selector is a TSelector derived class describing the analysis and the other arguments have the same meaning as above. For either set of signatures, the processing function is executed as many times as needed by a pool of fNWorkers workers; the number of workers can be passed to the constructor or set via SetNWorkers. It defaults to the number of cores.; A collection containing the result of each execution is returned.; Note: the user is responsible for the deletion of any object that might be created upon execution of func, returned objects included: ROOT::TTreeProcessorMP never deletes what it returns, it simply forgets it.; Note: that the usage of ROOT::TTreeProcessorMP::Process is indicated only when the task to be executed takes more than a few seconds, otherwise the overhead introduced by Process will outrun the benefits of parallel execution on most machines.; Parameters. funca lambda expression, an std::function, a loaded macro, a functor class or a function that takes zero arguments (for the first signature) or one (for the second signature). ; argsa standard container (vector, list, deque), an initializer list or a pointer to a TCollection (TList*, TObjArray*, ...). . Note: the version of ROOT::TTreeProcessorMP::Process that takes a TFileCollection* as argument incurs in the overhead of copying data from the TCollection to an STL container. Only use it when absolutely necessary.; Note: in cases where the function to be executed takes more than zero/one argument but all are fixed except zero/one, the function can be wrapped in a lambda or via std::bind to give it the right signature.; Note: the user should take care of initializing random seeds differently in each process (e.g. using the process id in the seed). Otherwise several parallel executions might generate the same sequence of pseudo-random numbers.; Return value:; Methods taking 'F func' return the return type of F. Methods taking a TSelector return a 'TList *' with the selecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TTreeProcessorMP.html:2581,load,loaded,2581,doc/v632/classROOT_1_1TTreeProcessorMP.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TTreeProcessorMP.html,2,['load'],['loaded']
Performance,"_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsHiddenReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooUnblindCPAsymVar.html:24627,cache,cache,24627,root/html526/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html526/RooUnblindCPAsymVar.html,4,['cache'],['cache']
Performance,"_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetCacheAllNumeric(Int_t ndim); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCacheNumeric(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealIntegral.html:22541,cache,cache,22541,root/html528/RooRealIntegral.html,https://root.cern,https://root.cern/root/html528/RooRealIntegral.html,1,['cache'],['cache']
Performance,"_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsHiddenReal.html:22981,cache,cache,22981,root/html532/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html532/RooAbsHiddenReal.html,40,['cache'],['cache']
Performance,"_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetMode(const Roo1DMomentMorphFunction::Setting& setting); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo1DMomentMorphFunction.html:22933,cache,cache,22933,root/html532/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html532/Roo1DMomentMorphFunction.html,1,['cache'],['cache']
Performance,"_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetMode(const Roo2DMomentMorphFunction::Setting& setting); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo2DMomentMorphFunction.html:23235,cache,cache,23235,root/html532/Roo2DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html532/Roo2DMomentMorphFunction.html,1,['cache'],['cache']
Performance,"_t structure. ;  ; virtual Int_t GetCryptoRandom (void *buf, Int_t len);  Return cryptographic random number Fill provided buffer with random values Returns number of bytes written to buffer or -1 in case of error. ;  ; virtual const char * GetDirEntry (void *dirp);  Get a directory entry. Returns 0 if no more entries. ;  ; virtual TString GetDirName (const char *pathname);  Return the directory name in pathname. ;  ; virtual void * GetDirPtr () const;  ; virtual const char * GetDynamicPath ();  Return the dynamic path (used to find shared libraries). ;  ; virtual Int_t GetEffectiveGid ();  Returns the effective group id. ;  ; virtual Int_t GetEffectiveUid ();  Returns the effective user id. ;  ; virtual const char * Getenv (const char *env);  Get environment variable. ;  ; virtual const char * GetError ();  Return system error string. ;  ; const char * GetErrorStr () const;  ; virtual const char * GetFlagsDebug () const;  Return the debug flags. ;  ; virtual const char * GetFlagsOpt () const;  Return the optimization flags. ;  ; virtual Int_t GetFPEMask ();  Return the bitmap of conditions that trigger a floating point exception. ;  ; virtual TString GetFromPipe (const char *command);  Execute command and return output in TString. ;  ; virtual int GetFsInfo (const char *path, Long_t *id, Long_t *bsize, Long_t *blocks, Long_t *bfree);  Get info about a file system: fs type, block size, number of blocks, number of free blocks. ;  ; virtual Int_t GetGid (const char *group=nullptr);  Returns the group's id. If group = 0, returns current user's group. ;  ; virtual UserGroup_t * GetGroupInfo (const char *group=nullptr);  Returns all group info in the UserGroup_t structure. ;  ; virtual UserGroup_t * GetGroupInfo (Int_t gid);  Returns all group info in the UserGroup_t structure. ;  ; virtual std::string GetHomeDirectory (const char *userName=nullptr) const;  Return the user's home directory. ;  ; virtual TInetAddress GetHostByName (const char *server);  Get Internet Proto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:7837,optimiz,optimization,7837,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['optimiz'],['optimization']
Performance,"_t tcpwindowsize = -1); Create a parallel server socket object for a named service. Set reuse; to true to force reuse of the server socket (i.e. do not wait for the; time out to pass). Using backlog one can set the desirable queue length; for pending connections.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. TSocket * Accept(UChar_t Opt = kSrvNoAuth); Accept a connection on a parallel server socket. Returns a full-duplex; parallel communication TPSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. TPServerSocket(const TPServerSocket& ). void operator=(const TPServerSocket& ). virtual ~TPServerSocket(); { }. » Author: Fons Rademakers 19/1/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-03-14 16:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPServerSocket.html:12980,queue,queue,12980,root/html534/TPServerSocket.html,https://root.cern,https://root.cern/root/html534/TPServerSocket.html,1,['queue'],['queue']
Performance,"_t tcpwindowsize = -1); Create a parallel server socket object for a named service. Set reuse; to true to force reuse of the server socket (i.e. do not wait for the; time out to pass). Using backlog one can set the desirable queue length; for pending connections.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. TSocket * Accept(UChar_t Opt = kSrvNoAuth); Accept a connection on a parallel server socket. Returns a full-duplex; parallel communication TPSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. TPServerSocket(const TPServerSocket& ). void operator=(const TPServerSocket& ). virtual ~TPServerSocket(); { }. » Author: Fons Rademakers 19/1/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-02 16:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPServerSocket.html:13609,queue,queue,13609,root/html604/TPServerSocket.html,https://root.cern,https://root.cern/root/html604/TPServerSocket.html,1,['queue'],['queue']
Performance,"_t tcpwindowsize = -1); Create a parallel server socket object for a named service. Set reuse; to true to force reuse of the server socket (i.e. do not wait for the; time out to pass). Using backlog one can set the desirable queue length; for pending connections.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. TSocket * Accept(UChar_t Opt = kSrvNoAuth); Accept a connection on a parallel server socket. Returns a full-duplex; parallel communication TPSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. TPServerSocket(const TPServerSocket& ). void operator=(const TPServerSocket& ). virtual ~TPServerSocket(); { }. » Author: Fons Rademakers 19/1/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-30 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPServerSocket.html:13609,queue,queue,13609,root/html602/TPServerSocket.html,https://root.cern,https://root.cern/root/html602/TPServerSocket.html,1,['queue'],['queue']
Performance,"_t tmax=1E-8,; Int_t nframes=200,Option_t *option="""");; The drawing/animation time range is a global variable that can be directly set:; gGeoManager->SetTminTmax(tmin, tmax);; // without arguments resets the time range to the maximum value; Once set, the time range will be active both for individual or global track drawing. For animation, this range is divided to the desired number of frames and will be automatically updated at each frame in order to get the animation effect.; The option provided to all track-drawing methods can trigger different track selections:; default:A track (or all primary tracks) drawn without daughters; /D: Track and first level descendents only are drawn; /*: Track and all descendents are drawn; /Ntype: All tracks having name=type are drawn; Generally several options can be concatenated in the same string (E.g. ""/D /Npion-"").; For animating tracks, additional options can be added:; /G:Geometry animate. Generally when drawing or animating tracks, one has to first perform a normal drawing of the geometry as convenient. The tracks will be drawn over the geometry. The geometry itself will be animated (camera moving and rotating in order to “catch” the majority of current track segments.); /S:Save all frames in gif format in the current folder. This option allows creating a movie based on individual frames.; 18.6 Checking the Geometry; Several checking methods are accessible from the context menu of volume objects or of the manager class. They generally apply only to the visible parts of the drawn geometry in order to ease geometry checking, and their implementation is in the TGeoChecker class. The checking package contains an overlap checker and several utility methods that generally have visualization outputs.; 18.6.1 The Overlap Checker; An overlap is any region in the Euclidian space being contained by more than one positioned volume. Due to the containment scheme used by the modeller, all points inside a volume have to be also contained by ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:997249,perform,perform,997249,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['perform']
Performance,"_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCacheElement(); RooAbsCacheElement(const RooAbsCacheElement&); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. static RooAbsCacheElement::ActionFindConstantNodes; static RooAbsCacheElement::ActionOperModeChange; static RooAbsCacheElement::ActionOptimizeCaching. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). RooAbsCacheElement(); Default constructor. virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Tue Jun 2 15:26:53 2015 » Last generated: 2015-06-02 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsCacheElement.html:2306,optimiz,optimizeCacheMode,2306,root/html604/RooAbsCacheElement.html,https://root.cern,https://root.cern/root/html604/RooAbsCacheElement.html,5,"['cache', 'optimiz']","['cache', 'cacheList', 'optimization', 'optimizeCacheMode']"
Performance,"_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); TStringcurrentLabel() const; const RooCatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidupdateIndexList().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiCategory.html:18707,optimiz,optimizeDirtyHook,18707,root/html602/RooMultiCategory.html,https://root.cern,https://root.cern/root/html602/RooMultiCategory.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistPdf.html:27043,cache,cache,27043,root/html526/RooHistPdf.html,https://root.cern,https://root.cern/root/html526/RooHistPdf.html,1,['cache'],['cache']
Performance,"_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; Double_tlogSum(Int_t i) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistConstraint.html:35383,optimiz,optimizeDirtyHook,35383,root/html534/RooHistConstraint.html,https://root.cern,https://root.cern/root/html534/RooHistConstraint.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"_t z, Int_t natoms);; TGeoMixture::DefineElementvoid DefineElement(Int_t iel, Double_t a, Double_t z, Double_t weight)Definition TGeoMaterial.h:226; or:; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight). iel: index of the element[0,nel-1]; a and z: the atomic mass and charge; weight: proportion by mass of the elements; natoms: number of atoms of the element in the molecule making the mixture. The radiation length is automatically computed when all elements are defined. Since tracking MC provide several other ways to create materials/mixtures, the materials classes are likely to evolve as the interfaces to these engines are being developed. Generally in the process of tracking material properties are not enough and more specific media properties have to be defined. These highly depend on the MC performing tracking and sometimes allow the definition of different media properties (e.g. energy or range cuts) for the same material. Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; TGeoElementRNClass representing a radionuclidevoid TGeoManager::SetDefaultRootUnits() { if ( fgDefaultUnits == kRo...Definition TGeoElement.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Materials__classes.html:6031,perform,performing,6031,doc/master/group__Materials__classes.html,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html,1,['perform'],['performing']
Performance,"_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_texpectedEvents(const RooArgSet* nset) const; virtual Double_texpectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_textendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeextendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*fitTo(RooAbsData& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:14338,cache,cacheList,14338,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['cache'],['cacheList']
Performance,"_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_texpectedEvents(const RooArgSet* nset) const; virtual Double_texpectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_textendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeextendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:14548,cache,cacheList,14548,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,2,['cache'],['cacheList']
Performance,"_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH2GL.html:2046,cache,cached,2046,root/html528/TH2GL.html,https://root.cern,https://root.cern/root/html528/TH2GL.html,6,['cache'],['cached']
Performance,"_t, Int_t) final;  Interface to system lseek. ;  ; Int_t SysStat (Int_t, Long_t *, Long64_t *, Long_t *, Long_t *) final;  Return file stat information. ;  ; Int_t SysSync (Int_t) final;  Interface to system fsync. All arguments like in POSIX fsync(). ;  ; Int_t SysWrite (Int_t, const void *, Int_t) final;  Interface to system write. All arguments like in POSIX write(). ;  ; Bool_t UpdateKeyData (TKeySQL *key);  Updates (overwrites) key data in KeysTable. ;  ; Bool_t VerifyLongStringTable ();  Checks that table for big strings is exists If not, will be created. ;  ; Long64_t VerifyObjectTable ();  Checks that objects table is exists If not, table will be created Returns maximum value for existing objects id. ;  ; Bool_t WriteKeyData (TKeySQL *key);  Add entry into keys table. ;  ; Bool_t WriteSpecialObject (Long64_t keyid, TObject *obj, const char *name, const char *title);  write special kind of object like streamer infos or file itself keys for that objects should exist in tables but not indicated in list of keys, therefore users can not get them with TDirectoryFile::Get() method ;  ;  Protected Member Functions inherited from TFile; Bool_t FlushWriteCache ();  Flush the write cache if active. ;  ; virtual EAsyncOpenStatus GetAsyncOpenStatus ();  ; virtual void Init (Bool_t create);  Initialize a TFile object. ;  ; Int_t MakeProjectParMake (const char *packname, const char *filename);  Create makefile at 'filemake' for PAR package 'pack'. ;  ; Int_t MakeProjectParProofInf (const char *packname, const char *proofinfdir);  Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'. ;  ; Int_t ReadBufferViaCache (char *buf, Int_t len);  Read buffer via cache. ;  ; Int_t WriteBufferViaCache (const char *buf, Int_t len);  Write buffer via cache. ;  ;  Protected Member Functions inherited from TDirectoryFile; void BuildDirectoryFile (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; void CleanTargets ();  Clean the pointers to t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:49560,cache,cache,49560,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['cache'],['cache']
Performance,"_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetCache(); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTNetFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXNetFile.html:12505,cache,cache,12505,root/html530/TXNetFile.html,https://root.cern,https://root.cern/root/html530/TXNetFile.html,1,['cache'],['cache']
Performance,"_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooObjCacheManager_normIntMgrThe integration cache manager; Int_t_numBins; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; RooListProxy_paramSetinterpolation parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ParamHistFunc(). ParamHistFunc(const char* name, const char* title,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:34938,cache,cache,34938,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,3,['cache'],['cache']
Performance,"_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. static Int_t_evalErrorCount; static map<const RooAbsArg*,std::pair<std::string,std::list<EvalError> > >_evalErrorList; static RooAbsReal::ErrorLoggingMode_evalErrorMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsReal(); Destructor. Bool_t operator==(Double_t value) const; Equality operator comparing to a Double_t. Bool_t operator==(const RooAbsArg& other); Equality operator when comparing to another RooAbsArg.; Only functional when the other arg is a RooAbsReal. TString getTitle(Bool_t appendUnit = kFALSE) const; Return this variable's title string. If appendUnit is true and; this variable has units, also append a string "" (<unit>)"". Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Int_t numEvalErrorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function sho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsReal.html:33072,cache,cache,33072,root/html532/RooAbsReal.html,https://root.cern,https://root.cern/root/html532/RooAbsReal.html,3,['cache'],"['cache', 'cached']"
Performance,"_tRooAbsArg::numCaches() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(const char*) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsString.html:9653,optimiz,optimizeCacheMode,9653,root/html530/RooAbsString.html,https://root.cern,https://root.cern/root/html530/RooAbsString.html,3,['optimiz'],['optimizeCacheMode']
Performance,"_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3Binding<double,unsigned int,double,double>&operator=(const RooCFunction3Binding<double,unsigned int,double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_double_double_.html:19958,optimiz,optimizeCacheMode,19958,root/html602/RooCFunction3Binding_double_unsigned_int_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_double_double_.html,2,['optimiz'],['optimizeCacheMode']
Performance,"_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); RooAbsCategory&operator=(const RooAbsCategory&); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategory.html:11331,optimiz,optimizeCacheMode,11331,root/html602/RooAbsCategory.html,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html,2,['optimiz'],['optimizeCacheMode']
Performance,"_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumConvPdf.html:42202,cache,cache,42202,root/html532/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html532/RooNumConvPdf.html,1,['cache'],['cache']
Performance,"_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_effEfficiency function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; RooArgSet*_fixedNset! Fixed normalization set overriding default normalization set (if provided); Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooEffProd.html:40466,cache,cache,40466,root/html534/RooEffProd.html,https://root.cern,https://root.cern/root/html534/RooEffProd.html,2,['cache'],['cache']
Performance,"_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine ; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenericPdf.html:37372,cache,cache,37372,root/html526/RooGenericPdf.html,https://root.cern,https://root.cern/root/html526/RooGenericPdf.html,1,['cache'],['cache']
Performance,"_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine ; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGenericPdf.html:37754,cache,cache,37754,root/html528/RooGenericPdf.html,https://root.cern,https://root.cern/root/html528/RooGenericPdf.html,3,['cache'],['cache']
Performance,"_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooCategoryProxy_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; Int_t_numPdfNumber o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimultaneous.html:37592,cache,cache,37592,root/html526/RooSimultaneous.html,https://root.cern,https://root.cern/root/html526/RooSimultaneous.html,1,['cache'],['cache']
Performance,"_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooCategoryProxy_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSimultaneous.html:38166,cache,cache,38166,root/html528/RooSimultaneous.html,https://root.cern,https://root.cern/root/html528/RooSimultaneous.html,2,['cache'],['cache']
Performance,"_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooRealProxy_nNumber of expected events; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooExtendedTerm.html:36567,cache,cache,36567,root/html526/RooExtendedTerm.html,https://root.cern,https://root.cern/root/html526/RooExtendedTerm.html,2,['cache'],['cache']
Performance,"_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooRealProxy_nNumber of expected events; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExtendedTerm.html:36949,cache,cache,36949,root/html528/RooExtendedTerm.html,https://root.cern,https://root.cern/root/html528/RooExtendedTerm.html,6,['cache'],['cache']
Performance,"_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; Bool_t_noRounding; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooPoisson.html:37004,cache,cache,37004,root/html528/RooPoisson.html,https://root.cern,https://root.cern/root/html528/RooPoisson.html,3,['cache'],['cache']
Performance,"_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Roo2DKeysPdf.html:37551,cache,cache,37551,root/html526/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html526/Roo2DKeysPdf.html,37,['cache'],['cache']
Performance,"_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalizat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/Roo2DKeysPdf.html:37933,cache,cache,37933,root/html528/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html528/Roo2DKeysPdf.html,117,['cache'],['cache']
Performance,"_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooRealProxy_nominalThe nominal value; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooJeffreysPrior.html:37125,cache,cache,37125,root/html528/RooJeffreysPrior.html,https://root.cern,https://root.cern/root/html528/RooJeffreysPrior.html,3,['cache'],['cache']
Performance,"_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTruthModel.html:38024,cache,cache,38024,root/html526/RooTruthModel.html,https://root.cern,https://root.cern/root/html526/RooTruthModel.html,1,['cache'],['cache']
Performance,"_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooTruthModel.html:38406,cache,cache,38406,root/html528/RooTruthModel.html,https://root.cern,https://root.cern/root/html528/RooTruthModel.html,3,['cache'],['cache']
Performance,"_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooResolutionModel.html:38695,cache,cache,38695,root/html526/RooResolutionModel.html,https://root.cern,https://root.cern/root/html526/RooResolutionModel.html,1,['cache'],['cache']
Performance,"_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooResolutionModel.html:39077,cache,cache,39077,root/html528/RooResolutionModel.html,https://root.cern,https://root.cern/root/html528/RooResolutionModel.html,2,['cache'],['cache']
Performance,"_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,double,double,bool>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction3Binding_double_double_double_bool_.html:32573,cache,cache,32573,root/html526/RooCFunction3Binding_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html526/RooCFunction3Binding_double_double_double_bool_.html,2,['cache'],['cache']
Performance,"_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetSet of parameters to which constraints apply; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of constraint terms; TIterator*_setIter1! do not persist; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStrin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooConstraintSum.html:32618,cache,cache,32618,root/html532/RooConstraintSum.html,https://root.cern,https://root.cern/root/html532/RooConstraintSum.html,1,['cache'],['cache']
Performance,"_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooObjCacheManager_projCacheMgrManager of cache with coefficient projections and transformations; Bool_t_projectCoefsIf true coefficients need to be projected for use in evaluate(); RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_t_recursiveFlag indicating is fractions are treated recursively; RooSetProxy_refCoefNormReference observable set for coefficient interpretation; TNamed*_refCoefRangeNameReference range name for coefficient interpreation; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooArgList*_snormList! List of supplemental normalization factors; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddPdf.html:45111,cache,cache,45111,root/html534/RooAddPdf.html,https://root.cern,https://root.cern/root/html534/RooAddPdf.html,1,['cache'],['cache']
Performance,"_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; TSocket*fSocketconnection to rootd server; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; TStringfUserremote user name; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static Long64_tTFile::fgBytesReadNumber of bytes read by all TFile objects; static Long64_tTFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:23368,cache,cache,23368,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,8,['cache'],"['cache', 'cached']"
Performance,"_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooExpensiveObjectCache&operator=(const RooExpensiveObjectCache&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); voidprint() const; virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tregisterObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Bool_tregisterObject(const char* ownerName, const char* objectName, TObject& cacheObject, const RooArgSet& params); voidTObject::ResetBit(UInt_t f); const TObject*retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); Bool_tsetObj(Int_t uniqueID, TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); Int_tsize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExpensiveObjectCache.html:4291,cache,cacheObject,4291,root/html528/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html528/RooExpensiveObjectCache.html,1,['cache'],['cacheObject']
Performance,"_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooExpensiveObjectCache&operator=(const RooExpensiveObjectCache&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); voidprint() const; virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tregisterObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Bool_tregisterObject(const char* ownerName, const char* objectName, TObject& cacheObject, const RooArgSet& params); voidTObject::ResetBit(UInt_t f); const TObject*retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); Bool_tsetObj(Int_t uniqueID, TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp, char* parent); Int_tsize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooExpensiveObjectCache.html:4291,cache,cacheObject,4291,root/html526/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html526/RooExpensiveObjectCache.html,1,['cache'],['cacheObject']
Performance,"_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum ESlaveStatus { kActive; kNotActive; kBad; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TStringfDataDirdirectory for user data; TStringfHostNamehostname this slave is running on; TStringfMsdmass storage domain slave is in; TStringfOrdinalslave ordinal; Int_tfPerfIndexrelative performance of this slave; TSlaveInfo::ESlaveStatusfStatusslave status; SysInfo_tfSysInfoInfomation about its hardware. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t Compare(const TObject* obj) const; Used to sort slaveinfos by ordinal. Bool_t IsEqual(const TObject* obj) const; Used to compare slaveinfos by ordinal. void Print(Option_t* option = """") const; Print slave info. If opt = ""active"" print only the active; slaves, if opt=""notactive"" print only the not active slaves,; if opt = ""bad"" print only the bad slaves, else; print all slaves. void SetSysInfo(SysInfo_t si); Setter for fSysInfo. TProofInterruptHandler& operator=(const TSlaveInfo& ). TSlaveInfo(const char* ordinal = """", const char* host = """", Int_t perfidx = 0, const char* msd = """", const char* datadir = """"); { }. const char * GetDataDir() const; { return fDataDir; }. const char * GetMsd() const; { return fMsd; }. const char * GetName() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSlaveInfo.html:5873,perform,performance,5873,root/html534/TSlaveInfo.html,https://root.cern,https://root.cern/root/html534/TSlaveInfo.html,1,['perform'],['performance']
Performance,"_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum ESlaveStatus { kActive; kNotActive; kBad; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TStringfDataDirdirectory for user data; TStringfHostNamehostname this slave is running on; TStringfMsdmass storage domain slave is in; TStringfOrdinalslave ordinal; Int_tfPerfIndexrelative performance of this slave; TSlaveInfo::ESlaveStatusfStatusslave status; SysInfo_tfSysInfoInfomation about its hardware. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t Compare(const TObject* obj) const; Used to sort slaveinfos by ordinal. void Print(Option_t* option = """") const; Print slave info. If opt = ""active"" print only the active; slaves, if opt=""notactive"" print only the not active slaves,; if opt = ""bad"" print only the bad slaves, else; print all slaves. void SetSysInfo(SysInfo_t si); Setter for fSysInfo. TProofInterruptHandler& operator=(const TSlaveInfo& ). TSlaveInfo(const char* ordinal = """", const char* host = """", Int_t perfidx = 0, const char* msd = """", const char* datadir = """"); { }. const char * GetDataDir() const; { return fDataDir; }. const char * GetMsd() const; { return fMsd; }. const char * GetName() const; { return fHostName; }. const char * GetOrdinal() const; { return fOrdinal; }.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSlaveInfo.html:5761,perform,performance,5761,root/html528/TSlaveInfo.html,https://root.cern,https://root.cern/root/html528/TSlaveInfo.html,3,['perform'],['performance']
Performance,"_tTWebFile::fSizefile size; TSocket*TWebFile::fSocketsocket for HTTP/1.1 (stays alive between calls); Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; TUrlTWebFile::fUrlOrgsave original url in case of temp redirection; Bool_tfUseMultiRangeIs the S3 server capable of serving multirange requests?; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static atomic<Long64_t>TFile::fgBytesReadNumber of bytes read by all TFile objects; static atomic<Long64_t>TFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static atomic<Long64_t>TFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static TUrlTWebFile::fgProxyglobally set proxy URL; static atomic<Int_t>TFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TDirectory. ←",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TS3WebFile.html:26712,cache,cache,26712,root/html602/TS3WebFile.html,https://root.cern,https://root.cern/root/html602/TS3WebFile.html,4,['cache'],"['cache', 'cached']"
Performance,"_t_allExtendableFlag indicating if all PDF components are extendable; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of component analytical integration codes; Double_t*_coefCache! Transiet cache with transformed values of coefficients; Int_t_coefErrCount! Coefficient error counter; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoefFlag indicating if last PDFs coefficient was supplied in the ctor; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddPdf.html:39882,cache,cache,39882,root/html532/RooAddPdf.html,https://root.cern,https://root.cern/root/html532/RooAddPdf.html,1,['cache'],['cache']
Performance,"_t_allExtendableFlag indicating if all PDF components are extendable; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of component analytical integration codes; Double_t*_coefCache! Transiet cache with transformed values of coefficients; Int_t_coefErrCount! Coefficient error counter; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoefFlag indicating if last PDFs coefficient was supplied in the ctor; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddPdf.html:37791,cache,cache,37791,root/html526/RooAddPdf.html,https://root.cern,https://root.cern/root/html526/RooAddPdf.html,3,['cache'],['cache']
Performance,"_t_numPdfNumber of registered PDFs; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooObjCacheManager_partIntMgrComponent normalization manager; TList_pdfProxyListList of PDF proxies (named after applicable category state); Int_tRooAbsReal::_plotBinsNumber of plot bins; const TNamed*_plotCoefNormRange; RooSetProxy_plotCoefNormSet; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSimultaneous.html:43864,cache,cache,43864,root/html534/RooSimultaneous.html,https://root.cern,https://root.cern/root/html534/RooSimultaneous.html,1,['cache'],['cache']
Performance,"_tfAxisLength; Double_tfGridLength; TString*fLabels; Double_tfLabelsOffset; Double_tfLabelsSize; Int_tfNDiv; Int_tfNDiv1; Int_tfNDiv2; Int_tfNDiv3; Int_tfNTicks1; Int_tfNTicks2; TGLText*fText; Double_tfTickMarksLength; Int_tfTickMarksOrientation; Double_t*fTicks1; Double_t*fTicks2; Double_tfWmax; Double_tfWmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLAxis(); Constructor. void Init(); Default initialization. ~TGLAxis(); Destructor. void PaintGLAxis(const Double_t[3] p1, const Double_t[3] p2, Double_t wmin, Double_t wmax, Int_t ndiv, Option_t* opt = """"); Paint GL Axis. p1, p2 : Axis position in the 3D space.; wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; ndiv : Number of axis divisions. It is an integer in the form; ""ttsspp"" where ""tt"" is the number of tertiary divisions,; ""ss"" is the number of secondary divisions and ""pp"" the; number of primary divisions.; opt : Options.; ""N"" - By default the number of divisions is optimized to; get a nice labeling. When option ""N"" is given, the; number of divisions is not optimized. void PaintGLAxisBody(); Paint horizontal axis body at position (0,0,0). void PaintGLAxisTickMarks(); Paint axis tick marks. void PaintGLAxisLabels(); Paint axis labels on the main tick marks. void TicksPositions(Option_t* opt = """"); Compute ticks positions. void TicksPositionsNoOpt(); Compute ticks positions. Linear and not optimized. void TicksPositionsOpt(); Compute ticks positions. Linear and optimized. void DoLabels(); Do labels. void SetLabelsAngles(Double_t a1, Double_t a2, Double_t a3); Set labels' angles. TGLAxis(const TGLAxis& ). TGLAxis& operator=(const TGLAxis& ). void SetTickMarksLength(Double_t length); {fTickMarksLength = length;}. void SetTickMarksOrientation(Int_t tmo); {fTickMarksOrientation = tmo;}. void SetLabelsOffset(Double_t offset); {fLabelsOffset = offset;}. void SetLabelsSize(Double_t size); {fLabelsSize = size;}. void SetGridLength(Double_t grid); {fGr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLAxis.html:4466,optimiz,optimized,4466,root/html602/TGLAxis.html,https://root.cern,https://root.cern/root/html602/TGLAxis.html,2,['optimiz'],['optimized']
Performance,"_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; RooStats::ModelConfig&fModel; Int_tfNbinsnumber of samples per variable; RooAbsData*fPOIToTestvalue of POI points to perform the construction; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the parameter points to perform the construction.; allow ability to profile on some nuisance paramters. PointSetInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::PointSetInterval. FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); FeldmanCousins();; Common constructor. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& ); Set the DataSet. void SetPdf(RooAbsPdf& ); Set the Pdf. void SetParameters(const RooArgSet& ); specify the parameters of interest in the interval. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). void SetParameterPointsToTest(RooAbsData& pointsToTest); User-defined set of points to test. void SetPOIPointsToTest(RooAbsData& poiToTest); User-defined set of points to test. void SetTest",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__FeldmanCousins.html:4521,perform,perform,4521,root/html530/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html530/RooStats__FeldmanCousins.html,5,['perform'],['perform']
Performance,"_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; TTree*fOwner! pointer to the owner Tree/chain; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; Bool_tfReadDirectionSet! read direction established; Bool_tfReverseRead! reading in reverse mode ; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; Long64_tfZipBytes! Total compressed size of branches in cache; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor. void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCache.html:18909,cache,cache,18909,root/html530/TTreeCache.html,https://root.cern,https://root.cern/root/html530/TTreeCache.html,1,['cache'],['cache']
Performance,"_tfNbinsnumber of samples per variable; RooArgSetfNuisParamsRooArgSet specifying nuisance parameters for interval; RooArgSetfPOIRooArgSet specifying parameters of interest for interval; RooAbsPdf*fPdfcommon PDF; RooAbsData*fPointsToTestpoints to perform the construction; boolfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(); default constructor; fWS = new RooWorkspace(""FeldmanCousinsWS"");; fOwnsWorkspace = true;; fDataName = """";; fPdfName = """";. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the parameter points to perform the construction.; allow ability to profile on some nuisance paramters. ConfInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::PointSetInterval. FeldmanCousins(). Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& data); Set the DataSet. { fData = &data; }. void SetPdf(RooAbsPdf& pdf); Set the Pdf. { fPdf = &pdf; }. void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams.removeAll(); fNuisParams.add(set);}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__FeldmanCousins.html:9002,perform,perform,9002,root/html526/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html526/RooStats__FeldmanCousins.html,1,['perform'],['perform']
Performance,"_tfStartSafe! flag a safe start for point classification; Double_tfStep! step to be done from current point and direction; TGeoNode*fTopNode! top physical node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNavigator(); dummy constructor. TGeoNavigator(TGeoManager* geom); Default constructor. TGeoNavigator(const TGeoNavigator& ); Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNavigator.html:12684,perform,performance,12684,root/html528/TGeoNavigator.html,https://root.cern,https://root.cern/root/html528/TGeoNavigator.html,2,['perform'],['performance']
Performance,"_tnumEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_toffset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Double_t value) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:18797,optimiz,optimizeCacheMode,18797,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,1,['optimiz'],['optimizeCacheMode']
Performance,"_type;; 482 ; 483 void push_back(const T &Elt); 484 {; 485 if (R__unlikely(this->size() >= this->capacity())); 486 this->grow();; 487 memcpy(reinterpret_cast<void *>(this->end()), &Elt, sizeof(T));; 488 this->set_size(this->size() + 1);; 489 }; 490 ; 491 void pop_back() { this->set_size(this->size() - 1); }; 492};; 493 ; 494/// Storage for the SmallVector elements. This is specialized for the N=0 case; 495/// to avoid allocating unnecessary storage.; 496template <typename T, unsigned N>; 497struct SmallVectorStorage {; 498 alignas(T) char InlineElts[N * sizeof(T)]{};; 499};; 500 ; 501/// We need the storage to be properly aligned even for small-size of 0 so that; 502/// the pointer math in \a SmallVectorTemplateCommon::getFirstEl() is; 503/// well-defined.; 504template <typename T>; 505struct alignas(T) SmallVectorStorage<T, 0> {; 506};; 507 ; 508/// The size of the inline storage of an RVec.; 509/// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); 510/// unless the size of the buffer with 8 elements would be over a certain maximum size.; 511template <typename T>; 512struct RVecInlineStorageSize {; 513private:; 514#ifdef R__HAS_HARDWARE_INTERFERENCE_SIZE; 515 constexpr std::size_t cacheLineSize = std::hardware_destructive_interference_size;; 516#else; 517 // safe bet: assume the typical 64 bytes; 518 static constexpr std::size_t cacheLineSize = 64;; 519#endif; 520 static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);; 521 static constexpr unsigned maxInlineByteSize = 1024;; 522 ; 523public:; 524 static constexpr unsigned value =; 525 elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8);; 526};; 527 ; 528// A C++14-compatible implementation of std::uninitialized_value_construct; 529template <typename ForwardIt>; 530void UninitializedValueConstruct(ForwardIt first, ForwardIt last); 531{; 532#if __cplusplus < 201703L; 533 for (; first !=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RVec_8hxx_source.html:18704,cache,cacheline,18704,doc/v632/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RVec_8hxx_source.html,1,['cache'],['cacheline']
Performance,"_type;; 482 ; 483 void push_back(const T &Elt); 484 {; 485 if (R__unlikely(this->size() >= this->capacity())); 486 this->grow();; 487 memcpy(reinterpret_cast<void *>(this->end()), &Elt, sizeof(T));; 488 this->set_size(this->size() + 1);; 489 }; 490 ; 491 void pop_back() { this->set_size(this->size() - 1); }; 492};; 493 ; 494/// Storage for the SmallVector elements. This is specialized for the N=0 case; 495/// to avoid allocating unnecessary storage.; 496template <typename T, unsigned N>; 497struct SmallVectorStorage {; 498 alignas(T) char InlineElts[N * sizeof(T)]{};; 499};; 500 ; 501/// We need the storage to be properly aligned even for small-size of 0 so that; 502/// the pointer math in \a SmallVectorTemplateCommon::getFirstEl() is; 503/// well-defined.; 504template <typename T>; 505struct alignas(T) SmallVectorStorage<T, 0> {; 506};; 507 ; 508/// The size of the inline storage of an RVec.; 509/// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); 510/// unless the size of the buffer with 8 elements would be over a certain maximum size.; 511template <typename T>; 512struct RVecInlineStorageSize {; 513private:; 514#ifdef R__HAS_HARDWARE_INTERFERENCE_SIZE; 515 static constexpr std::size_t cacheLineSize = std::hardware_destructive_interference_size;; 516#else; 517 // safe bet: assume the typical 64 bytes; 518 static constexpr std::size_t cacheLineSize = 64;; 519#endif; 520 static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);; 521 static constexpr unsigned maxInlineByteSize = 1024;; 522 ; 523public:; 524 static constexpr unsigned value =; 525 elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8);; 526};; 527 ; 528// A C++14-compatible implementation of std::uninitialized_value_construct; 529template <typename ForwardIt>; 530void UninitializedValueConstruct(ForwardIt first, ForwardIt last); 531{; 532#if __cplusplus < 201703L; 533 for (; f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:18705,cache,cacheline,18705,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,1,['cache'],['cacheline']
Performance,"_t ; load = kFALSE . ); const. Return pointer to global variable with address addr. ; Definition at line 1639 of file TROOT.cxx. ◆ GetGlobalFunction(). TFunction * TROOT::GetGlobalFunction ; (; const char * ; function, . const char * ; params = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If params != 0 it will also resolve overloading other it returns the first name match. If params == 0 and load is true force reading of all currently defined global functions from Cling. The param string must be of the form: ""3189,\""aap\"",1.3"". ; Definition at line 1685 of file TROOT.cxx. ◆ GetGlobalFunctions(). TListOfFunctions * TROOT::GetGlobalFunctions ; (; ). protected . Internal routine returning, and creating if necessary, the list of global function. ; Definition at line 1663 of file TROOT.cxx. ◆ GetGlobalFunctionWithPrototype(). TFunction * TROOT::GetGlobalFunctionWithPrototype ; (; const char * ; function, . const char * ; proto = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If proto != 0 it will also resolve overloading. If load is true force reading of all currently defined global functions from CINT (more expensive). The proto string must be of the form: ""int, char*, float"". ; Definition at line 1718 of file TROOT.cxx. ◆ GetIconPath(). const TString & TROOT::GetIconPath ; (; ). static . Get the icon path in the installation. Static utility function. ; Definition at line 3168 of file TROOT.cxx. ◆ GetIncludeDir(). const TString & TROOT::GetIncludeDir ; (; ). static . Get the include directory in the installation. Static utility function. ; Definition at line 3042 of file TROOT.cxx. ◆ GetInterpreter(). TInterpreter * TROOT::GetInterpreter ; (; ); const. inline . Definition at line 210 of file TROOT.h. ◆ GetLibDir(). const TString & TROOT::GetLibDir ; (; ). static . Get the library directory in the installation. Static utility function. ; Definition at line 3010 of file TROOT.cxx. ◆ GetListOfBrows",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:53622,load,load,53622,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,1,['load'],['load']
Performance,"_t ; load = kFALSE . ); const. Return pointer to global variable with address addr. ; Definition at line 1639 of file TROOT.cxx. ◆ GetGlobalFunction(). TFunction * TROOT::GetGlobalFunction ; (; const char * ; function, . const char * ; params = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If params != 0 it will also resolve overloading other it returns the first name match. If params == 0 and load is true force reading of all currently defined global functions from Cling. The param string must be of the form: ""3189,\""aap\"",1.3"". ; Definition at line 1685 of file TROOT.cxx. ◆ GetGlobalFunctions(). TListOfFunctions * TROOT::GetGlobalFunctions ; (; ). protected . Internal routine returning, and creating if necessary, the list of global function. ; Definition at line 1663 of file TROOT.cxx. ◆ GetGlobalFunctionWithPrototype(). TFunction * TROOT::GetGlobalFunctionWithPrototype ; (; const char * ; function, . const char * ; proto = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If proto != 0 it will also resolve overloading. If load is true force reading of all currently defined global functions from CINT (more expensive). The proto string must be of the form: ""int, char*, float"". ; Definition at line 1718 of file TROOT.cxx. ◆ GetIconPath(). const TString & TROOT::GetIconPath ; (; ). static . Get the icon path in the installation. Static utility function. ; Definition at line 3172 of file TROOT.cxx. ◆ GetIncludeDir(). const TString & TROOT::GetIncludeDir ; (; ). static . Get the include directory in the installation. Static utility function. ; Definition at line 3046 of file TROOT.cxx. ◆ GetInterpreter(). TInterpreter * TROOT::GetInterpreter ; (; ); const. inline . Definition at line 210 of file TROOT.h. ◆ GetLibDir(). const TString & TROOT::GetLibDir ; (; ). static . Get the library directory in the installation. Static utility function. ; Definition at line 3014 of file TROOT.cxx. ◆ GetListOfBrows",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT.html:53591,load,load,53591,doc/master/classTROOT.html,https://root.cern,https://root.cern/doc/master/classTROOT.html,1,['load'],['load']
Performance,"_t ; notOnClient = kFALSE, . TList * ; workers = 0 . ). Enable specified package. ; Executes the PROOF-INF/BUILD.sh script if it exists followed by the PROOF-INF/SETUP.C script. In case notOnClient = true, don't enable the package on the client. The default is to enable packages also on the client. It is is possible to specify options for the loading step via 'loadopts'; the string will be passed passed as argument to SETUP. Special option 'chkv=<o>' (or 'checkversion=<o>') can be used to control plugin version checking during building: possible choices are: off no check; failure may occur at loading on check ROOT version [default] svn check ROOT version and Git commit SHA1. (Use ';', ' ' or '|' to separate 'chkv=<o>' from the rest.) If specified, enables packages only on the specified workers. Returns 0 in case of success and -1 in case of error. ; Definition at line 8197 of file TProof.cxx. ◆ EnablePackage() [3/3]. Int_t TProof::EnablePackage ; (; const char * ; package, . TList * ; loadopts, . Bool_t ; notOnClient = kFALSE, . TList * ; workers = 0 . ). Enable specified package. ; Executes the PROOF-INF/BUILD.sh script if it exists followed by the PROOF-INF/SETUP.C script. In case notOnClient = true, don't enable the package on the client. The default is to enable packages also on the client. It is is possible to specify a list of objects to be passed to the SETUP functions via 'loadopts'; the objects must be streamable. Returns 0 in case of success and -1 in case of error. ; Definition at line 8258 of file TProof.cxx. ◆ Exec() [1/3]. Int_t TProof::Exec ; (; const char * ; cmd, . Bool_t ; plusMaster = kFALSE . ). Send command to be executed on the PROOF master and/or slaves. ; If plusMaster is kTRUE then exeucte on slaves and master too. Command can be any legal command line command. Commands like "".x file.C"" or "".L file.C"" will cause the file file.C to be send to the PROOF cluster. Returns -1 in case of error, >=0 in case of succes. ; Definition at line 6521 of f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:87459,load,loadopts,87459,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['load'],['loadopts']
Performance,_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; void fillCacheObject (FuncCacheElem &cacheFunc) const override;  Fill cache using running integral cache elements calculate() method with specification of cdf-specific boundary conditions. ;  ;  Protected Member Functions inherited from RooNumRunningInt; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  Return observable in nset to be cached by RooAbsCachedPdf this is always the x observable that is integrated. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  Return the parameters of the cache created by RooAbsCachedPdf. ;  ; const char * binningName () const override;  ; FuncCacheElem * createCache (const RooArgSet *nset) const override;  Create custom cache element for running integral calculations. ;  ; double evaluate () const override;  Dummy function that is never called. ;  ; void fillCacheObject (FuncCacheElem &cacheFunc) const override;  Fill the cache object by calling its calculate() method. ;  ; const char * inputBaseName () const override;  Return unique name for RooA,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumCdf.html:49724,cache,cacheFunc,49724,doc/master/classRooNumCdf.html,https://root.cern,https://root.cern/doc/master/classRooNumCdf.html,3,['cache'],"['cache', 'cacheFunc']"
Performance,"_t LoadQueryFont (const char *font_name) override;  Load font and query font. ;  ; void LookupString (Event_t *event, char *buf, Int_t buflen, UInt_t &keysym) override;  Convert the keycode from the event structure to a key symbol (according to the modifiers specified in the event structure and the current keyboard mapping). ;  ; void LowerWindow (Window_t id) override;  Lower window so it lays below all its siblings. ;  ; void MapRaised (Window_t id) override;  Map window on screen and put on top of all windows. ;  ; void MapSubwindows (Window_t id) override;  Map sub windows. ;  ; void MapWindow (Window_t id) override;  Map window on screen. ;  ; void MoveResizeWindow (Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Move and resize a window. ;  ; void MoveWindow (Int_t wid, Int_t x, Int_t y) override;  Move the window wid. ;  ; void MoveWindow (Window_t id, Int_t x, Int_t y) override;  Move a window. ;  ; void NextEvent (Event_t &event) override;  Copies first pending event from event queue to Event_t structure and removes event from queue. ;  ; Int_t OpenDisplay (const char *dpyName) override;  Open connection to display server (if such a thing exist on the current platform). ;  ; Int_t OpenDisplay (void *display);  Open the display. Return -1 if the opening fails, 0 when ok. ;  ; Int_t OpenPixmap (UInt_t w, UInt_t h) override;  Open a new pixmap. ;  ; Bool_t ParseColor (Colormap_t cmap, const char *cname, ColorStruct_t &color) override;  Parse string cname containing color name, like ""green"" or ""#00FF00"". ;  ; Bool_t PointInRegion (Int_t x, Int_t y, Region_t reg) override;  Returns true if the point x,y is in the region. ;  ; Region_t PolygonRegion (Point_t *points, Int_t np, Bool_t winding) override;  Create region for the polygon defined by the points array. ;  ; void PutImage (Drawable_t id, GContext_t gc, Drawable_t img, Int_t dx, Int_t dy, Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Put (x,y,w,h) part of image img in window win at position",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11.html:16223,queue,queue,16223,doc/master/classTGX11.html,https://root.cern,https://root.cern/doc/master/classTGX11.html,4,['queue'],['queue']
Performance,"_t ProcessWS (THttpCallArg *arg) override;  Process websocket request - called from THttpServer thread THttpWSHandler interface. ;  ;  Public Member Functions inherited from THttpWSHandler; virtual ~THttpWSHandler ();  destructor Make sure that all sending threads are stopped correctly ;  ; void CloseWS (UInt_t wsid);  Close connection with given websocket id. ;  ; Int_t GetNumWS ();  Returns current number of websocket connections. ;  ; UInt_t GetWS (Int_t num=0);  Return websocket id with given sequential number Number of websockets returned with GetNumWS() method. ;  ; Bool_t HasWS (UInt_t wsid);  Return kTRUE if websocket with given ID exists. ;  ; TClass * IsA () const override;  ; Bool_t IsDisabled () const;  Returns true when processing of websockets is disabled, set shortly before handler need to be destroyed. ;  ; Bool_t IsSyncMode () const;  Returns processing mode of WS handler If sync mode is TRUE (default), all event processing and data sending performed in main thread All send functions are blocking and must be performed from main thread If sync mode is false, WS handler can be used from different threads and starts its own sending threads. ;  ; Int_t SendCharStarWS (UInt_t wsid, const char *str);  Send string via given websocket id. ;  ; Int_t SendHeaderWS (UInt_t wsid, const char *hdr, const void *buf, int len);  Send binary data with text header via given websocket id. ;  ; Int_t SendWS (UInt_t wsid, const void *buf, int len);  Send binary data via given websocket id. ;  ; void SetDisabled ();  Disable all processing of websockets, normally called shortly before destructor. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowWSHandler.html:2113,perform,performed,2113,doc/v632/classROOT_1_1RWebWindowWSHandler.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowWSHandler.html,4,['perform'],['performed']
Performance,"_t _nameLength;  . #include <RooCachedReal.h>. Inheritance diagram for RooCachedReal:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooCachedReal() [1/4]. RooCachedReal::RooCachedReal ; (; ). inline . Definition at line 22 of file RooCachedReal.h. ◆ RooCachedReal() [2/4]. RooCachedReal::RooCachedReal ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _func, . const RooArgSet & ; cacheObs . ). Constructor taking name, title and function to be cached and fixed choice of variable to cache. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in the observables of the function. If the fixed set of cache observables does not match the observables defined in the use context of the p.d.f the cache is still filled completely. Ee.g. when it is specified to cache x and p and only x is a observable in the given use context the cache histogram will store sampled values for all values of observable x and parameter p. In such a mode of operation the cache will also not be recalculated if the observable p changes ; Definition at line 68 of file RooCachedReal.cxx. ◆ RooCachedReal() [3/4]. RooCachedReal::RooCachedReal ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _func . ). Constructor taking name, title and function to be cached. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in the observables of the function ; Definition at line 42 of file RooCachedReal.cxx. ◆ RooCachedReal() [4/4]. RooCachedReal::RooCachedReal ; (; const RooCachedReal & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 87 of file RooCachedReal.cxx. Member Function Documentation. ◆ actualObservables(). RooFit::OwningPtr< RooArgSet > RooCachedReal::actualObservables ; (; const RooArgSet & ; nset); const. overrideprot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:63987,cache,cache,63987,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,2,['cache'],['cache']
Performance,"_view ; name, . const std::vector< std::string > & ; variations . ). Definition at line 20 of file RJittedFilter.cxx. ◆ ~RJittedFilter(). RJittedFilter::~RJittedFilter ; (; ). Definition at line 34 of file RJittedFilter.cxx. Member Function Documentation. ◆ AddFilterName(). void RJittedFilter::AddFilterName ; (; std::vector< std::string > & ; filters). finalvirtual . Implements ROOT::Detail::RDF::RNodeBase.; Definition at line 122 of file RJittedFilter.cxx. ◆ CheckFilters(). bool RJittedFilter::CheckFilters ; (; unsigned int ; slot, . Long64_t ; entry . ). finalvirtual . Implements ROOT::Detail::RDF::RNodeBase.; Definition at line 56 of file RJittedFilter.cxx. ◆ FillReport(). void RJittedFilter::FillReport ; (; ROOT::RDF::RCutFlowReport & ; cr); const. finalvirtual . Reimplemented from ROOT::Detail::RDF::RFilterBase.; Definition at line 74 of file RJittedFilter.cxx. ◆ FinalizeSlot(). void RJittedFilter::FinalizeSlot ; (; unsigned int ; slot). finalvirtual . Clean-up operations to be performed at the end of a task. ; Implements ROOT::Detail::RDF::RFilterBase.; Definition at line 110 of file RJittedFilter.cxx. ◆ GetGraph(). std::shared_ptr< RDFGraphDrawing::GraphNode > RJittedFilter::GetGraph ; (; std::unordered_map< void *, std::shared_ptr< RDFGraphDrawing::GraphNode > > & ; visitedMap). finalvirtual . Implements ROOT::Detail::RDF::RNodeBase.; Definition at line 132 of file RJittedFilter.cxx. ◆ GetVariedFilter(). std::shared_ptr< RNodeBase > RJittedFilter::GetVariedFilter ; (; const std::string & ; ). finalvirtual . Return a clone of this node that acts as a Filter working with values in the variationName ""universe"". ; Reimplemented from ROOT::Detail::RDF::RNodeBase.; Definition at line 141 of file RJittedFilter.cxx. ◆ IncrChildrenCount(). void RJittedFilter::IncrChildrenCount ; (; ). finalvirtual . Implements ROOT::Detail::RDF::RNodeBase.; Definition at line 80 of file RJittedFilter.cxx. ◆ InitNode(). void RJittedFilter::InitNode ; (; ). finalvirtual . Reimplemented",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RJittedFilter.html:5085,perform,performed,5085,doc/master/classROOT_1_1Detail_1_1RDF_1_1RJittedFilter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RJittedFilter.html,1,['perform'],['performed']
Performance,`; 329 /// dir = newvalue;; 330 /// ```; 331 /// leads to; 332 /// ```; 333 /// gDirectory == newvalue; 334 /// ```; 335 /// To prevent this we would need a new mechanism such that the type; 336 /// used by `auto` in that case is `TDirectory*` rather than the `Internal`; 337 /// type `TDirectoryAtomicAdapter`.; 338 struct TDirectoryAtomicAdapter {; 339 // The shared pointer's lifetime is that of the thread creating this object; 340 // (with the default constructor); 341 TDirectory::SharedGDirectory_t &fValue;; 342 ; 343 TDirectoryAtomicAdapter() : fValue(TDirectory::GetSharedLocalCurrentDirectory()) {}; 344 ; 345 template <typename T>; 346 explicit operator T*() const {; 347 return (T *)fValue->load();; 348 }; 349 ; 350 operator TDirectory*() const {; 351 return fValue->load();; 352 }; 353 ; 354 operator bool() const { return fValue->load() != nullptr; }; 355 ; 356 bool operator==(const TDirectory *other) const {; 357 return fValue->load() == other;; 358 }; 359 ; 360 bool operator!=(const TDirectory *other) const {; 361 return fValue->load() != other;; 362 }; 363 ; 364 bool operator==(TDirectory *other) const {; 365 return fValue->load() == other;; 366 }; 367 ; 368 bool operator!=(TDirectory *other) const {; 369 return fValue->load() != other;; 370 }; 371 ; 372 TDirectory *operator=(TDirectory *newvalue) {; 373 if (newvalue) {; 374 newvalue->RegisterGDirectory(fValue);; 375 }; 376 fValue->exchange(newvalue);; 377 return newvalue;; 378 }; 379 ; 380 TDirectory *operator->() const { return fValue->load(); }; 381 };; 382} // Internal; 383} // ROOT; 384#define gDirectory (::ROOT::Internal::TDirectoryAtomicAdapter{}); 385 ; 386#endif; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; O,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8h_source.html:14865,load,load,14865,doc/master/TDirectory_8h_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html,8,['load'],['load']
Performance,"a ; RooNDKeysPdf General N-dimensional non-parametric kernel estimation p.d.f; RooNLLVar Function representing (extended) -log(L) of p.d.f and dataset; RooNameReg String name registry; RooNameSet A sterile version of RooArgSet, containing only the names of the contained RooAbsArgs; RooNonCPEigenDecay PDF to model CP-violating decays to final states which are not CP eigenstates; RooNormSetCache Management tool for tracking sets of similar integration/normalization sets; RooNovosibirsk Novosibirsk PDF; RooNumCdf Numeric calculator for CDF for a given PDF; RooNumConvPdf Operator PDF implementing numeric convolution of 2 input PDFs; RooNumConvolution Operator PDF implementing numeric convolution of 2 input functions; RooNumGenConfig Numeric (MC) Event generator configuration ; RooNumGenFactory Numeric Generator factory; RooNumIntConfig Numeric Integrator configuration ; RooNumIntFactory Numeric Integrator factory; RooNumRunningInt Numeric calculator for running integral of a given function; RooNumber wrapper class for portable numerics; RooObjCacheManager Cache manager for generic caches that contain RooAbsArg objects; RooParamBinning Binning specification with ranges parameterized by external RooAbsReal functions; RooParametricStepFunction Parametric Step Function Pdf; RooPlot Plot frame and container for graphics objects; RooPlotable Abstract interface for plotable objects in a RooPlot; RooPoisson A Poisson PDF; RooPolyVar Polynomial function; RooPolynomial Polynomial PDF; RooPrintable Interface for printable objects; RooProdGenContext Context for efficient generation of a a dataset from a RooProdPdf; RooProdPdf PDF representing a product of PDFs; RooProduct Product of RooAbsReal and/or RooAbsCategory terms; RooProfileLL Real-valued function representing profile likelihood of external (likelihood) function; RooProjectedPdf Operator p.d.f calculating projection of another p.d.f; RooProofDriverSelector ; RooPullVar Calculation of pull of measurement w.r.t a truth value; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:38843,cache,caches,38843,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['cache'],['caches']
Performance,"a C++ command when some event happens in a pad ;  ►CTExMapThis class stores a (key,value) pair using an external hash ;  CAssoc_t;  CTExMapIter;  ►CTF11-Dim function class ;  CTF1FunctorPointer;  CTF1FunctorPointerImpl;  CTF12A projection of a TF2 along X or Y ;  CTF1AbsComposition;  CTF1ConvolutionClass wrapping convolution of two functions ;  CTF1Editor;  CTF1NormSumClass adding two functions: c1*f1+c2*f2 ;  CTF1ParametersTF1 Parameters class ;  CTF2A 2-Dim function with parameters ;  CTF2GLGL renderer for TF2 ;  CTF3A 3-Dim function with parameters ;  CTFastCgi;  CTFeldmanCousinsClass to calculate the CL upper limit using the Feldman-Cousins method as described in PRD V57 #7, p3873-3889 ;  CTFFTComplex;  CTFFTComplexReal;  CTFFTReal;  CTFFTRealComplex;  ►CTFileA ROOT file is a suite of consecutive data records (TKey instances) with a well defined format ;  CInfoListRetSimple struct of the return value of GetStreamerInfoListImpl ;  CTFileCacheReadA cache when reading files over the network ;  CTFileCacheWriteA cache when writing files over the network ;  CTFileCollectionClass that contains a list of TFileInfo's and accumulated meta data information about its entries ;  CTFileDrawMapThis class is automatically called by TFile::DrawMap ;  CTFileHandler;  CTFileInfoClass describing a generic file including meta information ;  CTFileInfoMeta;  CTFileIter;  CTFileMergeInfo;  CTFileMergerThis class provides file copy and merging services ;  CTFileOpenHandleClass holding info about the file being opened ;  CTFilePrefetchThe prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a block of tree entries ;  CTFileSet;  CTFileStager;  ►CTFitEditor;  CFuncParamData_tTF1Convolution object ;  CTFitParametersDialog;  CTFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O ;  CTFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointer, i.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:154515,cache,cache,154515,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,2,['cache'],['cache']
Performance,"a ROOT session, you can do:; root > T->Process(""myselect.C""). Bool_t MemoryFull(Int_t nbytes); Check if adding nbytes to memory we are still below MaxVirtualsize. TTree* MergeTrees(TList* list, Option_t* option = """"); Static function merging the trees in the TList into a new tree. Trees in the list can be memory or disk-resident trees.; The new tree is created in the current directory (memory if gROOT). Long64_t Merge(TCollection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:107928,load,loading,107928,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,2,['load'],['loading']
Performance,"a RooDataHist. The first list of observables are the p.d.f.; observables, which may any RooAbsReal (function or variable). The second list; are the corresponding observables in the RooDataHist which must be of type; RooRealVar or RooCategory This constructor thus allows to apply a coordinate transformation; on the histogram data to be applied. RooHistPdf(const RooHistPdf& other, const char* name = 0); Copy constructor. ~RooHistPdf(); Destructor. Double_t evaluate() const; Return the current value: The value of the bin enclosing the current coordinates; of the observables, normalized by the histograms contents. Interpolation; is applied if the RooHistPdf is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooHistPdf. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistPdf can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used on the integral over; all histogram observables is supported. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. Int_t getMaxVal(const RooArgSet& vars) const; Only handle case of maximum in all variables. Double_t maxVal(Int_t code) const. Bool_t importWorkspaceHook(RooWorkspace& ws); Check if our datahist is already in the workspace. TObject* clone(const char* newname) const; { return new",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistPdf.html:42856,perform,perform,42856,root/html528/RooHistPdf.html,https://root.cern,https://root.cern/root/html528/RooHistPdf.html,1,['perform'],['perform']
Performance,"a RooDataHist. The first list of observables are the p.d.f.; observables, which may any RooAbsReal (function or variable). The second list; are the corresponding observables in the RooDataHist which must be of type; RooRealVar or RooCategory This constructor thus allows to apply a coordinate transformation; on the histogram data to be applied. RooHistPdf(const RooHistPdf& other, const char* name = 0); Copy constructor. ~RooHistPdf(); Destructor. Double_t evaluate() const; Return the current value: The value of the bin enclosing the current coordinates; of the observables, normalized by the histograms contents. Interpolation; is applied if the RooHistPdf is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooHistPdf. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistPdf can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used on the integral over; all histogram observables is supported. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. Int_t getMaxVal(const RooArgSet& vars) const; Only handle case of maximum in all variables. Double_t maxVal(Int_t code) const. Bool_t importWorkspaceHook(RooWorkspace& ws); Check if our datahist is already in the workspace. void Streamer(TBuffer& b); Stream an object of class Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooHistPdf.html:43072,perform,perform,43072,root/html530/RooHistPdf.html,https://root.cern,https://root.cern/root/html530/RooHistPdf.html,1,['perform'],['perform']
Performance,"a RooDataHist. The first list of observables are the p.d.f.; observables, which may any RooAbsReal (function or variable). The second list; are the corresponding observables in the RooDataHist which must be of type; RooRealVar or RooCategory This constructor thus allows to apply a coordinate transformation; on the histogram data to be applied. RooHistPdf(const RooHistPdf& other, const char* name = 0); Copy constructor. ~RooHistPdf(); Destructor. Double_t evaluate() const; Return the current value: The value of the bin enclosing the current coordinates; of the observables, normalized by the histograms contents. Interpolation; is applied if the RooHistPdf is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooHistPdf. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistPdf can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used on the integral over; all histogram observables is supported. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. Int_t getMaxVal(const RooArgSet& vars) const; Only handle case of maximum in all variables. Double_t maxVal(Int_t code) const. TObject* clone(const char* newname) const; { return new RooHistPdf(*this,newname); }. RooDataHist& dataHist(); Return RooDataHist that is represented. c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistPdf.html:42021,perform,perform,42021,root/html526/RooHistPdf.html,https://root.cern,https://root.cern/root/html526/RooHistPdf.html,1,['perform'],['perform']
Performance,"a RooDataHist. The first list of observables are the p.d.f.; observables, which may any RooAbsReal (function or variable). The second list; are the corresponding observables in the RooDataHist which must be of type; RooRealVar or RooCategory This constructor thus allows to apply a coordinate transformation; on the histogram data to be applied. RooHistPdf(const RooHistPdf& other, const char* name = 0); Copy constructor. ~RooHistPdf(); Destructor. Double_t evaluate() const; Return the current value: The value of the bin enclosing the current coordinates; of the observables, normalized by the histograms contents. Interpolation; is applied if the RooHistPdf is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooHistPdf. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistPdf can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used on the integral over; all histogram observables is supported. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-inter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistPdf.html:44303,perform,perform,44303,root/html532/RooHistPdf.html,https://root.cern,https://root.cern/root/html532/RooHistPdf.html,4,['perform'],['perform']
Performance,"a TNamed on the python side, and transfer it back and forth.; 50/// root [1] std::any res1;; 51/// root [2] TPython::Exec(""_anyresult = ROOT.std.make_any['TNamed']('hello', '')"", &res1);; 52/// root [3] TPython::Bind(&std::any_cast<TNamed&>(res1), ""n"");; 53/// root [4] std::any res2;; 54/// root [5] TPython::Exec(""_anyresult = ROOT.std.make_any['TNamed*', 'TNamed*'](n)"", &res2);; 55/// root [6] (&std::any_cast<TNamed&>(res1) == std::any_cast<TNamed*>(res2)); 56/// (bool) true; 57///; 58/// // Variables can cross-over by using an `std::any` with a specific name.; 59/// root [6] TPython::Exec(""_anyresult = ROOT.std.make_any['Int_t'](1 + 1)"", &res1);; 60/// root [7] std::any_cast<int>(res1); 61/// (int) 2; 62/// ~~~; 63///; 64/// And with a python file `MyPyClass.py` like this:; 65/// ~~~{.py}; 66/// print 'creating class MyPyClass ... '; 67///; 68/// class MyPyClass:; 69/// def __init__( self ):; 70/// print 'in MyPyClass.__init__'; 71///; 72/// def gime( self, what ):; 73/// return what; 74/// ~~~; 75/// one can load a python module, and use the class. Casts are; 76/// necessary as the type information can not be otherwise derived.; 77/// ~~~{.cpp}; 78/// root [6] TPython::LoadMacro( ""MyPyClass.py"" );; 79/// creating class MyPyClass ...; 80/// root [7] MyPyClass m;; 81/// in MyPyClass.__init__; 82/// root [8] std::string s = (char*)m.gime( ""aap"" );; 83/// root [9] s; 84/// (class TString)""aap""; 85/// ~~~; 86/// It is possible to switch between interpreters by calling `TPython::Prompt()`; 87/// on the Cling side, while returning with `^D` (EOF). State is preserved between; 88/// successive switches.; 89///; 90/// The API part provides (direct) C++ access to the bindings functionality of; 91/// PyROOT. It allows verifying that you deal with a PyROOT python object in the; 92/// first place (CPPInstance_Check for CPPInstance and any derived types, as well; 93/// as CPPInstance_CheckExact for CPPInstance's only); and it allows conversions; 94/// of `void*` to an CPPInstanc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPython_8cxx_source.html:2820,load,load,2820,doc/master/TPython_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html,1,['load'],['load']
Performance,"a being generated; Bool_tRooAbsGenContext::_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooArgSet*_cloneSetInternal clone of p.d.f.; RooAbsReal*_effPointer to efficiency function; RooAbsGenContext*_generatorGenerator context for p.d.f. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooEffGenContext(const RooAbsPdf& model, const RooAbsPdf& pdf, const RooAbsReal& eff, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Constructor of generator context for RooEffProd products. ~RooEffGenContext(); Destructor. void initGenerator(const RooArgSet& theEvent); One-time initialization of generator. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. Generate an event from the p.d.f and; then perform an accept/reject sampling based on the efficiency; function. RooEffGenContext(const RooAbsPdf& model, const RooAbsPdf& pdf, const RooAbsReal& eff, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Mon Jul 4 15:22:41 2011 » Last generated: 2011-07-04 15:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooEffGenContext.html:9530,perform,perform,9530,root/html530/RooEffGenContext.html,https://root.cern,https://root.cern/root/html530/RooEffGenContext.html,1,['perform'],['perform']
Performance,"a being generated; Bool_tRooAbsGenContext::_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooArgSet*_cloneSetInternal clone of p.d.f.; RooAbsReal*_effPointer to efficiency function; RooAbsGenContext*_generatorGenerator context for p.d.f. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooEffGenContext(const RooAbsPdf& model, const RooAbsPdf& pdf, const RooAbsReal& eff, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Constructor of generator context for RooEffProd products. ~RooEffGenContext(); Destructor. void initGenerator(const RooArgSet& theEvent); One-time initialization of generator. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. Generate an event from the p.d.f and; then perform an accept/reject sampling based on the efficiency; function. RooEffGenContext(const RooAbsPdf& model, const RooAbsPdf& pdf, const RooAbsReal& eff, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Thu Nov 3 20:07:59 2011 » Last generated: 2011-11-03 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooEffGenContext.html:9556,perform,perform,9556,root/html532/RooEffGenContext.html,https://root.cern,https://root.cern/root/html532/RooEffGenContext.html,1,['perform'],['perform']
Performance,"a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:5555,cache,cache,5555,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"a concrete implementation of the ProposalFunction interface.; It proposes points across the parameter space in the distribution of the; given PDF. To make Propose(xPrime, x) dependent on x, configure with; PdfProposal::AddMapping(varToUpdate, valueToUse). For example, suppose we have:. // our parameter; RooRealVar p(""p"", ""p"", 5, 0, 10);; // create mean and sigma for gaussian proposal function; RooRealVar meanP(""meanP"", ""meanP"", 0, 10);; RooRealVar sigma(""sigma"", ""sigma"", 1, 0, 5);; RooGaussian pGaussian(""pGaussian"", ""pGaussian"", p, meanP, sigma);; // configure proposal function; PdfProposal pdfProposal(pGaussian);; pdfProposal.AddMapping(meanP, p); // each call of Propose(xPrime, x), meanP in; // the proposal function will be updated to; // the value of p in x. this will center the; // proposal function about x's p when; // proposing for xPrime; // To improve performance, PdfProposal has the ability to cache a specified; // number of proposals. If you don't call this function, the default cache size; // is 1, which can be slow.; pdfProposal.SetCacheSize(desiredCacheSize);. PdfProposal currently uses a fixed cache size. Adaptive caching methods are in the works; for future versions. Function Members (Methods); public:. virtual~PdfProposal(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddMapping(RooRealVar& proposalParam, RooAbsReal& update); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual boolRooStats::ProposalFunction::CheckParameters(RooArgSet& params); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__PdfProposal.html:1368,cache,cache,1368,root/html526/RooStats__PdfProposal.html,https://root.cern,https://root.cern/root/html526/RooStats__PdfProposal.html,7,['cache'],['cache']
Performance,"a fixed set of observables, return all variables of the external input p.d.f that are not one of the cache observables. ;  ; FuncCacheElem * createCache (const RooArgSet *nset) const override;  Interface function to create an internal cache object that represent each cached function configuration. ;  ; double evaluate () const override;  Dummy evaluate, it is never called. ;  ; void fillCacheObject (FuncCacheElem &cacheFunc) const override;  Update contents of cache histogram by resampling the input function. ;  ; const char * inputBaseName () const override;  Return base name for caches, i.e. the name of the cached function. ;  ; void operModeHook () override;  ; const char * payloadUniqueSuffix () const override;  ;  Protected Member Functions inherited from RooAbsCachedReal; virtual const char * binningName () const;  ; TString cacheNameSuffix (const RooArgSet &nset) const;  Construct unique suffix name for cache p.d.f object. ;  ; FuncCacheElem * getCache (const RooArgSet *nset) const;  Retrieve cache corresponding to observables in nset. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:50471,cache,cache,50471,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,1,['cache'],['cache']
Performance,"a function which gets callback from cling when DynamicLibraryManager->loadLibrary failed for some reason.; 6566// Try to solve the problem by AutoLoading. Return true when AutoLoading success, return; 6567// false if not.; 6568bool TCling::LibraryLoadingFailed(const std::string& errmessage, const std::string& libStem, bool permanent, bool resolved); 6569{; 6570 StringRef errMsg(errmessage);; 6571 if (errMsg.contains(""undefined symbol: "")) {; 6572 // This branch is taken when the callback was from DynamicLibraryManager::loadLibrary; 6573 std::string mangled_name = std::string(errMsg.split(""undefined symbol: "").second);; 6574 void* res = ((TCling*)gCling)->LazyFunctionCreatorAutoload(mangled_name);; 6575 cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();; 6576 if (res && DLM && (DLM->loadLibrary(libStem, permanent, resolved) == cling::DynamicLibraryManager::kLoadLibSuccess)); 6577 // Return success when LazyFunctionCreatorAutoload could find mangled_name; 6578 return true;; 6579 } else {; 6580 // The callback is from IncrementalExecutor::diagnoseUnresolvedSymbols; 6581 if ( ((TCling*)gCling)->LazyFunctionCreatorAutoload(errmessage)); 6582 return true;; 6583 }; 6584 ; 6585 return false;; 6586}; 6587 ; 6588////////////////////////////////////////////////////////////////////////////////; 6589/// Autoload a library based on a missing symbol.; 6590 ; 6591void* TCling::LazyFunctionCreatorAutoload(const std::string& mangled_name) {; 6592 std::string dlsym_mangled_name = ROOT::TMetaUtils::DemangleNameForDlsym(mangled_name);; 6593 ; 6594 // We have already loaded the library.; 6595 if (void* Addr = llvm::sys::DynamicLibrary::SearchForAddressOfSymbol(dlsym_mangled_name)); 6596 return Addr;; 6597 ; 6598 const cling::DynamicLibraryManager &DLM = *GetInterpreterImpl()->getDynamicLibraryManager();; 6599 R__LOCKGUARD(gInterpreterMutex);; 6600 ; 6601 auto LibLoader = [](const std::string& LibName) -> bool {; 6602 if (gSystem->Load(LibName.c_str(), """", false)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:255919,load,loadLibrary,255919,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loadLibrary']
Performance,"a hint.; 513 ///; 514 /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.; 515 /// The following objects and methods automatically take advantage of; 516 /// multi-threading if a call to `EnableImplicitMT` has been made before usage:; 517 ///; 518 /// - RDataFrame internally runs the event-loop by parallelizing over clusters of entries; 519 /// - TTree::GetEntry reads multiple branches in parallel; 520 /// - TTree::FlushBaskets writes multiple baskets to disk in parallel; 521 /// - TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; 522 /// - THx::Fit performs in parallel the evaluation of the objective function over the data; 523 /// - TMVA::DNN trains the deep neural networks in parallel; 524 /// - TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel; 525 ///; 526 /// EnableImplicitMT calls in turn EnableThreadSafety.; 527 /// The 'numthreads' parameter allows to control the number of threads to; 528 /// be used by the implicit multi-threading. However, this parameter is just; 529 /// a hint for ROOT: it will try to satisfy the request if the execution; 530 /// scenario allows it. For example, if ROOT is configured to use an external; 531 /// scheduler, setting a value for 'numthreads' might not have any effect.; 532 /// The maximum number of threads can be influenced by the environment; 533 /// variable `ROOT_MAX_THREADS`: `export ROOT_MAX_THREADS=2` will try to set; 534 /// the maximum number of active threads to 2, if the scheduling library; 535 /// (such as tbb) ""permits"".; 536 ///; 537 /// \note Use `DisableImplicitMT()` to disable multi-threading (some locks will remain in place as; 538 /// described in EnableThreadSafety()). `EnableImplicitMT(1)` creates a thread-pool of size 1.; 539 void EnableImplicitMT(UInt_t numthreads); 540 {; 541#ifdef R__USE_IMT; 542 if (ROOT::Internal::IsImplicitMTEnabledImpl()); 543 return;; 544 EnableThreadSafety();; 545 static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:19711,multi-thread,multi-threading,19711,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['multi-thread'],['multi-threading']
Performance,"a node can have only one parent and several daughters. For a better understanding of the hierarchy, have a look at TGeoManage.; Just close now the X3D window and focus at the wire frame picture drawn in a pad. Activate Options/Event Status. Moving the mouse in the pad, you will notice that objects are sometimes changing color to red. Volumes are highlighted in this way whenever the mouse pointer is close enough to one of its vertices. When this happens, the corresponding volume is selected and you will see in the bottom right size of the ROOT canvas its name, shape type and corresponding path in the physical tree. Right clicking on the screen when a volume is selected will also open its context menu (picking). Note that there are several actions that can be performed both at view (no volume selected) and volume level.; TView (mouse not selecting any volume):. Click-and-drag rotates the view.; Pressing some keys perform different actions:; J/K - zoom / unzoom; H, L, U, I - move the viewpoint; Right click + SetParallel ()/SetPerspective () - switch from parallel to perspective view.; Right click + ShowAxis() - show coordinate axes.; Right click + Centered/Left/Side/Top - change view direction. TGeoVolume (mouse selecting a volume):. Double click will focus the corresponding volume.; Right click + CheckOverlaps() - run overlap checker on current volume.; Right click + Draw () - draw that volume according current global visualization options; Right click + DrawOnly() - draw only the selected volume.; Right click + InspectShape/Material() - print info about shape or material.; Right click + Raytrace() - initiate a ray tracing algorithm on current view.; Right click + RandomPoints/Rays() - shoot random points or rays inside the bounding box of the clicked volume and display only those inside visible volumes.; Right click + Weight() - estimates the weight of a volume within a given precision. Note that there are several additional methods for visibility and line attributes ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:14445,perform,perform,14445,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['perform']
Performance,"a referenced object and the parent object supporting this referenced object. ; The parent object is typically a branch of a TTree. For each object referenced in a TTree entry, the corresponding entry in the TTree's TBranchRef::fRefTable contains the index of the branch that needs to be loaded to bring the object into memory.; Persistency of a TRefTable is split into two parts:; entry specific information is stored (read) by FillBuffer (ReadBuffer). For each referenced object the object's fUniqueID and the referencing TRef::fPID is stored (to allow the TRefTable to autoload references created by different processes).; non-entry specific, i.e. global information is stored (read) by the Streamer function. This comprises all members marked as persistent. As TObject::fUniqueID is only unique for a given TProcessID, a table of unique IDs is kept for each used TProcessID. There is no natural order of TProcessIDs, so TRefTable stores a vector of the TGUID of all known TProcessIDs in fProcessGUIDs; the index of a TProcessID in this vector defines the index of the auto-loading info in fParentIDs for that TProcessID. The mapping of TProcessID* to index is cached for quick non-persistent lookup. ; Definition at line 35 of file TRefTable.h. Public Types; enum  EStatusBits { kHaveWarnedReadingOld = (1ULL << ( 14 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TRefTa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRefTable.html:1504,load,loading,1504,doc/master/classTRefTable.html,https://root.cern,https://root.cern/doc/master/classTRefTable.html,1,['load'],['loading']
Performance,"a request for boosting (i.e., BostNum > 0); 386 Int_t boostNum = 0;; 387 TMVA::Configurable *conf = new TMVA::Configurable(theOption);; 388 conf->DeclareOptionRef(boostNum = 0, ""Boost_num"", ""Number of times the classifier will be boosted"");; 389 conf->ParseOptions();; 390 delete conf;; 391 // this is name of weight file directory; 392 TString fileDir;; 393 if (fModelPersistence) {; 394 // find prefix in fWeightFileDir;; 395 TString prefix = gConfig().GetIONames().fWeightFileDirPrefix;; 396 fileDir = prefix;; 397 if (!prefix.IsNull()); 398 if (fileDir[fileDir.Length() - 1] != '/'); 399 fileDir += ""/"";; 400 fileDir += loader->GetName();; 401 fileDir += ""/"" + gConfig().GetIONames().fWeightFileDir;; 402 }; 403 // initialize methods; 404 IMethod *im;; 405 if (!boostNum) {; 406 im = ClassifierFactory::Instance().Create(theMethodName.Data(), fJobName, methodTitle, loader->GetDataSetInfo(),; 407 theOption);; 408 } else {; 409 // boosted classifier, requires a specific definition, making it transparent for the user; 410 Log() << kDEBUG << ""Boost Number is "" << boostNum << "" > 0: train boosted classifier"" << Endl;; 411 im = ClassifierFactory::Instance().Create(""Boost"", fJobName, methodTitle, loader->GetDataSetInfo(), theOption);; 412 MethodBoost *methBoost = dynamic_cast<MethodBoost *>(im); // DSMTEST divided into two lines; 413 if (!methBoost) { // DSMTEST; 414 Log() << kFATAL << ""Method with type kBoost cannot be casted to MethodCategory. /Factory"" << Endl; // DSMTEST; 415 return nullptr;; 416 }; 417 if (fModelPersistence); 418 methBoost->SetWeightFileDir(fileDir);; 419 methBoost->SetModelPersistence(fModelPersistence);; 420 methBoost->SetBoostedMethodName(theMethodName); // DSMTEST divided into two lines; 421 methBoost->fDataSetManager = loader->GetDataSetInfo().GetDataSetManager(); // DSMTEST; 422 methBoost->SetFile(fgTargetFile);; 423 methBoost->SetSilentFile(IsSilentFile());; 424 }; 425 ; 426 MethodBase *method = dynamic_cast<MethodBase *>(im);; 427 if (method == 0); 428",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:16313,load,loader,16313,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"a square matrix; namechar name[80]Definition TGX11.cxx:110; xmaxfloat xmaxDefinition THbookFile.cxx:95; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; ROOT::Detail::RDF::RActionImplBase class for action helpers, see RInterface::Book() for more information.Definition RActionImpl.hxx:26; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; THnTTemplated implementation of the abstract base THn.Definition THn.h:219; TRandom::Uniformvirtual Double_t Uniform(Double_t x1=1)Returns a uniform deviate on the interval (0, x1).Definition TRandom.cxx:682; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; double; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; ROOT::TSeqUTSeq< unsigned int > TSeqUDefinition TSeq.hxx:204; TMVA::TMVAGlob::Initializevoid Initialize(Bool_t useTMVAStyle=kTRUE)Definition tmvaglob.cxx:176; ; THnT<float> (*0x55999709c0e0): ""myThN"" ""A THn with 4 dimensions""; 4 dimensions, 128 entries in 1440 filled bins; DateApril 2018 ; AuthorsEnrico Guiraud, Danilo Piparo (CERN) ; Definition in file df018_customActions.C. tutorialsdataframedf018_customActions.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df018__customActions_8C.html:4927,multi-thread,multi-threading,4927,doc/master/df018__customActions_8C.html,https://root.cern,https://root.cern/doc/master/df018__customActions_8C.html,2,['multi-thread'],['multi-threading']
Performance,"a stack object. Be very careful if you take the address of stack objects. As we shall see soon, they are deleted automatically, which could leave you with an illegal pointer. Using it will corrupt and may as well crash the program!; It is time to look at the destruction of objects. A destructor is a special C++ function that releases resources for (or destroys) an object of a class. It is the opposite of a constructor that creates the object of a class when it is called. The compiler will provide a destructor that does nothing if none is provided. We will add one to our Quad class so that we can see when it is called. The class names the destructor but with a prefix ~ which is the C++ one’s complement i.e. bit wise complement, and hence has destruction overtones! We declare it in the .h file and define it in the .cxx file. It does not do much except print out that it has been called (still a useful debug technique despite today’s powerful debuggers!).; Now run root, load the Quad class and create a heap object:; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; To delete the object:; root[] delete my_objptr;; root[] my_objptr = 0;; You should see the print out from its destructor. Setting the pointer to zero afterwards is not strictly necessary (and Cling does it automatically), but the object is no more accessible, and any attempt to use the pointer again will, as has already been stated, cause grief. So much for heap objects, but how are stack objects deleted? In C++, a stack object is deleted as soon as control leaves the innermost compound statement that encloses it. Therefore, it is singularly futile to do something like:; root[] { Quad my_object(1.,2.,-3.); }; Cling does not follow this rule; if you type in the above line, you will not see the destructor message. As explained in the Script lesson, you can load in compound statements, which would be a bit pointless if everything disappeared as soon as it was loaded! Instead, to reset the stack y",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:253708,load,load,253708,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['load']
Performance,"a stock; For 10 stocks we got the historical daily data for Sep-2000 to Jun-2004:. GE : General Electric Co; SUNW : Sun Microsystems Inc; QCOM : Qualcomm Inc; BRCM : Broadcom Corp; TYC : Tyco International Ltd; IBM : International Business Machines Corp; AMAT : Applied Materials Inc; C : Citigroup Inc; PFE : Pfizer Inc; HD : Home Depot Inc. We calculate the optimal portfolio for 2.0 and 10.0 .; Food for thought :; We assumed that the stock returns have a Normal distribution . Check this assumption by histogramming the stock returns !; We used for the expected return in the objective function, the flat average over a time period . Investment firms will put significant resources in improving the return prediction .; If you want to trade significant number of shares, several other considerations have to be taken into account :; If you are going to buy, you will drive the price up (so-called ""slippage"") . This can be taken into account by adding terms to the objective (Google for ""slippage optimization""); FTC regulations might have to be added to the inequality constraints. Investment firms do not want to be exposed to the ""market"" as defined by a broad index like the S&P and ""hedge"" this exposure away . A perfect hedge this can be added as an equality constrain, otherwise add an inequality constrain . ; stock daily daily w1 w2; symb return sdv ; GE : 1.001 0.022 0.000 0.134; SUNW : 1.004 0.047 0.676 0.145; QCOM : 1.001 0.039 0.000 0.000; BRCM : 1.003 0.056 0.179 0.035; TYC : 1.001 0.042 0.145 0.069; IBM : 1.001 0.023 0.000 0.096; AMAT : 1.001 0.040 0.000 0.000; C : 1.000 0.023 0.000 0.000; PFE : 1.000 0.019 0.000 0.424; HD : 1.001 0.029 0.000 0.098; ; #include ""Riostream.h""; #include ""TCanvas.h""; #include ""TFile.h""; #include ""TMath.h""; #include ""TTree.h""; #include ""TArrayF.h""; #include ""TH1.h""; #include ""TF1.h""; #include ""TLegend.h""; #include ""TSystem.h""; ; #include ""TMatrixD.h""; #include ""TMatrixDSym.h""; #include ""TVectorD.h""; #include ""TQpProbDens.h""; #include ""TGond",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:4913,optimiz,optimization,4913,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,1,['optimiz'],['optimization']
Performance,"a stored in the histogram, call TH1::ResetStats. See TH1::GetStats. ; Definition at line 7575 of file TH1.cxx. ◆ GetMinimum(). Double_t TH1::GetMinimum ; (; Double_t ; minval = -FLT_MAX); const. virtual . Return minimum value larger than minval of bins in the range, unless the value has been overridden by TH1::SetMinimum, in which case it returns that value. ; This happens, for example, when the histogram is drawn and the y or z axis limits are changed; To get the minimum value of bins in the histogram regardless of whether the value has been overridden (using TH1::SetMinimum), use; h->GetBinContent(h->GetMinimumBin()); TH1::GetMinimumBin can be used to get the location of the minimum value. ; Reimplemented in TH2Poly.; Definition at line 8635 of file TH1.cxx. ◆ GetMinimumAndMaximum(). void TH1::GetMinimumAndMaximum ; (; Double_t & ; min, . Double_t & ; max . ); const. virtual . Retrieve the minimum and maximum values in the histogram. ; This will not return a cached value and will always search the histogram for the min and max values. The user can condition whether or not to call this with the GetMinimumStored() and GetMaximumStored() methods. If the cache is empty, then the value will be -1111. Users can then use the SetMinimum() or SetMaximum() methods to cache the results. For example, the following recipe will make efficient use of this method and the cached minimum and maximum values. Double_t currentMin = pHist->GetMinimumStored();; Double_t currentMax = pHist->GetMaximumStored();; if ((currentMin == -1111) || (currentMax == -1111)) {; pHist->GetMinimumAndMaximum(currentMin, currentMax);; pHist->SetMinimum(currentMin);; pHist->SetMaximum(currentMax);; }; Parameters. minreference to variable that will hold found minimum value ; maxreference to variable that will hold found maximum value . Definition at line 8731 of file TH1.cxx. ◆ GetMinimumBin() [1/2]. Int_t TH1::GetMinimumBin ; (; ); const. virtual . Return location of bin with minimum value in the range. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:164349,cache,cached,164349,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['cache'],['cached']
Performance,"a to SQL statements or read data from SQL tables; TBufferXML a specialized TBuffer to read/write to XML files; TButton A user interface button.; TCL C++ replacement for CERNLIB matrix / triangle matrix packages: F110 and F112; TCONE CONE shape; TCONS CONS shape; TCTUB The Cut Tube shape; TCanvas Graphics canvas; TCanvasImp ABC describing main window protocol; TChain A chain of TTrees; TChainElement A chain element; TChainIndex A Tree Index with majorname and minorname.; TChainIndex::TChainIndexEntry ; TChair A base class to provide a user custom interface to TTable class objects; TCint Interface to CINT C/C++ interpreter; TCivetweb http server implementation, based on civetweb embedded server; TClass Dictionary containing class information; TClassDocInfo info cache for class documentation; TClassDocOutput generates documentation web pages for a class; TClassEdit ; TClassGenerator interface for TClass generators; TClassMenuItem One element of the class context menu; TClassRef ; TClassStreamer ; TClassTable Table of known classes; TClassTree Manager class to draw classes inheritance tree and relations; TClonesArray An array of clone objects; TCollection Collection abstract base class; TCollectionClassStreamer ; TCollectionMemberStreamer ; TCollectionMethodBrowsable Helper object to browse a collection's methods; TCollectionPropertyBrowsable Helper object to add browsable collection properties; TCollectionProxyFactory ; TCollectionStreamer ; TColor Color defined by RGB or HLS; TColorGradient Gradient fill.; TColorGradient::Point ; TColorWheel The ROOT Color Wheel; TColumnView Helper to represent one TTable column; TComplex Complex Class; TCondition Condition variable class; TConditionImp Condition variable implementation ABC; TCondor Interface to the Condor System; TCondorSlave Describes a claimed slave; TConfidenceLevel output for TLimit functions; TContextMenu Context sensitive popup menu; TContextMenuImp Context sensitive popup menu implementation; TControlBar Contro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:56758,cache,cache,56758,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,1,['cache'],['cache']
Performance,"a volume pointing to a cone shape with given medium.Definition TGeoManager.cxx:3257; TGeoManager::AnimateTracksvoid AnimateTracks(Double_t tmin=0, Double_t tmax=5E-8, Int_t nframes=200, Option_t *option=""/*"")Draw animation of tracks.Definition TGeoManager.cxx:1836; TGeoManager::AddSkinSurfacevoid AddSkinSurface(TGeoSkinSurface *surf)Add skin surface;.Definition TGeoManager.cxx:2048; TGeoManager::MakeXtruTGeoVolume * MakeXtru(const char *name, TGeoMedium *medium, Int_t nz)Make a TGeoXtru-shaped volume with nz planes.Definition TGeoManager.cxx:3332; TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; TGeoManager::MakePconTGeoVolume * MakePcon(const char *name, TGeoMedium *medium, Double_t phi, Double_t dphi, Int_t nz)Make in one step a volume pointing to a polycone shape with given medium.Definition TGeoManager.cxx:3275; TGeoManager::fRaytraceModeInt_t fRaytraceModeFlag for multi-threading.Definition TGeoManager.h:146; TGeoManager::fVisDensityDouble_t fVisDensityparticles to be drawnDefinition TGeoManager.h:69; TGeoManager::AddNavigatorTGeoNavigator * AddNavigator()Add a navigator in the list of navigators.Definition TGeoManager.cxx:789; TGeoManager::GetTrackOfIdTVirtualGeoTrack * GetTrackOfId(Int_t id) constGet track with a given ID.Definition TGeoManager.cxx:2200; TGeoManager::FindDuplicateMaterialTGeoMaterial * FindDuplicateMaterial(const TGeoMaterial *mat) constFind if a given material duplicates an existing one.Definition TGeoManager.cxx:2992; TGeoManager::DivisionTGeoVolume * Division(const char *name, const char *mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed=0, Option_t *option="""")Create a new volume by dividing an existing one (GEANT3 like)Definition TGeoManager.cxx:1258; TGeoManager::VolumeTGeoVolume * Volume(const char *name, const char *shape, Int_t nmed, Float_t *upar, Int_t npar=0)Create a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:177601,multi-thread,multi-threading,177601,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"a way to have your scripts compiled, linked and dynamically loaded using the C++ compiler and linker. The advantage of this is that your scripts will run with the speed of compiled C++ and that you can use language constructs that are not fully supported by Cling. On the other hand, you cannot use any Cling shortcuts (see “C++ Extensions To Ease Scripting” above) and for small scripts, the overhead of the compile/link cycle might be larger than just executing the script in the interpreter.; ACLiC will build a dictionary and a shared library from your C++ script, using the compiler and the compiler options that were used to compile the ROOT executable. You do not have to write a Makefile remembering the correct compiler options, and you do not have to exit ROOT.; 7.4.1 Usage; Before you can compile your interpreted script you need to add include statements for the classes used in the script. Once you did that, you can build and load a shared library containing your script. To load it use the command .L and append the file name with a +.; root[] .L MyScript.C+; The + option generates the shared library and names it by taking the name of the file “filename” but replacing the dot before the extension by an underscore and by adding the shared library extension for the current platform. For example on most platforms, hsimple.cxx will generate hsimple_cxx.so.; The + command rebuild the library only if the script or any of the files it includes are newer than the library. When checking the timestamp, ACLiC generates a dependency file which name is the same as the library name, just replacing the ‘so’ extension by the extension ‘d’. For example on most platforms, hsimple.cxx will generate hsimple_cxx.d.; To ensure that the shared library is rebuilt you can use the ++ syntax:; root[] .L MyScript.C++; To build, load, and execute the function with the same name as the file you can use the .x command. This is the same as executing a named script; you can also provide parameters. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:269028,load,load,269028,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['load']
Performance,"a& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual RooAbsGenContext*RooAbsPdf::autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const; const RooFormulaVar&basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&basisConvVar() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; virtual RooAbsGenContext*RooAbsPdf::binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual voidchangeBasis(RooFormulaVar* basis); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooResolutionModel.html:4194,cache,cacheUniqueSuffix,4194,root/html534/RooResolutionModel.html,https://root.cern,https://root.cern/root/html534/RooResolutionModel.html,1,['cache'],['cacheUniqueSuffix']
Performance,"a(Double_t& ratio); voidupdateThresholds(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Double_t*_coefThresh[_nComp] Array of coefficient thresholds ; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; TList_gcListList of component generator contexts; RooDataSet*RooAbsGenContext::_genData! Data being generated; Bool_t_isModelAre we generating from a RooAddPdf or a RooAddModel; Bool_tRooAbsGenContext::_isValidIs context in valid state?; Int_t_nCompNumber of PDF components; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; RooAbsPdf*_pdfPointer to cloned p.d.f; RooArgSet*_pdfSetSet owned all nodes of internal clone of p.d.f; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; const RooArgSet*_vars; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAddGenContext(const RooAddPdf &model, const RooArgSet &vars, 				 const RooDataSet *prototype, const RooArgSet* auxProto,				 Bool_t verbose); Constructor. RooAddGenContext(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddGenContext.html:8342,load,load,8342,root/html526/RooAddGenContext.html,https://root.cern,https://root.cern/root/html526/RooAddGenContext.html,1,['load'],['load']
Performance,"a* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction1Binding<double,int>&operator=(const RooCFunction1Binding<double,int>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction1Binding_double_int_.html:19820,optimiz,optimizeCacheMode,19820,root/html602/RooCFunction1Binding_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction1Binding_double_int_.html,2,['optimiz'],['optimizeCacheMode']
Performance,"a*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsData(); Destructor. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in datas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsData.html:13484,cache,cached,13484,root/html526/RooAbsData.html,https://root.cern,https://root.cern/root/html526/RooAbsData.html,4,['cache'],['cached']
Performance,"a++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case, a=b, the algorithm advances each array by one index in an; attempt to move through the equality. However, this is incorrect when one or; the other of a or b (or both) have a repeated value, call it x. For the KS; statistic to be computed properly, rdiff needs to be calculated after all of; the a and b at x have been tallied (this is due to the definition of the; empirical distribution function; another way to convince yourself that the; old CERNLIB method is wrong is that it implies that the function defined as the; difference between a and b is multi-valued at x -- besides being ugly, this; would invalidate Kolmogorov's theorem). The solution is to just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t R = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMath.html:20137,perform,perform,20137,root/html528/TMath.html,https://root.cern,https://root.cern/root/html528/TMath.html,2,['perform'],['perform']
Performance,"a++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case, a=b, the algorithm advances each array by one index in an; attempt to move through the equality. However, this is incorrect when one or; the other of a or b (or both) have a repeated value, call it x. For the KS; statistic to be computed properly, rdiff needs to be calculated after all of; the a and b at x have been tallied (this is due to the definition of the; empirical distribution function; another way to convince yourself that the; old CERNLIB method is wrong is that it implies that the function defined as the; difference between a and b is multi-valued at x -- besides being ugly, this; would invalidate Kolmogorov's theorem). The solution is to just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMath.html:20237,perform,perform,20237,root/html532/TMath.html,https://root.cern,https://root.cern/root/html532/TMath.html,4,['perform'],['perform']
Performance,"a, const RooArgList& dependents); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFormulaVar.html:24959,cache,cache,24959,root/html602/RooFormulaVar.html,https://root.cern,https://root.cern/root/html602/RooFormulaVar.html,2,['cache'],['cache']
Performance,"a0+a1*x+a2*x*x); fixA0 - logical value of a0 parameter, which allows to fix the parameter (not to fit); a1Init - initial value of a1 parameter; fixA1 - logical value of a1 parameter, which allows to fix the parameter (not to fit); a2Init - initial value of a2 parameter; fixA2 - logical value of a2 parameter, which allows to fix the parameter (not to fit) . Definition at line 2693 of file TSpectrumFit.cxx. ◆ SetFitParameters(). void TSpectrumFit::SetFitParameters ; (; Int_t ; xmin, . Int_t ; xmax, . Int_t ; numberIterations, . Double_t ; alpha, . Int_t ; statisticType, . Int_t ; alphaOptim, . Int_t ; power, . Int_t ; fitTaylor . ). This function sets the following fitting parameters: . xmin, xmax - fitting region; numberIterations - # of desired iterations in the fit; alpha - convergence coefficient, it should be positive number and <=1, for details see references; statisticType - type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood; alphaOptim - optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal; power - possible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. . Definition at line 2610 of file TSpectrumFit.cxx. ◆ SetPeakParameters(). void TSpectrumFit::SetPeakParameters ; (; Double_t ; sigma, . Bool_t ; fixSigma, . const Double_t * ; positionInit, . const Bool_t * ; fixPosition, . const Double_t * ; ampInit, . const Bool_t * ; fixAmp . ). This function sets the following fitting parameters of peaks: . sigma - initial value of sigma parameter; fixSigma - logical value of sigma parameter, which allows to fix the parameter (not to fit); positionInit - array o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumFit.html:45997,optimiz,optimization,45997,doc/master/classTSpectrumFit.html,https://root.cern,https://root.cern/doc/master/classTSpectrumFit.html,1,['optimiz'],['optimization']
Performance,"a::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static RooAbsData::StorageTypeRooAbsData::defaultStorageType. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; TDirectory*RooDirItem::_dir! Associated directory; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool ; RooArgSetRooAbsData::_varsDimensions of this data set; RooArgSet_varsNoWgtVars without weight variable ; RooRealVar*_wgtVarPointer to weight variable (if set) ; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooDataSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void operator delete(void* ptr); Memory is owned b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDataSet.html:16902,cache,cached,16902,root/html532/RooDataSet.html,https://root.cern,https://root.cern/root/html532/RooDataSet.html,2,['cache'],['cached']
Performance,"a::allClientsCached(RooAbsArg*, const RooArgSet&); voidRooDirItem::appendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); static voidcleanup(); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidinitialize(const char* wgtVarName); voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); voidRooDirItem::removeFromDir(TObject* obj); virtual voidRooAbsData::resetCache(); RooDataSet(const char* name, const char* title, RooDataSet* ntuple, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, int nStart, int nStop, Bool_t copyCache, const char* wgtVarName = 0); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataSet.html:15483,optimiz,optimizeReadingWithCaching,15483,root/html602/RooDataSet.html,https://root.cern,https://root.cern/root/html602/RooDataSet.html,4,"['cache', 'optimiz']","['cacheList', 'optimizeReadingWithCaching']"
Performance,"a; The class TGeoMedium describes tracking media properties. This has a pointer to a material and the additional data members representing the properties related to tracking.; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);. name: name assigned to the medium; mat: pointer to a material; params: array of additional parameters. Another constructor allows effectively defining tracking parameters in GEANT3 style:; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; This constructor is reserved for creating tracking media from the VMC interface […]:. numed: user-defined medium index; imat: unique ID of the material; others: see G3 documentation. Looking at our simple world example, one can see that for creating volumes one needs to create tracking media before. The way to proceed for those not interested in performing tracking with external MC’s is to define and use only one dummy tracking medium as in the example (or a NULL pointer).; 18.2.4 User Interface for Handling Materials and Media; The TGeoManager class contains the API for accessing and handling defined materials:; TGeoManager::GetMaterial(name);; 18.3 Shapes; Shapes are geometrical objects that provide the basic modeling functionality. They provide the definition of the local coordinate system of the volume. Any volume must have a shape. Any shape recognized by the modeller has to derive from the base TGeoShape class, providing methods for:. Finding out if a point defined in their local frame is contained or not by the shape;; Computing the distance to enter/exit the shape from a local point, given a known direction;; Computing the maximum distance in any direction from a local point that does NOT result in a boundary crossing of the shape (safe distance);; Computing the cosines of the normal vector to the crossed shape surface, given a starting local point and an ong",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:896205,perform,performing,896205,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performing']
Performance,"a=0.8, ; prevFCN = 9770.666818 alpha=0.8, ; prevFCN = 9770.66743 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.668617 alpha=0.8, ; prevFCN = 9770.667852 alpha=0.8, ; prevFCN = 9770.667479 alpha=0.8, ; prevFCN = 9770.667297 alpha=0.8, ; prevFCN = 9770.667208 alpha=0.8, ; prevFCN = 9770.667165 alpha=0.8, ; prevFCN = 9770.667144 alpha=0.8, ; prevFCN = 9770.667134 alpha=0.8, ; prevFCN = 9770.667129 alpha=0.8, ; prevFCN = 9770.667126 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.666827 alpha=0.8, ; prevFCN = 9770.667421 alpha=0.8, ; prevFCN = 9770.667064 alpha=0.8, ; prevFCN = 9770.667183 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.667064 alpha=0.8, ; prevFCN = 9770.667183 alpha=0.8, ; prevFCN = 9770.66653 alpha=0.8, ; prevFCN = 9770.667718 alpha=0.8, ; prevFCN = 9770.667005 alpha=0.8, ; prevFCN = 9770.667243 alpha=0.8, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71f2aa10 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71f2aa10 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71a5f5d0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf705_linearmorph.C. tutorialsroofitrf705_linearmorph.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf705__linearmorph_8C.html:10983,optimiz,optimization,10983,doc/master/rf705__linearmorph_8C.html,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html,4,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"aCacheInt_t ReadBufferViaCache(char *buf, Int_t len)Read buffer via cache.Definition TFile.cxx:1889; TFile::operator=void operator=(const TFile &)=delete; TFile::CreateKeyvirtual TKey * CreateKey(TDirectory *mother, const TObject *obj, const char *name, Int_t bufsize)Creates key for object and converts data to buffer.Definition TFile.cxx:1047; TFile::Mapvirtual void Map()Definition TFile.h:267; TFile::WriteFreevirtual void WriteFree()Write FREE linked list on the file.Definition TFile.cxx:2543; TFile::GetReadaheadSizestatic Int_t GetReadaheadSize()Static function returning the readahead buffer size.Definition TFile.cxx:4599; TFile::~TFile~TFile() overrideFile destructor.Definition TFile.cxx:563; TFile::ReadBuffersvirtual Bool_t ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf)Read the nbuf blocks described in arrays pos and len.Definition TFile.cxx:1821; TFile::GetFileCounterstatic Long64_t GetFileCounter()Definition TFile.cxx:4617; TFile::fCacheReadMapTMap * fCacheReadMap!Pointer to the read cache (if any)Definition TFile.h:99; TFile::fBEGINLong64_t fBEGINFirst used byte in file.Definition TFile.h:78; TFile::MakeProjectParProofInfInt_t MakeProjectParProofInf(const char *packname, const char *proofinfdir)Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.Definition TFile.cxx:3486; TFile::WriteProcessIDvirtual UShort_t WriteProcessID(TProcessID *pid)Check if the ProcessID pidd is already in the file, if not, add it and return the index number in the...Definition TFile.cxx:3763; TFile::MakeProjectvirtual void MakeProject(const char *dirname, const char *classes=""*"", Option_t *option=""new"")Generate source code necessary to access the objects stored in the file.Definition TFile.cxx:2726; TFile::fArchiveOffsetLong64_t fArchiveOffset!Offset at which file starts in archiveDefinition TFile.h:101; TFile::EOpenTimeOutEOpenTimeOutOpen timeout constants.Definition TFile.h:67; TFile::kInstantTimeout@ kInstantTimeoutDefinition TFile.h:67; TFile::kEter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:34583,cache,cache,34583,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['cache'],['cache']
Performance,"aFrame is built with a *modular* and *flexible* workflow in mind, summarised as follows:; 175 ; 1761. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, [CSV files](https://root.cern/doc/master/df014__CSVDataSource_8C.html), [SQLite files](https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C.html), [RNTuples](https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTuple.html), and it can be extended to custom data formats. From Python, [NumPy arrays can be imported into RDataFrame](https://root.cern/doc/master/df032__MakeNumpyDataFrame_8py.html) as well.; 177 ; 1782. Transform the dataframe by:; 179 ; 180 - [Applying filters](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). This selects only specific rows of the dataset.; 181 ; 182 - [Creating custom columns](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). Custom columns can, for example, contain the results of a computation that must be performed for every row of the dataset.; 183 ; 1843. [Produce results](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#actions). *Actions* are used to aggregate data into results. Most actions are *lazy*, i.e. they are not executed on the spot, but registered with RDataFrame and executed only when a result is accessed for the first time.; 185 ; 186Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate work and then produce all results at the same time, upon first access to any of them.; 187 ; 188The following table shows how analyses based on TTreeReader and TTree::Draw() translate to RDataFrame. Follow the; 189[crash course](#crash-course) to discover more idiomatic and flexible ways to express analyses with RDataFrame.; 190<table>; 191<tr>; 192 <td>; 193 <b>TTreeReader</b>; 194 </td>; 195 <td>; 196 <b>ROOT::RDataFrame</b>; 197 </td>; 198</tr>; 199<tr>; 200 <td>; 201~~~{.cp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:14182,perform,performed,14182,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['perform'],['performed']
Performance,"aFrame is built with a *modular* and *flexible* workflow in mind, summarised as follows:; 179 ; 1801. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, [CSV files](https://root.cern/doc/master/df014__CSVDataSource_8C.html), [SQLite files](https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C.html), [RNTuples](https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTuple.html), and it can be extended to custom data formats. From Python, [NumPy arrays can be imported into RDataFrame](https://root.cern/doc/master/df032__MakeNumpyDataFrame_8py.html) as well.; 181 ; 1822. Transform the dataframe by:; 183 ; 184 - [Applying filters](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). This selects only specific rows of the dataset.; 185 ; 186 - [Creating custom columns](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). Custom columns can, for example, contain the results of a computation that must be performed for every row of the dataset.; 187 ; 1883. [Produce results](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#actions). *Actions* are used to aggregate data into results. Most actions are *lazy*, i.e. they are not executed on the spot, but registered with RDataFrame and executed only when a result is accessed for the first time.; 189 ; 190Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate work and then produce all results at the same time, upon first access to any of them.; 191 ; 192The following table shows how analyses based on TTreeReader and TTree::Draw() translate to RDataFrame. Follow the; 193[crash course](#crash-course) to discover more idiomatic and flexible ways to express analyses with RDataFrame.; 194<table>; 195<tr>; 196 <td>; 197 <b>TTreeReader</b>; 198 </td>; 199 <td>; 200 <b>ROOT::RDataFrame</b>; 201 </td>; 202</tr>; 203<tr>; 204 <td>; 205~~~{.cp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:14624,perform,performed,14624,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['perform'],['performed']
Performance,"aHandling -- RooTreeDataStore::loadValues(ds) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 35 out-of-range events; RooDataSet::ds[x,y] = 65 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds2) Ignored 36 out-of-range events; RooDataSet::ds2[x,y,z] = 26 entries; [#1] INFO:DataHandling -- RooAbsReal::attachToTree(i) TTree Int_t branch i will be converted to double precision.; RooDataSet::ds3[i,x] = 100 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #2 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #5 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #8 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #11 because",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8C.html:7950,load,loadValues,7950,doc/master/rf401__importttreethx_8C.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8C.html,1,['load'],['loadValues']
Performance,"aQ); static Bool_tIsU1IntervalOverlappingByMinMax(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); static voidLoadMacro(const char* mac); static voidMacro(const char* mac); TEveUtil&operator=(const TEveUtil&); static voidSetColorBrightness(Float_t value, Bool_t full_redraw = kFALSE); static voidSetupEnvironment(); static voidSetupGUI(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. static TObjArray*fgDefaultColors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupEnvironment(); Setup Include and Macro paths.; Since inclusion into ROOT this does nothing but could; potentially be reactivated if some common macros are established; and shipped with binary ROOT (in macros/eve). For example, these; might be used to spawn specific GUI / GL configurations. void SetupGUI(); Setup icon pictures and mime-types. Bool_t CheckMacro(const char* mac); Checks if macro 'mac' is loaded. void AssertMacro(const char* mac); Load and execute macro 'mac' if it has not been loaded yet. void Macro(const char* mac); Execute macro 'mac'. Do not reload the macro. void LoadMacro(const char* mac); Makes sure that macro 'mac' is loaded, but do not reload it. void ColorFromIdx(Color_t ci, UChar_t* col, Bool_t alpha = kTRUE); Fill col with RGBA values corresponding to index ci. If alpha; is true, set alpha component of col to 255.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Color_t ci, UChar_t* col, Char_t transparency); Fill col with RGBA values corresponding to index ci and transparency.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2, UChar_t* col, Bool_t alpha = kTRUE); Fill col with weighted RGBA values corresponding to; color-indices c1 and c2. If alpha is true, set alpha component; of col to 255. Color_t* FindColorVar(TObject* obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveUtil.html:2280,load,loaded,2280,root/html528/TEveUtil.html,https://root.cern,https://root.cern/root/html528/TEveUtil.html,3,['load'],['loaded']
Performance,"aSet* ntuple, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, int nStart, int nStop, Bool_t copyCache, const char* wgtVarName = 0); RooArgSetaddWgtVar(const RooArgSet& origVars, const RooAbsArg* wgtVar); Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); voidRooDirItem::appendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); static voidcleanup(); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidinitialize(const char* wgtVarName); voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); voidRooDirItem::removeFromDir(TObject* obj); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDataSet.html:15243,optimiz,optimizeReadingWithCaching,15243,root/html530/RooDataSet.html,https://root.cern,https://root.cern/root/html530/RooDataSet.html,4,"['cache', 'optimiz']","['cacheList', 'optimizeReadingWithCaching']"
Performance,"aSliceColor(Int_t slice, Color_t col); Set slice color in data. void SetEta(Float_t l, Float_t u); Set eta range. void SetPlotEt(Bool_t x); Set E/Et plot. Float_t GetMaxVal() const. void SetPhiWithRng(Float_t x, Float_t r); Set phi range. Float_t GetTransitionTheta() const; Get transition angle between barrel and end-cap cells, assuming fEndCapPosF = -fEndCapPosB. Float_t GetTransitionEta() const; Get transition eta between barrel and end-cap cells, assuming fEndCapPosF = -fEndCapPosB. Float_t GetTransitionThetaForward() const; Get transition angle between barrel and forward end-cap cells. Float_t GetTransitionEtaForward() const; Get transition eta between barrel and forward end-cap cells. Float_t GetTransitionThetaBackward() const; Get transition angle between barrel and backward end-cap cells. Float_t GetTransitionEtaBackward() const; Get transition eta between barrel and backward end-cap cells. void SetData(TEveCaloData* d); Set calorimeter event data. void DataChanged(); Update setting and cache on data changed.; Called from TEvecaloData::BroadcastDataChange(). Bool_t AssertCellIdCache() const; Assert cell id cache is ok.; Returns true if the cache has been updated. Bool_t CellInEtaPhiRng(TEveCaloData::CellData_t& ) const; Returns true if given cell is in the ceta phi range. void AssignCaloVizParameters(TEveCaloViz* cv); Assign paramteres from given model. void SetPalette(TEveRGBAPalette* p); Set TEveRGBAPalette object pointer. Float_t GetValToHeight() const; Get transformation factor from E/Et to height. TEveRGBAPalette* AssertPalette(); Make sure the TEveRGBAPalette pointer is not null.; If it is not set, a new one is instantiated and the range is set; to current min/max signal values. void Paint(Option_t* option = """"); Paint this object. Only direct rendering is supported. TClass* ProjectedClass(const TEveProjection* p) const; Virtual from TEveProjectable, returns TEveCalo2D class. void SetupColorHeight(Float_t value, Int_t slice, Float_t& height) const; Set ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveCaloViz.html:24234,cache,cache,24234,root/html534/TEveCaloViz.html,https://root.cern,https://root.cern/root/html534/TEveCaloViz.html,3,['cache'],['cache']
Performance,"aStore.h. Member Function Documentation. ◆ addColumn(). virtual RooAbsArg * RooAbsDataStore::addColumn ; (; RooAbsArg & ; var, . bool ; adjustRange = true . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ addColumns(). RooArgSet * RooAbsDataStore::addColumns ; (; const RooArgList & ; varList). Definition at line 60 of file RooAbsDataStore.cxx. ◆ append(). virtual void RooAbsDataStore::append ; (; RooAbsDataStore & ; other). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ attachBuffers(). virtual void RooAbsDataStore::attachBuffers ; (; const RooArgSet & ; extObs). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ attachCache(). virtual void RooAbsDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ cacheArgs(). virtual void RooAbsDataStore::cacheArgs ; (; const RooAbsArg * ; cacheOwner, . RooArgSet & ; varSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = false . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ cachedVars(). const RooArgSet & RooAbsDataStore::cachedVars ; (; ); const. inline . Definition at line 130 of file RooAbsDataStore.h. ◆ cacheOwner(). virtual const RooAbsArg * RooAbsDataStore::cacheOwner ; (; ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ changeObservableName(). virtual bool RooAbsDataStore::changeObservableName ; (; const char * ; from, . const char * ; to . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ checkInit(). virtual void RooAbsDataStore::checkInit ; (; ); const. inlinevirtual . Reimplemented in RooTreeDataStore.; Definition at line 137 of file RooAbsDataStore.h. ◆ Class(). stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsDataStore.html:18930,cache,cacheArgs,18930,doc/master/classRooAbsDataStore.html,https://root.cern,https://root.cern/doc/master/classRooAbsDataStore.html,1,['cache'],['cacheArgs']
Performance,"aStore::addReal ; (; RooAbsReal * ; real). protected . Definition at line 1244 of file RooVectorDataStore.cxx. ◆ addRealFull(). RooVectorDataStore::RealFullVector * RooVectorDataStore::addRealFull ; (; RooAbsReal * ; real). protected . Definition at line 1304 of file RooVectorDataStore.cxx. ◆ append(). void RooVectorDataStore::append ; (; RooAbsDataStore & ; other). overridevirtual . Implements RooAbsDataStore.; Definition at line 720 of file RooVectorDataStore.cxx. ◆ attachBuffers(). void RooVectorDataStore::attachBuffers ; (; const RooArgSet & ; extObs). overridevirtual . Implements RooAbsDataStore.; Definition at line 1041 of file RooVectorDataStore.cxx. ◆ attachCache(). void RooVectorDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). overridevirtual . Initialize cache of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ; Implements RooAbsDataStore.; Definition at line 982 of file RooVectorDataStore.cxx. ◆ cache(). const RooVectorDataStore * RooVectorDataStore::cache ; (; ); const. inline . Definition at line 171 of file RooVectorDataStore.h. ◆ cacheArgs(). void RooVectorDataStore::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; newVarSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = true . ). overridevirtual . Cache given RooAbsArgs: The tree is given direct write access of the args internal cache the args values is pre-calculated for all data points in this data collection. ; Upon a get() call, the internal cache of 'newVar' will be loaded with the precalculated value and it's dirty flag will be cleared. ; Implements RooAbsDataStore.; Definition at line 764 of file RooVectorDataStore.cxx. ◆ cacheOwner(). const RooAbsArg * RooVectorDataStore::cacheOwner ; (; ). inlineoverridevirtual . Implements RooAbsDataStore.; Definition at line 163 of file RooVectorDataStore.h. ◆ catStoreList(). std::vector< CatVector * > & RooVectorDataStore::catStoreList ; (; ). inline .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:26919,cache,cache,26919,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,1,['cache'],['cache']
Performance,"aStore::~RooCompositeDataStore ; (; ). override . Destructor. ; Definition at line 111 of file RooCompositeDataStore.cxx. Member Function Documentation. ◆ addColumn(). RooAbsArg * RooCompositeDataStore::addColumn ; (; RooAbsArg & ; var, . bool ; adjustRange = true . ). overridevirtual . WVE ownership issue here!! Caller (a RooAbsData) should take ownership of all arguments, but only does for the first one here... ; Implements RooAbsDataStore.; Definition at line 320 of file RooCompositeDataStore.cxx. ◆ append(). void RooCompositeDataStore::append ; (; RooAbsDataStore & ; other). overridevirtual . Implements RooAbsDataStore.; Definition at line 346 of file RooCompositeDataStore.cxx. ◆ attachBuffers(). void RooCompositeDataStore::attachBuffers ; (; const RooArgSet & ; extObs). overridevirtual . Implements RooAbsDataStore.; Definition at line 435 of file RooCompositeDataStore.cxx. ◆ attachCache(). void RooCompositeDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). overrideprotectedvirtual . Initialize cache of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ; Implements RooAbsDataStore.; Definition at line 411 of file RooCompositeDataStore.cxx. ◆ cacheArgs(). void RooCompositeDataStore::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; varSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = false . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 384 of file RooCompositeDataStore.cxx. ◆ cacheOwner(). const RooAbsArg * RooCompositeDataStore::cacheOwner ; (; ). inlineoverridevirtual . Implements RooAbsDataStore.; Definition at line 94 of file RooCompositeDataStore.h. ◆ changeObservableName(). bool RooCompositeDataStore::changeObservableName ; (; const char * ; from, . const char * ; to . ). overridevirtual . Change name of internal observable named 'from' into 'to'. ; Implements RooAbsDataStore.; Definition at line 290 of file RooCompositeDataStore.cxx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCompositeDataStore.html:22163,cache,cachedVars,22163,doc/master/classRooCompositeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooCompositeDataStore.html,1,['cache'],['cachedVars']
Performance,"abel for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meas; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; RooRealProxy_true; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooPullVar(); Default constructor. RooPullVar(const char* name, const char* title, RooRealVar& measurement, RooAbsReal& truth); Construct RooAbsReal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPullVar.html:36247,cache,cache,36247,root/html602/RooPullVar.html,https://root.cern,https://root.cern/root/html602/RooPullVar.html,4,['cache'],['cache']
Performance,"abelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooSetProxy_varSetNot used anymore?; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooConvCoefVar(const char* name, const char* title, const RooAbsAnaConvPdf& input, Int_t coefIdx, const RooArgSet* varList = 0); Constuctor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConvCoefVar.html:36290,cache,cache,36290,root/html602/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html602/RooConvCoefVar.html,4,['cache'],['cache']
Performance,"abilities of p.d.f.; RooDataSet*RooAbsGenContext::_genData! Data being generated; Bool_tRooAbsGenContext::_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooArgSet*_cloneSetInternal clone of p.d.f.; RooAbsReal*_effPointer to efficiency function; RooAbsGenContext*_generatorGenerator context for p.d.f. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooEffGenContext(const RooAbsPdf& model, const RooAbsPdf& pdf, const RooAbsReal& eff, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Constructor of generator context for RooEffProd products. ~RooEffGenContext(); Destructor. void initGenerator(const RooArgSet& theEvent); One-time initialization of generator. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. Generate an event from the p.d.f and; then perform an accept/reject sampling based on the efficiency; function. RooEffGenContext(const RooAbsPdf& model, const RooAbsPdf& pdf, const RooAbsReal& eff, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Mon Dec 7 13:47:27 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooEffGenContext.html:9301,perform,perform,9301,root/html526/RooEffGenContext.html,https://root.cern,https://root.cern/root/html526/RooEffGenContext.html,1,['perform'],['perform']
Performance,"able is a base class (not really abstract, but useless by itself) for helper objects that extend TBranch's browsing support. ; Each registered derived class's generator method is called, which fills all created helper objects into a list which can then be browsed. For details of what these browser helper objects can do, see e.g. TMethodBrowsable, which allows methods to show up in the TBrowser.; Only registered helper objects are created. By default, only TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable are registered (see RegisterDefaultGenerators). You can prevent any of their objects to show up in the browser by unregistering the generator: TMethodBrowsable::Unregister(); TMethodBrowsable::Unregisterstatic void Unregister()Wrapper for the registration method.Definition TBranchBrowsable.cxx:595; will stop creating browsable method helper objects from that call on. Note that these helper objects are cached (in TBranch::fBrowsables); already created (and thus cached) browsables will still appear in the browser even after unregistering the corresponding generator.; You can implement your own browsable objects and their generator; see e.g. the simple TCollectionPropertyBrowsable. Note that you will have to register your generator just like any other, and that you should implement the following methods for your own class, mainly for consistency reasons: static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; TVirtualBranchBrowsable::RegisterGeneratorstatic void RegisterGenerator(MethodCreateListOfBrowsables_t generator)Adds a generator to be called when browsing branches.Definition TBranchBrowsable.cxx:356; TVirtualBranchBrowsable::UnregisterGeneratorstatic void UnregisterGenerator(MethodCreateListOfBrowsables_t generator)Removes a generator from the list of generators to be called when browsing branches.Definition TBranchBrow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualBranchBrowsable.html:1415,cache,cached,1415,doc/master/classTVirtualBranchBrowsable.html,https://root.cern,https://root.cern/doc/master/classTVirtualBranchBrowsable.html,2,['cache'],['cached']
Performance,able of first entry in each basket ; Definition at line 142 of file TBranch.h. ◆ fBaskets. TObjArray TBranch::fBaskets. protected . -> List of baskets of this branch ; Definition at line 140 of file TBranch.h. ◆ fBasketSeek. Long64_t* TBranch::fBasketSeek. protected . [fMaxBaskets] Addresses of baskets on file ; Definition at line 143 of file TBranch.h. ◆ fBasketSize. Int_t TBranch::fBasketSize. protected . Initial Size of Basket Buffer. ; Definition at line 118 of file TBranch.h. ◆ fBranches. TObjArray TBranch::fBranches. protected . -> List of Branches of this branch ; Definition at line 138 of file TBranch.h. ◆ fBrowsables. TList* TBranch::fBrowsables. protected . ! List of TVirtualBranchBrowsables used for Browse() ; Definition at line 152 of file TBranch.h. ◆ fBulk. BulkObj TBranch::fBulk. protected . ! Helper for performing bulk IO ; Definition at line 153 of file TBranch.h. ◆ fCacheInfo. CacheInfo_t TBranch::fCacheInfo. protected . ! Hold info about which basket are in the cache and if they have been retrieved from the cache. ; Definition at line 158 of file TBranch.h. ◆ fCompress. Int_t TBranch::fCompress. protected . Compression level and algorithm. ; Definition at line 117 of file TBranch.h. ◆ fCurrentBasket. TBasket* TBranch::fCurrentBasket. protected . ! Pointer to the current basket. ; Definition at line 133 of file TBranch.h. ◆ fDirectory. TDirectory* TBranch::fDirectory. protected . ! Pointer to directory where this branch buffers are stored ; Definition at line 148 of file TBranch.h. ◆ fEntries. Long64_t TBranch::fEntries. protected . Number of entries. ; Definition at line 134 of file TBranch.h. ◆ fEntryBuffer. TBuffer* TBranch::fEntryBuffer. protected . ! Buffer used to directly pass the content without streaming ; Definition at line 150 of file TBranch.h. ◆ fEntryNumber. Long64_t TBranch::fEntryNumber. protected . Current entry number (last one filled in this branch) ; Definition at line 121 of file TBranch.h. ◆ fEntryOffsetLen. Int_t TBranch::fEn,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:71149,cache,cache,71149,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,2,['cache'],['cache']
Performance,able::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TString_bnameName of the binning specification to be used to perform the mapping; set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooRealProxy_inputVarInput variable that is mapped; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArray,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBinningCategory.html:21752,perform,perform,21752,root/html602/RooBinningCategory.html,https://root.cern,https://root.cern/root/html602/RooBinningCategory.html,8,"['cache', 'perform']","['cache', 'caches', 'perform']"
Performance,"ableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction4Binding<double,double,double,double,bool>&operator=(const RooCFunction4Binding<double,double,double,double,bool>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_bool_.html:19880,optimiz,optimizeCacheMode,19880,root/html602/RooCFunction4Binding_double_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_bool_.html,2,['optimiz'],['optimizeCacheMode']
Performance,"ableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooExtendedBinding&operator=(const RooExtendedBinding&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExtendedBinding.html:19224,optimiz,optimizeCacheMode,19224,root/html602/RooExtendedBinding.html,https://root.cern,https://root.cern/root/html602/RooExtendedBinding.html,2,['optimiz'],['optimizeCacheMode']
Performance,"able_t img, Int_t dx, Int_t dy, Int_t x, Int_t y, UInt_t w, UInt_t h);  Combines an image with a rectangle of the specified drawable. ;  ; virtual void PutPixel (Drawable_t id, Int_t x, Int_t y, ULong_t pixel);  Overwrites the pixel in the image with the specified pixel value. ;  ; virtual void QueryColor (Colormap_t cmap, ColorStruct_t &color);  Returns the current RGB value for the pixel in the ""color"" structure. ;  ; virtual void QueryPointer (Int_t &ix, Int_t &iy);  Returns the pointer position. ;  ; virtual void QueryPointer (Window_t id, Window_t &rootw, Window_t &childw, Int_t &root_x, Int_t &root_y, Int_t &win_x, Int_t &win_y, UInt_t &mask);  Returns the root window the pointer is logically on and the pointer coordinates relative to the root window's origin. ;  ; virtual void RaiseWindow (Window_t id);  Raises the specified window to the top of the stack so that no sibling window obscures it. ;  ; virtual Pixmap_t ReadGIF (Int_t x0, Int_t y0, const char *file, Window_t id=0);  If id is NULL - loads the specified gif file at position [x0,y0] in the current window. ;  ; virtual Bool_t ReadPictureDataFromFile (const char *filename, char ***ret_data);  Reads picture data from file ""filename"" and store it in ""ret_data"". ;  ; virtual void RemoveWindow (ULongptr_t qwid);  Removes the created by Qt window ""qwid"". ;  ; virtual void ReparentWindow (Window_t id, Window_t pid, Int_t x, Int_t y);  If the specified window is mapped, ReparentWindow automatically performs an UnmapWindow request on it, removes it from its current position in the hierarchy, and inserts it as the child of the specified parent. ;  ; virtual Int_t RequestLocator (Int_t mode, Int_t ctyp, Int_t &x, Int_t &y);  Requests Locator position. ;  ; virtual Int_t RequestString (Int_t x, Int_t y, char *text);  Requests string: text is displayed and can be edited with Emacs-like keybinding. ;  ; virtual void RescaleWindow (Int_t wid, UInt_t w, UInt_t h);  Rescales the window ""wid"". ;  ; virtual Int_t Resize",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:22101,load,loads,22101,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['load'],['loads']
Performance,"ablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooListProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooUniform.html:38500,cache,cache,38500,root/html526/RooUniform.html,https://root.cern,https://root.cern/root/html526/RooUniform.html,2,['cache'],['cache']
Performance,"about the on-disk metadata of an RNTuple.; A new RNTupleParallelWriter class has been added, providing (initial) support for parallel writing of RNTuples.; A new static method RFieldBase::Check() has been added, which produces a support status report of a type with regards to RNTuple I/O.; A new internal RNTupleMerger class has been added, enabling the merging of different page sources into one page sink. This also means that RNTuples can be merged through hadd.; Zero-copy bulk reading has been added, with extra optimizations for ROOT::RVec fields.; It is now possible to use the RNTupleView with an external address with type erasure, e.g.:; std::shared_ptr<void> data{new float()};; auto view = reader->GetView(""pt"", data);; This enables use cases such as reading one specific entry of one specific field into a previously allocated memory location.; Further integration with RDataFrame: it is now possible to create RDataFrame for chains of RNTuples. This addition also comes with improvements to the multi-threaded work scheduling.; Many additional bug fixes and improvements. Please, report any issues regarding the above mentioned features should you encounter them. RNTuple is still in pre-production. The on-disk format is scheduled to be finalized by the end of 2024. Thus, we appreciate feedback and suggestions for improvement.; Histogram Libraries. Implement the FLT_MAX mechanism for THStack::GetMaximum() and THStack::GetMiniumum().; Print a warning when the range given to TAxis::SetRange is invalid.; Fix projection name in TH3 as requested here. Parallelism. The ROOT::Experimental::TFuture template has been removed. RooFit Libraries; New CPU likelihood evaluation backend by default; The new vectorizing CPU evaluation backend is not the default for RooFit likelihoods. Likelihood minimization is now up to 10x faster on a single CPU core.; If you experience unexpected problems related to the likelihood evaluation, you can revert back to the old backend by passing RooFit::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:7358,multi-thread,multi-threaded,7358,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['multi-thread'],['multi-threaded']
Performance,"about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:18875,cache,cache,18875,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,1,['cache'],['cache']
Performance,"about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCache.html:20741,cache,cache,20741,root/html530/TTreeCache.html,https://root.cern,https://root.cern/root/html530/TTreeCache.html,1,['cache'],['cache']
Performance,"about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the lis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:21583,cache,cache,21583,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['cache'],['cache']
Performance,"above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction2PdfBinding_double_double_double_.html:40352,cache,cache,40352,root/html532/RooCFunction2PdfBinding_double_double_double_.html,https://root.cern,https://root.cern/root/html532/RooCFunction2PdfBinding_double_double_double_.html,2,['cache'],['cache']
Performance,"above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumConvPdf.html:42594,cache,cache,42594,root/html530/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html530/RooNumConvPdf.html,2,['cache'],['cache']
Performance,"access the objects stored in the file. ;  ; virtual void Map ();  ; virtual void Map (Option_t *opt);  List the contents of a file sequentially. ;  ; virtual Bool_t Matches (const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; void Print (Option_t *option="""") const override;  Print all objects in the file. ;  ; virtual Bool_t ReadBufferAsync (Long64_t offs, Int_t len);  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from this file. ;  ; virtual void ReadStreamerInfo ();  Read the list of StreamerInfo from this file. ;  ; virtual Int_t Recover ();  Attempt to recover file if not correctly closed. ;  ; virtual void ResetErrno () const;  Method resetting the errno. ;  ; virtual void SetCacheRead (TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect);  Set a pointer to the read cache. ;  ; virtual void SetCacheWrite (TFileCacheWrite *cache);  Set a pointer to the write cache. ;  ; virtual void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Used to specify the compression level and algorithm. ;  ; virtual void SetEND (Long64_t last);  ; virtual void SetOffset (Long64_t offset, ERelativeTo pos=kBeg);  Set position from where to start reading. ;  ; virtual void SetOption (Option_t *option="">"");  ; virtual void SetReadCalls (Int_t readcalls=0);  ; virtual void ShowStreamerInfo ();  Show the StreamerInfo of all classes written to this file. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetXNGFile.html:6667,cache,cache,6667,doc/master/classTNetXNGFile.html,https://root.cern,https://root.cern/doc/master/classTNetXNGFile.html,6,['cache'],['cache']
Performance,"access to the underlying stl container. ; Definition at line 116 of file RooAbsCollection.h. ◆ getCatIndex(). Int_t RooAbsCollection::getCatIndex ; (; const char * ; name, . Int_t ; defVal = 0, . bool ; verbose = false . ); const. Get index value of a RooAbsCategory stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1054 of file RooAbsCollection.cxx. ◆ getCatLabel(). const char * RooAbsCollection::getCatLabel ; (; const char * ; name, . const char * ; defVal = """", . bool ; verbose = false . ); const. Get state name of a RooAbsCategory stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1011 of file RooAbsCollection.cxx. ◆ getHashTableSize(). Int_t RooAbsCollection::getHashTableSize ; (; ); const. inline . Query the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ; Definition at line 111 of file RooAbsCollection.h. ◆ GetName(). const char * RooAbsCollection::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 365 of file RooAbsCollection.h. ◆ getRealValue(). double RooAbsCollection::getRealValue ; (; const char * ; name, . double ; defVal = 0.0, . bool ; verbose = false . ); const. Get value of a RooAbsReal stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 968 of file RooAbsCollection.cxx. ◆ getSize(). Int_t RooAbsCollection::getSize ; (; ); const. inline . Return the number of elements in the collection. ; Definition at line 310 of file RooAbsCollection.h. ◆ getStringValue(). const char * RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsCollection.html:43318,perform,performing,43318,doc/v632/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html,1,['perform'],['performing']
Performance,"access to the underlying stl container. ; Definition at line 116 of file RooAbsCollection.h. ◆ getCatIndex(). Int_t RooAbsCollection::getCatIndex ; (; const char * ; name, . Int_t ; defVal = 0, . bool ; verbose = false . ); const. Get index value of a RooAbsCategory stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1064 of file RooAbsCollection.cxx. ◆ getCatLabel(). const char * RooAbsCollection::getCatLabel ; (; const char * ; name, . const char * ; defVal = """", . bool ; verbose = false . ); const. Get state name of a RooAbsCategory stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1021 of file RooAbsCollection.cxx. ◆ getHashTableSize(). Int_t RooAbsCollection::getHashTableSize ; (; ); const. inline . Query the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ; Definition at line 111 of file RooAbsCollection.h. ◆ GetName(). const char * RooAbsCollection::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 342 of file RooAbsCollection.h. ◆ getRealValue(). double RooAbsCollection::getRealValue ; (; const char * ; name, . double ; defVal = 0.0, . bool ; verbose = false . ); const. Get value of a RooAbsReal stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 978 of file RooAbsCollection.cxx. ◆ getSize(). Int_t RooAbsCollection::getSize ; (; ); const. inline . Return the number of elements in the collection. ; Definition at line 287 of file RooAbsCollection.h. ◆ getStringValue(). const char * RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCollection.html:41771,perform,performing,41771,doc/master/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/master/classRooAbsCollection.html,1,['perform'],['performing']
Performance,"ace TMVA;; ; void TMVARegression( TString myMethodList = """" ); {; // The explicit loading of the shared libTMVA is done in TMVAlogon.C, defined in .rootrc; // if you use your private .rootrc, or run from a different directory, please copy the; // corresponding lines from .rootrc; ; // methods to be processed can be given as an argument; use format:; //; // mylinux~> root -l TMVARegression.C\‍(\""myMethod1,myMethod2,myMethod3\""\‍); //; ; //---------------------------------------------------------------; // This loads the library; TMVA::Tools::Instance();; ; ; ; // Default MVA methods to be trained + tested; std::map<std::string,int> Use;; ; // Mutidimensional likelihood and Nearest-Neighbour methods; Use[""PDERS""] = 0;; Use[""PDEFoam""] = 1;; Use[""KNN""] = 1;; //; // Linear Discriminant Analysis; Use[""LD""] = 1;; //; // Function Discriminant analysis; Use[""FDA_GA""] = 0;; Use[""FDA_MC""] = 0;; Use[""FDA_MT""] = 0;; Use[""FDA_GAMT""] = 0;; //; // Neural Network; Use[""MLP""] = 0;; // Deep neural network (with CPU or GPU); #ifdef R__HAS_TMVAGPU; Use[""DNN_GPU""] = 1;; Use[""DNN_CPU""] = 0;; #else; Use[""DNN_GPU""] = 0;; #ifdef R__HAS_TMVACPU; Use[""DNN_CPU""] = 1;; #else; Use[""DNN_CPU""] = 0;; #endif; #endif; //; // Support Vector Machine; Use[""SVM""] = 0;; //; // Boosted Decision Trees; Use[""BDT""] = 0;; Use[""BDTG""] = 1;; // ---------------------------------------------------------------; ; std::cout << std::endl;; std::cout << ""==> Start TMVARegression"" << std::endl;; ; // Select methods (don't look at this code - not of interest); if (myMethodList != """") {; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) it->second = 0;; ; std::vector<TString> mlist = gTools().SplitString( myMethodList, ',' );; for (UInt_t i=0; i<mlist.size(); i++) {; std::string regMethod(mlist[i].Data());; ; if (Use.find(regMethod) == Use.end()) {; std::cout << ""Method \"""" << regMethod << ""\"" not known in TMVA under this name. Choose among the following:"" << std::endl;; for (std::map<std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:135308,load,loads,135308,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['load'],['loads']
Performance,"ace typically used to manipulate RVecs is RDataFrame, and RDataFrame performs an on-the-fly RVec <-> std::vector conversion rather than writing RVecs to disk. Note that, currently, RVecs written e.g. in a TTree cannot be read back using certain ROOT interfaces (e.g. TTreeReaderArray, RDataFrame and the experimental RNTuple). All these limitations will be lifted in v6.26.; Portable implementation of the RANLUX++ generator, see RanluxppEngine and our blog post.; Change TRandom3::GetSeed to return the current state element in the contained seed vector of TRandom3. The return value will now change after every call of TRandom3::Rndm (when generating a random number). Before the function was returning the first element of the state, which was changing only after 624 calls to Rndm().; Fix a bug in ROOT::Fit::BinData copy constructor; Fix a bug in applying a correction factor used for the computation of the fit confidence level in ROOT::Fit::FitResult.; TMatrix: optimize implementation of TPrincipal::AddRow that is heavily used by CMS. Minuit2. Add a new improved message logging system. Debug message now can be enabled in Minuit2 when using maximum print level.; When using external provided gradient, compute in MnSeed still numerical gradients to obtain correct step sizes and initial estimate of covariance matrix. This allows to start with a good first state estimation, reducing significantly the number of subsequent iterations. TMVA. Introducing TMVA PyTorch Interface, a method to use PyTorch internally with TMVA for deep learning. This can be used as an alternative to PyKeras Interface for complex models providing more flexibility and power.; Add support in the TMVA Keras interface for Tensorflow.Keras (the version embedded in Tensorflow) and for standalone Keras versions up to it latest 2.3. For using Tensorflow.Keras one needs to use the booking option tf.keras=True.; Update the TMVA Keras tutorials to use now tensorflow.keras.; Deprecate the MethodDNN in favour of Metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:14832,optimiz,optimize,14832,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['optimiz'],['optimize']
Performance,"ace; One can now register an arbitrary command to the server, which become visible in the web browser. Then, when the item is clicked by the user, the command ends-up in a gROOT->ProcessLineSync() call.; Custom Properties; Custom properties can be configured for any item in the server. For example, one could configure an icon for each item visible in the browser. Or one could ‘hide’ any item from the user (but keep access with normal http requests). With such properties one could specify which item is drawn when web page is loaded, or configure monitoring. See tutorials/http/httpcontrol.C macro for more details.; Method Calls; Implement exe.json requests to be able to execute any method of registered objects. This request is used to provide remote TTree::Draw() functionality.; Misc; Correctly set ‘Cache-Control’ headers when replying to http requests. Better support of STL containers when converting objects into json with TBufferJSON class.; JavaScript ROOT. Several files can now be loaded simultaneously; Use d3.time.scale to display time scales; Implemented drag and drop to superimpose histograms or graphs; Allow selection of drawing option via context menu; Better support of touch devices; Provide simple layout, making it default; Allow to open ROOT files in online session (via url parameter); One could monitor simultaneously objects from server and root files; Implement ‘autocol’ draw option - when superimposing histograms, their line colors will be automatically assigned; Implement ‘nostat’ draw option - disabled stat drawing; Using ‘same’ identifier in item name, one can easily draw or superimpose similar items from different files. Could be used in URL like: ...&files=[file1.root,file2.root]&items=[file1.root/hpx, file2.root/_same_] ...&files=[file1.root,file2.root]&item=file1.root/hpx+file2.root/_same_ Main limitation - file names should have similar length.; When ‘autozoom’ specified in draw options, histogram zoomed into non-empty content. Same command avai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:9744,load,loaded,9744,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['load'],['loaded']
Performance,"ace; colors to distinguish contours (""SURF"" option at theta = 0). Combined; with the option ""CONT"" (or ""CONT0""), the option ""Z""; allows to display the color palette defined by gStyle->SetPalette(). Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *hcont4 = new TH2F(""hcont4"",""Option CONT4Z example "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcont4->Fill(px-1,5*py);; hcont4->Fill(2+0.5*px,2*py-10.,0.1);; }; gStyle->SetPalette(1);; hcont4->Draw(""CONT4Z"");; return c1;; }; The default number of contour levels is 20 equidistant levels and can be changed; with TH1::SetContour() or TStyle::SetNumberContours().; The LIST option; When option ""LIST"" is specified together with option; ""CONT"", the points used to draw the contours are saved in; TGraph objects:. h->Draw(""CONT LIST"");; gPad->Update();. The contour are saved in TGraph objects once the pad is painted.; Therefore to use this functionnality in a macro, gPad->Update(); should be performed after the histogram drawing. Once the list is; built, the contours are accessible in the following way:. TObjArray *contours = gROOT->GetListOfSpecials()->FindObject(""contours""); Int_t ncontours = contours->GetSize();; TList *list = (TList*)contours->At(i);. Where i is a contour number, and list contains a list of; TGraph objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example shows how to use this functionality. Picture; Source. // Getting Contours From TH2D; // Author: Josh de Bever; // CSI Medical Physics Group; // The University of Western Ontario; // London, Ontario, Canada; // Date: Oct. 22, 2004; // Modified by O.Couet (Nov. 26, 2004). Double_t SawTooth(Double_t x, Double_t WaveLen);. TCanvas *ContourList(){. const Double_t PI = TMath::Pi();. TC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THistPainter.html:40114,perform,performed,40114,root/html602/THistPainter.html,https://root.cern,https://root.cern/root/html602/THistPainter.html,1,['perform'],['performed']
Performance,"ace; colors to distinguish contours (""SURF"" option at theta = 0). Combined; with the option ""CONT"" (or ""CONT0""), the option ""Z""; allows to display the color palette defined by gStyle->SetPalette(). Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *hcont4 = new TH2F(""hcont4"",""Option CONT4Z example "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcont4->Fill(px-1,5*py);; hcont4->Fill(2+0.5*px,2*py-10.,0.1);; }; gStyle->SetPalette(1);; hcont4->Draw(""CONT4Z"");; return c1;; }; The default number of contour levels is 20 equidistant levels and can be changed; with TH1::SetContour() or TStyle::SetNumberContours().; The LIST option; When option ""LIST"" is specified together with option; ""CONT"", the points used to draw the contours are saved in; TGraph objects:. h->Draw(""CONT LIST"");; gPad->Update();. The contour are saved in TGraph objects once the pad is painted.; Therefore to use this functionnality in a macro, gPad->Update(); should be performed after the histogram drawing. Once the list is; built, the contours are accessible in the following way:. TObjArray *contours = gROOT->GetListOfSpecials()->FindObject(""contours""); Int_t ncontours = contours->GetSize();; TList *list = (TList*)contours->At(i);. Where i is a contour number, and list contains a list of; TGraph objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example shows how to use this functionality. Picture; Source. // Getting Contours From TH2D; // Author: Josh de Bever; // CSI Medical Physics Group; // The University of Western Ontario; // London, Ontario, Canada; // Date: Oct. 22, 2004; // Modified by O.Couet (Nov. 26, 2004). TCanvas *ContourList(){. const Double_t PI = TMath::Pi();. TCanvas* c = new TCanvas(""c"",""Contour List"",0,0,600,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:35542,perform,performed,35542,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,4,['perform'],['performed']
Performance,"acementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name compatibi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:28342,perform,perform,28342,root/html528/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,3,['perform'],['perform']
Performance,"acementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:28342,perform,perform,28342,root/html526/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,1,['perform'],['perform']
Performance,"acementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a sca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:19923,perform,perform,19923,root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,1,['perform'],['perform']
Performance,"ach and every access by caching those object. See ROOT-7830 for example.; This release contains several bug fixes and improvements, notably in unloading and performance. NOTE: The GCC 5 ABI is not supported yet, due to a lack of support in clang. I/O Libraries; hadd; We extended the hadd options to allow more control on the compression settings use for the output file. In particular the new option -fk allows for a copy of the input files with no decompressions/recompression of the TTree baskets even if they do not match the requested compression setting.; New options:. -ff allows to force the compression setting to match the one from the first input; -fk[0-209] allows to keep all the basket compressed as is and to compress the meta data with the given compression setting or the compression setting of the first input file.; -a option append to existing file; The verbosity level is now optional after -v. Command line utilities; We added command line utilities to streamline very common operations performed on root files, like listing their content or creating directories. The command line utilities are: - rootbrowse: to open the file in a TBrowser - rootcp: to copy content from one file to another - rooteventselector: to select a subset of the events in a tree contained in a file - rootls: to list the content of a rootfile - rootmkdir: to create a directory in a rootfile - rootmv: to move content across files - rootprint: to plot content (histograms, graphs) of files - rootrm: to remove content from files These utilities took inspiration from the well known *nix commands and all offer the -h switch which provides documentation for all options available and example invocation lines.; TBufferFile.; We updated TBuffer::Expand to properly shrink the buffer when requested, hence reducing memory usage in some cases.; I/O New functionalities; We added support for template parameter packs in class name involved in the I/O.; TTree Libraries; Improvement of handling of default n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:8229,perform,performed,8229,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['perform'],['performed']
Performance,"ach pdf list element (i) is paired with coefficient list element (i).; The number of coefficients must be either equal to the number of PDFs,; in which case extended MLL fitting is enabled, or be one less. All PDFs must inherit from RooAbsPdf. All coefficients must inherit from RooAbsReal. RooAddModel(const RooAddModel& other, const char* name = 0); Copy constructor. ~RooAddModel(); Destructor. void fixCoefNormalization(const RooArgSet& refCoefNorm); By default the interpretation of the fraction coefficients is; performed in the contextual choice of observables. This makes the; shape of the p.d.f explicitly dependent on the choice of; observables. This method instructs RooAddPdf to freeze the; interpretation of the coefficients to be done in the given set of; observables. If frozen, fractions are automatically transformed; from the reference normalization set to the contextual normalization; set by ratios of integrals. void fixCoefRange(const char* rangeName); By default the interpretation of the fraction coefficients is; performed in the default range. This make the shape of a RooAddPdf; explicitly dependent on the range of the observables. To allow; a range independent definition of the fraction this function; instructs RooAddPdf to freeze its interpretation in the given; named range. If the current normalization range is different; from the reference range, the appropriate fraction coefficients; are automically calculation from the reference fractions using; ratios if integrals. RooResolutionModel* convolution(RooFormulaVar* basis, RooAbsArg* owner) const; Instantiate a clone of this resolution model representing a convolution with given; basis function. The owners object name is incorporated in the clones name; to avoid multiple convolution objects with the same name in complex PDF structures. RooAddModel will clone all the component models to create a composite convolution object. Int_t basisCode(const char* name) const; Return code for basis function representi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:43866,perform,performed,43866,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,7,['perform'],['performed']
Performance,"achToVStore(RooVectorDataStore& vstore); virtual const char*RooNumRunningInt::binningName() const; TStringRooAbsCachedReal::cacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidRooAbsCachedReal::clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); virtual RooAbsCachedReal::FuncCacheElem*RooNumRunningInt::createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voidRooAbsCachedReal::disableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooNumRunningInt::evaluate() const; virtual voidfillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; static Bool_tRooAbsArg::flipAClean(); RooAbsCachedReal::FuncCacheElem*RooAbsCachedReal::getCache(const RooArgSet* nset) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual const char*RooNumRunningInt::inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumCdf.html:27081,cache,cacheFunc,27081,root/html532/RooNumCdf.html,https://root.cern,https://root.cern/root/html532/RooNumCdf.html,1,['cache'],['cacheFunc']
Performance,"ache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache mis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:3690,cache,cache,3690,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"ache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenProdProj(); Default constructor. RooGenProdProj(const char* name, const char* title, const RooArgSet& _prodSet, const RooArgSet& _intSet, const RooArgSet& _normSet, const char* isetRangeName, const char* normRangeName = 0, Bool_t doFactorize = kTRUE); Constructor for a normalization projection of the product of p.d.f.s _prodSet; integrated over _intSet in range isetRangeName while normalized over _normSet. RooGenProdProj(const RooGenProdProj& other, const char* name = 0); Copy constructor. ~RooGenProdProj(); Destructor. RooAbsReal* makeIntegral(const char* name, const RooArgSet& compSet, const RooArgSet& intSet, RooArgSet& saveSet, const char* isetRangeName, Bool_t doFactorize); Utility function to create integral over observables intSet in range isetRangeName over product of p.d.fs in compSet.; The integration is factorized into components as much as possible and done analytically as far as possible.; All component object needed to represent product integral are added as owned members to saveSet.; The return value is a RooAbsReal object representing the requested integral. Double_t evaluate() const; Calculate and return value of normalization projection. void operModeHook(); Intercept cache mode operation changes and propagate them to the components. TObject* clone(const char* newname) const; { return new RooGenProdProj(*this, newname); }. » Last changed: Mon Jul 4 15:23:02 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooGenProdProj.html:35174,cache,cache,35174,root/html530/RooGenProdProj.html,https://root.cern,https://root.cern/root/html530/RooGenProdProj.html,1,['cache'],['cache']
Performance,"ache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenProdProj(); Default constructor. RooGenProdProj(const char* name, const char* title, const RooArgSet& _prodSet, const RooArgSet& _intSet, const RooArgSet& _normSet, const char* isetRangeName, const char* normRangeName = 0, Bool_t doFactorize = kTRUE); Constructor for a normalization projection of the product of p.d.f.s _prodSet; integrated over _intSet in range isetRangeName while normalized over _normSet. RooGenProdProj(const RooGenProdProj& other, const char* name = 0); Copy constructor. ~RooGenProdProj(); Destructor. RooAbsReal* makeIntegral(const char* name, const RooArgSet& compSet, const RooArgSet& intSet, RooArgSet& saveSet, const char* isetRangeName, Bool_t doFactorize); Utility function to create integral over observables intSet in range isetRangeName over product of p.d.fs in compSet.; The integration is factorized into components as much as possible and done analytically as far as possible.; All component object needed to represent product integral are added as owned members to saveSet.; The return value is a RooAbsReal object representing the requested integral. Double_t evaluate() const; Calculate and return value of normalization projection. void operModeHook(); Intercept cache mode operation changes and propagate them to the components. TObject* clone(const char* newname) const; { return new RooGenProdProj(*this, newname); }. » Last changed: Thu Nov 3 20:08:19 2011 » Last generated: 2011-11-03 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGenProdProj.html:35553,cache,cache,35553,root/html532/RooGenProdProj.html,https://root.cern,https://root.cern/root/html532/RooGenProdProj.html,1,['cache'],['cache']
Performance,"ache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenProdProj(); Default constructor. RooGenProdProj(const char* name, const char* title, const RooArgSet& _prodSet, const RooArgSet& _intSet, const RooArgSet& _normSet, const char* isetRangeName, const char* normRangeName = 0, Bool_t doFactorize = kTRUE); Constructor for a normalization projection of the product of p.d.f.s _prodSet; integrated over _intSet in range isetRangeName while normalized over _normSet. RooGenProdProj(const RooGenProdProj& other, const char* name = 0); Copy constructor. ~RooGenProdProj(); Destructor. RooAbsReal* makeIntegral(const char* name, const RooArgSet& compSet, const RooArgSet& intSet, RooArgSet& saveSet, const char* isetRangeName, Bool_t doFactorize); Utility function to create integral over observables intSet in range isetRangeName over product of p.d.fs in compSet.; The integration is factorized into components as much as possible and done analytically as far as possible.; All component object needed to represent product integral are added as owned members to saveSet.; The return value is a RooAbsReal object representing the requested integral. Double_t evaluate() const; Calculate and return value of normalization projection. void operModeHook(); Intercept cache mode operation changes and propagate them to the components. TObject* clone(const char* newname) const; { return new RooGenProdProj(*this, newname); }. » Last changed: Tue Jun 2 15:31:20 2015 » Last generated: 2015-06-02 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooGenProdProj.html:39229,cache,cache,39229,root/html604/RooGenProdProj.html,https://root.cern,https://root.cern/root/html604/RooGenProdProj.html,1,['cache'],['cache']
Performance,ache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; pRooRealMPFE*RooAbsTestStatistic::_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplitRooAbsTestStatistic::_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_tRooAbsTestStatistic::_nCPUNumber of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataWeightedAverage.html:39794,cache,cache,39794,root/html602/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html602/RooDataWeightedAverage.html,4,['cache'],['cache']
Performance,"ache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; Int_tRooSimultaneous::_numPdfNumber of registered PDFs; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooObjCacheManagerRooSimultaneous::_partIntMgrComponent normalization manager; TListRooSimultaneous::_pdfProxyListList of PDF proxies (named after applicable category state); Int_tRooAbsReal::_plotBinsNumber of plot bins; const TNamed*RooSimultaneous::_plotCoefNormRange; RooSetProxyRooSimultaneous::_plotCoefNormSet; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__HistFactorySimultaneous.html:44034,cache,cache,44034,root/html534/RooStats__HistFactory__HistFactorySimultaneous.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__HistFactorySimultaneous.html,1,['cache'],['cache']
Performance,"ache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; Int_tRooSimultaneous::_numPdfNumber of registered PDFs; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooObjCacheManagerRooSimultaneous::_partIntMgrComponent normalization manager; TListRooSimultaneous::_pdfProxyListList of PDF proxies (named after applicable category state); Int_tRooAbsReal::_plotBinsNumber of plot bins; const TNamed*RooSimultaneous::_plotCoefNormRange; RooSetProxyRooSimultaneous::_plotCoefNormSet; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__HistFactorySimultaneous.html:45764,cache,cache,45764,root/html602/RooStats__HistFactory__HistFactorySimultaneous.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__HistFactorySimultaneous.html,2,['cache'],['cache']
Performance,"ache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; Bool_t_protectNegative; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooPoisson.html:42559,cache,cache,42559,root/html534/RooPoisson.html,https://root.cern,https://root.cern/root/html534/RooPoisson.html,1,['cache'],['cache']
Performance,"ache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:45000,cache,cache,45000,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,6,['cache'],['cache']
Performance,"ache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TName",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:49199,cache,cache,49199,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,3,['cache'],['cache']
Performance,"ache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree()->AddBranchToCache(b, subbranches);; 1110 if (res<0) {; 1111 Error(""AddBranchToCache"", ""Error adding branch"");; 1112 }; 1113 return res;; 1114 }; 1115 } else {; 1116 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1117 return -1;; 1118 }; 1119 ; 1120 TFile *f = GetCurrentFile();; 1121 if (!f) {; 1122 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1123 return -1;; 1124 }; 1125 TTreeCache *tc = GetReadCache(f,true);; 1126 if (!tc) {; 1127 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1128 return -1;; 1129 }; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranches is true all the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:40433,cache,cache,40433,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"acheAlpha is true, a two-dimensional cache is constructed in both alpha and x. ; Definition at line 101 of file RooIntegralMorph.cxx. ◆ RooIntegralMorph() [3/3]. RooIntegralMorph::RooIntegralMorph ; (; const RooIntegralMorph & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 119 of file RooIntegralMorph.cxx. Member Function Documentation. ◆ actualObservables(). RooFit::OwningPtr< RooArgSet > RooIntegralMorph::actualObservables ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Observable to be cached for given choice of normalization. ; Returns the 'x' observable unless doCacheAlpha is set in which case a set with both x and alpha ; Implements RooAbsCachedPdf.; Definition at line 134 of file RooIntegralMorph.cxx. ◆ actualParameters(). RooFit::OwningPtr< RooArgSet > RooIntegralMorph::actualParameters ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Parameters of the cache. ; Returns parameters of both pdf1 and pdf2 and parameter cache, in case doCacheAlpha is not set. ; Implements RooAbsCachedPdf.; Definition at line 148 of file RooIntegralMorph.cxx. ◆ cacheAlpha(). bool RooIntegralMorph::cacheAlpha ; (; ); const. inline . Definition at line 45 of file RooIntegralMorph.h. ◆ Class(). static TClass * RooIntegralMorph::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooIntegralMorph::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooIntegralMorph::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 110 of file RooIntegralMorph.h. ◆ clone(). TObject * RooIntegralMorph::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 35 of file RooIntegralMorph.h. ◆ createCache(). RooAbsCachedPdf::PdfCacheElem * RooIntegralMorph::createCache ; (; const RooArgSet * ; nset); const. overrideprotectedvirtual . Create and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooIntegralMorph.html:82435,cache,cache,82435,doc/master/classRooIntegralMorph.html,https://root.cern,https://root.cern/doc/master/classRooIntegralMorph.html,1,['cache'],['cache']
Performance,acheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooSetProxy_compSetDSet proxy for denominator components ; RooSetProxy_compSetNSet proxy for numerator components ; RooArgSet*_compSetOwnedDOwner of denominator components; RooArgSet*_compSetOwnedNOwner of numerator components ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveDDo we have a denominator term?; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooListProxy_intListMaster integrals representing numerator and denominator; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenProdProj.html:31029,cache,cache,31029,root/html526/RooGenProdProj.html,https://root.cern,https://root.cern/root/html526/RooGenProdProj.html,4,['cache'],['cache']
Performance,"acheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxyc; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExponential.html:39031,cache,cache,39031,root/html528/RooExponential.html,https://root.cern,https://root.cern/root/html528/RooExponential.html,2,['cache'],['cache']
Performance,"acheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache ()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinWidthFunction.html:34447,cache,cache,34447,doc/master/classRooBinWidthFunction.html,https://root.cern,https://root.cern/doc/master/classRooBinWidthFunction.html,136,['cache'],['cache']
Performance,acheRead.h. ◆ fNoCacheReadCalls. Int_t TFileCacheRead::fNoCacheReadCalls. protected . Number of read calls by basket to fill cached tree. ; Definition at line 34 of file TFileCacheRead.h. ◆ fNseek. Int_t TFileCacheRead::fNseek. protected . Number of blocks to be prefetched. ; Definition at line 39 of file TFileCacheRead.h. ◆ fNtot. Int_t TFileCacheRead::fNtot. protected . Total size of prefetched blocks. ; Definition at line 40 of file TFileCacheRead.h. ◆ fPos. Long64_t* TFileCacheRead::fPos. protected . [fNb] start of long buffers ; Definition at line 46 of file TFileCacheRead.h. ◆ fPrefetch. TFilePrefetch* TFileCacheRead::fPrefetch. protected . ! Object that does the asynchronous reading in another thread ; Definition at line 25 of file TFileCacheRead.h. ◆ fPrefetchedBlocks. Long64_t TFileCacheRead::fPrefetchedBlocks. protected . Number of blocks prefetched. ; Definition at line 55 of file TFileCacheRead.h. ◆ fReadCalls. Int_t TFileCacheRead::fReadCalls. protected . Number of read calls for this cache. ; Definition at line 32 of file TFileCacheRead.h. ◆ fSeek. Long64_t* TFileCacheRead::fSeek. protected . [fNseek] Position on file of buffers to be prefetched ; Definition at line 43 of file TFileCacheRead.h. ◆ fSeekIndex. Int_t* TFileCacheRead::fSeekIndex. protected . [fNseek] sorted index table of fSeek ; Definition at line 45 of file TFileCacheRead.h. ◆ fSeekLen. Int_t* TFileCacheRead::fSeekLen. protected . [fNseek] Length of buffers to be prefetched ; Definition at line 47 of file TFileCacheRead.h. ◆ fSeekPos. Int_t* TFileCacheRead::fSeekPos. protected . [fNseek] Position of sorted blocks in fBuffer ; Definition at line 49 of file TFileCacheRead.h. ◆ fSeekSize. Int_t TFileCacheRead::fSeekSize. protected . Allocated size of fSeek. ; Definition at line 42 of file TFileCacheRead.h. ◆ fSeekSort. Long64_t* TFileCacheRead::fSeekSort. protected . [fNseek] Position on file of buffers to be prefetched (sorted) ; Definition at line 44 of file TFileCacheRead.h. ◆ fSeekSortLe,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheRead.html:30508,cache,cache,30508,doc/master/classTFileCacheRead.html,https://root.cern,https://root.cern/doc/master/classTFileCacheRead.html,1,['cache'],['cache']
Performance,"acheRead::ReadBuffervirtual Int_t ReadBuffer(char *buf, Long64_t pos, Int_t len)Read buffer at position pos.Definition TFileCacheRead.cxx:364; TFileCacheRead::Closevirtual void Close(Option_t *option="""")Close out any threads or asynchronous fetches used by the underlying implementation.Definition TFileCacheRead.cxx:189; TFileCacheRead::GetBufferSizevirtual Int_t GetBufferSize() constDefinition TFileCacheRead.h:88; TFileCacheRead::GetFileTFile * GetFile() constDefinition TFileCacheRead.h:92; TFileCacheRead::SetFilevirtual void SetFile(TFile *file, TFile::ECacheAction action=TFile::kDisconnect)Set the file using this cache and reset the current blocks (if any).Definition TFileCacheRead.cxx:545; TFileCacheWriteA cache when writing files over the network.Definition TFileCacheWrite.h:19; TFileCacheWrite::Flushvirtual Bool_t Flush()Flush the current write buffer to the file.Definition TFileCacheWrite.cxx:79; TFileCacheWrite::ReadBuffervirtual Int_t ReadBuffer(char *buf, Long64_t pos, Int_t len)Called by the read cache to check if the requested data is not in the write cache buffer.Definition TFileCacheWrite.cxx:108; TFileCacheWrite::GetBytesInCachevirtual Int_t GetBytesInCache() constDefinition TFileCacheWrite.h:38; TFileCacheWrite::WriteBuffervirtual Int_t WriteBuffer(const char *buf, Long64_t pos, Int_t len)Write buffer at position pos in the write buffer.Definition TFileCacheWrite.cxx:121; TFileOpenHandleClass holding info about the file being opened.Definition TFile.h:354; TFileOpenHandle::fFileTFile * fFileTFile instance of the file being opened.Definition TFile.h:362; TFileOpenHandle::GetNetOptInt_t GetNetOpt() constDefinition TFile.h:381; TFileOpenHandle::GetFileTFile * GetFile() constDefinition TFile.h:372; TFileOpenHandle::GetOptconst char * GetOpt() constDefinition TFile.h:379; TFileOpenHandle::MatchesBool_t Matches(const char *name)Return kTRUE if this async request matches the open request specified by 'url'.Definition TFile.cxx:4790; TFileOpenHandle::GetCompr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:209243,cache,cache,209243,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,['cache'],['cache']
Performance,acheRead::fBNseek; Int_tTFileCacheRead::fBNtot; Long64_t*TFileCacheRead::fBPos; Long64_t*TFileCacheRead::fBSeek; Int_t*TFileCacheRead::fBSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:18461,cache,cache,18461,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['cache'],['cache']
Performance,"acheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsOptTestStatistic.html:2746,cache,cacheUniqueSuffix,2746,root/html534/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html,1,['cache'],['cacheUniqueSuffix']
Performance,"acheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsOptTestStatistic.html:2746,cache,cacheUniqueSuffix,2746,root/html532/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsOptTestStatistic.html,1,['cache'],['cacheUniqueSuffix']
Performance,"achedPdf(const RooAbsCachedPdf& other, const char* name = 0); Copy constructor. ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedPdf.html:48031,cache,cache,48031,root/html602/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html,2,['cache'],['cache']
Performance,"achedReal, and RooGenProdProj.; Definition at line 562 of file RooAbsArg.h. ◆ optimizeCacheMode() [1/2]. void RooAbsArg::optimizeCacheMode ; (; const RooArgSet & ; observables). virtual . Activate cache mode optimization with given definition of observables. ; The cache operation mode of all objects in the expression tree will modified such that all nodes that depend directly or indirectly on any of the listed observables will be set to ADirty, as they are expected to change every time. This save change tracking overhead for nodes that are a priori known to change every time ; Definition at line 1782 of file RooAbsArg.cxx. ◆ optimizeCacheMode() [2/2]. void RooAbsArg::optimizeCacheMode ; (; const RooArgSet & ; observables, . RooArgSet & ; optimizedNodes, . RooLinkedList & ; processedNodes . ). virtual . Activate cache mode optimization with given definition of observables. ; The cache operation mode of all objects in the expression tree will modified such that all nodes that depend directly or indirectly on any of the listed observables will be set to ADirty, as they are expected to change every time. This save change tracking overhead for nodes that are a priori known to change every time ; Definition at line 1801 of file RooAbsArg.cxx. ◆ optimizeDirtyHook(). virtual void RooAbsArg::optimizeDirtyHook ; (; const RooArgSet * ; ). inlineprotectedvirtual . Definition at line 564 of file RooAbsArg.h. ◆ overlaps(). bool RooAbsArg::overlaps ; (; const RooAbsArg & ; testArg, . bool ; valueOnly = false . ); const. Test if any of the nodes of tree are shared with that of the given tree. ; Definition at line 900 of file RooAbsArg.cxx. ◆ ownedComponents(). const RooArgSet * RooAbsArg::ownedComponents ; (; ); const. inline . Definition at line 519 of file RooAbsArg.h. ◆ Print(). void RooAbsArg::Print ; (; Option_t * ; options = nullptr); const. inlineoverridevirtual . Print the object to the defaultPrintStream(). ; Parameters. [in]optionsV print verbose. T print a tree structure ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:78742,cache,cache,78742,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['cache']
Performance,achedReal::payloadUniqueSuffix ; (; ); const. inlineoverrideprotectedvirtual . Reimplemented from RooAbsCachedReal.; Definition at line 63 of file RooCachedReal.h. ◆ setCacheSource(). void RooCachedReal::setCacheSource ; (; bool ; flag). inline . Definition at line 43 of file RooCachedReal.h. ◆ setCdfBoundaries(). void RooCachedReal::setCdfBoundaries ; (; bool ; flag). inline . If flag is true the RooHistFunc that represent the cache histogram will use special boundary conditions for use with cumulative distribution functions: at the lower bound the function is forced to converge at zero and the upper bound is the function is forced to converge at 1.0. ; Definition at line 34 of file RooCachedReal.h. ◆ Streamer(). void RooCachedReal::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsCachedReal. ◆ StreamerNVirtual(). void RooCachedReal::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 72 of file RooCachedReal.h. Member Data Documentation. ◆ _cacheObs. RooSetProxy RooCachedReal::_cacheObs. protected . Variables to be cached. ; Definition at line 66 of file RooCachedReal.h. ◆ _cacheSource. bool RooCachedReal::_cacheSource. protected . Keep an attached clone of the source in the cache for fast operation. ; Definition at line 68 of file RooCachedReal.h. ◆ _useCdfBoundaries. bool RooCachedReal::_useCdfBoundaries. protected . Are c.d.f boundary conditions used by the RooHistFuncs? ; Definition at line 67 of file RooCachedReal.h. ◆ func. RooRealProxy RooCachedReal::func. protected . Proxy to function being cached. ; Definition at line 65 of file RooCachedReal.h. Libraries for RooCachedReal:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooCachedReal.h; roofit/roofitcore/src/RooCachedReal.cxx. RooCachedReal. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:46 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:69881,cache,cached,69881,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,3,['cache'],"['cache', 'cached']"
Performance,"acing in the pad. void SaveAs(const char* filename, Option_t* option = """") const; Save geometry having this as top volume as a C++ macro. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void UnmarkSaved(); Reset SavePrimitive bits. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this volume. TGeoNode * FindNode(const char* name) const; search a daughter inside the list of nodes. Int_t GetNodeIndex(const TGeoNode* node, Int_t* check_list, Int_t ncheck) const; Get the index of a daugther within check_list by providing the node pointer. Int_t GetIndex(const TGeoNode* node) const; get index number for a given daughter. char * GetObjectInfo(Int_t px, Int_t py) const; Get volume info for the browser. Bool_t GetOptimalVoxels() const; --- Returns true if cylindrical voxelization is optimal. char * GetPointerName() const; Provide a pointer name containing uid. TGeoVoxelFinder * GetVoxels() const; Getter for optimization structure. void GrabFocus(); Move perspective view focus to this volume. Bool_t IsAssembly() const; Returns true if the volume is an assembly or a scaled assembly. TGeoVolume * CloneVolume() const; Clone this volume.; build a volume with same name, shape and medium. void CloneNodesAndConnect(TGeoVolume* newmother) const; Clone the array of nodes. void MakeCopyNodes(const TGeoVolume* other); make a new list of nodes and copy all nodes of other volume inside. TGeoVolume * MakeCopyVolume(TGeoShape* newshape); make a copy of this volume; build a volume with same name, shape and medium. TGeoVolume * MakeReflectedVolume(const char* newname = """") const; Make a copy of this volume which is reflected with respect to XY plane. void SetAsTopVolume(); Set this volume as the TOP one (the whole geometry starts from here). void SetCurrentPoint(Double_t x, Double_t y, Double_t z); Set the current tracking point. void SetShape(const TGeoShape* shape); set the shape associated ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoVolume.html:29035,optimiz,optimization,29035,root/html532/TGeoVolume.html,https://root.cern,https://root.cern/root/html532/TGeoVolume.html,1,['optimiz'],['optimization']
Performance,"acing in the pad. void SaveAs(const char* filename, Option_t* option = """") const; Save geometry having this as top volume as a C++ macro. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void UnmarkSaved(); Reset SavePrimitive bits. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this volume. TGeoNode * FindNode(const char* name) const; search a daughter inside the list of nodes. Int_t GetNodeIndex(const TGeoNode* node, Int_t* check_list, Int_t ncheck) const; Get the index of a daugther within check_list by providing the node pointer. Int_t GetIndex(const TGeoNode* node) const; get index number for a given daughter. char * GetObjectInfo(Int_t px, Int_t py) const; Get volume info for the browser. Bool_t GetOptimalVoxels() const; --- Returns true if cylindrical voxelization is optimal. char * GetPointerName() const; Provide a pointer name containing uid. TGeoVoxelFinder * GetVoxels() const; Getter for optimization structure. void GrabFocus(); Move perspective view focus to this volume. TGeoVolume * CloneVolume() const; Clone this volume.; build a volume with same name, shape and medium. void CloneNodesAndConnect(TGeoVolume* newmother) const; Clone the array of nodes. void MakeCopyNodes(const TGeoVolume* other); make a new list of nodes and copy all nodes of other volume inside. TGeoVolume * MakeCopyVolume(TGeoShape* newshape); make a copy of this volume; build a volume with same name, shape and medium. TGeoVolume * MakeReflectedVolume(const char* newname = """") const; Make a copy of this volume which is reflected with respect to XY plane. void SetAsTopVolume(); Set this volume as the TOP one (the whole geometry starts from here). void SetCurrentPoint(Double_t x, Double_t y, Double_t z); Set the current tracking point. void SetShape(const TGeoShape* shape); set the shape associated with this volume. void SortNodes(); sort nodes by decreasing volume of the bounding box. ON",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoVolume.html:28627,optimiz,optimization,28627,root/html528/TGeoVolume.html,https://root.cern,https://root.cern/root/html528/TGeoVolume.html,2,['optimiz'],['optimization']
Performance,"ack is coming from. When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker.**. Overlap checking. This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; Here precision represents the desired maximum accepted overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). The check is performed by verifying the mesh representation of one candidate against the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=“d” or option=“",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1000466,load,loaded,1000466,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance,"ackPropagator.cxx. ◆ DeclFileName(). static const char * TEveTrackPropagator::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 348 of file TEveTrackPropagator.h. ◆ DistributeOffset(). void TEveTrackPropagator::DistributeOffset ; (; const TEveVectorD & ; off, . Int_t ; first_point, . Int_t ; np, . TEveVectorD & ; p . ). private . Distribute offset between first and last point index and rotate momentum. ; Definition at line 777 of file TEveTrackPropagator.cxx. ◆ ElementChanged(). void TEveTrackPropagator::ElementChanged ; (; Bool_t ; update_scenes = kTRUE, . Bool_t ; redraw = kFALSE . ). overridevirtual . Element-change notification. ; Stamp all tracks as requiring display-list regeneration. Virtual from TEveElement. ; Reimplemented from TEveElement.; Definition at line 308 of file TEveTrackPropagator.cxx. ◆ FillPointSet(). void TEveTrackPropagator::FillPointSet ; (; TEvePointSet * ; ps); const. Reset ps and populate it with points in propagation cache. ; Definition at line 1005 of file TEveTrackPropagator.cxx. ◆ GetCurrentPoint(). Int_t TEveTrackPropagator::GetCurrentPoint ; (; ); const. Get index of current point on track. ; Definition at line 358 of file TEveTrackPropagator.cxx. ◆ GetDelta(). Double_t TEveTrackPropagator::GetDelta ; (; ); const. inline . Definition at line 317 of file TEveTrackPropagator.h. ◆ GetEditPathMarks(). Bool_t TEveTrackPropagator::GetEditPathMarks ; (; ); const. inline . Definition at line 319 of file TEveTrackPropagator.h. ◆ GetFitCluster2Ds(). Bool_t TEveTrackPropagator::GetFitCluster2Ds ; (; ); const. inline . Definition at line 327 of file TEveTrackPropagator.h. ◆ GetFitDaughters(). Bool_t TEveTrackPropagator::GetFitDaughters ; (; ); const. inline . Definition at line 324 of file TEveTrackPropagator.h. ◆ GetFitDecay(). Bool_t TEveTrackPropagator::GetFitDecay ; (; ); const. inline . Definition at line 326 of file TEveTrackPropagator.h. ◆ GetFitLineSegments(). Bool_t TEveTra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTrackPropagator.html:47178,cache,cache,47178,doc/master/classTEveTrackPropagator.html,https://root.cern,https://root.cern/doc/master/classTEveTrackPropagator.html,1,['cache'],['cache']
Performance,"ackground trees; ; inputFileName = ""Higgs_data.root""; inputFileLink = ""http://root.cern.ch/files/"" + inputFileName; ; ; if ROOT.gSystem.AccessPathName(inputFileName):; ROOT.Info(""TMVA_Higgs_Classification"", ""Download Higgs_data.root file""); TFile.SetCacheFileDir("".""); inputFile = TFile.Open(inputFileLink, ""CACHEREAD""); if inputFile is None:; raise FileNotFoundError(""Input file cannot be downloaded - exit""); else:; # file exists; inputFile = TFile.Open(inputFileName); ; ; # --- Register the training and test trees; signalTree = inputFile.Get(""sig_tree""); backgroundTree = inputFile.Get(""bkg_tree""); signalTree.Print(); ; ## Declare DataLoader(s); ; # The next step is to declare the DataLoader class that deals with input variables; # Define the input variables that shall be used for the MVA training; # note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; loader = TMVA.DataLoader(""dataset""); ; loader.AddVariable(""m_jj""); loader.AddVariable(""m_jjj""); loader.AddVariable(""m_lv""); loader.AddVariable(""m_jlv""); loader.AddVariable(""m_bb""); loader.AddVariable(""m_wbb""); loader.AddVariable(""m_wwbb""); ; # We set now the input data trees in the TMVA DataLoader class; # global event weights per tree (see below for setting event-wise weights); signalWeight = 1.0; backgroundWeight = 1.0; # You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight); loader.AddBackgroundTree(backgroundTree, backgroundWeight); ; # Set individual event weights (the variables must exist in the original TTree); # for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; # for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; # loader->SetBackgroundWeightExpression( ""weight"" );; ; ; # Apply additional cuts on the signal and background samples (can be different); mycuts = ROOT.TCut("""") # for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; mycutb = ROOT.TCut("""") # for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:59397,load,loader,59397,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['load'],['loader']
Performance,"acobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_mode; static Int_tRooPrintable::_nameLength; RooAbsIntegrator*_numIntEngine! do not persist; RooAbsFunc*_numIntegrand! do not persist; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet*_params! cache for set of parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; TNamed*_rangeName; Bool_t_restartNumIntEngine! do not persist; RooArgSet_saveInt! do not persist; RooArgSet_saveSum! do not persist ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooListProxy_sumCat! do not persist ; TIterator*_sumCatIter!; RooSetProxy_sumListSet of discrete observable over which is summed numerically; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealIntegral.html:33385,cache,cache,33385,root/html526/RooRealIntegral.html,https://root.cern,https://root.cern/root/html526/RooRealIntegral.html,1,['cache'],['cache']
Performance,"acted distribution ; [in]useAxisBinning(default=true) if set to true, try to extract a histogram with proper binning and axis labels ; [out]ematInv(default=nullptr) to return the inverse covariance matrix. returns a new histogram. See method GetOutput() for a detailed description of the arguments. The inverse of the covariance matrix is stored in a new histogram returned by ematInv if that pointer is non-zero. ; Definition at line 813 of file TUnfoldDensity.cxx. ◆ GetScanVariable(). Double_t TUnfoldDensity::GetScanVariable ; (; Int_t ; mode, . const char * ; distribution, . const char * ; axisSteering . ). virtual . calculate the function for ScanTau() ; Parameters. [in]modethe variable to be calculated ; [in]distributiondistribution for which the variable is to be calculated ; [in]axisSteeringdetailed steering for selecting bins on the axes of the distribution (see method GetRhoItotal()). return value: the scan result for the given choice of tau (for which the unfolding was performed prior to calling this method) ; In ScanTau() the unfolding is repeated for various choices of tau. For each tau, after unfolding, GetScanVariable() is called to determine the scan result for this choice of tau. ; the following modes are implemented . kEScanTauRhoAvg : average (stat+bgr) global correlation . kEScanTauRhoSquaredAvg : average (stat+bgr) global correlation squared . kEScanTauRhoMax : maximum (stat+bgr) global correlation . kEScanTauRhoAvgSys : average (stat+bgr+sys) global correlation . kEScanTauRhoAvgSquaredSys : average (stat+bgr+sys) global correlation squared . kEScanTauRhoMaxSys : maximum (stat+bgr+sys) global correlation . Definition at line 1680 of file TUnfoldDensity.cxx. ◆ IsA(). TClass * TUnfoldDensity::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TUnfold.; Definition at line 205 of file TUnfoldDensity.h. ◆ RegularizeDistribution(). void TUnfoldDensity::RegularizeDistribution ; (; ERegMode ; regmode, . ED",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:64748,perform,performed,64748,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,1,['perform'],['performed']
Performance,"activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:41622,cache,cache,41622,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,2,['cache'],['cache']
Performance,"activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:133497,cache,cache,133497,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,1,['cache'],['cache']
Performance,"actor); TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidwriteHistToFile(char* outputFile, const char* histName) const; voidwriteNTupleToFile(char* outputFile, const char* name) const; voidwriteToFile(char* outputFile, const char* name) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/Roo2DKeysPdf.html:29720,cache,cache,29720,root/html528/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html528/Roo2DKeysPdf.html,2,['cache'],['cache']
Performance,"actory : Training finished; : ; Factory : Train method: MLPBNN for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ MLPBNN ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The MLP artificial neural network (ANN) is a traditional feed-; : forward multilayer perceptron implementation. The MLP has a user-; : defined hidden layer architecture, while the number of input (output); : nodes is determined by the input variables (output classes, i.e., ; : signal and one background). ; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Neural networks are stable and performing for a large variety of ; : linear and non-linear classification problems. However, in contrast; : to (e.g.) boosted decision trees, the user is advised to reduce the ; : number of input variables that have only little discrimination power. ; : ; : In the tests we have carried out so far, the MLP and ROOT networks; : (TMlpANN, interfaced via TMVA) performed equally well, with however; : a clear speed advantage for the MLP. The Clermont-Ferrand neural ; : net (CFMlpANN) exhibited worse classification performance in these; : tests, which is partly due to the slow convergence of its training; : (at least 10k training cycles are required to achieve approximately; : competitive results).; : ; : ␛[1mOvertraining: ␛[0monly the TMlpANN performs an explicit separation of the; : full training sample into independent training and validation samples.; : We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would only reduce the available training; : information. However, if the performance on the training sample is ; : found to be significantly better than the one found",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:42530,perform,performed,42530,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['performed']
Performance,"ad a buffer from the file. ;  ; virtual Bool_t ReadBuffer (char *buf, Long64_t pos, Int_t len);  Read a buffer from the file at the offset 'pos' in the file. ;  ; virtual Bool_t ReadBufferAsync (Long64_t offs, Int_t len);  ; virtual Bool_t ReadBuffers (char *buf, Long64_t *pos, Int_t *len, Int_t nbuf);  Read the nbuf blocks described in arrays pos and len. ;  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from this file. ;  ; virtual void ReadStreamerInfo ();  Read the list of StreamerInfo from this file. ;  ; virtual Int_t Recover ();  Attempt to recover file if not correctly closed. ;  ; virtual Int_t ReOpen (Option_t *mode);  Reopen a file with a different access mode. ;  ; virtual void Seek (Long64_t offset, ERelativeTo pos=kBeg);  Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. ;  ; virtual void SetCacheRead (TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect);  Set a pointer to the read cache. ;  ; virtual void SetCacheWrite (TFileCacheWrite *cache);  Set a pointer to the write cache. ;  ; virtual void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Used to specify the compression level and algorithm. ;  ; virtual void SetEND (Long64_t last);  ; virtual void SetOffset (Long64_t offset, ERelativeTo pos=kBeg);  Set position from where to start reading. ;  ; virtual void SetOption (Option_t *option="">"");  ; virtual void SetReadCalls (Int_t readcalls=0);  ; virtual void ShowStreamerInfo ();  Show the StreamerInfo of all classes written to this file. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html:8259,cache,cache,8259,doc/v632/classROOT_1_1TBufferMergerFile.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html,10,['cache'],['cache']
Performance,"ad array of Float16_t from buffer. ; Implements TBuffer.; Definition at line 583 of file TBufferText.cxx. ◆ ReadString(). char * TBufferText::ReadString ; (; char * ; , . Int_t ;  . ). inlinefinalvirtual . Implements TBuffer.; Definition at line 91 of file TBufferText.h. ◆ ReadVersionForMemberWise(). Version_t TBufferText::ReadVersionForMemberWise ; (; const TClass * ; = nullptr). inlinefinalvirtual . Implements TBuffer.; Definition at line 98 of file TBufferText.h. ◆ ReadVersionNoCheckSum(). Version_t TBufferText::ReadVersionNoCheckSum ; (; UInt_t * ; , . UInt_t * ;  . ). inlinefinalvirtual . Implements TBuffer.; Definition at line 82 of file TBufferText.h. ◆ ReadWithFactor() [1/2]. void TBufferText::ReadWithFactor ; (; Double_t * ; d, . Double_t ; factor, . Double_t ; minvalue . ). finalvirtual . Read a Double32_t from the buffer when the factor and minimun value have been specified see comments about Double32_t encoding at TBufferFile::WriteDouble32(). ; Currently TBufferText does not optimize space in this case. ; Implements TBuffer.; Definition at line 532 of file TBufferText.cxx. ◆ ReadWithFactor() [2/2]. void TBufferText::ReadWithFactor ; (; Float_t * ; f, . Double_t ; factor, . Double_t ; minvalue . ). finalvirtual . Read a Double32_t from the buffer when the factor and minimun value have been specified see comments about Double32_t encoding at TBufferFile::WriteDouble32(). ; Currently TBufferText does not optimize space in this case. ; Implements TBuffer.; Definition at line 510 of file TBufferText.cxx. ◆ ReadWithNbits() [1/2]. void TBufferText::ReadWithNbits ; (; Double_t * ; d, . Int_t ; nbits . ). finalvirtual . Read a Double32_t from the buffer when the number of bits is specified (explicitly or not) see comments about Double32_t encoding at TBufferFile::WriteDouble32(). ; Currently TBufferText does not optimize space in this case. ; Implements TBuffer.; Definition at line 543 of file TBufferText.cxx. ◆ ReadWithNbits() [2/2]. void TBufferText::ReadWithN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferText.html:43545,optimiz,optimize,43545,doc/master/classTBufferText.html,https://root.cern,https://root.cern/doc/master/classTBufferText.html,1,['optimiz'],['optimize']
Performance,"ad did the work while we were; 1759 // waiting.; 1760 if (!fEnums.load()) fEnums = new TListOfEnumsWithLock(nullptr);; 1761 }; 1762 if (load) {; 1763 R__LOCKGUARD(gROOTMutex);; 1764 (*fEnums).Load(); // Refresh the list of enums.; 1765 }; 1766 return fEnums.load();; 1767}; 1768 ; 1769////////////////////////////////////////////////////////////////////////////////; 1770 ; 1771TCollection *TROOT::GetListOfFunctionTemplates(); 1772{; 1773 R__LOCKGUARD(gROOTMutex);; 1774 if(!fFuncTemplate) {; 1775 fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1776 }; 1777 return fFuncTemplate;; 1778}; 1779 ; 1780////////////////////////////////////////////////////////////////////////////////; 1781/// Return list containing the TGlobals currently defined.; 1782/// Since globals are created and deleted during execution of the; 1783/// program, we need to update the list of globals every time we; 1784/// execute this method. However, when calling this function in; 1785/// a (tight) loop where no interpreter symbols will be created; 1786/// you can set load=kFALSE (default).; 1787 ; 1788TCollection *TROOT::GetListOfGlobals(Bool_t load); 1789{; 1790 if (!fGlobals) {; 1791 fGlobals = new TListOfDataMembers(nullptr, TDictionary::EMemberSelection::kAlsoUsingDecls);; 1792 // We add to the list the ""funcky-fake"" globals.; 1793 ; 1794 // provide special functor for gROOT, while ROOT::GetROOT() does not return reference; 1795 TGlobalMappedFunction::MakeFunctor(""gROOT"", ""TROOT*"", ROOT::GetROOT, [] {; 1796 ROOT::GetROOT();; 1797 return (void *)&ROOT::Internal::gROOTLocal;; 1798 });; 1799 ; 1800 TGlobalMappedFunction::MakeFunctor(""gPad"", ""TVirtualPad*"", TVirtualPad::Pad);; 1801 TGlobalMappedFunction::MakeFunctor(""gVirtualX"", ""TVirtualX*"", TVirtualX::Instance);; 1802 TGlobalMappedFunction::MakeFunctor(""gDirectory"", ""TDirectory*"", TDirectory::CurrentDirectory);; 1803 ; 1804 // Don't let TGlobalMappedFunction delete our globals, now that we take them.; 1805 fGlobals->AddAll(&TGlobalMappedFuncti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:68632,load,load,68632,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['load']
Performance,"ad specified package.; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackageOnClient(const char* package); Unload a specific package on the client.; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::UnloadPackage; case). Keep in sync in case of changes. Int_t UnloadPackages(); Unload all packages.; Returns 0 in case of success and -1 in case of error. Int_t EnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; If specified, enables packages only on the specified workers.; Returns 0 in case of success and -1 in case of error.; Provided for backward compatibility. Int_t EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify options for the loading step via 'loadopts';; the string will be passed passed as argument to SETUP.; Special option 'chkv=<o>' (or 'checkversion=<o>') can be used to control; plugin version checking during building: possible choices are:; off no check; failure may occur at loading; on check ROOT version [default]; svn check ROOT version and Git commit SHA1.; (Use ';', ' ' or '|' to separate 'chkv=<o>' from the rest.); If specified, enables packages only on the specified workers.; Returns 0 in case of success and -1 in case of error. Int_t EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Execute",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:76569,load,loadopts,76569,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,2,['load'],['loadopts']
Performance,"ad specified package.; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackageOnClient(const char* package); Unload a specific package on the client.; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::UnloadPackage; case). Keep in sync in case of changes. Int_t UnloadPackages(); Unload all packages.; Returns 0 in case of success and -1 in case of error. Int_t EnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; If specified, enables packages only on the specified workers.; Returns 0 in case of success and -1 in case of error.; Provided for backward compatibility. Int_t EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify options for the loading step via 'loadopts';; the string will be passed passed as argument to SETUP.; Special option 'chkv=<o>' (or 'checkversion=<o>') can be used to control; plugin version checking during building: possible choices are:; off no check; failure may occur at loading; on check ROOT version [default]; svn check ROOT version and SVN revision number.; (Use ';', ' ' or '|' to separate 'chkv=<o>' from the rest.); If specified, enables packages only on the specified workers.; Returns 0 in case of success and -1 in case of error. Int_t EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Exe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:74413,load,loadopts,74413,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['load'],['loadopts']
Performance,"adBuffer > _treeReadBuffer;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; void finalizeConstruction ();  ; std::pair< const RooArgSet *, AddCacheElem * > getNormAndCache (const RooArgSet *nset) const;  Look up projection cache and per-PDF norm sets. ;  ; void materializeRefCoefNormFromAttribute () const;  ; void setAllExtendable (bool allExtendable);  ; void setRecursiveFraction (bool recursiveFraction);  . Private Attributes; std::unique_ptr< const RooArgSet > _copyOfLastNormSet = nullptr;  ! ;  ; RooFit::UniqueId< RooArgSet >::Value_t _idOfLast",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:75014,cache,cache,75014,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,1,['cache'],['cache']
Performance,"adBuffer > _treeReadBuffer;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static Int_t _evalErrorCount = 0;  ; static std::map< const RooAbsArg *, std::pair< std::string, std::list< EvalError > > > _evalErrorList;  ; static ErrorLoggingMode _evalErrorMode = RooAbsReal::PrintErrors;  ; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:60014,cache,cache,60014,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['cache'],['cache']
Performance,"adBuffer > _treeReadBuffer;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _doFloorGlobal = false;  Global flag for introducing floor at zero in pdf. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static Int_t _evalErrorCount = 0;  ; static std::map< const RooAbsArg *, std::pair< std::string, std::list< EvalError > > > _evalErrorList;  ; static ErrorLoggingMode _evalErrorMode = RooAbsReal::Prin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumPdf.html:65082,cache,cache,65082,doc/v632/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumPdf.html,1,['cache'],['cache']
Performance,"adBuffer > _treeReadBuffer;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _doFloorGlobal = false;  Global flag for introducing floor at zero in pdf. ;  ;  Static Protected Attributes inherited from RooAbsReal; static Int_t _evalErrorCount = 0;  ; static std::map< const RooAbsArg *, std::pair< std::string, std::list< EvalError > > > _evalErrorList;  ; static ErrorLoggingMode _evalErrorMode = RooAbsReal::PrintErrors;  ; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumFunc.html:51161,cache,cache,51161,doc/v632/classRooRealSumFunc.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumFunc.html,1,['cache'],['cache']
Performance,"adEditor. class TVirtualPadEditor. TVirtualPadEditor. Abstract base class used by ROOT graphics editor. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPadEditor(); virtual voidBuild(); static TClass*Class(); virtual voidDeleteEditors(); virtual voidDrawLine(Double_t, Double_t, Double_t, Double_t); virtual voidDrawLineNDC(Double_t, Double_t, Double_t, Double_t); virtual voidDrawText(Double_t, Double_t, const char*); virtual voidDrawTextNDC(Double_t, Double_t, const char*); virtual voidFillAttributes(Int_t, Int_t); virtual TCanvas*GetCanvas() const; static const char*GetEditorName(); static TVirtualPadEditor*GetPadEditor(Bool_t load = kTRUE); virtual voidHide(); static voidHideEditor(); virtual TClass*IsA() const; virtual Bool_tIsGlobal() const; virtual voidLineAttributes(Int_t, Int_t, Int_t); static TVirtualPadEditor*LoadEditor(); virtual voidMarkerAttributes(Int_t, Int_t, Float_t); TVirtualPadEditor&operator=(const TVirtualPadEditor&); virtual voidSetGlobal(Bool_t); static voidSetPadEditorName(const char* name); virtual voidShow(); static voidShowEditor(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); static voidTerminate(); virtual voidTextAttributes(Int_t, Float_t, Int_t, Int_t, Float_t); static voidUpdateFillAttributes(Int_t col, Int_t sty); static voidUpdateLineAttributes(Int_t col, Int_t sty, Int_t width); static voidUpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); static voidUpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize). Data Members; protected:. static TStringfgEditorNamename of the default pad editor ""Ged""; static TVirtualPadEditor*fgPadEditorsingleton editor dialog. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualPadEditor(); Virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualPadEditor.html:1032,load,load,1032,root/html534/TVirtualPadEditor.html,https://root.cern,https://root.cern/root/html534/TVirtualPadEditor.html,1,['load'],['load']
Performance,"adFloat16(Float_t* f, TStreamerElement* ele = 0); read a Float16_t from the buffer. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); read a Double32_t from the buffer. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferXML.html:33213,optimiz,optimize,33213,root/html528/TBufferXML.html,https://root.cern,https://root.cern/root/html528/TBufferXML.html,6,['optimiz'],['optimize']
Performance,"adFunctionMultiNumGradFunction class to wrap a normal function in a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) ;  CMultPolicyMatrix-matrix multiplication policy ;  CNullTypeFunc1D;  COneDimMultiFunctionAdapterOneDimMultiFunctionAdapter class to wrap a multidimensional function in one dimensional one ;  COneDimParamFunctionAdapterOneDimParamFunctionAdapter class to wrap a multi-dim parameteric function in one dimensional one ;  CParamFunctionBase template class for all Parametric Functions ;  CParamFunctionBaseClass defining the signature for multi-dim parametric functions ;  CParamFunctorParam Functor class for Multidimensional functions ;  ►CParamFunctorHandlerParamFunctor Handler class is responsible for wrapping any other functor and pointer to free C functions ;  CFuncEvaluator;  CFuncEvaluator< F * >;  CFuncEvaluator< F *const >;  CParamMemFunHandlerParamFunctor Handler to Wrap pointers to member functions ;  CPlaceExpr;  CPlaceExpr< T, D1, D2, D3, D4, A, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >;  CPlaceExpr< T, D1, D2, D3, D4, A, MatRepSym< T, D1 >, MatRepSym< T, D3 > >;  CPlaceMatrixStructure to deal when a submatrix is placed in a matrix ;  CPlaceMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >;  CPlaceMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepSym< T, D3 > >;  CPlainParameters;  CPlusEqualsEvaluate the expression performing a += operation Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) ;  CPlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >Specialization for symmetrix += general : NOT Allowed operation ;  CPlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices Evaluate the expression performing a += operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:46264,perform,performing,46264,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,2,['perform'],['performing']
Performance,"adNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypefPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tfReadDirectionSet! read direction established; Bool_tfReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←. TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:21034,cache,cache,21034,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,1,['cache'],['cache']
Performance,"adNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypefPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tfReadDirectionSet! read direction established; Bool_tfReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←. TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:20931,cache,cache,20931,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,1,['cache'],['cache']
Performance,"adResults.end(), 0);; 1259 }; 1260 ; 1261 // Called by RDataFrame to retrieve the name of this action.; 1262 std::string GetActionName() const { return ""MyCounter""; }; 1263};; 1264 ; 1265int main() {; 1266 ROOT::RDataFrame df(10);; 1267 ROOT::RDF::RResultPtr<int> resultPtr = df.Book<>(MyCounter{df.GetNSlots()}, {});; 1268 // The GetValue call triggers the event loop; 1269 std::cout << ""Number of processed entries: "" << resultPtr.GetValue() << std::endl;; 1270}; 1271~~~; 1272 ; 1273See the Book() method for more information and [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html); 1274for a more complete example.; 1275 ; 1276#### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(); 1277 ; 1278Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; 1279executes the callable on the values of those columns for each event that passes all upstream selections.; 1280It can be used to perform actions that are not already available in the interface. For example, the following snippet; 1281evaluates the root mean square of column ""x"":; 1282~~~{.cpp}; 1283// Single-thread evaluation of RMS of column ""x"" using Foreach; 1284double sumSq = 0.;; 1285unsigned int n = 0;; 1286df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; 1287std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1288~~~; 1289In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; 1290thread will execute the expression concurrently.; 1291The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; 1292this is probably too much head-scratch for such a simple operation.; 1293 ; 1294ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; 1295additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:74202,perform,perform,74202,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['perform'],['perform']
Performance,"adResults.end(), 0);; 1299 }; 1300 ; 1301 // Called by RDataFrame to retrieve the name of this action.; 1302 std::string GetActionName() const { return ""MyCounter""; }; 1303};; 1304 ; 1305int main() {; 1306 ROOT::RDataFrame df(10);; 1307 ROOT::RDF::RResultPtr<int> resultPtr = df.Book<>(MyCounter{df.GetNSlots()}, {});; 1308 // The GetValue call triggers the event loop; 1309 std::cout << ""Number of processed entries: "" << resultPtr.GetValue() << std::endl;; 1310}; 1311~~~; 1312 ; 1313See the Book() method for more information and [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html); 1314for a more complete example.; 1315 ; 1316#### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(); 1317 ; 1318Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; 1319executes the callable on the values of those columns for each event that passes all upstream selections.; 1320It can be used to perform actions that are not already available in the interface. For example, the following snippet; 1321evaluates the root mean square of column ""x"":; 1322~~~{.cpp}; 1323// Single-thread evaluation of RMS of column ""x"" using Foreach; 1324double sumSq = 0.;; 1325unsigned int n = 0;; 1326df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; 1327std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1328~~~; 1329In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; 1330thread will execute the expression concurrently.; 1331The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; 1332this is probably too much head-scratch for such a simple operation.; 1333 ; 1334ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; 1335additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:75882,perform,perform,75882,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['perform'],['perform']
Performance,"adStreamerInfo()If the streamerinfos are to be read at file opening.Definition TFile.cxx:3742; TFile::fArchiveTArchiveFile * fArchive!Archive file from which we read this fileDefinition TFile.h:97; TFile::SysSyncvirtual Int_t SysSync(Int_t fd)Interface to system fsync. All arguments like in POSIX fsync().Definition TFile.cxx:4552; TFile::DirCreateEntryvirtual Long64_t DirCreateEntry(TDirectory *)Definition TFile.h:167; TFile::ReOpenvirtual Int_t ReOpen(Option_t *mode)Reopen a file with a different access mode.Definition TFile.cxx:2162; TFile::ReadStreamerInfovirtual void ReadStreamerInfo()Read the list of StreamerInfo from this file.Definition TFile.cxx:3605; TFile::Matchesvirtual Bool_t Matches(const char *name)Return kTRUE if 'url' matches the coordinates of this file.Definition TFile.cxx:4766; TFile::IsBinaryBool_t IsBinary() constDefinition TFile.h:259; TFile::IsRawBool_t IsRaw() constDefinition TFile.h:260; TFile::SetCacheReadvirtual void SetCacheRead(TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect)Set a pointer to the read cache.Definition TFile.cxx:2365; TFile::fClassIndexTArrayC * fClassIndex!Index of TStreamerInfo classes written to this fileDefinition TFile.h:94; TFile::GetFileBytesWrittenstatic Long64_t GetFileBytesWritten()Static function returning the total number of bytes written to all files.Definition TFile.cxx:4583; TFile::GetStreamerInfoListImplvirtual InfoListRet GetStreamerInfoListImpl(bool lookupSICache)See documentation of GetStreamerInfoList for more details.Definition TFile.cxx:1376; TFile::kStartBigFile@ kStartBigFileDefinition TFile.h:200; TFile::GetCompressionSettingsInt_t GetCompressionSettings() constDefinition TFile.h:397; TFile::SetReadStreamerInfostatic void SetReadStreamerInfo(Bool_t readinfo=kTRUE)Specify if the streamerinfos must be read at file opening.Definition TFile.cxx:3732; TFile::fNoAnchorInNameBool_t fNoAnchorInName!True if we don't want to force the anchor to be appended to the file nameDefini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:29585,cache,cache,29585,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,2,['cache'],['cache']
Performance,"adTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:13129,cache,cacheDir,13129,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,2,['cache'],['cacheDir']
Performance,"addRealFull ; (; RooAbsReal * ; real). protected . Definition at line 1304 of file RooVectorDataStore.cxx. ◆ append(). void RooVectorDataStore::append ; (; RooAbsDataStore & ; other). overridevirtual . Implements RooAbsDataStore.; Definition at line 720 of file RooVectorDataStore.cxx. ◆ attachBuffers(). void RooVectorDataStore::attachBuffers ; (; const RooArgSet & ; extObs). overridevirtual . Implements RooAbsDataStore.; Definition at line 1041 of file RooVectorDataStore.cxx. ◆ attachCache(). void RooVectorDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). overridevirtual . Initialize cache of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ; Implements RooAbsDataStore.; Definition at line 982 of file RooVectorDataStore.cxx. ◆ cache(). const RooVectorDataStore * RooVectorDataStore::cache ; (; ); const. inline . Definition at line 171 of file RooVectorDataStore.h. ◆ cacheArgs(). void RooVectorDataStore::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; newVarSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = true . ). overridevirtual . Cache given RooAbsArgs: The tree is given direct write access of the args internal cache the args values is pre-calculated for all data points in this data collection. ; Upon a get() call, the internal cache of 'newVar' will be loaded with the precalculated value and it's dirty flag will be cleared. ; Implements RooAbsDataStore.; Definition at line 764 of file RooVectorDataStore.cxx. ◆ cacheOwner(). const RooAbsArg * RooVectorDataStore::cacheOwner ; (; ). inlineoverridevirtual . Implements RooAbsDataStore.; Definition at line 163 of file RooVectorDataStore.h. ◆ catStoreList(). std::vector< CatVector * > & RooVectorDataStore::catStoreList ; (; ). inline . Definition at line 542 of file RooVectorDataStore.h. ◆ changeObservableName(). bool RooVectorDataStore::changeObservableName ; (; const char * ; from, . const char * ; to . ). override",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:27098,cache,cacheArgs,27098,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,1,['cache'],['cacheArgs']
Performance,"aded. ;  ; void Unload (TEnum *e);  Mark enum 'e' as being unloaded. ;  ; void UnmapObject (TObject *obj);  Remove a pair<id, object> from the map of functions and their ids. ;  . Private Attributes; TClass * fClass;  ; TExMap * fIds;  Context of this list. Not owned. ;  ; Bool_t fIsLoaded;  Holder of TEnum for unloaded Enums. ;  ; ULong64_t fLastLoadMarker;  Mark whether Load was executed. ;  ; THashList * fUnloaded;  Map from DeclId_t to TEnum*. ;  . Friends; class TClass;  ; class TCling;  ; class TProtoClass;  ; class TROOT;  . Additional Inherited Members;  Protected Types inherited from TList; using TObjLinkPtr_t = std::shared_ptr< TObjLink >;  ; using TObjLinkWeakPtr_t = std::weak_ptr< TObjLink >;  ;  Protected Types inherited from TCollection; enum  EStatusBits { kIsOwner = (1ULL << ( 14 )); , kUseRWLock = (1ULL << ( 16 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Attributes inherited from THashList; THashTable * fTable;  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . #include <TListOfEnums.h>. Inheritance diagram for TListOfEnums:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ DeclId_t. typedef TDictionary::DeclId_t TListOfEnums::DeclId_t. Definition at line 59 of file TListOfEnums.h. Constructor & Destructor Documentation. ◆ TListOfEnums() [1/2]. TListOfEnums::TListOfEnums ; (; const TListOfEnums & ; ). privatedelete . Represent interpreter state when we last did a full load. . ◆ TListOfEnums() [2/2]. TListOfEnu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnums.html:22315,cache,cache,22315,doc/master/classTListOfEnums.html,https://root.cern,https://root.cern/doc/master/classTListOfEnums.html,1,['cache'],['cache']
Performance,"ader & operator= (const TTensorDataLoader &)=default;  ; TTensorDataLoader & operator= (TTensorDataLoader &&)=default;  ; template<typename RNG > ; void Shuffle (RNG &rng);  Shuffle the order of the samples in the batch. ;  . Private Types; using BatchIterator_t = TTensorBatchIterator< Data_t, Architecture_t >;  ; using DeviceBuffer_t = typename Architecture_t::DeviceBuffer_t;  ; using HostBuffer_t = typename Architecture_t::HostBuffer_t;  ; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Shape_t = typename Architecture_t::Tensor_t::Shape_t;  ; using Tensor_t = typename Architecture_t::Tensor_t;  . Private Attributes; size_t fBatchDepth;  The number of matrices in the tensor. ;  ; size_t fBatchHeight;  The number od rows in each matrix. ;  ; size_t fBatchIndex;  The index of the batch when there are multiple batches in parallel. ;  ; size_t fBatchSize;  The size of a batch. ;  ; size_t fBatchWidth;  The number of columns in each matrix. ;  ; const Data_t & fData;  The data that should be loaded in the batches. ;  ; std::vector< DeviceBuffer_t > fDeviceBuffers;  The device buffers used to keep the input, output and weight data. ;  ; std::vector< HostBuffer_t > fHostBuffers;  The host buffers used to load the input, output and weight data. ;  ; Shape_t fInputLayout;  The input data layout (does not include batch size) ;  ; size_t fNOutputFeatures;  The number of outputs from the classifier/regressor. ;  ; size_t fNSamples;  The total number of samples in the dataset. ;  ; size_t fNStreams;  Number of buffer pairs. ;  ; std::vector< size_t > fSampleIndices;  Ordering of the samples in the epoch. ;  . #include <TMVA/DNN/TensorDataLoader.h>; Member Typedef Documentation. ◆ BatchIterator_t. template<typename Data_t , typename Architecture_t > . using TMVA::DNN::TTensorDataLoader< Data_t, Architecture_t >::BatchIterator_t = TTensorBatchIterator<Data_t, Architecture_t>. private . Definition at line 140 of file TensorDataLoader.h. ◆ DeviceBuffer_t. template<typen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TTensorDataLoader.html:7569,load,loaded,7569,doc/master/classTMVA_1_1DNN_1_1TTensorDataLoader.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TTensorDataLoader.html,1,['load'],['loaded']
Performance,"ader viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimize",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCacheElement.html:923,cache,cacheList,923,root/html528/RooAbsCacheElement.html,https://root.cern,https://root.cern/root/html528/RooAbsCacheElement.html,3,['cache'],['cacheList']
Performance,"ader.h:161; TTreeReader::kEntryValid@ kEntryValiddata read okayDefinition TTreeReader.h:153; TTreeReader::fSetEntryBaseCallingLoadTreebool fSetEntryBaseCallingLoadTreeTrue if during the LoadTree execution triggered by SetEntryBase.Definition TTreeReader.h:338; TTreeReader::fValuesstd::deque< ROOT::Internal::TTreeReaderValueBase * > fValuesreaders that use our directorDefinition TTreeReader.h:327; TTreeReader::RegisterValueReaderbool RegisterValueReader(ROOT::Internal::TTreeReaderValueBase *reader)Add a value reader for this tree.Definition TTreeReader.cxx:858; TTreeReader::fTreeTTree * fTreetree that's readDefinition TTreeReader.h:318; TTreeReader::fWarnAboutLongerFriendsbool fWarnAboutLongerFriendsDefinition TTreeReader.h:345; TTreeReader::GetTreeTTree * GetTree() constDefinition TTreeReader.h:207; TTreeReader::endIterator_t end()Return an iterator beyond the last TTree entry.Definition TTreeReader.h:270; TTreeReader::SetEntriesRangeEEntryStatus SetEntriesRange(Long64_t beginEntry, Long64_t endEntry)Set the range of entries to be loaded by Next(); end will not be loaded.Definition TTreeReader.cxx:533; TTreeReader::SetEntryBaseEEntryStatus SetEntryBase(Long64_t entry, bool local)Load an entry into the tree, return the status of the read.Definition TTreeReader.cxx:630; TTreeReader::GetProxyKeystd::string GetProxyKey(const char *branchname)Definition TTreeReader.h:304; TTreeReader::WarnIfFriendsHaveMoreEntriesvoid WarnIfFriendsHaveMoreEntries()Definition TTreeReader.cxx:440; TTreeReader::GetEntryStatusEEntryStatus GetEntryStatus() constDefinition TTreeReader.h:249; TTreeReader::ELoadTreeStatusELoadTreeStatusDefinition TTreeReader.h:167; TTreeReader::kInternalLoadTree@ kInternalLoadTreeNotify/LoadTree was last called from SetEntryBase.Definition TTreeReader.h:170; TTreeReader::kMissingBranchFromTree@ kMissingBranchFromTreeMissing expected branch when loading new tree.Definition TTreeReader.h:172; TTreeReader::kNoTree@ kNoTreedefault state, no TTree is connected (formerl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReader_8h_source.html:23388,load,loaded,23388,doc/master/TTreeReader_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html,2,['load'],['loaded']
Performance,"ader_len = 0;; 12482 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12483 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12484 len = buf[1] & 127;; 12485 mask_len = (buf[1] & 128) ? 4 : 0;; 12486 if ((len < 126) && (body_len >= mask_len)) {; 12487 /* inline 7-bit length field */; 12488 data_len = len;; 12489 header_len = 2 + mask_len;; 12490 } else if ((len == 126) && (body_len >= (4 + mask_len))) {; 12491 /* 16-bit length field */; 12492 header_len = 4 + mask_len;; 12493 data_len = ((((size_t)buf[2]) << 8) + buf[3]);; 12494 } else if (body_len >= (10 + mask_len)) {; 12495 /* 64-bit length field */; 12496 uint32_t l1, l2;; 12497 memcpy(&l1, &buf[2], 4); /* Use memcpy for alignment */; 12498 memcpy(&l2, &buf[6], 4);; 12499 header_len = 10 + mask_len;; 12500 data_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);; 12501 ; 12502 if (data_len > (uint64_t)0x7FFF0000ul) {; 12503 /* no can do */; 12504 mg_cry_internal(; 12505 conn,; 12506 ""%s"",; 12507 ""websocket out of memory; closing connection"");; 12508 break;; 12509 }; 12510 }; 12511 }; 12512 ; 12513 if ((header_len > 0) && (body_len >= header_len)) {; 12514 /* Allocate space to hold websocket payload */; 12515 unsigned char *data = mem;; 12516 ; 12517 if ((size_t)data_len > (size_t)sizeof(mem)) {; 12518 data = (unsigned char *)mg_malloc_ctx((size_t)data_len,; 12519 conn->phys_ctx);; 12520 if (data == NULL) {; 12521 /* Allocation failed, exit the loop and then close the; 12522 * connection */; 12523 mg_cry_internal(; 12524 conn,; 12525 ""%s"",; 12526 ""websocket out of memory; closing connection"");; 12527 break;; 12528 }; 12529 }; 12530 ; 12531 /* Copy the mask before we shift the queue and destroy it */; 12532 if (mask_len > 0) {; 12533 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12534 } else {; 12535 memset(mask, 0, sizeof(mask));; 12536 }; 12537 ; 12538 /* Read frame payload from the first message in the queue into; 12539 * data and advance the queue by moving the memory in place.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:363868,queue,queue,363868,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,3,['queue'],['queue']
Performance,"ader_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1] & 128) ? 4 : 0;; 12487 if ((len < 126) && (body_len >= mask_len)) {; 12488 /* inline 7-bit length field */; 12489 data_len = len;; 12490 header_len = 2 + mask_len;; 12491 } else if ((len == 126) && (body_len >= (4 + mask_len))) {; 12492 /* 16-bit length field */; 12493 header_len = 4 + mask_len;; 12494 data_len = ((((size_t)buf[2]) << 8) + buf[3]);; 12495 } else if (body_len >= (10 + mask_len)) {; 12496 /* 64-bit length field */; 12497 uint32_t l1, l2;; 12498 memcpy(&l1, &buf[2], 4); /* Use memcpy for alignment */; 12499 memcpy(&l2, &buf[6], 4);; 12500 header_len = 10 + mask_len;; 12501 data_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);; 12502 ; 12503 if (data_len > (uint64_t)0x7FFF0000ul) {; 12504 /* no can do */; 12505 mg_cry_internal(; 12506 conn,; 12507 ""%s"",; 12508 ""websocket out of memory; closing connection"");; 12509 break;; 12510 }; 12511 }; 12512 }; 12513 ; 12514 if ((header_len > 0) && (body_len >= header_len)) {; 12515 /* Allocate space to hold websocket payload */; 12516 unsigned char *data = mem;; 12517 ; 12518 if ((size_t)data_len > (size_t)sizeof(mem)) {; 12519 data = (unsigned char *)mg_malloc_ctx((size_t)data_len,; 12520 conn->phys_ctx);; 12521 if (data == NULL) {; 12522 /* Allocation failed, exit the loop and then close the; 12523 * connection */; 12524 mg_cry_internal(; 12525 conn,; 12526 ""%s"",; 12527 ""websocket out of memory; closing connection"");; 12528 break;; 12529 }; 12530 }; 12531 ; 12532 /* Copy the mask before we shift the queue and destroy it */; 12533 if (mask_len > 0) {; 12534 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12535 } else {; 12536 memset(mask, 0, sizeof(mask));; 12537 }; 12538 ; 12539 /* Read frame payload from the first message in the queue into; 12540 * data and advance the queue by moving the memory in place.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:363901,queue,queue,363901,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,3,['queue'],['queue']
Performance,"ading = kReservedLoading; };  ; typedef std::atomic< std::map< std::string, TObjArray * > * > ConvSIMap_t;  Persistent address of pointer to this TClass object and its successors. ;  ; enum class  ERuntimeProperties : UChar_t { kNotInitialized = 0; , kSet = (1ULL << ( 0 )); , kConsistentHash = (1ULL << ( 1 )); };  Indicates whether GetClassVersion has been called. More...;  ; enum  EStreamerType { ;   kDefault =0; , kEmulatedStreamer =1; , kTObject =2; , kInstrumented =4; , ;   kForeign =8; , kExternal =16. };  ; typedef std::multimap< void *, Version_t > RepoCont_t;  ; typedef void(* StreamerImpl_t) (const TClass *pThis, void *obj, TBuffer &b, const TClass *onfile_class);  Schema evolution rules. ;  . Private Member Functions;  TClass (const TClass &tc)=delete;  ; Bool_t CanSplitBaseAllow ();  Pointer to the function implementing streaming for this class. ;  ; TList * CreateListOfDataMembers (std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load);  Create the list containing the TDataMembers (of actual data members or members pulled in through using declarations) of a class. ;  ; TVirtualStreamerInfo * DetermineCurrentStreamerInfo ();  Determine and set pointer to current TVirtualStreamerInfo. ;  ; TMethod * FindClassOrBaseMethodWithId (DeclId_t faddr);  Find a method with decl id in this class or its bases. ;  ; Int_t GetBaseClassOffsetRecurse (const TClass *toBase);  Return data member offset to the base class ""cl"". ;  ; TMethod * GetClassMethod (Longptr_t faddr);  Look for a method in this class that has the interface function address faddr. ;  ; TListOfFunctions * GetMethodList ();  Return (create an empty one if needed) the list of functions. ;  ; TVirtualStreamerInfo * GetStreamerInfoImpl (Int_t version, Bool_t silent) const;  ; void Init (const char *name, Version_t cversion, const std::type_info *info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il, ClassInfo_t *classInfo, Bool_t silent)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:39494,load,load,39494,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,2,['load'],['load']
Performance,"ading if it is globally off.; 4188 autoload = autoload && IsClassAutoLoadingEnabled();; 4189 ; 4190 // Avoid the double search below in case the name is a fundamental type; 4191 // or typedef to a fundamental type.; 4192 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 4193 TDataType *fundType = (TDataType *)typeTable->THashTable::FindObject( name );; 4194 ; 4195 if (fundType && fundType->GetType() < TVirtualStreamerInfo::kObject; 4196 && fundType->GetType() > 0) {; 4197 // Fundamental type, no a class.; 4198 return kUnknown;; 4199 }; 4200 ; 4201 // Migrated from within TClass::GetClass; 4202 // If we want to know if a class or a namespace with this name exists in the; 4203 // interpreter and this is an enum in the type system, before or after loading; 4204 // according to the autoload function argument, return kUnknown.; 4205 if (isClassOrNamespaceOnly && TEnum::GetEnum(name, autoload ? TEnum::kAutoload : TEnum::kNone)); 4206 return kUnknown;; 4207 ; 4208 const char *classname = name;; 4209 ; 4210 // RAII to suspend and restore auto-loading and auto-parsing based on some external conditions.; 4211 class MaybeSuspendAutoLoadParse {; 4212 int fStoreAutoLoad = 0;; 4213 int fStoreAutoParse = 0;; 4214 bool fSuspendedAutoParse = false;; 4215 public:; 4216 MaybeSuspendAutoLoadParse(int autoload) {; 4217 fStoreAutoLoad = ((TCling*)gCling)->SetClassAutoLoading(autoload);; 4218 }; 4219 ; 4220 void SuspendAutoParsing() {; 4221 fSuspendedAutoParse = true;; 4222 fStoreAutoParse = ((TCling*)gCling)->SetSuspendAutoParsing(true);; 4223 }; 4224 ; 4225 ~MaybeSuspendAutoLoadParse() {; 4226 if (fSuspendedAutoParse); 4227 ((TCling*)gCling)->SetSuspendAutoParsing(fStoreAutoParse);; 4228 ((TCling*)gCling)->SetClassAutoLoading(fStoreAutoLoad);; 4229 }; 4230 };; 4231 ; 4232 MaybeSuspendAutoLoadParse autoLoadParseRAII( autoload );; 4233 if (TClassEdit::IsStdPair(classname) || TClassEdit::IsStdPairBase(classname)); 4234 autoLoadParseRAII.SuspendAutoParsing();; 42",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:163337,load,loading,163337,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loading']
Performance,"ading...; Searching...; No Matches. List of all members |; Classes |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; RooProduct Class ReferenceRooFit » RooFit Core. ; Represents the product of a given set of RooAbsReal objects. ; Definition at line 29 of file RooProduct.h. Classes; class  CacheElem;  ; class  ProdMap;  . Public Member Functions;  RooProduct ();  Default constructor. ;  ;  RooProduct (const char *name, const char *title, const RooArgList &prodSet);  Construct function representing the product of functions in prodSet. ;  ;  RooProduct (const char *name, const char *title, RooAbsReal &real1, RooAbsReal &real2);  ;  RooProduct (const RooProduct &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooProduct () override;  Destructor. ;  ; void addTerm (RooAbsArg *term);  Add a term to this product. ;  ; double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const override;  Calculate integral internally from appropriate partial integral cache. ;  ; std::list< double > * binBoundaries (RooAbsRealLValue &, double, double) const override;  Forward the plot sampling hint from the p.d.f. that defines the observable obs. ;  ; CacheMode canNodeBeCached () const override;  ; const RooArgList & categoricalComponents () const;  ; TObject * clone (const char *newname) const override;  ; RooArgList components ();  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force internal handling of integration of given observable if any of the product terms depend on it. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Declare that we handle all integrations internally. ;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  Tests if the distribution is binned. Unless overridden by derived classes, t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProduct.html:1157,cache,cache,1157,doc/master/classRooProduct.html,https://root.cern,https://root.cern/doc/master/classRooProduct.html,1,['cache'],['cache']
Performance,"admin sniff->Restrict(""/CmdReset"",""allow=admin"");; Or fully hide command from guest account sniff->Restrict(""/CmdRebin"",""hidden=guest""); . Definition at line 466 of file TRootSniffer.cxx. ◆ ScanCollection(). void TRootSniffer::ScanCollection ; (; TRootSnifferScanRec & ; rec, . TCollection * ; lst, . const char * ; foldername = nullptr, . TCollection * ; keys_lst = nullptr . ). protected . Scan collection content. ; Definition at line 776 of file TRootSniffer.cxx. ◆ ScanHierarchy(). void TRootSniffer::ScanHierarchy ; (; const char * ; topname, . const char * ; path, . TRootSnifferStore * ; store, . Bool_t ; only_fields = kFALSE . ). Method scans normal objects, registered in ROOT. ; scan ROOT hierarchy with provided store object ; Definition at line 1001 of file TRootSniffer.cxx. ◆ ScanKeyProperties(). void TRootSniffer::ScanKeyProperties ; (; TRootSnifferScanRec & ; rec, . TKey * ; key, . TObject *& ; obj, . TClass *& ; obj_class . ). protectedvirtual . Scans TKey properties in special cases load objects from the file. ; Reimplemented in TRootSnifferFull.; Definition at line 741 of file TRootSniffer.cxx. ◆ ScanObjectChilds(). void TRootSniffer::ScanObjectChilds ; (; TRootSnifferScanRec & ; rec, . TObject * ; obj . ). protectedvirtual . scans object childs (if any) here one scans collection, branches, trees and so on ; Reimplemented in TRootSnifferFull.; Definition at line 761 of file TRootSniffer.cxx. ◆ ScanObjectMembers(). void TRootSniffer::ScanObjectMembers ; (; TRootSnifferScanRec & ; rec, . TClass * ; cl, . char * ; ptr . ). protected . scan object data members some members like enum or static members will be excluded ; Definition at line 608 of file TRootSniffer.cxx. ◆ ScanObjectProperties(). void TRootSniffer::ScanObjectProperties ; (; TRootSnifferScanRec & ; rec, . TObject * ; obj . ). protectedvirtual . Scans object properties here such fields as _autoload or _icon properties depending on class or object name could be assigned By default properties, coded in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootSniffer.html:36901,load,load,36901,doc/master/classTRootSniffer.html,https://root.cern,https://root.cern/doc/master/classTRootSniffer.html,1,['load'],['load']
Performance,"aframe tutorials. Detailed Description; Use the Aggregate action to specify arbitrary data aggregations. ; This tutorial shows how to use the Aggregate action to evaluate the product of all the elements of a column. This operation may be performed using a Reduce action, however aggregate is used for the sake of the tutorial; ; void df023_aggregate(); {; ; // Column to be aggregated; const std::string columnName = ""x"";; ; ROOT::EnableImplicitMT(2);; auto rdf = ROOT::RDataFrame(5);; auto d = rdf.Define(columnName, ""rdfentry_ + 1."");; ; // Aggregator function. It receives an accumulator (acc) and a column value (x). The variable acc is shared among the; // calls, so the function has to specify how the value has to be aggregated in the accumulator.; auto aggregator = [](double acc, double x) { return acc * x; };; ; // If multithread is enabled, the aggregator function will be called by more threads and will produce a vector of; // partial accumulators. The merger function performs the final aggregation of these partial results.; auto merger = [](std::vector<double> &accumulators) {; auto size = accumulators.size();; for (int i = 1; i < size; ++i) {; accumulators[0] *= accumulators[i];; }; };; ; // The accumulator is initialized at this value by every thread.; double initValue = 1.;; ; // Multiplies all elements of the column ""x""; auto result = d.Aggregate(aggregator, merger, columnName, initValue);; ; std::cout << *result << std::endl;; }; d#define d(i)Definition RSha256.hxx:102; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df023__aggregate_8C.html:1173,perform,performs,1173,doc/master/df023__aggregate_8C.html,https://root.cern,https://root.cern/doc/master/df023__aggregate_8C.html,1,['perform'],['performs']
Performance,"after the directory was written once,...Definition TDirectory.cxx:1287; TDirectory::fUUIDTUUID fUUIDDefinition TDirectory.h:143; TDirectory::fListTList * fListDefinition TDirectory.h:142; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TFileCacheReadA cache when reading files over the network.Definition TFileCacheRead.h:22; TFileCacheRead::ReadBuffervirtual Int_t ReadBuffer(char *buf, Long64_t pos, Int_t len)Read buffer at position pos.Definition TFileCacheRead.cxx:364; TFileCacheRead::Closevirtual void Close(Option_t *option="""")Close out any threads or asynchronous fetches used by the underlying implementation.Definition TFileCacheRead.cxx:189; TFileCacheRead::GetBufferSizevirtual Int_t GetBufferSize() constDefinition TFileCacheRead.h:88; TFileCacheRead::GetFileTFile * GetFile() constDefinition TFileCacheRead.h:92; TFileCacheRead::SetFilevirtual void SetFile(TFile *file, TFile::ECacheAction action=TFile::kDisconnect)Set the file using this cache and reset the current blocks (if any).Definition TFileCacheRead.cxx:545; TFileCacheWriteA cache when writing files over the network.Definition TFileCacheWrite.h:19; TFileCacheWrite::Flushvirtual Bool_t Flush()Flush the current write buffer to the file.Definition TFileCacheWrite.cxx:79; TFileCacheWrite::ReadBuffervirtual Int_t ReadBuffer(char *buf, Long64_t pos, Int_t len)Called by the read cache to check if the requested data is not in the write cache buffer.Definition TFileCacheWrite.cxx:108; TFileCacheWrite::GetBytesInCachevirtual Int_t GetBytesInCache() constDefinition TFileCacheWrite.h:38; TFileCacheWrite::WriteBuffervirtual Int_t WriteBuffer(const char *buf, Long64_t pos, Int_t len)Write buffer at position pos in the write buffer.Definition TFileCacheWrite.cxx:121; TFileOpenHandleClass holding info about the file being opened.Definition TFile.h:354; TFileOpenHandle::fFileTFile * fFileTFile instance of the file being opened.Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:208844,cache,cache,208844,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"ag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedPdf(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedPdf(const RooAbsCachedPdf& other, const char* name = 0); Copy constructor. ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedPdf.html:47592,cache,cache,47592,root/html602/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html,2,['cache'],['cache']
Performance,ag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_effFuncEfficiency modeling function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooEfficiency.html:37308,cache,cache,37308,root/html526/RooEfficiency.html,https://root.cern,https://root.cern/root/html526/RooEfficiency.html,1,['cache'],['cache']
Performance,ag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_effFuncEfficiency modeling function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Pr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooEfficiency.html:37690,cache,cache,37690,root/html528/RooEfficiency.html,https://root.cern,https://root.cern/root/html528/RooEfficiency.html,3,['cache'],['cache']
Performance,ag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooArgSet*_curNormSet! Current normalization set; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; TVectorD*_mref; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfItr!; RooListProxy_pdfList; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMomentMorph.html:37542,cache,cache,37542,root/html526/RooMomentMorph.html,https://root.cern,https://root.cern/root/html526/RooMomentMorph.html,1,['cache'],['cache']
Performance,ag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooArgSet*_curNormSet! Current normalization set; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; TVectorD*_mref; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfItr!; RooListProxy_pdfList; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum o,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMomentMorph.html:37924,cache,cache,37924,root/html528/RooMomentMorph.html,https://root.cern,https://root.cern/root/html528/RooMomentMorph.html,3,['cache'],['cache']
Performance,"ag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,unsigned int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction2Binding_double_unsigned_int_double_.html:33315,cache,cache,33315,root/html530/RooCFunction2Binding_double_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html530/RooCFunction2Binding_double_unsigned_int_double_.html,1,['cache'],['cache']
Performance,"ag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void GetFileName (const char *filename, TString &fn, bool *=nullptr);  To be able to re-localize the entry-list we identify the file by just the name and the anchor, i.e. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TObjArray * fBlocks;  blocks with indices of passing events (TEntryListBlocks) ;  ; TEntryList * fCurrent;  ! currently filled entry list ;  ; TDirectory * fDirectory;  ! Pointer to directory holding this tree ;  ; Long64_t fEntriesToProcess;  used on proof to set the number of entries to process in a packet ;  ; TString fFileName;  name of the file, where the tree is ;  ; Long64_t fLastIndexQueried;  ! used to optimize GetEntry() function from a loop ;  ; Long64_t fLastIndexReturned;  ! used to optimize GetEntry() function from a loop ;  ; TList * fLists;  a list of underlying entry lists for each tree of a chain ;  ; Long64_t fN;  number of entries in the list ;  ; Int_t fNBlocks;  number of TEntryListBlocks ;  ; bool fReapply;  If true, TTree::Draw will 'reapply' the original cut. ;  ; bool fShift;  ! true when some sub-lists don't correspond to trees (when the entry list is used as input in TChain) ;  ; ULong_t fStringHash;  ! Hash value of a string of treename and filename ;  ; TString fTreeName;  name of the tree ;  ; Int_t fTreeNumber;  ! the index of the tree in the chain (used when the entry list is used as input (TTree::SetEntryList()) ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; TEntryList & operator= (const TEntryList &);  . Friends; TEntryList operator|| (TEntryList &elist1, TEntryLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryList.html:23664,optimiz,optimize,23664,doc/master/classTEntryList.html,https://root.cern,https://root.cern/doc/master/classTEntryList.html,2,['optimiz'],['optimize']
Performance,"ag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  ;  Static Public Member Functions inherited from RooAbsLValue; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy cache of another RooAbsArg to our cache. ;  ; bool fitRangeOKForPlotting () const;  Check if fit range is usable as plot range, i.e. ;  ; virtual void setValFast (double value);  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; virtual double evaluate () const =0;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsRealLValue.html:55993,cache,cache,55993,doc/master/classRooAbsRealLValue.html,https://root.cern,https://root.cern/doc/master/classRooAbsRealLValue.html,2,['cache'],['cache']
Performance,"age of unique_ptr<THttpServer> ; Definition at line 273 of file RWebWindowsManager.cxx. ◆ ~RWebWindowsManager(). RWebWindowsManager::~RWebWindowsManager ; (; ). window manager destructor Required here for correct usage of unique_ptr<THttpServer> ; Definition at line 287 of file RWebWindowsManager.cxx. Member Function Documentation. ◆ AddServerLocation(). void RWebWindowsManager::AddServerLocation ; (; const std::string & ; server_prefix, . const std::string & ; files_path . ). static . Configure server location which can be used for loading of custom scripts or files When THttpServer instance of RWebWindowsManager will be created, THttpServer::AddLocation() method with correspondent arguments will be invoked. ; Definition at line 178 of file RWebWindowsManager.cxx. ◆ AssignMainThrd(). void RWebWindowsManager::AssignMainThrd ; (; ). static . Re-assigns main thread id Normally main thread id recognized at the moment when library is loaded It supposed to be a thread where gApplication->Run() will be called If application runs in separate thread, one have to call this method to let RWebWindowsManager correctly recognize such situation. ; Definition at line 117 of file RWebWindowsManager.cxx. ◆ ClearServerLocations(). void RWebWindowsManager::ClearServerLocations ; (; ). static . Clear all server locations Does not change configuration of already running HTTP server. ; Definition at line 239 of file RWebWindowsManager.cxx. ◆ CreateServer(). bool RWebWindowsManager::CreateServer ; (; bool ; with_http = false). private . Creates http server, if required - with real http engine (civetweb) One could configure concrete HTTP port, which should be used for the server, provide following entry in rootrc file: ; WebGui.HttpPort: 8088; or specify range of http ports, which can be used: WebGui.HttpPortMin: 8800; WebGui.HttpPortMax: 9800; By default range [8800..9800] is used; One also can bind HTTP server socket to loopback address, In that case only connection from localhost will be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html:8274,load,loaded,8274,doc/master/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html,1,['load'],['loaded']
Performance,"age. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; If specified, enables packages only on the specified workers.; Returns 0 in case of success and -1 in case of error.; Provided for backward compatibility. Int_t EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify options for the loading step via 'loadopts';; the string will be passed passed as argument to SETUP.; Special option 'chkv=<o>' (or 'checkversion=<o>') can be used to control; plugin version checking during building: possible choices are:; off no check; failure may occur at loading; on check ROOT version [default]; svn check ROOT version and SVN revision number.; (Use ';', ' ' or '|' to separate 'chkv=<o>' from the rest.); If specified, enables packages only on the specified workers.; Returns 0 in case of success and -1 in case of error. Int_t EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify a list of objects to be passed to the SETUP; functions via 'loadopts'; the objects must be streamable.; Returns 0 in case of success and -1 in case of error. Int_t DownloadPackage(const char* par, const char* dstdir = 0); Download a PROOF archive (PAR file) from the master package repository.; The PAR fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:75023,load,loading,75023,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['load'],['loading']
Performance,"ager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization; TGeoManager::GetCurrentNodeIdInt_t GetCurrentNodeId() constGet the unique ID of the current node.Definition TGeoManager.cxx:1663; TGeoManager::CdNodevoid CdNode(Int_t nodeid)Change current path to point to the node having this id.Definition TGeoManager.cxx:1655; ptTPaveText * ptDefinition entrylist_figure1.C:7. Current global transformation. This represents the transformation from MARS to the local reference of the current node, being the product of all local mother-daughter transformations in the branch. The global transformation can be referenced or copied:. const TGeoHMatrix *global = gGeoManager->GetCurrentMatrix();; TGeoHMatrix *copy = new TGeoHMatrix(*global);; TGeoManager::GetCurrentMatrixTGeoHMatrix * GetCurrentMatrix() constDefinition TGeoManager.h:496. One often needs to perform master-to-local and local-to-master point and vector conversions to get from MARS to the local node coordinates. This can be done by using the global transformation or directly the **TGeoManager** corresponding interfaces:. Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; TGeoManager::MasterToLocalvoid MasterToLocal(const Double_t *master, Double_t *local) constDefinition TGeoManager.h:538. Saving and Restoring the Current State; As we already described, saving and restoring modeller states can be quite useful during tracking and is a feature extensively used by external tracking engines. We will call this navigation history management, which in most of the cases can be performed by handling the state identifiers. For quite big geometries, state indexing is not possible anymore",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:78027,perform,perform,78027,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['perform']
Performance,"ager::fUniqueVolumesTObjArray * fUniqueVolumesDefinition TGeoManager.h:129; TGeoManager::fgExportPrecisionstatic UInt_t fgExportPrecisionMaximum number of Xtru vertices.Definition TGeoManager.h:55; TGeoManager::fRegionsTObjArray * fRegionsDefinition TGeoManager.h:109; TGeoManager::Nodevoid Node(const char *name, Int_t nr, const char *mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t *upar, Int_t npar=0)Create a node called <name_nr> pointing to the volume called <name> as daughter of the volume called ...Definition TGeoManager.cxx:1353; TGeoManager::fGShapesTObjArray * fGShapesDefinition TGeoManager.h:97; TGeoManager::fPaintVolumeTGeoVolume * fPaintVolumeDefinition TGeoManager.h:134; TGeoManager::PopPointBool_t PopPoint(Int_t index)Definition TGeoManager.h:596; TGeoManager::GetSkinSurfaceTGeoSkinSurface * GetSkinSurface(const char *name) constGet skin surface with a given name;.Definition TGeoManager.cxx:2041; TGeoManager::UpdateElementsvoid UpdateElements()Update element flags when geometry is loaded from a file.Definition TGeoManager.cxx:4167; TGeoManager::TGeoManagerTGeoManager()Default constructor.Definition TGeoManager.cxx:311; TGeoManager::fPropertiesConstPropMap_t fPropertiesDefinition TGeoManager.h:149; TGeoManager::MakeTubeTGeoVolume * MakeTube(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoManager.cxx:3204; TGeoManager::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoManager.cxx:1681; TGeoManager::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoManager.cxx:1098; TGeoManager::fMaterialsTList * fMaterialsDefinition TGeoManager.h:105; TGeoManager::GetNmanyInt_t GetNmany() constDefinition TGeoManager.h:195; TGeoManager::CheckBoundaryErrorsvoid CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.)Check pushes and pulls needed to cross the ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8h_source.html:46144,load,loaded,46144,doc/master/TGeoManager_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html,1,['load'],['loaded']
Performance,"ager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxysigmaL; RooRealProxysigmaR; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBifurGauss.html:39139,cache,cache,39139,root/html528/RooBifurGauss.html,https://root.cern,https://root.cern/root/html528/RooBifurGauss.html,2,['cache'],['cache']
Performance,"agerFile.cxx. ◆ Class(). static TClass * TDataSetManagerFile::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDataSetManagerFile::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDataSetManagerFile::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 100 of file TDataSetManagerFile.h. ◆ ClearCache(). Int_t TDataSetManagerFile::ClearCache ; (; const char * ; uri = 0). overridevirtual . Clear cached information matching uri. ; Reimplemented from TDataSetManager.; Definition at line 1253 of file TDataSetManagerFile.cxx. ◆ CreateLsFile(). Int_t TDataSetManagerFile::CreateLsFile ; (; const char * ; group, . const char * ; user, . Long_t & ; mtime, . TString & ; checksum . ). protected . Create or recreate the dataset lists for 'uri'. ; The list are saved in text form in 'uri'/ls.txt for fast browsing and in 'uri'/ls.root in form of TMacro for optimized and portable transfer. Return 0 on success, 1 if the file was empty, -1 on error ; Definition at line 474 of file TDataSetManagerFile.cxx. ◆ DeclFileName(). static const char * TDataSetManagerFile::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 100 of file TDataSetManagerFile.h. ◆ ExistsDataSet() [1/2]. Bool_t TDataSetManagerFile::ExistsDataSet ; (; const char * ; group, . const char * ; user, . const char * ; dsName . ). protected . Checks if the indicated dataset exits. ; Definition at line 1576 of file TDataSetManagerFile.cxx. ◆ ExistsDataSet() [2/2]. Bool_t TDataSetManagerFile::ExistsDataSet ; (; const char * ; uri). overridevirtual . Checks if the indicated dataset exits. ; Reimplemented from TDataSetManager.; Definition at line 1947 of file TDataSetManagerFile.cxx. ◆ FillLsDataSet(). Int_t TDataSetManagerFile::FillLsDataSet ; (; const char * ; group, . const char * ; user, . const char * ; dsname, . TList *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManagerFile.html:23917,optimiz,optimized,23917,doc/master/classTDataSetManagerFile.html,https://root.cern,https://root.cern/doc/master/classTDataSetManagerFile.html,1,['optimiz'],['optimized']
Performance,ahead buffer. ; Definition at line 31 of file TFileCacheRead.h. ◆ fEnablePrefetching. Bool_t TFileCacheRead::fEnablePrefetching. protected . reading by prefetching asynchronously ; Definition at line 37 of file TFileCacheRead.h. ◆ fFile. TFile* TFileCacheRead::fFile. protected . Pointer to file. ; Definition at line 51 of file TFileCacheRead.h. ◆ fIsSorted. Bool_t TFileCacheRead::fIsSorted. protected . True if fSeek array is sorted. ; Definition at line 53 of file TFileCacheRead.h. ◆ fIsTransferred. Bool_t TFileCacheRead::fIsTransferred. protected . True when fBuffer contains something valid. ; Definition at line 54 of file TFileCacheRead.h. ◆ fLen. Int_t* TFileCacheRead::fLen. protected . [fNb] Length of long buffers ; Definition at line 50 of file TFileCacheRead.h. ◆ fNb. Int_t TFileCacheRead::fNb. protected . Number of long buffers. ; Definition at line 41 of file TFileCacheRead.h. ◆ fNoCacheBytesRead. Long64_t TFileCacheRead::fNoCacheBytesRead. protected . Number of bytes read by basket to fill cached tree. ; Definition at line 33 of file TFileCacheRead.h. ◆ fNoCacheReadCalls. Int_t TFileCacheRead::fNoCacheReadCalls. protected . Number of read calls by basket to fill cached tree. ; Definition at line 34 of file TFileCacheRead.h. ◆ fNseek. Int_t TFileCacheRead::fNseek. protected . Number of blocks to be prefetched. ; Definition at line 39 of file TFileCacheRead.h. ◆ fNtot. Int_t TFileCacheRead::fNtot. protected . Total size of prefetched blocks. ; Definition at line 40 of file TFileCacheRead.h. ◆ fPos. Long64_t* TFileCacheRead::fPos. protected . [fNb] start of long buffers ; Definition at line 46 of file TFileCacheRead.h. ◆ fPrefetch. TFilePrefetch* TFileCacheRead::fPrefetch. protected . ! Object that does the asynchronous reading in another thread ; Definition at line 25 of file TFileCacheRead.h. ◆ fPrefetchedBlocks. Long64_t TFileCacheRead::fPrefetchedBlocks. protected . Number of blocks prefetched. ; Definition at line 55 of file TFileCacheRead.h. ◆ fReadCalls,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheRead.html:29444,cache,cached,29444,doc/master/classTFileCacheRead.html,https://root.cern,https://root.cern/doc/master/classTFileCacheRead.html,1,['cache'],['cached']
Performance,"ained only to variable parameters. int CovMatrixStatus() const. return the status of the covariance matrix. double Correlation(unsigned int i, unsigned int j) const. return correlation coefficient between variable i and j.; If the variable is fixed or const the return value is zero. double GlobalCC(unsigned int i) const. get global correlation coefficient for the variable i. This is a number between zero and one which gives; the correlation between the i-th variable and that linear combination of all other variables which; is most strongly correlated with i.; If the variable is fixed or const the return value is zero. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0). get the minos error for parameter i, return false if Minos failed; A minimizaiton must be performed befre, return false if no minimization has been done; In case of Minos failed the status error is updated as following; status += 10 * minosStatus where the minos status is:; status = 1 : maximum number of function calls exceeded when running for lower error; status = 2 : maximum number of function calls exceeded when running for upper error; status = 3 : new minimum found when running for lower error; status = 4 : new minimum found when running for upper error; status = 5 : any other failure. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0). scan a parameter i around the minimum. A minimization must have been done before,; return false if it is not the case. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. bool Hesse(). perform a full calculation of the Hessian matrix for error calculation; If a valid minimum exists the calculation is done on the minimum point otherwise is performed; in the current set values of parameters; S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Minuit2__Minuit2Minimizer.html:9293,perform,performed,9293,root/html526/ROOT__Minuit2__Minuit2Minimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Minuit2__Minuit2Minimizer.html,2,['perform'],['performed']
Performance,"ainer::HandleCrossing ; (; Event_t * ; ev). inlineoverridevirtual . Reimplemented from TGCompositeFrame.; Definition at line 247 of file TRootCanvas.cxx. ◆ HandleDoubleClick(). Bool_t TRootContainer::HandleDoubleClick ; (; Event_t * ; ev). inlineoverridevirtual . Reimplemented from TGCompositeFrame.; Definition at line 236 of file TRootCanvas.cxx. ◆ HandleExpose(). Bool_t TRootContainer::HandleExpose ; (; Event_t * ; ev). inlineoverridevirtual . Reimplemented from TGWindow.; Definition at line 245 of file TRootCanvas.cxx. ◆ HandleKey(). Bool_t TRootContainer::HandleKey ; (; Event_t * ; ev). inlineoverridevirtual . Reimplemented from TGCompositeFrame.; Definition at line 241 of file TRootCanvas.cxx. ◆ HandleMotion(). Bool_t TRootContainer::HandleMotion ; (; Event_t * ; ev). inlineoverridevirtual . Reimplemented from TGCompositeFrame.; Definition at line 243 of file TRootCanvas.cxx. ◆ SavePrimitive(). void TRootContainer::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; = """" . ). overridevirtual . Save a canvas container as a C++ statement(s) on output stream out. ; Reimplemented from TGCompositeFrame.; Definition at line 2093 of file TRootCanvas.cxx. ◆ SetEditable(). void TRootContainer::SetEditable ; (; Bool_t ; on). inlineoverridevirtual . Switch ON/OFF edit mode. ; If edit mode is ON it is possible:. embed other ROOT GUI application (a la ActiveX). For example: TGMainFrame *m = new TGMainFrame(gClient->GetRoot(), 500, 500); m->SetEditable(); gSystem->Load(""$ROOTSYS/test/Aclock""); // load Aclock demo Aclock a; gROOT->Macro(""$ROOTSYS/tutorials/gui/guitest.C""); m->SetEditable(0); m->MapWindow(); ; Reimplemented from TGCompositeFrame.; Definition at line 250 of file TRootCanvas.cxx. Member Data Documentation. ◆ fCanvas. TRootCanvas* TRootContainer::fCanvas. private . Definition at line 231 of file TRootCanvas.cxx. gui/gui/src/TRootCanvas.cxx. TRootContainer. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:23 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootContainer.html:32559,load,load,32559,doc/master/classTRootContainer.html,https://root.cern,https://root.cern/doc/master/classTRootContainer.html,1,['load'],['load']
Performance,"ainerKey (Event_t *ev);  Handle keyboard events in the canvas container. ;  ; Bool_t HandleContainerMotion (Event_t *ev);  Handle mouse motion event in the canvas container. ;  ; Bool_t HandleDNDDrop (TDNDData *data) override;  Handle drop events. ;  ; Atom_t HandleDNDEnter (Atom_t *typelist) override;  Handle drag enter events. ;  ; Bool_t HandleDNDLeave () override;  Handle drag leave events. ;  ; Atom_t HandleDNDPosition (Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot) override;  Handle dragging position events. ;  ; TRootCanvas & operator= (const TRootCanvas &)=delete;  . Private Attributes; Bool_t fAutoFit;  when true canvas container keeps same size as canvas ;  ; Int_t fButton;  currently pressed button ;  ; TRootContainer * fCanvasContainer;  container in canvas widget ;  ; Int_t fCanvasID;  index in fWindows array of TGX11 ;  ; TGLayoutHints * fCanvasLayout;  layout for canvas widget ;  ; TGCanvas * fCanvasWindow;  canvas widget ;  ; TGLayoutHints * fDockLayout;  layout hints for dockable frame widget ;  ; TGPopupMenu * fEditClearMenu;  clear cascade submenu ;  ; TGPopupMenu * fEditMenu;  edit menu ;  ; TVirtualPadEditor * fEditor;  pointer to currently loaded pad editor ;  ; TGCompositeFrame * fEditorFrame;  side frame for current pad editor ;  ; TGLayoutHints * fEditorLayout;  layout for editor frame ;  ; Bool_t fEmbedded;  true if embedded in any other frame (e.g. in the browser) ;  ; TGPopupMenu * fFileMenu;  file menu ;  ; TGPopupMenu * fFileSaveMenu;  save cascade submenu ;  ; TGPopupMenu * fHelpMenu;  help menu ;  ; TGHorizontal3DLine * fHorizontal1;  toolbar separator ;  ; TGLayoutHints * fHorizontal1Layout;  layout hints for separator ;  ; const TGPicture * fIconPic;  icon picture ;  ; TGCompositeFrame * fMainFrame;  main frame containing canvas and side frame ;  ; TGLayoutHints * fMainFrameLayout;  layout for main frame ;  ; TGMenuBar * fMenuBar;  menubar ;  ; TGLayoutHints * fMenuBarHelpLayout;  layout hint for help menu in menubar ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootCanvas.html:32624,load,loaded,32624,doc/master/classTRootCanvas.html,https://root.cern,https://root.cern/doc/master/classTRootCanvas.html,1,['load'],['loaded']
Performance,"aining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedPdf.html:40352,cache,cache,40352,root/html526/RooCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooCachedPdf.html,2,['cache'],['cache']
Performance,"ainingEvent (Long64_t ievt) const;  ; virtual const std::vector< Float_t > & GetTrainingHistory (const char *);  ; UInt_t GetTrainingROOTVersionCode () const;  ; TString GetTrainingROOTVersionString () const;  calculates the ROOT version string from the training version code on the fly ;  ; UInt_t GetTrainingTMVAVersionCode () const;  ; TString GetTrainingTMVAVersionString () const;  calculates the TMVA version string from the training version code on the fly ;  ; Double_t GetTrainTime () const;  ; TransformationHandler & GetTransformationHandler (Bool_t takeReroutedIfAvailable=true);  ; const TransformationHandler & GetTransformationHandler (Bool_t takeReroutedIfAvailable=true) const;  ; TString GetWeightFileName () const;  retrieve weight file name ;  ; Double_t GetXmax (Int_t ivar) const;  ; Double_t GetXmin (Int_t ivar) const;  ; Bool_t HasMVAPdfs () const;  ; virtual void Init ()=0;  ; void InitIPythonInteractive ();  ; virtual TClass * IsA () const;  ; Bool_t IsModelPersistence () const;  ; virtual Bool_t IsSignalLike ();  uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation) for a quick determination if an event would be selected as signal or background ;  ; virtual Bool_t IsSignalLike (Double_t mvaVal);  uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation) for a quick determination if an event with this mva output value would be selected as signal or background ;  ; Bool_t IsSilentFile () const;  ; virtual void MakeClass (const TString &classFileName=TString("""")) const;  create reader class for method (classification only at present) ;  ; TDirectory * MethodBaseDir () const;  returns the ROOT directory where all instances of the corresponding MVA method are stored ;  ; virtual std::map< TString, Double_t > OptimizeTuningParameters (TString fomType=""ROCIntegral"", TString fitType=""FitGA"");  call the Optimizer with the set of parameters and ranges that are meant to be tuned.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBase.html:9910,tune,tuned,9910,doc/master/classTMVA_1_1MethodBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBase.html,1,['tune'],['tuned']
Performance,"aint volume. void PrintVoxels() const; Print the voxels for this volume. void ReplayCreation(const TGeoVolume* other); Recreate the content of the other volume without pointer copying. Voxels are; ignored and supposed to be created in a later step via Voxelize. void PrintNodes() const; print nodes. TH2F * LegoPlot(Int_t ntheta = 20, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 60, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RegisterYourself(Option_t* option = """"); Register the volume and all materials/media/matrices/shapes to the manager. void RandomPoints(Int_t npoints = 1000000, Option_t* option = """"); Draw random points in the bounding box of this volume. void RandomRays(Int_t nrays = 10000, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0); Random raytracing method. void Raytrace(Bool_t flag = kTRUE); Draw this volume with current settings and perform raytracing in the pad. void SaveAs(const char* filename, Option_t* option = """") const; Save geometry having this as top volume as a C++ macro. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void UnmarkSaved(); Reset SavePrimitive bits. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this volume. TGeoNode * FindNode(const char* name) const; search a daughter inside the list of nodes. Int_t GetNodeIndex(const TGeoNode* node, Int_t* check_list, Int_t ncheck) const; Get the index of a daugther within check_list by providing the node pointer. Int_t GetIndex(const TGeoNode* node) const; get index number for a given daughter. char * GetObjectInfo(Int_t px, Int_t py) const; Get volume info for the browser. Bool_t GetOptimalVoxels() const; --- Returns true if cylindrical voxelization is optimal. char * GetPointerName() const; Provide a pointer name containing ui",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoVolume.html:27601,perform,perform,27601,root/html528/TGeoVolume.html,https://root.cern,https://root.cern/root/html528/TGeoVolume.html,3,['perform'],['perform']
Performance,"aits::CallableTraits<std::decay_t<F>>::ret_type> ; auto ROOT::RDF::Not (F &&f) -> decltype(RDFInternal::NotHelper(Args(), std::forward< F >(f)));  Given a callable with signature bool(T1, T2, ...) return a callable with same signature that returns the negated result. ;  ; template<typename... ArgTypes, typename F > ; std::function< bool(ArgTypes...)> ROOT::Internal::RDF::NotHelper (ROOT::TypeTraits::TypeList< ArgTypes... >, F &&f);  ; template<typename... ArgTypes, typename Ret , typename... Args> ; std::function< bool(ArgTypes...)> ROOT::Internal::RDF::NotHelper (ROOT::TypeTraits::TypeList< ArgTypes... >, Ret(*f)(Args...));  ; template<std::size_t N, typename T , typename F > ; auto ROOT::Internal::RDF::PassAsVec (F &&f) -> PassAsVecHelper< std::make_index_sequence< N >, T, F >;  ; template<std::size_t N, typename T , typename F > ; auto ROOT::RDF::PassAsVec (F &&f) -> RDFInternal::PassAsVecHelper< std::make_index_sequence< N >, T, F >;  PassAsVec is a callable generator that allows passing N variables of type T to a function as a single collection. ;  ; unsigned int ROOT::RDF::RunGraphs (std::vector< RResultHandle > handles);  Trigger the event loop of multiple RDataFrames concurrently. ;  ; template<typename NodeType > ; std::string ROOT::RDF::SaveGraph (NodeType node);  Create a graphviz representation of the dataframe computation graph, return it as a string. ;  ; template<typename NodeType > ; void ROOT::RDF::SaveGraph (NodeType node, const std::string &outputFile);  Create a graphviz representation of the dataframe computation graph, write it to the specified file. ;  ; template<typename T > ; RResultMap< T > ROOT::RDF::Experimental::VariationsFor (RResultPtr< T > resPtr);  Produce all required systematic variations for the given result. ;  ; SnapshotPtr_t ROOT::RDF::Experimental::VariationsFor (SnapshotPtr_t resPtr);  . treedataframeincROOTRDFHelpers.hxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:26 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx.html:3163,concurren,concurrently,3163,doc/master/RDFHelpers_8hxx.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx.html,1,['concurren'],['concurrently']
Performance,"al (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,int>funcFunction pointer reference; RooRealProxyxArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction1PdfBinding_double_int_.html:38789,cache,cache,38789,root/html526/RooCFunction1PdfBinding_double_int_.html,https://root.cern,https://root.cern/root/html526/RooCFunction1PdfBinding_double_int_.html,2,['cache'],['cache']
Performance,"al . Reimplemented in RooCachedReal, and RooNumRunningInt.; Definition at line 93 of file RooAbsCachedReal.h. ◆ selfNormalized(). virtual bool RooAbsCachedReal::selfNormalized ; (; ); const. inlinevirtual . Definition at line 32 of file RooAbsCachedReal.h. ◆ setInterpolationOrder(). void RooAbsCachedReal::setInterpolationOrder ; (; Int_t ; order). Set interpolation order of RooHistFunct representing cache histogram. ; Definition at line 254 of file RooAbsCachedReal.cxx. ◆ Streamer(). void RooAbsCachedReal::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in RooCachedReal, RooNumCdf, and RooNumRunningInt. ◆ StreamerNVirtual(). void RooAbsCachedReal::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 120 of file RooAbsCachedReal.h. Friends And Related Symbol Documentation. ◆ FuncCacheElem. friend class FuncCacheElem. friend . Definition at line 95 of file RooAbsCachedReal.h. Member Data Documentation. ◆ _anaIntMap. std::map<Int_t,std::pair<const RooArgSet*,const RooArgSet*> > RooAbsCachedReal::_anaIntMap. mutableprotected . ! Map for analytical integration codes ; Definition at line 113 of file RooAbsCachedReal.h. ◆ _cacheMgr. RooObjCacheManager RooAbsCachedReal::_cacheMgr. mutableprotected . ! The cache manager ; Definition at line 106 of file RooAbsCachedReal.h. ◆ _disableCache. bool RooAbsCachedReal::_disableCache. private . Definition at line 118 of file RooAbsCachedReal.h. ◆ _ipOrder. Int_t RooAbsCachedReal::_ipOrder. protected . Interpolation order for cache histograms. ; Definition at line 109 of file RooAbsCachedReal.h. Libraries for RooAbsCachedReal:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooAbsCachedReal.h; roofit/roofitcore/src/RooAbsCachedReal.cxx. RooAbsCachedReal. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:39 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedReal.html:68854,cache,cache,68854,doc/master/classRooAbsCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedReal.html,2,['cache'],['cache']
Performance,"al Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual TStringoperator TString(); virtual RooAbsArg&operator=(const char* newValue); Bool_tRooAbsString::operator==(const char*) const; virtual Bool_tRooAbsString::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStringVar.html:9341,optimiz,optimizeCacheMode,9341,root/html526/RooStringVar.html,https://root.cern,https://root.cern/root/html526/RooStringVar.html,1,['optimiz'],['optimizeCacheMode']
Performance,"al Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual TStringoperator TString(); virtual RooAbsArg&operator=(const char* newValue); Bool_tRooAbsString::operator==(const char*) const; virtual Bool_tRooAbsString::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStringVar.html:9456,optimiz,optimizeCacheMode,9456,root/html528/RooStringVar.html,https://root.cern,https://root.cern/root/html528/RooStringVar.html,1,['optimiz'],['optimizeCacheMode']
Performance,"al EAclicMode GetAclicMode () const;  AclicMode indicates whether the library should be built in debug mode or optimized. ;  ; virtual Int_t GetAclicProperties () const;  Return the ACLiC properties field. ;  ; void GetBeepDefaults (Int_t &freq, Int_t &duration) const;  ; virtual const char * GetBuildArch () const;  Return the build architecture. ;  ; virtual const char * GetBuildCompiler () const;  Return the build compiler. ;  ; virtual const char * GetBuildCompilerVersion () const;  Return the build compiler version. ;  ; virtual const char * GetBuildCompilerVersionStr () const;  Return the build compiler version identifier string. ;  ; virtual const char * GetBuildDir () const;  Return the path of the build directory. ;  ; virtual const char * GetBuildNode () const;  Return the build node name. ;  ; virtual void * GetDirPtr () const;  ; const char * GetErrorStr () const;  ; virtual const char * GetFlagsDebug () const;  Return the debug flags. ;  ; virtual const char * GetFlagsOpt () const;  Return the optimization flags. ;  ; virtual TString GetFromPipe (const char *command);  Execute command and return output in TString. ;  ; virtual const char * GetIncludePath ();  Get the list of include path. ;  ; virtual const char * GetLinkdefSuffix () const;  Return the linkdef suffix chosen by the user for ACLiC. ;  ; virtual const char * GetLinkedLibs () const;  Return the list of library linked to this executable. ;  ; virtual TSeqCollection * GetListOfFileHandlers () const;  ; virtual TSeqCollection * GetListOfSignalHandlers () const;  ; virtual TSeqCollection * GetListOfStdExceptionHandlers () const;  ; virtual TList * GetListOfTimers () const;  ; virtual const char * GetMakeExe () const;  Return the command line use to make an executable. ;  ; virtual const char * GetMakeSharedLib () const;  Return the command line use to make a shared library. ;  ; virtual const char * GetObjExt () const;  Get the object file extension. ;  ; int GetPathInfo (const char *path, Long_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:16506,optimiz,optimization,16506,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['optimiz'],['optimization']
Performance,"al Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddModel.html:22852,optimiz,optimizeCacheMode,22852,root/html528/RooAddModel.html,https://root.cern,https://root.cern/root/html528/RooAddModel.html,8,['optimiz'],['optimizeCacheMode']
Performance,"al Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTNetFile::ReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTNetFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCastorFile.html:12959,cache,cacheDir,12959,root/html532/TCastorFile.html,https://root.cern,https://root.cern/root/html532/TCastorFile.html,1,['cache'],['cacheDir']
Performance,"al Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTWebFile::ReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTWebFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TAS3File.html:12334,cache,cacheDir,12334,root/html532/TAS3File.html,https://root.cern,https://root.cern/root/html532/TAS3File.html,2,['cache'],['cacheDir']
Performance,"al Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTWebFile::ReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTWebFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:13802,cache,cacheDir,13802,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,3,['cache'],['cacheDir']
Performance,"al TBasket * CreateBasket (TBranch *);  Create a basket for this tree and given branch. ;  ; Int_t Debug () const;  ; void Delete (Option_t *option="""") override;  Delete this tree from memory or/and disk. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Called by TKey and TObject::Clone to automatically add us to a directory when we are read from a file. ;  ; virtual Long64_t Draw (const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Draw expression varexp for entries and objects that pass a (optional) selection. ;  ; virtual Long64_t Draw (const char *varexp, const TCut &selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Draw expression varexp for specified entries. ;  ; void Draw (Option_t *opt) override;  Default Draw method for all objects. ;  ; virtual void DropBaskets ();  Remove some baskets from memory. ;  ; virtual Int_t DropBranchFromCache (const char *bname, bool subbranches=false);  Remove the branch with name 'bname' from the Tree cache. ;  ; virtual Int_t DropBranchFromCache (TBranch *branch, bool subbranches=false);  Remove the branch b from the Tree cache. ;  ; virtual void DropBuffers (Int_t nbytes);  Drop branch buffers to accommodate nbytes below MaxVirtualsize. ;  ; bool EnableCache ();  Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ;  ; virtual Int_t Fill ();  Fill all branches. ;  ; virtual TBranch * FindBranch (const char *name);  Return the branch that correspond to the path 'branchname', which can include the name of the tree or the omitted name of the parent branches. ;  ; virtual TLeaf * FindLeaf (const char *name);  Find leaf.. ;  ; virtual Int_t Fit (const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Option_t *goption="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Fit a projected item(s) from a tree. ;  ; virtual Int_t FlushBaske",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:25374,cache,cache,25374,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,3,['cache'],['cache']
Performance,"al TBasket * CreateBasket (TBranch *);  Create a basket for this tree and given branch. ;  ; Int_t Debug () const;  ; void Delete (Option_t *option="""") override;  Delete this tree from memory or/and disk. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Called by TKey and TObject::Clone to automatically add us to a directory when we are read from a file. ;  ; virtual Long64_t Draw (const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Draw expression varexp for entries and objects that pass a (optional) selection. ;  ; virtual Long64_t Draw (const char *varexp, const TCut &selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Draw expression varexp for specified entries. ;  ; void Draw (Option_t *opt) override;  Default Draw method for all objects. ;  ; virtual void DropBaskets ();  Remove some baskets from memory. ;  ; virtual Int_t DropBranchFromCache (const char *bname, bool subbranches=false);  Remove the branch with name 'bname' from the Tree cache. ;  ; virtual Int_t DropBranchFromCache (TBranch *branch, bool subbranches=false);  Remove the branch b from the Tree cache. ;  ; virtual void DropBuffers (Int_t nbytes);  Drop branch buffers to accommodate nbytes below MaxVirtualsize. ;  ; bool EnableCache ();  Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ;  ; virtual TBranch * FindBranch (const char *name);  Return the branch that correspond to the path 'branchname', which can include the name of the tree or the omitted name of the parent branches. ;  ; virtual TLeaf * FindLeaf (const char *name);  Find leaf.. ;  ; virtual Int_t Fit (const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Option_t *goption="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Fit a projected item(s) from a tree. ;  ; virtual Int_t FlushBaskets (bool create_cluster=true) const;  Write to d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNtuple.html:8239,cache,cache,8239,doc/master/classTNtuple.html,https://root.cern,https://root.cern/doc/master/classTNtuple.html,2,['cache'],['cache']
Performance,"al and background trees; ; **/; ; TString inputFileName = ""Higgs_data.root"";; TString inputFileLink = ""http://root.cern/files/"" + inputFileName;; ; TFile *inputFile = nullptr;; ; if (!gSystem->AccessPathName(inputFileName)) {; // file exists; inputFile = TFile::Open( inputFileName );; }; ; if (!inputFile) {; // download file from Cernbox location; Info(""TMVA_Higgs_Classification"",""Download Higgs_data.root file"");; TFile::SetCacheFileDir(""."");; inputFile = TFile::Open(inputFileLink, ""CACHEREAD"");; if (!inputFile) {; Error(""TMVA_Higgs_Classification"",""Input file cannot be downloaded - exit"");; return;; }; }; ; // --- Register the training and test trees; ; TTree *signalTree = (TTree*)inputFile->Get(""sig_tree"");; TTree *backgroundTree = (TTree*)inputFile->Get(""bkg_tree"");; ; signalTree->Print();; ; /***; ## Declare DataLoader(s); ; The next step is to declare the DataLoader class that deals with input variables; ; Define the input variables that shall be used for the MVA training; note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; ; ***/; ; TMVA::DataLoader * loader = new TMVA::DataLoader(""dataset"");; ; loader->AddVariable(""m_jj"");; loader->AddVariable(""m_jjj"");; loader->AddVariable(""m_lv"");; loader->AddVariable(""m_jlv"");; loader->AddVariable(""m_bb"");; loader->AddVariable(""m_wbb"");; loader->AddVariable(""m_wwbb"");; ; /// We set now the input data trees in the TMVA DataLoader class; ; // global event weights per tree (see below for setting event-wise weights); Double_t signalWeight = 1.0;; Double_t backgroundWeight = 1.0;; ; // You can add an arbitrary number of signal or background trees; loader->AddSignalTree ( signalTree, signalWeight );; loader->AddBackgroundTree( backgroundTree, backgroundWeight );; ; ; // Set individual event weights (the variables must exist in the original TTree); // for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; // for background: factory->SetBackgroundWeightExpression(""we",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:59887,load,loader,59887,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,8,['load'],['loader']
Performance,"al case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));. Of course, dynamic_cast<> can also be used in the example 1. void * GetObjectUnchecked(const char* namecycle); return pointer to object identified by namecycle.; The returned object may or may not derive from TObject. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY IMPORTANT NOTE:; The calling application must cast the returned object to; the final type, eg; MyClass *obj = (MyClass*)directory->GetObject(""some object of MyClass"");. void * GetObjectChecked(const char* namecycle, const char* classname); See documentation of TDirectoryFile::GetObjectCheck(const char *namecycle, const TClass *cl). void * GetObjectChecked(const char* namecycle, const TClass* cl); return pointer to object identified by namecycle if and only if the actual; object is a type suitable to be stored as a pointer to a ""expectedClass""; If expectedClass is null, no check is performed. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY IMPORTANT NOTE:; The calling application must cast the returned pointer to; the type described by the 2 arguments (i.e. cl):; MyClass *obj = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));. Note: We recommend using the method TDirectoryFile::GetObject:; MyClass *obj = 0;; directory->GetObject(""some object inheriting from MyClass"",obj);; if (obj) { ... we found what we are looking for ... }. Int_t GetBufferSize() const; Return the buffer size to create new TKeys.; If the stored fBufferSize is null, the value returned is the average; buffer size of objects in the file so far. TKey * GetKey(const char* name, Short_t cycle = 9999) const; -*-*-*Return pointer to key with name,cycle; *-* ======",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDirectoryFile.html:18238,perform,performed,18238,root/html528/TDirectoryFile.html,https://root.cern,https://root.cern/root/html528/TDirectoryFile.html,6,['perform'],['performed']
Performance,"al clone of input function; RooChi2Var::FuncMode_funcModeFunction, P.d.f. or extended p.d.f?; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooAbsData*RooAbsOptTestStatistic::_origDataOriginal data ; RooAbsReal*RooAbsOptTestStatistic::_origFuncOriginal function ; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooChi2Var.html:36279,cache,cache,36279,root/html532/RooChi2Var.html,https://root.cern,https://root.cern/root/html532/RooChi2Var.html,2,['cache'],['cache']
Performance,"al data structure see convention for numbering bins in TH1::GetBin. ;  ; virtual void SavePrimitiveHelp (std::ostream &out, const char *hname, Option_t *option="""");  Helper function for the SavePrimitive functions from TH1 or classes derived from TH1, eg TProfile, TProfile2D. ;  ; virtual void UpdateBinContent (Int_t bin, Double_t content);  Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static TH1D * DoProject1D (const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 1D histogram ;  ; static TH2D * DoProject2D (const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 2D histogram ;  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1, Int_t lastB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:52132,perform,performing,52132,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,2,['perform'],['performing']
Performance,"al for a more complete example.; Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(); Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and executes the callable on the values of those columns for each event that passes all upstream selections. It can be used to perform actions that are not already available in the interface. For example, the following snippet evaluates the root mean square of column ""x"": // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; nconst Int_t nDefinition legend1.C:16; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach(): thread will execute the expression concurrently. The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of rms; but this is probably too much head-scratch for such a simple operation.; ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame guarantees that ForeachSlot() will invoke the user expression with different slot parameters for different concurrent executions (see Special helper columns: rdfentry_ and rdfslot_ for more information on the slot parameter). We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"": // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; const unsigned int nSlots = df.GetNSlots();; std::vector<double> sumSqs(nSlots, 0.);; std::vector<unsigned int> ns(nSlots, 0);; ; df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; double sumSq = std::accumulate(sumSqs.be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:68415,concurren,concurrent,68415,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['concurren'],['concurrent']
Performance,"al function interface provide interface for calculating each data contrinution to the function which is required by some algorithm (like Fumili) ;  CBasicMinimizerBase Minimizer class, which defines the basic funcionality of various minimizer implementations (apart from Minuit and Minuit2) It provides support for storing parameter values, step size, parameter transofrmation etc ;  CBinaryOpBinaryOperation class A class representing binary operators in the parse tree ;  CBinaryOpCopyLBinary Operation class with value storage for the left argument ;  CBinaryOpCopyRBinary Operation class with value storage for the right argument ;  CBoostLorentz boost class with the (4D) transformation represented internally by a 4x4 orthosymplectic matrix ;  CBoostXClass representing a Lorentz Boost along the X axis, by beta ;  CBoostYClass representing a Lorentz Boost along the Y axis, by beta ;  CBoostZClass representing a Lorentz Boost along the Z axis, by beta ;  CBrentMinimizer1DUser class for performing function minimization ;  CBrentRootFinderClass for finding the root of a one dimensional function using the Brent algorithm ;  CCartesian2DClass describing a 2D cartesian coordinate system (x, y coordinates) ;  CCartesian3DClass describing a 3D cartesian coordinate system (x, y, z coordinates) ;  CChebyshevApproxClass describing a Chebyshev series which can be used to approximate a function in a defined range [a,b] using Chebyshev polynomials ;  CChebyshevPol;  CCholeskyDecompClass to compute the Cholesky decomposition of a matrix ;  CCholeskyDecompGenDimClass to compute the Cholesky decomposition of a matrix ;  CCholInverter;  CCompileTimeChecker;  CCompileTimeChecker< false >;  CConstantConstant expression class A class representing constant expressions (literals) in the parse tree ;  CCoordinateTraits;  CCoordinateTraits< Cartesian3D< Scalar > >;  CCoordinateTraits< Cylindrical3D< Scalar > >;  CCoordinateTraits< CylindricalEta3D< Scalar > >;  CCoordinateTraits< Polar3D< Scalar ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:26487,perform,performing,26487,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,3,['perform'],['performing']
Performance,"al function interface provide interface for calculating each data contrinution to the function which is required by some algorithm (like Fumili) ;  CBasicMinimizerBase Minimizer class, which defines the basic funcionality of various minimizer implementations (apart from Minuit and Minuit2) It provides support for storing parameter values, step size, parameter transofrmation etc ;  CBinaryOpBinaryOperation class A class representing binary operators in the parse tree ;  CBinaryOpCopyLBinary Operation class with value storage for the left argument ;  CBinaryOpCopyRBinary Operation class with value storage for the right argument ;  CBoostLorentz boost class with the (4D) transformation represented internally by a 4x4 orthosymplectic matrix ;  CBoostXClass representing a Lorentz Boost along the X axis, by beta ;  CBoostYClass representing a Lorentz Boost along the Y axis, by beta ;  CBoostZClass representing a Lorentz Boost along the Z axis, by beta ;  CBrentMinimizer1DUser class for performing function minimization ;  CBrentRootFinderClass for finding the root of a one dimensional function using the Brent algorithm ;  CCartesian2DClass describing a 2D cartesian coordinate system (x, y coordinates) ;  CCartesian3DClass describing a 3D cartesian coordinate system (x, y, z coordinates) ;  CChebyshevApproxClass describing a Chebyshev series which can be used to approximate a function in a defined range [a,b] using Chebyshev polynomials ;  CChebyshevPol;  CCholeskyDecompClass to compute the Cholesky decomposition of a matrix ;  CCholeskyDecompGenDimClass to compute the Cholesky decomposition of a matrix ;  CCholInverter;  CCompileTimeChecker;  CCompileTimeChecker< false >;  CConstantConstant expression class A class representing constant expressions (literals) in the parse tree ;  CCylindrical3DClass describing a cylindrical coordinate system based on rho, z and phi ;  CCylindricalEta3DClass describing a cylindrical coordinate system based on eta (pseudorapidity) instead of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:33667,perform,performing,33667,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,4,['perform'],['performing']
Performance,"al in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLLogicalShape.html:6035,cache,cache,6035,root/html528/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html,6,['cache'],['cache']
Performance,"al integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,int>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction4Binding_double_double_double_double_int_.html:32651,cache,cache,32651,root/html526/RooCFunction4Binding_double_double_double_double_int_.html,https://root.cern,https://root.cern/root/html526/RooCFunction4Binding_double_double_double_double_int_.html,2,['cache'],['cache']
Performance,"al integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooRealProxy_offsetOffset of transformation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooRealProxy_slopeSlope of transformation; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooRealProxy_varInput observable; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooLinearVar.html:37619,cache,cache,37619,root/html530/RooLinearVar.html,https://root.cern,https://root.cern/root/html530/RooLinearVar.html,1,['cache'],['cache']
Performance,"al prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UpdateBranches (TTree *tree);  Update pointer to current Tree and recompute pointers to the branches in the cache. ;  ;  Publi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:15599,optimiz,optimize,15599,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['optimiz'],['optimize']
Performance,"al stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoParameterDerivative(double x, const double* p, unsigned int ipar) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ParameterGradient(const double * x , const double * p, double * grad ). Evaluate the all the derivatives (gradient vector) of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency. double ParameterDerivative(const double * x, const double * p, unsigned int ipar = 0). Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. return DoParameterDerivative(double x, const double* p, unsigned int ipar) const. void ParameterGradient(const double * x , double * grad ). Evaluate all derivatives using cached parameter values. return ParameterGradient(x, Parameters(), grad). double ParameterDerivative(const double * x, unsigned int ipar = 0). Evaluate partial derivative using cached parameter values. virtual ~IParametricGradFunctionOneDim(). Virtual Destructor (no operations). {}. void ParameterGradient(double x , const double * p, double * grad ). Evaluate the derivatives of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency if needed. double ParameterDerivative(double x, const double * p, unsigned int ipar = 0). Partial derivative with respect a parameter. double ParameterDerivative(double x, unsigned int ipar = 0). Evaluate partial derivative using cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 27272 2009-01-28 09:03:03Z moneta $ » Last generated: 2009-12-07 13:43",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IParametricGradFunctionOneDim.html:3214,cache,cached,3214,root/html526/ROOT__Math__IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IParametricGradFunctionOneDim.html,1,['cache'],['cached']
Performance,"al sum= 6.33125; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'val_loss', Entries= 0, Total sum= 6.20691; Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_PyKeras_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_BDTG.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: TMVA_LSTM for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0494 sec ; Factory : Test method: TMVA_DNN for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0212 sec ; Factory : Test method: PyKeras_LSTM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00597 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:45342,perform,performance,45342,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['perform'],['performance']
Performance,al table; Roo2DKeysPdf Two-dimensional kernel estimation p.d.f.; RooAICRegistry Registry for analytical integration codes; RooAbsAnaConvPdf Abstract Composite Convoluted PDF; RooAbsArg Abstract variable; RooAbsBinning Abstract base class for binning specification; RooAbsCache Base class for cache managers ; RooAbsCacheElement Base class for cache elements; RooAbsCachedPdf Abstract base class for cached p.d.f.s; RooAbsCachedReal Abstract base class for cached p.d.f.s; RooAbsCategory Abstract discrete variable; RooAbsCategoryLValue Abstract modifiable index variable ; RooAbsCollection Collection of RooAbsArg objects; RooAbsData Abstract data collection; RooAbsDataStore Abstract Data Storage class; RooAbsFunc Abstract real-valued function interface; RooAbsGenContext Abstract context for generating a dataset from a PDF; RooAbsHiddenReal Abstract hidden real-valued variable; RooAbsIntegrator Abstract interface for real-valued function integrators; RooAbsLValue Abstract variable; RooAbsMCStudyModule Monte Carlo study manager add-on module; RooAbsNumGenerator Abstract base class for numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract PDF with normalization support; RooAbsProxy Abstract proxy interface; RooAbsReal Abstract real-valued variable; RooAbsRealLValue Abstract modifiable real-valued object; RooAbsRootFinder Abstract interface for 1-dim real-valued function root finders; RooAbsSelfCachedPdf Abstract base class for self-caching p.d.f.s; RooAbsSelfCachedReal Abstract base class for self-caching functions; RooAbsString Abstract string-valued variable; RooAbsTestStatistic Abstract base class for real-valued test statistics; RooAcceptReject Context for generating a dataset from a PDF; RooAdaptiveGaussKronrodIntegrator1D 1-dimensional adaptive Gauss-Kronrod numerical integration engine; RooAdaptiveIntegratorND N-dimensional adaptive integration (interface to MathCore integrator); RooAddGenContex,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:24310,optimiz,optimized,24310,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['optimiz'],['optimized']
Performance,"al void SetReapplyCut(bool apply=false)Definition TEntryList.h:108; TEntryList::SetDirectoryvirtual void SetDirectory(TDirectory *dir)Add reference to directory dir. dir can be 0.Definition TEntryList.cxx:1170; TEntryList::GetEntryvirtual Long64_t GetEntry(Long64_t index)Return the number of the entry #index of this TEntryList in the TTree or TChain See also Next().Definition TEntryList.cxx:759; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TEventList<div class=""legacybox""><h2>Legacy Code</h2> TEventList is a legacy interface: there will be no bug fi...Definition TEventList.h:31; TEventList::GetEntryvirtual Long64_t GetEntry(Int_t index) constReturn value of entry at index in the list.Definition TEventList.cxx:227; TEventList::GetReapplyCutvirtual bool GetReapplyCut() constDefinition TEventList.h:57; TEventList::GetNvirtual Int_t GetN() constDefinition TEventList.h:56; TFileCacheReadA cache when reading files over the network.Definition TFileCacheRead.h:22; TFileCacheRead::WaitFinishPrefetchvirtual void WaitFinishPrefetch()Definition TFileCacheRead.cxx:691; TFileCacheRead::GetBufferSizevirtual Int_t GetBufferSize() constDefinition TFileCacheRead.h:88; TFileMergeInfoDefinition TFileMergeInfo.h:42; TFileMergeInfo::fIOFeaturesTIOFeatures * fIOFeaturesDefinition TFileMergeInfo.h:55; TFileMergeInfo::fIsFirstBool_t fIsFirstDefinition TFileMergeInfo.h:52; TFileMergeInfo::fOptionsTString fOptionsDefinition TFileMergeInfo.h:53; TFileMergeInfo::fOutputDirectoryTDirectory * fOutputDirectoryDefinition TFileMergeInfo.h:51; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::SetCacheReadvirtual void SetCacheRead(TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect)Set a pointer to the read cache.Definition TFile.cxx:2365; TFile::GetCompressionSettingsInt_t GetCompressionSettings(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:410937,cache,cache,410937,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"al voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TKey*TDirectory::FindKey(const char*) const; virtual TKey*TDirectory::FindKeyAny(const char*) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*FindObjectAnyFile(const char* name) const; const char*FindObjectClassName(const char* name) const; const char*FindObjectPathName(const TObject* obj) const; TObject*FindSpecialObject(const char* name, void*& where); TClass*FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; voidForceStyle(Bool_t force = kTRUE); Bool_tFromPopUp() const; virtual TObject*TDirectory::Get(const char* namecycle); TApplication*GetApplication() const; virtual Int_tTDirectory::GetBufferSize() const; Int_tGetBuiltDate() const; Int_tGetBuiltTime() const; TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; static const char**&GetExtraInterpreterArgs(); virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TFunctionTemplate*GetFunctionTemplate(const char* name); TObject*GetGeometry(const char* name) const; const char*GetGitBranch() const; const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:5042,load,load,5042,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['load'],['load']
Performance,"al voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TKey*TDirectory::FindKey(const char*) const; virtual TKey*TDirectory::FindKeyAny(const char*) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*FindObjectAnyFile(const char* name) const; const char*FindObjectClassName(const char* name) const; const char*FindObjectPathName(const TObject* obj) const; TObject*FindSpecialObject(const char* name, void*& where); TClass*FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; voidForceStyle(Bool_t force = kTRUE); Bool_tFromPopUp() const; virtual TObject*TDirectory::Get(const char* namecycle); TApplication*GetApplication() const; virtual Int_tTDirectory::GetBufferSize() const; Int_tGetBuiltDate() const; Int_tGetBuiltTime() const; TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TObject*GetGeometry(const char* name) const; TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TROOT.html:4912,load,load,4912,root/html530/TROOT.html,https://root.cern,https://root.cern/root/html530/TROOT.html,2,['load'],['load']
Performance,"al voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TKey*TDirectory::FindKey(const char*) const; virtual TKey*TDirectory::FindKeyAny(const char*) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*FindObjectAnyFile(const char* name) const; const char*FindObjectClassName(const char* name) const; const char*FindObjectPathName(const TObject* obj) const; TObject*FindSpecialObject(const char* name, void*& where); TClass*FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; voidForceStyle(Bool_t force = kTRUE); Bool_tFromPopUp() const; virtual TObject*TDirectory::Get(const char* namecycle); TApplication*GetApplication() const; virtual Int_tTDirectory::GetBufferSize() const; Int_tGetBuiltDate() const; Int_tGetBuiltTime() const; TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TObject*GetGeometry(const char* name) const; const char*GetGitBranch() const; const char*GetGitCommit() const; const char*GetGitDate(); TGlobal*GetGlobal(const char* name, Bool_t load = kFAL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TROOT.html:5046,load,load,5046,root/html534/TROOT.html,https://root.cern,https://root.cern/root/html534/TROOT.html,1,['load'],['load']
Performance,"al voidattachToTree(TTree& t, Int_t bufSize = 32000); virtual voidattachToVStore(RooVectorDataStore& vstore); TStringRooAbsArg::cleanBranchName() const; voidclearTypes(); virtual voidcopyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); const RooCatType*defineType(const char* label); const RooCatType*defineType(const char* label, Int_t index); const RooCatType*defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidfillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tisValid() const; virtual Bool_tisValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidsetTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidsyncCache(const RooArgSet* set = 0); RooCatTypetraceEval() const; virtual Bool_ttraceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCategory.html:17380,optimiz,optimizeDirtyHook,17380,root/html532/RooAbsCategory.html,https://root.cern,https://root.cern/root/html532/RooAbsCategory.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"al*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfClosedObjects() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory::GetListOfKeys() const; TSeqCollection*GetListOfMappedFiles() const; TSeqCollection*GetListOfMessageHandlers() const; TSeqCollection*GetListOfProofs() const; TSeqCollection*GetListOfSecContexts() const; TSeqCollection*GetListOfSockets() const; TSeqCollection*GetListOfSpecials() const; TSeqCollection*GetListOfStreamerInfo() const; TSeqCollection*GetListOfStyles() const; TSeqCollection*GetListOfTasks() const; TCollection*GetListOfTypes(Bool_t load = kFALSE); static const char*GetMacroPath(); virtual TObject*TDirectory::GetMother() const; virtual TDirectory*TDirectory::GetMotherDir() const; virtual const char*TNamed::GetName() const; virtual Int_tTDirectory::GetNbytesKeys() const; Int_tGetNclasses() const; virtual Int_tTDirectory::GetNkeys() const; Int_tGetNtypes() const; voidTDirectory::GetObject(const char* namecycle, void*& ptr); virtual void*TDirectory::GetObjectChecked(const char* namecycle, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TROOT.html:6838,load,load,6838,root/html530/TROOT.html,https://root.cern,https://root.cern/root/html530/TROOT.html,3,['load'],['load']
Performance,al*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooAbsReal*_funcInt! Function integral; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized ; RooNumIntConfig_intConfigNumeric integrator configuration for integration of function over bin; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_t_integrateIs integration over the bin volume requested; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealMPFE**RooAbsTestStatistic::_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplitRooAbsTestStatistic::_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_tRooAbsTestStatistic::_nCPUNumber of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooXYChi2Var.html:38531,cache,cache,38531,root/html534/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html534/RooXYChi2Var.html,1,['cache'],['cache']
Performance,"al*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxysigma; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGaussian.html:38535,cache,cache,38535,root/html526/RooGaussian.html,https://root.cern,https://root.cern/root/html526/RooGaussian.html,4,['cache'],['cache']
Performance,"al*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxywidth; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBreitWigner.html:38663,cache,cache,38663,root/html526/RooBreitWigner.html,https://root.cern,https://root.cern/root/html526/RooBreitWigner.html,2,['cache'],['cache']
Performance,"al*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; TIterator*_obsIter! Iterator over lowSet; RooListProxy_obsSetLow-side variation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; TIterator*_paramIter! Iterator over paramSet; RooListProxy_paramSetinterpolation parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooJeffreysPrior.html:42026,cache,cache,42026,root/html534/RooJeffreysPrior.html,https://root.cern,https://root.cern/root/html534/RooJeffreysPrior.html,1,['cache'],['cache']
Performance,"al*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; TIterator*_obsIter! Iterator over lowSet; RooListProxy_obsSetLow-side variation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; TIterator*_paramIter! Iterator over paramSet; RooListProxy_paramSetinterpolation parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooJeffreysPrior.html:43706,cache,cache,43706,root/html602/RooJeffreysPrior.html,https://root.cern,https://root.cern/root/html602/RooJeffreysPrior.html,2,['cache'],['cache']
Performance,"al, const char *receiver_class, void *receiver, const char *slot);  This method allows to make a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; virtual void DeletePlayer ();  Delete player instance. ;  ; virtual Int_t Fork ();  Fork a child. ;  ; Int_t GetSessionStatus ();  Return the status of this session: 0 idle 1 running 2 being terminated (currently unused) 3 queued 4 idle timed-out (not set in here but in TIdleTOTimer::Notify) This is typically run in the reader thread, so access needs to be protected. ;  ; virtual void HandleArchive (TMessage *mess, TString *slb=0);  Handle archive request. ;  ; virtual Int_t HandleCache (TMessage *mess, TString *slb=0);  Handle here all cache and package requests. ;  ; virtual void HandleCheckFile (TMessage *mess, TString *slb=0);  Handle file checking request. ;  ; virtual Int_t HandleDataSets (TMessage *mess, TString *slb=0);  Handle here requests about datasets. ;  ; virtual void HandleFork (TMessage *mess);  Cloning itself via fork. Not implemented. ;  ; virtual Int_t HandleLibIncPath (TMessage *mess);  Handle lib, inc search paths modification request. ;  ; virtual void HandleProcess (TMessage *mess, TString *slb=0);  Handle processing request. ;  ; virtual void HandleQueryList (TMessage *mess);  Handle request for list of queries. ;  ; virtual void HandleRemove (TMessage *mess, TString *slb=0);  Handle remov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:22975,queue,queued,22975,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['queue'],['queued']
Performance,"al. ~LikelihoodInterval(); Destructor. Bool_t IsInInterval(const RooArgSet& ) const; This is the main method to satisfy the RooStats::ConfInterval interface.; It returns true if the parameter point is in the interval. RooArgSet* GetParameters() const; returns list of parameters. Bool_t CheckParameters(const RooArgSet& ) const; check that the parameters are correct. Double_t LowerLimit(const RooRealVar& param, bool& status); Compute lower limit, check first if limit has been computed; status is a boolean flag which will b set to false in case of error; and is true if calculation is succesfull; in case of error return also a lower limit value of zero. Double_t UpperLimit(const RooRealVar& param, bool& status); Compute upper limit, check first if limit has been computed; status is a boolean flag which will b set to false in case of error; and is true if calculation is succesfull; in case of error return also a lower limit value of zero. void ResetLimits(); reset map with cached limits - called every time the test size or CL has been changed. bool CreateMinimizer(); internal function to create minimizer object needed to find contours or interval limits; (running MINOS).; Minimizer must be Minuit or Minuit2. bool FindLimits(const RooRealVar& param, double& lower, double& upper); Method to find both lower and upper limits using MINOS; If cached values exist (limits have been already found) return them in that case; check first if limit has been computed; otherwise compute limit using MINOS; in case of failure lower and upper will mantain previous value (will not be modified). Int_t GetContourPoints(const RooRealVar& paramX, const RooRealVar& paramY, Double_t* x, Double_t* y, Int_t npoints = 30); use Minuit to find the contour of the likelihood function at the desired CL. explicit LikelihoodInterval(const char* name = 0); defult constructor. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (e.g 0.682 for a 1-sigma interval). {fConfidenceLevel ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__LikelihoodInterval.html:9715,cache,cached,9715,root/html528/RooStats__LikelihoodInterval.html,https://root.cern,https://root.cern/root/html528/RooStats__LikelihoodInterval.html,3,['cache'],['cached']
Performance,"al. ~LikelihoodInterval(); Destructor. Bool_t IsInInterval(const RooArgSet& ) const; This is the main method to satisfy the RooStats::ConfInterval interface.; It returns true if the parameter point is in the interval. RooArgSet* GetParameters() const; returns list of parameters. Bool_t CheckParameters(const RooArgSet& ) const; check that the parameters are correct. Double_t LowerLimit(const RooRealVar& param, bool& status); Compute lower limit, check first if limit has been computed; status is a boolean flag which will b set to false in case of error; and is true if calculation is successful; in case of error return also a lower limit value of zero. Double_t UpperLimit(const RooRealVar& param, bool& status); Compute upper limit, check first if limit has been computed; status is a boolean flag which will b set to false in case of error; and is true if calculation is successful; in case of error return also a lower limit value of zero. void ResetLimits(); reset map with cached limits - called every time the test size or CL has been changed. bool CreateMinimizer(); internal function to create minimizer object needed to find contours or interval limits; (running MINOS).; Minimizer must be Minuit or Minuit2. bool FindLimits(const RooRealVar& param, double& lower, double& upper); Method to find both lower and upper limits using MINOS; If cached values exist (limits have been already found) return them in that case; check first if limit has been computed; otherwise compute limit using MINOS; in case of failure lower and upper will mantain previous value (will not be modified). Int_t GetContourPoints(const RooRealVar& paramX, const RooRealVar& paramY, Double_t* x, Double_t* y, Int_t npoints = 30); use Minuit to find the contour of the likelihood function at the desired CL. explicit LikelihoodInterval(const char* name = 0); default constructor. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (e.g 0.682 for a 1-sigma interval). {fConfidenceLevel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__LikelihoodInterval.html:9813,cache,cached,9813,root/html534/RooStats__LikelihoodInterval.html,https://root.cern,https://root.cern/root/html534/RooStats__LikelihoodInterval.html,3,['cache'],['cached']
Performance,al::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; RooListProxy_funcListList of component FUNCs; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoef; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normIntMgrThe integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this ob,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealSumPdf.html:38240,cache,cache,38240,root/html526/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html526/RooRealSumPdf.html,1,['cache'],['cache']
Performance,al::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; RooListProxy_funcListList of component FUNCs; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoef; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normIntMgrThe integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Ro,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealSumPdf.html:38622,cache,cache,38622,root/html528/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html528/RooRealSumPdf.html,1,['cache'],['cache']
Performance,al::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; RooListProxy_funcListList of component FUNCs; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoef; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normIntMgrThe integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealSumPdf.html:39091,cache,cache,39091,root/html530/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html530/RooRealSumPdf.html,1,['cache'],['cache']
Performance,"al::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to functions whose running integral is calculated; RooRealProxyxIntergrated observable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumRunningInt.html:33430,cache,cache,33430,root/html526/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html526/RooNumRunningInt.html,2,['cache'],['cache']
Performance,"al::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,int>funcFunction pointer reference; RooRealProxyxArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction1Binding_double_int_.html:33145,cache,cache,33145,root/html530/RooCFunction1Binding_double_int_.html,https://root.cern,https://root.cern/root/html530/RooCFunction1Binding_double_int_.html,1,['cache'],['cache']
Performance,"al::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_setset of terms to be summed; TIterator*_setIter! Iterator over set; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAddition(). RooAddition(const char* name, const char* title, const RooArgList& sumSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddition.html:34868,cache,cache,34868,root/html534/RooAddition.html,https://root.cern,https://root.cern/root/html534/RooAddition.html,2,['cache'],['cache']
Performance,"al::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAddPdf&operator=(const RooAddPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddPdf.html:24091,optimiz,optimizeCacheMode,24091,root/html602/RooAddPdf.html,https://root.cern,https://root.cern/root/html602/RooAddPdf.html,4,['optimiz'],['optimizeCacheMode']
Performance,"al::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooBDecay&operator=(const RooBDecay&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBDecay.html:23668,optimiz,optimizeCacheMode,23668,root/html602/RooBDecay.html,https://root.cern,https://root.cern/root/html602/RooBDecay.html,4,['optimiz'],['optimizeCacheMode']
Performance,"al::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooLandau&operator=(const RooLandau&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLandau.html:22817,optimiz,optimizeCacheMode,22817,root/html602/RooLandau.html,https://root.cern,https://root.cern/root/html602/RooLandau.html,4,['optimiz'],['optimizeCacheMode']
Performance,"al::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction4PdfBinding<double,double,double,double,bool>&operator=(const RooCFunction4PdfBinding<double,double,double,double,bool>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_bool_.html:23614,optimiz,optimizeCacheMode,23614,root/html602/RooCFunction4PdfBinding_double_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_bool_.html,4,['optimiz'],['optimizeCacheMode']
Performance,"al::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction1Binding<double,int>&operator=(const RooCFunction1Binding<double,int>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction1Binding_double_int_.html:19748,optimiz,optimizeCacheMode,19748,root/html602/RooCFunction1Binding_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction1Binding_double_int_.html,2,['optimiz'],['optimizeCacheMode']
Performance,"al::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsAnaConvPdf.html:32434,cache,cache,32434,root/html532/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsAnaConvPdf.html,9,['cache'],['cache']
Performance,al; kLess; kGreater; kLessThan; kGreaterThan; kNot; kcosh; ksinh; ktanh; kacosh; kasinh; katanh; kStringEqual; kStringNotEqual; kBitAnd; kBitOr; kLeftShift; kRightShift; kJumpIf; kJump; kexpo; kxexpo; kyexpo; kzexpo; kxyexpo; kgaus; kxgaus; kygaus; kzgaus; kxygaus; klandau; kxlandau; kylandau; kzlandau; kxylandau; kpol; kxpol; kypol; kzpol; kParameter; kConstant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TF1::fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*TF1::fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Double_tTF1::fChisquareFunction fit chisquare; void*TF1::fCintFunc! pointer to interpreted function class; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TArrayDTF2::fContourArray to display contour levels; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF3.html:22196,cache,cache,22196,root/html528/TF3.html,https://root.cern,https://root.cern/root/html528/TF3.html,4,['cache'],['cache']
Performance,al; kLess; kGreater; kLessThan; kGreaterThan; kNot; kcosh; ksinh; ktanh; kacosh; kasinh; katanh; kStringEqual; kStringNotEqual; kBitAnd; kBitOr; kLeftShift; kRightShift; kJumpIf; kJump; kexpo; kxexpo; kyexpo; kzexpo; kxyexpo; kgaus; kxgaus; kygaus; kzgaus; kxygaus; klandau; kxlandau; kylandau; kzlandau; kxylandau; kpol; kxpol; kypol; kzpol; kParameter; kConstant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TF1::fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*TF1::fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Double_tTF1::fChisquareFunction fit chisquare; void*TF1::fCintFunc! pointer to interpreted function class; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TArrayDfContourArray to display contour levels; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TOb,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF2.html:20055,cache,cache,20055,root/html528/TF2.html,https://root.cern,https://root.cern/root/html528/TF2.html,4,['cache'],['cache']
Performance,"al; kLess; kGreater; kLessThan; kGreaterThan; kNot; kcosh; ksinh; ktanh; kacosh; kasinh; katanh; kStringEqual; kStringNotEqual; kBitAnd; kBitOr; kLeftShift; kRightShift; kJumpIf; kJump; kexpo; kxexpo; kyexpo; kzexpo; kxyexpo; kgaus; kxgaus; kygaus; kzgaus; kxygaus; klandau; kxlandau; kylandau; kzlandau; kxylandau; kpol; kxpol; kypol; kzpol; kParameter; kConstant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TF1::fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*TF1::fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Int_tfCaseprojection along X(0), or Y(1); Double_tTF1::fChisquareFunction fit chisquare; void*TF1::fCintFunc! pointer to interpreted function class; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; TF2*fF2pointer to the mother TF2; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF12.html:18167,cache,cache,18167,root/html528/TF12.html,https://root.cern,https://root.cern/root/html528/TF12.html,4,['cache'],['cache']
Performance,"alContext & ; ctx); const. overrideprotectedvirtual . Compute multiple values of BifurGauss distribution. ; Reimplemented from RooAbsReal.; Definition at line 72 of file RooBifurGauss.cxx. ◆ evaluate(). double RooBifurGauss::evaluate ; (; ); const. overrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 58 of file RooBifurGauss.cxx. ◆ getAnalyticalIntegral(). Int_t RooBifurGauss::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 80 of file RooBifurGauss.cxx. ◆ IsA(). TClass * RooBifurGauss::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 49 of file RooBifurGauss.h. ◆ Streamer(). void RooBifurGauss::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooBifurGauss::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 49 of file RooBifurGauss.h. ◆ translate(). void RooBifurGauss::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from transl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBifurGauss.html:77083,perform,performed,77083,doc/master/classRooBifurGauss.html,https://root.cern,https://root.cern/doc/master/classRooBifurGauss.html,1,['perform'],['performed']
Performance,"alErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooConvCoefVar&operator=(const RooConvCoefVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConvCoefVar.html:19373,optimiz,optimizeCacheMode,19373,root/html602/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html602/RooConvCoefVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"alErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooFirstMoment&operator=(const RooFirstMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_tRooAbsMoment::order() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFirstMoment.html:19294,optimiz,optimizeCacheMode,19294,root/html602/RooFirstMoment.html,https://root.cern,https://root.cern/root/html602/RooFirstMoment.html,2,['optimiz'],['optimizeCacheMode']
Performance,"alErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooGenProdProj&operator=(const RooGenProdProj&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenProdProj.html:19524,optimiz,optimizeCacheMode,19524,root/html602/RooGenProdProj.html,https://root.cern,https://root.cern/root/html602/RooGenProdProj.html,2,['optimiz'],['optimizeCacheMode']
Performance,"alErrorIter(); static Bool_tRooAbsReal::evalErrorLoggingEnabled(); virtual Double_tevaluate() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooConvCoefVar.html:10563,cache,cacheList,10563,root/html526/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html526/RooConvCoefVar.html,2,['cache'],['cacheList']
Performance,"alErrorIter(); static Bool_tRooAbsReal::evalErrorLoggingEnabled(); virtual Double_tevaluate() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooPlot*RooAbsRealLValue::frame() const; RooPlot*RooAbsRealLValue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooErrorVar.html:11714,cache,cacheList,11714,root/html526/RooErrorVar.html,https://root.cern,https://root.cern/root/html526/RooErrorVar.html,1,['cache'],['cacheList']
Performance,"alIntegral to offer all our actual observable for internal integration. ; Reimplemented from RooAbsReal.; Definition at line 322 of file RooAbsCachedPdf.cxx. ◆ getAnalyticalIntegralWN(). int RooAbsCachedPdf::getAnalyticalIntegralWN ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Advertises internal (analytical) integration capabilities. ; Call is forwarded to RooHistPdf cache p.d.f of cache that is used for given choice of observables ; Reimplemented from RooAbsReal.; Definition at line 334 of file RooAbsCachedPdf.cxx. ◆ getCache(). RooAbsCachedPdf::PdfCacheElem * RooAbsCachedPdf::getCache ; (; const RooArgSet * ; nset, . bool ; recalculate = true . ); const. protected . Retrieve cache object associated with given choice of observables. ; If cache object does not exist, create and fill and register it on the fly. If recalculate=false recalculation of cache contents of existing caches that are marked dirty due to dependent parameter changes is suppressed. ; Definition at line 113 of file RooAbsCachedPdf.cxx. ◆ getCacheHist() [1/2]. RooDataHist * RooAbsCachedPdf::getCacheHist ; (; const RooArgSet & ; nset); const. inline . Definition at line 43 of file RooAbsCachedPdf.h. ◆ getCacheHist() [2/2]. RooDataHist * RooAbsCachedPdf::getCacheHist ; (; const RooArgSet * ; nset = nullptr); const. Return pointer to RooDataHist cache histogram for given choice of observables. ; Definition at line 100 of file RooAbsCachedPdf.cxx. ◆ getCachePdf() [1/2]. RooAbsPdf * RooAbsCachedPdf::getCachePdf ; (; const RooArgSet & ; nset); const. inline . Definition at line 39 of file RooAbsCachedPdf.h. ◆ getCachePdf() [2/2]. RooAbsPdf * RooAbsCachedPdf::getCachePdf ; (; const RooArgSet * ; nset = nullptr); const. Return pointer to RooHistPdf cache pdf for given choice of observables. ; Definition at line 90 of file RooAbsCachedPdf.cxx. ◆ getInterpolationOrder(). Int_t RooAbsCachedPdf::getInterp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:81708,cache,cache,81708,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,2,['cache'],"['cache', 'caches']"
Performance,"alIsAProxy* TClass::GetIsAProxy() const; 2956{; 2957 return fIsA;; 2958}; 2959 ; 2960////////////////////////////////////////////////////////////////////////////////; 2961/// Static method returning pointer to TClass of the specified class name.; 2962/// If load is true, an attempt is made to obtain the class by loading; 2963/// the appropriate shared library (directed by the rootmap file).; 2964/// If silent is 'true', do not warn about missing dictionary for the class.; 2965/// (typically used for classes that are used only for transient members); 2966/// Returns `nullptr` in case class is not found.; 2967 ; 2968TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent); 2969{; 2970 return TClass::GetClass(name, load, silent, 0, 0);; 2971}; 2972 ; 2973TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size); 2974{; 2975 if (!name || !name[0]) return nullptr;; 2976 ; 2977 if (strstr(name, ""(anonymous)"")) return nullptr;; 2978 if (strstr(name, ""(unnamed)"")) return nullptr;; 2979 if (strncmp(name,""class "",6)==0) name += 6;; 2980 if (strncmp(name,""struct "",7)==0) name += 7;; 2981 ; 2982 if (!gROOT->GetListOfClasses()) return nullptr;; 2983 ; 2984 // FindObject will take the read lock before actually getting the; 2985 // TClass pointer so we will need not get a partially initialized; 2986 // object.; 2987 TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2988 ; 2989 // Early return to release the lock without having to execute the; 2990 // long-ish normalization.; 2991 if (cl && (cl->IsLoaded() || cl->TestBit(kUnloading))) return cl;; 2992 ; 2993 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2994 ; 2995 // Now that we got the write lock, another thread may have constructed the; 2996 // TClass while we were waiting, so we need to do the checks again.; 2997 ; 2998 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2999 if (cl) {; 3000 if (cl->IsLoaded() || cl->TestBit(kUnloading",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:111324,load,load,111324,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,3,['load'],['load']
Performance,"alIsAProxy* TClass::GetIsAProxy() const; 3023{; 3024 return fIsA;; 3025}; 3026 ; 3027////////////////////////////////////////////////////////////////////////////////; 3028/// Static method returning pointer to TClass of the specified class name.; 3029/// If load is true, an attempt is made to obtain the class by loading; 3030/// the appropriate shared library (directed by the rootmap file).; 3031/// If silent is 'true', do not warn about missing dictionary for the class.; 3032/// (typically used for classes that are used only for transient members); 3033/// Returns `nullptr` in case class is not found.; 3034 ; 3035TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent); 3036{; 3037 return TClass::GetClass(name, load, silent, 0, 0);; 3038}; 3039 ; 3040TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size); 3041{; 3042 if (!name || !name[0]) return nullptr;; 3043 ; 3044 if (strstr(name, ""(anonymous)"")) return nullptr;; 3045 if (strstr(name, ""(unnamed)"")) return nullptr;; 3046 if (strncmp(name,""class "",6)==0) name += 6;; 3047 if (strncmp(name,""struct "",7)==0) name += 7;; 3048 ; 3049 if (!gROOT->GetListOfClasses()) return nullptr;; 3050 ; 3051 // FindObject will take the read lock before actually getting the; 3052 // TClass pointer so we will need not get a partially initialized; 3053 // object.; 3054 TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 3055 ; 3056 // Early return to release the lock without having to execute the; 3057 // long-ish normalization.; 3058 if (cl && (cl->IsLoaded() || cl->TestBit(kUnloading))) return cl;; 3059 ; 3060 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3061 ; 3062 // Now that we got the write lock, another thread may have constructed the; 3063 // TClass while we were waiting, so we need to do the checks again.; 3064 ; 3065 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 3066 if (cl) {; 3067 if (cl->IsLoaded() || cl->TestBit(kUnloading",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:114075,load,load,114075,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,3,['load'],['load']
Performance,"alNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,bool>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction4Ref<VO,VI1,VI2,VI3,VI4> Streamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_bool_.html:36897,cache,cache,36897,root/html602/RooCFunction4Binding_double_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_bool_.html,4,['cache'],['cache']
Performance,"alNoticeUser-defined notice shown when reading a sealed likelihood; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataHist& data, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none()); RooChi2Var constr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChi2Var.html:44544,cache,cache,44544,root/html602/RooChi2Var.html,https://root.cern,https://root.cern/root/html602/RooChi2Var.html,2,['cache'],['cache']
Performance,"alSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,double,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction3Binding_double_double_double_double_.html:33730,cache,cache,33730,root/html532/RooCFunction3Binding_double_double_double_double_.html,https://root.cern,https://root.cern/root/html532/RooCFunction3Binding_double_double_double_double_.html,1,['cache'],['cache']
Performance,"alShape* shape2); Compare 'shape1' and 'shape2' bounding box volumes - return kTRUE if; 'shape1' bigger than 'shape2'. void RebuildSceneInfo(TGLRnrCtx& rnrCtx); Major change in scene, need to rebuild all-element draw-vector and; sort it. Sort the TGLPhysical draw list by shape bounding box diagonal, from; large to small. This makes dropout of shapes with time limited; Draw() calls must less noticable. As this does not use projected; size it only needs to be done after a scene content change - not; everytime scene drawn (potential camera/projection change). void UpdateSceneInfo(TGLRnrCtx& rnrCtx); Fill scene-info with information needed for rendering, take into; account the render-context (viewer state, camera, clipping).; Here we have to iterate over all the physical shapes and select; the visible ones. While at it, opaque and transparent shapes are; divided into two groups. void LodifySceneInfo(TGLRnrCtx& rnrCtx); Setup LOD-dependant values in scene-info.; We have to perform LOD quantization for all draw-elements. void PreDraw(TGLRnrCtx& rnrCtx); Initialize rendering.; Pass to base-class where most work is done.; Check if GL-ctx is shared with the previous one; if not; wipe display-lists of all logicals. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque elements. void RenderTransp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements. void PostDraw(TGLRnrCtx& rnrCtx); Called after the rendering is finished.; In debug mode draw statistcs is dumped.; Parent's PostDraw is called for GL cleanup. void RenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); Do full rendering of scene. First draw the opaques, then the transparents. For each we do; the number of passes required by draw mode and clipping setup. void RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLScene.html:9001,perform,perform,9001,root/html528/TGLScene.html,https://root.cern,https://root.cern/root/html528/TGLScene.html,3,['perform'],['perform']
Performance,"alShape* shape2); Compare 'shape1' and 'shape2' bounding box volumes - return kTRUE if; 'shape1' bigger than 'shape2'. void RebuildSceneInfo(TGLRnrCtx& rnrCtx); Major change in scene, need to rebuild all-element draw-vector and; sort it. Sort the TGLPhysical draw list by shape bounding box diagonal, from; large to small. This makes dropout of shapes with time limited; Draw() calls must less noticable. As this does not use projected; size it only needs to be done after a scene content change - not; everytime scene drawn (potential camera/projection change). void UpdateSceneInfo(TGLRnrCtx& rnrCtx); Fill scene-info with information needed for rendering, take into; account the render-context (viewer state, camera, clipping).; Here we have to iterate over all the physical shapes and select; the visible ones. While at it, opaque and transparent shapes are; divided into two groups. void LodifySceneInfo(TGLRnrCtx& rnrCtx); Setup LOD-dependant values in scene-info.; We have to perform LOD quantization for all draw-elements. void PreDraw(TGLRnrCtx& rnrCtx); Initialize rendering.; Pass to base-class where most work is done.; Check if GL-ctx is shared with the previous one; if not; wipe display-lists of all logicals. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque elements. void RenderTransp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements. void RenderSelOpaqueForHighlight(TGLRnrCtx& rnrCtx); Render selected opaque elements for highlight. void RenderSelTranspForHighlight(TGLRnrCtx& rnrCtx); Render selected transparent elements for highlight. void RenderHighlight(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec). void PostDraw(TGLRnrCtx& rnrCtx); Called after the rendering is finished.; In debug mode draw statistcs is dumped.; Parent's PostDraw is called for GL cleanup. void RenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLScene.html:9226,perform,perform,9226,root/html534/TGLScene.html,https://root.cern,https://root.cern/root/html534/TGLScene.html,3,['perform'],['perform']
Performance,"alValue *gv) const;  Return pointer to cling DeclId for a global value. ;  ; cling::Interpreter * GetInterpreterImpl () const;  ; cling::MetaProcessor * GetMetaProcessorImpl () const;  ; Bool_t HandleNewTransaction (const cling::Transaction &T);  Helper function to increase the internal Cling count of transactions that change the AST. ;  ; void InitRootmapFile (const char *name);  Create a resource table and read the (possibly) three resource files, i.e. ;  ; void InvalidateCachedDecl (const std::tuple< TListOfDataMembers *, TListOfFunctions *, TListOfFunctionTemplates *, TListOfEnums * > &Lists, const clang::Decl *D);  Invalidate cached TCling information for the given declaration, and removed it from the appropriate object list. ;  ; bool IsClassAutoLoadingEnabled () const;  Returns if class AutoLoading is currently enabled. ;  ; void LoadPCM (std::string pcmFileNameFullPath);  Tries to load a rdict PCM, issues diagnostics if it fails. ;  ; void LoadPCMImpl (TFile &pcmFile);  Tries to load a PCM from TFile; returns true on success. ;  ; TCling & operator= (const TCling &)=delete;  ; void ProcessClassesToUpdate ();  ; int ReadRootmapFile (const char *rootmapfile, TUniqueString *uniqueString=nullptr);  Read and parse a rootmapfile in its new format, and return 0 in case of success, -1 if the file has already been read, and -3 in case its format is the old one (e.g. ;  ; void RegisterLoadedSharedLibrary (const char *name);  Register a new shared library name with the interpreter; add it to fSharedLibs. ;  ; void RegisterRdictForLoadPCM (const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent);  Register Rdict data for future loading by LoadPCM;. ;  ; void UpdateListOfLoadedSharedLibraries ();  . Static Private Member Functions; static Int_t DeepAutoLoadImpl (const char *cls, std::unordered_set< std::string > &visited, bool nameIsNormalized);  ; template<typename List , typename Object > ; static void RemoveAndInvalidateObject (List &L, Object *O);  ; stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:47813,load,load,47813,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['load'],['load']
Performance,"alVar &var2, double n1=1.0, double n2=2.0, double n3=0.0, double n4=0.0, double n5=0.0, double n6=0.0, unsigned int npoints=50);  Create and draw a TH2 with the error contours in the parameters var1 and var2. ;  ; int evalCounter () const;  ; auto fitter ();  Return underlying ROOT fitter object. ;  ; ROOT::Math::IMultiGenFunction * getMultiGenFcn () const;  ; int getNPar () const;  ; int getPrintLevel ();  Get the MINUIT internal printing level. ;  ; int hesse ();  Execute HESSE. ;  ; int improve ();  Execute IMPROVE. ;  ; TClass * IsA () const override;  ; RooFit::OwningPtr< RooFitResult > lastMinuitFit ();  ; int migrad ();  Execute MIGRAD. ;  ; int minimize (const char *type, const char *alg=nullptr);  Minimise the function passed in the constructor. ;  ; std::string const & minimizerType () const;  ; int minos ();  Execute MINOS. ;  ; int minos (const RooArgSet &minosParamList);  Execute MINOS for given list of parameters. ;  ; void optimizeConst (int flag);  If flag is true, perform constant term optimization on function being minimized. ;  ; RooFit::OwningPtr< RooFitResult > save (const char *name=nullptr, const char *title=nullptr);  Save and return a RooFitResult snapshot of current minimizer status. ;  ; void saveStatus (const char *label, int status);  ; int seek ();  Execute SEEK. ;  ; void setEps (double eps);  Change MINUIT epsilon. ;  ; void setErrorLevel (double level);  Set the level for MINUIT error analysis to the given value. ;  ; void setEvalErrorWall (bool flag);  ; bool setLogFile (const char *logf=nullptr);  ; void setMaxFunctionCalls (int n);  Change maximum number of likelihood function class from MINUIT (RooMinimizer default 500 * #parameters) ;  ; void setMaxIterations (int n);  Change maximum number of MINUIT iterations (RooMinimizer default 500 * #parameters) ;  ; void setMinimizerType (std::string const &type);  Choose the minimizer algorithm. ;  ; void setOffsetting (bool flag);  Enable internal likelihood offsetting for enhanced nume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMinimizer.html:3665,optimiz,optimizeConst,3665,doc/master/classRooMinimizer.html,https://root.cern,https://root.cern/doc/master/classRooMinimizer.html,3,"['optimiz', 'perform']","['optimization', 'optimizeConst', 'perform']"
Performance,"alVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooHistConstraint&operator=(const RooHistConstraint&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistConstraint.html:22847,optimiz,optimizeCacheMode,22847,root/html602/RooHistConstraint.html,https://root.cern,https://root.cern/root/html602/RooHistConstraint.html,4,['optimiz'],['optimizeCacheMode']
Performance,"alars. { SetComponents(begin,end); }. explicit Rotation3D( AxisAngle const & a ). Construct from an AxisAngle. { gv_detail::convert(a, *this); }. explicit Rotation3D( EulerAngles const & e ). Construct from EulerAngles. { gv_detail::convert(e, *this); }. explicit Rotation3D( RotationZYX const & e ). Construct from RotationZYX. { gv_detail::convert(e, *this); }. explicit Rotation3D( Quaternion const & q ). Construct from a Quaternion. { gv_detail::convert(q, *this); }. explicit Rotation3D( RotationZ const & r ). Construct from an axial rotation. { gv_detail::convert(r, *this); }. explicit Rotation3D( RotationY const & r ); { gv_detail::convert(r, *this); }. explicit Rotation3D( RotationX const & r ); { gv_detail::convert(r, *this); }. explicit Rotation3D(const ForeignMatrix & m). Construct from a linear algebra matrix of size at least 3x3,; which must support operator()(i,j) to obtain elements (0,0) thru (2,2).; Precondition: The matrix is assumed to be orthonormal. No checking; or re-adjusting is performed. { SetComponents(m); }. Rotation3D(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v1, const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v2, const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v3). Construct from three orthonormal vectors (which must have methods; x(), y() and z()) which will be used as the columns of the rotation; matrix. The orthonormality will be checked, and values adjusted; so that the result will always be a good rotation matrix. SetComponents(ROOT::Math::Rotation3D::Scalar xx, ROOT::Math::Rotation3D::Scalar xy, ROOT::Math::Rotation3D::Scalar xz, ROOT::Math::Rotation3D::Scalar yx, ROOT::Math::Rotation3D::Scalar yy, ROOT::Math::Rotation3D::Scalar yz, ROOT::Math::Rotation3D::Scalar zx, ROOT::Math::Rotation3D::Scalar zy, ROOT::Math::Rotation3D::Scalar zz); The co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Rotation3D.html:7141,perform,performed,7141,root/html526/ROOT__Math__Rotation3D.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Rotation3D.html,1,['perform'],['performed']
Performance,"alculate. ; Owners of such objects can registers these here with associated parameter values for which the object is valid, so that other instances can, at a later moment retrieve these precalculated objects. ; Definition at line 24 of file RooExpensiveObjectCache.h. Classes; class  ExpensiveObject;  . Public Member Functions;  RooExpensiveObjectCache ();  ;  RooExpensiveObjectCache (const RooExpensiveObjectCache &other);  ;  ~RooExpensiveObjectCache () override;  Destructor. ;  ; void clearAll ();  Clear all cache elements. ;  ; bool clearObj (Int_t uniqueID);  Clear cache element with given unique ID Retrieve payload object of cache element with given unique ID. ;  ; bool empty () const;  ; const TObject * getObj (Int_t uniqueID);  Retrieve payload object of cache element with given unique ID. ;  ; void importCacheObjects (RooExpensiveObjectCache &other, const char *ownerName, bool verbose=false);  ; TClass * IsA () const override;  ; void print () const;  ; bool registerObject (const char *ownerName, const char *objectName, TObject &cacheObject, const RooArgSet &params);  Register object associated with given name and given associated parameters with given values in cache. ;  ; const TObject * retrieveObject (const char *name, TClass *tclass, const RooArgSet &params);  Retrieve object from cache that was registered under given name with given parameters, if current parameter values match those that were stored in the registry for this object. ;  ; bool setObj (Int_t uniqueID, TObject *obj);  Place new payload object in cache element with given unique ID. ;  ; Int_t size () const;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExpensiveObjectCache.html:1463,cache,cacheObject,1463,doc/master/classRooExpensiveObjectCache.html,https://root.cern,https://root.cern/doc/master/classRooExpensiveObjectCache.html,2,['cache'],"['cache', 'cacheObject']"
Performance,"alculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCategoryLValue(const char* name, const char* title); Constructor. RooAbsCategoryLValue(const RooAbsCategoryLValue& other, const char* name = 0); Copy constructor. ~RooAbsCategoryLValue(); Destructor. RooAbsArg& operator=(Int_t index); Assignment operator from integer index number. RooAbsArg& operator=(const char* label); Assignment operator from string pointer. RooAbsArg& operator=(const RooAbsCategory& other); Assignment from another RooAbsCategory. Bool_t setOrdinal(UInt_t index, const char* rangeName); Set our state to our n'th defined type and return kTRUE.; Return kFALSE if n is out of range. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream (dummy implementation). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream (dummy implementation). void randomize(const char* rangeName = 0); Randomize current value. void setBin(Int_t ibin, const char* rangeName = 0); Set category to i-th fit bin, which is the i-th registered state. Int_t getBin(const char* rangeName = 0) const; Get index of plot bin for current value this category. Int_t numBins(const char* rangeName) const; Returm the number of fit bins ( = number of types ). RooAbsCategoryLValue(); Constructor, assignment etc. Bool_t setIndex(Int_t index, Bool_t printError = kTRUE); Value mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategoryLValue.html:25969,cache,cached,25969,root/html602/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html,2,['cache'],['cached']
Performance,"alculation method; 154 // - kUseEventSelection: computes efficiencies from given data sample; 155 // - kUsePDFs : creates smoothed PDFs from data samples, and; 156 // uses this to compute efficiencies; 157 enum EEffMethod { kUseEventSelection = 0,; 158 kUsePDFs };; 159 ; 160 // improve the Monte Carlo by providing some additional information; 161 enum EFitParameters { kNotEnforced = 0,; 162 kForceMin,; 163 kForceMax,; 164 kForceSmart };; 165 ; 166 // general; 167 TString fFitMethodS; ///< chosen fit method (string); 168 EFitMethodType fFitMethod; ///< chosen fit method; 169 TString fEffMethodS; ///< chosen efficiency calculation method (string); 170 EEffMethod fEffMethod; ///< chosen efficiency calculation method; 171 std::vector<EFitParameters>* fFitParams; ///< vector for series of fit methods; 172 Double_t fTestSignalEff; ///< used to test optimized signal efficiency; 173 Double_t fEffSMin; ///< used to test optimized signal efficiency; 174 Double_t fEffSMax; ///< used to test optimized signal efficiency; 175 Double_t* fCutRangeMin; ///< minimum of allowed cut range; 176 Double_t* fCutRangeMax; ///< maximum of allowed cut range; 177 std::vector<Interval*> fCutRange; ///< allowed ranges for cut optimisation; 178 ; 179 // for the use of the binary tree method; 180 BinarySearchTree* fBinaryTreeS;; 181 BinarySearchTree* fBinaryTreeB;; 182 ; 183 // MC method; 184 Double_t** fCutMin; ///< minimum requirement; 185 Double_t** fCutMax; ///< maximum requirement; 186 Double_t* fTmpCutMin; ///< temporary minimum requirement; 187 Double_t* fTmpCutMax; ///< temporary maximum requirement; 188 TString* fAllVarsI; ///< what to do with variables; 189 ; 190 // relevant for all methods; 191 Int_t fNpar; ///< number of parameters in fit (default: 2*Nvar); 192 Double_t fEffRef; ///< reference efficiency; 193 std::vector<Int_t>* fRangeSign; ///< used to match cuts to fit parameters (and vice versa); 194 TRandom* fRandom; ///< random generator for MC optimisation method; 195 ; 196 // ba",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8h_source.html:6560,optimiz,optimized,6560,doc/master/MethodCuts_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8h_source.html,1,['optimiz'],['optimized']
Performance,"alculatorGeneric::fDefaultSampler; RooStats::TestStatistic*RooStats::HypoTestCalculatorGeneric::fDefaultTestStat; const RooStats::ModelConfig*RooStats::HypoTestCalculatorGeneric::fNullModel; RooStats::TestStatSampler*RooStats::HypoTestCalculatorGeneric::fTestStatSampler. private:. RooAbsData*fAsimovDataasimov data set ; RooArgSetfAsimovGlobObssnapshot of Asimov global observables ; RooArgSetfBestFitPoisnapshot of best fitted POI values; doublefNLLAsimov; doublefNLLObs; boolfOneSided; intfUseQTildeflag to indicate if using qtilde or not (-1 (default based on RooRealVar)), 0 false, 1 (true); static intfgPrintLevelcontrol print level (0 minimal, 1 normal, 2 debug). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetPrintLevel(int level); set print level (static function); 0 minimal, 1 normal, 2 debug. AsymptoticCalculator(RooAbsData& data, const RooStats::ModelConfig& altModel, const RooStats::ModelConfig& nullModel); constructor for asymptotic calculator from Data set and ModelConfig; The constructor will perform a global fit of the model to the data; and build an Asimov data set.; It will then also fit the model to the Asimov data set to find the likelihood value; of the Asimov data set; NOTE: If a fit has been done before, one for speeding up could set all the initial prameters; to the fit value and in addition set the null snapshot to the best fit. Double_t EvaluateNLL(RooAbsPdf& pdf, RooAbsData& data, const RooArgSet* poiSet = 0). HypoTestResult* GetHypoTest() const; It performs an hypothesis tests using the likelihood function; and computes the p values for the null and the alternate using the asymptotic; formulae for the profile likelihood ratio.; See G. Cowan, K. Cranmer, E. Gross and O. Vitells.; Asymptotic formulae for likelihood- based tests of new physics. Eur. Phys. J., C71:1–19, 2011.; The formulae are valid only for one POI. If more than one POI exists consider as POI only the; first one. double GetExpected",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__AsymptoticCalculator.html:4703,perform,perform,4703,root/html532/RooStats__AsymptoticCalculator.html,https://root.cern,https://root.cern/root/html532/RooStats__AsymptoticCalculator.html,1,['perform'],['perform']
Performance,"alidateCurrentTree(). void TChain::InvalidateCurrentTree ; (; ). protected . Set the TTree to be reloaded as soon as possible. ; In particular this is needed when adding a Friend.; If the tree has clones, copy them into the chain clone list so we can change their branch addresses when necessary.; This is to support the syntax: TTree* clone = chain->GetTree()->CloneTree(0);; TTree::CloneTreevirtual TTree * CloneTree(Long64_t nentries=-1, Option_t *option="""")Create a clone of this tree and copy nentries.Definition TTree.cxx:3139; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557. Definition at line 1278 of file TChain.cxx. ◆ IsA(). TClass * TChain::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TProofChain.; Definition at line 173 of file TChain.h. ◆ LoadBaskets(). Int_t TChain::LoadBaskets ; (; Long64_t ; maxmemory). overridevirtual . Dummy function. ; It could be implemented and load all baskets of all trees in the chain. For the time being use TChain::Merge and TTree::LoadBasket on the resulting tree. ; Reimplemented from TTree.; Definition at line 1296 of file TChain.cxx. ◆ LoadTree(). Long64_t TChain::LoadTree ; (; Long64_t ; entry). overridevirtual . Find the tree which contains entry, and set it as the current tree. ; Returns the entry number in that tree.; The input argument entry is the entry serial number in the whole chain.; In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number is less than zero or too large for the chain.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or the TTree is missing from the file.; -5: Internal error, please report the circumstance when this happen as a ROOT issue.; -6: An error occurred within the notify callback. Calls fNotify->Notify() (if fNotify is not null) when starting the processing o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:81006,load,load,81006,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,1,['load'],['load']
Performance,"alisation between data; and Monte Carlo. If the regularisation is strong, i.e. large parameter tau,; then the distribution x or its derivatives will look like the bias; distribution. If the parameter tau is small, the distribution x is; independent of the bias. Three basic types of regularisation are implemented in TUnfold. condition regularisation. kRegModeNone none; kRegModeSize minimize the size of (x-x0); kRegModeDerivative minimize the 1st derivative of (x-x0); kRegModeCurvature minimize the 2nd derivative of (x-x0). kRegModeSize is the regularisation scheme which usually is found in; literature. In addition, the bias usually is not present; (bias scale factor is zero). The non-standard regularisation schemes kRegModeDerivative and; kRegModeCurvature have the nice feature that they create correlations; between x-bins, whereas the non-regularized unfolding tends to create; negative correlations between bins. For these regularisation schemes the; parameter tau could be tuned such that the correlations are smallest,; as an alternative to the L-curve method. If kRegModeSize is chosen or if x is a smooth function through all bins,; the regularisation condition can be set on all bins together by giving; the appropriate argument in the constructor (see examples above). If x is composed of independent groups of bins (for example,; signal and background binning in two variables), it may be necessary to; set regularisation conditions for the individual groups of bins.; In this case, give kRegModeNone in the constructor and specify; the bin grouping with calls to; RegularizeBins() specify a 1-dimensional group of bins; RegularizeBins2D() specify a 2-dimensional group of bins. For ultimate flexibility, the regularisation condition can be set on each; bin individually; -> give kRegModeNone in the constructor and use; RegularizeSize() regularize one bin; RegularizeDerivative() regularize the slope given by two bins; RegularizeCurvature() regularize the curvature given by thr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfold.html:9680,tune,tuned,9680,root/html528/TUnfold.html,https://root.cern,https://root.cern/root/html528/TUnfold.html,3,['tune'],['tuned']
Performance,"alization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:2676,perform,performed,2676,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,12,['perform'],['performed']
Performance,"alization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooKeysPdf.html:41069,cache,cache,41069,root/html532/RooKeysPdf.html,https://root.cern,https://root.cern/root/html532/RooKeysPdf.html,6,['cache'],['cache']
Performance,"alization set with for above integral; const RooArgSet*_nset! Normalization set to be used in evaluation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooRealProxy_pdfProbability Density function; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooEffProd.html:41482,cache,cache,41482,root/html532/RooEffProd.html,https://root.cern,https://root.cern/root/html532/RooEffProd.html,2,['cache'],['cache']
Performance,"alization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGaussModel.html:41624,cache,cache,41624,root/html532/RooGaussModel.html,https://root.cern,https://root.cern/root/html532/RooGaussModel.html,2,['cache'],['cache']
Performance,"alization/ projection; configurations can be cached. ; . Function Members (Methods); public:. virtual~RooCacheManager<RooAbsCacheElement>(); Int_tcacheSize() const; static TClass*Class(); virtual voidRooAbsCache::findConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); RooAbsCacheElement*getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const char* isetRangeName); RooAbsCacheElement*getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*getObjByIndex(Int_t index) const; virtual voidinsertObjectHook(RooAbsCacheElement&); virtual TClass*IsA() const; Int_tlastIndex() const; const RooNameSet*nameSet1ByIndex(Int_t index) const; const RooNameSet*nameSet2ByIndex(Int_t index) const; RooCacheManager<RooAbsCacheElement>&operator=(const RooCacheManager<RooAbsCacheElement>&); virtual voidoperModeHook(); virtual voidRooAbsCache::optimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidreset(); RooCacheManager<RooAbsCacheElement>(Int_t maxSize = 2); RooCacheManager<RooAbsCacheElement>(RooAbsArg* owner, Int_t maxSize = 2); RooCacheManager<RooAbsCacheElement>(const RooCacheManager<RooAbsCacheElement>& other, RooAbsArg* owner = 0); Int_tsetObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidsterilize(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. Int_t_lastIndex! Last slot accessed; Int_t_maxSize! Maximum size; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCacheManager_RooAbsCacheElement_.html:2158,optimiz,optimizeCacheMode,2158,root/html602/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html602/RooCacheManager_RooAbsCacheElement_.html,2,['optimiz'],['optimizeCacheMode']
Performance,"alize Unix system interface. ; Reimplemented from TSystem.; Definition at line 595 of file TUnixSystem.cxx. ◆ IsA(). TClass * TUnixSystem::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TSystem.; Definition at line 219 of file TUnixSystem.h. ◆ IsPathLocal(). Bool_t TUnixSystem::IsPathLocal ; (; const char * ; path). overridevirtual . Returns TRUE if the url in 'path' points to the local file system. ; This is used to avoid going through the NIC card for local operations. ; Reimplemented from TSystem.; Definition at line 1643 of file TUnixSystem.cxx. ◆ Link(). int TUnixSystem::Link ; (; const char * ; from, . const char * ; to . ). overridevirtual . Create a link from file1 to file2. ; Returns 0 when successful, -1 in case of failure. ; Reimplemented from TSystem.; Definition at line 1686 of file TUnixSystem.cxx. ◆ ListLibraries(). void TUnixSystem::ListLibraries ; (; const char * ; regexp = """"). overridevirtual . List all loaded shared libraries. ; Reimplemented from TSystem.; Definition at line 2848 of file TUnixSystem.cxx. ◆ ListSymbols(). void TUnixSystem::ListSymbols ; (; const char * ; module, . const char * ; re = """" . ). overridevirtual . List symbols in a shared library. ; Reimplemented from TSystem.; Definition at line 2840 of file TUnixSystem.cxx. ◆ Load(). int TUnixSystem::Load ; (; const char * ; module, . const char * ; entry = """", . Bool_t ; system = kFALSE . ). overridevirtual . Load a shared library. ; Returns 0 on successful loading, 1 in case lib was already loaded and -1 in case lib does not exist or in case of error. ; Reimplemented from TSystem.; Definition at line 2824 of file TUnixSystem.cxx. ◆ MakeDirectory(). int TUnixSystem::MakeDirectory ; (; const char * ; name). overridevirtual . Make a Unix file system directory. ; Returns 0 in case of success and -1 if the directory could not be created. ; Reimplemented from TSystem.; Definition at line 1380 of file TUnixSystem.cxx. ◆ Now(). TTim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:58356,load,loaded,58356,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['load'],['loaded']
Performance,"alize random number generator.; 50gRandom.SetSeed(); 51rannor, rndm = gRandom.Rannor, gRandom.Rndm; 52 ; 53# For speed, bind and cache the Fill member functions,; 54histos = [ 'hpx', 'hpxpy', 'hprof', 'ntuple' ]; 55for name in histos:; 56 exec('%sFill = %s.Fill' % (name,name)); 57 ; 58# Fill histograms randomly.; 59px_ref, py_ref = ctypes.c_double(), ctypes.c_double(); 60kUPDATE = 1000; 61for i in range( 25000 ):; 62 # Generate random values. Use ctypes to pass doubles by reference; 63 rannor( px_ref, py_ref ); 64 # Retrieve the generated values; 65 px = px_ref.value; 66 py = py_ref.value; 67 ; 68 pz = px*px + py*py; 69 random = rndm(1); 70 ; 71 # Fill histograms.; 72 hpx.Fill( px ); 73 hpxpy.Fill( px, py ); 74 hprof.Fill( px, pz ); 75 ntuple.Fill( px, py, pz, random, i ); 76 ; 77 # Update display every kUPDATE events.; 78 if i and i%kUPDATE == 0:; 79 if i == kUPDATE:; 80 hpx.Draw(); 81 ; 82 c1.Modified(); 83 c1.Update(); 84 ; 85 if gSystem.ProcessEvents(): # allow user interrupt; 86 break; 87 ; 88# Destroy member functions cache.; 89for name in histos:; 90 exec('del %sFill' % name); 91del histos; 92 ; 93gBenchmark.Show( 'hsimple' ); 94 ; 95# Save all objects in this file.; 96hpx.SetFillColor( 0 ); 97hfile.Write(); 98hpx.SetFillColor( 48 ); 99c1.Modified(); 100c1.Update(); 101 ; 102# Note that the file is automatically closed when application terminates; 103# or when the file destructor is called.; SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TProfileProfile Histogram.Definition TProfile.h:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimple_8py_source.html:2900,cache,cache,2900,doc/master/hsimple_8py_source.html,https://root.cern,https://root.cern/doc/master/hsimple_8py_source.html,1,['cache'],['cache']
Performance,"alized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; TStringTWebFile::fMsgGetHeadcache GetHead() msg; TStringTWebFile::fMsgReadBuffercache ReadBuffer() msg; TStringTWebFile::fMsgReadBuffer10cache ReadBuffer10() msg; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Bool_tTWebFile::fNoProxydon't use proxy; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; TUrlTWebFile::fProxyproxy URL; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; TUrlfServerServer url; Long64_tTWebFile::fSizefile size; TSocket*TWebFile::fSocketsocket for HTTP/1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TAS3File.html:21865,cache,cache,21865,root/html532/TAS3File.html,https://root.cern,https://root.cern/root/html532/TAS3File.html,4,['cache'],['cache']
Performance,"all active leaves for entry.Definition TTree.cxx:9385; TTree::fEventListTEventList * fEventList! Pointer to event selection list (if one)Definition TTree.h:125; TTree::GetAutoSavevirtual Long64_t GetAutoSave() constDefinition TTree.h:448; TTree::StopCacheLearningPhasevirtual Int_t StopCacheLearningPhase()Stop the cache learning phase.Definition TTree.cxx:9474; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::fSortedBranchesstd::vector< std::pair< Long64_t, TBranch * > > fSortedBranches! Branches to be processed in parallel when IMT is on, sorted by average task timeDefinition TTree.h:144; TTree::SetCircularvirtual void SetCircular(Long64_t maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTree::fSavedBytesLong64_t fSavedBytesNumber of autosaved bytes.Definition TTree.h:88; TTree::AddBranchToCachevirtual Int_t AddBranchToCache(const char *bname, bool subbranches=false)Add branch with name bname to the Tree cache.Definition TTree.cxx:1059; TTree::GetMedianClusterSizeLong64_t GetMedianClusterSize()Estimate the median cluster size for the TTree.Definition TTree.cxx:8297; TTree::GetClusterIteratorvirtual TClusterIterator GetClusterIterator(Long64_t firstentry)Return an iterator over the cluster of baskets starting at firstentry.Definition TTree.cxx:5467; TTree::ResetBranchAddressvirtual void ResetBranchAddress(TBranch *)Tell all of our branches to set their addresses to zero.Definition TTree.cxx:8065; TTree::fCacheUserSetbool fCacheUserSet! true if the cache setting was explicitly given by userDefinition TTree.h:141; TTree::GetNewlineValuechar GetNewlineValue(std::istream &inputStream)Determine which newline this file is using.Definition TTree.cxx:7588; TTree::fIOFeaturesTIOFeatures fIOFeaturesIO features to define for newly-written baskets and branches.Definition TTree.h:114; TTree::GetEntryNumberWithIndexvirtual Long64_t Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:437821,cache,cache,437821,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"all libraries known to ROOT via the rootmap system.; 1968/// Returns the number of top level libraries successfully loaded.; 1969 ; 1970UInt_t TSystem::LoadAllLibraries(); 1971{; 1972 UInt_t nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just load the first library - TSystem will do the rest.; 2002 auto res = gSystem->Load(lib);; 2003 if (res >=0) {; 2004 if (res == 0) ++nlibs;; 2005 loadedlibs.insert(lib.Data());; 2006 } else {; 2007 failedlibs.insert(lib.Data());; 2008 }; 2009 }; 2010 }; 2011 }; 2012 return nlibs;; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Find a dynamic library called lib using the system search paths.; 2017/// Appends known extensions if needed. Returned string must be deleted; 2018/// by the user!; 2019 ; 2020char *TSystem::DynamicPathName(const char *lib, Bool_t quiet /*=kFALSE*/); 2021{; 2022 TString sLib(lib);; 2023 if (FindDynamicLibrary(sLib, quiet)); 2024 return StrDup(sLib);; 2025 return nullptr;; 2026}; 2027 ; 2028////////////////////////////////////////////////////////////////////////////////; 2029/// Find a dynamic library using the system se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:64588,load,loadedlibs,64588,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loadedlibs']
Performance,"all materials,media and matrices. void ClearAttributes(); Reset all attributes to default ones. Default attributes for visualization; are those defined before closing the geometry. void CloseGeometry(Option_t* option = ""d""); Closing geometry implies checking the geometry validity, fixing shapes; with negative parameters (run-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the current navigator. void ConvertReflections(); Convert all reflections in geometry to normal rotations + reflected shapes. Int_t CountNodes(const TGeoVolume* vol = 0, Int_t nlevels = 10000, Int_t option = 0); Count the total number of nodes starting from a volume, nlevels down. void DefaultAngles(); Set default angles for a given view. void DrawCu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:44314,cache,cache,44314,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,3,['cache'],['cache']
Performance,"all materials,media and matrices. void ClearAttributes(); Reset all attributes to default ones. Default attributes for visualization; are those defined before closing the geometry. void CloseGeometry(Option_t* option = ""d""); Closing geometry implies checking the geometry validity, fixing shapes; with negative parameters (run-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the current navigator. void ConvertReflections(); Convert all reflections in geometry to normal rotations + reflected shapes. void CountLevels(); Count maximum number of nodes per volume, maximum depth and maximum; number of xtru vertices. Int_t CountNodes(const TGeoVolume* vol = 0, Int_t nlevels = 10000, Int_t option = 0); Count the total number of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoManager.html:46660,cache,cache,46660,root/html534/TGeoManager.html,https://root.cern,https://root.cern/root/html534/TGeoManager.html,3,['cache'],['cache']
Performance,"all sub-branches of this branch too. ;  ; TBuffer * GetTransientBuffer (Int_t size);  Returns the transient buffer currently used by this TBranch for reading/writing baskets. ;  ; TTree * GetTree () const;  ; Int_t GetWriteBasket () const;  ; Long64_t GetZipBytes (Option_t *option="""") const;  Return total number of zip bytes in the branch if option =""*"" includes all sub-branches of this branch too. ;  ; TClass * IsA () const override;  ; bool IsAutoDelete () const;  Return true if an existing object in a TBranchObject must be deleted. ;  ; bool IsFolder () const override;  Return true if more than one leaf or browsables, false otherwise. ;  ; virtual void KeepCircular (Long64_t maxEntries);  keep a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void Print (Option_t *option="""") const override;  Print TBranch parameters. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void Reset (Option_t *option="""");  Reset a Branch. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetAfterMerge (TFileMergeInfo *);  Reset a Branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetAddress (void *add);  Set address of this branch. ;  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBasketSize (Int_t buffsize);  Set the basket size The function makes sure that the basket size is greater than fEntryOffsetlen. ;  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:6917,cache,cached,6917,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,2,['cache'],"['cache', 'cached']"
Performance,"allVars minus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return pointer to weight variable if it is defined. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree *t, const RooFormulaVar* select, const char* /*rangeName*/, Int_t /*nStart*/, Int_t /*nStop*/); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore *ads, const RooFormulaVar* select, 				 const char* rangeName, Int_t nStart, Int_t nStop); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='inde",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeDataStore.html:13410,load,loadValues,13410,root/html526/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html526/RooTreeDataStore.html,1,['load'],['loadValues']
Performance,"alled by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooCachedReal.h>. Inheritance diagram for RooCachedReal:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooCachedReal() [1/4]. RooCachedReal::RooCachedReal ; (; ). inline . Definition at line 22 of file RooCachedReal.h. ◆ RooCachedReal() [2/4]. RooCachedReal::RooCachedReal ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _func, . const RooArgSet & ; cacheObs . ). Constructor taking name, title and function to be cached and fixed choice of variable to cache. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in the observables of the function. If the fixed set of cache observables does not match the observables defined in the use context of the p.d.f the cache is still filled completely. Ee.g. when it is specified to cache x and p and only x is a observable in the given use context the cache histogram will store sampled values for all values of observable x and parameter p. In such a mode of operation the cache will also not be recalculated if the observable p changes ; Definition at line 68 of file RooCachedReal.cxx. ◆ RooCachedReal() [3/4]. RooCachedReal::RooCachedReal ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _func . ). Constructor taking name, title and function to be cached. ; To control granularity of the binning of the cache his",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:63545,cache,cacheObs,63545,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,1,['cache'],['cacheObs']
Performance,"alled when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TGeoAtt;  TGeoAtt ();  Default constructor. ;  ;  TGeoAtt (Option_t *vis_opt, Option_t *activity_opt="""", Option_t *optimization_opt="""");  Constructor. ;  ; virtual ~TGeoAtt ();  Destructor. ;  ; Bool_t IsActive () const;  ; Bool_t IsActiveDaughters () const;  ; Bool_t IsVisBranch () const;  ; Bool_t IsVisContainers () const;  ; Bool_t IsVisDaughters () const;  ; Bool_t IsVisible () const;  ; Bool_t IsVisLeaves () const;  ; Bool_t IsVisOnly () const;  ; Bool_t IsVisRaytrace () const;  ; Bool_t IsVisStreamed () const;  ; Bool_t IsVisTouched () const;  ; void ResetAttBit (UInt_t f);  ; void SetActiveDaughters (Bool_t flag=kTRUE);  ; void SetActivity (Bool_t flag=kTRUE);  ; void SetAttBit (UInt_t f);  ; void SetAttBit (UInt_t f, Bool_t set);  ; void SetOptimization (Option_t *option);  Set optimization flags. ;  ; void SetVisBranch ();  Set branch type visibility. ;  ; virtual void SetVisContainers (Bool_t flag=kTRUE);  Set branch type visibility. ;  ; void SetVisDaughters (Bool_t vis=kTRUE);  Set visibility for the daughters. ;  ; virtual void SetVisLeaves (Bool_t flag=kTRUE);  Set branch type visibility. ;  ; virtual void SetVisOnly (Bool_t flag=kTRUE);  Set branch type visibility. ;  ; void SetVisRaytrace (Bool_t flag=kTRUE);  ; void SetVisStreamed (Bool_t vis=kTRUE);  Mark attributes as ""streamed to file"". ;  ; void SetVisTouched (Bool_t vis=kTRUE);  Mark visualization attributes as ""modified"". ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Bool_t TestAttB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNode.html:19356,optimiz,optimization,19356,doc/master/classTGeoNode.html,https://root.cern,https://root.cern/doc/master/classTGeoNode.html,3,['optimiz'],['optimization']
Performance,"alled when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TGeoAtt;  TGeoAtt ();  Default constructor. ;  ;  TGeoAtt (Option_t *vis_opt, Option_t *activity_opt="""", Option_t *optimization_opt="""");  Constructor. ;  ; virtual ~TGeoAtt ();  Destructor. ;  ; Bool_t IsActive () const;  ; Bool_t IsActiveDaughters () const;  ; Bool_t IsVisBranch () const;  ; Bool_t IsVisContainers () const;  ; Bool_t IsVisDaughters () const;  ; Bool_t IsVisible () const;  ; Bool_t IsVisLeaves () const;  ; Bool_t IsVisOnly () const;  ; Bool_t IsVisRaytrace () const;  ; Bool_t IsVisStreamed () const;  ; Bool_t IsVisTouched () const;  ; void ResetAttBit (UInt_t f);  ; void SetActiveDaughters (Bool_t flag=kTRUE);  ; void SetActivity (Bool_t flag=kTRUE);  ; void SetAttBit (UInt_t f);  ; void SetAttBit (UInt_t f, Bool_t set);  ; void SetOptimization (Option_t *option);  Set optimization flags. ;  ; void SetVisBranch ();  Set branch type visibility. ;  ; virtual void SetVisContainers (Bool_t flag=kTRUE);  Set branch type visibility. ;  ; void SetVisDaughters (Bool_t vis=kTRUE);  Set visibility for the daughters. ;  ; virtual void SetVisibility (Bool_t vis=kTRUE);  Set visibility for this object. ;  ; virtual void SetVisLeaves (Bool_t flag=kTRUE);  Set branch type visibility. ;  ; virtual void SetVisOnly (Bool_t flag=kTRUE);  Set branch type visibility. ;  ; void SetVisRaytrace (Bool_t flag=kTRUE);  ; void SetVisStreamed (Bool_t vis=kTRUE);  Mark attributes as ""streamed to file"". ;  ; void SetVisTouched (Bool_t vis=kTRUE);  Mark visualization attributes as ""modified"". ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrack.html:14558,optimiz,optimization,14558,doc/master/classTGeoTrack.html,https://root.cern,https://root.cern/doc/master/classTGeoTrack.html,2,['optimiz'],['optimization']
Performance,"alled when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TGeoAtt;  TGeoAtt ();  Default constructor. ;  ;  TGeoAtt (Option_t *vis_opt, Option_t *activity_opt="""", Option_t *optimization_opt="""");  Constructor. ;  ; virtual ~TGeoAtt ();  Destructor. ;  ; Bool_t IsActive () const;  ; Bool_t IsActiveDaughters () const;  ; Bool_t IsVisBranch () const;  ; Bool_t IsVisContainers () const;  ; Bool_t IsVisDaughters () const;  ; Bool_t IsVisible () const;  ; Bool_t IsVisLeaves () const;  ; Bool_t IsVisOnly () const;  ; Bool_t IsVisRaytrace () const;  ; Bool_t IsVisStreamed () const;  ; Bool_t IsVisTouched () const;  ; void ResetAttBit (UInt_t f);  ; void SetActiveDaughters (Bool_t flag=kTRUE);  ; void SetActivity (Bool_t flag=kTRUE);  ; void SetAttBit (UInt_t f);  ; void SetAttBit (UInt_t f, Bool_t set);  ; void SetOptimization (Option_t *option);  Set optimization flags. ;  ; void SetVisBranch ();  Set branch type visibility. ;  ; void SetVisDaughters (Bool_t vis=kTRUE);  Set visibility for the daughters. ;  ; void SetVisRaytrace (Bool_t flag=kTRUE);  ; void SetVisStreamed (Bool_t vis=kTRUE);  Mark attributes as ""streamed to file"". ;  ; void SetVisTouched (Bool_t vis=kTRUE);  Mark visualization attributes as ""modified"". ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Bool_t TestAttBit (UInt_t f) const;  ;  Public Member Functions inherited from TAttLine;  TAttLine ();  AttLine default constructor. ;  ;  TAttLine (Color_t lcolor, Style_t lstyle, Width_t lwidth);  AttLine normal constructor. ;  ; virtual ~TAttLine ();  AttLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:32784,optimiz,optimization,32784,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,3,['optimiz'],['optimization']
Performance,"allel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 525 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 494 of file TROOT.cxx. ◆ FindEndSymbol(). static st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:21453,concurren,concurrent,21453,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['concurren'],['concurrent']
Performance,"allel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 526 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 495 of file TROOT.cxx. ◆ FindEndSymbol(). static st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:21414,concurren,concurrent,21414,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['concurren'],['concurrent']
Performance,"allel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 579 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 548 of file TROOT.cxx. ◆ FindEndSymbol(). static st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:20724,concurren,concurrent,20724,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,1,['concurren'],['concurrent']
Performance,"allel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 580 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 549 of file TROOT.cxx. ◆ FindEndSymbol(). static st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v620/namespaceROOT.html:20816,concurren,concurrent,20816,doc/v620/namespaceROOT.html,https://root.cern,https://root.cern/doc/v620/namespaceROOT.html,1,['concurren'],['concurrent']
Performance,"alling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; ... Here the entry is processed; }; Always using at least the same two branches; In this example, two branches are always used: in addition, some analysis functions are invoked and those may trigger the reading of other branches which are a priori not known. There is no point in prefetching branches that will be used very rarely: we can rely on the system to cache the right branches. TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; for (auto i : TSeqL(nentries)) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; // At this point we may call a user function where a few more branches; // will be read conditionally. These branches will be put in the cache; // if they have been used in the first 10 entries; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... Here the entry is processed; }. How can the usage and performance of TTreeCache be verified?; Once the event loop terminated, the number of effective system reads for a given file can be checked with a code like the following: printf(""Reading %lld bytes in %d transactions\n"",myTFilePtr->GetBytesRead(), f->GetReadCalls());; Another handy command is: m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:9899,cache,cachesize,9899,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,4,['cache'],['cachesize']
Performance,"ally via the plug-in manager; The possible types of Root-finding algorithms are: . Root Bracketing Algorithms which do not require function derivatives . RootFinder::kBRENT (default method implemented in MathCore) . RootFinder::kGSL_BISECTION . RootFinder::kGSL_FALSE_POS . RootFinder::kGSL_BRENT . Root Finding Algorithms using Derivatives . RootFinder::kGSL_NEWTON . RootFinder::kGSL_SECANT . RootFinder::kGSL_STEFFENSON . This class does not cupport copying ; Definition at line 73 of file RootFinder.h. Public Types; enum  EType { ;   kBRENT; , kGSL_BISECTION; , kGSL_FALSE_POS; , kGSL_BRENT; , ;   kGSL_NEWTON; , kGSL_SECANT; , kGSL_STEFFENSON. };  . Public Member Functions;  RootFinder (const RootFinder &)=delete;  ;  RootFinder (RootFinder &&)=delete;  ;  RootFinder (RootFinder::EType type=RootFinder::kBRENT);  Construct a Root-Finder algorithm. ;  ; virtual ~RootFinder ();  ; int Iterate ();  Perform a single iteration and return the Status. ;  ; int Iterations () const;  Return the number of iteration performed to find the Root. ;  ; const char * Name () const;  Return the current and latest estimate of the lower value of the Root-finding interval (for bracketing algorithms) ;  ; RootFinder & operator= (const RootFinder &rhs)=delete;  ; RootFinder & operator= (RootFinder &&rhs)=delete;  ; double Root () const;  Return the current and latest estimate of the Root. ;  ; bool SetFunction (const IGenFunction &f, double xlow, double xup);  Provide to the solver the function and the initial search interval [xlow, xup] for algorithms not using derivatives (bracketing algorithms) The templated function f must be of a type implementing the operator() method, double operator() ( double x ) Returns non zero if interval is not valid (i.e. ;  ; bool SetFunction (const IGradFunction &f, double xstart);  Provide to the solver the function and an initial estimate of the root, for algorithms using derivatives. ;  ; bool SetMethod (RootFinder::EType type=RootFinder::kBRENT);  ; templ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1RootFinder.html:1519,perform,performed,1519,doc/master/classROOT_1_1Math_1_1RootFinder.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1RootFinder.html,1,['perform'],['performed']
Performance,"als(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTPointSet3DGL::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTPointSet3DGL::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidTPointSet3DGL::SetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tTPointSet3DGL::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; TEveTrackGL(); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveTrackGL.html:1868,cache,cached,1868,root/html602/TEveTrackGL.html,https://root.cern,https://root.cern/root/html602/TEveTrackGL.html,2,['cache'],['cached']
Performance,"alse);  Factory method to resurrect a field from the stored on-disk type information. ;  ; static std::unique_ptr< RDeleter > GetDeleterOf (const RFieldBase &other);  ; static Internal::RColumn * GetPrincipalColumnOf (const RFieldBase &other);  Fields may need direct access to the principal column of their sub fields, e.g. in RRVecField::ReadBulk. ;  ;  Protected Attributes inherited from ROOT::Experimental::RFieldBase; Internal::RColumn * fAuxiliaryColumn = nullptr;  Some fields have a second column in its column representation. ;  ; std::vector< std::unique_ptr< Internal::RColumn > > fAvailableColumns;  The columns are connected either to a sink or to a source (not to both); they are owned by the field. ;  ; std::vector< std::reference_wrapper< const ColumnRepresentation_t > > fColumnRepresentatives;  Pointers into the static vector GetColumnRepresentations().GetSerializationTypes() when SetColumnRepresentatives is called. ;  ; std::uint32_t fOnDiskTypeChecksum = 0;  TClass checksum cached from the descriptor after a call to ConnectPageSource(). ;  ; std::uint32_t fOnDiskTypeVersion = kInvalidTypeVersion;  C++ type version cached from the descriptor after a call to ConnectPageSource() ;  ; RFieldBase * fParent;  Sub fields point to their mother field. ;  ; Internal::RColumn * fPrincipalColumn = nullptr;  All fields that have columns have a distinct main column. ;  ; std::vector< ReadCallback_t > fReadCallbacks;  List of functions to be called after reading a value. ;  ; std::vector< std::unique_ptr< RFieldBase > > fSubFields;  Collections and classes own sub fields. ;  ; int fTraits = 0;  Properties of the type that allow for optimizations of collections of that type. ;  ; std::string fTypeAlias;  A typedef or using name that was used when creating the field. ;  . #include <ROOT/RField.hxx>. Inheritance diagram for ROOT::Experimental::RField< T, typename >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RField.html:12426,cache,cached,12426,doc/master/classROOT_1_1Experimental_1_1RField.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RField.html,1,['cache'],['cached']
Performance,"alse;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions; void addParameters (RooAbsCollection &params, const RooArgSet *nset=nullptr, bool stripDisconnected=true) const;  Add all parameters of the function and its daughters to params. ;  ; bool callRedirectServersHook (RooAbsCollection const &newSet, bool mustReplaceAll, bool nameChange, bool isRecursionStep);  Private helper function for RooAbsArg::redirectServers(). ;  ; std::size_t getParametersSizeEstimate (const RooArgSet *nset=nullptr) const;  Obtain an estimate of the number of parameters of the function and its daughters. ;  ; RefCountListLegacyIterator_t * makeLegacyIterator (const RefCountList_t &list) const;  ; void substituteServer (RooAbsArg *oldServer, RooAbsArg *newServer);  Set by the RooFitDriver for this arg to retrieve its result in the run context. ;  . Friends; std::ostream & ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:38442,cache,cache,38442,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['cache']
Performance,"also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Interface function to create an internal cache object that represent; each cached function configuration. This interface allows to create and; return a class derived from RooAbsCachedReal::FuncCacheElem so that; a derived class fillCacheObject implementation can utilize extra functionality; defined in such a derived cache class. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Update contents of cache histogram by resampling the input function. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. void operModeHook(). RooCachedReal(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooCachedReal(*this,newname); }. void setCdfBoundaries(Bool_t flag); If flag is true the RooHistFunc that represent the cache histogram; will use special boundary conditions for use with cumulative distribution; functions: at the lower bound the function is forced to converge at zero and the upper; bound is the function is forced to converge at 1.0. Bool_t getCdfBoundaries() const; If true the c.d.f boundary mode is active. Bool_t cacheSource() const; { return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedReal.html:39227,cache,cache,39227,root/html534/RooCachedReal.html,https://root.cern,https://root.cern/root/html534/RooCachedReal.html,2,['cache'],['cache']
Performance,"also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure initiated during the loading of a library. Bool_t HasDictionarySelection(const char* clname); Check whether a class has a dictionary or ROOT can load one.; This is equivalent to ask HasDictionary() or whether a library is known; where it can be loaded from, or whether a Dictionary function is; available because the class's dictionary library was already loaded. void GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); Verify the base classes always. void GetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); Verify the Data Members. void GetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); Pair is a special case and we have to check its elements for missing dictionaries; Pair is a transparent container so we should always look at its. void GetMissingDictionariesWithRecursionCheck(TCollection& result, TCollection& visited, bool recurse); From the second level of recursion onwards it is different state check. void GetMissingDictionaries(THashTable& result, bool recurse = false); Get the classes that have a missing dictionary starting from this one.; With recurse = false the classes checked for missing dictionaries are:; th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:39497,load,loaded,39497,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,4,['load'],['loaded']
Performance,"alternate"".; For example, with arr1[3] and arr2[2]; tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr[0]+arr2[0] ; arr[1]+arr2[1] and arr[1]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:31434,load,load,31434,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,1,['load'],['load']
Performance,aluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; vector<Int_t>_catRefReference valyes for categories; RooListProxy_catSetList of categories to check; TIterator*_catSetIter! do not persist; Bool_t_checkValCheck contents as well if true; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; vector<Double_t>_realRefReference values for reals; RooListP,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChangeTracker.html:31058,cache,cache,31058,root/html526/RooChangeTracker.html,https://root.cern,https://root.cern/root/html526/RooChangeTracker.html,3,['cache'],['cache']
Performance,aluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; vector<Int_t>_catRefReference valyes for categories; RooListProxy_catSetList of categories to check; TIterator*_catSetIter! do not persist; Bool_t_checkValCheck contents as well if true; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; vector<Double_t>_realRefReference values for reals; RooL,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooChangeTracker.html:32100,cache,cache,32100,root/html532/RooChangeTracker.html,https://root.cern,https://root.cern/root/html532/RooChangeTracker.html,1,['cache'],['cache']
Performance,"alue gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if they put limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakness is that it depends heavily on; knowledge of the first derivatives, and fails miserably if they are very; inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. Getting the right minimum with limits. If MIGRAD converges normally to a point where no parameter is near one of; its limits, then the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMinuit.html:4772,perform,perform,4772,root/html602/TMinuit.html,https://root.cern,https://root.cern/root/html602/TMinuit.html,4,['perform'],['perform']
Performance,"alue of the version, let's restore the sign.; 7261 if (version == -1); 7262 info->SetClassVersion(-1);; 7263 ; 7264 if( !info->BuildFor( this ) ) {; 7265 delete info;; 7266 return nullptr;; 7267 }; 7268 ; 7269 if (!info->IsCompiled()) {; 7270 // Streamer info has not been compiled, but exists.; 7271 // Therefore it was read in from a file and we have to do schema evolution?; 7272 // Or it didn't have a dictionary before, but does now?; 7273 info->BuildOld();; 7274 }; 7275 ; 7276 //----------------------------------------------------------------------------; 7277 // Cache this streamer info; 7278 /////////////////////////////////////////////////////////////////////////////; 7279 ; 7280 if (!arr) {; 7281 arr = new TObjArray(16, -2);; 7282 if (!fConversionStreamerInfo.load()) {; 7283 fConversionStreamerInfo = new std::map<std::string, TObjArray*>();; 7284 }; 7285 (*fConversionStreamerInfo)[cl->GetName()] = arr;; 7286 }; 7287 arr->AddAtAndExpand( info, info->GetClassVersion() );; 7288 ; 7289 return info;; 7290}; 7291 ; 7292////////////////////////////////////////////////////////////////////////////////; 7293/// Register the StreamerInfo in the given slot, change the State of the; 7294/// TClass as appropriate.; 7295 ; 7296void TClass::RegisterStreamerInfo(TVirtualStreamerInfo *info); 7297{; 7298 if (info) {; 7299 R__LOCKGUARD(gInterpreterMutex);; 7300 Int_t slot = info->GetClassVersion();; 7301 if (fStreamerInfo->GetSize() > (slot-fStreamerInfo->LowerBound()); 7302 && fStreamerInfo->At(slot) != nullptr; 7303 && fStreamerInfo->At(slot) != info) {; 7304 Error(""RegisterStreamerInfo"",; 7305 ""Register StreamerInfo for %s on non-empty slot (%d)."",; 7306 GetName(),slot);; 7307 }; 7308 fStreamerInfo->AddAtAndExpand(info, slot);; 7309 if (fState <= kForwardDeclared) {; 7310 fState = kEmulated;; 7311 if (fCheckSum==0 && slot==fClassVersion) fCheckSum = info->GetCheckSum();; 7312 }; 7313 }; 7314}; 7315 ; 7316//////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:279477,load,load,279477,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"alue of the version, let's restore the sign.; 7328 if (version == -1); 7329 info->SetClassVersion(-1);; 7330 ; 7331 if( !info->BuildFor( this ) ) {; 7332 delete info;; 7333 return nullptr;; 7334 }; 7335 ; 7336 if (!info->IsCompiled()) {; 7337 // Streamer info has not been compiled, but exists.; 7338 // Therefore it was read in from a file and we have to do schema evolution?; 7339 // Or it didn't have a dictionary before, but does now?; 7340 info->BuildOld();; 7341 }; 7342 ; 7343 //----------------------------------------------------------------------------; 7344 // Cache this streamer info; 7345 /////////////////////////////////////////////////////////////////////////////; 7346 ; 7347 if (!arr) {; 7348 arr = new TObjArray(16, -2);; 7349 if (!fConversionStreamerInfo.load()) {; 7350 fConversionStreamerInfo = new std::map<std::string, TObjArray*>();; 7351 }; 7352 (*fConversionStreamerInfo)[cl->GetName()] = arr;; 7353 }; 7354 arr->AddAtAndExpand( info, info->GetClassVersion() );; 7355 ; 7356 return info;; 7357}; 7358 ; 7359////////////////////////////////////////////////////////////////////////////////; 7360/// Register the StreamerInfo in the given slot, change the State of the; 7361/// TClass as appropriate.; 7362 ; 7363void TClass::RegisterStreamerInfo(TVirtualStreamerInfo *info); 7364{; 7365 if (info) {; 7366 R__LOCKGUARD(gInterpreterMutex);; 7367 Int_t slot = info->GetClassVersion();; 7368 if (fStreamerInfo->GetSize() > (slot-fStreamerInfo->LowerBound()); 7369 && fStreamerInfo->At(slot) != nullptr; 7370 && fStreamerInfo->At(slot) != info) {; 7371 Error(""RegisterStreamerInfo"",; 7372 ""Register StreamerInfo for %s on non-empty slot (%d)."",; 7373 GetName(),slot);; 7374 }; 7375 fStreamerInfo->AddAtAndExpand(info, slot);; 7376 if (fState <= kForwardDeclared) {; 7377 fState = kEmulated;; 7378 if (fCheckSum==0 && slot==fClassVersion) fCheckSum = info->GetCheckSum();; 7379 }; 7380 }; 7381}; 7382 ; 7383//////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:282228,load,load,282228,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"alue the integral over the function; represented by this histogram. Double_t sum(const RooArgSet& sumSet, const RooArgSet& sliceSet, Bool_t correctForBinSize, Bool_t inverseCorr, const map<const RooAbsArg*,pair<Double_t,Double_t> >& ranges); Return the sum of the weights of a multi-dimensional slice of the histogram; by summing only over the dimensions specified in sumSet. The coordinates of all other dimensions are fixed to those given in sliceSet. If correctForBinSize is specified, the sum of weights; is multiplied by the M-dimensional bin volume, (M = N(sumSet)),; or the fraction of it that falls inside the range rangeName,; making the return value the integral over the function; represented by this histogram. If correctForBinSize is not specified, the weights are multiplied by the; fraction of the bin volume that falls inside the range, i.e. a factor or; binVolumeInRange/totalBinVolume. void calculatePartialBinVolume(const RooArgSet& dimSet) const; Fill the transient cache with partial bin volumes with up-to-date; values for the partial volume specified by observables 'dimSet'. Int_t numEntries() const; Return the number of bins. Double_t sumEntries() const. Double_t sumEntries(const char* cutSpec, const char* cutRange = 0) const; Return the sum of weights in all entries matching cutSpec (if specified); and in named range cutRange (if specified); Return the. void reset(); Reset all bin weights to zero. const RooArgSet* get(Int_t masterIdx) const; Return an argset with the bin center coordinates for; bin sequential number 'masterIdx'. For iterative use. const RooArgSet* get(const RooArgSet& coord) const; Return a RooArgSet with center coordinates of the bin; enclosing the point 'coord'. Double_t binVolume(const RooArgSet& bin); Return the volume of the bin enclosing coordinates 'coord'. void setAllWeights(Double_t value); Set all the event weight of all bins to the specified value. TIterator* sliceIterator(RooAbsArg& sliceArg, const RooArgSet& otherArgs); Create a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataHist.html:34165,cache,cache,34165,root/html602/RooDataHist.html,https://root.cern,https://root.cern/root/html602/RooDataHist.html,2,['cache'],['cache']
Performance,"alue to be returned for points outside the region ;  ; double XMax () const;  ; double XMin () const;  ; double YMax () const;  ; double YMin () const;  ; double ZOuterValue () const;  return the user defined Z-outer value ;  . Protected Member Functions; unsigned int Cell (unsigned int x, unsigned int y) const;  ; int CellX (double x) const;  ; int CellY (double y) const;  . Protected Attributes; std::set< unsigned int > fCells [(fNCells+1) *(fNCells+1)];  ! grid cells with containing triangles ;  ; bool fInit;  ! True if FindAllTriangles() has been performed ;  ; int fNdt;  ! Number of Delaunay triangles found ;  ; int fNpoints;  ! Number of data points ;  ; double fOffsetX;  ! Normalization offset X ;  ; double fOffsetY;  ! Normalization offset Y ;  ; double fScaleFactorX;  ! Normalization factor X ;  ; double fScaleFactorY;  ! Normalization factor Y ;  ; Triangles fTriangles;  ! Triangles of Triangulation ;  ; const double * fX;  ! Pointer to X array (managed externally) ;  ; double fXCellStep;  ! inverse denominator to calculate X cell = fNCells / (fXNmax - fXNmin) ;  ; std::vector< double > fXN;  ! normalized X ;  ; double fXNmax;  ! Maximum value of fXN ;  ; double fXNmin;  ! Minimum value of fXN ;  ; const double * fY;  ! Pointer to Y array ;  ; double fYCellStep;  ! inverse denominator to calculate X cell = fNCells / (fYNmax - fYNmin) ;  ; std::vector< double > fYN;  ! normalized Y ;  ; double fYNmax;  ! Maximum value of fYN ;  ; double fYNmin;  ! Minimum value of fYN ;  ; const double * fZ;  ! Pointer to Z array ;  ; double fZout;  ! Height for points lying outside the convex hull ;  . Static Protected Attributes; static const int fNCells = 25;  ! number of cells to divide the normalized space ;  . Private Member Functions;  Delaunay2D (const Delaunay2D &);  ; void DoFindTriangles ();  internal function to find the triangle use Triangle or CGAL if flag is set ;  ; double DoInterpolateNormalized (double x, double y);  internal method to compute the interpol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Delaunay2D.html:3601,perform,performed,3601,doc/master/classROOT_1_1Math_1_1Delaunay2D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Delaunay2D.html,1,['perform'],['performed']
Performance,"alue(Int_t value); // *SIGNAL*; void PrintValue() const { printf(""value = %d\n"", fValue); }; };; void A::SetValue(Int_t value) { // Set new value; // Emit signal ""SetValue(Int_t)"" with a single parameter; if (value != fValue) {; fValue = value;; Emit(""SetValue(Int_t)"", fValue);; }; }; // Main program; #ifdef STANDALONE; int main(int argc, char **argv) {; A* a = new A();; A* b = new A();; a->Connect(""SetValue(Int_t)"", ""A"", b, ""SetValue(Int_t)"");; printf(""n******* Test of SetValue(Int_t) signal *******n"");; b->SetValue(10);; printf(""nt***** b before ******n"");; b->PrintValue();; a->SetValue(20);; printf(""t***** b after a->SetValue(20) ******n"");; b->PrintValue();; return 0;; }; #endif; ACLiC simplifies this procedure and allows the dictionary generation by:; root[] .L tst.C++; It will create the shared library tst_C.so.; The next line will create an executable:; g++ -otst tst.C `root-config --cflags --libs` ./tst_C.so -DSTANDALONE; The library tst_C.so is a dynamically loaded library and should be located in $LD_LIBRARY_PATH. The current working directory should be added to $LD_LIBRARY_PATH via:; export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./; To run it, you just do:; ./tst; 25.8 Widgets in Detail; 25.8.1 Buttons; Buttons are a popular group of widgets designed to provide specific interfaces for user interaction. TGButton is an abstract class defining the general button behavior: width, height, state, its group, tool tip text, etc.; There are two main groups of buttons: command buttons with a text or graphics inside that indicate the action to be accomplished and option buttons well known as radio and check buttons that select or change properties. The first group is presented in ROOT by TGPictureButton and TGTextButton classes. They yield an action as soon as they are clicked. It can be opening/closing a dialog box or invoking a specific function in an application. Remember the Draw button from the example. The radio and check buttons from the second group are used to sel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1175549,load,loaded,1175549,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance,"alue; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_asymLeft; Bool_t_asymRight; Double_t_binWidth; Double_t*_dataPts[_nEvents]; Double_t*_dataWgts[_nEvents]; Double_t_hi; Double_t_lo; Double_t_lookupTable[1001]; Bool_t_mirrorLeft; Bool_t_mirrorRight; Int_t_nEvents; static RooKeysPdf::(anonymous)_nPoints; static const Double_t_nSigma!; Double_t_rho; Double_t_sumWgt; Char_t_varName[128]; Double_t*_weights[_nEvents]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooKeysPdf(); coverity[UNINIT_CTOR]. RooKeysPdf(const char* name, const char* title, RooAbsReal& x, RooDataSet& data, RooKeysPdf::Mirror mirror = NoMirror, Double_t rho = 1); cache stuff about x. RooKeysPdf(const char* name, const char* title, RooAbsReal& x, RooRealVar& xdata, RooDataSet& data, RooKeysPdf::Mirror mirror = NoMirror, Double_t rho = 1); cache stuff about x. RooKeysPdf(const RooKeysPdf& other, const char* name = 0). ~RooKeysPdf(). void LoadDataSet(RooDataSet& data). Double_t evaluate() const. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const. Int_t getMaxVal(const RooArgSet& vars) const. Double_t maxVal(Int_t code) const. Double_t g(Double_t x, Double_t sigma) const. TObject* clone(const char* newname) const; {return new RooKeysPdf(*this,newname); }. » Last changed: Tue Jun 2 15:31:44 2015 » Last generated: 2015-06-02 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooKeysPdf.html:46739,cache,cache,46739,root/html604/RooKeysPdf.html,https://root.cern,https://root.cern/root/html604/RooKeysPdf.html,1,['cache'],['cache']
Performance,"alue; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optional",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf.html:44954,perform,performance,44954,root/html532/RooAbsPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf.html,1,['perform'],['performance']
Performance,"alue; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxyRooAbsHiddenReal::_stateProxy to hiding state category; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; RooRealProxy_value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooUnblindOffset(); Default constructor. RooUnblindOffset(const char* name, const char* title, const char* blin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindOffset.html:36940,cache,cache,36940,root/html602/RooUnblindOffset.html,https://root.cern,https://root.cern/root/html602/RooUnblindOffset.html,4,['cache'],['cache']
Performance,"alue; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxyRooAbsHiddenReal::_stateProxy to hiding state category; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; RooRealProxy_value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooUnblindUniform(); Default constructor. RooUnblindUniform(const char* name, const char* title, const char* bl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindUniform.html:36269,cache,cache,36269,root/html602/RooUnblindUniform.html,https://root.cern,https://root.cern/root/html602/RooUnblindUniform.html,4,['cache'],['cache']
Performance,"alue; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,int>funcFunction pointer reference; RooRealProxyxArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction1Ref<VO,VI> Streamer(TBuffer& ); Custom streamer for function pointer reference object. When w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction1Binding_double_int_.html:36607,cache,cache,36607,root/html602/RooCFunction1Binding_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction1Binding_double_int_.html,4,['cache'],['cache']
Performance,"alue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Int_t_arrSizeSize of the weight array; Bool_t*_binValid! Valid bins with current range definition; Double_t*_binv[_arrSize] Bin volume array ; TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; Int_t_curIndexCurrent index; Double_t_curSumW2Current sum of weights^2; Double_t_curVolumeVolume of bin enclosing current coordinate; Double_t_curWeightWeight associated with the current coordinate; Double_t_curWgtErrHiError on weight associated with the current coordinate; Double_t_curWgtErrLoError on weight associated with the current coordinate; TDirectory*RooDirItem::_dir! Associated directory; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; Double_t*_errHi[_arrSize] High-side error on weight array; Double_t*_errLo[_arrSize] Low-side error on weight array; vector<Int_t>_idxMultMultiplier jump table for index calculation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; list<const RooAbsBinning*>_lvbins! List of used binnings associated with lvalues; list<RooAbsLValue*>_lvvars! List of observables casted as RooAbsLValue; static Int_tRooPrintable::_nameLength; vector<Double_t>*_pbinv! Partial bin volume array; RooCacheManager<std::vector<Double_t> >_pbinvCacheMgr! Cache manager for arrays of partial bin volumes; TIterator*_realIter! Iterator over realVars; RooArgSet_realVarsReal dimensions of the dataset ; Double_t*_sumw2[_arrSize] Sum of weights^2; RooArgSetRooAbsData::_varsDimensions of this data set; Double_t*_wgt[_arrSize] Weight array; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooDataHist(); Default constructor. RooDataHist(const char* name, const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataHist.html:16693,cache,cached,16693,root/html526/RooDataHist.html,https://root.cern,https://root.cern/root/html526/RooDataHist.html,4,['cache'],['cached']
Performance,"alueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooKeysPdf.html:39647,cache,cache,39647,root/html528/RooKeysPdf.html,https://root.cern,https://root.cern/root/html528/RooKeysPdf.html,48,['cache'],['cache']
Performance,"alueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; TString_sigCatNameName of accept state of accept/reject category; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooEfficiency.html:39319,cache,cache,39319,root/html530/RooEfficiency.html,https://root.cern,https://root.cern/root/html530/RooEfficiency.html,1,['cache'],['cache']
Performance,"alueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsAnaConvPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsAnaConvPdf::coefAnalyticalIntegral(Int_t coef,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDecay.html:2068,cache,cacheUniqueSuffix,2068,root/html532/RooDecay.html,https://root.cern,https://root.cern/root/html532/RooDecay.html,1,['cache'],['cacheUniqueSuffix']
Performance,"alueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsAnaConvPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBCPEffDecay.html:2370,cache,cacheUniqueSuffix,2370,root/html532/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html532/RooBCPEffDecay.html,5,['cache'],['cacheUniqueSuffix']
Performance,"alueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsAnaConvPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsAnaConvPdf::coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDecay.html:2068,cache,cacheUniqueSuffix,2068,root/html528/RooDecay.html,https://root.cern,https://root.cern/root/html528/RooDecay.html,2,['cache'],['cacheUniqueSuffix']
Performance,"alueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsAnaConvPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBCPEffDecay.html:2370,cache,cacheUniqueSuffix,2370,root/html528/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html528/RooBCPEffDecay.html,10,['cache'],['cacheUniqueSuffix']
Performance,"alueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsSelfCachedReal.html:2575,cache,cacheUniqueSuffix,2575,root/html528/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html528/RooAbsSelfCachedReal.html,4,['cache'],['cacheUniqueSuffix']
Performance,"alueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsSelfCachedReal.html:2575,cache,cacheUniqueSuffix,2575,root/html530/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html530/RooAbsSelfCachedReal.html,8,['cache'],['cacheUniqueSuffix']
Performance,"alueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidsetAnaIntZ(Double_t z); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniq",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMultiVarGaussian.html:27189,cache,cache,27189,root/html526/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html526/RooMultiVarGaussian.html,1,['cache'],['cache']
Performance,"alueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedReal.html:23756,cache,cache,23756,root/html532/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedReal.html,1,['cache'],['cache']
Performance,"alues from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TF1*func; RooListProxyolist; RooListProxyplist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTFnBinding.html:32879,cache,cache,32879,root/html532/RooTFnBinding.html,https://root.cern,https://root.cern/root/html532/RooTFnBinding.html,1,['cache'],['cache']
Performance,"alues, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a provided dataset ('projData'), to correctly; project out data dependents that are not properly described by the PDF (e.g. per-event errors). The functions value can be multiplied with an optional scale factor. The interpretation; of the scale factor is unique for generic real functions, for PDFs there are various interpretations; possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1., RooAbsReal::ScaleType stype = Relative, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsReal.html:56295,perform,performed,56295,root/html602/RooAbsReal.html,https://root.cern,https://root.cern/root/html602/RooAbsReal.html,2,['perform'],['performed']
Performance,"alues, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a provided dataset ('projData'), to correctly; project out data dependents that are not properly described by the PDF (e.g. per-event errors). The functions value can be multiplied with an optional scale factor. The interpretation; of the scale factor is unique for generic real functions, for PDFs there are various interpretations; possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:50992,perform,performed,50992,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,4,['perform'],['performed']
Performance,always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_normSetPointer to set with observables used for normalization ; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Ro,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:32448,cache,cache,32448,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,1,['cache'],['cache']
Performance,always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Roo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsOptTestStatistic.html:33058,cache,cache,33058,root/html528/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html528/RooAbsOptTestStatistic.html,2,['cache'],['cache']
Performance,"alysisType fAnalysisType! the training typeDefinition Factory.h:221; TMVA::Factory::fJobNameTString fJobName! jobname, used as extension in weight file namesDefinition Factory.h:219; TMVA::Factory::HasMethodBool_t HasMethod(const TString &datasetname, const TString &title) constChecks whether a given method name is defined for a given dataset.Definition Factory.cxx:586; TMVA::Factory::GetROCCurveTGraph * GetROCCurve(DataLoader *loader, TString theMethodName, Bool_t setTitles=kTRUE, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)Argument iClass specifies the class to generate the ROC curve in a multiclass setting.Definition Factory.cxx:912; TMVA::Factory::BookMethodMethodBase * BookMethod(DataLoader *, TMVA::Types::EMVA, TString, TString, TMVA::Types::EMVA, TString)Definition Factory.h:102; TMVA::Factory::TrainAllMethodsForRegressionvoid TrainAllMethodsForRegression(void)Definition Factory.h:116; TMVA::Factory::EvaluateImportanceAllTH1F * EvaluateImportanceAll(DataLoader *loader, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")Definition Factory.cxx:2246; TMVA::Factory::SetVerbosevoid SetVerbose(Bool_t v=kTRUE)Definition Factory.cxx:343; TMVA::Factory::fgTargetFileTFile * fgTargetFile! ROOT output fileDefinition Factory.h:205; TMVA::Factory::fDefaultTrfsstd::vector< TMVA::VariableTransformBase * > fDefaultTrfs! list of transformations on default DataSetDefinition Factory.h:208; TMVA::Factory::GetMethodIMethod * GetMethod(const TString &datasetname, const TString &title) constReturns pointer to MVA that corresponds to given method title.Definition Factory.cxx:566; TMVA::Factory::DeleteAllMethodsvoid DeleteAllMethods(void)Delete methods.Definition Factory.cxx:324; TMVA::Factory::fTransformationsTString fTransformations! list of transformations to testDefinition Factory.h:212; TMVA::Factory::Greetingsvoid Greetings()Print welcome message.Definition Factory.cxx:295; TMVA::IMethodInterface for all concrete MVA method implementations.Definition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:18492,load,loader,18492,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,1,['load'],['loader']
Performance,"alyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidapplyWeightSquared(Bool_t flag); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsOptTestStatistic::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNLLVar.html:2113,cache,cacheUniqueSuffix,2113,root/html602/RooNLLVar.html,https://root.cern,https://root.cern/root/html602/RooNLLVar.html,2,['cache'],['cacheUniqueSuffix']
Performance,"am & ; fout, . const TString & ; className . ); const. Recursively descends a tree and writes the node instance to the output stream. ; Definition at line 2990 of file MethodBDT.cxx. ◆ MakeClassSpecific(). void TMVA::MethodBDT::MakeClassSpecific ; (; std::ostream & ; fout, . const TString & ; className . ); const. virtual . Make ROOT-independent C++ class for classifier response (classifier-specific implementation). ; Reimplemented from TMVA::MethodBase.; Definition at line 2756 of file MethodBDT.cxx. ◆ MakeClassSpecificHeader(). void TMVA::MethodBDT::MakeClassSpecificHeader ; (; std::ostream & ; fout, . const TString & ; className . ); const. virtual . Specific class header. ; Reimplemented from TMVA::MethodBase.; Definition at line 2876 of file MethodBDT.cxx. ◆ OptimizeTuningParameters(). std::map< TString, Double_t > TMVA::MethodBDT::OptimizeTuningParameters ; (; TString ; fomType = ""ROCIntegral"", . TString ; fitType = ""FitGA"" . ). virtual . Call the Optimizer with the set of parameters and ranges that are meant to be tuned. ; Reimplemented from TMVA::MethodBase.; Definition at line 1068 of file MethodBDT.cxx. ◆ PreProcessNegativeEventWeights(). void TMVA::MethodBDT::PreProcessNegativeEventWeights ; (; ). private . O.k. ; you know there are events with negative event weights. This routine will remove them by pairing them with the closest event(s) of the same event class with positive weights A first attempt is ""brute force"", I dont' try to be clever using search trees etc, just quick and dirty to see if the result is any good ; Definition at line 932 of file MethodBDT.cxx. ◆ PrivateGetMvaValue(). Double_t TMVA::MethodBDT::PrivateGetMvaValue ; (; const TMVA::Event * ; ev, . Double_t * ; err = nullptr, . Double_t * ; errUpper = nullptr, . UInt_t ; useNTrees = 0 . ). private . Return the MVA value (range [-1;1]) that classifies the event according to the majority vote from the total number of decision trees. ; Definition at line 2467 of file MethodBDT.cxx. ◆ ProcessO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:54687,tune,tuned,54687,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['tune'],['tuned']
Performance,"am (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; value_type evaluate () const override;  Calculate and return the value of the mapping function. ;  ; void recomputeShape () override;  No shape recomputation is necessary. This category does not depend on other categories. ;  ;  Protected Member Functions inherited from RooAbsCategory; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValueDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not check if type already exists. ;  ; void fillTreeBranch (TTree &t) override;  Fill tree branches associated with current object with current value. ;  ; bool isValid () const override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; RooCatType * retrieveLegacyState (value_type index) const;  Return the legacy RooCatType corresponding to index. If it doesn't exist, create one. ;  ; void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooThresholdCategory.html:35348,cache,cached,35348,doc/master/classRooThresholdCategory.html,https://root.cern,https://root.cern/doc/master/classRooThresholdCategory.html,1,['cache'],['cached']
Performance,"am a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported.; gPad must exist (otherwise this call has no sense), and; either it's a gl-pad or we are on OS X with --enable-cocoa. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCanvas.html:46202,load,loaded,46202,root/html534/TCanvas.html,https://root.cern,https://root.cern/root/html534/TCanvas.html,1,['load'],['loaded']
Performance,"am with the function after fitting. . ""0"" Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions. . ""R"" Fit using a fitting range specified in the function range with TF1::SetRange. . ""B"" Use this option when you want to fix or set limits on one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used. . ""C"" In case of linear fitting, do no calculate the chisquare (saves CPU time). . ""G"" Uses the gradient implemented in TF1::GradientPar for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function. . ""WIDTH"" Scales the histogran bin content by the bin width (useful for variable bins histograms) . ""SERIAL"" Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique . ""MULTITHREAD"" Forces usage of multi-thread execution whenever possible . The default fitting of an histogram (when no option is given) is perfomed as following:; a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; the full range of the histogram is used;; the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; for linear functions (polN, chenbyshev or formula expressions combined using operator ++) a linear minimization is used.; only the status of the fit is returned;; the fit is performed in Multithread whenever is enabled in ROOT;; only the last fitted function is saved in the histogram;; the histogram is drawn after fitting overalyed with the resulting fitting function. Minimizer Configuration; The Fit is perfomed using the default Minimizer, defined ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:128892,multi-thread,multi-thread,128892,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['multi-thread'],['multi-thread']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooAbsOptTestStatistic(); RooAbsOptTestStatistic(const RooAbsOptTestStatistic& other, const char* name = 0); RooAbsOptTestStatistic(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t cloneInputData = kTRUE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidseal(const char* notice = """"); const char*sealNotice() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsOptTestStatistic.html:23973,cache,cache,23973,root/html602/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html,2,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooAbsTestStatistic(); RooAbsTestStatistic(const RooAbsTestStatistic& other, const char* name = 0); RooAbsTestStatistic(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsTestStatistic.html:23780,cache,cache,23780,root/html602/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsTestStatistic.html,2,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooChi2Var(const RooChi2Var& other, const char* name = 0); RooChi2Var(const char* name, const char* title, RooAbsPdf& pdf, RooDataHist& data, Bool_t extended = kFALSE, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE, RooDataHist::ErrorType = RooDataHist::SumW2); RooChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataHist& data, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChi2Var.html:23530,cache,cache,23530,root/html602/RooChi2Var.html,https://root.cern,https://root.cern/root/html602/RooChi2Var.html,2,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooDataWeightedAverage(); RooDataWeightedAverage(const RooDataWeightedAverage& other, const char* name = 0); RooDataWeightedAverage(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t showProgress = kFALSE, Bool_t verbose = kTRUE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidRooAbsOptTestStatistic::seal(const char* notice = """"); const char*RooAbsOptTestStatistic::sealNotice() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataWeightedAverage.html:23663,cache,cache,23663,root/html602/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html602/RooDataWeightedAverage.html,2,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooNLLVar(); RooNLLVar(const RooNLLVar& other, const char* name = 0); RooNLLVar(const char* name, const char* title, RooAbsPdf& pdf, RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none()); RooNLLVar(const char* name, const char* title, RooAbsPdf& pdf, RooAbsData& data, Bool_t extended, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNLLVar.html:23432,cache,cache,23432,root/html602/RooNLLVar.html,https://root.cern,https://root.cern/root/html602/RooNLLVar.html,2,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooRealIntegral(); RooRealIntegral(const RooRealIntegral& other, const char* name = 0); RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealIntegral.html:22499,cache,cache,22499,root/html602/RooRealIntegral.html,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html,2,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooXYChi2Var(); RooXYChi2Var(const RooXYChi2Var& other, const char* name = 0); RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidRooAbsOptTestStatistic::seal(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooXYChi2Var.html:23571,cache,cache,23571,root/html602/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html602/RooXYChi2Var.html,2,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); Bool_tRooAbsOptTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChi2Var.html:23164,cache,cache,23164,root/html526/RooChi2Var.html,https://root.cern,https://root.cern/root/html526/RooChi2Var.html,8,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); Bool_tsetData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:22020,cache,cache,22020,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,1,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsTestStatistic.html:22280,cache,cache,22280,root/html528/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html528/RooAbsTestStatistic.html,1,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsTestStatistic.html:21885,cache,cache,21885,root/html526/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsTestStatistic.html,1,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetCacheAllNumeric(Int_t ndim); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCacheNumeric(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealIntegral.html:20898,cache,cache,20898,root/html526/RooRealIntegral.html,https://root.cern,https://root.cern/root/html526/RooRealIntegral.html,2,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidseal(const char* notice = """"); const char*sealNotice() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); Bool_tsetData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsOptTestStatistic.html:22417,cache,cache,22417,root/html528/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html528/RooAbsOptTestStatistic.html,1,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tsetData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsTestStatistic.html:22758,cache,cache,22758,root/html532/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsTestStatistic.html,1,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetCacheAllNumeric(Int_t ndim); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCacheNumeric(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")ME",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealIntegral.html:21836,cache,cache,21836,root/html532/RooRealIntegral.html,https://root.cern,https://root.cern/root/html532/RooRealIntegral.html,1,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetCacheAllNumeric(Int_t ndim); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCacheNumeric(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealIntegral.html:22819,cache,cache,22819,root/html534/RooRealIntegral.html,https://root.cern,https://root.cern/root/html534/RooRealIntegral.html,1,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tsetData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:23800,cache,cache,23800,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,1,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tsetData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsTestStatistic.html:22372,cache,cache,22372,root/html530/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html530/RooAbsTestStatistic.html,1,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetCacheAllNumeric(Int_t ndim); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCacheNumeric(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealIntegral.html:21462,cache,cache,21462,root/html530/RooRealIntegral.html,https://root.cern,https://root.cern/root/html530/RooRealIntegral.html,1,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidRooAbsOptTestStatistic::seal(const char* notice = """"); const char*RooAbsOptTestStatistic::sealNotice() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooChi2Var.html:23808,cache,cache,23808,root/html532/RooChi2Var.html,https://root.cern,https://root.cern/root/html532/RooChi2Var.html,3,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidRooAbsOptTestStatistic::seal(const char* notice = """"); const char*RooAbsOptTestStatistic::sealNotice() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNLLVar.html:23478,cache,cache,23478,root/html532/RooNLLVar.html,https://root.cern,https://root.cern/root/html532/RooNLLVar.html,1,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidRooAbsOptTestStatistic::seal(const char* notice = """"); const char*RooAbsOptTestStatistic::sealNotice() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChi2Var.html:25239,cache,cache,25239,root/html534/RooChi2Var.html,https://root.cern,https://root.cern/root/html534/RooChi2Var.html,4,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidRooAbsOptTestStatistic::seal(const char* notice = """"); const char*RooAbsOptTestStatistic::sealNotice() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooChi2Var.html:23725,cache,cache,23725,root/html530/RooChi2Var.html,https://root.cern,https://root.cern/root/html530/RooChi2Var.html,4,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidseal(const char* notice = """"); const char*sealNotice() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsOptTestStatistic.html:22861,cache,cache,22861,root/html532/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsOptTestStatistic.html,1,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidseal(const char* notice = """"); const char*sealNotice() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsOptTestStatistic.html:23987,cache,cache,23987,root/html534/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html,1,['cache'],['cache']
Performance,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidseal(const char* notice = """"); const char*sealNotice() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsOptTestStatistic.html:22509,cache,cache,22509,root/html530/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html,1,['cache'],['cache']
Performance,"am, bool& status); Compute lower limit, check first if limit has been computed; status is a boolean flag which will b set to false in case of error; and is true if calculation is succesfull; in case of error return also a lower limit value of zero. Double_t UpperLimit(const RooRealVar& param, bool& status); Compute upper limit, check first if limit has been computed; status is a boolean flag which will b set to false in case of error; and is true if calculation is succesfull; in case of error return also a lower limit value of zero. void ResetLimits(); reset map with cached limits - called every time the test size or CL has been changed. bool CreateMinimizer(); internal function to create minimizer object needed to find contours or interval limits; (running MINOS).; Minimizer must be Minuit or Minuit2. bool FindLimits(const RooRealVar& param, double& lower, double& upper); Method to find both lower and upper limits using MINOS; If cached values exist (limits have been already found) return them in that case; check first if limit has been computed; otherwise compute limit using MINOS; in case of failure lower and upper will mantain previous value (will not be modified). Int_t GetContourPoints(const RooRealVar& paramX, const RooRealVar& paramY, Double_t* x, Double_t* y, Int_t npoints = 30); use Minuit to find the contour of the likelihood function at the desired CL. explicit LikelihoodInterval(const char* name = 0); defult constructor. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (e.g 0.682 for a 1-sigma interval). {fConfidenceLevel = cl; ResetLimits(); }. Double_t ConfidenceLevel() const; return confidence level. {return fConfidenceLevel;}. Double_t LowerLimit(const RooRealVar& param); return the lower bound of the interval on a given parameter. { bool ok; return LowerLimit(param,ok); }. Double_t UpperLimit(const RooRealVar& param); return the upper bound of the interval on a given parameter. { bool ok; return UpperLimit(param,ok); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__LikelihoodInterval.html:10086,cache,cached,10086,root/html528/RooStats__LikelihoodInterval.html,https://root.cern,https://root.cern/root/html528/RooStats__LikelihoodInterval.html,3,['cache'],['cached']
Performance,"am, bool& status); Compute lower limit, check first if limit has been computed; status is a boolean flag which will b set to false in case of error; and is true if calculation is successful; in case of error return also a lower limit value of zero. Double_t UpperLimit(const RooRealVar& param, bool& status); Compute upper limit, check first if limit has been computed; status is a boolean flag which will b set to false in case of error; and is true if calculation is successful; in case of error return also a lower limit value of zero. void ResetLimits(); reset map with cached limits - called every time the test size or CL has been changed. bool CreateMinimizer(); internal function to create minimizer object needed to find contours or interval limits; (running MINOS).; Minimizer must be Minuit or Minuit2. bool FindLimits(const RooRealVar& param, double& lower, double& upper); Method to find both lower and upper limits using MINOS; If cached values exist (limits have been already found) return them in that case; check first if limit has been computed; otherwise compute limit using MINOS; in case of failure lower and upper will mantain previous value (will not be modified). Int_t GetContourPoints(const RooRealVar& paramX, const RooRealVar& paramY, Double_t* x, Double_t* y, Int_t npoints = 30); use Minuit to find the contour of the likelihood function at the desired CL. explicit LikelihoodInterval(const char* name = 0); default constructor. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (e.g 0.682 for a 1-sigma interval). {fConfidenceLevel = cl; ResetLimits(); }. Double_t ConfidenceLevel() const; return confidence level. {return fConfidenceLevel;}. Double_t LowerLimit(const RooRealVar& param); return the lower bound of the interval on a given parameter. { bool ok; return LowerLimit(param,ok); }. Double_t UpperLimit(const RooRealVar& param); return the upper bound of the interval on a given parameter. { bool ok; return UpperLimit(param,ok);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__LikelihoodInterval.html:10184,cache,cached,10184,root/html534/RooStats__LikelihoodInterval.html,https://root.cern,https://root.cern/root/html534/RooStats__LikelihoodInterval.html,3,['cache'],['cached']
Performance,"am.weights.xml␛[0m; : writing foam DiscrFoam to file; : Foams written to file: ␛[0;36mdataset/weights/TMVAClassification_PDEFoam.weights_foams.root␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_PDEFoam.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: KNN for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ KNN ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The k-nearest neighbor (k-NN) algorithm is a multi-dimensional classification; : and regression algorithm. Similarly to other TMVA algorithms, k-NN uses a set of; : training events for which a classification category/regression target is known. ; : The k-NN method compares a test event to all training events using a distance ; : function, which is an Euclidean distance in a space defined by the input variables. ; : The k-NN method, as implemented in TMVA, uses a kd-tree algorithm to perform a; : quick search for the k events with shortest distance to the test event. The method; : returns a fraction of signal events among the k neighbors. It is recommended; : that a histogram which stores the k-NN decision variable is binned with k+1 bins; : between 0 and 1.; : ; : ␛[1m--- Performance tuning via configuration options: ␛[0m; : ; : The k-NN method estimates a density of signal and background events in a ; : neighborhood around the test event. The method assumes that the density of the ; : signal and background events is uniform and constant within the neighborhood. ; : k is an adjustable parameter and it determines an average size of the ; : neighborhood. Small k values (less than 10) are sensitive to statistical ; : fluctuations and large (greater than 100) values might not sufficiently capture ; : local differences between events in the training set. The speed of the k-NN; : method also increases with larger values of k. ; : ; : The k-NN method assigns equal weight to a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:32794,perform,perform,32794,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['perform']
Performance,"ame ""Peaks""; f#define f(i)Definition RSha256.hxx:104; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TMacroClass supporting a collection of lines with C++ code.Definition TMacro.h:31; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; mTMarker mDefinition textangle.C:8. Definition at line 31 of file TMacro.h. Public Member Functions;  TMacro ();  Create an empty macro, use AddLine() or ReadFile() to fill this macro. ;  ;  TMacro (const char *name, const char *title="""");  Create a macro with a name and a title. ;  ;  TMacro (const TMacro &);  Copy constructor. ;  ; virtual ~TMacro ();  Delete this macro. ;  ; virtual TObjString * AddLine (const char *text);  Add line with text in the list of lines of this macro. ;  ; void Browse (TBrowser *b) override;  When clicking in the browser, the following action is performed on this macro, depending the content of the variable TMacro.Browse. ;  ; virtual TMD5 * Checksum ();  Returns checksum of the current content. ;  ; virtual Longptr_t Exec (const char *params=nullptr, Int_t *error=nullptr);  Execute this macro with params, if params is 0, default parameters (set via SetParams) are used. ;  ; virtual TObjString * GetLineWith (const char *text) const;  Search the first line containing text. ;  ; TList * GetListOfLines () const;  ; TClass * IsA () const override;  ; virtual Bool_t Load () const;  Load the macro into the interpreter. ;  ; TMacro & operator= (const TMacro &);  Copy constructor. ;  ; void Paint (Option_t *option="""") override;  Execute this macro (called by TPad::Paint). ;  ; void Print (Option_t *option="""") const override;  Print contents of this macro. ;  ; virtual Int_t ReadFile (const char *filename);  Read lines in filename in this macro. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Sa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacro.html:2383,perform,performed,2383,doc/master/classTMacro.html,https://root.cern,https://root.cern/doc/master/classTMacro.html,1,['perform'],['performed']
Performance,"ame = ""Higgs_data.root""; inputFileLink = ""http://root.cern.ch/files/"" + inputFileName; ; ; if ROOT.gSystem.AccessPathName(inputFileName):; ROOT.Info(""TMVA_Higgs_Classification"", ""Download Higgs_data.root file""); TFile.SetCacheFileDir("".""); inputFile = TFile.Open(inputFileLink, ""CACHEREAD""); if inputFile is None:; raise FileNotFoundError(""Input file cannot be downloaded - exit""); else:; # file exists; inputFile = TFile.Open(inputFileName); ; ; # --- Register the training and test trees; signalTree = inputFile.Get(""sig_tree""); backgroundTree = inputFile.Get(""bkg_tree""); signalTree.Print(); ; ## Declare DataLoader(s); ; # The next step is to declare the DataLoader class that deals with input variables; # Define the input variables that shall be used for the MVA training; # note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; loader = TMVA.DataLoader(""dataset""); ; loader.AddVariable(""m_jj""); loader.AddVariable(""m_jjj""); loader.AddVariable(""m_lv""); loader.AddVariable(""m_jlv""); loader.AddVariable(""m_bb""); loader.AddVariable(""m_wbb""); loader.AddVariable(""m_wwbb""); ; # We set now the input data trees in the TMVA DataLoader class; # global event weights per tree (see below for setting event-wise weights); signalWeight = 1.0; backgroundWeight = 1.0; # You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight); loader.AddBackgroundTree(backgroundTree, backgroundWeight); ; # Set individual event weights (the variables must exist in the original TTree); # for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; # for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; # loader->SetBackgroundWeightExpression( ""weight"" );; ; ; # Apply additional cuts on the signal and background samples (can be different); mycuts = ROOT.TCut("""") # for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; mycutb = ROOT.TCut("""") # for example: TCut mycutb = ""abs(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:59425,load,loader,59425,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['load'],['loader']
Performance,"ame = 0); Copy constructor. Initializes in clean state so that upon eval; this instance will create its own server processes. ~RooRealMPFE(); Destructor. void initVars(); Initialize list of variables of front-end argument 'arg'. void initialize(); Initialize the remote process and message passing; pipes between current process and remote process. void serverLoop(); Server loop of remote processes. This function will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getVal(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) const; { return new RooRealMPFE(*this,newname); }. » Last changed: Tue Dec 14 15:30:40 2010 » Last generated: 2010-12-14 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealMPFE.html:35987,queue,queue,35987,root/html528/RooRealMPFE.html,https://root.cern,https://root.cern/root/html528/RooRealMPFE.html,2,"['optimiz', 'queue']","['optimize', 'queue']"
Performance,"ame = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. Int_t setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Setter function without integration set. Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. void insertObjectHook(RooAbsCacheElement& ); Interface function to perform post-insert operations on cached object. template <> void RooCacheManager<RooAbsCacheElement> ShowMembers(TMemberInspector& insp, char* parent); needed to avoid 'specialization after instantiation' problem in gcc. » Last changed: Mon Dec 7 13:47:00 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCacheManager_RooAbsCacheElement_.html:4627,cache,cacheSize,4627,root/html526/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html526/RooCacheManager_RooAbsCacheElement_.html,6,"['cache', 'perform']","['cache', 'cacheSize', 'cached', 'perform']"
Performance,"ame = x.frame(Title=""Projection on X with LLratio(y,z)>0.7"", Bins=40); dataSel.plotOn(frame); ; # Perform parallel projection using MC integration of pdf using given input dataSet.; # In self mode the data-weighted average of the pdf is calculated by splitting the; # input dataset in N equal pieces and calculating in parallel the weighted average; # one each subset. The N results of those calculations are then weighted into the; # final result; ; # Use four processes; model.plotOn(frame, ProjWData=dataSel, NumCPU=4); ; c = ROOT.TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf603_multicpu.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.130; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.130; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.010; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.140, 2 slices; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf603_multicpu.py. tutorialsroofitrf603_multicpu.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf603__multicpu_8py.html:3697,optimiz,optimization,3697,doc/master/rf603__multicpu_8py.html,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8py.html,1,['optimiz'],['optimization']
Performance,"ame of this TChain; and a title equal to the file name. So, to loop over the; TFiles that have been added to this chain:. TObjArray *fileElements=chain->GetListOfFiles();; TIter next(fileElements);; TChainElement *chEl=0;; while (( chEl=(TChainElement*)next() )) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. Return value:. If nentries>0 (including the default of kBigNumber) and no; wildcarding is used, ALWAYS returns 1 without regard to whether; the file exists or contains the correct tree. If wildcarding is used, regardless of the value of nentries,; returns the number of files matching the name without regard to; whether they contain the correct tree. If nentries<=0 and wildcarding is not used, return 1 if the file; exists and contains the correct tree and 0 otherwise. Int_t AddFile(const char* name, Long64_t nentries = kBigNumber, const char* tname = """"); -- Add a new file to this chain. If tname is specified, the chain will load the tree named tname; from the file, otherwise the original treename specified in the; TChain constructor will be used. A. If nentries <= 0, the file is opened and the tree header read; into memory to get the number of entries. B. If nentries > 0, the file is not opened, and nentries is assumed; to be the number of entries in the file. In this case, no check; is made that the file exists nor that the tree exists in the file.; This second mode is interesting in case the number of entries in; the file is already stored in a run database for example. C. If nentries == kBigNumber (default), the file is not opened.; The number of entries in each file will be read only when the file; is opened to read an entry. This option is the default and very; efficient if one processes the chain sequentially. Note that in; case GetEntry(entry) is called and entry refers to an entry in the; third file, for example, this forces the tree headers in the first; and second file to be read to find the number of entries in those; files. Note that i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TChain.html:30724,load,load,30724,root/html532/TChain.html,https://root.cern,https://root.cern/root/html532/TChain.html,1,['load'],['load']
Performance,"ame""); This function calculates the background spectrum in this histogram.; The background is returned as a histogram.; to be implemented (may be). Int_t ShowPeaks(Double_t sigma = 2, Option_t* option = """", Double_t threshold = 0.05); Interface to TSpectrum2::Search; the function finds peaks in this histogram where the width is > sigma; and the peak maximum greater than threshold*maximum bin content of this.; for more detauils see TSpectrum::Search.; note the difference in the default value for option compared to TSpectrum2::Search; option="""" by default (instead of ""goff""). void Smooth(Int_t ntimes = 1, Option_t* option = """"); Smooth bin contents of this 2-d histogram using kernel algorithms; similar to the ones used in the raster graphics community.; Bin contents in the active range are replaced by their smooth values.; If Errors are defined via Sumw2, they are also scaled and computed.; However, note the resulting errors will be correlated between different-bins, so; the errors should not be used blindly to perform any calculation involving several bins,; like fitting the histogram. One would need to compute also the bin by bin correlation matrix. 3 kernels are proposed k5a, k5b and k3a.; k5a and k5b act on 5x5 cells (i-2,i-1,i,i+1,i+2, and same for j); k5b is a bit more stronger in smoothing; k3a acts only on 3x3 cells (i-1,i,i+1, and same for j).; By default the kernel ""k5a"" is used. You can select the kernels ""k5b"" or ""k3a""; via the option argument.; If TAxis::SetRange has been called on the x or/and y axis, only the bins; in the specified range are smoothed.; In the current implementation if the first argument is not used (default value=1). implementation by David McKee (dmckee@bama.ua.edu). Extended by Rene Brun. void Streamer(TBuffer& ); Stream an object of class TH2. Int_t BufferFill(Double_t x, Double_t y, Double_t w). Int_t Fill(Double_t ). void FillN(Int_t , const Double_t* , const Double_t* , Int_t ); {;}. Double_t GetBinErrorLow(Int_t binx, Int_t biny);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH2.html:55128,perform,perform,55128,root/html534/TH2.html,https://root.cern,https://root.cern/root/html534/TH2.html,1,['perform'],['perform']
Performance,"ame(""myTree"", ""myFile.root""); sum = df.Filter(""x > 10"").Sum(""y""); print(sum.GetValue()). User code in the RDataFrame workflow; C++ code; In the simple example that was shown above, a C++ expression is passed to the Filter() operation as a string (""x > 0""), even if we call the method from Python. Indeed, under the hood, the analysis computations run in C++, while Python is just the interface language.; To perform more complex operations that don't fit into a simple expression string, you can just-in-time compile C++ functions - via the C++ interpreter cling - and use those functions in an expression. See the following snippet for an example:; # JIT a C++ function from Python; ROOT.gInterpreter.Declare(""""""; bool myFilter(float x) {; return x > 10;; }; """"""); ; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); # Use the function in an RDF operation; sum = df.Filter(""myFilter(x)"").Sum(""y""); print(sum.GetValue()); To increase the performance even further, you can also pre-compile a C++ library with full code optimizations and load the function into the RDataFrame computation as follows.; ROOT.gSystem.Load(""path/to/myLibrary.so"") # Library with the myFilter function; ROOT.gInterpreter.Declare('#include ""myLibrary.h""') # Header with the declaration of the myFilter function; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); sum = df.Filter(""myFilter(x)"").Sum(""y""); print(sum.GetValue()); A more thorough explanation of how to use C++ code from Python can be found in the PyROOT manual.; Python code; ROOT also offers the option to compile Python functions with fundamental types and arrays thereof using Numba. Such compiled functions can then be used in a C++ expression provided to RDataFrame.; The function to be compiled should be decorated with ROOT.Numba.Declare, which allows to specify the parameter and return types. See the following snippet for a simple example or the full tutorial here.; @ROOT.Numba.Declare([""float""], ""bool""); def myFilter(x):; return x > 10; ; df = ROOT.RDataFr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:80808,perform,performance,80808,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,6,"['load', 'optimiz', 'perform']","['load', 'optimizations', 'performance']"
Performance,"ame(). static const char * TSelHist::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 60 of file TSelHist.h. ◆ GetOutputList(). TList * TSelHist::GetOutputList ; (; ); const. inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 56 of file TSelHist.h. ◆ IsA(). TClass * TSelHist::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TSelector.; Definition at line 60 of file TSelHist.h. ◆ Process(). Bool_t TSelHist::Process ; (; Long64_t ; entry). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either TSelHist::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used. ; Reimplemented from TSelector.; Definition at line 267 of file TSelHist.cxx. ◆ SetInputList(). void TSelHist::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 55 of file TSelHist.h. ◆ SetObject(). void TSelHist::SetObject ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 54 of file TSelHist.h. ◆ SetOption(). void TSelHist::SetOption ; (; const char * ; option). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 53 of file TSelHist.h. ◆ SlaveBegin(). void TSelHist::SlaveBeg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelHist.html:15158,load,loaded,15158,doc/master/classTSelHist.html,https://root.cern,https://root.cern/doc/master/classTSelHist.html,1,['load'],['loaded']
Performance,"ame(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int OpenConne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSystem.html:34941,load,loaded,34941,root/html534/TSystem.html,https://root.cern,https://root.cern/root/html534/TSystem.html,1,['load'],['loaded']
Performance,"ame) const; 1580{; 1581 return (TStyle*)GetListOfStyles()->FindObject(name);; 1582}; 1583 ; 1584////////////////////////////////////////////////////////////////////////////////; 1585/// Return pointer to function with name.; 1586 ; 1587TObject *TROOT::GetFunction(const char *name) const; 1588{; 1589 if (!name || !*name); 1590 return nullptr;; 1591 ; 1592 static std::atomic<bool> isInited = false;; 1593 ; 1594 // Capture the state before calling FindObject as it could change; 1595 // between the end of FindObject and the if statement; 1596 bool wasInited = isInited.load();; 1597 ; 1598 auto f1 = fFunctions->FindObject(name);; 1599 if (f1 || wasInited); 1600 return f1;; 1601 ; 1602 // If 2 threads gets here at the same time, the static initialization ""lock""; 1603 // will stall one of them until ProcessLine is finished and both will return the; 1604 // correct answer.; 1605 // Note: if one (or more) thread(s) is suspended right after the 'isInited.load()`; 1606 // and restart after this thread has finished the initialization (i.e. a rare case),; 1607 // the only penalty we pay is a spurious 2nd lookup for an unknown function.; 1608 [[maybe_unused]] static const auto _res = []() {; 1609 gROOT->ProcessLine(""TF1::InitStandardFunctions();"");; 1610 isInited = true;; 1611 return true;; 1612 }();; 1613 return fFunctions->FindObject(name);; 1614}; 1615 ; 1616////////////////////////////////////////////////////////////////////////////////; 1617 ; 1618TFunctionTemplate *TROOT::GetFunctionTemplate(const char *name); 1619{; 1620 if (!gInterpreter) return nullptr;; 1621 ; 1622 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1623 ; 1624 return (TFunctionTemplate*)fFuncTemplate->FindObject(name);; 1625}; 1626 ; 1627////////////////////////////////////////////////////////////////////////////////; 1628/// Return pointer to global variable by name. If load is true force; 1629/// reading of all currently defined globals from CINT (more expensive).; 1630 ; 1631",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:61714,load,load,61714,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['load']
Performance,"ame);; 1552 altcl = TClass::GetClass(alternate.c_str(),/*load=*/ false,true);; 1553 if (altcl) {; 1554 newName.append(altcl->GetName());; 1555 newName.append(suffix);; 1556 return altcl;; 1557 }; 1558 }; 1559 }; 1560 }; 1561 newName.clear();; 1562 return 0;; 1563 }; 1564 ; 1565 TClass *FixCollectionV5(TClass *context, TClass *oldClass, TClass *newClass); 1566 {; 1567 assert(oldClass->GetCollectionProxy() && newClass->GetCollectionProxy());; 1568 ; 1569 TVirtualCollectionProxy *old = oldClass->GetCollectionProxy();; 1570 TVirtualCollectionProxy *current = newClass->GetCollectionProxy();; 1571 Int_t stlkind = old->GetCollectionType();; 1572 ; 1573 if (stlkind == ROOT::kSTLmap || stlkind == ROOT::kSTLmultimap) {; 1574 ; 1575 if (current->GetValueClass() == nullptr) {; 1576 // This should really never happen (the content of map should always; 1577 // be a pair and thus have a TClass ... so let's just give up ...; 1578 // It actually happens in the case where one of the member is an; 1579 // enum that is part of dictionary payload that is not yet; 1580 // auto-loaded.; 1581 return nullptr;; 1582 }; 1583 TVirtualStreamerInfo *info = current->GetValueClass()->GetStreamerInfo();; 1584 if (info->GetElements()->GetEntriesFast() != 2) {; 1585 return oldClass;; 1586 }; 1587 TStreamerElement *f = (TStreamerElement*) info->GetElements()->At(0);; 1588 TStreamerElement *s = (TStreamerElement*) info->GetElements()->At(1);; 1589 ; 1590 // Since we do not create TClass for pair of unknown types, old->GetValueClass can; 1591 // be nullptr even-though the type used be known. An example of such change; 1592 // is `RooExpensiveObjectCache::ExpensiveObject` which used to be recorded; 1593 // as `ExpensiveObject` in the name of the map ... making it unknown; 1594 // (and this is precisely the type of change we are trying to handle here/below!); 1595 info = old->GetValueClass() ? old->GetValueClass()->GetStreamerInfo() : nullptr;; 1596 assert(!info || info->GetElements()->GetEntriesFast() ==",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:60620,load,loaded,60620,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['load'],['loaded']
Performance,"ame, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidsetUnitNorm(Bool_t flag); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistPdf.html:29470,cache,cache,29470,root/html526/RooHistPdf.html,https://root.cern,https://root.cern/root/html526/RooHistPdf.html,1,['cache'],['cache']
Performance,"ame, const TString &methodTitle="""") constDefinition Factory.cxx:1305; TMVA::Factory::BookMethodWeightfileMethodBase * BookMethodWeightfile(DataLoader *dataloader, TMVA::Types::EMVA methodType, const TString &weightfile)Adds an already constructed method to be managed by this factory.Definition Factory.cxx:501; TMVA::Factory::fModelPersistenceBool_t fModelPersistence! option to save the trained model in xml file or using serializationDefinition Factory.h:222; TMVA::Factory::OptimizeAllMethodsstd::map< TString, Double_t > OptimizeAllMethods(TString fomType=""ROCIntegral"", TString fitType=""FitGA"")Iterates through all booked methods and sees if they use parameter tuning and if so does just that,...Definition Factory.cxx:701; TMVA::Factory::OptimizeAllMethodsForClassificationvoid OptimizeAllMethodsForClassification(TString fomType=""ROCIntegral"", TString fitType=""FitGA"")Definition Factory.h:110; TMVA::Factory::GetROCROCCurve * GetROC(DataLoader *loader, TString theMethodName, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)Private method to generate a ROCCurve instance for a given method.Definition Factory.cxx:749; TMVA::Factory::IsSilentFileBool_t IsSilentFile() constDefinition Factory.h:151; TMVA::Factory::EvaluateImportanceShortTH1F * EvaluateImportanceShort(DataLoader *loader, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")Definition Factory.cxx:2358; TMVA::Factory::fAnalysisTypeTypes::EAnalysisType fAnalysisType! the training typeDefinition Factory.h:221; TMVA::Factory::fJobNameTString fJobName! jobname, used as extension in weight file namesDefinition Factory.h:219; TMVA::Factory::HasMethodBool_t HasMethod(const TString &datasetname, const TString &title) constChecks whether a given method name is defined for a given dataset.Definition Factory.cxx:586; TMVA::Factory::GetROCCurveTGraph * GetROCCurve(DataLoader *loader, TString theMethodName, Bool_t setTitles=kTRUE, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)Argument iClass spec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:17013,load,loader,17013,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,1,['load'],['loader']
Performance,"ame, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tvolume(const char* rangeName) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategoryLValue.html:17591,cache,cache,17591,root/html602/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html,2,['cache'],['cache']
Performance,"ame, const char* title, const RooArgList& sumSet, Bool_t takeOwnerShip = kFALSE). RooAddition(const char* name, const char* title, const RooArgList& sumSet1, const RooArgList& sumSet2, Bool_t takeOwnerShip = kFALSE). RooAddition(const RooAddition& other, const char* name = 0). ~RooAddition(). Double_t evaluate() const; Calculate and return current value of self. Double_t defaultErrorLevel() const; Return the default error level for MINUIT error analysis; If the addition contains one or more RooNLLVars and; no RooChi2Vars, return the defaultErrorLevel() of; RooNLLVar. If the addition contains one ore more RooChi2Vars; and no RooNLLVars, return the defaultErrorLevel() of; RooChi2Var. If the addition contains neither or both; issue a warning message and return a value of 1. void enableOffsetting(Bool_t ). Bool_t setData(RooAbsData& data, Bool_t cloneData = kTRUE). void printMetaArgs(ostream& os) const. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& numVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate integral cache. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. TObject* clone(const char* newname) const; { return new RooAddition(*this, newname); }. const RooArgList& list1() const; { return _set ; }. const RooArgList& list() const; { return _set ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. » Last changed: Tue Jun 30 14:30:49 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddition.html:38718,cache,cache,38718,root/html602/RooAddition.html,https://root.cern,https://root.cern/root/html602/RooAddition.html,1,['cache'],['cache']
Performance,"ame, const char* title, const RooArgList& sumSet, Bool_t takeOwnerShip = kFALSE). RooAddition(const char* name, const char* title, const RooArgList& sumSet1, const RooArgList& sumSet2, Bool_t takeOwnerShip = kFALSE). RooAddition(const RooAddition& other, const char* name = 0). ~RooAddition(). Double_t evaluate() const; Calculate and return current value of self. Double_t defaultErrorLevel() const; Return the default error level for MINUIT error analysis; If the addition contains one or more RooNLLVars and; no RooChi2Vars, return the defaultErrorLevel() of; RooNLLVar. If the addition contains one ore more RooChi2Vars; and no RooNLLVars, return the defaultErrorLevel() of; RooChi2Var. If the addition contains neither or both; issue a warning message and return a value of 1. void enableOffsetting(Bool_t ). Bool_t setData(RooAbsData& data, Bool_t cloneData = kTRUE). void printMetaArgs(ostream& os) const. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& numVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate integral cache. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. TObject* clone(const char* newname) const; { return new RooAddition(*this, newname); }. const RooArgList& list1() const; { return _set ; }. const RooArgList& list() const; { return _set ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. » Last changed: Tue Mar 10 17:14:25 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddition.html:37218,cache,cache,37218,root/html534/RooAddition.html,https://root.cern,https://root.cern/root/html534/RooAddition.html,1,['cache'],['cache']
Performance,"ame, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:29826,cache,cache,29826,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,3,['cache'],['cache']
Performance,"ame, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsArg.html:30286,cache,cache,30286,root/html532/RooAbsArg.html,https://root.cern,https://root.cern/root/html532/RooAbsArg.html,4,['cache'],['cache']
Performance,"ame.c_str(), clname);; 3036 }; 3037 baseOffset = TVirtualStreamerInfo::kNeedObjectForVirtualBaseClass;; 3038 } else {; 3039 // We have an object to determine the vbase offset.; 3040 TClingClassInfo* ci = (TClingClassInfo*)cl->GetClassInfo();; 3041 TClingClassInfo* baseCi = (TClingClassInfo*)baseCl->GetClassInfo();; 3042 if (ci && baseCi) {; 3043 baseOffset = ci->GetBaseOffset(baseCi, const_cast<void*>(obj),; 3044 true /*isDerivedObj*/);; 3045 if (baseOffset == -1) {; 3046 Error(""InspectMembers"",; 3047 ""Error calculating offset of virtual base %s of class %s"",; 3048 sBaseName.c_str(), clname);; 3049 }; 3050 } else {; 3051 Error(""InspectMembers"",; 3052 ""Cannot calculate offset of virtual base %s of class %s"",; 3053 sBaseName.c_str(), clname);; 3054 continue;; 3055 }; 3056 }; 3057 } else {; 3058 baseOffset = recLayout.getBaseClassOffset(baseDecl).getQuantity();; 3059 }; 3060 // TOFIX: baseCl can be null here!; 3061 if (baseCl->IsLoaded()) {; 3062 // For loaded class, CallShowMember will (especially for TObject); 3063 // call the virtual ShowMember rather than the class specific version; 3064 // resulting in an infinite recursion.; 3065 InspectMembers(insp, cobj + baseOffset, baseCl, isTransient);; 3066 } else {; 3067 baseCl->CallShowMembers(cobj + baseOffset,; 3068 insp, isTransient);; 3069 }; 3070 } // loop over bases; 3071}; 3072 ; 3073////////////////////////////////////////////////////////////////////////////////; 3074/// Reset the interpreter internal state in case a previous action was not correctly; 3075/// terminated.; 3076 ; 3077void TCling::ClearFileBusy(); 3078{; 3079 // No-op there is not equivalent state (to be cleared) in Cling.; 3080}; 3081 ; 3082////////////////////////////////////////////////////////////////////////////////; 3083/// Delete existing temporary values.; 3084 ; 3085void TCling::ClearStack(); 3086{; 3087 // No-op for cling due to cling::Value.; 3088}; 3089 ; 3090///////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:118215,load,loaded,118215,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loaded']
Performance,"ame.so will be created.; 2699/// If the option ""++"" is specified, the generated shared lib is dynamically; 2700/// linked with the current executable module.; 2701/// If the option ""+"" and ""nocompile"" are specified, the utility files are generated; 2702/// as in the option ""+"" but they are not executed.; 2703/// Example:; 2704/// file.MakeProject(""demo"",""*"",""recreate++"");; 2705/// - creates a new directory demo unless it already exist; 2706/// - clear the previous directory content; 2707/// - generate the xxx.h files for all classes xxx found in this file; 2708/// and not yet known to the CINT dictionary.; 2709/// - creates the build script MAKEP; 2710/// - creates a LinkDef.h file; 2711/// - runs rootcint generating demoProjectDict.cxx; 2712/// - compiles demoProjectDict.cxx into demoProjectDict.o; 2713/// - generates a shared lib demo.so; 2714/// - dynamically links the shared lib demo.so to the executable; 2715/// If only the option ""+"" had been specified, one can still link the; 2716/// shared lib to the current executable module with:; 2717///; 2718/// gSystem->load(""demo/demo.so"");; 2719///; 2720/// The following feature is not yet enabled:; 2721/// One can restrict the list of classes to be generated by using expressions like:; 2722///; 2723/// classes = ""Ali*"" generate code only for classes starting with Ali; 2724/// classes = ""myClass"" generate code for class MyClass only.; 2725///; 2726 ; 2727void TFile::MakeProject(const char *dirname, const char * /*classes*/,; 2728 Option_t *option); 2729{; 2730 TString opt = option;; 2731 opt.ToLower();; 2732 Bool_t makepar = kFALSE;; 2733 TString parname, pardir;; 2734 if (opt.Contains(""par"")) {; 2735 // Create a PAR file; 2736 parname = gSystem->BaseName(dirname);; 2737 if (parname.EndsWith("".par"")) parname.ReplaceAll("".par"","""");; 2738 pardir = gSystem->GetDirName(dirname);; 2739 // Cleanup or prepare the dirs; 2740 TString path, filepath;; 2741 void *dir = gSystem->OpenDirectory(pardir);; 2742 if (dir) {; 2743 path.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:97975,load,load,97975,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['load'],['load']
Performance,"ame3); ; c = ROOT.TCanvas(""rf105_funcbinding"", ""rf105_funcbinding"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.6); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); ; c.SaveAs(""rf105_funcbinding.png""); RooCFunction1Binding<double,double>::erf[ function=(0x7f013b501000) x=x ] = 0; RooCFunction3PdfBinding<double,double,double,double>::beta[ function=ROOT::Math::beta_pdf x=x2 a=a b=b ] = 0.934689; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:Fitting -- RooAbsPdf::fitTo(beta_over_beta_Int[x2]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_beta_over_beta_Int[x2]_betaData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); RooTFnBinding::fa1[ TFn={fa1=sin(x)/x} obs=(x3) ] = -0.0547936; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf105_funcbinding.py. tutorialsroofitrf105_funcbinding.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf105__funcbinding_8py.html:3296,optimiz,optimization,3296,doc/master/rf105__funcbinding_8py.html,https://root.cern,https://root.cern/doc/master/rf105__funcbinding_8py.html,2,['optimiz'],['optimization']
Performance,"ame=%s, fType[%d]=%d,""; 1567 "" %s, bufpos=%d, arr=%p, eoffset=%d, Redirect=%p\n"",; 1568 info->GetClass()->GetName(),aElement->GetName(),fElemId,fCompInfo->fType,; 1569 aElement->ClassName(),b.Length(),addr, 0,b.PeekDataCache() ? b.PeekDataCache()->GetObjectAt(0) : 0);; 1570 }; 1571 ; 1572 }; 1573 ~TConfigurationUseCache() override {}; 1574 TConfiguration *Copy() override; 1575 {; 1576 TConfigurationUseCache *copy = new TConfigurationUseCache(*this);; 1577 fAction.fConfiguration = copy->fAction.fConfiguration->Copy(); // since the previous allocation did a 'move' of fAction we need to fix it.; 1578 return copy;; 1579 }; 1580 };; 1581 ; 1582 INLINE_TEMPLATE_ARGS Int_t UseCache(TBuffer &b, void *addr, const TConfiguration *conf); 1583 {; 1584 TConfigurationUseCache *config = (TConfigurationUseCache*)conf;; 1585 ; 1586 Int_t bufpos = b.Length();; 1587 TVirtualArray *cached = b.PeekDataCache();; 1588 if (cached==0) {; 1589 TStreamerElement *aElement = conf->fCompInfo->fElem;; 1590 TStreamerInfo *info = (TStreamerInfo*)conf->fInfo;; 1591 Warning(""ReadBuffer"",""Skipping %s::%s because the cache is missing."",info->GetName(),aElement->GetName());; 1592 char *ptr = (char*)addr;; 1593 info->ReadBufferSkip(b,&ptr,config->fCompInfo,config->fCompInfo->fType+TStreamerInfo::kSkip,aElement,1,0);; 1594 } else {; 1595 config->fAction(b, (*cached)[0]);; 1596 }; 1597 // Idea: Factor out this 'if' to a UseCacheRepeat function; 1598 if (config->fNeedRepeat) {; 1599 b.SetBufferOffset(bufpos);; 1600 }; 1601 return 0;; 1602 }; 1603 ; 1604 INLINE_TEMPLATE_ARGS Int_t UseCacheVectorPtrLoop(TBuffer &b, void *start, const void *end, const TConfiguration *conf); 1605 {; 1606 TConfigurationUseCache *config = (TConfigurationUseCache*)conf;; 1607 Int_t bufpos = b.Length();; 1608 ; 1609 TVirtualArray *cached = b.PeekDataCache();; 1610 if (cached==0) {; 1611 TStreamerElement *aElement = config->fCompInfo->fElem;; 1612 TStreamerInfo *info = (TStreamerInfo*)config->fInfo;; 1613 Warning(""ReadBuffer"",""Skippi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:65503,cache,cached,65503,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,2,['cache'],"['cache', 'cached']"
Performance,"ame=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void DrawCPU (const char *outfile, const char *opt=""std:"", Bool_t verbose=kFALSE, Int_t dofit=0, Int_t n0=-1, Int_t n1=-1);  Draw the CPU speedup plot. ;  ; static void DrawDataSet (const char *outfile, const char *opt=""std:"", const char *type=""mbs"", Bool_t verbose=kFALSE, Int_t dofit=0, Int_t n0=-1, Int_t n1=-1);  Draw the CPU speedup plot. ;  ; static void DrawEfficiency (const char *outfile, const char *opt="""", Bool_t verbose=kFALSE);  Draw the efficiency plot. ;  ; static TList * GetGraphs ();  ; static void GetPerfSpecs (const char *path=""."", Int_t degfit=1);  Get performance specs. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Static Protected Member Functions; static void AssertFittingFun (Double_t mi, Double_t mx);  Make sure that the fitting functions are defined. ;  ; static TGraphErrors * GetGraph (TDirectory *d, const char *pfn, Int_t &nb, Double_t &xmi, Double_t &xmx, Double_t &ymi, Double_t &ymx, Int_t &kmx, TProfile *&pf);  Get from TDirectory 'd' the TProfile named 'pfn' and create the graph. ;  . Protected Attributes; TString fCPUPar;  ; TString fCPUSel;  ; TStri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofBench.html:11508,perform,performance,11508,doc/master/classTProofBench.html,https://root.cern,https://root.cern/doc/master/classTProofBench.html,1,['perform'],['performance']
Performance,"amed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsCategory::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBinningCategory.html:15654,cache,cache,15654,root/html532/RooBinningCategory.html,https://root.cern,https://root.cern/root/html532/RooBinningCategory.html,1,['cache'],['cache']
Performance,"amed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedPdf.html:44250,cache,cacheNameSuffix,44250,root/html532/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedPdf.html,6,['cache'],"['cache', 'cacheNameSuffix']"
Performance,"amedMemberWise; kNotDecompressed; kTextBasedStreaming; kUser1; kUser2; kUser3; };; enum TBuffer::EMode { kRead; kWrite; };; enum TBuffer::[unnamed] { kIsOwner; kCannotHandleMemberWiseStreaming; kInitialSize; kMinimalSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMessage.html:20088,cache,cache,20088,root/html530/TMessage.html,https://root.cern,https://root.cern/root/html530/TMessage.html,3,['cache'],['cache']
Performance,"amedMemberWise; kNotDecompressed; kTextBasedStreaming; kUser1; kUser2; kUser3; };; enum TBuffer::EMode { kRead; kWrite; };; enum TBuffer::[unnamed] { kIsOwner; kCannotHandleMemberWiseStreaming; kInitialSize; kMinimalSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. vector<Int_t>*fColumnVec!; TString*fInsertQuery!; vector<int,allocator<int> >::iteratorfIter; TSQLRow**fRowPtr!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL(TBuffer::EMode mode, vector<Int_t>* vc, TString",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBufferSQL.html:18827,cache,cache,18827,root/html530/TBufferSQL.html,https://root.cern,https://root.cern/root/html530/TBufferSQL.html,3,['cache'],['cache']
Performance,"amer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void RooStats::PdfProposal::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 118 of file PdfProposal.h. Member Data Documentation. ◆ fCache. std::unique_ptr<RooDataSet> RooStats::PdfProposal::fCache. protected . our position in the cached proposal data set ; Definition at line 109 of file PdfProposal.h. ◆ fCachePosition. Int_t RooStats::PdfProposal::fCachePosition = 0. protected . how many points to generate each time ; Definition at line 108 of file PdfProposal.h. ◆ fCacheSize. Int_t RooStats::PdfProposal::fCacheSize = 1. protected . the last point we were at ; Definition at line 107 of file PdfProposal.h. ◆ fIt. std::map<RooRealVar*,RooAbsReal*>::iterator RooStats::PdfProposal::fIt. protected . map of values in pdf to update ; Definition at line 105 of file PdfProposal.h. ◆ fLastX. RooArgSet RooStats::PdfProposal::fLastX. protected . pdf iterator ; Definition at line 106 of file PdfProposal.h. ◆ fMap. std::map<RooRealVar*, RooAbsReal*> RooStats::PdfProposal::fMap. protected . the proposal density function ; Definition at line 104 of file PdfProposal.h. ◆ fMaster. RooArgSet RooStats::PdfProposal::fMaster. protected . the cached proposal data set ; Definition at line 110 of file PdfProposal.h. ◆ fOwnsPdf. bool RooStats::PdfProposal::fOwnsPdf = false. protected . pointers to master variables needed for updates ; Definition at line 111 of file PdfProposal.h. ◆ fPdf. RooAbsPdf* RooStats::PdfProposal::fPdf = nullptr. protected . Definition at line 103 of file PdfProposal.h. Libraries for RooStats::PdfProposal:. [legend]; The documentation for this class was generated from the following files:; roofit/roostats/inc/RooStats/PdfProposal.h; roofit/roostats/src/PdfProposal.cxx. RooStatsPdfProposal. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:55 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1PdfProposal.html:20634,cache,cached,20634,doc/master/classRooStats_1_1PdfProposal.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1PdfProposal.html,1,['cache'],['cached']
Performance,"amer!saved info to call Streamer; UInt_tfOnHeapnumber of instances on heap; Long_tfProperty!Property; TList*fRealDatalinked list for persistent members including base classes; TVirtualRefProxy*fRefProxy!Pointer to reference proxy if this class represents a reference; TClassRef*fRefStart!List of references to this object; void*fResetAfterMergepointer to a function implementing Merging objects of this class.; ROOT::TSchemaRuleSet*fSchemaRules! Schema evolution rules; TStringfSharedLibsshared libraries containing class code; ShowMembersFunc_tfShowMemberspointer to the class's ShowMembers function; Int_tfSizeofSizeof the class.; TClassStreamer*fStreamerpointer to streamer function; ClassStreamerFunc_tfStreamerFuncWrapper around this class custom Streamer member function.; G__p2memfuncfStreamerImpl! Pointer to the function implementing the right streaming behavior for the class represented by this object.; TObjArray*fStreamerInfoArray of TVirtualStreamerInfo; Int_tfStreamerType!cached of the streaming method to use; const type_info*fTypeInfopointer to the C++ type information.; Bool_tfVersionUsed!Indicates whether GetClassVersion has been called; static TClass::ENewTypefgCallingNewIntent of why/how TClass::New() is called; static Int_tfgClassCountprovides unique id for a each class; static THashTable*fgClassShortTypedefHash; static THashTable*fgClassTypedefHash. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IdMap_t * GetIdMap(). void AddClass(TClass* cl); static: Add a class to the list and map of classes. void RemoveClass(TClass* cl); static: Remove a class from the list and map of classes. TClass(); Default ctor. TClass(const char* name, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; No",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClass.html:17185,cache,cached,17185,root/html532/TClass.html,https://root.cern,https://root.cern/root/html532/TClass.html,1,['cache'],['cached']
Performance,"amer(),element->GetTypeName(),isSTLbase));; 3638 } else {; 3639 writeSequence->AddAction(WriteSTL<WriteArraySTLMemberWiseSameClass,WriteSTLObjectWiseFastArray>, new TConfigSTL(this,i,compinfo,compinfo->fOffset,element->GetArrayLength(),oldClass,element->GetTypeName(),isSTLbase));; 3640 }; 3641 }; 3642 }; 3643 break;; 3644 } */; 3645 default:; 3646 writeSequence->AddAction( GenericWriteAction, new TGenericConfiguration(this,i,compinfo) );; 3647 break;; 3648 }; 3649#if defined(CDJ_NO_COMPILE); 3650 if (element->TestBit(TStreamerElement::kCache)) {; 3651 TConfiguredAction action( writeSequence->fActions.back() ); // Action is moved, we must pop it next.; 3652 writeSequence->fActions.pop_back();; 3653 writeSequence->AddAction( UseCache, new TConfigurationUseCache(this,action,element->TestBit(TStreamerElement::kRepeat)) );; 3654 }; 3655#endif; 3656}; 3657 ; 3658////////////////////////////////////////////////////////////////////////////////; 3659 ; 3660void TStreamerInfo::AddWriteTextAction(TStreamerInfoActions::TActionSequence *writeSequence, Int_t i, TStreamerInfo::TCompInfo *compinfo); 3661{; 3662 TStreamerElement *element = compinfo->fElem;; 3663 if (element->TestBit(TStreamerElement::kCache) && !element->TestBit(TStreamerElement::kWrite)) {; 3664 // Skip element cached for reading purposes.; 3665 return;; 3666 }; 3667 if (element->GetType() >= kArtificial && !element->TestBit(TStreamerElement::kWrite)) {; 3668 // Skip artificial element used for reading purposes.; 3669 return;; 3670 }; 3671 ; 3672 Bool_t generic = kFALSE, isBase = kFALSE;; 3673 ; 3674 switch (compinfo->fType) {; 3675 // write basic types; 3676 case TStreamerInfo::kBool:; 3677 writeSequence->AddAction(WriteBasicType<Bool_t>, new TConfiguration(this, i, compinfo, compinfo->fOffset));; 3678 break;; 3679 case TStreamerInfo::kChar:; 3680 writeSequence->AddAction(WriteBasicType<Char_t>, new TConfiguration(this, i, compinfo, compinfo->fOffset));; 3681 break;; 3682 case TStreamerInfo::kShort:; 3683 writeSeq",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:169864,cache,cached,169864,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['cache'],['cached']
Performance,"amerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuList; fClassMenuList=nullptr;; 1727 ; 1728 fIsOffsetStreamerSet=kFALSE;; 1729 ; 1730 if ( fIsA ) delete fIsA;; 1731 ; 1732 if ( fRefProxy ) fRefProxy->Release();; 1733 fRefProxy = nullptr;; 1734 ; 1735 delete fStreamer;; 1736 delete fCollectionProxy;; 1737 delete fIsAMethod.load();; 1738 delete fSchemaRules;; 1739 if (fConversionStreamerInfo.load()) {; 1740 std::map<std::string, TObjArray*>::iterator it;; 1741 std::map<std::string, TObjArray*>::iterator end = (*fConversionStreamerInfo).end();; 1742 for( it = (*fConversionStreamerInfo).begin(); it != end; ++it ) {; 1743 delete it->second;; 1744 }; 1745 delete fConversionStreamerInfo.load();; 1746 }; 1747}; 1748 ; 1749////////////////////////////////////////////////////////////////////////////////; 1750 ; 1751namespace {; 1752 Int_t ReadRulesContent(FILE *f); 1753 {; 1754 // Read a class.rules file which contains one rule per line with comment; 1755 // starting with a #; 1756 // Returns the number of rules loaded.; 1757 // Returns -1 in case of error.; 1758 ; 1759 R__ASSERT(f!=nullptr);; 1760 TString rule(1024);; 1761 int c, state = 0;; 1762 Int_t count = 0;; 1763 ; 1764 while ((c = fgetc(f)) != EOF) {; 1765 if (c == 13) // ignore CR; 1766 continue;; 1767 if (c == '\n') {; 1768 if (state != 3) {; 1769 state = 0;; 1770 if (rule.Length() > 0) {; 1771 if (TClass::AddRule(rule)) {; 1772 ++count;; 1773 }; 1774 rule.Clear();; 1775 }; 1776 }; 1777 continue;; 1778 }; 1779 switch (state) {; 1780 case 0: // start of line; 1781 switch (c) {; 1782 case ' ':; 1783 case '\t':; 1784 break;; 1785 case '#':; 1786 state = 1;; 1787 break;; 1788 default:; 1789 state = 2;; 1790 break;; 1791 }; 1792 break;; 1793 ; 1794 case 1: // comment; 1795 break;; 1796 ; 1797 case 2: // rule; 1798 swi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:66710,load,load,66710,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"amerInfo = nullptr;; 1784 ; 1785 if (fDeclFileLine >= -1); 1786 TClass::RemoveClass(this);; 1787 ; 1788 gCling->ClassInfo_Delete(fClassInfo);; 1789 fClassInfo=nullptr;; 1790 ; 1791 if (fClassMenuList); 1792 fClassMenuList->Delete();; 1793 delete fClassMenuList; fClassMenuList=nullptr;; 1794 ; 1795 fIsOffsetStreamerSet=kFALSE;; 1796 ; 1797 if ( fIsA ) delete fIsA;; 1798 ; 1799 if ( fRefProxy ) fRefProxy->Release();; 1800 fRefProxy = nullptr;; 1801 ; 1802 delete fStreamer;; 1803 delete fCollectionProxy;; 1804 delete fIsAMethod.load();; 1805 delete fSchemaRules;; 1806 if (fConversionStreamerInfo.load()) {; 1807 std::map<std::string, TObjArray*>::iterator it;; 1808 std::map<std::string, TObjArray*>::iterator end = (*fConversionStreamerInfo).end();; 1809 for( it = (*fConversionStreamerInfo).begin(); it != end; ++it ) {; 1810 delete it->second;; 1811 }; 1812 delete fConversionStreamerInfo.load();; 1813 }; 1814}; 1815 ; 1816////////////////////////////////////////////////////////////////////////////////; 1817 ; 1818namespace {; 1819 Int_t ReadRulesContent(FILE *f); 1820 {; 1821 // Read a class.rules file which contains one rule per line with comment; 1822 // starting with a #; 1823 // Returns the number of rules loaded.; 1824 // Returns -1 in case of error.; 1825 ; 1826 R__ASSERT(f!=nullptr);; 1827 TString rule(1024);; 1828 int c, state = 0;; 1829 Int_t count = 0;; 1830 ; 1831 while ((c = fgetc(f)) != EOF) {; 1832 if (c == 13) // ignore CR; 1833 continue;; 1834 if (c == '\n') {; 1835 if (state != 3) {; 1836 state = 0;; 1837 if (rule.Length() > 0) {; 1838 if (TClass::AddRule(rule)) {; 1839 ++count;; 1840 }; 1841 rule.Clear();; 1842 }; 1843 }; 1844 continue;; 1845 }; 1846 switch (state) {; 1847 case 0: // start of line; 1848 switch (c) {; 1849 case ' ':; 1850 case '\t':; 1851 break;; 1852 case '#':; 1853 state = 1;; 1854 break;; 1855 default:; 1856 state = 2;; 1857 break;; 1858 }; 1859 break;; 1860 ; 1861 case 1: // comment; 1862 break;; 1863 ; 1864 case 2: // rule; 1865 swi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:69461,load,load,69461,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"amerInfo*)targetClass->FindConversionStreamerInfo( cl, fCheckSum );; 2186 else {; 2187 info = (TStreamerInfo*)cl->FindStreamerInfo( fCheckSum );; 2188 if (info) {; 2189 // Now that we found it, we need to make sure it is initialize (Find does not initialize the StreamerInfo).; 2190 info = (TStreamerInfo*)cl->GetStreamerInfo(info->GetClassVersion());; 2191 }; 2192 }; 2193 if( info ) {; 2194 fInfo = info;; 2195 // We no longer reset the class version so that in case the user is passing us later; 2196 // the address of a class that require (another) Conversion we can find the proper; 2197 // StreamerInfo.; 2198 // fClassVersion = fInfo->GetClassVersion();; 2199 }; 2200 }; 2201 }; 2202}; 2203 ; 2204 ; 2205////////////////////////////////////////////////////////////////////////////////; 2206/// Init the streamer info for the branch class, try to compensate for class; 2207/// code unload/reload and schema evolution.; 2208 ; 2209void TBranchElement::InitInfo(); 2210{; 2211 if (!fInfo); 2212 SetupInfo();; 2213 ; 2214 //; 2215 // Fixup cached streamer info if necessary.; 2216 //; 2217 // FIXME: What if the class code was unloaded/reloaded since we were cached?; 2218 ; 2219 if (fInfo) {; 2220 ; 2221 if (!fInfo->IsCompiled()) {; 2222 // Streamer info has not yet been compiled.; 2223 ; 2224 Error(""InitInfo"",""StreamerInfo is not compiled."");; 2225 }; 2226 // return immediately if we are called recursively.; 2227 if (fInInitInfo); 2228 return;; 2229 fInInitInfo = true;; 2230 if (!fInit) {; 2231 // We were read in from a file, figure out what our fID should be,; 2232 // schema evolution must be considered.; 2233 //; 2234 // Force our fID to be the id of the first streamer element that matches our name.; 2235 //; 2236 auto SetOnfileObject = [this](TStreamerInfo *info) {; 2237 Int_t arrlen = 1;; 2238 if (fType==31 || fType==41) {; 2239 TLeaf *leaf = (TLeaf*)fLeaves.At(0);; 2240 if (leaf) {; 2241 arrlen = leaf->GetMaximum();; 2242 }; 2243 }; 2244 bool toplevel = (fType == 3 || fType ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:79182,cache,cached,79182,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['cache'],['cached']
Performance,"amerInfo::EReadWrite { kBase; kOffsetL; kOffsetP; kCounter; kCharStar; kChar; kShort; kInt; kLong; kFloat; kDouble; kDouble32; kUChar; kUShort; kUInt; kULong; kBits; kLong64; kULong64; kBool; kFloat16; kObject; kAny; kObjectp; kObjectP; kTString; kTObject; kTNamed; kAnyp; kAnyP; kAnyPnoVT; kSTLp; kSkip; kSkipL; kSkipP; kConv; kConvL; kConvP; kSTL; kSTLstring; kStreamer; kStreamLoop; kCache; kArtificial; kCacheNew; kCacheDelete; kMissing; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTVirtualStreamerInfo::fIsBuilt! true if the StreamerInfo has been 'built'; TStringTNamed::fNameobject identifier; Bool_tTVirtualStreamerInfo::fOptimized! true if the Streamer has been optimized; TStringTNamed::fTitleobject title; static Bool_tTVirtualStreamerInfo::fgCanDeleteTrue if ReadBuffer can delete object; static TVirtualStreamerInfo*TVirtualStreamerInfo::fgInfoFactory; static Bool_tTVirtualStreamerInfo::fgOptimizeTrue if optimization on; static Bool_tTVirtualStreamerInfo::fgStreamMemberWiseTrue if the collections are to be stream ""member-wise"" (when possible). private:. UInt_tfCheckSumchecksum of original class; TClass*fClass!pointer to class; Int_tfClassVersionClass version identifier; TStreamerInfo::TCompInfo*fComp![fNdata] additional info; ULong_t*fElem![fNdata]; TObjArray*fElementsArray of TStreamerElements; Int_t*fLength![fNdata]; ULong_tfLiveCount! Number of outstanding pointer to this StreamerInfo.; ULong_t*fMethod![fNdata]; Int_tfNVirtualInfoLoc! Number of virtual info location to update.; Int_tfNdata!number of optmized types; Int_t*fNewType![fNdata]; Int_tfNumber!Unique identifier; Int_t*fOffset![fNdata]; Version_tfOldVersion! Version of the TStreamerInfo object read from the file; Int_tfOnFileClassVersion!Class version identifier as stored on fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStreamerInfo.html:12194,optimiz,optimized,12194,root/html528/TStreamerInfo.html,https://root.cern,https://root.cern/root/html528/TStreamerInfo.html,6,['optimiz'],"['optimization', 'optimized']"
Performance,"amerNVirtual(). void TEntryListBlock::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 80 of file TEntryListBlock.h. ◆ Transform(). void TEntryListBlock::Transform ; (; bool ; dir, . UShort_t * ; indexnew . ). protected . Transform the existing fIndices. . dir=0 - transform from bits to a list; dir=1 - tranform from a list to bits . Definition at line 563 of file TEntryListBlock.cxx. Member Data Documentation. ◆ fCurrent. UShort_t TEntryListBlock::fCurrent. protected . ! to fasten Contains() in list mode ; Definition at line 53 of file TEntryListBlock.h. ◆ fIndices. UShort_t* TEntryListBlock::fIndices. protected . [fN] ; Definition at line 49 of file TEntryListBlock.h. ◆ fLastIndexQueried. Int_t TEntryListBlock::fLastIndexQueried. protected . ! to optimize GetEntry() in a loop ; Definition at line 54 of file TEntryListBlock.h. ◆ fLastIndexReturned. Int_t TEntryListBlock::fLastIndexReturned. protected . ! to optimize GetEntry() in a loop ; Definition at line 55 of file TEntryListBlock.h. ◆ fN. Int_t TEntryListBlock::fN. protected . size of fIndices for I/O =fNPassed for list, fBlockSize for bits ; Definition at line 48 of file TEntryListBlock.h. ◆ fNPassed. Int_t TEntryListBlock::fNPassed. protected . number of entries in the entry list (if fPassing=0 - number of entries not in the entry list ; Definition at line 46 of file TEntryListBlock.h. ◆ fPassing. bool TEntryListBlock::fPassing. protected . 1 - stores entries that belong to the list 0 - stores entries that don't belong to the list ; Definition at line 51 of file TEntryListBlock.h. ◆ fType. Int_t TEntryListBlock::fType. protected . 0 - bits, 1 - list ; Definition at line 50 of file TEntryListBlock.h. Libraries for TEntryListBlock:. [legend]; The documentation for this class was generated from the following files:; tree/tree/inc/TEntryListBlock.h; tree/tree/src/TEntryListBlock.cxx. TEntryListBlock. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:31 (GVA ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryListBlock.html:18539,optimiz,optimize,18539,doc/master/classTEntryListBlock.html,https://root.cern,https://root.cern/doc/master/classTEntryListBlock.html,1,['optimiz'],['optimize']
Performance,"amera::Dolly ; (; Int_t ; delta, . Bool_t ; mod1, . Bool_t ; mod2 . ). virtual . Dolly the camera - 'move camera along eye line, retaining lens focal length'. ; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive dolly in, -ive dolly out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). Returns kTRUE is redraw required (camera change), kFALSE otherwise. ; Reimplemented in TGLOrthoCamera.; Definition at line 1046 of file TGLCamera.cxx. ◆ DrawDebugAids(). void TGLCamera::DrawDebugAids ; (; ); const. Draw out some debugging aids for the camera: . The frustum used to create the current interest box (RED); The same frustum as a squared off box (ORANGE); The axis aligned version of the frustum used as interest box basis (YELLOW); The current interest box (BLUE) . Definition at line 793 of file TGLCamera.cxx. ◆ EyeDirection(). TGLVector3 TGLCamera::EyeDirection ; (; ); const. Extract the camera eye direction (vector), running from EyePoint() Camera must have valid frustum cache - call Apply() after last modification, before using. ; Definition at line 236 of file TGLCamera.cxx. ◆ EyePoint(). TGLVertex3 TGLCamera::EyePoint ; (; ); const. Return the camera eye point (vertex) in world space Camera must have valid frustum cache - call Apply() after last modification, before using. ; Definition at line 219 of file TGLCamera.cxx. ◆ Frustum(). TGLBoundingBox TGLCamera::Frustum ; (; Bool_t ; asBox = kTRUE); const. private . expansion c.f. aligned current frustum box ; Return the current camera frustum.; If asBox == kFALSE return a true frustum (truncated square based pyramid). If asBox == kTRUE return a true box, using the far clipping plane intersection projected back to the near plane.; Camera must have valid frustum cache - call Apply() after last modification, before using; Note: TGLBoundingBox is not really valid when filled with truncated pyramid; this is used as a visual debug aid only so ok. . Definition at line 171 of file TGLCamera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLCamera.html:23679,cache,cache,23679,doc/master/classTGLCamera.html,https://root.cern,https://root.cern/doc/master/classTGLCamera.html,1,['cache'],['cache']
Performance,"ameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete possible MVA ouput values.; (I still leave the code here, but use this with care!!! The default; however is to use the distributions!!!. Double_t GetSigEffAt(Double_t bkgEff = 0.1); calculate the signal efficiency for a given background efficiency. OptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__OptimizeConfigParameters.html:3240,optimiz,optimization,3240,root/html528/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html528/TMVA__OptimizeConfigParameters.html,1,['optimiz'],['optimization']
Performance,"ameters. [in]pathPath where object is written to file ; [in]objPython object. The input Python object is serialized and written to a file. The Python module pickle is used to do so. ; Definition at line 272 of file PyMethodBase.cxx. ◆ Streamer(). virtual void TMVA::PyMethodBase::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::MethodBase.; Reimplemented in TMVA::MethodPyAdaBoost. ◆ StreamerNVirtual(). void TMVA::PyMethodBase::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 142 of file PyMethodBase.h. ◆ Train(). virtual void TMVA::PyMethodBase::Train ; (; ). pure virtual . Implements TMVA::MethodBase.; Implemented in TMVA::MethodPyAdaBoost, TMVA::MethodPyGTB, TMVA::MethodPyKeras, TMVA::MethodPyRandomForest, and TMVA::MethodPyTorch. ◆ UnSerialize(). Int_t PyMethodBase::UnSerialize ; (; TString ; path, . PyObject ** ; obj . ). static . Unserialize Python object. ; Parameters. [in]pathPath to serialized Python object ; [in]objPython object where the unserialized Python object is loaded . ReturnsError code ; Definition at line 294 of file PyMethodBase.cxx. Friends And Related Symbol Documentation. ◆ Factory. friend class Factory. friend . Definition at line 63 of file PyMethodBase.h. Member Data Documentation. ◆ fClassifier. PyObject* TMVA::PyMethodBase::fClassifier. protected . Definition at line 115 of file PyMethodBase.h. ◆ fEval. PyObject * PyMethodBase::fEval = NULL. staticprivate . Definition at line 124 of file PyMethodBase.h. ◆ fGlobalNS. PyObject * PyMethodBase::fGlobalNS = NULL. staticprotected . Definition at line 133 of file PyMethodBase.h. ◆ fLocalNS. PyObject* TMVA::PyMethodBase::fLocalNS. protected . Definition at line 134 of file PyMethodBase.h. ◆ fMain. PyObject * PyMethodBase::fMain = NULL. staticprotected . Definition at line 132 of file PyMethodBase.h. ◆ fModule. PyObject* TMVA::PyMethodBase::fModule. protected . Definition at line 114 of file PyMethodBase.h. ◆ fModuleBuiltin. PyObject * PyMeth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PyMethodBase.html:39207,load,loaded,39207,doc/master/classTMVA_1_1PyMethodBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PyMethodBase.html,1,['load'],['loaded']
Performance,"ametricGradFunctionOneDim::ParameterDerivative(double x, const double* p, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; virtual voidParameterGradient(double x, const double* par, double* grad) const; virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; static voidSetDerivPrecision(double eps); virtual voidSetParameters(const double* p); ROOT::Math::WrappedTF1WrappedTF1(TF1& f); ROOT::Math::WrappedTF1WrappedTF1(const ROOT::Math::WrappedTF1& rhs). private:. virtual doubleDoDerivative(double x) const; virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const; virtual doubleDoParameterDerivative(double x, const double* p, unsigned int ipar) const. Data Members; private:. TF1*fFuncpointer to ROOT function; boolfLinearflag for linear functions; boolfPolynomialflag for polynomial functions; doublefX[1]! cached vector for x value (needed for TF1::EvalPar signature); static doublefgEpsepsilon used in derivative calculation h ~ eps |x|. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; WrappedTF1(TF1& f); fParams(f.GetParameters(),f.GetParameters()+f.GetNpar()); constructor from a TF1 function pointer. WrappedTF1(TF1& f); fParams(rhs.fParams); copy constructor. void ParameterGradient(double x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. double DoDerivative(double x) const; return the function derivatives w.r.t. x. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const; evaluate the derivative of the function with respect to the parameters; IMPORTANT NOTE: TF1::GradientPar returns 0 for fixed parameters to avoid computing useless derivatives; BUT the TLinearFitter wants to have the derivatives also for fixed parameters.; so in case of fLinear (or fPolynomi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__WrappedTF1.html:3570,cache,cached,3570,root/html604/ROOT__Math__WrappedTF1.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__WrappedTF1.html,1,['cache'],['cached']
Performance,"ample the bins. ; This can be used to change options such as sampling accuracy or to entirely exchange the integrator.; Example: Use the 61-point Gauss-Kronrod integration rule; ROOT::Math::IntegratorOneDimOptions intOptions = pdf.integrator()->Options();; intOptions.SetNPoints(6); // 61-point integration rule; intOptions.SetRelTolerance(1.E-9); // Smaller tolerance -> more subdivisions; pdf.integrator()->SetOptions(intOptions);; ROOT::Math::BaseIntegratorOptions::SetRelTolerancevoid SetRelTolerance(double tol)set the relative toleranceDefinition IntegratorOptions.h:80; ROOT::Math::IntegratorOneDimOptionsNumerical one dimensional integration options.Definition IntegratorOptions.h:113; ROOT::Math::IntegratorOneDimOptions::SetNPointsvoid SetNPoints(unsigned int n)Set number of points for active integration rule.Definition IntegratorOptions.h:140; See alsoROOT::Math::IntegratorOneDim::SetOptions for more details on integration options. ; NoteWhen RooBinSamplingPdf is loaded from files, integrator options will fall back to the default values. ; Definition at line 278 of file RooBinSamplingPdf.cxx. ◆ IsA(). TClass * RooBinSamplingPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 134 of file RooBinSamplingPdf.h. ◆ isBinnedDistribution(). bool RooBinSamplingPdf::isBinnedDistribution ; (; const RooArgSet & ; ); const. inlineoverridevirtual . Returns true, since this PDF is meant to be binned. ; Reimplemented from RooAbsReal.; Definition at line 101 of file RooBinSamplingPdf.h. ◆ isDirectGenSafe(). bool RooBinSamplingPdf::isDirectGenSafe ; (; const RooAbsArg & ; arg); const. inlineoverridevirtual . Forwards to the PDF's implementation. ; Reimplemented from RooAbsPdf.; Definition at line 91 of file RooBinSamplingPdf.h. ◆ maxVal(). double RooBinSamplingPdf::maxVal ; (; Int_t ; code); const. inlineoverridevirtual . Return maximum value for set of observables identified by code assigned in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:87691,load,loaded,87691,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['load'],['loaded']
Performance,"ampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; voidinitialize(RooAbsCategoryLValue& inIndexCat, map<string,RooAbsPdf*> pdfMap); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimultaneous.html:36545,optimiz,optimizeDirtyHook,36545,root/html602/RooSimultaneous.html,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"an attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager; RooSetProxy_cacheObsObservable to be cached; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedPdf.html:43127,cache,cache,43127,root/html602/RooCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooCachedPdf.html,2,['cache'],['cache']
Performance,"an attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooRealProxyRooLegendre::_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; intRooLegendre::_l1; intRooLegendre::_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSpHarmonic.html:35729,cache,cache,35729,root/html602/RooSpHarmonic.html,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html,2,['cache'],['cache']
Performance,"an be either real or discrete. See RooDataHist::RooDataHist for details on the binning.; RooHistFunc neither owns or clone 'dhist' and the user must ensure the input histogram exists; for the entire life span of this function. RooHistFunc(const RooHistFunc& other, const char* name = 0); Copy constructor. ~RooHistFunc(). Double_t evaluate() const; Return the current value: The value of the bin enclosing the current coordinates; of the dependents, normalized by the histograms contents. Interpolation; is applied if the RooHistFunc is configured to do that. Int_t getMaxVal(const RooArgSet& vars) const; Only handle case of maximum in all variables. Double_t maxVal(Int_t code) const. Double_t totVolume() const; Return the total volume spanned by the observables of the RooDataHist. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistFunc can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used, only the integral; over all RooHistPdf observables is implemented. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistFunc.html:38577,perform,perform,38577,root/html534/RooHistFunc.html,https://root.cern,https://root.cern/root/html534/RooHistFunc.html,3,['perform'],['perform']
Performance,"an be found in the ROOT include path or the current directory. ; If 'name' contains any ACLiC style information (e.g. trailing +[+][g|O]), it will be striped off 'name'. If fullpath is != 0, the full path to the file is returned in *fullpath, which must be deleted by the caller. ; Definition at line 966 of file TSystem.cxx. ◆ IsPathLocal(). Bool_t TSystem::IsPathLocal ; (; const char * ; path). virtual . Returns TRUE if the url in 'path' points to the local file system. ; This is used to avoid going through the NIC card for local operations. ; Reimplemented in TDavixSystem, TUnixSystem, TWinNTSystem, and TNetXNGSystem.; Definition at line 1305 of file TSystem.cxx. ◆ Link(). int TSystem::Link ; (; const char * ; from, . const char * ; to . ). virtual . Create a link from file1 to file2. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1359 of file TSystem.cxx. ◆ ListLibraries(). void TSystem::ListLibraries ; (; const char * ; regexp = """"). virtual . List the loaded shared libraries. ; regexp is a regular expression allowing to filter the list.; Examples:; The following line lists all the libraries currently loaded: gSystem->ListLibraries(); TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; The following line lists all the libraries currently loaded having ""RIO"" in their names: gSystem->ListLibraries("".*RIO.*""). Reimplemented in TUnixSystem.; Definition at line 2085 of file TSystem.cxx. ◆ ListSymbols(). void TSystem::ListSymbols ; (; const char * ; module, . const char * ; re = """" . ). virtual . List symbols in a shared library. ; Reimplemented in TUnixSystem.; Definition at line 2064 of file TSystem.cxx. ◆ Load(). int TSystem::Load ; (; const char * ; module, . const char * ; entry = """", . Bool_t ; system = kFALSE . ). virtual . Load a shared library. ; Returns 0 on successful loading, 1 in case lib was already loaded, -1 in case lib does not exist or in case of er",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:72210,load,loaded,72210,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['load'],['loaded']
Performance,"an be joined onto other RNTuples. More...;  ; class  ROOT::Experimental::RNTupleInspector;  Inspect on-disk and storage-related information of an RNTuple. More...;  ; class  ROOT::Experimental::Internal::RNTupleMerger;  Given a set of RPageSources merge them into an RPageSink, optionally changing their compression. More...;  ; class  ROOT::Experimental::Detail::RNTupleMetrics;  A collection of Counter objects with a name, a unit, and a description. More...;  ; class  ROOT::Experimental::RNTupleModel;  The RNTupleModel encapulates the schema of an ntuple. More...;  ; class  ROOT::Experimental::Internal::RNTupleModelChangeset;  The incremental changes to a RNTupleModel More...;  ; class  ROOT::Experimental::RNTupleParallelWriter;  A writer to fill an RNTuple from multiple contexts. More...;  ; class  ROOT::Experimental::Detail::RNTuplePerfCounter;  A performance counter with a name and a unit, which can be activated on demand. More...;  ; class  ROOT::Experimental::Detail::RNTuplePlainCounter;  A non thread-safe integral performance counter. More...;  ; class  ROOT::Experimental::RNTupleProcessor;  Interface for iterating over entries of RNTuples and vertically concatenated RNTuples (chains). More...;  ; class  ROOT::Experimental::RNTupleReader;  An RNTuple that is used to read data from storage. More...;  ; class  ROOT::Experimental::RNTupleReadOptions;  Common user-tunable settings for reading ntuples. More...;  ; class  ROOT::Experimental::Internal::RNTupleSerializer;  A helper class for serializing and deserialization of the RNTuple binary format. More...;  ; class  ROOT::Experimental::Detail::RNTupleTickCounter< BaseCounterT >;  An either thread-safe or non thread safe counter for CPU ticks. More...;  ; class  ROOT::Experimental::Detail::RNTupleTimer< WallTimeT, CpuTimeT >;  Record wall time and CPU time between construction and destruction. More...;  ; class  ROOT::Experimental::RNTupleView< T >;  An RNTupleView for a known type. More...;  ; class  ROOT::Experime",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__NTuple.html:9723,perform,performance,9723,doc/master/group__NTuple.html,https://root.cern,https://root.cern/doc/master/group__NTuple.html,1,['perform'],['performance']
Performance,"an be specified after a comma, e.g. ""mymacro.C+,thisheader.h,thatheader.h"". If existing in the same directory, a header basename(macro).h or .hh, is also uploaded. The default is to load the macro also on the client; notOnClient can be used to avoid loading on the client. On masters, if uniqueWorkers is kTRUE, the macro is loaded on unique workers only, and collection is not done; if uniqueWorkers is kFALSE, collection from the previous request is done, and broadcasting + collection from the other workers is done. The wrks arg can be used on the master to limit the set of workers. Returns 0 in case of success and -1 in case of error. ; Reimplemented in TProofLite.; Definition at line 8628 of file TProof.cxx. ◆ LoadPackage(). Int_t TProof::LoadPackage ; (; const char * ; package, . Bool_t ; notOnClient = kFALSE, . TList * ; loadopts = 0, . TList * ; workers = 0 . ). private . Load specified package. ; Executes the PROOF-INF/SETUP.C script on all active nodes. If notOnClient = true, don't load package on the client. The default is to load the package also on the client. The argument 'loadopts' specify a list of objects to be passed to the SETUP. The objects in the list must be streamable; the SETUP macro will be executed like this: SETUP.C(loadopts). Returns 0 in case of success and -1 in case of error. ; Definition at line 8069 of file TProof.cxx. ◆ LogMessage(). void TProof::LogMessage ; (; const char * ; msg, . Bool_t ; all . ). Log a message into the appropriate window by emitting a signal. ; Definition at line 6414 of file TProof.cxx. ◆ LogViewer(). void TProof::LogViewer ; (; const char * ; url = 0, . Int_t ; sessionidx = 0 . ). static . Start the log viewer window usign the plugin manager. ; Definition at line 12470 of file TProof.cxx. ◆ MakePlayer(). TVirtualProofPlayer * TProof::MakePlayer ; (; const char * ; player = 0, . TSocket * ; s = 0 . ). protectedvirtual . Construct a TProofPlayer object. ; The player string specifies which player should be created: re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:115153,load,load,115153,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['load'],['load']
Performance,"an existing medium for making a volume. ; Definition at line 1408 of file TGeoManagerEditor.cxx. ◆ DoSelectShape(). void TGeoManagerEditor::DoSelectShape ; (; ). Slot for selecting an existing shape. ; Definition at line 1338 of file TGeoManagerEditor.cxx. ◆ DoSelectShape2(). void TGeoManagerEditor::DoSelectShape2 ; (; ). Slot for selecting a shape for making a volume. ; Definition at line 1352 of file TGeoManagerEditor.cxx. ◆ DoSelectTopVolume(). void TGeoManagerEditor::DoSelectTopVolume ; (; ). Slot for setting top geometry volume. ; Definition at line 1436 of file TGeoManagerEditor.cxx. ◆ DoSelectVolume(). void TGeoManagerEditor::DoSelectVolume ; (; ). Slot for selecting an existing volume. ; Definition at line 1422 of file TGeoManagerEditor.cxx. ◆ DoSetTopVolume(). void TGeoManagerEditor::DoSetTopVolume ; (; ). Set top volume for the geometry. ; Definition at line 1256 of file TGeoManagerEditor.cxx. ◆ LoadLib(). void TGeoManagerEditor::LoadLib ; (; ). static . Dummy static function, used to load plugin. ; Definition at line 1527 of file TGeoManagerEditor.cxx. ◆ SelectedSlot(). void TGeoManagerEditor::SelectedSlot ; (; TVirtualPad * ; pad, . TObject * ; obj, . Int_t ; event . ). virtual . Connected to TCanvas::Selected. ; TGeoManagerEditor takes this function from TGedEditor and only uses it if obj is a TGeoVolume. ; Definition at line 708 of file TGeoManagerEditor.cxx. ◆ SetModel(). void TGeoManagerEditor::SetModel ; (; TObject * ; obj). overridevirtual . Refresh editor according the selected obj. ; Implements TGedFrame.; Definition at line 795 of file TGeoManagerEditor.cxx. ◆ ShowSelectMaterial(). void TGeoManagerEditor::ShowSelectMaterial ; (; Bool_t ; show = kTRUE). protected . Show/hide interface for material selection. ; Definition at line 1491 of file TGeoManagerEditor.cxx. ◆ ShowSelectMatrix(). void TGeoManagerEditor::ShowSelectMatrix ; (; Bool_t ; show = kTRUE). protected . Show/hide interface for matrix selection. ; Definition at line 1515 of file TGeoM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManagerEditor.html:47974,load,load,47974,doc/master/classTGeoManagerEditor.html,https://root.cern,https://root.cern/doc/master/classTGeoManagerEditor.html,1,['load'],['load']
Performance,"an intermediate package such as HippoDraw @bib-HippoDraw, then the user’s \(\mbox{FCN}\) may be supplied by the this package.; The name of the user’s class to implement the FCNBase interface may be chosen freely (in documentation we give it the generic name \(\mbox{FCN}\)).; 4.1.1 FCNBase::operator()(const std::vector\(<\)double\(>\)&); The meaning of the vector of parameters std::vector\(<\)double\(>\) in the argument of FCNBase::operator() are of course defined by the user, who uses the values of those parameters to calculate their function value. The order and the position of these parameters is strictly the one specified by the user when supplying the starting values for minimization.; The starting values must be specified by the user, either via an std::vector\(<\)double\(>\) or the MnUserParameters (see [api:parameters]) supplied as input to the M minimizers such as VariableMetricMinimizer or MnMigrad (see [api:migrad]). Later values are determined by M as it searches for the minimum or performs whatever analysis is requested by the user.; 4.1.2 FCNBase::up(); [howto:errordef] Returns the value of \(\mbox{up}\) (default value \(= 1.\)), defining parameter errors. M defines parameter errors as the change in parameter value required to change the function value by \(\mbox{up}\). Normally, for chisquared fits \(\mbox{up = 1}\), and for negative log likelihood, \(\mbox{up = 0.5}\).; 4.1.3 \(\mbox{FCN}\) function with gradient; By default first derivatives are calculated numerically by M . In case the user wants to supply their own gradient calculator (e.g. analytical derivatives), they need to implement the FCNGradientBase interface. The size of the output vector is the same as of the input one. The same is true for the position of the elements (first derivative of the function with respect to the \(n_\mathrm{th}\) variable has index \(n\) in the output vector).; 4.2 M parameters; Interaction with the parameters of the function are essential both for M and the use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:30617,perform,performs,30617,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['perform'],['performs']
Performance,"an interpolator class from number of data points and with Interpolation::Type type.; The data can be set later on with the SetData method.; In case the data size is not known, better using the default of zero or the next constructor later on.; The default interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continuous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The default interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically generated. F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__Interpolator.html:3019,perform,performed,3019,root/html602/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__Interpolator.html,1,['perform'],['performed']
Performance,"an interpolator class from number of data points and with Interpolation::Type type.; The data can be set later on with the SetData method.; In case the data size is not known, better using the default of zero or the next constructor later on.; The default interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continuous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The default interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically generated. F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__Interpolator.html:3019,perform,performed,3019,root/html534/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__Interpolator.html,1,['perform'],['performed']
Performance,"an interpolator class from number of data points and with Interpolation::Type type.; The data can be set later on with the SetData method.; In case the data size is not known, better using the default of zero or the next constructor later on.; The default interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continuous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The default interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:34; This page has been automatically generated. F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__Interpolator.html:3019,perform,performed,3019,root/html604/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__Interpolator.html,1,['perform'],['performed']
Performance,"an nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; RooRealProxy_realVarRealVar with the original error; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooErrorVar.html:36692,cache,cache,36692,root/html526/RooErrorVar.html,https://root.cern,https://root.cern/root/html526/RooErrorVar.html,2,['cache'],['cache']
Performance,"an to release a snapshot of ROOT using cling in the third quarter of 2012; we will really appreciate feedback on problems with reading old files - as you correctly pointed out this is one of the most crucial ingredients of this project.; Cheers, Axel. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:50 Permalink . Thank you for clarifying a . Thank you for clarifying a transition plan, it is quite a reasonable approach. I just want to add a personal request to your wish list. Would it be possible to improve IO speed for reading? Very often analysis code is constrained by CPU/disk access limits when reading ntuples. The speed varies from ~100kHz for a tree with few float branches to ~200 Hz for complex data structure. A factor of few improvement for complex data can be a difference between requiring just one machine or a small farm. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:51 Permalink . Re: I/O Performance . Hi ROOT User,; We have dramatically improved the I/O performance over the last two years. If you use the latest production release also for writing data you might be able to see a performance improvement of an order of magnitude compared to e.g. 5.26, both in real and CPU time! See e.g. this blog entry.; We have been comparing the performance of ROOT I/O with competitors like Google ProtoBuf; we know exactly where we spend extra time and why, e.g. for schema evolution, proper C++ type support, introspection, pointers.; On the other hand, are you sure you make use of all the performance features ROOT offers? Did you enable the tree cache (on by default for PROOF and one tree per file, off - for now, still - otherwise)? Do you only read the branches you need? I am working on a new TTree read access class that should simplify all of that considerably (and is type safe - no more void*&!); maybe I should take your comment as an invitation to speed up :-); Cheers, Axel. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:51 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:15249,perform,performance,15249,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['perform'],['performance']
Performance,an which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of analytical integration codes; RooObjCacheManager_coefNormMgrCoefficient normalization manager; RooArgSet*_convNormSet! Subset of last normalization that applies to convolutions; RooListProxy_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*_convSetIter! Iterator over _convNormSet; RooRealVar*_convVar! Convolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_t_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*_model! Original resolution model; static Int_tRooPrintable::_nameL,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsAnaConvPdf.html:40996,cache,cache,40996,root/html532/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsAnaConvPdf.html,1,['cache'],['cache']
Performance,an which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of analytical integration codes; RooObjCacheManager_coefNormMgrCoefficient normalization manager; RooArgSet*_convNormSet! Subset of last normalization that applies to convolutions; RooListProxy_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*_convSetIter! Iterator over _convNormSet; RooRealVar*_convVar! Convolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_t_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*_model! Original resolution m,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:38964,cache,cache,38964,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,3,['cache'],['cache']
Performance,"anDeleteLast; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. vector<double>fCovarcached covariance matrix (NxN); auto_ptr<ROOT::Fit::FitData>fFitData! data of the fit (managed by TBackCompFitter); auto_ptr<ROOT::Fit::Fitter>fFitter! pointer to fitter object (managed by TBackCompFitter); ROOT::Math::Minimizer*fMinimizer; ROOT::Math",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBackCompFitter.html:10734,cache,cache,10734,root/html528/TBackCompFitter.html,https://root.cern,https://root.cern/root/html528/TBackCompFitter.html,4,['cache'],['cache']
Performance,"anStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsRealLValue.html:35645,cache,cache,35645,root/html526/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsRealLValue.html,8,['cache'],['cache']
Performance,"anaIntVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealIntegral.html:2427,cache,cacheUniqueSuffix,2427,root/html602/RooRealIntegral.html,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html,2,['cache'],['cacheUniqueSuffix']
Performance,"anager::AnimateTracksvoid AnimateTracks(Double_t tmin=0, Double_t tmax=5E-8, Int_t nframes=200, Option_t *option=""/*"")Draw animation of tracks.Definition TGeoManager.cxx:1836; TGeoManager::AddSkinSurfacevoid AddSkinSurface(TGeoSkinSurface *surf)Add skin surface;.Definition TGeoManager.cxx:2048; TGeoManager::GetMotherTGeoNode * GetMother(Int_t up=1) constDefinition TGeoManager.h:493; TGeoManager::MakeXtruTGeoVolume * MakeXtru(const char *name, TGeoMedium *medium, Int_t nz)Make a TGeoXtru-shaped volume with nz planes.Definition TGeoManager.cxx:3332; TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; TGeoManager::MakePconTGeoVolume * MakePcon(const char *name, TGeoMedium *medium, Double_t phi, Double_t dphi, Int_t nz)Make in one step a volume pointing to a polycone shape with given medium.Definition TGeoManager.cxx:3275; TGeoManager::fRaytraceModeInt_t fRaytraceModeFlag for multi-threading.Definition TGeoManager.h:146; TGeoManager::fVisDensityDouble_t fVisDensityparticles to be drawnDefinition TGeoManager.h:69; TGeoManager::AddNavigatorTGeoNavigator * AddNavigator()Add a navigator in the list of navigators.Definition TGeoManager.cxx:789; TGeoManager::GetListOfUVolumesTObjArray * GetListOfUVolumes() constDefinition TGeoManager.h:477; TGeoManager::GetTrackOfIdTVirtualGeoTrack * GetTrackOfId(Int_t id) constGet track with a given ID.Definition TGeoManager.cxx:2200; TGeoManager::FindDuplicateMaterialTGeoMaterial * FindDuplicateMaterial(const TGeoMaterial *mat) constFind if a given material duplicates an existing one.Definition TGeoManager.cxx:2992; TGeoManager::PopPointBool_t PopPoint()Definition TGeoManager.h:595; TGeoManager::GetVolumeTGeoVolume * GetVolume(Int_t uid) constDefinition TGeoManager.h:574; TGeoManager::GetListOfOverlapsTObjArray * GetListOfOverlaps()Definition TGeoManager.h:469; TGeoManager::DivisionTGeoVolume * Division(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8h_source.html:40357,multi-thread,multi-threading,40357,doc/master/TGeoManager_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html,1,['multi-thread'],['multi-threading']
Performance,"anager::FindNode(x,y,z) beforehand The method computing the distance to next boundary is:. TGeoNode *TGeoManager::FindNextBoundary(stepmax, path); The output node returned by the method is the object which shape boundary will be crossed first. The distance to the next crossing can be retrieved after the call:; Double_t TGeoManager::GetStep(). The main input parameter is stepmax, which act as a trigger for different features. The absolute value of this parameter represents the step value proposed by the user. The algorithm will never try o search for boundaries further than this distance. In case no boundary is found the returned node will be the current one and the computed step to boundary will be equal to abs (stepmax) having the meaning ""step approved"". The default value for stepmax is TGeoShape::Big with the meaning that boundaries are looked for without limitation. Finding the distance to the next crossed boundary; According the values of the input parameters the method will perform additional optional tasks:; |stepmax| < TGeoShape::Big(); The safe distance in the current volume is also computed. Moving the particle from its current location with this distance in any direction is safe in the sense that will never change the current state.; stepmax < 0; The global matrix for the object that will have the next crossed boundary is also computed. This can be retrieved for masterlocal point or vector conversions: TGeoManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; path 0; In case a path to a given physical object is specified, the distance to its bounda",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:130997,perform,perform,130997,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['perform']
Performance,"anager::FindNode(x,y,z); Note that the current particle position can be set using SetCurrentPosition(x,y,z) method of the manager class, in which case FindNode() can be called without arguments. The method returns a pointer to the ""deepest node"" that geometrically contains P (in our case let us suppose it is B\_3). Since a node is just a positioned volume, we can then get a pointer to the volume, medium or material objects related to it. ""Deepest"" means that B\_3 still contains point P (as well as A\_1 and TOP\_1), but none of the daughters of volume B does. After finding out the node containing the particle, one can check if the geometry state is different compared to the last located point:; Bool_t *TGeoManager::IsSameLocation(); The algorithm for finding where a point is located in geometry is presented in the figure 17-36.; It always starts by checking if the last computed modeller state is the answer. This optimizes the search when continuously tracking a particle. The main actions performed are:. moving up and down in the logical node tree while updating the current node and its global matrix; converting the global position into the local frame of the current node/volume; checking whether the local position lies within the geometrical shape of the current volume - if this is the case continue the search downwards for the daughters of the current node, otherwise search upwards its containers until the top level is reached.; the number of candidate nodes to be checked at a given level is minimized by an additional optimization structure: voxels. This is effective even in case there is only one daughter of the current volume.; in case the current node is declared as possibly overlapping, the method FindInCluster() is invoked. This method checks all different possibilities within the cluster of overlapping candidates. One of the candidates is prioritized if one of the following conditions id fulfilled (in order):; Is declared as non-overlapping (these are anyway se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:128371,perform,performed,128371,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['performed']
Performance,"anager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxysigma; RooRealProxywidth; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooVoigtian.html:39612,cache,cache,39612,root/html528/RooVoigtian.html,https://root.cern,https://root.cern/root/html528/RooVoigtian.html,2,['cache'],['cache']
Performance,"anagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedPdf.html:44283,cache,cache,44283,root/html534/RooCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooCachedPdf.html,1,['cache'],['cache']
Performance,"analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer is guranteed to be valid as far as the fitter class is valid and a new fit is not redone.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the fitter class; has not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false). apply correction in the error matrix for the weights for likelihood fits; This method can be called only after a fit. The; passed function (loglw2) is a log-likelihood function impelemented using the; sum of weight squared; When using FitConfig.SetWeightCorrection() this correction is applied; automatically when doing a likelihood fit (binned or unbinned). bool DoInitMinimizer(); initialize the minimizer. bool DoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization. bool DoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization after having set obj function. void DoUpdateFitConfig(); update config after fit. int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Fit__Fitter.html:12827,perform,performing,12827,root/html604/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html604/ROOT__Fit__Fitter.html,1,['perform'],['performing']
Performance,"anch element. void SetBranchCount(TBranchElement* bre); -- Set the branch counter for this branch. Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set object this branch is pointing to. void SetOffset(Int_t offset); Set offset of the object (to which the data member represented by this; branch belongs) inside its containing object (if any). void SetReadActionSequence(); Set the sequence of actions needed to read the data out of the buffer. void SetReadLeavesPtr(); Set the ReadLeaves pointer to execute the expected operations. void SetFillActionSequence(); Set the sequence of actions needed to write the data out from the buffer. void SetFillLeavesPtr(); Set the FillLeaves pointer to execute the expected operations. void SetTargetClass(const char* name); Set the name of the class of the in-memory object into which the data will; loaded. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void SetupAddressesImpl(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void Streamer(TBuffer& ); -- Stream an object of class TBranchElement. Int_t Unroll(const char* name, TClass* cltop, TClass* cl, char* ptr, Int_t basketsize, Int_t splitlevel, Int_t btype); -- Split class cl into sub-branches of this branch. Create a sub-branch of this branch for each non-empty,; non-abstract base class of cl (unless we are a sub-branch; of a TClonesArray or an STL container, in which case we; do *not* create a sub-branch), and for each non-split data; member of cl. Note: We do *n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBranchElement.html:35091,load,loaded,35091,root/html534/TBranchElement.html,https://root.cern,https://root.cern/root/html534/TBranchElement.html,3,['load'],['loaded']
Performance,"anch element. void SetBranchCount(TBranchElement* bre); -- Set the branch counter for this branch. Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set object this branch is pointing to. void SetOffset(Int_t offset); Set offset of the object (to which the data member represented by this; branch belongs) inside its containing object (if any). void SetReadActionSequence(); Set the sequence of actions needed to read the data out of the buffer. void SetReadLeavesPtr(); Set the ReadLeaves pointer to execute the expected operations. void SetFillActionSequence(); Set the sequence of actions needed to write the data out from the buffer. void SetFillLeavesPtr(); Set the FillLeaves pointer to execute the expected operations. void SetTargetClass(const char* name); Set the name of the class of the in-memory object into which the data will; loaded. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void SetupAddressesImpl(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void Streamer(TBuffer& b); -- Stream an object of class TBranchElement. Int_t Unroll(const char* name, TClass* cltop, TClass* cl, char* ptr, Int_t basketsize, Int_t splitlevel, Int_t btype); -- Split class cl into sub-branches of this branch. Create a sub-branch of this branch for each non-empty,; non-abstract base class of cl (unless we are a sub-branch; of a TClonesArray or an STL container, in which case we; do *not* create a sub-branch), and for each non-split data; member of cl. Note: We do *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBranchElement.html:34815,load,loaded,34815,root/html532/TBranchElement.html,https://root.cern,https://root.cern/root/html532/TBranchElement.html,1,['load'],['loaded']
Performance,"anch kAutoDelete bit. ;  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr);  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T *add, TBranch **ptr=nullptr);  ; Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr, TClass *realClass, EDataType datatype, bool isptr) override;  Check if bname is already in the status list, and if not, create a TChainElement object and set its address. ;  ; Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr=nullptr) override;  Set branch address. ;  ; Int_t SetBranchAddress (const char *bname, void *add, TClass *realClass, EDataType datatype, bool isptr) override;  Check if bname is already in the status list, and if not, create a TChainElement object and set its address. ;  ; void SetBranchStatus (const char *bname, bool status=true, UInt_t *found=nullptr) override;  Set branch status to Process or DoNotProcess. ;  ; Int_t SetCacheSize (Long64_t cacheSize=-1) override;  Set maximum size of the file cache . ;  ; void SetDirectory (TDirectory *dir) override;  Remove reference to this chain from current directory and add reference to new directory dir. ;  ; void SetEntryList (TEntryList *elist, Option_t *opt="""") override;  Set the input entry list (processing the entries of the chain will then be limited to the entries in the list). ;  ; virtual void SetEntryListFile (const char *filename="""", Option_t *opt="""");  Set the input entry list (processing the entries of the chain will then be limited to the entries in the list). ;  ; void SetEventList (TEventList *evlist) override;  This function transfroms the given TEventList into a TEntryList. ;  ; void SetMakeClass (Int_t make) override;  Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode). ;  ; void SetName (const char *name) override;  Change the name of this TChain. ;  ; virtual void SetPacketSize (Int_t size=100);  Set number of entries per packe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:10925,cache,cacheSize,10925,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,4,['cache'],"['cache', 'cacheSize']"
Performance,"anch kAutoDelete bit. ;  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr);  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T *add, TBranch **ptr=nullptr);  ; Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr, TClass *realClass, EDataType datatype, bool isptr) override;  Check if bname is already in the status list, and if not, create a TChainElement object and set its address. ;  ; Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr=nullptr) override;  Set branch address. ;  ; Int_t SetBranchAddress (const char *bname, void *add, TClass *realClass, EDataType datatype, bool isptr) override;  Check if bname is already in the status list, and if not, create a TChainElement object and set its address. ;  ; void SetBranchStatus (const char *bname, bool status=true, UInt_t *found=nullptr) override;  Set branch status to Process or DoNotProcess. ;  ; Int_t SetCacheSize (Long64_t cacheSize=-1) override;  Set maximum size of the file cache . ;  ; void SetDirectory (TDirectory *dir) override;  Remove reference to this chain from current directory and add reference to new directory dir. ;  ; void SetEntryList (TEntryList *elist, Option_t *opt="""") override;  Set the input entry list (processing the entries of the chain will then be limited to the entries in the list). ;  ; virtual void SetEntryListFile (const char *filename="""", Option_t *opt="""");  Set the input entry list (processing the entries of the chain will then be limited to the entries in the list). ;  ; void SetMakeClass (Int_t make) override;  Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode). ;  ; virtual void SetPacketSize (Int_t size=100);  Set number of entries per packet for parallel root. ;  ; virtual void SetProof (bool on=true, bool refresh=false, bool gettreeheader=false);  Enable/Disable PROOF processing on the current default Proof (gProof). ;  ; void SetWeigh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofChain.html:12177,cache,cacheSize,12177,doc/master/classTProofChain.html,https://root.cern,https://root.cern/doc/master/classTProofChain.html,2,['cache'],"['cache', 'cacheSize']"
Performance,"anch->GetMaxBaskets();; 3776 for (Int_t i=0;i<nbaskets;i++) {; 3777 Long64_t pos = branch->GetBasketSeek(i);; 3778 if (!pos) continue;; 3779 TFile *branchFile = branch->GetFile();; 3780 if (!branchFile) continue;; 3781 branchFile->GetRecordHeader(header,pos,16,nbytes,objlen,keylen);; 3782 if (nbytes <= 0) continue;; 3783 branchFile->MakeFree(pos,pos+nbytes-1);; 3784 ntot += nbytes;; 3785 nbask++;; 3786 }; 3787 }; 3788 ; 3789 // delete Tree header key and all keys with the same name; 3790 // A Tree may have been saved many times. Previous cycles are invalid.; 3791 while (key) {; 3792 ntot += key->GetNbytes();; 3793 key->Delete();; 3794 delete key;; 3795 key = fDirectory->GetKey(GetName());; 3796 }; 3797 if (dirsav) dirsav->cd();; 3798 if (gDebug) Info(""TTree::Delete"", ""Deleting Tree: %s: %d baskets deleted. Total space freed = %d bytes\n"",GetName(),nbask,ntot);; 3799 }; 3800 ; 3801 if (fDirectory) {; 3802 fDirectory->Remove(this);; 3803 //delete the file cache if it points to this Tree; 3804 MoveReadCache(file,nullptr);; 3805 fDirectory = nullptr;; 3806 ResetBit(kMustCleanup);; 3807 }; 3808 ; 3809 // Delete object from CINT symbol table so it can not be used anymore.; 3810 gCling->DeleteGlobal(this);; 3811 ; 3812 // Warning: We have intentional invalidated this object while inside a member function!; 3813 delete this;; 3814}; 3815 ; 3816 ///////////////////////////////////////////////////////////////////////////////; 3817 /// Called by TKey and TObject::Clone to automatically add us to a directory; 3818 /// when we are read from a file.; 3819 ; 3820void TTree::DirectoryAutoAdd(TDirectory* dir); 3821{; 3822 if (fDirectory == dir) return;; 3823 if (fDirectory) {; 3824 fDirectory->Remove(this);; 3825 // Delete or move the file cache if it points to this Tree; 3826 TFile *file = fDirectory->GetFile();; 3827 MoveReadCache(file,dir);; 3828 }; 3829 fDirectory = dir;; 3830 TBranch* b = nullptr;; 3831 TIter next(GetListOfBranches());; 3832 while((b = (TBranch*) next())) {; 383",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:149659,cache,cache,149659,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,anchAddressStatusTTree::kNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Float_t*fArgs! [fNvar] Array of variables; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TNtuple.html:23632,cache,cache,23632,root/html604/TNtuple.html,https://root.cern,https://root.cern/root/html604/TNtuple.html,2,['cache'],['cache']
Performance,"anchElement.cxx:5855; TBranchElement::GetCheckSumUInt_t GetCheckSum()Definition TBranchElement.h:185; TBranchElement::SetObjectvoid SetObject(void *objadd) overrideSet object this branch is pointing to.Definition TBranchElement.cxx:5575; TBranchObjectA Branch for the case of an object.Definition TBranchObject.h:26; TBranchRefA branch containing and managing a TRefTable for TRef autoloading.Definition TBranchRef.h:34; TBranchRef::Resetvoid Reset(Option_t *option="""") overrideDefinition TBranchRef.cxx:187; TBranchRef::Printvoid Print(Option_t *option="""") const overridePrint the TRefTable branch.Definition TBranchRef.cxx:159; TBranchRef::Clearvoid Clear(Option_t *option="""") overrideClear entries in the TRefTable.Definition TBranchRef.cxx:95; TBranchRef::ResetAfterMergevoid ResetAfterMerge(TFileMergeInfo *) overrideReset a Branch after a Merge operation (drop data but keep customizations) TRefTable is cleared.Definition TBranchRef.cxx:198; TBranchSTLA Branch handling STL collection of pointers (vectors, lists, queues, sets and multisets) while stori...Definition TBranchSTL.h:22; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBranch::GetLeafvirtual TLeaf * GetLeaf(const char *name) constReturn pointer to the 1st Leaf named name in thisBranch.Definition TBranch.cxx:2055; TBranch::GetMakeClassvirtual bool GetMakeClass() constReturn whether this branch is in a mode where the object are decomposed or not (Also known as MakeCla...Definition TBranch.cxx:2117; TBranch::SetupAddressesvirtual void SetupAddresses()If the branch address is not set, we set all addresses starting with the top level parent branch.Definition TBranch.cxx:3294; TBranch::ResetAddressvirtual void ResetAddress()Reset the address of the branch.Definition TBranch.cxx:2651; TBranch::GetBasketSeekvirtual Long64_t GetBasketSeek(Int_t basket) constReturn address of basket in the file.Definition TBranch.cxx:1302; TBranch::GetAddressvirtual char * GetAddress() constDefinition TBranch.h:212; TBranch::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:393889,queue,queues,393889,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['queue'],['queues']
Performance,"anches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_setset of terms to be summed; TIterator*_setIter! Iterator over set; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAddition(). RooAddition(const char* name, const char* title, const RooArgSet& sumSet,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddition.html:33030,cache,cache,33030,root/html532/RooAddition.html,https://root.cern,https://root.cern/root/html532/RooAddition.html,2,['cache'],['cache']
Performance,"and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuoatUpdate"" return is null. Int_t FillLsDataSet(const char* group, const char* user, const char* dsName, TList* out, UInt_t option); Check for the 'ls.txt' for 'group' and 'user' and fill the path for the; ls file in 'out'.; If 'dsname' is defined, open the file and extract the relevant line.; Return 0 on success, -1 on failure. TFileCollection * GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0). Returns the dataset <dsName> of user <user> in group <group> .; If checksum is non-zero, it will contain the pointer to a TMD5 sum object; with the checksum of the file, has to be deleted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not; contain the list of files. This is much faster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is checked against it,; if it does not match the file is not written (the function returns 2 in this; case, if the file has disappeared it is also not written (i.e. checksum; implies the bit kFileMustExist set in option).; Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManagerFile.html:16254,cache,cache,16254,root/html528/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html528/TDataSetManagerFile.html,6,['cache'],['cache']
Performance,"and get parameters of the event generator.; Note, if the derived class interfaces a (set of) Fortran common blocks (like TPythia, TVenus does), one better make the derived class a singleton. That is, something like; class MyGenerator : public TGenerator ; { ; public: ; static MyGenerator* Instance() ; { ; if (!fgInstance) fgInstance = new MyGenerator; ; return fgInstance; ; } ; void GenerateEvent() { ... } ; void ImportParticles(TClonesArray* a, Option_t opt="""") {...} ; Int_t ImportParticles(Option_t opt="""") { ... } ; Int_t SetParameter(const char* name, Double_t val) { ... } ; Double_t GetParameter(const char* name) { ... } ; virtual ~MyGenerator() { ... } ; protected: ; MyGenerator() { ... } ; MyGenerator(const MyGenerator& o) { ... } ; MyGenerator& operator=(const MyGenerator& o) { ... } ; static MyGenerator* fgInstance; ; ClassDefOverride(MyGenerator,0); ; }; ; Having multiple objects accessing the same common blocks is not ; safe. . Concrete TGenerator classes can be loaded in scripts and subseqent- ; ly used in compiled code: . // MyRun.h ; class MyRun : public TObject ; { ; public: ; static MyRun* Instance() { ... } ; void SetGenerator(TGenerator* g) { fGenerator = g; } ; void Run(Int_t n, Option_t* option="""") ; { ; TFile* file = TFile::Open(""file.root"",""RECREATE""); ; TTree* tree = new TTree(""T"",""T""); ; TClonesArray* p = new TClonesArray(""TParticles""); ; tree->Branch(""particles"", &p); ; for (Int_t event = 0; event < n; event++) { ; fGenerator->GenerateEvent(); ; fGenerator->ImportParticles(p,option); ; tree->Fill(); ; } ; file->Write(); ; file->Close(); ; } ; ... ; protected: ; TGenerator* fGenerator; ; ClassDefOverride(MyRun,0); ; }; ; ; // Config.C ; void Config() ; { ; MyRun* run = MyRun::Instance(); ; run->SetGenerator(MyGenerator::Instance()); ; } ; ; // main.cxx ; int ; main(int argc, char** argv) ; { ; TApplication app("""", 0, 0); ; gSystem->ProcessLine("".x Config.C""); ; MyRun::Instance()->Run(10); ; return 0; ; } ; This is especially useful for example",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenerator.html:2762,load,loaded,2762,doc/master/classTGenerator.html,https://root.cern,https://root.cern/doc/master/classTGenerator.html,1,['load'],['loaded']
Performance,"and giving the same results.; Scalability : the basic architecture should not put any implicit limitations on the number of computers that can be used in parallel.; Adaptability : the system should be able to adapt itself to variations in the remote environment (changing load on the cluster nodes, network interruptions, etc.).; Being an extension of the ROOT system, PROOF is designed to work on objects in ROOT data stores, though, for the time being, it mainly addresses the case of TTree based object collections.; PROOF is primarily meant as an interactive alternative to batch systems for Central Analysis Facilities and departmental workgroups (Tier-2’s). However, thanks to a multi-tier architecture allowing multiple levels of masters, it can be easily adapted to wide range virtual clusters distributed over geographically separated domains and heterogeneous machines (GRIDs).; While pure interactivity might not always be possible when performing a complicated analysis on a very large data set, PROOF still tries to give the user the interactive experience with something we call “interactive batch”. With “interactive batch” the user can start very long running queries, disconnect the client and at any time, any location and from any computer reconnect to the query to monitor its progress or retrieve the results. This feature gives it a distinct advantage over purely batch based solutions, that only provide an answer once all sub-jobs have been finished. The Multi-tier structure of a PROOF cluster. Details about the PROOF system and the way to use it can be found at 1; The PROOF development is a joint effort between CERN and MIT.; 25 Writing a Graphical User Interface. The ROOT GUI classes support an extensive and rich set of widgets with the Windows 95 look and feel. The widget classes interface to the underlying graphics system via a single abstract class. Concrete versions of this abstract class have been implemented for X11 and Win32, thereby making the ROOT GUI ful",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1126376,perform,performing,1126376,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performing']
Performance,"and height of the pixmap.; lenname : pixmap name length; pxname : pixmap name. void ImgPickPalette(RXImage* image, Int_t& ncol, Int_t*& R, Int_t*& G, Int_t*& B); Returns in R G B the ncol colors of the palette used by the image.; The image pixels are changed to index values in these R G B arrays.; This produces a colormap with only the used colors (so even on displays; with more than 8 planes we will be able to create GIF's when the image; contains no more than 256 different colors). If it does contain more; colors we will have to use GIFquantize to reduce the number of colors.; The R G B arrays must be deleted by the caller. Int_t WriteGIF(char* name); Writes the current window into GIF file. Returns 1 in case of success,; 0 otherwise. void PutImage(Int_t offset, Int_t itran, Int_t x0, Int_t y0, Int_t nx, Int_t ny, Int_t xmin, Int_t ymin, Int_t xmax, Int_t ymax, UChar_t* image, Drawable_t id); Draw image. Pixmap_t ReadGIF(Int_t x0, Int_t y0, const char* file, Window_t id = 0); If id is NULL - loads the specified gif file at position [x0,y0] in the; current window. Otherwise creates pixmap from gif file. unsigned char * GetColorBits(Drawable_t wid, Int_t x = 0, Int_t y = 0, UInt_t w = 0, UInt_t h = 0); Returns an array of pixels created from a part of drawable (defined by x, y, w, h); in format:; b1, g1, r1, 0, b2, g2, r2, 0 ... bn, gn, rn, 0 .. Pixels are numbered from left to right and from top to bottom.; By default all pixels from the whole drawable are returned. Note that return array is 32-bit aligned. Pixmap_t CreatePixmapFromData(unsigned char* bits, UInt_t width, UInt_t height); create pixmap from RGB data. RGB data is in format :; b1, g1, r1, 0, b2, g2, r2, 0 ... bn, gn, rn, 0 .. Pixels are numbered from left to right and from top to bottom.; Note that data must be 32-bit aligned. Int_t AddPixmap(ULong_t pixid, UInt_t w, UInt_t h); Register pixmap created by gVirtualGL; w,h : Width and height of the pixmap.; register new pixmap. Int_t SupportsExtension(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGX11.html:39217,load,loads,39217,root/html602/TGX11.html,https://root.cern,https://root.cern/root/html602/TGX11.html,2,['load'],['loads']
Performance,"and integration of pdfs, construction of cumulative distribution functions from pdfs in two dimensions ;  ; file  rf309_ndimplot.C;   Multidimensional models: making 2/3 dimensional plots of pdfs and datasets ;  ; file  rf309_ndimplot.py;   Multidimensional models: making 2/3 dimensional plots of pdfs and datasets ;  ; file  rf310_sliceplot.C;   Multidimensional models: projecting pdf and data slices in discrete observables ;  ; file  rf310_sliceplot.py;   Multidimensional models: projecting pdf and data slices in discrete observables ;  ; file  rf311_rangeplot.C;   Multidimensional models: projecting pdf and data ranges in continuous observables ;  ; file  rf311_rangeplot.py;   Multidimensional models: projecting pdf and data ranges in continuous observables ;  ; file  rf312_multirangefit.C;   Multidimensional models: performing fits in multiple (disjoint) ranges in one or more dimensions ;  ; file  rf312_multirangefit.py;   Multidimensional models: performing fits in multiple (disjoint) ranges in one or more dimensions ;  ; file  rf313_paramranges.C;   Multidimensional models: working with parametrized ranges to define non-rectangular regions for fitting and integration ;  ; file  rf313_paramranges.py;   Multidimensional models: working with parameterized ranges to define non-rectangular regions for fitting and integration ;  ; file  rf314_paramfitrange.C;   Multidimensional models: working with parametrized ranges in a fit. ;  ; file  rf314_paramfitrange.py;   Multidimensional models: working with parameterized ranges in a fit. ;  ; file  rf315_projectpdf.C;   Multidimensional models: marginizalization of multi-dimensional pdfs through integration ;  ; file  rf315_projectpdf.py;   Multidimensional models: marginizalization of multi-dimensional pdfs through integration ;  ; file  rf316_llratioplot.C;   Multidimensional models: using the likelihood ratio technique to construct a signal enhanced one-dimensional projection of a multi-dimensional pdf ;  ; file  rf316_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__roofit.html:9016,perform,performing,9016,doc/master/group__tutorial__roofit.html,https://root.cern,https://root.cern/doc/master/group__tutorial__roofit.html,1,['perform'],['performing']
Performance,"and it appears before the array in the columnList.; By default, in case of TTree or TChain inputs, Snapshot will try to write out all top-level branches. For other types of inputs, all columns returned by GetColumnNames() will be written out. If friend trees or chains are present, by default all friend top-level branches that have names that do not collide with names of branches in the main TTree/TChain will be written out. Since v6.24, Snapshot will also write out friend branches with the same names of branches in the main TTree/TChain with names of the form <friendname>_<branchname> in order to differentiate them from the branches in the main tree/chain. Writing to a sub-directory; Snapshot supports writing the TTree in a sub-directory inside the TFile. It is sufficient to specify the path to the TTree as part of the TTree name, e.g. df.Snapshot(""subdir/t"", ""f.root"") write TTree t in the sub-directory subdir of file f.root (creating file and sub-directory as needed).; AttentionIn multi-thread runs (i.e. when EnableImplicitMT() has been called) threads will loop over clusters of entries in an undefined order, so Snapshot will produce outputs in which (clusters of) entries will be shuffled with respect to the input TTree. Using such ""shuffled"" TTrees as friends of the original trees would result in wrong associations between entries in the main TTree and entries in the ""shuffled"" friend. Since v6.22, ROOT will error out if such a ""shuffled"" TTree is used in a friendship.; NoteIn case no events are written out (e.g. because no event passes all filters) the behavior of Snapshot in single-thread and multi-thread runs is different: in single-thread runs, Snapshot will write out a TTree with the specified name and zero entries; in multi-thread runs, no TTree object will be written out to disk. Snapshot will refuse to process columns with names of the form #columnname. These are special columns made available by some data sources (e.g. RNTupleDS) that represent the size of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:125334,multi-thread,multi-thread,125334,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['multi-thread'],['multi-thread']
Performance,"and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented from TTreeCache.; Definition at line 375 of file TTreeCacheUnzip.cxx. ◆ SetParallelUnzip(). Int_t TTreeCacheUnzip::SetParallelUnzip ; (; TTreeCacheUnzip::EParUnzipMode ; option = TTreeCacheUnzip::kEnable). static . Static function that (de)activates multithreading unzipping. ; The possible options are:; kEnable Enable it, which causes an automatic detection and launches the additional thread if the number of cores in the machine is greater than one; kDisable Disable will not activate the additional thread.; kForce Force will start the additional thread even if there is only one core. the default will be taken as kEnable. Returns 0 if there was an error, 1 otherwise. ; Definition at line 436 of file TTreeCacheUnzip.cxx. ◆ SetUnzipBufferSize(). void TTreeCacheUnzip::SetUnzipBufferSize ; (; Long64_t ; bufferSize). Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ; Definition at line 839 of file TTreeCacheUnzip.cxx. ◆ SetUnzipGroupSize(). void TTreeCacheUnzip::SetUnzipGroupSize ; (; Int_t ; groupSize). inline . Definition at line 146 of file TTreeCacheUnzip.h. ◆ SetUnzipRelBufferSize(). void TTreeCacheUnzip::SetUnzipRelBufferSize ; (; Float_t ; relbufferSize). static . static function: Sets the unzip relative buffer size ; Definition at line 830 of file TTreeCacheUnzip.cxx. ◆ StopLearningPhase(). void TTreeCacheUnzip::StopLearningPhase ; (; ). overridevirtual . It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ; Reimplemented from TTreeCache.; Definition at line 384 of file TTreeCacheUnzip.cxx. ◆ Streamer(). void TTreeCacheUnzip::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TTreeCache. ◆ StreamerNVirtual(). void TTreeCach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:36203,cache,cache,36203,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented from TTreeCache.; Definition at line 376 of file TTreeCacheUnzip.cxx. ◆ SetParallelUnzip(). Int_t TTreeCacheUnzip::SetParallelUnzip ; (; TTreeCacheUnzip::EParUnzipMode ; option = TTreeCacheUnzip::kEnable). static . Static function that (de)activates multithreading unzipping. ; The possible options are:; kEnable Enable it, which causes an automatic detection and launches the additional thread if the number of cores in the machine is greater than one; kDisable Disable will not activate the additional thread.; kForce Force will start the additional thread even if there is only one core. the default will be taken as kEnable. Returns 0 if there was an error, 1 otherwise. ; Definition at line 437 of file TTreeCacheUnzip.cxx. ◆ SetUnzipBufferSize(). void TTreeCacheUnzip::SetUnzipBufferSize ; (; Long64_t ; bufferSize). Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ; Definition at line 840 of file TTreeCacheUnzip.cxx. ◆ SetUnzipGroupSize(). void TTreeCacheUnzip::SetUnzipGroupSize ; (; Int_t ; groupSize). inline . Definition at line 146 of file TTreeCacheUnzip.h. ◆ SetUnzipRelBufferSize(). void TTreeCacheUnzip::SetUnzipRelBufferSize ; (; Float_t ; relbufferSize). static . static function: Sets the unzip relative buffer size ; Definition at line 831 of file TTreeCacheUnzip.cxx. ◆ StopLearningPhase(). void TTreeCacheUnzip::StopLearningPhase ; (; ). overridevirtual . It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ; Reimplemented from TTreeCache.; Definition at line 385 of file TTreeCacheUnzip.cxx. ◆ Streamer(). void TTreeCacheUnzip::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TTreeCache. ◆ StreamerNVirtual(). void TTreeCach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:36277,cache,cache,36277,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"and minor number. ;  ; Long64_t GetEntryNumberWithIndex (Long64_t major, Long64_t minor) const override;  Return entry number corresponding to major and minor number. ;  ; virtual Long64_t * GetIndex () const;  ; virtual Long64_t * GetIndexValues () const;  ; virtual Long64_t * GetIndexValuesMinor () const;  ; virtual TTreeFormula * GetMajorFormula ();  Return a pointer to the TreeFormula corresponding to the majorname. ;  ; const char * GetMajorName () const override;  ; virtual TTreeFormula * GetMinorFormula ();  Return a pointer to the TreeFormula corresponding to the minorname. ;  ; const char * GetMinorName () const override;  ; Long64_t GetN () const override;  ; TClass * IsA () const override;  ; bool IsValidFor (const TTree *parent) override;  Return true if index can be applied to the TTree. ;  ; void Print (Option_t *option="""") const override;  Print the table with : serial number, majorname, minorname. ;  ; void SetTree (TTree *T) override;  this function is called by TChain::LoadTree and TTreePlayer::UpdateFormulaLeaves when a new Tree is loaded. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TTreeIndex. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UpdateFormulaLeaves (const TTree *parent) override;  Called by TChain::LoadTree when the parent chain changes it's tree. ;  ;  Public Member Functions inherited from TVirtualIndex;  TVirtualIndex ();  pointer to Tree ;  ;  ~TVirtualIndex () override;  ; virtual TTree * GetTree () const;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeIndex.html:2554,load,loaded,2554,doc/master/classTTreeIndex.html,https://root.cern,https://root.cern/doc/master/classTTreeIndex.html,1,['load'],['loaded']
Performance,"and quantile) ;  permute.C Tutorial illustrating the use of TMath::Permute can be run with: ;  principal.C Principal Components Analysis (PCA) example ;  quantiles.C Demo for quantiles ;  quasirandom.C Example of generating quasi-random numbers ;  Rolke.C Example of the usage of the TRolke class The TRolke class computes the profile likelihood confidence limits for 7 different model assumptions on systematic/statistical uncertainties ;  testrandom.C Performance test of all the ROOT random generator (TRandom, TRandom1, TRandom2 and TRandom3) Tests the generator TRandom3 against some ref values and creates a timing table against TRandom, TRandom1 and TRandom2 ;  tStudent.C Example macro describing the student t distribution ;  TSVDUnfoldExample.C Data unfolding using Singular Value Decomposition ;  vavilov.C Test of the TMath::Vavilov distribution ;  ► matrix;  invertMatrix.C This macro shows several ways to invert a matrix ;  solveLinear.C This macro shows several ways to perform a linear least-squares analysis ;  ► mc;  CompareMasses.CMacro to compare masses in ROOT data base to the values from pdg pdg ;  ► memstat;  memstatExample.CScript post-processing the file generated by TMemStat (default memstat.root) ;  ► mlp;  mlpHiggs.C Example of a Multi Layer Perceptron For a LEP search for invisible Higgs boson, a neural network was used to separate the signal from the background passing some selection cuts ;  mlpRegression.CThis macro shows the use of an ANN for regression analysis: given a set {i} of input vectors i and a set {o} of output vectors o, one looks for the unknown function f(i)=o ;  ► multicore;  imt001_parBranchProcessing.C Demonstrate how to activate and use the implicit parallelisation of TTree::GetEntry ;  imt101_parTreeProcessing.C Illustrate the usage of the TTreeProcessorMT::Process method ;  mp001_fillHistos.C Fill histograms in parallel and write them on file ;  mp101_fillNtuples.C Fill n-tuples in distinct workers ;  mp102_readNtuplesFillHistosAnd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:133171,perform,perform,133171,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['perform'],['perform']
Performance,"and quantile) ;  permute.C Tutorial illustrating the use of TMath::Permute can be run with: ;  principal.C Principal Components Analysis (PCA) example ;  quantiles.C Demo for quantiles ;  quasirandom.C Example of generating quasi-random numbers ;  Rolke.C Example of the usage of the TRolke class The TRolke class computes the profile likelihood confidence limits for 7 different model assumptions on systematic/statistical uncertainties ;  testrandom.C Performance test of all the ROOT random generator (TRandom, TRandom1, TRandom2 and TRandom3) Tests the generator TRandom3 against some ref values and creates a timing table against TRandom, TRandom1 and TRandom2 ;  tStudent.C Example macro describing the student t distribution ;  TSVDUnfoldExample.C Data unfolding using Singular Value Decomposition ;  vavilov.C Test of the TMath::Vavilov distribution ;  ► matrix;  invertMatrix.C This macro shows several ways to invert a matrix ;  solveLinear.C This macro shows several ways to perform a linear least-squares analysis ;  ► mc;  CompareMasses.CMacro to compare masses in ROOT data base to the values from pdg pdg ;  ► memstat;  memstatExample.CScript post-processing the file generated by TMemStat (default memstat.root) ;  ► mlp;  mlpHiggs.C Example of a Multi Layer Perceptron For a LEP search for invisible Higgs boson, a neural network was used to separate the signal from the background passing some selection cuts ;  mlpRegression.CThis macro shows the use of an ANN for regression analysis: given a set {i} of input vectors i and a set {o} of output vectors o, one looks for the unknown function f(i)=o ;  ► multicore;  imt001_parBranchProcessing.CDemonstrate how to activate and use the implicit parallelisation of TTree::GetEntry ;  imt101_parTreeProcessing.CIllustrate the usage of the TTreeProcessorMT::Process method ;  mp001_fillHistos.C Fill histograms in parallel and write them on file ;  mp101_fillNtuples.C Fill n-tuples in distinct workers ;  mp102_readNtuplesFillHistosAndFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:132920,perform,perform,132920,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['perform'],['perform']
Performance,and standard deviation of all objects written so far to this file. Returns mean value + one standard deviation. ; Definition at line 1183 of file TFile.cxx. ◆ GetBytesRead(). virtual Long64_t TFile::GetBytesRead ; (; ); const. inlinevirtual . Definition at line 241 of file TFile.h. ◆ GetBytesReadExtra(). virtual Long64_t TFile::GetBytesReadExtra ; (; ); const. inlinevirtual . Definition at line 242 of file TFile.h. ◆ GetBytesToPrefetch(). Int_t TFile::GetBytesToPrefetch ; (; ); const. virtual . Max number of bytes to prefetch. ; By default this is 75% of the read cache size. But specific TFile implementations may need to change it ; Reimplemented in TXNetFile.; Definition at line 5222 of file TFile.cxx. ◆ GetBytesWritten(). Long64_t TFile::GetBytesWritten ; (; ); const. virtual . Return the total number of bytes written so far to the file. ; Definition at line 4566 of file TFile.cxx. ◆ GetCacheFileDir(). const char * TFile::GetCacheFileDir ; (; ). static . Get the directory where to locally stage/cache remote files. ; Definition at line 4654 of file TFile.cxx. ◆ GetCacheRead(). TFileCacheRead * TFile::GetCacheRead ; (; const TObject * ; tree = nullptr); const. Return a pointer to the current read cache. ; Definition at line 1262 of file TFile.cxx. ◆ GetCacheWrite(). TFileCacheWrite * TFile::GetCacheWrite ; (; ); const. Return a pointer to the current write cache. ; Definition at line 1279 of file TFile.cxx. ◆ GetClassIndex(). TArrayC * TFile::GetClassIndex ; (; ); const. inline . Definition at line 226 of file TFile.h. ◆ GetCompressionAlgorithm(). Int_t TFile::GetCompressionAlgorithm ; (; ); const. inline . Definition at line 385 of file TFile.h. ◆ GetCompressionFactor(). Float_t TFile::GetCompressionFactor ; (; ). Return the file compression factor. ; Add total number of compressed/uncompressed bytes for each key. Returns the ratio of the two. ; Definition at line 1202 of file TFile.cxx. ◆ GetCompressionLevel(). Int_t TFile::GetCompressionLevel ; (; ); const. inline,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:63232,cache,cache,63232,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,1,['cache'],['cache']
Performance,"and the tree; fReader.SetTree(tree);; };  ; void TutorialSelector::SlaveBegin(TTree *tree); {; // SlaveBegin() is a good place to create histograms.; // For PROOF, this is called for each worker.; // The TTree* is there for backward compatibility; e.g. PROOF passes 0.;  ; fEff = new TEfficiency(""eff"", ""Moun trigger efficiency"", 100, 0., 10.);; // Add to output list (needed for PROOF); GetOutputList()->Add(fEff);; };  ; Bool_t TutorialSelector::Process(Long64_t entry); {; // The Process() function is called for each entry in the tree to be; // processed. The entry argument specifies which entry in the currently; // loaded tree is to be processed.; // It can be passed to either EventSelector::GetEntry() or TBranch::GetEntry(); // to read either all or the required parts of the TTree.; //; // This function should contain the ""body"" of the analysis: select relevant; // tree entries, run algorithms on the tree entry and typically fill histograms.;  ; // *** 1. *** Tell the reader to load the data for this entry:; fReader.SetEntry(entry);;  ; // *** 2. *** Do the actual analysis; int tagMuon = gRandom->Integer(fRaPt.GetSize());;  ; if (fRaTriggered[tagMuon]) {; for (int iMuon = 0, nMuons = fRaPt.GetSize(); iMuon < nMuons; ++iMuon) {; // All but the tag muon can be probe muons; if (iMuon != tagMuon) {; 	 // Fill the efficiency object with; 	 // - whether this muon has triggered; 	 // - the pT of this muon.; 	 fEff->Fill(fRaTriggered[iMuon], fRaPt[iMuon]);; }; }; };  ; return kTRUE;; };  ; void TutorialSelector::Terminate(); {; // The Terminate() function is the last function to be called during the; // analysis of a tree with a selector. It always runs on the client, it can; // be used to present the results graphically or save the results to file.;  ; fEff->Print();; }.  . . ‹ 10. Go Parallel!; up; 11. Done! ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/tutorialselectorc.html:4970,load,load,4970,d/tutorialselectorc.html,https://root.cern,https://root.cern/d/tutorialselectorc.html,1,['load'],['load']
Performance,"and then the label is correctly aligned. The dot, if last character of the string, is also stripped. In the following, we have some parameters, like tick marks length and characters height (in percentage of the length of the axis, in user coordinates). The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%; Labels offset: 1.0 %. 9.5.7.7 Stripping Decimals; Use the TStyle::SetStripDecimals to strip decimals when drawing axis labels. By default, the option is set to true, and TGaxis::PaintAxis removes trailing zeros after the dot in the axis labels, e.g. {0, 0.5, 1, 1.5, 2, 2.5, etc.}; TStyle::SetStripDecimals (Bool_t strip=kTRUE); If this function is called with strip=kFALSE, TGaxis::PaintAxis() will draw labels with the same number of digits after the dot, e.g. {0.0, 0.5, 1.0, 1.5, 2.0, 2.5, etc.}; 9.5.7.8 Optional Grid; chopt = 'W': cross-Wire; 9.5.7.9 Axis Binning Optimization; By default, the axis binning is optimized. chopt = 'N': No binning optimization; chopt = 'I': Integer labeling. 9.5.8 Axis with Time Units; Histograms’ axis can be defined as “time axis”. To do that it is enough to activate the SetTimeDisplay attribute on a given axis. If h is a histogram, it is done the following way:; h->GetXaxis()->SetTimeDisplay(1); // X axis is a time axis; Two parameters can be adjusted in order to define time axis: the time format and the time offset.; 9.5.8.1 Time Format; It defines the format of the labels along the time axis. It can be changed using the TAxis method SetTimeFormat. The time format is the one used by the C function strftime(). It is a string containing the following formatting characters:. For the date:; %a abbreviated weekday name; %b abbreviated month name; %d day of the month (01-31); %m month (01-12); %y year without century; %Y year with century. For the time:; %H hour (24-hour clock); %I hour (12-hour clock); %p local equivalent of AM or PM; %M ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:343168,optimiz,optimized,343168,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimized']
Performance,"and this needs to remain supported. This enables code like RooRealVar x(...);; dataHist.getIndex(x);; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; xDouble_t x[n]Definition legend1.C:17; It is, however, recommended to use dataHist.getIndex(RooArgSet(x));; in this case. ; Definition at line 160 of file RooDataHist.h. ◆ getVarInfo(). RooDataHist::VarInfo const & RooDataHist::getVarInfo ; (; ). private . Return reference to VarInfo struct with cached histogram variable information that is frequently used for histogram weights retrieval. ; If the _varInfo struct was not initialized yet, it will be initialized in this function. ; Definition at line 2424 of file RooDataHist.cxx. ◆ getWeightBatch(). std::span< const double > RooDataHist::getWeightBatch ; (; std::size_t ; first, . std::size_t ; len, . bool ; sumW2 = false . ); const. overridevirtual . Return event weights of all events in range [first, first+len). ; If cacheValidEntries() has been called, out-of-range events will have a weight of 0. ; Implements RooAbsData.; Definition at line 2406 of file RooDataHist.cxx. ◆ importDHistSet(). void RooDataHist::importDHistSet ; (; const RooArgList & ; vars, . RooCategory & ; indexCat, . std::map< std::string, RooDataHist * > ; dmap, . double ; initWgt . ). protected . Import data from given set of TH1/2/3 into this RooDataHist. ; The category indexCat labels the sources in the constructed RooDataHist. The stl map provides the mapping between the indexCat state labels and the import source ; Definition at line 605 of file RooDataHist.cxx. ◆ importTH1(). void RooDataHist::importTH1 ; (; const RooArgList & ; vars, . const TH1 & ; histo, . double ; initWgt, . bool ; doDensityCorrection . ). protected . Import data from given TH1/2/3 into this RooDataHist. ; Definition at line 374 of file RooDataHist.cxx. ◆ importTH1Set(). void RooDataHist::importTH1Set ; (; const RooArgList & ; vars, . RooCategory & ; indexCat, . std::map< std::string, TH1 * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:60925,cache,cacheValidEntries,60925,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['cache'],['cacheValidEntries']
Performance,"and use the ROOT::Math::Minimizer interface to perform the minimization of the objective function. More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter.; Here we present a detailed description of the ROOT::Fit classes and how to use them. Using these classes instead of the interface provided directly in the ROOT data objects, like TH1::Fit allow are more fine control to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed.; To understand how these class work, let’s go through a simple example, such as fitting an histogram.; When fitting an histogram, instead of using TH1::Fit we will show in the following hot wo use the ROOT::Fit classes. We will show how to perform the following different type of fits with the histogram data: * a least square fit using the observed errors (Neyman chi-squared); * a least square fit using the expected errors from the function (Pearson chi-squared); * a binned likelihood fit; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it.; Let’s go through all the steps required for performing these fits using the ROOT::Fit::Fitter class. These steps are: 1. Create the input fit data object. 2. Create the input model function. 3. Configure the fit. 4. Perform the data fitting. 5. Examine the result.; 5.7.1 Creating the input fit data; We have two types of input data, binned data (class ROOT::Fit::BinData) used for least square (chi-square) fits of histograms or TGraph objects or un-binned data (class ROOT::Fit::UnBinData) used for fitting vectors of data points (e.g. from a TTree).; 5.7.1.1 Using Binned data; Let’s suppose we have an histogram, represented as a TH1 type object (it can be one or multi-dimensional). The following shows how to create and fill a ROOT:Fit::BinData object.; ROOT::Fit::DataOptions opt;; opt.fInt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:190759,perform,perform,190759,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['perform']
Performance,"and vice versa. The purpose of these features is the copyless interfacing of Python and C++ using their most common data containers, Numpy arrays and RVec with a std::vector interface. Conversion of RVecs to Numpy arrays; RVecs of fundamental types (int, float, ...) have in Python the __array_interface__ attribute attached. This information allows Numpy to adopt the memory of RVecs without copying the content. You can find further documentation regarding the Numpy array interface here. The following code example demonstrates the memory adoption mechanism using numpy.asarray.; rvec = ROOT.RVec('double')((1, 2, 3)); print(rvec) # { 1.0000000, 2.0000000, 3.0000000 }; ; npy = numpy.asarray(rvec); print(npy) # [1. 2. 3.]; ; rvec[0] = 42; print(npy) # [42. 2. 3.]. Conversion of Numpy arrays to RVecs; Data owned by Numpy arrays with fundamental types (int, float, ...) can be adopted by RVecs. To create an RVec from a Numpy array, ROOT offers the facility ROOT.VecOps.AsRVec, which performs a similar operation to numpy.asarray, but vice versa. A code example demonstrating the feature and the adoption of the data owned by the Numpy array is shown below.; npy = numpy.array([1.0, 2.0, 3.0]); print(npy) # [1. 2. 3.]; ; rvec = ROOT.VecOps.AsRVec(npy); print(rvec) # { 1.0000000, 2.0000000, 3.0000000 }; ; npy[0] = 42; print(rvec) # { 42.000000, 2.0000000, 3.0000000 }. Definition at line 1529 of file RVec.hxx. Public Types; using const_reference = typename SuperClass::const_reference;  ; using reference = typename SuperClass::reference;  ; using size_type = typename SuperClass::size_type;  ; using value_type = typename SuperClass::value_type;  ;  Public Types inherited from ROOT::VecOps::RVecN< T, Internal::VecOps::RVecInlineStorageSize< T >::value >; using const_reference = typename Internal::VecOps::SmallVectorTemplateCommon< T >::const_reference;  ; using reference = typename Internal::VecOps::SmallVectorTemplateCommon< T >::reference;  ; using size_type = typename Internal::VecO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html:9696,perform,performs,9696,doc/v632/classROOT_1_1VecOps_1_1RVec.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html,2,['perform'],['performs']
Performance,"and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable. Function Members (Methods); public:. TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); virtual~TBuffer3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBuffer3D.html:8283,cache,cache,8283,root/html526/TBuffer3D.html,https://root.cern,https://root.cern/root/html526/TBuffer3D.html,5,['cache'],['cache']
Performance,"and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable. Function Members (Methods); public:. virtual~TBuffer3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """");",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBuffer3D.html:8283,cache,cache,8283,root/html602/TBuffer3D.html,https://root.cern,https://root.cern/root/html602/TBuffer3D.html,2,['cache'],['cache']
Performance,"andBinding*_integrand! Binding of Convolution Integrand function; RooAbsIntegrator*_integrator! Numeric integrator of convolution integrand; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet_ownedClonedModelSetOwning set of cloned model components; RooArgSet_ownedClonedPdfSetOwning set of cloned PDF components; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useWindowSwitch to activate window convolution; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Int_t_verboseThreshCall count ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumConvolution.html:35863,cache,cache,35863,root/html532/RooNumConvolution.html,https://root.cern,https://root.cern/root/html532/RooNumConvolution.html,1,['cache'],['cache']
Performance,"andler ;  CTProofLogElem;  CTProofMergePrg;  CTProofMgrThe PROOF manager interacts with the PROOF server coordinator to create or destroy a PROOF session, attach to or detach from existing one, and to monitor any client activity on the cluster ;  CTProofMgrLiteBasic TProofMgr functionality implementation in the case of Lite session ;  ►CTProofMonSenderProvides the interface for PROOF monitoring to different writers ;  CTDSetPlet;  CTProofMonSenderMLTProofMonSender implementation for the ML writer ;  CTProofMonSenderSQLTProofMonSender implementation for the SQL writers ;  CTProofNodeInfoThe purpose of this class is to provide a complete node description for masters, submasters and workers ;  CTProofNodesPROOF worker node information ;  CTProofOutputFileClass to steer the merging of files produced on the workers ;  CTProofOutputListDerivation of TList with an overload of ls() and Print() allowing to filter out some of the variables ;  CTProofPerfAnalysisSet of tools to analyse the performance tree ;  ►CTProofPlayerInternal class steering processing in PROOF ;  CTCleanup;  CTProofPlayerLiteVersion of TProofPlayerRemote merges the functionality needed by clients and masters ;  CTProofPlayerLocal;  CTProofPlayerRemote;  CTProofPlayerSlave;  CTProofPlayerSuperMaster;  CTProofProgressDialog;  CTProofProgressInfo;  CTProofProgressLog;  CTProofProgressMemoryPlot;  CTProofProgressStatusContainer class for processing statistics ;  CTProofQueryResultTQueryResult version adapted to PROOF neeeds ;  CTProofResources;  CTProofResourcesStaticThe purpose of this class is to provide a standard interface to static config files ;  CTProofServClass providing the PROOF server ;  CTProofServLiteVersion of the PROOF worker server for local running ;  CTProofServLogHandler;  CTProofServLogHandlerGuard;  CTProofSuperMasterImplementation of TProof controlling PROOF federated clusters ;  CTProofVectorContainer;  ►CTProtoClassPersistent version of a TClass ;  CTProtoRealData;  CTPServerSocket;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:179300,perform,performance,179300,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,4,['perform'],['performance']
Performance,"andler::~RWebWindowWSHandler ; (; ). overridedefault . Member Function Documentation. ◆ AllowMTProcess(). Bool_t ROOT::RWebWindowWSHandler::AllowMTProcess ; (; ); const. inlineoverridevirtual . Allow processing of WS actions in arbitrary thread. ; Reimplemented from THttpWSHandler.; Definition at line 149 of file RWebWindowWSHandler.hxx. ◆ AllowMTSend(). Bool_t ROOT::RWebWindowWSHandler::AllowMTSend ; (; ); const. inlineoverridevirtual . Allows usage of special threads for send operations. ; Reimplemented from THttpWSHandler.; Definition at line 152 of file RWebWindowWSHandler.hxx. ◆ CanServeFiles(). Bool_t ROOT::RWebWindowWSHandler::CanServeFiles ; (; ); const. inlineoverridevirtual . returns true when window allowed to serve files relative to default page ; Reimplemented from THttpWSHandler.; Definition at line 138 of file RWebWindowWSHandler.hxx. ◆ CompleteWSSend(). void ROOT::RWebWindowWSHandler::CompleteWSSend ; (; UInt_t ; wsid). inlineoverridevirtual . React on completion of multi-threaded send operation. ; Reimplemented from THttpWSHandler.; Definition at line 155 of file RWebWindowWSHandler.hxx. ◆ GetBoolEnv(). int RWebWindowWSHandler::GetBoolEnv ; (; const std::string & ; name, . int ; dflt = -1 . ). static . Parse boolean gEnv variable which should be ""yes"" or ""no"". ; Returns1 for true or 0 for false Returns; Parameters. dfltif result is not defined ; namename of the env variable . Definition at line 47 of file RWebWindowsManager.cxx. ◆ GetCodeVersion(). std::string ROOT::RWebWindowWSHandler::GetCodeVersion ; (; ). inlineoverrideprotectedvirtual . Method generate extra suffix for all kinds of loaded code. ; Reimplemented from THttpWSHandler.; Definition at line 38 of file RWebWindowWSHandler.hxx. ◆ GetDefaultPageContent(). TString ROOT::RWebWindowWSHandler::GetDefaultPageContent ; (; ). inlineoverridevirtual . returns content of default web-page THttpWSHandler interface ; Reimplemented from THttpWSHandler.; Definition at line 135 of file RWebWindowWSHandl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowWSHandler.html:15828,multi-thread,multi-threaded,15828,doc/v632/classROOT_1_1RWebWindowWSHandler.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowWSHandler.html,1,['multi-thread'],['multi-threaded']
Performance,"andler::~RWebWindowWSHandler ; (; ). overridedefault . Member Function Documentation. ◆ AllowMTProcess(). Bool_t ROOT::RWebWindowWSHandler::AllowMTProcess ; (; ); const. inlineoverridevirtual . Allow processing of WS actions in arbitrary thread. ; Reimplemented from THttpWSHandler.; Definition at line 149 of file RWebWindowWSHandler.hxx. ◆ AllowMTSend(). Bool_t ROOT::RWebWindowWSHandler::AllowMTSend ; (; ); const. inlineoverridevirtual . Allows usage of special threads for send operations. ; Reimplemented from THttpWSHandler.; Definition at line 152 of file RWebWindowWSHandler.hxx. ◆ CanServeFiles(). Bool_t ROOT::RWebWindowWSHandler::CanServeFiles ; (; ); const. inlineoverridevirtual . returns true when window allowed to serve files relative to default page ; Reimplemented from THttpWSHandler.; Definition at line 138 of file RWebWindowWSHandler.hxx. ◆ CompleteWSSend(). void ROOT::RWebWindowWSHandler::CompleteWSSend ; (; UInt_t ; wsid). inlineoverridevirtual . React on completion of multi-threaded send operation. ; Reimplemented from THttpWSHandler.; Definition at line 155 of file RWebWindowWSHandler.hxx. ◆ GetBoolEnv(). int RWebWindowWSHandler::GetBoolEnv ; (; const std::string & ; name, . int ; dflt = -1 . ). static . Parse boolean gEnv variable which should be ""yes"" or ""no"". ; Returns1 for true or 0 for false Returns; Parameters. dfltif result is not defined ; namename of the env variable . Definition at line 48 of file RWebWindowsManager.cxx. ◆ GetCodeVersion(). std::string ROOT::RWebWindowWSHandler::GetCodeVersion ; (; ). inlineoverrideprotectedvirtual . Method generate extra suffix for all kinds of loaded code. ; Reimplemented from THttpWSHandler.; Definition at line 38 of file RWebWindowWSHandler.hxx. ◆ GetDefaultPageContent(). TString ROOT::RWebWindowWSHandler::GetDefaultPageContent ; (; ). inlineoverridevirtual . returns content of default web-page THttpWSHandler interface ; Reimplemented from THttpWSHandler.; Definition at line 135 of file RWebWindowWSHandl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowWSHandler.html:15821,multi-thread,multi-threaded,15821,doc/master/classROOT_1_1RWebWindowWSHandler.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowWSHandler.html,1,['multi-thread'],['multi-threaded']
Performance,"andling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 35 out-of-range events; RooDataSet::ds[x,y] = 65 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds2) Ignored 36 out-of-range events; RooDataSet::ds2[x,y,z] = 26 entries; [#1] INFO:DataHandling -- RooAbsReal::attachToTree(i) TTree Int_t branch i will be converted to double precision.; RooDataSet::ds3[i,x] = 100 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #2 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #5 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #8 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #11 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds4) Ignored 33 out-of-range events; RooDataSet::ds4[i,x] = 67 entries; RooDataSet::dsABC[x,y,c] = 26 entries; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf401_importttreethx.C. tutorialsroofitrf401_importttreethx.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8C.html:8562,load,loadValues,8562,doc/master/rf401__importttreethx_8C.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8C.html,6,['load'],['loadValues']
Performance,"ange is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:2877,latency,latency,2877,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,6,"['cache', 'latency']","['cache', 'latency']"
Performance,"ange is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. It is not simple to activate the cache; by default (except case1 below) because there are many possible configurations.; In some applications you know a priori the list of branches to read.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:2836,latency,latency,2836,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,6,"['cache', 'latency']","['cache', 'latency']"
Performance,"ange time for the specified selection. ; Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 2439 of file TVirtualX.cxx. ◆ SetTextAlign(). void TVirtualX::SetTextAlign ; (; Short_t ; talign = 11). overridevirtual . Sets the text alignment. ; Parameters. [in]taligntext alignment.; talign = txalh horizontal text alignment; talign = txalv vertical text alignment . Reimplemented from TAttText.; Definition at line 890 of file TVirtualX.cxx. ◆ SetTextColor(). void TVirtualX::SetTextColor ; (; Color_t ; cindex). overridevirtual . Sets the color index ""cindex"" for text. ; Reimplemented from TAttText.; Definition at line 897 of file TVirtualX.cxx. ◆ SetTextFont() [1/2]. Int_t TVirtualX::SetTextFont ; (; char * ; fontname, . ETextSetMode ; mode . ). virtual . Sets text font to specified name ""fontname"".This function returns 0 if the specified font is found, 1 if it is not. ; Parameters. [in]fontnamefont name ; [in]modeloading flag; mode = 0 search if the font exist (kCheck); mode = 1 search the font and load it if it exists (kLoad) . Reimplemented in TGQuartz, TGWin32, TGWin32VirtualXProxy, TGX11, and TGX11TTF.; Definition at line 910 of file TVirtualX.cxx. ◆ SetTextFont() [2/2]. void TVirtualX::SetTextFont ; (; Font_t ; fontnumber). overridevirtual . Sets the current text font number. ; Reimplemented from TAttText.; Definition at line 918 of file TVirtualX.cxx. ◆ SetTextMagnitude(). void TVirtualX::SetTextMagnitude ; (; Float_t ; mgn). virtual . Sets the current text magnification factor to ""mgn"". ; Reimplemented in TGCocoa, TGWin32VirtualXProxy, TGWin32, and TGX11.; Definition at line 925 of file TVirtualX.cxx. ◆ SetTextSize(). void TVirtualX::SetTextSize ; (; Float_t ; textsize). overridevirtual . Sets the current text size to ""textsize"". ; Reimplemented from TAttText.; Definition at line 932 of file TVirtualX.cxx. ◆ SetTypeList(). void TVirtualX::SetTypeList ; (; Window_t ; win, . Atom_t ; prop, . Atom_t * ; typelist . ). virtual . Add ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:128182,load,load,128182,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['load'],['load']
Performance,"ange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs; return RooAbsPdf::genContext(vars,prototype,auxProto,verbose) ; // WVE DEBUG. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Loop over components for plot sampling hints and merge them if there are multiple. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Loop over components for plot sampling hints and merge them if there are multiple. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooAddPdf with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. Bool_t selfNormalized() const; P.d.f is self normalized. ExtendMode extendMode() const; Return extended mode capabilities. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; Return list of component p.d.fs. const RooArgList& coefList() const; Return list of coefficients of component p.d.f.s. const RooArgSet& getCoefNormalization() const; { return _refCoefNorm ; }. const char* getCoefRange() const; { return _refCoefRangeName?RooNameReg::str(_refCoefRangeName):"""" ; }. CacheMode canNodeBeCached() const; { return RooAbsArg::NotAdvi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddPdf.html:51245,cache,cache-and-track,51245,root/html534/RooAddPdf.html,https://root.cern,https://root.cern/root/html534/RooAddPdf.html,3,['cache'],['cache-and-track']
Performance,"ange; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooObjCacheManager_projCacheMgrManager of cache with coefficient projections and transformations; Bool_t_projectCoefsIf true coefficients need to be projected for use in evaluate(); RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_t_recursiveFlag indicating is fractions are treated recursively; RooSetProxy_refCoefNormReference observable set for coefficient interpretation; TNamed*_refCoefRangeNameReference range name for coefficient interpreation; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooArgList*_snormList! List of supplemental normalization factors; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddPdf.html:46766,cache,cache,46766,root/html602/RooAddPdf.html,https://root.cern,https://root.cern/root/html602/RooAddPdf.html,2,['cache'],['cache']
Performance,"ange; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCachedPdf.html:41843,cache,cache,41843,root/html532/RooCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooCachedPdf.html,2,['cache'],['cache']
Performance,"angeName_{catName} will be used; as range definition for each index state of a RooSimultaneous. RooAbsOptTestStatistic(const RooAbsOptTestStatistic& other, const char* name = 0); Copy constructor. void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsOptTestStatistic.html:45925,optimiz,optimizations,45925,root/html602/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html,2,['optimiz'],['optimizations']
Performance,"angeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxybeta; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxygamma; RooRealProxymu; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooGamma.html:39540,cache,cache,39540,root/html530/RooGamma.html,https://root.cern,https://root.cern/root/html530/RooGamma.html,2,['cache'],['cache']
Performance,"anged from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* cacheUniqueSuffix() const; { return Form(""_%lx"", (ULong_t)_dataClone) ; }. Bool_t isDerived() const; Override this to be always true to force calculation of likelihood without parameters. { return kTRUE ; }. void seal(const char* notice = """"); { _sealed = kTRUE ; _sealNotice = notice ; }. Bool_t isSealed() const; { return _sealed ; }. const char* sealNotice() const; { return _sealNotice.Data() ; }. Bool_t allowFunctionCache(); { return kTRUE ; }. RooArgSet requiredExtraObservables() const; { return RooArgSet() ; }. » Last changed: Tue Mar 10 17:14:05 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsOptTestStatistic.html:44241,cache,cacheUniqueSuffix,44241,root/html534/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html,1,['cache'],['cacheUniqueSuffix']
Performance,"anges and forward them to fNode. Bool_t CanEditMainColor() const; Can edit main-color -- not available for assemblies. void SetMainColor(Color_t color); Set color, propagate to volume's line color. Bool_t CanEditMainTransparency() const; Can edit main transparency -- not available for assemblies. Char_t GetMainTransparency() const; Get transparency -- it is taken from the geo node. void SetMainTransparency(Char_t t); Set transparency, propagate to volume's transparency. void UpdateNode(TGeoNode* node); Updates all reve-browsers having the node in their contents.; All 3D-pads updated if any change found. Should (could?) be optimized with some assumptions about; volume/node structure (search for parent, know the same node can not; reoccur on lower level once found). void UpdateVolume(TGeoVolume* volume); Updates all reve-browsers having the volume in their contents.; All 3D-pads updated if any change found. Should (could?) be optimized with some assumptions about; volume/node structure (search for parent, know the same node can not; reoccur on lower level once found). void Draw(Option_t* option = """"); Draw the object. void Save(const char* file, const char* name = ""Extract"", Bool_t leafs_only = kFALSE); Save TEveGeoShapeExtract tree starting at this node.; This function is obsolete, use SaveExtract() instead. void SaveExtract(const char* file, const char* name, Bool_t leafs_only); Save the shape tree as TEveGeoShapeExtract.; File is always recreated. void WriteExtract(const char* name, Bool_t leafs_only); Write the shape tree as TEveGeoShapeExtract to current directory. TEveGeoShapeExtract* DumpShapeTree(TEveGeoNode* geon, TEveGeoShapeExtract* parent = 0, Bool_t leafs_only = kFALSE); Export the node hierarchy into tree of TEveGeoShapeExtract objects. TEveGeoNode(const TEveGeoNode& ). TEveGeoNode& operator=(const TEveGeoNode& ). TObject* GetObject(const TEveException& ) const; { const TObject* obj = this; return const_cast<TObject*>(obj); }. TGeoNode* GetNode() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveGeoNode.html:20340,optimiz,optimized,20340,root/html528/TEveGeoNode.html,https://root.cern,https://root.cern/root/html528/TEveGeoNode.html,6,['optimiz'],['optimized']
Performance,"angle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; R; TBenchmark::Startvirtual void Start(const char *name)Starts Benchmark with the specified name.Definition TBenchmark.cxx:172; TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::ToggleEventStatusvirtual void ToggleEventStatus()Toggle event statusbar.Definition TCanvas.cxx:2431; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TIterDefinition TCollection.h:235; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TKey::ReadObjvirtual TObject * ReadObj()To read a TObject* from the file.Definition TKey.cxx:759; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Drawvirtual void Draw(Option_t *option=""""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/th2polyEurope_8C.html:7306,cache,cacheDir,7306,doc/master/th2polyEurope_8C.html,https://root.cern,https://root.cern/doc/master/th2polyEurope_8C.html,2,['cache'],"['cache', 'cacheDir']"
Performance,"angled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+interpreted); 3337 // classes; 3338 cl = gInterpreter->GetClass(typeinfo, load);; 3339 ; 3340 return cl; // Can be zero.; 3341}; 3342 ; 3343////////////////////////////////////////////////////////////////////////////////; 3344/// Static method returning pointer to TClass of the specified ClassInfo.; 3345/// If load is true an attempt is made to obtain the class by loading; 3346/// the appropriate shared library (directed by the rootmap file).; 3347/// If silent is 'true', do not warn about missing dictionary for the class.; 3348/// (typically used for class that are used only for transient members); 3349/// Returns 0 in case class is not found.; 3350 ; 3351TClass *TClass::GetClass(ClassInfo_t *info, Bool_t load, Bool_t silent); 3352{; 3353 if (!info || !gCling->ClassInfo_IsValid(info)) return nullptr;; 3354 if (!gROOT->GetListOfClasses()) return nullptr;; 3355 ; 3356 // Technically we need the write lock only for the call to ClassInfo_FullName; 3357 // and GenerateTClass but FindObject will take the read lock (and LoadClass will; 3358 // take the write lock). Since taking/releasing the lock is expensive, let just; 3359 // take the write guard and keep it.; 3360 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3361 ; 3362 // Get the normalized name.; 3363 TString name( gCling->ClassInfo_FullName(info) );; 3364 ; 3365 TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 3366 ; 3367 if (cl) {; 3368 if (cl->IsLoaded()) return cl;; 3369 ; 3370 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3371 load = kTRUE;; 3372 ; 3373 }; 3374 ; 3375 if (!load) return nullptr;; 3376 ; 3377 TClass *loadedcl = nullptr;; 3378 if (cl) loadedcl = gROOT->LoadClass(cl->GetName(),silent);; 3379 else loadedcl = gROOT->LoadClass(name,silent);; 3380 ; 3381 if (loadedcl) return loadedcl;; 3382 ; 3383 if (cl) return cl; // If we f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:127528,load,load,127528,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"angled_name);; 3398 if (cl); 3399 return cl;; 3400 }; 3401 }; 3402 ; 3403 // last attempt. Look in the interpreter list of all (compiled+interpreted); 3404 // classes; 3405 cl = gInterpreter->GetClass(typeinfo, load);; 3406 ; 3407 return cl; // Can be zero.; 3408}; 3409 ; 3410////////////////////////////////////////////////////////////////////////////////; 3411/// Static method returning pointer to TClass of the specified ClassInfo.; 3412/// If load is true an attempt is made to obtain the class by loading; 3413/// the appropriate shared library (directed by the rootmap file).; 3414/// If silent is 'true', do not warn about missing dictionary for the class.; 3415/// (typically used for class that are used only for transient members); 3416/// Returns 0 in case class is not found.; 3417 ; 3418TClass *TClass::GetClass(ClassInfo_t *info, Bool_t load, Bool_t silent); 3419{; 3420 if (!info || !gCling->ClassInfo_IsValid(info)) return nullptr;; 3421 if (!gROOT->GetListOfClasses()) return nullptr;; 3422 ; 3423 // Technically we need the write lock only for the call to ClassInfo_FullName; 3424 // and GenerateTClass but FindObject will take the read lock (and LoadClass will; 3425 // take the write lock). Since taking/releasing the lock is expensive, let just; 3426 // take the write guard and keep it.; 3427 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3428 ; 3429 // Get the normalized name.; 3430 TString name( gCling->ClassInfo_FullName(info) );; 3431 ; 3432 TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 3433 ; 3434 if (cl) {; 3435 if (cl->IsLoaded()) return cl;; 3436 ; 3437 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3438 load = kTRUE;; 3439 ; 3440 }; 3441 ; 3442 if (!load) return nullptr;; 3443 ; 3444 TClass *loadedcl = nullptr;; 3445 if (cl) loadedcl = gROOT->LoadClass(cl->GetName(),silent);; 3446 else loadedcl = gROOT->LoadClass(name,silent);; 3447 ; 3448 if (loadedcl) return loadedcl;; 3449 ; 3450 if (cl) return cl; // If we f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:130279,load,load,130279,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. private:. TClass*fClassContext of this list. Not owned.; TExMap*fIdsMap from DeclId_t to TFunction*; ULong64_tfLastLoadMarkerRepresent interpreter state when we last did a full load.; THashTablefOverloadsTLists of overloads.; THashList*fUnloadedHolder of TFunction for unloaded functions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TListOfFunctionTemplates(TClass* cl); Constructor. ~TListOfFunctionTemplates(); Destructor. void MapObject(TObject* obj); Add pair<id, object> to the map of functions and their ids. void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfFunctionTemplates.html:11320,load,load,11320,root/html602/TListOfFunctionTemplates.html,https://root.cern,https://root.cern/root/html602/TListOfFunctionTemplates.html,2,['load'],['load']
Performance,"anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. private:. TClass*fClassContext of this list. Not owned.; TExMap*fIdsMap from DeclId_t to TFunction*; ULong64_tfLastLoadMarkerRepresent interpreter state when we last did a full load.; THashTablefOverloadsTLists of overloads.; THashList*fUnloadedHolder of TFunction for unloaded functions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TListOfFunctions(TClass* cl); Constructor. ~TListOfFunctions(); Destructor. void MapObject(TObject* obj); Add pair<id, object> to the map of functions and their ids. void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfFunctions.html:11162,load,load,11162,root/html602/TListOfFunctions.html,https://root.cern,https://root.cern/root/html602/TListOfFunctions.html,2,['load'],['load']
Performance,"ansient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; vector<double>_high; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Double_t_interpBoundary; vector<int>_interpCode; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Bool_t_logInit! flag used for chaching polynomial coefficients; vector<double>_low; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__FlexibleInterpVar.html:35939,cache,cache,35939,root/html602/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__FlexibleInterpVar.html,4,['cache'],['cache']
Performance,"ansient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsSelfCachedPdf.html:44041,cache,cache,44041,root/html602/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsSelfCachedPdf.html,6,['cache'],['cache']
Performance,ansient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; TIterator*_histObsIter! ; RooArgSet_histObsListList of observables defining dimensions of histogram; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfObsIter! ; RooSetProxy_pdfObsListList of observables mapped onto histogram observables; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! M,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistPdf.html:38270,cache,cache,38270,root/html526/RooHistPdf.html,https://root.cern,https://root.cern/root/html526/RooHistPdf.html,1,['cache'],['cache']
Performance,ansient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; TIterator*_histObsIter! ; RooArgSet_histObsListList of observables defining dimensions of histogram; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfObsIter! ; RooSetProxy_pdfObsListList of observables mapped onto histogram observables; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsAr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistPdf.html:38897,cache,cache,38897,root/html528/RooHistPdf.html,https://root.cern,https://root.cern/root/html528/RooHistPdf.html,2,['cache'],['cache']
Performance,"ansient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_t_valueConstant value of self; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooConstVar(const char* name, const char* title, Double_t value); Constructor with value; _fast = kTRUE ;. RooConstVar(const RooConst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooConstVar.html:32533,cache,cache,32533,root/html532/RooConstVar.html,https://root.cern,https://root.cern/root/html532/RooConstVar.html,2,['cache'],['cache']
Performance,"ansient members); 3349/// Returns 0 in case class is not found.; 3350 ; 3351TClass *TClass::GetClass(ClassInfo_t *info, Bool_t load, Bool_t silent); 3352{; 3353 if (!info || !gCling->ClassInfo_IsValid(info)) return nullptr;; 3354 if (!gROOT->GetListOfClasses()) return nullptr;; 3355 ; 3356 // Technically we need the write lock only for the call to ClassInfo_FullName; 3357 // and GenerateTClass but FindObject will take the read lock (and LoadClass will; 3358 // take the write lock). Since taking/releasing the lock is expensive, let just; 3359 // take the write guard and keep it.; 3360 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3361 ; 3362 // Get the normalized name.; 3363 TString name( gCling->ClassInfo_FullName(info) );; 3364 ; 3365 TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 3366 ; 3367 if (cl) {; 3368 if (cl->IsLoaded()) return cl;; 3369 ; 3370 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3371 load = kTRUE;; 3372 ; 3373 }; 3374 ; 3375 if (!load) return nullptr;; 3376 ; 3377 TClass *loadedcl = nullptr;; 3378 if (cl) loadedcl = gROOT->LoadClass(cl->GetName(),silent);; 3379 else loadedcl = gROOT->LoadClass(name,silent);; 3380 ; 3381 if (loadedcl) return loadedcl;; 3382 ; 3383 if (cl) return cl; // If we found the class but we already have a dummy class use it.; 3384 ; 3385 // We did not find a proper TClass but we do know (we have a valid; 3386 // ClassInfo) that the class is known to the interpreter.; 3387 TClass *ncl = gInterpreter->GenerateTClass(info, silent);; 3388 if (!ncl->IsZombie()) {; 3389 return ncl;; 3390 } else {; 3391 delete ncl;; 3392 return nullptr;; 3393 }; 3394}; 3395 ; 3396////////////////////////////////////////////////////////////////////////////////; 3397 ; 3398Bool_t TClass::HasNoInfoOrEmuOrFwdDeclaredDecl(const char* name){; 3399 return fNoInfoOrEmuOrFwdDeclNameRegistry.HasDeclName(name);; 3400}; 3401 ; 3402////////////////////////////////////////////////////////////////////////////////; 3403",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:128362,load,load,128362,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,7,['load'],"['load', 'loadedcl']"
Performance,"ansient members); 3416/// Returns 0 in case class is not found.; 3417 ; 3418TClass *TClass::GetClass(ClassInfo_t *info, Bool_t load, Bool_t silent); 3419{; 3420 if (!info || !gCling->ClassInfo_IsValid(info)) return nullptr;; 3421 if (!gROOT->GetListOfClasses()) return nullptr;; 3422 ; 3423 // Technically we need the write lock only for the call to ClassInfo_FullName; 3424 // and GenerateTClass but FindObject will take the read lock (and LoadClass will; 3425 // take the write lock). Since taking/releasing the lock is expensive, let just; 3426 // take the write guard and keep it.; 3427 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3428 ; 3429 // Get the normalized name.; 3430 TString name( gCling->ClassInfo_FullName(info) );; 3431 ; 3432 TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 3433 ; 3434 if (cl) {; 3435 if (cl->IsLoaded()) return cl;; 3436 ; 3437 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3438 load = kTRUE;; 3439 ; 3440 }; 3441 ; 3442 if (!load) return nullptr;; 3443 ; 3444 TClass *loadedcl = nullptr;; 3445 if (cl) loadedcl = gROOT->LoadClass(cl->GetName(),silent);; 3446 else loadedcl = gROOT->LoadClass(name,silent);; 3447 ; 3448 if (loadedcl) return loadedcl;; 3449 ; 3450 if (cl) return cl; // If we found the class but we already have a dummy class use it.; 3451 ; 3452 // We did not find a proper TClass but we do know (we have a valid; 3453 // ClassInfo) that the class is known to the interpreter.; 3454 TClass *ncl = gInterpreter->GenerateTClass(info, silent);; 3455 if (!ncl->IsZombie()) {; 3456 return ncl;; 3457 } else {; 3458 delete ncl;; 3459 return nullptr;; 3460 }; 3461}; 3462 ; 3463////////////////////////////////////////////////////////////////////////////////; 3464 ; 3465Bool_t TClass::HasNoInfoOrEmuOrFwdDeclaredDecl(const char* name){; 3466 return fNoInfoOrEmuOrFwdDeclNameRegistry.HasDeclName(name);; 3467}; 3468 ; 3469////////////////////////////////////////////////////////////////////////////////; 3470",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:131113,load,load,131113,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,7,['load'],"['load', 'loadedcl']"
Performance,"ant to Snapshot those; 1528 ColumnNames_t dsColumnsWithoutSizeColumns;; 1529 std::copy_if(dsColumns.begin(), dsColumns.end(), std::back_inserter(dsColumnsWithoutSizeColumns),; 1530 [](const std::string &name) { return name.size() < 13 || name.substr(0, 13) != ""R_rdf_sizeof_""; });; 1531 ColumnNames_t columnNames;; 1532 columnNames.reserve(definedColumns.size() + treeBranchNames.size() + dsColumns.size());; 1533 columnNames.insert(columnNames.end(), definedColumns.begin(), definedColumns.end());; 1534 columnNames.insert(columnNames.end(), treeBranchNames.begin(), treeBranchNames.end());; 1535 columnNames.insert(columnNames.end(), dsColumns.begin(), dsColumns.end());; 1536 const auto selectedColumns = RDFInternal::ConvertRegexToColumns(columnNames, columnNameRegexp, ""Cache"");; 1537 return Cache(selectedColumns);; 1538 }; 1539 ; 1540 ////////////////////////////////////////////////////////////////////////////; 1541 /// \brief Save selected columns in memory.; 1542 /// \param[in] columnList columns to be cached in memory.; 1543 /// \return a `RDataFrame` that wraps the cached dataset.; 1544 ///; 1545 /// See the previous overloads for more information.; 1546 RInterface<RLoopManager> Cache(std::initializer_list<std::string> columnList); 1547 {; 1548 ColumnNames_t selectedColumns(columnList);; 1549 return Cache(selectedColumns);; 1550 }; 1551 ; 1552 // clang-format off; 1553 ////////////////////////////////////////////////////////////////////////////; 1554 /// \brief Creates a node that filters entries based on range: [begin, end).; 1555 /// \param[in] begin Initial entry number considered for this range.; 1556 /// \param[in] end Final entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset.; 1557 /// \param[in] stride Process one entry of the [begin, end) range every `stride` entries. Must be strictly greater than 0.; 1558 /// \return the first node of the computation graph for which the event loop is limited to a certai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:86339,cache,cached,86339,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['cache'],['cached']
Performance,"antiles of the bigger sample by linear interpolation. ;  ; void Quartiles ();  compute quartiles a quartile is a 25 per cent or 75 per cent quantile ;  ;  Protected Member Functions inherited from TGraph; virtual Double_t ** Allocate (Int_t newsize);  Allocate internal data structures for newsize points. ;  ; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; virtual void CopyAndRelease (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin);  Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin != iend. ;  ; virtual Bool_t CopyPoints (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin);  Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin != iend. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; virtual Bool_t DoMerge (const TGraph *g);  protected function to perform the merge operation of a graph ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; virtual void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE);  Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ; virtual void SwapPoints (Int_t pos1, Int_t pos2);  Swap points. ;  ; virtual void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low);  Upda",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphQQ.html:30558,perform,perform,30558,doc/master/classTGraphQQ.html,https://root.cern,https://root.cern/doc/master/classTGraphQQ.html,1,['perform'],['perform']
Performance,"anual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » ROOT 6 Analysis Workshop 2. Running code in ROOT. Interpreting; ROOT executes your C++ code. There are two ways: loading it into the interpreter or compiling it as a shared library. Either way, it's easiest to provide a function that has the same name as the file. For instance you could have a file printTree.C containing; int printTree(TFile* file, const char* name) {; TTree* tree = 0;; file->GetObject(name, tree);; if (tree) {; tree->Print();; return 0;; } else {; Error(""printTree()"", ""Cannot find tree %s!"", name);; return -1;; }; }. You can now run this as; .x printTree.C(file, ""MyTree"");. This is equivalent to; .L printTree.C; printTree(file, ""MyTree"");. Compiling; You can also have your code compiled into a shared library, simply by adding a ""+"" behind the file name:; .x printTree.C+(file, ""MyTree"");. In the above example this will fail: we need to add the #includes for he compiler to be able to understand the code, while the interpreter has a lot of contextual knowledge and can automatically include headers and load libraries.; Expressions; You saw that with "".x"", ROOT prints the result of running the function whil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/2-running-code-root.html:1973,load,loading,1973,d/2-running-code-root.html,https://root.cern,https://root.cern/d/2-running-code-root.html,1,['load'],['loading']
Performance,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase ; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode ; Long64_t*TFileCacheRead::fSeek[fNseek],MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCacheUnzip.html:12916,cache,cache,12916,root/html534/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html,6,['cache'],"['cache', 'cached']"
Performance,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCacheUnzip.html:13602,cache,cache,13602,root/html602/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html,12,['cache'],"['cache', 'cached']"
Performance,"anup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfIsBuilt! true if the StreamerInfo has been 'built'; TStringTNamed::fNameobject identifier; Bool_tfOptimized! true if the Streamer has been optimized; TStringTNamed::fTitleobject title; static Bool_tfgCanDeleteTrue if ReadBuffer can delete object; static TVirtualStreamerInfo*fgInfoFactory; static Bool_tfgOptimizeTrue if optimization on; static Bool_tfgStreamMemberWiseTrue if the collections are to be stream ""member-wise"" (when possible). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualStreamerInfo& operator=(const TVirtualStreamerInfo& ); assignment operator. ~TVirtualStreamerInfo(); Destructor. Bool_t CanDelete(); static function returning true if ReadBuffer can delete object. Bool_t CanOptimize(); static function returning true if optimization can be on. TStreamerBasicType * GetElementCounter(const char* countName, TClass* cl); Get pointer to a TStreamerBasicType in TClass *cl; static function. Bool_t GetStreamMemberWise(); Return whether the TStreamerInfos will save the collections in; ""member-wise"" order whenever possible. The default is to store member-wise.; kTRUE indicates member-wise storing; kFALSE inddicates object-wise storing. A collection can be saved member wise when it contain is guaranteed to be; homogeneous. For example std::vector<THit> can be stored member wise,; while std::vector<THit*> can not (possible use of polymorphism). void Optimize(Bool_t opt = kTRUE); This is a static function.; Set optimization option.; When this option is activated (default), consecutive data members; of the same type are merged into an array (faster).; Optimization must be off in TTree split mode. TVirtualStreamerInfo * Factory(); Static function returning a pointer to a new TVirtualStreamerInfo obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualStreamerInfo.html:9216,optimiz,optimization,9216,root/html528/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html528/TVirtualStreamerInfo.html,3,['optimiz'],['optimization']
Performance,anup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_t_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCategory.html:18963,cache,cache,18963,root/html532/RooAbsCategory.html,https://root.cern,https://root.cern/root/html532/RooAbsCategory.html,3,['cache'],"['cache', 'caches']"
Performance,"anvas Name="" <<GetName()<<"" Title=""<<GetTitle()<<"" Option=""<<option<<std::endl;; 1508 TROOT::IncreaseDirLevel();; 1509 TPad::ls(option);; 1510 TROOT::DecreaseDirLevel();; 1511}; 1512 ; 1513////////////////////////////////////////////////////////////////////////////////; 1514/// Static function to build a default canvas.; 1515 ; 1516TCanvas *TCanvas::MakeDefCanvas(); 1517{; 1518 auto cdef = GetNewCanvasName();; 1519 ; 1520 auto c = new TCanvas(cdef.Data(), cdef.Data(), 1);; 1521 ; 1522 ::Info(""TCanvas::MakeDefCanvas"","" created default TCanvas with name %s"", cdef.Data());; 1523 return c;; 1524}; 1525 ; 1526////////////////////////////////////////////////////////////////////////////////; 1527/// Set option to move objects/pads in a canvas.; 1528///; 1529/// - set = 1 (default) graphics objects are moved in opaque mode; 1530/// - set = 0 only the outline of objects is drawn when moving them; 1531///; 1532/// The option opaque produces the best effect. It requires however a; 1533/// a reasonably fast workstation or response time.; 1534 ; 1535void TCanvas::MoveOpaque(Int_t set); 1536{; 1537 SetBit(kMoveOpaque,set);; 1538}; 1539 ; 1540////////////////////////////////////////////////////////////////////////////////; 1541/// Paint canvas.; 1542 ; 1543void TCanvas::Paint(Option_t *option); 1544{; 1545 if (fCanvas); 1546 TPad::Paint(option);; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Prepare for pick, call TPad::Pick() and when selected object; 1551/// is different from previous then emit Picked() signal.; 1552 ; 1553TPad *TCanvas::Pick(Int_t px, Int_t py, TObject *prevSelObj); 1554{; 1555 TObjLink *pickobj = nullptr;; 1556 ; 1557 fSelected = nullptr;; 1558 fSelectedOpt = """";; 1559 fSelectedPad = nullptr;; 1560 ; 1561 TPad *pad = Pick(px, py, pickobj);; 1562 if (!pad) return nullptr;; 1563 ; 1564 if (!pickobj) {; 1565 fSelected = pad;; 1566 fSelectedOpt = """";; 1567 } else {; 1568 if (!fSelected) { // can be set v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:47938,response time,response time,47938,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['response time'],['response time']
Performance,"anvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals from CINT (more; expensive). TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:23961,load,load,23961,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,4,['load'],['load']
Performance,"anvas.; To automate files loading and objects drawing, one can provide number of URL parameters in address string like:. file - name of the file, which will be automatically open with page loading; files - array of file names for loading; json - name of JSON file with stored ROOT object like histogram or canvas; item - item name to be displayed; opt - drawing option for the item; items - array of items name to be displayed; opts - array of drawing options for the items; expand - item name(s) to be expanded in the hierarchy browser; focus - item name to be focused on in the hierarchy browser; title - set browser title; dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; layout - can be ‘simple’, ‘flex’, ‘tabs’, ‘gridNxM’, ‘horizNMK’, ‘vertNMK’; browser - layout of the browser ‘fix’ (default), ‘float’, ‘no’ (hidden), ‘off’ (fully disabled); nobrowser - do not display file browser (same as browser=no); float - display floating browser (same as browser=float); status - configure status line ‘no’ (default), ‘off’ (completely disable), ‘size’; inject - name of extra JavaScript to load, see several examples in demo/ subdir; optimize - drawing optimization 0:off, 1:only large histograms (default), 2:always; palette - id of default color palette, 51..121 - new ROOT6 palette (default 57); interactive - enable/disable interactive functions 0 - disable all, 1 - enable all; noselect - hide file-selection part in the browser (only when file name is specified); mathjax - use MathJax for latex output; latex - ‘off’, ‘symbols’, ‘normal’, ‘mathjax’, ‘alwaysmath’ control of TLatex processor; style - name of TStyle object to define global JSROOT style; toolbar - show canvas tool buttons ‘off’, ‘on’ and ‘popup’, ‘left’ or ‘right’ for position, ‘vert’ for vertical; divsize - fixed size in pixels for main div element like &dvisize=1500x800; canvsize - default canvas size in pixels like &canvsize=1200x800; optstat - settings for stat box, def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:2383,load,load,2383,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,3,"['load', 'optimiz']","['load', 'optimization', 'optimize']"
Performance,"anvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooTreeDataStore.html:10131,cache,cached,10131,root/html528/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html528/RooTreeDataStore.html,8,"['cache', 'load']","['cache', 'cached', 'loading']"
Performance,"anvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeDataStore.html:10122,cache,cached,10122,root/html526/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html526/RooTreeDataStore.html,4,"['cache', 'load']","['cache', 'cached', 'loading']"
Performance,"any analytical integration is possible, return integration scenario code; RooAddPdf queries each component PDF for its analytical integration capability of the requested set ('allVars'). It finds the largest common set of variables that can be integrated by all components. If such a set exists, it reconfirms that each component is capable of analytically integrating the common set, and combines the components individual integration codes into a single integration code valid for RooAddPdf. ; Reimplemented from RooAbsReal.; Definition at line 631 of file RooAddPdf.cxx. ◆ getCoefNormalization(). const RooArgSet & RooAddPdf::getCoefNormalization ; (; ); const. Definition at line 335 of file RooAddPdf.cxx. ◆ getCoefRange(). const char * RooAddPdf::getCoefRange ; (; ); const. inline . Definition at line 83 of file RooAddPdf.h. ◆ getNormAndCache(). std::pair< const RooArgSet *, AddCacheElem * > RooAddPdf::getNormAndCache ; (; const RooArgSet * ; nset); const. private . Look up projection cache and per-PDF norm sets. ; If a PDF doesn't have a special norm set, use the defaultNorm. If defaultNorm == nullptr, use the member _normSet. ; Definition at line 458 of file RooAddPdf.cxx. ◆ getProjCache(). AddCacheElem * RooAddPdf::getProjCache ; (; const RooArgSet * ; nset, . const RooArgSet * ; iset = nullptr . ); const. protected . Manager of cache with coefficient projections and transformations. ; Retrieve cache element for the computation of the PDF normalisation.; Parameters. [in]nsetCurrent normalisation set (integration over these variables yields 1). ; [in]isetIntegration set. Variables to be integrated over (if integrations are performed). If a cache element does not exist, create and fill it on the fly. The cache also contains; Supplemental normalization terms (in case not all added p.d.f.s have the same observables); Projection integrals to calculate transformed fraction coefficients when a frozen reference frame is provided; Projection integrals for similar transformati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:89158,cache,cache,89158,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['cache'],['cache']
Performance,"any flow of information from the interpreter into the ROOT's typesystem: a snapshot of the typesystem status is taken. ; Definition at line 209 of file TEnum.cxx. ◆ GetEnum() [2/2]. TEnum * TEnum::GetEnum ; (; const std::type_info & ; ti, . ESearchAction ; sa = kALoadAndInterpLookup . ). static . Definition at line 175 of file TEnum.cxx. ◆ GetQualifiedName(). const char * TEnum::GetQualifiedName ; (; ); const. inline . Definition at line 77 of file TEnum.h. ◆ GetUnderlyingType(). EDataType TEnum::GetUnderlyingType ; (; ); const. inline . Get the underlying integer type of the enum: enum E { kOne }; // ==> int enum F: long; // ==> long Returns kNumDataTypes if the enum is unknown / invalid. ; Definition at line 71 of file TEnum.h. ◆ IsA(). TClass * TEnum::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TDictionary.; Definition at line 81 of file TEnum.h. ◆ IsValid(). Bool_t TEnum::IsValid ; (; ). Return true if this enum object is pointing to a currently loaded enum. ; If a enum is unloaded after the TEnum is created, the TEnum will be set to be invalid. ; Definition at line 124 of file TEnum.cxx. ◆ operator=(). TEnum & TEnum::operator= ; (; const TEnum & ; src). Assign operator. ; Definition at line 81 of file TEnum.cxx. ◆ Property(). Long_t TEnum::Property ; (; ); const. overridevirtual . Get property description word. For meaning of bits see EProperty. ; Implements TDictionary.; Definition at line 139 of file TEnum.cxx. ◆ SetClass(). void TEnum::SetClass ; (; TClass * ; cl). inline . Definition at line 75 of file TEnum.h. ◆ Streamer(). void TEnum::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TDictionary. ◆ StreamerNVirtual(). void TEnum::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 81 of file TEnum.h. ◆ Update(). void TEnum::Update ; (; DeclId_t ; id). Definition at line 156 of file TEnum.cxx. Member D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTEnum.html:19033,load,loaded,19033,doc/v632/classTEnum.html,https://root.cern,https://root.cern/doc/v632/classTEnum.html,2,['load'],['loaded']
Performance,"ap< std::string, value_type > _stateNames;  Map state names to index numbers. Make sure state names are updated in recomputeShape(). ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from RooAbsCategory; using value_type = int;  The type used to denote a specific category state. ;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooThresholdCategory.html:41238,cache,cache,41238,doc/master/classRooThresholdCategory.html,https://root.cern,https://root.cern/doc/master/classRooThresholdCategory.html,2,['cache'],['cache']
Performance,"ap< std::string, value_type > _stateNames;  Map state names to index numbers. Make sure state names are updated in recomputeShape(). ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooSuperCategory;  . Additional Inherited Members;  Public Types inherited from RooAbsCategory; using value_type = int;  The type used to denote a specific category state. ;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMultiCategory.html:41614,cache,cache,41614,doc/master/classRooMultiCategory.html,https://root.cern,https://root.cern/doc/master/classRooMultiCategory.html,1,['cache'],['cache']
Performance,"ap< std::string, value_type > _stateNames;  Map state names to index numbers. Make sure state names are updated in recomputeShape(). ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Attributes; TreeReadBuffer * _treeReadBuffer = nullptr;  . Friends; class RooVectorDataStore;  . Legacy interface; Previous versions of RooAbsCategory were based on RooCatType, a class containing a state and a label.; It has been replaced by integers, which use less space and allow for faster access. The following part of the interface should not be used if possible. Since RooCatType in essence is only an index and a state name, equivalent functionality can be achieved using begin() and end(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategory.html:42493,cache,cache,42493,doc/master/classRooAbsCategory.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategory.html,1,['cache'],['cache']
Performance,"ap< std::string, value_type > _stateNames;  Map state names to index numbers. Make sure state names are updated in recomputeShape(). ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; void setDefCat (value_type defCat);  . Friends; class RooMappedCategoryCache;  . Additional Inherited Members;  Public Types inherited from RooAbsCategory; using value_type = int;  The type used to denote a specific category state. ;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMappedCategory.html:41827,cache,cache,41827,doc/master/classRooMappedCategory.html,https://root.cern,https://root.cern/doc/master/classRooMappedCategory.html,1,['cache'],['cache']
Performance,"ap< std::string, value_type > _stateNames;  Map state names to index numbers. Make sure state names are updated in recomputeShape(). ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooAbsCategoryLValue.h>. Inheritance diagram for RooAbsCategoryLValue:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooAbsCategoryLValue() [1/3]",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategoryLValue.html:45920,cache,cache,45920,doc/master/classRooAbsCategoryLValue.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategoryLValue.html,1,['cache'],['cache']
Performance,"ap< std::string, value_type > _stateNames;  Map state names to index numbers. Make sure state names are updated in recomputeShape(). ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooCategory.h>. Inheritance diagram for RooCategory:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ RangeMap_t. using RooCategory::RangeMap_t = std::map<std",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCategory.html:51460,cache,cache,51460,doc/master/classRooCategory.html,https://root.cern,https://root.cern/doc/master/classRooCategory.html,1,['cache'],['cache']
Performance,"ap< std::string, value_type > _stateNames;  Map state names to index numbers. Make sure state names are updated in recomputeShape(). ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooSuperCategory.h>. Inheritance diagram for RooSuperCategory:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooSuperCategory() [1/3]. RooSuperCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSuperCategory.html:47546,cache,cache,47546,doc/master/classRooSuperCategory.html,https://root.cern,https://root.cern/doc/master/classRooSuperCategory.html,1,['cache'],['cache']
Performance,ape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet!,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDecay.html:38238,cache,cache,38238,root/html526/RooDecay.html,https://root.cern,https://root.cern/root/html526/RooDecay.html,1,['cache'],['cache']
Performance,ape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDecay.html:38620,cache,cache,38620,root/html528/RooDecay.html,https://root.cern,https://root.cern/root/html528/RooDecay.html,3,['cache'],['cache']
Performance,"ape(s):. TGeoShape *clip1, *clip2, ... One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; gGeoManager->SetClippingShape(clip1); One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);; Perform ray-tracing:gGeoManager->GetTopVolume()->Raytrace();. One can redo the steps 2-3 as many times as needed. Let us look how the rootgeom.C example looks clipped with a tube. Ray-tracing example with box-clipping. Representing Misalignments of the Ideal Geometry; The ideal positioning of a detector does not match its position in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information. Physical Nodes; Physical nodes are the actual ""touchable"" objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 106-109, therefore it is impossible to create all physical nodes as objects in memory. In TGeo, physical nodes are represented by the class TGeoPhysicalNode and can be created on demand for alignment purposes:; TGeoPhysicalNode(const char* path); TGeoPhysicalNodePhysical nodes are the actual 'touchable' objects in the geometry, representing a path of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:114902,perform,performing,114902,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['performing']
Performance,"ape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidDrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEvePolygonSetProjectedGL.html:1857,cache,cached,1857,root/html528/TEvePolygonSetProjectedGL.html,https://root.cern,https://root.cern/root/html528/TEvePolygonSetProjectedGL.html,3,['cache'],['cached']
Performance,"ape_t;; 140 using BatchIterator_t = TTensorBatchIterator<Data_t, Architecture_t>;; 141 ; 142 const Data_t &fData; ///< The data that should be loaded in the batches.; 143 size_t fNSamples; ///< The total number of samples in the dataset.; 144 size_t fBatchSize; ///< The size of a batch.; 145 Shape_t fInputLayout; ///< The input data layout (does not include batch size); 146 size_t fBatchDepth; ///< The number of matrices in the tensor.; 147 size_t fBatchHeight; ///< The number od rows in each matrix.; 148 size_t fBatchWidth; ///< The number of columns in each matrix.; 149 size_t fNOutputFeatures; ///< The number of outputs from the classifier/regressor.; 150 size_t fBatchIndex; ///< The index of the batch when there are multiple batches in parallel; 151 ; 152 ; 153 size_t fNStreams; ///< Number of buffer pairs.; 154 std::vector<DeviceBuffer_t> fDeviceBuffers; ///< The device buffers used to keep the input, output and weight data.; 155 std::vector<HostBuffer_t> fHostBuffers; ///< The host buffers used to load the input, output and weight data.; 156 ; 157 std::vector<size_t> fSampleIndices; ///< Ordering of the samples in the epoch.; 158 ; 159public:; 160 /*! Constructor. */; 161 TTensorDataLoader(const Data_t &data, size_t nSamples, size_t batchSize, const Shape_t & inputLayout,; 162 const Shape_t & batchLayout, size_t nOutputFeatures, size_t nStreams = 1);; 163 ; 164 TTensorDataLoader(const TTensorDataLoader &) = default;; 165 TTensorDataLoader(TTensorDataLoader &&) = default;; 166 TTensorDataLoader &operator=(const TTensorDataLoader &) = default;; 167 TTensorDataLoader &operator=(TTensorDataLoader &&) = default;; 168 ; 169 /** Copy input tensor into the given host buffer. Function to be specialized by; 170 * the architecture-specific backend. */; 171 void CopyTensorInput(HostBuffer_t &buffer, IndexIterator_t begin);; 172 /** Copy output matrix into the given host buffer. Function to be specialized; 173 * by the architecture-specific backend. */; 174 void CopyTensorO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TensorDataLoader_8h_source.html:6510,load,load,6510,doc/master/TensorDataLoader_8h_source.html,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html,1,['load'],['load']
Performance,"apes""); - filled /added by negotiation with viewer via TVirtualViewer3D. Together these allow clients to publish objects to any one of the 3D viewers; (currently OpenGL/x3d,TPad), free of viewer specific drawing code. They allow; our simple x3d viewer, and considerably more sophisticated OpenGL one to both; work with both geometry libraries (g3d and geom) efficiently.; Publishing to a viewer consists of the following steps:. Create / obtain viewer handle; Begin scene on viewer; Fill mandatory parts of TBuffer3D describing object; Add to viewer; Fill optional parts of TBuffer3D if requested by viewer, and add again; ... repeat 3/4/5; as required; End scene on viewer. Creating / Obtaining Viewer; Create/obtain the viewer handle via local/global pad - the viewer is always; bound to a TPad object at present [This may be removed as a restriction in; the future] . You should perform the publishing to the viewer described below; in the Paint() method of the object you attach to the pad (via Draw()); TVirtualViewer3D * v = gPad->GetViewer3D(""xxxx"");; "" xxxx"" is viewer type: OpenGL ""ogl"", X3D ""x3d"" or; Pad ""pad"" (default). The viewer is created via the plugin manager,; attached to pad, and the interface returned.; Begin / End Scene; Objects must be added to viewer between BeginScene/EndScene calls e.g.; v->BeginScene();; .....; v->AddObject(....);; v->AddObject(....);; .....; v->EndScene();>; The BeginScene call will cause the viewer to suspend redraws etc, and after; the EndScene the viewer will reset the camera to frame the new scene and redraw.; [x3d viewer does not support changing of scenes - objects added after the; first Open/CloseScene pair will be ignored.]; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualViewer3D.html:1630,perform,perform,1630,root/html528/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html528/TVirtualViewer3D.html,6,['perform'],['perform']
Performance,"aph*)myfunc.DrawIntegral(option);; The resulting graph will be drawn into the current pad. If this function is used via the context menu, it recommended to create a new canvas/pad before invoking this function. ; Reimplemented from TF2.; Definition at line 87 of file TF3.h. ◆ ExecuteEvent(). void TF3::ExecuteEvent ; (; Int_t ; event, . Int_t ; px, . Int_t ; py . ). overridevirtual . Execute action corresponding to one event. ; This member function is called when a F3 is clicked with the locator ; Reimplemented from TF2.; Definition at line 209 of file TF3.cxx. ◆ FindMinMax(). Double_t TF3::FindMinMax ; (; Double_t * ; x, . bool ; findmax . ); const. overrideprotectedvirtual . Return minimum/maximum value of the function. ; To find the minimum on a range, first set this range via the SetRange function If a vector x of coordinate is passed it will be used as starting point for the minimum. In addition on exit x will contain the coordinate values at the minimuma If x is NULL or x is inifinity or NaN, first, a grid search is performed to find the initial estimate of the minimum location. The range of the function is divided into fNpx and fNpy sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed by SetNpx and SetNpy functions; Then, a minimization is used with starting values found by the grid search The minimizer algorithm used (by default Minuit) can be changed by callinga ROOT::Math::Minimizer::SetDefaultMinimizerType("".."") Other option for the minimizer can be set using the static method of the MinimizerOptions class ; Reimplemented from TF2.; Definition at line 230 of file TF3.cxx. ◆ GetClippingBox(). virtual const Double_t * TF3::GetClippingBox ; (; ); const. inlinevirtual . Definition at line 110 of file TF3.h. ◆ GetClippingBoxOn(). virtual Bool_t TF3::GetClippingBoxOn ; (; ); const. inlinevirtual . Definition at line 108 of file TF3.h. ◆ GetMaximumXYZ(). Double_t TF3::GetMaximumXYZ ; (; Double_t & ; x, . Double_t & ; y, . Double_t & ; z .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF3.html:60815,perform,performed,60815,doc/master/classTF3.html,https://root.cern,https://root.cern/doc/master/classTF3.html,1,['perform'],['performed']
Performance,"aph.h:139; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualFitter::fPointSizeInt_t fPointSizeNumber of words per point in the cache.Definition TVirtualFitter.h:40; TVirtualFitter::GetObjectFitvirtual TObject * GetObjectFit() constDefinition TVirtualFitter.h:77; TVirtualFitter::fUserFuncTObject * fUserFuncPointer to user theoretical function (a TF1*)Definition TVirtualFitter.h:44; TVirtualFitter::GetFitOptionvirtual Foption_t GetFitOption() constDefinition TVirtualFitter.h:73; TVirtualFitter::SetFCNvirtual void SetFCN(void(*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t))To set the address of the minimization objective function called by the native compiler (see function...Definition TVirtualFitter.cxx:267; TVirtualFitter::fCacheDouble_t * fCache[fCacheSize] Array of points data (fNpoints*fPointSize < fCacheSize words)Definition TVirtualFitter.h:42; TVirtualFitter::fFCNvoid(* fFCN)(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag)Definition TVirtualFitter.h:46; TVirtualFitter::GetFitterstatic TVirtualFitter * GetFitter()static: return the current ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:79321,cache,cache,79321,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,1,['cache'],['cache']
Performance,"aphics Editors) functionality and the library is loaded using the plug-in mechanism. Editing a Geometry; There are two different use cases having different ways of invoking the geometry editors. The first one applies when starting with geometry from scratch and using the builder functionality to create new geometry objects. In this case, one should use the sequence:; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; The lines above will create a new TGeoManager class, create an empty canvas and start the editor in the left-sided editor frame attached to the canvas. To open the editor in a separate frame one should provide a non-empty string as option to the Edit() method. The geometry manager editor. The Geometry Manager Editor. Accessing/creating different categories of editable objects; The second use case applies when starting to edit an existing geometry. Supposing the geometry was loaded into memory, besides the first method that still applies one can also edit drawn geometry objects. For this, the menu entry View/Editor of the canvas containing for instance a drawn volume must be activated. For starting the volume editor one can click on a volume. The GUI of the TGeoManager class can be started by clicking on the top-right 40x40 pixels corner of the pad with a drawn geometry.; This is the main entry point for editing the geometry or creating new objects. Once the interface is created (using one of the methods described above), several categories can be accessed via a shutter GUI widget:. General. This allows changing the name/title of the geometry, setting the top volume, closing the geometry and saving the geometry in a file. The file name is formed by geometry_name.C or .root depending if the geometry need to be saved as a C macro or a .root file.; Shapes. The category provides buttons for creation of all supported shapes. The new shape name is chosen by the interface, but can be changed from the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:137786,load,loaded,137786,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['load'],['loaded']
Performance,"applyCutvirtual bool GetReapplyCut() constDefinition TEventList.h:57; TEventList::GetNvirtual Int_t GetN() constDefinition TEventList.h:56; TFileCacheReadA cache when reading files over the network.Definition TFileCacheRead.h:22; TFileCacheRead::WaitFinishPrefetchvirtual void WaitFinishPrefetch()Definition TFileCacheRead.cxx:691; TFileCacheRead::GetBufferSizevirtual Int_t GetBufferSize() constDefinition TFileCacheRead.h:88; TFileMergeInfoDefinition TFileMergeInfo.h:42; TFileMergeInfo::fIOFeaturesTIOFeatures * fIOFeaturesDefinition TFileMergeInfo.h:55; TFileMergeInfo::fIsFirstBool_t fIsFirstDefinition TFileMergeInfo.h:52; TFileMergeInfo::fOptionsTString fOptionsDefinition TFileMergeInfo.h:53; TFileMergeInfo::fOutputDirectoryTDirectory * fOutputDirectoryDefinition TFileMergeInfo.h:51; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::SetCacheReadvirtual void SetCacheRead(TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect)Set a pointer to the read cache.Definition TFile.cxx:2365; TFile::GetCompressionSettingsInt_t GetCompressionSettings() constDefinition TFile.h:397; TFile::GetCompressionLevelInt_t GetCompressionLevel() constDefinition TFile.h:391; TFile::GetENDvirtual Long64_t GetEND() constDefinition TFile.h:231; TFile::WriteStreamerInfovirtual void WriteStreamerInfo()Write the list of TStreamerInfo as a single object in this file The class Streamer description for al...Definition TFile.cxx:3792; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::MakeFreevirtual void MakeFree(Long64_t first, Long64_t last)Mark unused bytes on the file.Definition TFile.cxx:1484; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:411768,cache,cache,411768,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,['cache'],['cache']
Performance,"aps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooMultiCategory&operator=(const RooMultiCategory&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiCategory.html:11411,optimiz,optimizeCacheMode,11411,root/html602/RooMultiCategory.html,https://root.cern,https://root.cern/root/html602/RooMultiCategory.html,2,['optimiz'],['optimizeCacheMode']
Performance,"aps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooSuperCategory&operator=(const RooSuperCategory&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSuperCategory.html:12199,optimiz,optimizeCacheMode,12199,root/html602/RooSuperCategory.html,https://root.cern,https://root.cern/root/html602/RooSuperCategory.html,2,['optimiz'],['optimizeCacheMode']
Performance,"apsize). overridevirtual . Set the initial size of the map used to store object and class references during reading. ; The default size is TBufferFile::kMapSize. Increasing the default has the benefit that when reading many small objects the map does not need to be resized too often (the system is always dynamic, even with the default everything will work, only the initial resizing will cost some time). This method can only be called directly after the creation of the TBuffer, before any reading is done. Globally this option can be changed using SetGlobalReadParam(). ; Implements TBuffer.; Definition at line 97 of file TBufferIO.cxx. ◆ SetWriteParam(). void TBufferIO::SetWriteParam ; (; Int_t ; mapsize). overridevirtual . Set the initial size of the hashtable used to store object and class references during writing. ; The default size is TBufferFile::kMapSize. Increasing the default has the benefit that when writing many small objects the hashtable does not get too many collisions (the system is always dynamic, even with the default everything will work, only a large number of collisions will cost performance). For optimal performance hashsize should always be a prime. This method can only be called directly after the creation of the TBuffer, before any writing is done. Globally this option can be changed using SetGlobalWriteParam(). ; Implements TBuffer.; Definition at line 117 of file TBufferIO.cxx. ◆ Streamer(). void TBufferIO::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TBuffer.; Reimplemented in TBufferJSON, TBufferText, TBufferSQL2, TBufferXML, TMessage, and TBufferSQL. ◆ StreamerNVirtual(). void TBufferIO::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 120 of file TBufferIO.h. ◆ TagStreamerInfo(). void TBufferIO::TagStreamerInfo ; (; TVirtualStreamerInfo * ; info). overridevirtual . Mark the classindex of the current file as using this TStreamerInfo. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferIO.html:40784,perform,performance,40784,doc/master/classTBufferIO.html,https://root.cern,https://root.cern/doc/master/classTBufferIO.html,1,['perform'],['performance']
Performance,"apsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); Exit scene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (defa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLScene.html:11562,perform,perform,11562,root/html528/TGLScene.html,https://root.cern,https://root.cern/root/html528/TGLScene.html,6,['perform'],['perform']
Performance,"ar *selExpr=nullptr, const char *wgtVarName=nullptr);  ;  RooTreeDataStore (RooStringView name, RooStringView title, const RooArgSet &vars, TTree &t, const char *selExpr=nullptr, const char *wgtVarName=nullptr);  ;  RooTreeDataStore (RooStringView name, RooStringView title, RooAbsDataStore &tds, const RooArgSet &vars, const RooFormulaVar *cutVar, const char *cutRange, Int_t nStart, Int_t nStop, const char *wgtVarName=nullptr);  ;  RooTreeDataStore (TTree *t, const RooArgSet &vars, const char *wgtVarName=nullptr);  Constructor to facilitate reading of legacy RooDataSets. ;  ;  ~RooTreeDataStore () override;  Destructor. ;  ; RooAbsArg * addColumn (RooAbsArg &var, bool adjustRange=true) override;  Add a new column to the data set which holds the pre-calculated values of 'newVar'. ;  ; void append (RooAbsDataStore &other) override;  ; void attachBuffers (const RooArgSet &extObs) override;  ; void cacheArgs (const RooAbsArg *owner, RooArgSet &varSet, const RooArgSet *nset=nullptr, bool skipZeroWeights=false) override;  Cache given RooAbsArgs with this tree: The tree is given direct write access of the args internal cache the args values is pre-calculated for all data points in this data collection. ;  ; const RooAbsArg * cacheOwner () override;  ; bool changeObservableName (const char *from, const char *to) override;  Change name of internal observable named 'from' into 'to'. ;  ; void checkInit () const override;  ; RooAbsDataStore * clone (const char *newname=nullptr) const override;  ; RooAbsDataStore * clone (const RooArgSet &vars, const char *newname=nullptr) const override;  ; void Draw (Option_t *option="""") override;  Default Draw method for all objects. ;  ; Int_t Fill ();  Interface function to TTree::Fill. ;  ; Int_t fill () override;  Interface function to TTree::Fill. ;  ; virtual const RooArgSet * get () const;  ; const RooArgSet * get (Int_t index) const override;  Load the n-th data point (n='index') in memory and return a pointer to the internal RooArgSet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:3049,cache,cacheArgs,3049,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,2,['cache'],"['cache', 'cacheArgs']"
Performance,"ar * BaseName (const char *pathname);  Base name of a file name. Base name of /user/root is root. ;  ; void Beep (Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE);  Beep for duration milliseconds with a tone of frequency freq. ;  ; Bool_t cd (const char *path);  ; virtual Bool_t ChangeDirectory (const char *path);  Change directory. ;  ; virtual int Chmod (const char *file, UInt_t mode);  Set the file permission bits. Returns -1 in case or error, 0 otherwise. ;  ; virtual void CleanCompiledMacros ();  Remove the shared libs produced by the CompileMacro() function, together with their rootmaps, linkdefs, and pcms (and some more on Windows). ;  ; virtual void CloseConnection (int sock, Bool_t force=kFALSE);  Close socket connection. ;  ; virtual void Closelog ();  Close connection to system log daemon. ;  ; virtual int ClosePipe (FILE *pipe);  Close the pipe. ;  ; virtual int CompileMacro (const char *filename, Option_t *opt="""", const char *library_name="""", const char *build_dir="""", UInt_t dirmode=0);  This method compiles and loads a shared library containing the code from the file ""filename"". ;  ; virtual char * ConcatFileName (const char *dir, const char *name);  Concatenate a directory and a file name. User must delete returned string. ;  ; virtual int CopyFile (const char *from, const char *to, Bool_t overwrite=kFALSE);  Copy a file. ;  ; virtual const char * DirName (const char *pathname);  Return the directory name in pathname. ;  ; virtual void DispatchOneEvent (Bool_t pendingOnly=kFALSE);  Dispatch a single event. ;  ; char * DynamicPathName (const char *lib, Bool_t quiet=kFALSE);  Find a dynamic library called lib using the system search paths. ;  ; virtual Func_t DynFindSymbol (const char *module, const char *entry);  Find specific entry point in specified library. ;  ; virtual Int_t Exec (const char *shellcmd);  Execute a command. ;  ; virtual void Exit (int code, Bool_t mode=kTRUE);  Exit the application. ;  ; virtual void ExitLoop ();  Exit fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixSystem.html:4156,load,loads,4156,doc/master/classTDavixSystem.html,https://root.cern,https://root.cern/doc/master/classTDavixSystem.html,6,['load'],['loads']
Performance,"ar * DeclFileName ();  ;  Static Public Member Functions inherited from TFile; static TFileOpenHandle * AsyncOpen (const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0);  Submit an asynchronous open request. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Cp (const char *src, const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000);  Allows to copy file from src to dst URL. ;  ; static TFile *& CurrentFile ();  Return the current ROOT file if any. ;  ; static const char * DeclFileName ();  ; static EAsyncOpenStatus GetAsyncOpenStatus (const char *name);  Get status of the async open request related to 'name'. ;  ; static EAsyncOpenStatus GetAsyncOpenStatus (TFileOpenHandle *handle);  Get status of the async open request related to 'handle'. ;  ; static const char * GetCacheFileDir ();  Get the directory where to locally stage/cache remote files. ;  ; static const TUrl * GetEndpointUrl (const char *name);  Get final URL for file being opened asynchronously. ;  ; static Long64_t GetFileBytesRead ();  Static function returning the total number of bytes read from all files. ;  ; static Long64_t GetFileBytesWritten ();  Static function returning the total number of bytes written to all files. ;  ; static Long64_t GetFileCounter ();  ; static Int_t GetFileReadCalls ();  Static function returning the total number of read calls from all files. ;  ; static Bool_t GetOnlyStaged ();  Returns staged only flag. ;  ; static UInt_t GetOpenTimeout ();  Returns open timeout (in ms). ;  ; static Int_t GetReadaheadSize ();  Static function returning the readahead buffer size. ;  ; static Bool_t GetReadStreamerInfo ();  If the streamerinfos are to be read at file opening. ;  ; static EFileType GetType (const char *name, Option_t *option="""", TString *prefix=nullptr);  Resolve the file type as a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:27819,cache,cache,27819,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,10,['cache'],['cache']
Performance,"ar expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8529 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8660 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:207673,cache,cachesize,207673,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['cache'],"['cache', 'cachesize']"
Performance,"ar expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8534 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8665 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8831 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8865 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8683 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; The cacheSize might be clamped, see TFileCacheRead::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:210164,cache,cachesize,210164,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['cache'],"['cache', 'cachesize']"
