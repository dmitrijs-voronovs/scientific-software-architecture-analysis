quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance,s of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooNumConvolution*_conv! Actual convolution calculation; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! do not persist; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_o,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:39257,cache,cache,39257,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,1,['cache'],['cache']
Performance,s of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooNumConvolution*_conv! Actual convolution calculation; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! do not persist; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*Ro,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumConvPdf.html:39639,cache,cache,39639,root/html528/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html528/RooNumConvPdf.html,3,['cache'],['cache']
Performance,"s of objects written so far; TStringfTablesType! type, used in CREATE TABLE statements; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tfUseIndexes! use indexes for tables: 0 - off, 1 - only for basic tables, 2 + normal class tables, 3 - all tables; Bool_tfUseSuffixes! use suffixes in column names like fValue:Int_t or fObject:pointer; Int_tfUseTransactions! use transaction statements for writing data into the tables; TStringfUserName! user name, used to access objects from database; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static atomic<Long64_t>TFile::fgBytesReadNumber of bytes read by all TFile objects; static atomic<Long64_t>TFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static atomic<Long64_t>TFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static atomic<Int_t>TFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size; static TSQLFile::ELockingKindskLockBusy; static TSQLFile::ELockingKindskLockFree.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLFile.html:34408,cache,cache,34408,root/html602/TSQLFile.html,https://root.cern,https://root.cern/root/html602/TSQLFile.html,6,"['CACHE', 'cache']","['CACHEREAD', 'cache', 'cached']"
Performance,"s of other objects). ; Reimplemented from TObject.; Definition at line 547 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; NoteThis function is overloaded in TChain. ; Reimplemented in TChain, and TTreeSQL.; Definition at line 6473 of file TTree.cxx. ◆ LoadTreeFriend(). Long64_t TTree::LoadTreeFriend ; (; Long64_t ; entry, . TTree * ; masterTree . ). virtual . Load entry on behalf of our master tree, we may use an index. ; Called by LoadTree() when the masterTree looks for the entry number in a friend tree (us) corresponding to the passed entry number in the masterTree.; If we have no index, our entry number and the masterTree entry number are the same.; If we do have an index, we must find the (major, minor) value pair in masterTree to locate our corresponding entry. ; Definition at line 6557 of file TTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:171212,Load,LoadTree,171212,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['Load'],['LoadTree']
Performance,"s of other objects). ; Reimplemented from TObject.; Definition at line 587 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; NoteThis function is overloaded in TChain. ; Reimplemented in TChain, and TTreeSQL.; Definition at line 6473 of file TTree.cxx. ◆ LoadTreeFriend(). Long64_t TTree::LoadTreeFriend ; (; Long64_t ; entry, . TTree * ; masterTree . ). virtual . Load entry on behalf of our master tree, we may use an index. ; Called by LoadTree() when the masterTree looks for the entry number in a friend tree (us) corresponding to the passed entry number in the masterTree.; If we have no index, our entry number and the masterTree entry number are the same.; If we do have an index, we must find the (major, minor) value pair in masterTree to locate our corresponding entry. ; Definition at line 6557 of file TTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:173400,Load,LoadTree,173400,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['Load'],['LoadTree']
Performance,"s of the freed record on the file are overwritten by GAPSIZE; where GAPSIZE = -(Number of bytes occupied by the record). Option compress is used to specify the compression level:; compress = 0 objects written to this file will not be compressed.; compress = 1 minimal compression level but fast. compress = 9 maximal compression level but slow. Note that the compression level may be changed at any time.; The new compression level will only apply to newly written objects.; The function TFile::Map() shows the compression factor; for each object written to this file.; The function TFile::GetCompressionFactor returns the global; compression factor for this file. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:26130,perform,performed,26130,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,1,['perform'],['performed']
Performance,"s of the; spectrum region. Usually peak finders fail to detect them.; resolution, decomposition of Double_tts and multiplets.; The algorithm should be able to recognize close positioned peaks.; ability to identify peaks with different sigma.; . Fig. 27 An example of one-dimensional synthetic spectrum with found peaks; denoted by markers.; ; References:. M.A. Mariscotti: A method for identification of peaks in the presence of; background and its application to spectrum analysis. NIM 50 (1967),; 309-320.; M. Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�,; I. Turzo.:Identification of peaks in; multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM; A 376 (1996), 451.; . Examples of peak searching method:. The SearchHighRes function provides users with the possibility to vary the; input parameters and with the access to the output deconvolved data in the; destination spectrum. Based on the output data one can tune the parameters.; ; Example 15 - script SearchHR1.c:; . Fig. 28 One-dimensional spectrum with found peaks denoted by markers, 3; iterations steps in the deconvolution.; . Fig. 29 One-dimensional spectrum with found peaks denoted by markers, 8; iterations steps in the deconvolution.; ; Script:; ; // Example to illustrate high resolution peak searching function (class TSpectrum).; // To execute this example, do; // root > .x SearchHR1.C; #include ; void SearchHR1() {; Double_t fPositionX[100];; Double_t fPositionY[100];; Int_t fNPeaks = 0;; Int_t i,nfound,bin;; Double_t nbins = 1024,a;; Double_t xmin = 0;; Double_t xmax = nbins;; Double_t * source = new Double_t[nbins];; Double_t * dest = new Double_t[nbins];; TH1F *h = new TH1F(""h"",""High resolution peak searching, number of iterations = 3"",nbins,xmin,xmax);; TH1F *d = new TH1F(""d"","""",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; h=(TH1F*) f->Get(""search2;1"");; for (i = 0; i < nbins; i++) source[i]=h->Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum.html:54021,tune,tune,54021,root/html602/TSpectrum.html,https://root.cern,https://root.cern/root/html602/TSpectrum.html,2,['tune'],['tune']
Performance,"s of those parameters to calculate their function value.; 791/// The starting values must be specified by the user.; 792/// Later values are determined by Minuit as it searches for the minimum; 793/// or performs whatever analysis is requested by the user.; 794///; 795/// Note that this virtual function may be redefined in a class derived from TMinuit.; 796/// The default function calls the function specified in SetFCN; 797///; 798/// Example of Minimisation function:; 799 ; 800Int_t TMinuit::Eval(Int_t npar, Double_t *grad, Double_t &fval, Double_t *par, Int_t flag); 801{; 802/*; 803 if (flag == 1) {; 804 read input data,; 805 calculate any necessary constants, etc.; 806 }; 807 if (flag == 2) {; 808 calculate GRAD, the first derivatives of FVAL; 809 (this is optional); 810 }; 811 Always calculate the value of the function, FVAL,; 812 which is usually a chisquare or log likelihood.; 813 if (iflag == 3) {; 814 will come here only after the fit is finished.; 815 Perform any final calculations, output fitted data, etc.; 816 }; 817*/; 818// See concrete examples in TH1::H1FitChisquare, H1FitLikelihood; 819 ; 820 if (fFCN) (*fFCN)(npar,grad,fval,par,flag);; 821 return 0;; 822}; 823 ; 824////////////////////////////////////////////////////////////////////////////////; 825/// fix a parameter; 826 ; 827Int_t TMinuit::FixParameter( Int_t parNo); 828{; 829 Int_t err;; 830 Double_t tmp[1];; 831 tmp[0] = parNo+1; //set internal Minuit numbering; 832 ; 833 mnexcm( ""FIX"", tmp, 1, err );; 834 ; 835 return err;; 836}; 837 ; 838////////////////////////////////////////////////////////////////////////////////; 839/// return parameter value and error; 840 ; 841Int_t TMinuit::GetParameter( Int_t parNo, Double_t &currentValue, Double_t &currentError ) const; 842{; 843 Int_t err;; 844 TString name; // ignored; 845 Double_t bnd1, bnd2; // ignored; 846 ; 847 mnpout( parNo, name, currentValue, currentError, bnd1, bnd2, err );; 848 ; 849 return err;; 850}; 851 ; 852///////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:30767,Perform,Perform,30767,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['Perform'],['Perform']
Performance,"s only; 385 */; 386 DisplacementVector3D<CoordSystem, Tag>& SetRho (Scalar rr) { fCoordinates.SetRho(rr); return *this;}; 387 ; 388 /**; 389 Change Eta - CylindricalEta3D coordinates only; 390 */; 391 DisplacementVector3D<CoordSystem, Tag>& SetEta (Scalar etaval) { fCoordinates.SetEta(etaval); return *this;}; 392 ; 393 ; 394 // ------ Operations combining two vectors ------; 395 // -- need to have the specialized version in order to avoid; 396 ; 397 /**; 398 Return the scalar (dot) product of two displacement vectors.; 399 It is possible to perform the product for any type of vector coordinates,; 400 but they must have the same coordinate system tag; 401 */; 402 template< class OtherCoords >; 403 Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v) const {; 404 return X()*v.X() + Y()*v.Y() + Z()*v.Z();; 405 }; 406 /**; 407 Return the scalar (dot) product of two vectors.; 408 It is possible to perform the product for any classes; 409 implementing x(), y() and z() member functions; 410 */; 411 template< class OtherVector >; 412 Scalar Dot( const OtherVector & v) const {; 413 return X()*v.x() + Y()*v.y() + Z()*v.z();; 414 }; 415 ; 416 /**; 417 Return vector (cross) product of two displacement vectors,; 418 as a vector in the coordinate system of this class.; 419 It is possible to perform the product for any type of vector coordinates,; 420 but they must have the same coordinate system tag; 421 */; 422 template <class OtherCoords>; 423 DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v) const {; 424 DisplacementVector3D result;; 425 result.SetXYZ ( Y()*v.Z() - v.Y()*Z(),; 426 Z()*v.X() - v.Z()*X(),; 427 X()*v.Y() - v.X()*Y() );; 428 return result;; 429 }; 430 /**; 431 Return vector (cross) product of two vectors,; 432 as a vector in the coordinate system of this class.; 433 It is possible to perform the product for any classes; 434 implementing X(), Y() and Z() member functions; 435 */; 436 template <class OtherVector>; 437 DisplacementVe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:13028,perform,perform,13028,doc/master/GenVector_2DisplacementVector3D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html,1,['perform'],['perform']
Performance,"s option 1, but you delete yourself the event.; for (Long64_t i=0;i<nentries;i++) {; delete event;; event = 0; // EXTREMELY IMPORTANT; T.GetEntry(i);; // the object event has been filled at this point; }. It is strongly recommended to use the default option 1. It has the; additional advantage that functions like TTree::Draw (internally calling; TTree::GetEntry) will be functional even when the classes in the file are; not available. TEntryList* GetEntryList(); Returns the entry list, set to this tree. Long64_t GetEntryNumber(Long64_t entry) const; Return entry number corresponding to entry. if no TEntryList set returns entry; else returns the entry number corresponding to the list index=entry. Long64_t GetEntryNumberWithBestIndex(Int_t major, Int_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table.; If an entry corresponding to major and minor is not found, the function; returns the index of the major,minor pair immediatly lower than the; requested value, ie it will return -1 if the pair is lower than; the first entry in the index. See also GetEntryNumberWithIndex. Long64_t GetEntryNumberWithIndex(Int_t major, Int_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:95340,perform,performs,95340,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['perform'],['performs']
Performance,"s option 1, but you delete yourself the event.; for (Long64_t i=0;i<nentries;i++) {; delete event;; event = 0; // EXTREMELY IMPORTANT; T.GetEntry(i);; // the object event has been filled at this point; }. It is strongly recommended to use the default option 1. It has the; additional advantage that functions like TTree::Draw (internally; calling TTree::GetEntry) will be functional even when the classes in the; file are not available. TEntryList* GetEntryList(); Returns the entry list, set to this tree. Long64_t GetEntryNumber(Long64_t entry) const; Return entry number corresponding to entry. if no TEntryList set returns entry; else returns the entry number corresponding to the list index=entry. Long64_t GetEntryNumberWithBestIndex(Int_t major, Int_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table.; If an entry corresponding to major and minor is not found, the function; returns the index of the major,minor pair immediatly lower than the; requested value, ie it will return -1 if the pair is lower than; the first entry in the index. See also GetEntryNumberWithIndex. Long64_t GetEntryNumberWithIndex(Int_t major, Int_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:91145,perform,performs,91145,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['perform'],['performs']
Performance,"s pad. ; The most important graphics class in the ROOT system. ; A Pad is contained in a Canvas.; A Pad may contain other pads (unlimited pad hierarchy).; A pad is a linked list of primitives of any type (graphics objects, histograms, detectors, tracks, etc.).; Adding a new element into a pad is in general performed by the Draw member function of the object classes.; It is important to realize that the pad is a linked list of references to the original object. For example, in case of a histogram, the histogram.Draw() operation only stores a reference to the histogram object and not a graphical representation of this histogram. When the mouse is used to change (say the bin content), the bin content of the original histogram is changed.; The convention used in ROOT is that a Draw operation only adds a reference to the object. The effective drawing is performed when the canvas receives a signal to be painted. This signal is generally sent when typing carriage return in the command input or when a graphical operation has been performed on one of the pads of this canvas. When a Canvas/Pad is repainted, the member function Paint for all objects in the Pad linked list is invoked. When the mouse is moved on the Pad, The member function DistancetoPrimitive is called for all the elements in the pad. DistancetoPrimitive returns the distance in pixels to this object.; When the object is within the distance window, the member function ExecuteEvent is called for this object.; In ExecuteEvent, move, changes can be performed on the object.; For examples of DistancetoPrimitive and ExecuteEvent functions, see classes TLine::DistancetoPrimitive, TLine::ExecuteEvent; TBox::DistancetoPrimitive, TBox::ExecuteEvent; TH1::DistancetoPrimitive, TH1::ExecuteEvent; TBox::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TBox.cxx:232; TBox::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:1469,perform,performed,1469,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['perform'],['performed']
Performance,"s particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; void df019_Cache(); {; // We create a data frame on top of the hsimple example.; auto hsimplePath = gROOT->GetTutorialDir();; hsimplePath += ""/hsimple.root"";; ROOT::RDataFrame df(""ntuple"", hsimplePath.Data());; ; // We apply a simple cut and define a new column.; auto df_cut = df.Filter([](float py) { return py > 0.f; }, {""py""}); .Define(""px_plus_py"", [](float px, float py) { return px + py; }, {""px"", ""py""});; ; // We cache the content of the dataset. Nothing has happened yet: the work to accomplish; // has been described. As for `Snapshot`, the types and columns can be written out explicitly; // or left for the jitting to handle (`df_cached` is intentionally unused - it shows how; // to create a *cached* dataframe specifying column types explicitly):; auto df_cached = df_cut.Cache<float, float>({""px_plus_py"", ""py""});; auto df_cached_implicit = df_cut.Cache();; auto h = df_cached_implicit.Histo1D<float>(""px_plus_py"");; ; // Now the event loop on the cached dataset is triggered. This event triggers the loop; // on the `df` data frame lazily.; h->DrawCopy();; }; h#define h(i)Definition RSha256.hxx:106; gROOT#define gROOTDefinition TROOT.h:406; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; df019_CacheDefinition df019_Cache.py:1; . DateJune 2018 ; AuthorDanilo Piparo (CERN) ; Definition in file df019_Cache.C. tutorialsdataframedf019_Cache.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df019__Cache_8C.html:1766,cache,cached,1766,doc/master/df019__Cache_8C.html,https://root.cern,https://root.cern/doc/master/df019__Cache_8C.html,4,"['Cache', 'cache']","['Cache', 'cached']"
Performance,"s read; TList*TEventIter::fPacketslist of packets processed packets; TStringTEventIter::fPathPath to current TDirectory; TSelector*TEventIter::fSelselector to be used; Bool_tTEventIter::fStoptermination of run requested. private:. Long64_tfCacheSizeCache size; Bool_tfDontCacheFilesControl OS caching of read files (Mac Os X only); TList*fFileTreesFiles && Trees currently open; TTree*fTreetree we are iterating over; TTreeCache*fTreeCacheinstance of the tree cache for the tree; Bool_tfTreeCacheIsLearningWhether cache is in learning phase; TStringfTreeNamename of the tree object to iterate over; Bool_tfUseParallelUnzipControl usage of parallel unzip; Bool_tfUseTreeCacheControl usage of the tree cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIterTree(); Default ctor. TEventIterTree(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIterTree(); Destructor. Long64_t GetCacheSize(); Return the size in bytes of the cache, if any; Return -1 if not used. Int_t GetLearnEntries(); Return the number of entries in the learning phase. TTree* GetTrees(TDSetElement* elem); Create a Tree for the main TDSetElement and for all the friends.; Returns the main tree or 0 in case of an error. TTree* Load(TDSetElement* elem, Bool_t& localfile, const char* objname = 0); Load a tree from s TDSetElement. Int_t GetNextPacket(Long64_t& first, Long64_t& num, TEntryList** enl = 0, TEventList** evl = 0); Get loop range. void PreProcessEvent(Long64_t ent); Actions to be done just before processing entry 'entry'.; Called by TProofPlayer. Long64_t GetNextEvent(); Get next event. TEventIterTree(). » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-04 09:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEventIterTree.html:8654,Load,Load,8654,root/html604/TEventIterTree.html,https://root.cern,https://root.cern/root/html604/TEventIterTree.html,2,['Load'],['Load']
Performance,"s read; TList*TEventIter::fPacketslist of packets processed packets; TStringTEventIter::fPathPath to current TDirectory; TSelector*TEventIter::fSelselector to be used; Bool_tTEventIter::fStoptermination of run requested. private:. Long64_tfCacheSizeCache size; Bool_tfDontCacheFilesControl OS caching of read files (Mac Os X only); TList*fFileTreesFiles && Trees currently open; TTree*fTreetree we are iterating over; TTreeCache*fTreeCacheinstance of the tree cache for the tree; Bool_tfTreeCacheIsLearningWhether cache is in learning phase; TStringfTreeNamename of the tree object to iterate over; Bool_tfUseParallelUnzipControl usage of parallel unzip; Bool_tfUseTreeCacheControl usage of the tree cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIterTree(); Default ctor. TEventIterTree(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIterTree(); Destructor. Long64_t GetCacheSize(); Return the size in bytes of the cache, if any; Return -1 if not used. Int_t GetLearnEntries(); Return the number of entries in the learning phase. TTree* GetTrees(TDSetElement* elem); Create a Tree for the main TDSetElement and for all the friends.; Returns the main tree or 0 in case of an error. TTree* Load(TDSetElement* elem, Bool_t& localfile, const char* objname = 0); Load a tree from s TDSetElement. Int_t GetNextPacket(Long64_t& first, Long64_t& num, TEntryList** enl = 0, TEventList** evl = 0); Get loop range. void PreProcessEvent(Long64_t ent); Actions to be done just before processing entry 'entry'.; Called by TProofPlayer. Long64_t GetNextEvent(); Get next event. TEventIterTree(). » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-30 14:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEventIterTree.html:8654,Load,Load,8654,root/html602/TEventIterTree.html,https://root.cern,https://root.cern/root/html602/TEventIterTree.html,2,['Load'],['Load']
Performance,"s related to input layout but not the same.; If the first layer is dense it should be ``1 | batch size ! number of variables`` (features); ; *(note the use of the character `|` as separator of input parameters for DNN layout)*; ; note that in case of only dense layer the input layout could be omitted but it is required when defining more; complex architectures; ; - **layer layout** string defining the layer architecture. The syntax is; - layer type (e.g. DENSE, CONV, RNN); - layer parameters (e.g. number of units); - activation function (e.g TANH, RELU,...); ; *the different layers are separated by the ``"",""`` *; ; #### 2. Define Training Strategy; ; We define here the training strategy parameters for the DNN. The parameters are separated by the ``"",""`` separator.; One can then concatenate different training strategy with different parameters. The training strategy are separated by; the ``""|""`` separator.; ; - Optimizer; - Learning rate; - Momentum (valid for SGD and RMSPROP); - Regularization and Weight Decay; - Dropout; - Max number of epochs; - Convergence steps. if the test error will not decrease after that value the training will stop; - Batch size (This value must be the same specified in the input layout); - Test Repetitions (the interval when the test error will be computed); ; ; #### 3. Define general DNN options; ; We define the general DNN options concatenating in the final string the previously defined layout and training strategy.; Note we use the ``"":""`` separator to separate the different higher level options, as in the other TMVA methods.; In addition to input layout, batch layout and training strategy we add now:; ; - Type of Loss function (e.g. CROSSENTROPY); - Weight Initizalization (e.g XAVIER, XAVIERUNIFORM, NORMAL ); - Variable Transformation; - Type of Architecture (e.g. CPU, GPU, Standard); ; We can then book the DL method using the built option string; ; ***/; ; if (useDL) {; ; bool useDLGPU = false;; #ifdef R__HAS_TMVAGPU; useDLGPU = true;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:64613,Optimiz,Optimizer,64613,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['Optimiz'],['Optimizer']
Performance,"s requires special care in sections protected by GetSharedDescriptorGuard() and GetExclDescriptorGuard() especially to avoid that the locks are acquired indirectly (e.g. by a call to GetNEntries()). As a general guideline, no other method of the page source should be called (directly or indirectly) in a guarded section. ; Definition at line 722 of file RPageStorage.hxx. ◆ GetType(). EPageStorageType ROOT::Experimental::Internal::RPageSource::GetType ; (; ). inlinefinalvirtual . Whether the concrete implementation is a sink or a source. ; Implements ROOT::Experimental::Internal::RPageStorage.; Definition at line 713 of file RPageStorage.hxx. ◆ LoadClusters(). virtual std::vector< std::unique_ptr< RCluster > > ROOT::Experimental::Internal::RPageSource::LoadClusters ; (; std::span< RCluster::RKey > ; clusterKeys). pure virtual . Populates all the pages of the given cluster ids and columns; it is possible that some columns do not contain any pages. ; The page source may load more columns than the minimal necessary set from columns. To indicate which columns have been loaded, LoadClusters()must mark them withSetColumnAvailable(). That includes the ones from thecolumnsthat don't have pages; otherwise subsequent requests for the cluster would assume an incomplete cluster and trigger loading again. LoadClusters()` is typically called from the I/O thread of a cluster pool, i.e. the method runs concurrently to other methods of the page source. ; Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSourceDaos, and ROOT::Experimental::Internal::RPageSourceFile. ◆ LoadPage() [1/2]. ROOT::Experimental::Internal::RPageRef ROOT::Experimental::Internal::RPageSource::LoadPage ; (; ColumnHandle_t ; columnHandle, . NTupleSize_t ; globalIndex . ). virtual . Allocates and fills a page that contains the index-th element. ; The default implementation searches the page and calls LoadPageImpl(). Returns a default-constructed RPage for suppressed ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:14234,load,load,14234,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['load'],['load']
Performance,"s so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:18824,cache,cache,18824,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,1,['cache'],['cache']
Performance,"s so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCache.html:20690,cache,cache,20690,root/html530/TTreeCache.html,https://root.cern,https://root.cern/root/html530/TTreeCache.html,1,['cache'],['cache']
Performance,"s so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:21532,cache,cache,21532,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['cache'],['cache']
Performance,"s some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:26916,cache,cache,26916,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,1,['cache'],['cache']
Performance,"s successfully loaded.; 1969 ; 1970UInt_t TSystem::LoadAllLibraries(); 1971{; 1972 UInt_t nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just load the first library - TSystem will do the rest.; 2002 auto res = gSystem->Load(lib);; 2003 if (res >=0) {; 2004 if (res == 0) ++nlibs;; 2005 loadedlibs.insert(lib.Data());; 2006 } else {; 2007 failedlibs.insert(lib.Data());; 2008 }; 2009 }; 2010 }; 2011 }; 2012 return nlibs;; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Find a dynamic library called lib using the system search paths.; 2017/// Appends known extensions if needed. Returned string must be deleted; 2018/// by the user!; 2019 ; 2020char *TSystem::DynamicPathName(const char *lib, Bool_t quiet /*=kFALSE*/); 2021{; 2022 TString sLib(lib);; 2023 if (FindDynamicLibrary(sLib, quiet)); 2024 return StrDup(sLib);; 2025 return nullptr;; 2026}; 2027 ; 2028////////////////////////////////////////////////////////////////////////////////; 2029/// Find a dynamic library using the system search paths. lib will be updated; 2030/// to contain the absolute filename if found. Returns lib if fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:64653,load,load,64653,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['load']
Performance,"s t r e a m; // -----------------------------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // Add Integration topic to existing INFO stream; RooMsgService::instance().getStream(1).addTopic(Integration);; ; // Construct integral over gauss to demonstrate new message stream; std::unique_ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams; cout << endl;; RooMsgService::instance().Print();; cout << endl;; ; // Remove stream; RooMsgService::instance().getStream(1).removeTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // -----------------------------------------------------------------------; ; // Show DEBUG level message on function tracing, trace RooGaussian only; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), ClassName(""RooGaussian""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // Show DEBUG level message on function tracing on all objects, redirect output to file; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), OutputFile(""rf506_debug.log""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // E x a m p l e o f a n o t h e r d e b u g g i n g s t r e a m; // ---------------------------------------------------------------------; ; // Show DEBUG level messages on client/server link state management; RooMsgService::instance().addStream(DEBUG, Topic(LinkStateMgmt));; RooMsgService::instance().Print(""v"");; ; // Clone composite pdf g to trigger some link state management activity; RooAbsArg *gprime = gauss.cloneTree();; gprime->Pri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf506__msgservice_8C.html:2466,Perform,Perform,2466,doc/master/rf506__msgservice_8C.html,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html,1,['Perform'],['Perform']
Performance,"s that a fifth of the; 146/// training data should be used. ""100""; 147/// indicates that 100 events should be used.; 148 ; 149void TMVA::MethodDNN::DeclareOptions(); 150{; 151 ; 152 DeclareOptionRef(fLayoutString=""SOFTSIGN|(N+100)*2,LINEAR"",; 153 ""Layout"",; 154 ""Layout of the network."");; 155 ; 156 DeclareOptionRef(fValidationSize = ""20%"", ""ValidationSize"",; 157 ""Part of the training data to use for ""; 158 ""validation. Specify as 0.2 or 20% to use a ""; 159 ""fifth of the data set as validation set. ""; 160 ""Specify as 100 to use exactly 100 events. ""; 161 ""(Default: 20%)"");; 162 ; 163 DeclareOptionRef(fErrorStrategy=""CROSSENTROPY"",; 164 ""ErrorStrategy"",; 165 ""Loss function: Mean squared error (regression)""; 166 "" or cross entropy (binary classification)."");; 167 AddPreDefVal(TString(""CROSSENTROPY""));; 168 AddPreDefVal(TString(""SUMOFSQUARES""));; 169 AddPreDefVal(TString(""MUTUALEXCLUSIVE""));; 170 ; 171 DeclareOptionRef(fWeightInitializationString=""XAVIER"",; 172 ""WeightInitialization"",; 173 ""Weight initialization strategy"");; 174 AddPreDefVal(TString(""XAVIER""));; 175 AddPreDefVal(TString(""XAVIERUNIFORM""));; 176 ; 177 DeclareOptionRef(fArchitectureString = ""CPU"", ""Architecture"", ""Which architecture to perform the training on."");; 178 AddPreDefVal(TString(""STANDARD""));; 179 AddPreDefVal(TString(""CPU""));; 180 AddPreDefVal(TString(""GPU""));; 181 AddPreDefVal(TString(""OPENCL""));; 182 ; 183 DeclareOptionRef(; 184 fTrainingStrategyString = ""LearningRate=1e-1,""; 185 ""Momentum=0.3,""; 186 ""Repetitions=3,""; 187 ""ConvergenceSteps=50,""; 188 ""BatchSize=30,""; 189 ""TestRepetitions=7,""; 190 ""WeightDecay=0.0,""; 191 ""Renormalize=L2,""; 192 ""DropConfig=0.0,""; 193 ""DropRepetitions=5|LearningRate=1e-4,""; 194 ""Momentum=0.3,""; 195 ""Repetitions=3,""; 196 ""ConvergenceSteps=50,""; 197 ""BatchSize=20,""; 198 ""TestRepetitions=7,""; 199 ""WeightDecay=0.001,""; 200 ""Renormalize=L2,""; 201 ""DropConfig=0.0+0.5+0.5,""; 202 ""DropRepetitions=5,""; 203 ""Multithreading=True"",; 204 ""TrainingStrategy"",; 205 ""Defines the tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:6255,perform,perform,6255,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['perform'],['perform']
Performance,s that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; static RooArgSet_emptySetSupports named argument constructor; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_t_extended; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_first!; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbs,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNLLVar.html:39386,cache,cache,39386,root/html602/RooNLLVar.html,https://root.cern,https://root.cern/root/html602/RooNLLVar.html,2,['cache'],['cache']
Performance,"s the closest distance to any boundary. Random points. A method to check the validity of a given geometry is shooting random points. This can be called with the method TGeoVolume::RandomPoints() and it draws a volume with the current visualization settings. Random points are generated in the bounding box of the drawn volume. The points are drawn with the color of their deepest container. Only points inside visible nodes are drawn. Random rays. A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node.; 18.7 The Drawing Package; The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provides all functionality being linked with the underlying ROOT visualization system. This library is dynamically loaded by the plug-in manager only when drawing features are requested. The geometrical structures that can be visualized are volumes and volume hierarchies.; The main component of the visualization system is volume primitive painting in a ROOT pad. Starting from this one, several specific options or subsystems are available, like: X3D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing.; The method TGeoManager::GetGeomPainter()loads the painting library in memory.; This is generally not needed since it is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes.; 18.7.1 Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1004609,load,loaded,1004609,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance,"s the desired array elements as follows:; 479 ; 480~~~{.cpp}; 481// h is filled with all the elements of `good_pts`, for each event; 482auto h = df.Define(""good_pts"", [](const ROOT::RVecF &pt) { return pt[pt > 0]; }); 483 .Histo1D(""good_pts"");; 484~~~; 485 ; 486And in Python:; 487 ; 488~~~{.py}; 489h = df.Define(""good_pts"", ""pt[pt > 0]"").Histo1D(""good_pts""); 490~~~; 491 ; 492Learn more at ROOT::VecOps::RVec.; 493 ; 494\anchor transformations; 495## Transformations: manipulating data; 496\anchor Filters; 497### Filters; 498A filter is created through a call to `Filter(f, columnList)` or `Filter(filterString)`. In the first overload, `f` can; 499be a function, a lambda expression, a functor class, or any other callable object. It must return a `bool` signalling; 500whether the event has passed the selection (`true`) or not (`false`). It should perform ""read-only"" operations on the; 501columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; 502when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; 503names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; 504certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; 505loop. See the paragraph about ""Just-in-time compilation"" below for more information.; 506 ; 507RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; 508in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; 509entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; 510each entry: after the first access it simply serves a cached result.; 511 ; 512\anchor named-filters-and-cutflow-reports; 513#### Named filters and cutflo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:30338,multi-thread,multi-threading,30338,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"s the desired array elements as follows:; 519 ; 520~~~{.cpp}; 521// h is filled with all the elements of `good_pts`, for each event; 522auto h = df.Define(""good_pts"", [](const ROOT::RVecF &pt) { return pt[pt > 0]; }); 523 .Histo1D(""good_pts"");; 524~~~; 525 ; 526And in Python:; 527 ; 528~~~{.py}; 529h = df.Define(""good_pts"", ""pt[pt > 0]"").Histo1D(""good_pts""); 530~~~; 531 ; 532Learn more at ROOT::VecOps::RVec.; 533 ; 534\anchor transformations; 535## Transformations: manipulating data; 536\anchor Filters; 537### Filters; 538A filter is created through a call to `Filter(f, columnList)` or `Filter(filterString)`. In the first overload, `f` can; 539be a function, a lambda expression, a functor class, or any other callable object. It must return a `bool` signalling; 540whether the event has passed the selection (`true`) or not (`false`). It should perform ""read-only"" operations on the; 541columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; 542when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; 543names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; 544certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; 545loop. See the paragraph about ""Just-in-time compilation"" below for more information.; 546 ; 547RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; 548in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; 549entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; 550each entry: after the first access it simply serves a cached result.; 551 ; 552\anchor named-filters-and-cutflow-reports; 553#### Named filters and cutflo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:31978,multi-thread,multi-threading,31978,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"s the n-th entry number; Next() - returns next entry number. Note, that this function is much faster than GetEntry, and it's called when GetEntry() is called for 2 or more indices in a row. TTree::Draw() and TChain::Draw(); Use option entrylist to write the results of TTree::Draw and TChain::Draw into an entry list. Example: tree->Draw("">>elist"", ""x<0 && y>0"", ""entrylist"");; TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEntryListA List of entry numbers in a TTree or TChain.Definition TEntryList.h:26; ; Example of Loop on TEntryList with a TChain; void loopChain() {; TFile *fe = TFile::Open(""myelist.root"");; TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; TChain *chain = new TChain(""ntuple"");; chain->Add(""hsimple.root"");; chain->Add(""hsimple2.root"");; Long64_t listEntries = myelist->GetN();; Long64_t chainEntries = chain->GetEntries();; Int_t treenum = 0;; chain->SetEntryList(myelist);; ; for (entry=start;entry < end;entry++) {; entryNumber = chain->GetEntryNumber(entry);; if (entryNumber < 0) break;; localEntry = chain->LoadTree(entryNumber);; if (localEntry < 0) break;; ....; then either call; branch->GetEntry(localEntry);; or; chain->GetEntry(entryNumber);; In the later case the LoadTree is then somewhat redundant.; ...; }; }; Long64_tlong long Long64_tDefinition RtypesCore.h:69; TChainA chain is a collection of files containing TTree objects.Definition TChain.h:33; TChain::GetEntryNumberLong64_t GetEntryNumber(Long64_t entry) const overrideReturn entry number corresponding to entry.Definition TChain.cxx:1021; TChain::SetEntryListvoid SetEntryList(TEntryList *elist, Option_t *opt="""") overrideSet the input entry list (processing the entries of the chain will then be limited to the entries in ...Definition TChain.cxx:2703; TChain::Addvirtual Int_t Add(TChain *chain)Add all files referenced by the passed chain to this chain.Definition TChain.cxx:219; TChain::LoadTreeLong64_t LoadTree(Long6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryList.html:2227,Load,LoadTree,2227,doc/master/classTEntryList.html,https://root.cern,https://root.cern/doc/master/classTEntryList.html,1,['Load'],['LoadTree']
Performance,"s the window size in pixels along X ; [in]whis the window size in pixels along Y . Definition at line 475 of file TCanvas.cxx. ◆ Constructor() [4/4]. void TCanvas::Constructor ; (; const char * ; name, . const char * ; title, . Int_t ; ww, . Int_t ; wh . ). Create a new canvas at a random position. ; Parameters. [in]namecanvas name ; [in]titlecanvas title ; [in]wwis the window size in pixels along X (if ww < 0 the menubar is not shown) ; [in]whis the window size in pixels along Y . Definition at line 386 of file TCanvas.cxx. ◆ CopyPixmaps(). void TCanvas::CopyPixmaps ; (; ). overrideprivatevirtual . Copy the canvas pixmap of the pad to the canvas. ; Implements TVirtualPad.; Definition at line 833 of file TCanvas.cxx. ◆ CreatePainter(). void TCanvas::CreatePainter ; (; ). private . Probably, TPadPainter must be placed in a separate ROOT module - ""padpainter"" (the same as ""histpainter""). ; But now, it's directly in a gpad dir, so, in case of default painter, no *.so should be loaded, no need in plugin managers. May change in future. ; Definition at line 2582 of file TCanvas.cxx. ◆ DeclFileName(). static const char * TCanvas::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 238 of file TCanvas.h. ◆ Delete(). void TCanvas::Delete ; (; Option_t * ; option = """"). inlineoverridevirtual . Delete this object. ; Typically called as a command via the interpreter. Normally use ""delete"" operator when object has been allocated on the heap. ; Reimplemented from TObject.; Definition at line 120 of file TCanvas.h. ◆ DeleteCanvasPainter(). void TCanvas::DeleteCanvasPainter ; (; ). assert on IsBatch() == false? ; Definition at line 2613 of file TCanvas.cxx. ◆ Destructor(). void TCanvas::Destructor ; (; ). Actual canvas destructor. ; Definition at line 692 of file TCanvas.cxx. ◆ DisconnectWidget(). void TCanvas::DisconnectWidget ; (; ). Used by friend class TCanvasImp. ; Definition at line 2545 of file TCanvas.cxx. ◆ Draw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCanvas.html:69029,load,loaded,69029,doc/v632/classTCanvas.html,https://root.cern,https://root.cern/doc/v632/classTCanvas.html,1,['load'],['loaded']
Performance,"s the window size in pixels along X ; [in]whis the window size in pixels along Y . Definition at line 478 of file TCanvas.cxx. ◆ Constructor() [4/4]. void TCanvas::Constructor ; (; const char * ; name, . const char * ; title, . Int_t ; ww, . Int_t ; wh . ). Create a new canvas at a random position. ; Parameters. [in]namecanvas name ; [in]titlecanvas title ; [in]wwis the window size in pixels along X (if ww < 0 the menubar is not shown) ; [in]whis the window size in pixels along Y . Definition at line 389 of file TCanvas.cxx. ◆ CopyPixmaps(). void TCanvas::CopyPixmaps ; (; ). overrideprivatevirtual . Copy the canvas pixmap of the pad to the canvas. ; Implements TVirtualPad.; Definition at line 836 of file TCanvas.cxx. ◆ CreatePainter(). void TCanvas::CreatePainter ; (; ). private . Probably, TPadPainter must be placed in a separate ROOT module - ""padpainter"" (the same as ""histpainter""). ; But now, it's directly in a gpad dir, so, in case of default painter, no *.so should be loaded, no need in plugin managers. May change in future. ; Definition at line 2595 of file TCanvas.cxx. ◆ DeclFileName(). static const char * TCanvas::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 238 of file TCanvas.h. ◆ Delete(). void TCanvas::Delete ; (; Option_t * ; option = """"). inlineoverridevirtual . Delete this object. ; Typically called as a command via the interpreter. Normally use ""delete"" operator when object has been allocated on the heap. ; Reimplemented from TObject.; Definition at line 120 of file TCanvas.h. ◆ DeleteCanvasPainter(). void TCanvas::DeleteCanvasPainter ; (; ). assert on IsBatch() == false? ; Definition at line 2626 of file TCanvas.cxx. ◆ Destructor(). void TCanvas::Destructor ; (; ). Actual canvas destructor. ; Definition at line 695 of file TCanvas.cxx. ◆ DisconnectWidget(). void TCanvas::DisconnectWidget ; (; ). Used by friend class TCanvasImp. ; Definition at line 2558 of file TCanvas.cxx. ◆ Draw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCanvas.html:69405,load,loaded,69405,doc/master/classTCanvas.html,https://root.cern,https://root.cern/doc/master/classTCanvas.html,1,['load'],['loaded']
Performance,"s the; whole viewport. void MakeCurrent() const; Make GL context current. void SwapBuffers() const; Swap GL buffers. Bool_t RequestSelect(Int_t x, Int_t y); Post request for selection render pass viewer, picking objects; around the window point (x,y). Bool_t DoSelect(Int_t x, Int_t y); Perform GL selection, picking objects overlapping WINDOW; area described by 'rect'. Return kTRUE if selection should be; changed, kFALSE otherwise.; Select lock should already been taken in other thread in; TGLViewer::ReqSelect(). Bool_t RequestSecondarySelect(Int_t x, Int_t y); Request secondary select. Bool_t DoSecondarySelect(Int_t x, Int_t y); Secondary selection. void ApplySelection(); Process result from last selection (in fSelRec) and; extract a new current selection from it.; Here we only use physical shape. Bool_t RequestOverlaySelect(Int_t x, Int_t y); Post request for secondary selection rendering of selected object; around the window point (x,y). Bool_t DoOverlaySelect(Int_t x, Int_t y); Perform GL selection, picking overlay objects only.; Return TRUE if the selected overlay-element has changed. void AutoFade(Float_t fade, Float_t time = 1, Int_t steps = 10); Animate fading from curernt value to fade over given time (sec); and number of steps. void UseDarkColorSet(); Use the dark color-set. void UseLightColorSet(); Use the light color-set. void SwitchColorSet(); Swtich between dark and light colorsets. void UseDefaultColorSet(Bool_t x); Set usage of the default color set. Bool_t IsUsingDefaultColorSet() const; Check if the viewer is using the default color set.; If yes, some operations might be disabled. void SetClearColor(Color_t col); Set background method.; Deprecated method - set background color in the color-set. TGLColorSet& GetDefaultColorSet(); Returns reference to the default color-set.; Static function. void UseDefaultColorSetForNewViewers(Bool_t x); Sets static flag that determines if new viewers should use the; default color-set.; This is false at startup. Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLViewer.html:28355,Perform,Perform,28355,root/html528/TGLViewer.html,https://root.cern,https://root.cern/root/html528/TGLViewer.html,6,['Perform'],['Perform']
Performance,"s to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called comitting or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first call to flush the baskets happen, we also take this opportunity; to optimize the baskets buffers.; We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point; in case the program writing the Tree crashes.; The decisions to FlushBaskets and Auto Save can be made based either on the number; of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; written (fAutoFlush and fAutoSave positive).; Note that the user can decide to call FlushBaskets and AutoSave in her event loop; base on the number of events written instead of the number of bytes written. Note that calling FlushBaskets too often increases the IO time.; Note that calling AutoSave too often increases the IO time and also the file size. TBranch* FindBranch(const char* name); Return the branch that correspond to the path 'branchname', which can; include the name of the tree or the ommited name of the parent branches.; In cas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:83554,optimiz,optimize,83554,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,3,['optimiz'],['optimize']
Performance,"s to compare the; 484/// performance of various configurations; 485 ; 486TMVA::MethodBase *; 487TMVA::Factory::BookMethod(TMVA::DataLoader *loader, Types::EMVA theMethod, TString methodTitle, TString theOption); 488{; 489 return BookMethod(loader, Types::Instance().GetMethodName(theMethod), methodTitle, theOption);; 490}; 491 ; 492////////////////////////////////////////////////////////////////////////////////; 493/// Adds an already constructed method to be managed by this factory.; 494///; 495/// \note Private.; 496/// \note Know what you are doing when using this method. The method that you; 497/// are loading could be trained already.; 498///; 499 ; 500TMVA::MethodBase *; 501TMVA::Factory::BookMethodWeightfile(DataLoader *loader, TMVA::Types::EMVA methodType, const TString &weightfile); 502{; 503 TString datasetname = loader->GetName();; 504 std::string methodTypeName = std::string(Types::Instance().GetMethodName(methodType).Data());; 505 DataSetInfo &dsi = loader->GetDataSetInfo();; 506 ; 507 IMethod *im = ClassifierFactory::Instance().Create(methodTypeName, dsi, weightfile);; 508 MethodBase *method = (dynamic_cast<MethodBase *>(im));; 509 ; 510 if (method == nullptr); 511 return nullptr;; 512 ; 513 if (method->GetMethodType() == Types::kCategory) {; 514 Log() << kERROR << ""Cannot handle category methods for now."" << Endl;; 515 }; 516 ; 517 TString fileDir;; 518 if (fModelPersistence) {; 519 // find prefix in fWeightFileDir;; 520 TString prefix = gConfig().GetIONames().fWeightFileDirPrefix;; 521 fileDir = prefix;; 522 if (!prefix.IsNull()); 523 if (fileDir[fileDir.Length() - 1] != '/'); 524 fileDir += ""/"";; 525 fileDir = loader->GetName();; 526 fileDir += ""/"" + gConfig().GetIONames().fWeightFileDir;; 527 }; 528 ; 529 if (fModelPersistence); 530 method->SetWeightFileDir(fileDir);; 531 method->SetModelPersistence(fModelPersistence);; 532 method->SetAnalysisType(fAnalysisType);; 533 method->SetupMethod();; 534 method->SetFile(fgTargetFile);; 535 method->SetSilentF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:20916,load,loader,20916,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"s to process. The default is 1000 events. Be aware that executing stress with 1000 eventswill create several files consuming about 100 MB of disk space; running stress with 30 events will consume about 20 MB. The disk space is released once stress is done.; There are two ways to run stress:; From the system prompt or from the ROOT prompt using the interpreter.; > cd $ROOTSYS/test; > stress // default 1000 events; > stress 30 // test with 30 events; Start ROOT with the batch mode option (-b) to suppress the graphic output.; > root -b; root[] .L stress.cxx; root[] stress(1000)// test with 1000 events; root[] stress(30)// test with 30 events; The output of stress includes a pass/fail conclusion for each test, the total number of bytes read and written, and the elapsed real and CPU time. It also calculates a performance index for your machine relative to a reference machine a DELL Inspiron 7500 (Pentium III 600 MHz) with 256 MB of memory and 18GB IDE disk in ROOTMARKS. Higher ROOTMARKS means better performance. The reference machine has 200 ROOTMARKS, so the sample run below with 53.7 ROOTMARKS is about four times slower than the reference machine.; Here is a sample run:; % root -b; root[] .x stress.cxx(30). Test 1 : Functions, Random Numbers, Histogram Fits............. OK; Test 2 : Check size & compression factor of a Root file........ OK; Test 3 : Purge, Reuse of gaps in TFile......................... OK; Test 4 : Test of 2-d histograms, functions, 2-d fits........... OK; Test 5 : Test graphics & PostScript ............................OK; Test 6 : Test subdirectories in a Root file.................... OK; Test 7 : TNtuple, selections, TCutG, TEventList.......... OK; Test 8 : Trees split and compression modes..................... OK; Test 9 : Analyze Event.root file of stress 8................... OK; Test 10 : Create 10 files starting from Event.root.............. OK; Test 11 : Test chains of Trees using the 10 files............... OK; Test 12 : Compare histograms of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1084302,perform,performance,1084302,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performance']
Performance,"s to take a const char* to take a std::string_view as thus be able to be directly directly passed a TString, a std::string or a std::string_view. Usage example:; // With SetName(std::string_view); std::string str; …; obj.SetName( str );; obj.SetName( {str.data()+pos, len} );; Meta library; Backward Incompatibilities; TIsAProxy’s constructor no longer take the optional and unused 2nd argument which was reserved for a ‘context’. This context was unused in TIsAProxy itself and was not accessible from derived classes.; Interpreter; The new interface TInterpreter::Declare(const char* code) will declare the code to the interpreter with all interpreter extensions disabled, i.e. as “proper” C++ code. No autoloading or synamic lookup will be performed.; A new R__LOAD_LIBRARY(libWhatever) will load libWhatever at parse time. This allows ROOT to resolve symbols from this library very early on. It is a work-around for the following code from ROOT 5:; // ROOT 5:; void func() {; gSystem->Load(""libEvent"");; Event* e = new Event;; }; Instead, write:; // ROOT 6:; R__LOAD_LIBRARY(libEvent); #include ""Event.h"". void func() {; Event* e = new Event;; }; TClass; Introduced new overload for calculating the TClass CheckSum:; UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const;; which indicates via the ‘isvalid’ boolean whether the checksum could be calculated correctly or not.; TROOT; Implemented new gROOT->GetTutorialsDir() static method to return the actual location of the tutorials directory. This is $ROOTSYS/tutorials when not configuring with –prefix or -Dgnuinstall for CMake.; TColor; Add an enum to access the palette by name.; Add new palettes with 255 colors. Names and colors’ definitions have been taken from here. Except for the kBird palette. These palettes can be accessed with gStyle->SetPalette(num). num can be taken within the following enum:. kDeepSea = 51; kGreyScale = 52; kDarkBodyRadiator = 53; kBlueYellow = 54; kRainBow = 55; kInvertedDarkBodyRadiator = 56; k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:4642,Load,Load,4642,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['Load'],['Load']
Performance,"s true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealIntegral.html:39186,Perform,Perform,39186,root/html534/RooRealIntegral.html,https://root.cern,https://root.cern/root/html534/RooRealIntegral.html,3,['Perform'],['Perform']
Performance,"s true if string contains one of the wildcard characters ""[]*?"".Definition TString.cxx:964; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::UpdateBranchesvirtual void UpdateBranches(TTree *tree)Update pointer to current Tree and recompute pointers to the branches in the cache.Definition TTreeCache.cxx:2211; TTreeCache::ResetCachevirtual void ResetCache()This will simply clear the cache.Definition TTreeCache.cxx:2040; TTree::TClusterIteratorHelper class to iterate over cluster of baskets.Definition TTree.h:270; TTree::TFriendLockHelper class to prevent infinite recursion in the usage of TTree Friends.Definition TTree.h:188; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::AddFriendvirtual TFriendElement * AddFriend(const char *treename, const char *filename="""")Add a TFriendElement to the list of friends.Definition TTree.cxx:1332; TTree::FindBranchvirtual TBranch * FindBranch(const char *name)Return the branch that correspond to the path 'branchname', which can include the name of the tree or...Definition TTree.cxx:4841; TTree::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:143329,cache,cache,143329,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['cache'],['cache']
Performance,"s used as weight. A separate firstval argument is needed so the compiler does not pick this overload instead of the non-templated Fill overloads ; Definition at line 167 of file THnBase.h. ◆ FillBin(). virtual void THnBase::FillBin ; (; Long64_t ; bin, . Double_t ; w . ). pure virtual . Implemented in THn, and THnSparse. ◆ FillBinBase(). void THnBase::FillBinBase ; (; Double_t ; w). inlineprotected . Increment the statistics due to filled weight ""w"",. ; Definition at line 89 of file THnBase.h. ◆ Fit(). TFitResultPtr THnBase::Fit ; (; TF1 * ; f, . Option_t * ; option = """", . Option_t * ; goption = """" . ). Fit a THnSparse with function f. ; since the data is sparse by default a likelihood fit is performed merging all the regions with empty bins for better performance efficiency; Since the THnSparse is not drawn no graphics options are passed Here is the list of possible options = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range . Definition at line 505 of file THnBase.cxx. ◆ GetAxis(). TAxis * THnBase::GetAxis ; (; Int_t ; dim); const. inline . Definition at line 130 of file THnBase.h. ◆ GetBin() [1/6]. virtual Long64_t THnBase::GetBin ; (; const char * ; name[]); const. pure virtual . Implemented in THn, and THnSparse. ◆ GetBin() [2/6]. virtual Long64_t THnBase::GetBin ; (; const char * ; name[], . Bool_t ; = kTRUE . ). pure virtual . Implemented in THnSparse, and THn. ◆ GetBin() [3/6]. virtual Long64_t THnBase::GetBin ; (; const Double_t * ; x); const. pure virtual . Imple",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnBase.html:29074,perform,performed,29074,doc/master/classTHnBase.html,https://root.cern,https://root.cern/doc/master/classTHnBase.html,3,"['Perform', 'perform']","['Perform', 'performance', 'performed']"
Performance,"s useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& analDeps,; 352 const RooArgSet* /*normSet*/, const char* rangeName) const; 353{; 354 return _forceNumInt ? 0 : getAnalyticalIntegral(allDeps,analDeps,rangeName) ;; 355}; 356 ; 357 ; 358 ; 359////////////////////////////////////////////////////////////////////////////////; 360/// Interface function getAnalyticalIntergral advertises the; 361/// analytical integrals that are supported. 'integSet'; 362/// is the set of dependents for which integration is requested. The; 363/// function should copy the subset of dependents it can analytically; 364/// integrate to anaIntSet and return a unique identification code for; 365/// this integration configuration. If no integration can be; 366/// performed, zero should be returned.; 367 ; 368Int_t RooAbsReal::getAnalyticalIntegral(RooArgSet& /*integSet*/, RooArgSet& /*anaIntSet*/, const char* /*rangeName*/) const; 369{; 370 return 0 ;; 371}; 372 ; 373 ; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// Implements the actual analytical integral(s) advertised by; 377/// getAnalyticalIntegral. This functions will only be called with; 378/// codes returned by getAnalyticalIntegral, except code zero.; 379 ; 380double RooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName) const; 381{; 382// cout << ""RooAbsReal::analyticalIntegralWN("" << GetName() << "") code = "" << code << "" normSet = "" << (normSet?*normSet:RooArgSet()) << std::endl ;; 383 if (code==0) return getVal(normSet) ;; 384 return analyticalIntegral(code,rangeName) ;; 385}; 386 ; 387 ; 388 ; 389////////////////////////////////////////////////////////////////////////////////; 390/// Implements",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:12660,perform,performed,12660,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['perform'],['performed']
Performance,"s value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; const ROOT::Math::IBaseFunctionOneDim*funcFunctor; RooRealProxyvarArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFunctor1DBinding(const char* name, const char* title, const ROOT::Math::IBaseFunctionOneDim& ftor, RooAbsReal& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFunctor1DBinding.html:36501,cache,cache,36501,root/html602/RooFunctor1DBinding.html,https://root.cern,https://root.cern/root/html602/RooFunctor1DBinding.html,4,['cache'],['cache']
Performance,"s verbose then Dump().; If options contains 'streamerinfo', run ls on the list of streamerInfos; and the list of conversion streamerInfos. void MakeCustomMenuList(); Makes a customizable version of the popup menu list, i.e. makes a list; of TClassMenuItem objects of methods accessible by context menu.; The standard (and different) way consists in having just one element; in this list, corresponding to the whole standard list.; Once the customizable version is done, one can remove or add elements. void Move(void* arenaFrom, void* arenaTo) const; Register the fact that an object was moved from the memory location; 'arenaFrom' to the memory location 'arenaTo'. TList * GetMenuList() const; Return the list of menu items associated with the class. TListOfFunctions * GetMethodList(); Return (create an empty one if needed) the list of functions.; The major difference with GetListOfMethod is that this returns; the internal type of fMethod and thus can not be made public.; It also never 'loads' the content of the list. TMethod * GetMethodAny(const char* method); Return pointer to method without looking at parameters.; Does not look in (possible) base classes.; Has the side effect of loading all the TMethod object in the list; of the class. TMethod * GetMethodAllAny(const char* method); Return pointer to method without looking at parameters.; Does look in all base classes. TMethod * GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); Find the best method (if there is one) matching the parameters.; The params string must contain argument values, like ""3189, \""aap\"", 1.3"".; The function invokes GetClassMethod to search for a possible method; in the class itself or in its base classes. Returns 0 in case method; is not found. TMethod* FindClassOrBaseMethodWithId(TDictionary::DeclId_t faddr); Find a method with decl id in this class or its bases. TMethod * GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:42515,load,loads,42515,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['load'],['loads']
Performance,"s verifying that you deal with a PyROOT python object in the first place (CPPInstance_Check for CPPInstance and any derived types, as well as CPPInstance_CheckExact for CPPInstance's only); and it allows conversions of void* to an CPPInstance and vice versa. ; Definition at line 44 of file TPython.h. Static Public Member Functions; static const TPyReturn Eval (const char *expr) R__DEPRECATED(6;  Evaluate a python expression (e.g. ;  ; static Bool_t Exec (const char *cmd, std::any *result=nullptr, std::string const &resultName=""_anyresult"");  Executes a Python command within the current Python environment. ;  ; static void ExecScript (const char *name, int argc=0, const char **argv=nullptr);  Execute a python stand-alone script, with argv CLI arguments. ;  ; static Bool_t Import (const char *name);  Import the named python module and create Cling equivalents for its classes and methods. ;  ; static void LoadMacro (const char *name);  Execute the give python script as if it were a macro (effectively an execfile in main), and create Cling equivalents for any newly available python classes. ;  . Static Private Member Functions; static Bool_t Initialize ();  Initialization method: setup the python interpreter and load the ROOT module. ;  . #include <TPython.h>; Member Function Documentation. ◆ Eval(). const TPyReturn TPython::Eval ; (; const char * ; expr). static . Evaluate a python expression (e.g. ; ""ROOT.TBrowser()"").; Caution: do not hold on to the return value: either store it in a builtin type (implicit casting will work), or in a pointer to a ROOT object (explicit casting to a void* is required).; Deprecated:Use TPython::Exec() with an std::any output parameter instead. ; Definition at line 465 of file TPython.cxx. ◆ Exec(). Bool_t TPython::Exec ; (; const char * ; cmd, . std::any * ; result = nullptr, . std::string const & ; resultName = ""_anyresult"" . ). static . Executes a Python command within the current Python environment. ; This function initializes the Pyt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPython.html:3653,Load,LoadMacro,3653,doc/master/classTPython.html,https://root.cern,https://root.cern/doc/master/classTPython.html,1,['Load'],['LoadMacro']
Performance,"s volumeDefinition TGeoVolume.cxx:2347; TGeoVolume::SetNumbervoid SetNumber(Int_t number)Definition TGeoVolume.h:245; TGeoVolume::SetLineWidthvoid SetLineWidth(Width_t lwidth) overrideSet the line width.Definition TGeoVolume.cxx:2185; TGeoVolume::GetMediumTGeoMedium * GetMedium() constDefinition TGeoVolume.h:175; TGeoVolume::GetRefCountInt_t GetRefCount() constDefinition TGeoVolume.h:131; TGeoVolume::SortNodesvoid SortNodes()sort nodes by decreasing volume of the bounding box.Definition TGeoVolume.cxx:2080; TGeoVolume::Voxelizevoid Voxelize(Option_t *option)build the voxels for this volumeDefinition TGeoVolume.cxx:2464; TGeoVolume::IsRunTimeBool_t IsRunTime() constDefinition TGeoVolume.h:109; TGeoVolume::CreateThreadDatavirtual void CreateThreadData(Int_t nthreads)Definition TGeoVolume.cxx:435; TGeoVolume::GetByteCountvirtual Int_t GetByteCount() constget the total size in bytes for this volumeDefinition TGeoVolume.cxx:2204; TGeoVolume::OptimizeVoxelsBool_t OptimizeVoxels()Perform an extensive sampling to find which type of voxelization is most efficient.Definition TGeoVolume.cxx:1247; TGeoVolume::IsVolumeMultivirtual Bool_t IsVolumeMulti() constDefinition TGeoVolume.h:110; TGeoVolume::CountNodesInt_t CountNodes(Int_t nlevels=1000, Int_t option=0)Count total number of subnodes starting from this volume, nlevels down.Definition TGeoVolume.cxx:730; TGeoVolume::UnmarkSavedvoid UnmarkSaved()Reset SavePrimitive bits.Definition TGeoVolume.cxx:1699; TGeoVolume::SetFindervoid SetFinder(TGeoPatternFinder *finder)Definition TGeoVolume.h:244; TGeoVolume::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoVolume.h:362; TGeoVolume::Grabvoid Grab()Definition TGeoVolume.h:136; TGeoVolume::Classstatic TClass * Class(); TGeoVolume::SetTransparencyvoid SetTransparency(Char_t transparency=0)Definition TGeoVolume.h:376; TGeoVolume::Releasevoid Release()Definition TGeoVolume.h:137; TGeoVolume::FindOverlapsvoid FindOverlaps() constloop all nodes marked as overlaps and find overlappin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:235018,Optimiz,OptimizeVoxels,235018,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,2,"['Optimiz', 'Perform']","['OptimizeVoxels', 'Perform']"
Performance,"s wanted. The instructions are coded in in the calling program (main.cpp), which allows looping, conditional execution, and all the other possibilities of , but not interactivity, since it must be compiled before execution.; 2.2 Design aspects of M in; What M is:. platform independent; written in an object-oriented way using standard; independent of any external package. The maintainability should be guaranteed with the choice of a modern computer language. Choosing object-oriented technology M should profit from an increased flexibility and functionality and make it also extendable (recursivness, new algorithms, new functionality).; What M does not:. histogramming; data handling; graphics. M is kept as a low-level package with optimal performance.; The main usages of M are. from a user’s program (such as int main()…); from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. its numerical accuracy (equivalent to its Fortran version); its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a two-way strategy was imposed:. a minimal required interface with minimum interaction with M objects and with appropriate usage of the standard library (STL): the user’s implementation of the FCNBase class, initial parameter values and uncertainties are provided by the to M user via std::vectors.; a rich interface which provides the user with more functionality such as interaction with parameters. The core of the minimization functionality and related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal and external parameters; Each of the parameters to the \(\mbox{FCN}\) is defined by the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:9793,perform,performance,9793,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['perform'],['performance']
Performance,"s well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Long64_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Buffersize might be clamped, see TFileCacheRead::SetBufferSize Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2073 of file TTreeCache.cxx. ◆ SetEntryRange(). void TTreeCache::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2106 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2128 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2145 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:48936,optimiz,optimize,48936,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['optimiz'],['optimize']
Performance,"s were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unordered_set<const clang::NamespaceDecl*> fNSFromRootmaps; // Collection of namespaces fwd declared in the rootmaps; 126 TObjArray* fRootmapFiles; // Loaded rootmap files.; 127 Bool_t fLockProcessLine; // True if ProcessLine should lock gInterpreterMutex.; 128 Bool_t fCxxModulesEnabled;// True if C++ modules was enabled; 129 ; 130 std::unique_ptr<cling::Interpreter> fInterpreter; // The interpreter.; 131 std::unique_ptr<cling::MetaProcessor> fMetaProcessor; // The metaprocessor.; 132 ; 133 std::vector<cling::Value> *fTemporaries; // Stack of temporaries; 134 ROOT::TMetaUtils::TNormalizedCtxt *fNormalizedCtxt; // Which typedef to avoid stripping.; 135 ROOT::TMetaUtils::TClingLookupHelper *fLookupHelper; // lookup helper used by TClassEdit; 136 ; 137 void* fPrevLoadedDynLibInfo; // Internal info to mark the last loaded libray.; 138 std::vector<void*> fRegisterModuleDyLibs; // Stack of libraries currently running RegisterModule; 139 TClingCallbacks* fClingCallbacks; // cling::Interpreter owns it.; 140 struct CharPtrCmp_t {; 141 bool operator()(const char* a, const char *b) const {; 142 return strcmp(a, b) < 0;; 143 }; 144 };; 145 std::set<TClass*> fModTClasses;; 146 std::vector<std::pair<TClass*,DictFuncPtr_t> > fClassesToUpdate;; 147 void* fAutoLoadCallBack;; 148 ULong64_t fTransactionCount; // Cling counter for commited or unloaded transactions which changed the AST.; 149 std::vector<const char*> fCurExecutingMacros;; 150 ; 151 typedef void* SpecialObjectLookupCtx_t;; 152 typedef std::unordered_map<std::string, TObject*> SpecialObjectMap_t;; 153 std::map<SpecialObjectLookupCtx_t, SpecialObjectMap_t> fSpecialObjectMaps;; 154 ; 155 struct MutexStateAndRecurseCount {; 156 /// State of gCoreMutex when the first interpret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:5289,load,loaded,5289,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['load'],['loaded']
Performance,"s when the same information can be retrieved using an index access operator of an array.) All similar accesses in derived classes should be replaced by the getters get_curWeight() or better get_wgt(i), which were also supported in ROOT <v6.24. More details on what happened:. Reduced side effects. This code produces undefined behaviour because the side effect of get(i), i.e., loading the new weight into _curWeight is not guaranteed to happen before weight() is called:. processEvent(dataHist.get(i), dataHist.weight()); // Dangerous! Order of evaluation is not guaranteed.; With the modernised interface, one would use:; processEvent(dataHist.get(i), dataHist.weight(i));; To modernise old code, one should replace patterns like h.get(i); h.func() by h.func(i);. One may #define R__SUGGEST_NEW_INTERFACE to switch on deprecation warnings for the functions in question. Similarly, the bin content can now be set using an index, making prior loading of a certain coordinate unnecessary:; for (int i=0 ; i<hist->numEntries() ; i++) {; - hist->get(i) ;; - hist->set(hist->weight() / sum);; + hist->set(i, hist->weight(i) / sum, 0.);; }. More const correctness. calcTreeIndex() doesn’t rely on side effects, any more. Instead of overwriting the internal coordinates with new values:. // In a RooDataHist subclass:; _vars = externalCoordinates;; auto index = calcTreeIndex();. // Or from the outside:; auto index = dataHist.getIndex(externalCoordinates); // Side effect: Active bin is now `index`.; coordinates are now passed into calcTreeIndex without side effects:; // In a subclass:; auto index = calcTreeIndex(externalCoordinates, fast=<true/false>); // No side effect. // From the outside:; auto index = dataHist.getIndex(externalCoordinates); // No side effect; This will allow for marking more functions const, or for lying less about const correctness. RooDataHist now supports fits with RooFit’s faster BatchMode().; Lower memory footprint. If weight errors are not needed, RooDataHist now allo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:23605,load,loading,23605,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['load'],['loading']
Performance,"s |; Protected Member Functions |; Protected Attributes |; Private Member Functions |; Friends |; List of all members ; TContextMenu Class ReferenceCore ROOT classes » Base ROOT classes. ; This class provides an interface to context sensitive popup menus. ; These menus pop up when the user hits the right mouse button, and are destroyed when the menu pops downs.; Context Menus are automatically generated by ROOT using the following convention: if the string // *MENU* is found in the comment field of a member function. This function will be added to the list of items in the menu.; The picture below shows a canvas with a pop-up menu. The picture below shows a canvas with a pop-up menu and a dialog box. Definition at line 44 of file TContextMenu.h. Public Member Functions;  TContextMenu (const char *name, const char *title=""Context sensitive popup menu"");  Create a context menu. ;  ; virtual ~TContextMenu ();  Destroy a context menu. ;  ; virtual void Action (TClassMenuItem *classmenuitem);  Action to be performed when this menu item is selected. ;  ; void Action (TMethod *method);  ; virtual void Action (TObject *object, TMethod *method);  Action to be performed when this menu item is selected. ;  ; virtual void Action (TObject *object, TToggle *toggle);  Action to be performed when this toggle menu item is selected. ;  ; void Action (TToggle *toggle);  ; virtual const char * CreateArgumentTitle (TMethodArg *argument);  Create string describing argument (for use in dialog box). ;  ; virtual const char * CreateDialogTitle (TObject *object, TFunction *method);  Create title for dialog box retrieving argument values. ;  ; virtual const char * CreatePopupTitle (TObject *object);  Create title for popup menu. ;  ; void Execute (const char *method, const char *params, Int_t *error=nullptr) override;  Execute method on this object with the given parameter string, e.g. ;  ; void Execute (const char *params);  ; void Execute (TMethod *method, TObjArray *params, Int_t *error=null",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTContextMenu.html:1214,perform,performed,1214,doc/master/classTContextMenu.html,https://root.cern,https://root.cern/doc/master/classTContextMenu.html,1,['perform'],['performed']
Performance,"s |; Static Public Member Functions |; List of all members ; TEveContextMenu Class ReferenceGraphics » 3D Graphics » Event Display. ; Specialization of TContext menu. ; Provide a window manager hint that ensures proper placement of popup on Cocoa. ; Definition at line 430 of file TEveWindow.h. Public Member Functions;  TEveContextMenu (const char *name, const char *title=""Eve context menu"");  Constructor. ;  ; TClass * IsA () const override;  ; void SetupAndPopup (TGWindow *button, TObject *obj);  Position the popup below given button and show context menu for object obj. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TContextMenu;  TContextMenu (const char *name, const char *title=""Context sensitive popup menu"");  Create a context menu. ;  ; virtual ~TContextMenu ();  Destroy a context menu. ;  ; virtual void Action (TClassMenuItem *classmenuitem);  Action to be performed when this menu item is selected. ;  ; void Action (TMethod *method);  ; virtual void Action (TObject *object, TMethod *method);  Action to be performed when this menu item is selected. ;  ; virtual void Action (TObject *object, TToggle *toggle);  Action to be performed when this toggle menu item is selected. ;  ; void Action (TToggle *toggle);  ; virtual const char * CreateArgumentTitle (TMethodArg *argument);  Create string describing argument (for use in dialog box). ;  ; virtual const char * CreateDialogTitle (TObject *object, TFunction *method);  Create title for dialog box retrieving argument values. ;  ; virtual const char * CreatePopupTitle (TObject *object);  Create title for popup menu. ;  ; void Execute (const char *method, const char *params, Int_t *error=nullptr) override;  Execute method on this object with the given parameter string, e.g. ;  ; void Execute (const char *params);  ; void Execute (TMethod *method, TObjArray *params, Int_t *error=null",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveContextMenu.html:1183,perform,performed,1183,doc/master/classTEveContextMenu.html,https://root.cern,https://root.cern/doc/master/classTEveContextMenu.html,1,['perform'],['performed']
Performance,"s"", theMethod->fDataSetInfo.GetName(), mname[0][i].Data());; 1924 // for (UInt_t icls = 0; icls < theMethod->fDataSetInfo.GetNClasses(); ++icls) {; 1925 // res += TString::Format(""%#1.3f "", (multiclass_testEff[i][icls]) * (multiclass_testPur[i][icls]));; 1926 // }; 1927 // Log() << kINFO << res << Endl;; 1928 // }; 1929 ; 1930 // Log() << kINFO << hLine << Endl;; 1931 // Log() << kINFO << Endl;; 1932 // }; 1933 ; 1934 // --- 1 vs Rest ROC AUC, signal efficiency @ given background efficiency; 1935 // --------------------------------------------------------------------; 1936 TString header1 = TString::Format(""%-15s%-15s%-15s%-15s%-15s%-15s"", ""Dataset"", ""MVA Method"", ""ROC AUC"", ""Sig eff@B=0.01"",; 1937 ""Sig eff@B=0.10"", ""Sig eff@B=0.30"");; 1938 TString header2 = TString::Format(""%-15s%-15s%-15s%-15s%-15s%-15s"", ""Name:"", ""/ Class:"", ""test (train)"", ""test (train)"",; 1939 ""test (train)"", ""test (train)"");; 1940 Log() << kINFO << Endl;; 1941 Log() << kINFO << ""1-vs-rest performance metrics per class"" << Endl;; 1942 Log() << kINFO << hLine << Endl;; 1943 Log() << kINFO << Endl;; 1944 Log() << kINFO << ""Considers the listed class as signal and the other classes"" << Endl;; 1945 Log() << kINFO << ""as background, reporting the resulting binary performance."" << Endl;; 1946 Log() << kINFO << ""A score of 0.820 (0.850) means 0.820 was acheived on the"" << Endl;; 1947 Log() << kINFO << ""test set and 0.850 on the training set."" << Endl;; 1948 ; 1949 Log() << kINFO << Endl;; 1950 Log() << kINFO << header1 << Endl;; 1951 Log() << kINFO << header2 << Endl;; 1952 for (Int_t k = 0; k < 2; k++) {; 1953 for (Int_t i = 0; i < nmeth_used[k]; i++) {; 1954 if (k == 1) {; 1955 mname[k][i].ReplaceAll(""Variable_"", """");; 1956 }; 1957 ; 1958 const TString datasetName = itrMap->first;; 1959 const TString mvaName = mname[k][i];; 1960 ; 1961 MethodBase *theMethod = dynamic_cast<MethodBase *>(GetMethod(datasetName, mvaName));; 1962 if (theMethod == 0) {; 1963 continue;; 1964 }; 1965 ; 1966 Log() << kINFO <<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:81215,perform,performance,81215,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,2,['perform'],['performance']
Performance,"s"",; 19865 config_options[DOCUMENT_ROOT].name);; 19866 }; 19867 free_context(ctx);; 19868 pthread_setspecific(sTlsKey, NULL);; 19869 return NULL;; 19870 }; 19871#endif; 19872 ; 19873 get_system_name(&ctx->systemName);; 19874 ; 19875#if defined(USE_LUA); 19876 /* If a Lua background script has been configured, start it. */; 19877 ctx->lua_bg_log_available = 0;; 19878 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19879 char ebuf[256];; 19880 struct vec opt_vec;; 19881 struct vec eq_vec;; 19882 const char *sparams;; 19883 ; 19884 memset(ebuf, 0, sizeof(ebuf));; 19885 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19886 ; 19887 /* Create a Lua state, load all standard libraries and the mg table */; 19888 lua_State *state = mg_lua_context_script_prepare(; 19889 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19890 if (!state) {; 19891 mg_cry_ctx_internal(ctx,; 19892 ""lua_background_script load error: %s"",; 19893 ebuf);; 19894 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19895 mg_snprintf(NULL,; 19896 NULL, /* No truncation check for error buffers */; 19897 error->text,; 19898 error->text_buffer_size,; 19899 ""Error in script %s: %s"",; 19900 config_options[LUA_BACKGROUND_SCRIPT].name,; 19901 ebuf);; 19902 }; 19903 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19904 ; 19905 free_context(ctx);; 19906 pthread_setspecific(sTlsKey, NULL);; 19907 return NULL;; 19908 }; 19909 ; 19910 /* Add a table with parameters into mg.params */; 19911 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19912 if (sparams && sparams[0]) {; 19913 lua_getglobal(state, ""mg"");; 19914 lua_pushstring(state, ""params"");; 19915 lua_newtable(state);; 19916 ; 19917 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19918 != NULL) {; 19919 reg_llstring(; 19920 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19921 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19922 break;; 19923 }; 19924 lua_rawset(state, -3);; 19925 lua_pop(state, 1);; 19",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:594393,load,load,594393,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['load'],['load']
Performance,"s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!state) {; 19892 mg_cry_ctx_internal(ctx,; 19893 ""lua_background_script load error: %s"",; 19894 ebuf);; 19895 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19896 mg_snprintf(NULL,; 19897 NULL, /* No truncation check for error buffers */; 19898 error->text,; 19899 error->text_buffer_size,; 19900 ""Error in script %s: %s"",; 19901 config_options[LUA_BACKGROUND_SCRIPT].name,; 19902 ebuf);; 19903 }; 19904 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19905 ; 19906 free_context(ctx);; 19907 pthread_setspecific(sTlsKey, NULL);; 19908 return NULL;; 19909 }; 19910 ; 19911 /* Add a table with parameters into mg.params */; 19912 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19913 if (sparams && sparams[0]) {; 19914 lua_getglobal(state, ""mg"");; 19915 lua_pushstring(state, ""params"");; 19916 lua_newtable(state);; 19917 ; 19918 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19919 != NULL) {; 19920 reg_llstring(; 19921 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19922 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:594426,load,load,594426,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['load'],['load']
Performance,"s()); 5187 return kTRUE;; 5188 ; 5189 int advice = POSIX_FADV_WILLNEED;; 5190 if (len == 0) {; 5191 // according POSIX spec if len is zero, all data following offset; 5192 // is specified. Nevertheless ROOT uses zero to probe readahead; 5193 // capabilities.; 5194 advice = POSIX_FADV_NORMAL;; 5195 }; 5196 Double_t start = 0;; 5197 if (gPerfStats) start = TTimeStamp();; 5198#if defined(R__SEEK64); 5199 Int_t result = posix_fadvise64(fD, offset, len, advice);; 5200#else; 5201 Int_t result = posix_fadvise(fD, offset, len, advice);; 5202#endif; 5203 if (gPerfStats) {; 5204 gPerfStats->FileReadEvent(this, len, start);; 5205 }; 5206 return (result != 0);; 5207}; 5208#else; 5209Bool_t TFile::ReadBufferAsync(Long64_t, Int_t); 5210{; 5211 // Not supported yet on non Linux systems.; 5212 ; 5213 return kTRUE;; 5214}; 5215#endif; 5216 ; 5217////////////////////////////////////////////////////////////////////////////////; 5218/// Max number of bytes to prefetch.; 5219///; 5220/// By default this is 75% of the; 5221/// read cache size. But specific TFile implementations may need to change it; 5222 ; 5223Int_t TFile::GetBytesToPrefetch() const; 5224{; 5225 TFileCacheRead *cr = nullptr;; 5226 if ((cr = GetCacheRead())) {; 5227 Int_t bytes = cr->GetBufferSize() / 4 * 3;; 5228 return ((bytes < 0) ? 0 : bytes);; 5229 }; 5230 return 0;; 5231}; Bytes.h; frombufvoid frombuf(char *&buf, Bool_t *x)Definition Bytes.h:278; tobufvoid tobuf(char *&buf, Bool_t x)Definition Bytes.h:55; Compression.h; RConcurrentHashColl.hxx; RConfig.hxx; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; sizesize_t size(const MatrixT &matrix)retrieve the size of a squ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:189725,cache,cache,189725,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"s(). std::vector< std::string > RooLagrangianMorphFunc::getSamples ; (; ); const. return the vector of sample names, used to build the morph func ; Definition at line 2176 of file RooLagrangianMorphFunc.cxx. ◆ getSampleWeight(). RooAbsReal * RooLagrangianMorphFunc::getSampleWeight ; (; const char * ; name). retrieve the weight (prefactor) of a sample with the given name ; Definition at line 2184 of file RooLagrangianMorphFunc.cxx. ◆ getScale(). double RooLagrangianMorphFunc::getScale ; (; ). get energy scale of the EFT expansion ; Definition at line 1977 of file RooLagrangianMorphFunc.cxx. ◆ getSumElement(). RooProduct * RooLagrangianMorphFunc::getSumElement ; (; const char * ; name); const. return the RooProduct that is the element of the RooRealSumPdfi corresponding to the given sample name ; Definition at line 2150 of file RooLagrangianMorphFunc.cxx. ◆ hasCache(). bool RooLagrangianMorphFunc::hasCache ; (; ); const. private . return true if a cache object is present, false otherwise ; Definition at line 2347 of file RooLagrangianMorphFunc.cxx. ◆ hasParameter(). bool RooLagrangianMorphFunc::hasParameter ; (; const char * ; paramname); const. check if a parameter of the given name is contained in the list of known parameters ; Definition at line 2442 of file RooLagrangianMorphFunc.cxx. ◆ init(). void RooLagrangianMorphFunc::init ; (; ). private . initialise inputs required for the morphing function ; Definition at line 1910 of file RooLagrangianMorphFunc.cxx. ◆ insert(). void RooLagrangianMorphFunc::insert ; (; RooWorkspace * ; ws). ◆ IsA(). TClass * RooLagrangianMorphFunc::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsReal.; Definition at line 257 of file RooLagrangianMorphFunc.h. ◆ isBinnedDistribution(). bool RooLagrangianMorphFunc::isBinnedDistribution ; (; const RooArgSet & ; obs); const. overridevirtual . check if this PDF is a binned distribution in the given observable ; Reimplemented from RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:84462,cache,cache,84462,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,1,['cache'],['cache']
Performance,"s().; 322///; 323/// WARNING when a selector is used with a TChain:; 324/// in the Process, ProcessCut, ProcessFill function, you must use; 325/// the pointer to the current Tree to call GetEntry(entry).; 326/// entry is always the local entry number in the current tree.; 327/// Assuming that fChain is the pointer to the TChain being processed,; 328/// use fChain->GetTree()->GetEntry(entry);; 329 ; 330void TSelector::ProcessFill(Long64_t /*entry*/); 331{; 332 ; 333}; 334 ; 335////////////////////////////////////////////////////////////////////////////////; 336/// The Process() function is called for each entry in the tree (or possibly; 337/// keyed object in the case of PROOF) to be processed. The entry argument; 338/// specifies which entry in the currently loaded tree is to be processed.; 339/// It can be passed to either t01::GetEntry() or TBranch::GetEntry(); 340/// to read either all or the required parts of the data. When processing; 341/// keyed objects with PROOF, the object is already loaded and is available; 342/// via the fObject pointer.; 343///; 344/// This function should contain the ""body"" of the analysis. It can contain; 345/// simple or elaborate selection criteria, run algorithms on the data; 346/// of the event and typically fill histograms.; 347///; 348/// The processing can be stopped by calling Abort().; 349///; 350/// Use fStatus to set the return value of TTree::Process().; 351///; 352/// The return value is currently not used.; 353///; 354/// WARNING when a selector is used with a TChain, you must use; 355/// the pointer to the current TTree to call GetEntry(entry).; 356/// The entry is always the local entry number in the current tree.; 357/// Assuming that fChain is the pointer to the TChain being processed,; 358/// use: `fChain->GetTree()->GetEntry(entry)`.; 359 ; 360bool TSelector::Process(Long64_t /*entry*/) {; 361 ; 362 return false;; 363}; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition Rtyp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:13473,load,loaded,13473,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,1,['load'],['loaded']
Performance,"s(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::HistFactory::FlexibleInterpVar&operator=(const RooStats::HistFactory::FlexibleInterpVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__FlexibleInterpVar.html:20223,optimiz,optimizeCacheMode,20223,root/html602/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__FlexibleInterpVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"s(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooChi2Var&operator=(const RooChi2Var&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChi2Var.html:20159,optimiz,optimizeCacheMode,20159,root/html602/RooChi2Var.html,https://root.cern,https://root.cern/root/html602/RooChi2Var.html,2,['optimiz'],['optimizeCacheMode']
Performance,"s(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TF2GL(); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF2GL.html:2135,cache,cached,2135,root/html602/TF2GL.html,https://root.cern,https://root.cern/root/html602/TF2GL.html,2,['cache'],['cached']
Performance,"s();; axis->SetAxisColor(Color_t color = 1);; axis->SetLabelColor(Color_t color = 1);; axis->SetLabelFont(Style_t font = 62);; axis->SetLabelOffset(Float_t offset = 0.005);; axis->SetLabelSize(Float_t size = 0.04);; axis->SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE);; axis->SetNoExponent(Bool_t noExponent = kTRUE);; axis->SetTickLength(Float_t length = 0.03);; axis->SetTitleOffset(Float_t offset = 1);; axis->SetTitleSize(Float_t size = 0.02);; The getters corresponding to the described setters are also available. The general options, not specific to axis, as for instance SetTitleTextColor() are valid and do have an effect on axis characteristics.; 9.5.3 Setting the Number of Divisions; Use TAxis::SetNdivisions(ndiv,optim) to set the number of divisions for an axis. The ndiv and optim are as follows:. ndiv = N1 + 100*N2 + 10000*N3; N1 = number of first divisions.; N2 = number of secondary divisions.; N3 = number of tertiary divisions.; optim = kTRUE (default), the divisions’ number will be optimized around the specified value.; optim = kFALSE, or n < 0, the axis will be forced to use exactly n divisions. For example:; ndiv = 0: no tick marks.; ndiv = 2: 2 divisions, one tick mark in the middle of the axis.; ndiv = 510: 10 primary divisions, 5 secondary divisions; ndiv = -10: exactly 10 primary divisions; 9.5.4 Zooming the Axis; You can use TAxis::SetRange or TAxis::SetRangeUser to zoom the axis.; TAxis::SetRange(Int_t binfirst,Int_t binlast); The SetRange method parameters are bin numbers. They are not axis. For example if a histogram plots the values from 0 to 500 and has 100 bins, SetRange(0,10) will cover the values 0 to 50. The parameters for SetRangeUser are user coordinates. If the start or end is in the middle of a bin the resulting range is approximation. It finds the low edge bin for the start and the high edge bin for the high.; TAxis::SetRangeUser(Axis_t ufirst,Axis_t ulast); Both methods, SetRange and SetRangeUser, are in the context menu of any axi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:337086,optimiz,optimized,337086,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimized']
Performance,"s(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTProofServ::DeletePlayer(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tTProofServ::Fork(); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; Int_tTProofServ::GetSessionStatus(); virtual voidTProofServ::HandleArchive(TMessage* mess, TString* slb = 0); virtual Int_tTProofServ::HandleCache(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleCheckFile(TMessage* mess, TString* slb = 0); virtual Int_tTProofServ::HandleDataSets(TMessage* mess, TString* slb = 0); virtual Int_tTProofServ::HandleLibIncPath(TMessage* mess); virtual voidTProofServ::HandleProcess(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleQueryList(TMessage* mess); virtual voidTProofServ::HandleRemove(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleRetrieve(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleSubmerger(TMessage* mess); virtual Int_tTProofServ::HandleWorkerLists(TMessage* mess); virtual voidTApplication::Help(const char* line); Bool_tTProofServ::IsIdle(); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); virtual voidTProofServ::MakePlayer(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual voidTProofServ::ProcessNext(TString* slb = 0); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh); Int_tTProofServ::SetupCommon(); Bool_tTProofServ::UnlinkDataDir(const char* path).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServLite.html:15541,Load,LoadGraphicsLibs,15541,root/html534/TProofServLite.html,https://root.cern,https://root.cern/root/html534/TProofServLite.html,2,['Load'],['LoadGraphicsLibs']
Performance,"s(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooMappedCategory&operator=(const RooMappedCategory&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMappedCategory.html:11166,optimiz,optimizeCacheMode,11166,root/html602/RooMappedCategory.html,https://root.cern,https://root.cern/root/html602/RooMappedCategory.html,2,['optimiz'],['optimizeCacheMode']
Performance,"s(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Stre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:46027,load,loaded,46027,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['load'],['loaded']
Performance,"s(methodList);; 200 return 0;; 201}; 202 ; DataLoader.h; mainint main()Definition Prototype.cxx:12; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; TFile.h; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; TMVAMultiClassGui.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TString.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTree.h; Tools.h; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddTreevoid AddTree(TTree *tree, const TString &className, Double_t weight=1.0, const TCut &cut="""", Types::ETreeType tt=Types::kMaxTreeType)Definition DataLoader.cxx:351; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C_source.html:8751,cache,cacheDir,8751,doc/master/TMVAMulticlass_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C_source.html,2,['cache'],"['cache', 'cacheDir']"
Performance,"s) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual voidrandomize(const char* rangeName = 0); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooAbsCategoryLValue(); RooAbsCategoryLValue(const char* name, const char* title); RooAbsCategoryLValue(const RooAbsCategoryLValue& other, const char* name = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); voidsetConstant(Bool_t v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategoryLValue.html:14641,cache,cache,14641,root/html602/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html,2,['cache'],['cache']
Performance,"s) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual voidrandomize(const char* rangeName = 0); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategoryLValue.html:13448,cache,cache,13448,root/html526/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsCategoryLValue.html,2,['cache'],['cache']
Performance,"s) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual voidrandomize(const char* rangeName = 0); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCategoryLValue.html:13819,cache,cache,13819,root/html532/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html532/RooAbsCategoryLValue.html,1,['cache'],['cache']
Performance,"s) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual voidrandomize(const char* rangeName = 0); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); voidsetConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategoryLValue.html:14618,cache,cache,14618,root/html534/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html,1,['cache'],['cache']
Performance,"s) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual voidrandomize(const char* rangeName = 0); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCategoryLValue.html:13736,cache,cache,13736,root/html530/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html,1,['cache'],['cache']
Performance,"s) specified via argv; 67 TString fWorkDir; //Working directory specified via argv; 68 TString fIdleCommand; //Command to execute while application is idle; 69 TTimer *fIdleTimer; //Idle timer; 70 TSignalHandler *fSigHandler; //Interrupt handler; 71 EExitOnException fExitOnException; //Exit on exception option; 72 ; 73 static Bool_t fgGraphNeeded; // True if graphics libs need to be initialized; 74 static Bool_t fgGraphInit; // True if graphics libs initialized; 75 ; 76 TApplication(const TApplication&) = delete;; 77 TApplication& operator=(const TApplication&) = delete;; 78 ; 79protected:; 80 TApplication *fAppRemote; //Current remote application, if defined; 81 ; 82 static TList *fgApplications; //List of available applications; 83 ; 84 TApplication();; 85 ; 86 virtual Longptr_t ProcessRemote(const char *line, Int_t *error = nullptr);; 87 virtual void Forum(const char *line);; 88 virtual void GitHub(const char *line);; 89 virtual void Help(const char *line);; 90 virtual void LoadGraphicsLibs();; 91 virtual void MakeBatch();; 92 void SetSignalHandler(TSignalHandler *sh) { fSigHandler = sh; }; 93 ; 94 static Int_t ParseRemoteLine(const char *ln,; 95 TString &hostdir, TString &user,; 96 Int_t &dbg, TString &script);; 97 static TApplication *Open(const char *url, Int_t debug, const char *script);; 98 static void Close(TApplication *app);; 99 ; 100public:; 101 TApplication(const char *appClassName, Int_t *argc, char **argv,; 102 void *options = nullptr, Int_t numOptions = 0);; 103 virtual ~TApplication();; 104 ; 105 void InitializeGraphics(Bool_t only_web = kFALSE);; 106 virtual void GetOptions(Int_t *argc, char **argv);; 107 TSignalHandler *GetSignalHandler() const { return fSigHandler; }; 108 virtual void SetEchoMode(Bool_t mode);; 109 TString GetSetup();; 110 void OpenForumTopic(const TString & type);; 111 void OpenGitHubIssue(const TString & type);; 112 void OpenInBrowser(const TString & url);; 113 void OpenReferenceGuideFor(const TString & strippedClass);; 114 virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8h_source.html:3508,Load,LoadGraphicsLibs,3508,doc/master/TApplication_8h_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html,1,['Load'],['LoadGraphicsLibs']
Performance,"s)->fCache = t->fNext;; 344 }; 345 ; 346 if (t && t->Next()); 347 return t->Next()->GetObject();; 348 else; 349 return nullptr;; 350}; 351 ; 352////////////////////////////////////////////////////////////////////////////////; 353/// Returns the object at position idx. Returns 0 if idx is out of range.; 354 ; 355TObject *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// Returns the object before object obj. Obj is found using the; 367/// object's IsEqual() method. Returns 0 if obj is first in list.; 368 ; 369TObject *TList::Before(const TObject *obj) const; 370{; 371 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 372 R__COLLECTION_WRITE_GUARD();; 373 ; 374 TObjLink *t;; 375 ; 376 auto cached = fCache.lock();; 377 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 378 t = cached.get();; 379 ((TList*)this)->fCache = cached->fPrev; //cast const away, fCache should be mutable; 380 } else {; 381 Int_t idx;; 382 t = FindLink(obj, idx);; 383 if (t) ((TList*)this)->fCache = t->fPrev;; 384 }; 385 ; 386 if (t && t->Prev()); 387 return t->Prev()->GetObject();; 388 else; 389 return nullptr;; 390}; 391 ; 392////////////////////////////////////////////////////////////////////////////////; 393/// Remove all objects from the list. Does not delete the objects; 394/// unless the TList is the owner (set via SetOwner()) and option; 395/// ""nodelete"" is not set.; 396/// If option=""nodelete"" then don't delete any heap objects that were; 397/// marked with the kCanDelete bit, otherwise these objects will be; 398/// deleted (this option is used by THashTable::Clear()).; 399 ; 400void TList::Clear(Option_t *option); 401{; 402 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 403 R__COLLEC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:10985,cache,cached,10985,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,1,['cache'],['cached']
Performance,"s). ; Reimplemented from TObject.; Definition at line 935 of file TProof.h. ◆ IsIdle(). Bool_t TProof::IsIdle ; (; ); const. inline . Definition at line 940 of file TProof.h. ◆ IsLite(). Bool_t TProof::IsLite ; (; ); const. inline . Definition at line 933 of file TProof.h. ◆ IsMaster(). Bool_t TProof::IsMaster ; (; ); const. inline . Definition at line 936 of file TProof.h. ◆ IsParallel(). Bool_t TProof::IsParallel ; (; ); const. inline . Definition at line 939 of file TProof.h. ◆ IsProofd(). Bool_t TProof::IsProofd ; (; ); const. inline . Definition at line 934 of file TProof.h. ◆ IsSync(). Bool_t TProof::IsSync ; (; ); const. inlineprivate . Definition at line 669 of file TProof.h. ◆ IsTty(). Bool_t TProof::IsTty ; (; ); const. inline . Definition at line 938 of file TProof.h. ◆ IsValid(). Bool_t TProof::IsValid ; (; ); const. inline . Definition at line 937 of file TProof.h. ◆ IsWaiting(). Bool_t TProof::IsWaiting ; (; ); const. inline . Definition at line 941 of file TProof.h. ◆ Load(). Int_t TProof::Load ; (; const char * ; macro, . Bool_t ; notOnClient = kFALSE, . Bool_t ; uniqueWorkers = kTRUE, . TList * ; wrks = 0 . ). virtual . Load the specified macro on master, workers and, if notOnClient is kFALSE, on the client. ; The macro file is uploaded if new or updated. Additional files to be uploaded (or updated, if needed) can be specified after a comma, e.g. ""mymacro.C+,thisheader.h,thatheader.h"". If existing in the same directory, a header basename(macro).h or .hh, is also uploaded. The default is to load the macro also on the client; notOnClient can be used to avoid loading on the client. On masters, if uniqueWorkers is kTRUE, the macro is loaded on unique workers only, and collection is not done; if uniqueWorkers is kFALSE, collection from the previous request is done, and broadcasting + collection from the other workers is done. The wrks arg can be used on the master to limit the set of workers. Returns 0 in case of success and -1 in case of error. ; Reimpl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:113799,Load,Load,113799,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['Load'],['Load']
Performance,"s). Bool_t IsLeafString(Int_t code) const; return TRUE if the leaf or data member corresponding to code is a string. char * PrintValue(Int_t mode = 0) const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values. char * PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. Bool_t LoadCurrentDim(). void Convert(UInt_t fromVersion); Convert the fOper of a TTTreeFormula version fromVersion to the current in memory version. Bool_t SwitchToFormLeafInfo(Int_t code); Convert the underlying lookup method from the direct technique; (dereferencing the address held by the branch) to the method using; TFormLeafInfo. This is in particular usefull in the case where we; need to append an additional TFormLeafInfo (for example to call a; method).; Return false if the switch was unsuccessfull (basically in the; case of an old style split tree). TTreeFormula(const char* name, const char* form",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeFormula.html:26215,Load,LoadTree,26215,root/html534/TTreeFormula.html,https://root.cern,https://root.cern/root/html534/TTreeFormula.html,6,"['Load', 'load']","['LoadTree', 'loaded']"
Performance,"s).; If set to 0 (default) no scaling is applied. Bool_t SavePictureWidth(const TString& fileName, Int_t width, Bool_t pixel_object_scale = kTRUE); Save picture with given width (height scaled proportinally).; If pixel_object_scale is true (default), the corresponding; scaling gets calculated from the current window size. Bool_t SavePictureHeight(const TString& fileName, Int_t height, Bool_t pixel_object_scale = kTRUE); Save picture with given height (width scaled proportinally).; If pixel_object_scale is true (default), the corresponding; scaling gets calculated from the current window size. Bool_t SavePictureScale(const TString& fileName, Float_t scale, Bool_t pixel_object_scale = kTRUE); Save picture with given scale to current window size.; If pixel_object_scale is true (default), the same scaling is; used. void DrawGuides(); Draw reference marker and coordinate axes. void DrawDebugInfo(); If in debug mode draw camera aids and overall bounding box. void PreDraw(); Perform GL work which must be done before each draw. void PostDraw(); Perform GL work which must be done after each draw. void FadeView(Float_t alpha); Draw a rectangle (background color and given alpha) across the; whole viewport. void MakeCurrent() const; Make GL context current. void SwapBuffers() const; Swap GL buffers. Bool_t RequestSelect(Int_t x, Int_t y); Post request for selection render pass viewer, picking objects; around the window point (x,y). Bool_t DoSelect(Int_t x, Int_t y); Perform GL selection, picking objects overlapping WINDOW; area described by 'rect'. Return kTRUE if selection should be; changed, kFALSE otherwise.; Select lock should already been taken in other thread in; TGLViewer::ReqSelect(). Bool_t RequestSecondarySelect(Int_t x, Int_t y); Request secondary select. Bool_t DoSecondarySelect(Int_t x, Int_t y); Secondary selection. void ApplySelection(); Process result from last selection (in fSelRec) and; extract a new current selection from it.; Here we only use physical shape. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLViewer.html:27150,Perform,Perform,27150,root/html528/TGLViewer.html,https://root.cern,https://root.cern/root/html528/TGLViewer.html,6,['Perform'],['Perform']
Performance,"s); 3397 RegisterLoadedSharedLibrary(lib.c_str());; 3398#else; 3399 Error(""TCling::UpdateListOfLoadedSharedLibraries"",; 3400 ""Platform not supported!"");; 3401#endif; 3402}; 3403 ; 3404namespace {; 3405template <int N>; 3406static bool StartsWithStrLit(const char *haystack, const char (&needle)[N]) {; 3407 return !strncmp(haystack, needle, N - 1);; 3408}; 3409}; 3410 ; 3411////////////////////////////////////////////////////////////////////////////////; 3412/// Register a new shared library name with the interpreter; add it to; 3413/// fSharedLibs.; 3414 ; 3415void TCling::RegisterLoadedSharedLibrary(const char* filename); 3416{; 3417 // Ignore NULL filenames, aka ""the process"".; 3418 if (!filename) return;; 3419 ; 3420 // Tell the interpreter that this library is available; all libraries can be; 3421 // used to resolve symbols.; 3422 cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();; 3423 if (!DLM->isLibraryLoaded(filename)) {; 3424 DLM->loadLibrary(filename, true /*permanent*/, true /*resolved*/);; 3425 }; 3426 ; 3427#if defined(R__MACOSX); 3428 // Check that this is not a system library that does not exist on disk.; 3429 auto lenFilename = strlen(filename);; 3430 auto isInMacOSSystemDir = [](const char *fn) {; 3431 return StartsWithStrLit(fn, ""/usr/lib/"") || StartsWithStrLit(fn, ""/System/Library/"");; 3432 };; 3433 if (!strcmp(filename, ""cl_kernels"") // yepp, no directory; 3434 ; 3435 // These we should not link with (e.g. because they forward to .tbd):; 3436 || StartsWithStrLit(filename, ""/usr/lib/system/""); 3437 || StartsWithStrLit(filename, ""/usr/lib/libc++""); 3438 || StartsWithStrLit(filename, ""/System/Library/Frameworks/""); 3439 || StartsWithStrLit(filename, ""/System/Library/PrivateFrameworks/""); 3440 || StartsWithStrLit(filename, ""/System/Library/CoreServices/""); 3441 || StartsWithStrLit(filename, ""/usr/lib/libSystem""); 3442 || StartsWithStrLit(filename, ""/usr/lib/libstdc++""); 3443 || StartsWithStrLit(filename, ""/usr/lib/libicucore""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:132344,load,loadLibrary,132344,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loadLibrary']
Performance,"s); RooDataHist::dh[c,x] = 300 bins (2964 weights); [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 35 out-of-range events; RooDataSet::ds[x,y] = 65 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #8 because z cannot accommodate the value 10; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds2) Ignored 36 out-of-range events; RooDataSet::ds2[x,z,y] = 26 entries; [#1] INFO:DataHandling -- RooAbsReal::attachToTree(i) TTree Int_t branch i will be converted to double precision.; RooDataSet::ds3[x,i] = 100 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #2 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #5 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #8 because i cannot accommodate the value 0; [#1] INFO:DataHandling --",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8py.html:4754,load,loadValues,4754,doc/master/rf401__importttreethx_8py.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8py.html,2,['load'],['loadValues']
Performance,"s);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLLogicalShape(); voidAddRef(TGLPhysicalShape* phys) const; virtual Bool_tAlwaysSecondarySelect() const; const TGLBoundingBox&BoundingBox() const; static TClass*Class(); voidDestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidDLCacheClear(); virtual voidDLCacheDrop(); virtual voidDLCachePurge(); virtual UInt_tDLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidDrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*GetExternal() const; const TGLPhysicalShape*GetFirstPhysical() const; static Bool_tGetIgnoreSizeForCameraInterest(); TGLScene*GetScene() const; TObject*ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidInvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tQuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tRef() const; Bool_tSetDLCache(Bool_t cached); static voidSetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidStrongRef(Bool_t strong) const; voidSubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesSupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; TGLLogicalShape(); TGLLogicalShape(TObject* obj); TGLLogicalShape(const TBuffer3D& buffer); UInt_tUnrefFirstPhysical(); virtual voidUpdateBoundingBox(); voidUpdateBoundingBoxesOfPhysicals(). protected:. voidPurgeDLRange(UInt_t base, Int_t size) const. private:. TGLLogicalShape&operator=(const TGLLogicalShape&); TGLLogicalShape(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLLogicalShape.html:3295,cache,cached,3295,root/html602/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html602/TGLLogicalShape.html,2,['cache'],['cached']
Performance,"s);; 1516 }; 1517 ; 1518 return *this;; 1519}; 1520 ; 1521////////////////////////////////////////////////////////////////////////////////; 1522/// Perform a rank 1 operation on matrix A:; 1523/// A += alpha * v * v^T; 1524 ; 1525template <class Element>; 1526TMatrixT<Element> &TMatrixT<Element>::Rank1Update(const TVectorT<Element> &v, Element alpha); 1527{; 1528 if (gMatrixCheck) {; 1529 R__ASSERT(this->IsValid());; 1530 R__ASSERT(v.IsValid());; 1531 if (v.GetNoElements() < TMath::Max(this->fNrows, this->fNcols)) {; 1532 Error(""Rank1Update"", ""vector too short"");; 1533 return *this;; 1534 }; 1535 }; 1536 ; 1537 const Element *const pv = v.GetMatrixArray();; 1538 Element *mp = this->GetMatrixArray();; 1539 ; 1540 for (Int_t i = 0; i < this->fNrows; i++) {; 1541 const Element tmp = alpha * pv[i];; 1542 for (Int_t j = 0; j < this->fNcols; j++); 1543 *mp++ += tmp * pv[j];; 1544 }; 1545 ; 1546 return *this;; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Perform a rank 1 operation on matrix A:; 1551/// A += alpha * v1 * v2^T; 1552 ; 1553template <class Element>; 1554TMatrixT<Element> &; 1555TMatrixT<Element>::Rank1Update(const TVectorT<Element> &v1, const TVectorT<Element> &v2, Element alpha); 1556{; 1557 if (gMatrixCheck) {; 1558 R__ASSERT(this->IsValid());; 1559 R__ASSERT(v1.IsValid());; 1560 R__ASSERT(v2.IsValid());; 1561 if (v1.GetNoElements() < this->fNrows) {; 1562 Error(""Rank1Update"", ""vector v1 too short"");; 1563 return *this;; 1564 }; 1565 ; 1566 if (v2.GetNoElements() < this->fNcols) {; 1567 Error(""Rank1Update"", ""vector v2 too short"");; 1568 return *this;; 1569 }; 1570 }; 1571 ; 1572 const Element *const pv1 = v1.GetMatrixArray();; 1573 const Element *const pv2 = v2.GetMatrixArray();; 1574 Element *mp = this->GetMatrixArray();; 1575 ; 1576 for (Int_t i = 0; i < this->fNrows; i++) {; 1577 const Element tmp = alpha * pv1[i];; 1578 for (Int_t j = 0; j < this->fNcols; j++); 1579 *mp++ += tmp * pv2[j];; 158",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMatrixT_8cxx_source.html:55258,Perform,Perform,55258,doc/master/TMatrixT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html,1,['Perform'],['Perform']
Performance,"s)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. THashTable*fBasesLoaded! table of base classes already checked or loaded; TList*fHandlerslist of plugin handlers; Bool_tfReadingDirs! true if we are running LoadHandlersFromPluginDirs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TPluginManager(); Clean up the plugin manager. void LoadHandlersFromEnv(TEnv* env); Load plugin handlers specified in config file, like:; Plugin.TFile: ^rfio: TRFIOFile RFIO ""TRFIOFile(...)""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). void LoadHandlerMacros(const char* path); Load all plugin macros from the specified path/base directory. void LoadHandlersFromPluginDirs(const char* base = 0); Load plugin handlers specified via macros in a list of plugin; directories. The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPluginManager.html:9970,Load,LoadHandlerMacros,9970,root/html602/TPluginManager.html,https://root.cern,https://root.cern/root/html602/TPluginManager.html,4,['Load'],"['Load', 'LoadHandlerMacros']"
Performance,"s)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TList*TVirtualMonitoringWriter::fTmpOpenPhasesTo store open phases when there is not yet an object. private:. TSQLServer*fDBSQL database where to write; Long64_tfMaxBulkSizeMax packet size for insertions; TStringfTableSQL table name; Bool_tfVerboseVerbosity toggle. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TVirtualMonitoringWriter. ←; TSQLMonitoringWriter. Function documentation; TSQLMonitoringWriter(const char* serv, const char* user, const char* pass, const char* table); Constructor. ~TSQLMonitoringWriter(); Destructor. Bool_t SendParameters(TList* values, const char* ); Register query log using the information in the list which is in the form; TParameter(<par>,<value>) or TNamed(<name>,<string>). For bulk sending,; the first entry in the list is an TObjString defining the variable names; in the format; VARname1,VARname2,...; while the other entries are TObjStrings with the multiplets to be sent; VARvalue1,VARvalue2,... The string 'opt' allows the following additional control:; table=[<db>.]<table> allows to insert to a different table from the; one defined at construction (change is not; persistent); if <db> is not specified, the same; db defined at cinstruction is used.; bulk Do a bulk insert; More options can be given concurrently, comma-separated .; The specified table must already have been created in the DB. TSQLMonitoringWriter(const TSQLMonitoringWriter& ). TSQLMonitoringWriter& operator=(const TSQLMonitoringWriter& ). void Verbose(Bool_t onoff); { fVerbose = onoff; }. » Author: J.F. Grosse-Oetringhaus, G.Ganis » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLMonitoringWriter.html:8368,concurren,concurrently,8368,root/html602/TSQLMonitoringWriter.html,https://root.cern,https://root.cern/root/html602/TSQLMonitoringWriter.html,1,['concurren'],['concurrently']
Performance,"s* sender_class, const char* signal, TClass* receiver_class, const char* slot); static voidTApplication::Close(TApplication* app); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidDeletePlayer(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tFork(); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; Int_tGetSessionStatus(); virtual voidHandleArchive(TMessage* mess, TString* slb = 0); virtual Int_tHandleCache(TMessage* mess, TString* slb = 0); virtual voidHandleCheckFile(TMessage* mess, TString* slb = 0); virtual Int_tHandleDataSets(TMessage* mess, TString* slb = 0); virtual voidHandleFork(TMessage* mess); virtual voidHandleLibIncPath(TMessage* mess); virtual voidHandleProcess(TMessage* mess, TString* slb = 0); virtual voidHandleQueryList(TMessage* mess); virtual voidHandleRemove(TMessage* mess, TString* slb = 0); virtual voidHandleRetrieve(TMessage* mess, TString* slb = 0); virtual voidHandleSubmerger(TMessage* mess); virtual Int_tHandleWorkerLists(TMessage* mess); virtual voidTApplication::Help(const char* line); Bool_tIsIdle(); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); virtual voidMakePlayer(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual voidProcessNext(TString* slb = 0); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh); virtual Int_tSetup(); Int_tSetupCommon(); Bool_tUnlinkDataDir(const char* path).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofServ.html:13969,Load,LoadGraphicsLibs,13969,root/html530/TProofServ.html,https://root.cern,https://root.cern/root/html530/TProofServ.html,2,['Load'],['LoadGraphicsLibs']
Performance,"s*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTFormula::IsLinear() const; virtual Bool_tTFormula::IsNormalized() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; Bool_tok(); voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); voidTFormula::Optimize(); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual voidTFormula::ProcessLinear(TString& replaceformula); virtual Int_tTObject::Read(const char* name); Bool_treCompile(const char* newFormula); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::Rese",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFormula.html:5667,Optimiz,Optimize,5667,root/html602/RooFormula.html,https://root.cern,https://root.cern/root/html602/RooFormula.html,1,['Optimiz'],['Optimize']
Performance,"s, ""); print("">> the category 'c' will be projected in the filling process""); ; # The binning of real variables (like x,y) is done using their fit range; # 'get/setRange()' and number of specified fit bins 'get/setBins()'.; # Category dimensions of binned datasets get one bin per defined category; # state; x.setBins(10); y.setBins(10); dh = ROOT.RooDataHist(""dh"", ""binned version of d"", {x, y}, d); dh.Print(""v""); ; yframe = y.frame(Bins=10, Title=""Operations on binned datasets""); dh.plotOn(yframe) # plot projection of 2D binned data on y; ; # Examine the statistics of a binned dataset; print("">> number of bins in dh : "", dh.numEntries()); print("">> sum of weights in dh : "", dh.sum(False)); # accounts for bin volume; print("">> integral over histogram: "", dh.sum(True)); ; # Locate a bin from a set of coordinates and retrieve its properties; x.setVal(0.3); y.setVal(20.5); print("">> retrieving the properties of the bin enclosing coordinate (x,y) = (0.3,20.5) bin center:""); # load bin center coordinates in internal buffer; dh.get({x, y}).Print(""v""); print("" weight = "", dh.weight()) # return weight of last loaded coordinates; ; # Reduce the 2-dimensional binned dataset to a 1-dimensional binned dataset; #; # All reduce() methods are interfaced in RooAbsData. All reduction techniques; # demonstrated on unbinned datasets can be applied to binned datasets as; # well.; print("">> Creating 1-dimensional projection on y of dh for bins with x>0""); dh2 = dh.reduce({y}, ""x>0""); dh2.Print(""v""); ; # Add dh2 to yframe and redraw; dh2.plotOn(yframe, LineColor=""r"", MarkerColor=""r""); ; # Saving and loading from file; # -------------------------------------------------------; ; # Datasets can be persisted with ROOT I/O; print(""\n >> Persisting d via ROOT I/O""); f = ROOT.TFile(""rf402_datahandling.root"", ""RECREATE""); d.Write(); f.ls(); ; # To read back in future session:; # > ROOT.TFile f(""rf402_datahandling.root""); # > d = (ROOT.RooDataSet*) f.FindObject(""d""); ; c = ROOT.TCanvas(""rf402_datah",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf402__datahandling_8py.html:4185,load,load,4185,doc/master/rf402__datahandling_8py.html,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8py.html,1,['load'],['load']
Performance,"s, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; voidinitialize() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvPdf.html:38093,optimiz,optimizeDirtyHook,38093,root/html534/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html534/RooNumConvPdf.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"s, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void Le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:26054,cache,cache,26054,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,1,['cache'],['cache']
Performance,"s, UInt_t mode) override;  Open a file in 'MemFile'. ;  ; Int_t SysRead (Int_t fd, void *buf, Int_t len) override;  Read specified number of bytes from current offset into the buffer. ;  ; Int_t SysReadImpl (Int_t fd, void *buf, Long64_t len);  Read specified number of bytes from current offset into the buffer. ;  ; Long64_t SysSeek (Int_t fd, Long64_t offset, Int_t whence) override;  Seek to a specified position in the file. ;  ; Int_t SysStat (Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime) override;  Perform a stat on the file; see TFile::SysStat(). ;  ; Int_t SysSync (Int_t fd) override;  Sync remaining data to disk. ;  ; Int_t SysWrite (Int_t fd, const void *buf, Int_t len) override;  Write a buffer into the file. ;  ; Int_t SysWriteImpl (Int_t fd, const void *buf, Long64_t len);  Write a buffer into the file. ;  ;  Protected Member Functions inherited from TFile; virtual Long64_t DirCreateEntry (TDirectory *);  ; virtual Int_t DirReadKeys (TDirectory *);  ; virtual void DirWriteHeader (TDirectory *);  ; virtual void DirWriteKeys (TDirectory *);  ; Bool_t FlushWriteCache ();  Flush the write cache if active. ;  ; virtual EAsyncOpenStatus GetAsyncOpenStatus ();  ; virtual InfoListRet GetStreamerInfoListImpl (bool lookupSICache);  See documentation of GetStreamerInfoList for more details. ;  ; virtual void Init (Bool_t create);  Initialize a TFile object. ;  ; Int_t MakeProjectParMake (const char *packname, const char *filename);  Create makefile at 'filemake' for PAR package 'pack'. ;  ; Int_t MakeProjectParProofInf (const char *packname, const char *proofinfdir);  Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'. ;  ; Int_t ReadBufferViaCache (char *buf, Int_t len);  Read buffer via cache. ;  ; Int_t WriteBufferViaCache (const char *buf, Int_t len);  Write buffer via cache. ;  ;  Protected Member Functions inherited from TDirectoryFile; void BuildDirectoryFile (TFile *motherFile, TDirectory *motherDir);  Initialise direc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMemFile.html:34368,cache,cache,34368,doc/master/classTMemFile.html,https://root.cern,https://root.cern/doc/master/classTMemFile.html,5,['cache'],['cache']
Performance,"s, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; B) We will call ""overlaps"" only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from.; When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker. Overlap checking; This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; TGeoManager::CheckOverlapsvoid CheckOverlaps(Double_t ovlp=0.1, Option_t *option="""")Check all geometry for illegal overlaps within a limit OVLP.Definition TGeoManager.cxx:3869; Here precision represents the desired maximum accepted overlap value in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:101086,optimiz,optimize,101086,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,2,"['optimiz', 'perform']","['optimize', 'performance']"
Performance,"s, const RooLinkedList& norms, const RooLinkedList& imps, const RooLinkedList& ints, const RooLinkedList& cross) const; Group product into terms that can be calculated independently. std::vector<RooAbsReal*> processProductTerm(const RooArgSet* nset, const RooArgSet* iset, const char* isetRangeName, const RooArgSet* term, const RooArgSet& termNSet, const RooArgSet& termISet, Bool_t& isOwned, Bool_t forceWrap = kFALSE) const; Calculate integrals of factorized product terms over observables iset while normalized; to observables in nset. const char* makeRGPPName(const char* pfx, const RooArgSet& term, const RooArgSet& iset, const RooArgSet& nset, const char* isetRangeName) const; Make an appropriate automatic name for a RooGenProdProj object in getPartIntList(). Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all observables for internal integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Determine which part (if any) of given integral can be performed analytically.; If any analytical integration is possible, return integration scenario code. RooProdPdf implements two strategies in implementing analytical integrals. First, PDF components whose entire set of dependents are requested to be integrated; can be dropped from the product, as they will integrate out to 1 by construction. Second, RooProdPdf queries each remaining component PDF for its analytical integration; capability of the requested set ('allVars'). It finds the largest common set of variables; that can be integrated by all remaining components. If such a set exists, it reconfirms that; each component is capable of analytically integrating the common set, and combines the components; individual integration codes into a single integration code valid for RooProdPdf. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProdPdf.html:51795,perform,performed,51795,root/html528/RooProdPdf.html,https://root.cern,https://root.cern/root/html528/RooProdPdf.html,6,['perform'],['performed']
Performance,"s, const char* wgtName); Utility function for constructors; Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName); Utility function for constructors; Return pointer to weight variable if it is defined. RooVectorDataStore(const RooVectorDataStore& other, const char* newname = 0); Regular copy ctor. RooVectorDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). RooVectorDataStore(const RooVectorDataStore& other, const RooArgSet& vars, const char* newname = 0); Clone ctor, must connect internal storage to given new external set of vars. RooVectorDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t , const char* wgtVarName = 0). ~RooVectorDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. const RooArgSet* getNative(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); throw(std::string(""RooVectorD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooVectorDataStore.html:12649,load,loaded,12649,root/html532/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html532/RooVectorDataStore.html,4,['load'],['loaded']
Performance,"s, which automatizes the process of compilation and linking.; In /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials there are 3 demonstration programs:; foam_kanwa.C; is a simple example how to run FOAM in interactive mode. To run this macro issue the following simple command from the Linux shell:; root foam_kanwa.C; or from CLING:; root [0] .x foam_kanwa.C; Simulation will start and graphical canvas with plot of the distribution function appear. In this example we defined the distribution function simply as a global function function Camel2.; foam_demo.C; shows usage of FOAM in compiled mode, which is the preferred method. The integrand function is defined now as a Density method from class TFDISTR inheriting from abstract class TFoamIntegrand. User can modify interface to integrand function according to their needs but they should always remember to define Density method which provides the density distribution. Enter CLING interpreter and type:; root [0] gSystem->Load(""libFoam.so""); root [1] .x foam_demo.C+; to load FOAM library, compile and execute macro foam_demo.C. A shared object foam_demo_C.so is created in the current directory. At the end of exploration phase FOAM object including distribution function will be written to disk.; foam_demopers.C; demonstrates persistency of FOAM classes. To run this macro type:; root [0] .x foam_demopers.C; Program reads the FOAM object from disk, checks its consistency and prints geometry of cells. Next starts the the generation. It can be interpreted directly by CLING because compiled TFDISTR class is already available in foam_demo_C.so library. . Files; file  foam_demo.C;   Demonstrate the TFoam class. ;  ; file  foam_demopers.C;   This simple macro demonstrates persistency of FOAM object. ;  ; file  foam_kanwa.C;   This program can be execute from the command line as folows: ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__FOAM.html:1943,Load,Load,1943,doc/master/group__tutorial__FOAM.html,https://root.cern,https://root.cern/doc/master/group__tutorial__FOAM.html,2,"['Load', 'load']","['Load', 'load']"
Performance,"s. ; At the moment two engine kinds are supported:. civetweb or http (default); fastcgi. Examples: // creates civetweb web server with http port 8080; serv->CreateEngine(""http:8080"");; serv->CreateEngine(""civetweb:8080"");; serv->CreateEngine("":8080"");; // creates fastcgi server with port 9000; serv->CreateEngine(""fastcgi:9000"");; One could apply additional parameters, using URL syntax: serv->CreateEngine(""http:8080?thrds=10""); . Definition at line 419 of file THttpServer.cxx. ◆ CreateItem(). Bool_t THttpServer::CreateItem ; (; const char * ; fullname, . const char * ; title . ). Create item in sniffer. ; Definition at line 1455 of file THttpServer.cxx. ◆ CreateServerThread(). void THttpServer::CreateServerThread ; (; ). Creates special thread to process all requests, directed to http server. ; Should be used with care - only dedicated instance of TRootSniffer is allowed By default THttpServer allows to access global lists pointers gROOT or gFile. To be on the safe side, all kind of such access performed from the main thread. Therefore usage of specialized thread means that no any global pointers will be accessible by THttpServer ; Definition at line 515 of file THttpServer.cxx. ◆ DeclFileName(). static const char * THttpServer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 198 of file THttpServer.h. ◆ ExecuteHttp(). Bool_t THttpServer::ExecuteHttp ; (; std::shared_ptr< THttpCallArg > ; arg). Execute HTTP request. ; Executes http request, specified in THttpCallArg structure.; Method can be called from any thread Actual execution will be done in main ROOT thread, where analysis code is running. ; Definition at line 642 of file THttpServer.cxx. ◆ ExecuteWS(). Bool_t THttpServer::ExecuteWS ; (; std::shared_ptr< THttpCallArg > & ; arg, . Bool_t ; external_thrd = kFALSE, . Bool_t ; wait_process = kFALSE . ). Execute WS request. ; Execute WS related operation. ; Definition at line 1299 of file THttpServer.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:23760,perform,performed,23760,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['perform'],['performed']
Performance,"s. ;  ; file  hierarchical_scene.C;  ; file  histobrowser.C;  Demonstrates how to use EVE as a histogram browser. ;  ; file  jetcone.C;  Demonstrates usage of TEveJetCone class. ;  ; file  lineset.C;  Demonstrates usage of class TEveStraightLineSet. ;  ; file  lineset.C;  Demonstrates usage of class REveStraightLineSet. ;  ; file  MultiView.C;  Multi-view (3d, rphi, rhoz) service class using EVE Window Manager. ;  ; file  overlay_palette.C;  ; file  overlay_test.C;  Demonstrates usage of TEveBox class. ;  ; file  pack.C;  Demonstrates usage of class TGPack. ;  ; file  paramlist.C;  Demonstrates usage of simple configuration via TEveParamList class. ;  ; file  pointset.C;  Demonstrates usage of class TEvePointSet. ;  ; file  projection.C;  Demonstrates usage of automatic 2D projections - class TEveProjectionManager. ;  ; file  projection_prescale.C;  Demonstrates usage pre-scaling for automatic 2D projections. ;  ; file  pythia_display.C;  Demo showing H -> ZZ -> 4 mu generated by Pythia. ;  ; file  quadset.C;  Demonstates usage of 2D digit class TEveQuadSet. ;  ; file  run_alice_esd.C;  Complex example showing ALICE ESD track visualization. ;  ; file  run_alice_esd_split.C;  Complex example showing ALICE ESD visualization in several views. ;  ; file  selection_sigs.C;  Test signals from TEveSelection class. ;  ; file  show_extract.C;  Helper script for showing of extracted / simplified geometries. ;  ; file  SplitGLView.C;  Helper classes for the alice_esd_split.C demo. ;  ; file  text.C;  Demonstrates usage of class TEveText - 2D & 3D text in GL. ;  ; file  track.C;  Demonstrates usage of TEveTrackPRopagator with different magnetic field configurations. ;  ; file  triangleset.C;  Demonstrates usage of class TEveTriangleSet. ;  ; file  view3ds.C;  Loading and display of basic 3DS models. ;  ; file  window_manager.C;  Demonstrates usage of EVE window-manager. ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__eve.html:4228,Load,Loading,4228,doc/master/group__tutorial__eve.html,https://root.cern,https://root.cern/doc/master/group__tutorial__eve.html,1,['Load'],['Loading']
Performance,"s. ;  ; virtual Int_t BufferFill (Double_t x, Double_t y, Double_t z, Double_t w);  Accumulate arguments in buffer. ;  ; Int_t BufferFill (Double_t, Double_t) override;  accumulate arguments in buffer. ;  ; virtual Int_t BufferFill (Double_t, Double_t, Double_t);  ; void DoFillProfileProjection (TProfile2D *p2, const TAxis &a1, const TAxis &a2, const TAxis &a3, Int_t bin1, Int_t bin2, Int_t bin3, Int_t inBin, Bool_t useWeights) const;  internal function to fill the bins of the projected profile 2D histogram called from DoProjectProfile2D ;  ; virtual TH1D * DoProject1D (const char *name, const char *title, const TAxis *projAxis, const TAxis *axis1, const TAxis *axis2, bool computeErrors, bool originalRange, bool useUF, bool useOF) const;  internal methdod performing the projection to 1D histogram called from other TH3::DoProject1D ;  ; virtual TH1D * DoProject1D (const char *name, const char *title, int imin1, int imax1, int imin2, int imax2, const TAxis *projAxis, const TAxis *axis1, const TAxis *axis2, Option_t *option) const;  internal method performing the projection to 1D histogram called from TH3::Project3D ;  ; virtual TH2D * DoProject2D (const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) const;  internal method performing the projection to a 2D histogram called from TH3::Project3D ;  ; virtual TProfile2D * DoProjectProfile2D (const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool originalRange, bool useUF, bool useOF) const;  internal method to project to a 2D Profile called from TH3::Project3DProfile ;  ; Int_t Fill (const char *, const char *, Double_t);  ; Int_t Fill (const char *, Double_t) override;  Increment bin with namex with a weight w. ;  ; Int_t Fill (const char *, Double_t, Double_t);  ; Int_t Fill (Double_t) override;  Invalid Fill method. ;  ; Int_t Fill (Double_t, const char *, Double_t);  ; Int_t Fill (Double_t, Double_t) over",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:47701,perform,performing,47701,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,24,['perform'],['performing']
Performance,"s. A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node.; 18.7 The Drawing Package; The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provides all functionality being linked with the underlying ROOT visualization system. This library is dynamically loaded by the plug-in manager only when drawing features are requested. The geometrical structures that can be visualized are volumes and volume hierarchies.; The main component of the visualization system is volume primitive painting in a ROOT pad. Starting from this one, several specific options or subsystems are available, like: X3D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing.; The method TGeoManager::GetGeomPainter()loads the painting library in memory.; This is generally not needed since it is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes.; 18.7.1 Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; Doing this ensures that the original top-level volume of the geometry is drawn, even if another volume is currently the geometry root. OK, I suppose you already did that with your simple geometry and immediately noticed a new ROOT canvas popping-up and having some more or less strange picture inside. Here are few questions that might come:; Q: “T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1005078,load,loads,1005078,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loads']
Performance,"s. Bool_t isConstant() const; Returns true if 'Constant' attribute is set. Bool_t IsSortable() const; Object is sortable in ROOT container class. Bool_t operator==(const RooAbsArg& other). Bool_t inRange(const char* ) const; Range management. Bool_t hasRange(const char* ) const; Has this argument a defined range (dummy interface always returns flase). Bool_t isShapeDirty() const; Dirty state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode==AClean ? (flipAClean() ? ADirty : AClean ) : _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). » Last changed: Mon Jul 4 15:21:16 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsArg.html:40949,cache,cacheUniqueSuffix,40949,root/html530/RooAbsArg.html,https://root.cern,https://root.cern/root/html530/RooAbsArg.html,3,['cache'],"['cache', 'cacheUniqueSuffix']"
Performance,"s. Function documentation; TGLAxis(); Constructor. void Init(); Default initialization. ~TGLAxis(); Destructor. void PaintGLAxis(const Double_t* p1, const Double_t* p2, Double_t wmin, Double_t wmax, Int_t ndiv, Option_t* opt = """"); Paint GL Axis. p1, p2 : Axis position in the 3D space.; wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; ndiv : Number of axis divisions. It is an integer in the form; ""ttsspp"" where ""tt"" is the number of tertiary divisions,; ""ss"" is the number of secondary divisions and ""pp"" the; number of primary divisions.; opt : Options.; ""N"" - By default the number of divisions is optimized to; get a nice labeling. When option ""N"" is given, the; number of divisions is not optimized. void PaintGLAxisBody(); Paint horizontal axis body at position (0,0,0). void PaintGLAxisTickMarks(); Paint axis tick marks. void PaintGLAxisLabels(); Paint axis labels on the main tick marks. void TicksPositions(Option_t* opt = """"); Compute ticks positions. void TicksPositionsNoOpt(); Compute ticks positions. Linear and not optimized. void TicksPositionsOpt(); Compute ticks positions. Linear and optimized. void DoLabels(); Do labels. void SetLabelsAngles(Double_t a1, Double_t a2, Double_t a3); Set labels' angles. TGLAxis(const TGLAxis& ). TGLAxis& operator=(const TGLAxis& ). void SetTickMarksLength(Double_t length); {fTickMarksLength = length;}. void SetTickMarksOrientation(Int_t tmo); {fTickMarksOrientation = tmo;}. void SetLabelsOffset(Double_t offset); {fLabelsOffset = offset;}. void SetLabelsSize(Double_t size); {fLabelsSize = size;}. void SetGridLength(Double_t grid); {fGridLength = grid;}. » Author: Olivier Couet 17/04/2007 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLAxis.h 21794 2008-01-21 21:11:46Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLAxis.html:4712,optimiz,optimized,4712,root/html528/TGLAxis.html,https://root.cern,https://root.cern/root/html528/TGLAxis.html,2,['optimiz'],['optimized']
Performance,"s. Function documentation; TGLAxis(); Constructor. void Init(); Default initialization. ~TGLAxis(); Destructor. void PaintGLAxis(const Double_t* p1, const Double_t* p2, Double_t wmin, Double_t wmax, Int_t ndiv, Option_t* opt = """"); Paint GL Axis. p1, p2 : Axis position in the 3D space.; wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; ndiv : Number of axis divisions. It is an integer in the form; ""ttsspp"" where ""tt"" is the number of tertiary divisions,; ""ss"" is the number of secondary divisions and ""pp"" the; number of primary divisions.; opt : Options.; ""N"" - By default the number of divisions is optimized to; get a nice labeling. When option ""N"" is given, the; number of divisions is not optimized. void PaintGLAxisBody(); Paint horizontal axis body at position (0,0,0). void PaintGLAxisTickMarks(); Paint axis tick marks. void PaintGLAxisLabels(); Paint axis labels on the main tick marks. void TicksPositions(Option_t* opt = """"); Compute ticks positions. void TicksPositionsNoOpt(); Compute ticks positions. Linear and not optimized. void TicksPositionsOpt(); Compute ticks positions. Linear and optimized. void DoLabels(); Do labels. void SetLabelsAngles(Double_t a1, Double_t a2, Double_t a3); Set labels' angles. TGLAxis(const TGLAxis& ). TGLAxis& operator=(const TGLAxis& ). void SetTickMarksLength(Double_t length); {fTickMarksLength = length;}. void SetTickMarksOrientation(Int_t tmo); {fTickMarksOrientation = tmo;}. void SetLabelsOffset(Double_t offset); {fLabelsOffset = offset;}. void SetLabelsSize(Double_t size); {fLabelsSize = size;}. void SetGridLength(Double_t grid); {fGridLength = grid;}. » Author: Olivier Couet 17/04/2007 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLAxis.h 21794 2008-01-21 21:11:46Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLAxis.html:4712,optimiz,optimized,4712,root/html530/TGLAxis.html,https://root.cern,https://root.cern/root/html530/TGLAxis.html,2,['optimiz'],['optimized']
Performance,"s. Function documentation; TGLAxis(); Constructor. void Init(); Default initialization. ~TGLAxis(); Destructor. void PaintGLAxis(const Double_t* p1, const Double_t* p2, Double_t wmin, Double_t wmax, Int_t ndiv, Option_t* opt = """"); Paint GL Axis. p1, p2 : Axis position in the 3D space.; wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; ndiv : Number of axis divisions. It is an integer in the form; ""ttsspp"" where ""tt"" is the number of tertiary divisions,; ""ss"" is the number of secondary divisions and ""pp"" the; number of primary divisions.; opt : Options.; ""N"" - By default the number of divisions is optimized to; get a nice labeling. When option ""N"" is given, the; number of divisions is not optimized. void PaintGLAxisBody(); Paint horizontal axis body at position (0,0,0). void PaintGLAxisTickMarks(); Paint axis tick marks. void PaintGLAxisLabels(); Paint axis labels on the main tick marks. void TicksPositions(Option_t* opt = """"); Compute ticks positions. void TicksPositionsNoOpt(); Compute ticks positions. Linear and not optimized. void TicksPositionsOpt(); Compute ticks positions. Linear and optimized. void DoLabels(); Do labels. void SetLabelsAngles(Double_t a1, Double_t a2, Double_t a3); Set labels' angles. TGLAxis(const TGLAxis& ). TGLAxis& operator=(const TGLAxis& ). void SetTickMarksLength(Double_t length); {fTickMarksLength = length;}. void SetTickMarksOrientation(Int_t tmo); {fTickMarksOrientation = tmo;}. void SetLabelsOffset(Double_t offset); {fLabelsOffset = offset;}. void SetLabelsSize(Double_t size); {fLabelsSize = size;}. void SetGridLength(Double_t grid); {fGridLength = grid;}. » Author: Olivier Couet 17/04/2007 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLAxis.h 21794 2008-01-21 21:11:46Z matevz $ » Last generated: 2011-12-02 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLAxis.html:4712,optimiz,optimized,4712,root/html532/TGLAxis.html,https://root.cern,https://root.cern/root/html532/TGLAxis.html,2,['optimiz'],['optimized']
Performance,"s. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEntryListFromFile(); default c-tor. TEntryListFromFile(const char* filename, const char* listname, Int_t nfiles); File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element; - xxx$xxx.root - $ sign is replaced by the name of the chain element; The TObjArray of chain elements is set by the TEntryListFromFile::SetFileNames(); function.; If the list name is not specified, the first object of class TEntryList; in the file is taken.; nfiles is the total number of files to process. ~TEntryListFromFile(); d-tor. Long64_t GetEntry(Int_t index); returns entry #index; See also Next() for a faster alternative. Long64_t GetEntryAndTree(Int_t index, Int_t& treenum); return the entry corresponding to the index parameter and the; number of the tree, where this entry is. Long64_t GetEntries(); Returns the total number of entries in the list.; If some lists have not been loaded, loads them. Long64_t Next(); Returns the next entry in the list.; Faster than GetEntry(). Int_t LoadList(Int_t listnumber); Loads the list #listnumber; This is the only function that can modify fCurrent and fFile data members. void Print(Option_t* option = """") const; Print info about this list. TEntryListFromFile(). void Add(const TEntryList* ); {}. Int_t Contains(Long64_t , TTree* ); {return 0;}. Bool_t Enter(Long64_t , TTree* ); {return 0;}. TEntryList * GetCurrentList() const; { return fCurrent; }. TEntryList * GetEntryList(const char* , const char* , Option_t* ); {return 0;}. Long64_t GetEntriesFast() const; { return fN; }. Long64_t GetN() const; { return fN; }. const char * GetTreeName() const; { return fTreeName.Data(); }. const char * GetFileName() const; { return fFileName.Data(); }. Int_t GetTreeNumber() const; { return fTreeNumber; }. Int_t Merge(TCollection* ); { return 0; }. void OptimizeStorage(); {}. Bool_t Remove(Long64_t , TTree* ); { return 0; }. void SetT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEntryListFromFile.html:10454,load,loaded,10454,root/html528/TEntryListFromFile.html,https://root.cern,https://root.cern/root/html528/TEntryListFromFile.html,4,['load'],"['loaded', 'loads']"
Performance,"s. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedPdf.html:44509,cache,cache,44509,root/html532/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedPdf.html,2,['cache'],['cache']
Performance,"s. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Static Protected Attributes |; List of all members ; RooObjCacheManager Class ReferenceRooFit » RooFit Core. ; Implementation of a RooCacheManager<RooAbsCacheElement> that specializes in the storage of cache elements that contain RooAbsArg objects. ; Caches with RooAbsArg derived payload require special care as server redirects cache operation mode changes and constant term optimization calls may need to be forwarded to such cache payload. This cache manager takes care of all these operations by forwarding these calls to the RooAbsCacheElement interface functions, which have a sensible default implementation. ; Definition at line 29 of file RooObjCacheManager.h. Public Member Functions;  RooObjCacheManager (const RooObjCacheManager &other, RooAbsArg *owner=nullptr);  Copy constructor. ;  ;  RooObjCacheManager (RooAbsArg *owner=nullptr, Int_t maxSize=2, bool clearCacheOnServerRedirect=true, bool allowOptimize=false);  Constructor of object cache manager for given owner. ;  ;  ~RooObjCacheManager () override;  Destructor. ;  ; void findConstantNodes (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  If clearOnRedirect is false, forward constant term optimization calls to cache elements. ;  ; void insertObjectHook (RooAbsCacheElement &) override;  Set owner link on all object inserted into cache. ;  ; TClass * IsA () const override;  ; void operModeHook () override;  Intercept changes to cache operation mode and forward to cache elements. ;  ; void optimizeCacheMode (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  Intercept calls to perform automatic optimization of cache mode operation. ;  ; void printCompactTreeHook (std::ostream &, const char *) override;  Add details on cache contents when printing in tree mode. ;  ; bool redirectServersHook (const RooAbsCollection &, bool, bool, bool) override;  Intercept server redirect calls. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:1186,cache,cache,1186,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['cache'],['cache']
Performance,"s. Namespaces ; df106_HiggsToFourLeptons.py File ReferenceTutorials » Dataframe tutorials. Detailed Description; The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads to a narrow invariant mass peak on top a relatively smooth and small background, revealing the Higgs at 125 GeV. Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting. The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; See the corresponding spec json file. ; import ROOT; import os; ; # Enable Multi-threaded mode; ROOT.EnableImplicitMT(); ; # Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; ; # Add the ProgressBar feature; ROOT.RDF.Experimental.AddProgressBar(df); ; # Access metadata information that is stored in the JSON config file of the RDataFrame.; # The metadata contained in the JSON file is accessible within a `DefinePerSample` call, through the `RSampleInfo` class.; df = df.DefinePerSample(""xsecs"", 'rdfsampleinfo_.GetD(""xsecs"")'); df = df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); df = df.DefinePerSample(""sumws"", 'rdfsampleinfo_.GetD(""sumws"")'); df = df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); ; # We must further apply an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:1156,Multi-thread,Multi-threaded,1156,doc/master/df106__HiggsToFourLeptons_8py.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html,1,['Multi-thread'],['Multi-threaded']
Performance,"s. ROOT; » TREE; » TREE; » TVirtualBranchBrowsable. class TVirtualBranchBrowsable: public TNamed. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TVirtualBranchBrowsable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualBranchBrowsable.html:1166,cache,cached,1166,root/html528/TVirtualBranchBrowsable.html,https://root.cern,https://root.cern/root/html528/TVirtualBranchBrowsable.html,8,['cache'],['cached']
Performance,"s. ROOT; » TREE; » TREE; » TVirtualBranchBrowsable. class TVirtualBranchBrowsable: public TNamed. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TVirtualBranchB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualBranchBrowsable.html:1190,cache,cached,1190,root/html602/TVirtualBranchBrowsable.html,https://root.cern,https://root.cern/root/html602/TVirtualBranchBrowsable.html,4,['cache'],['cached']
Performance,"s. [in]code. Reimplemented from RooAbsPdf.; Definition at line 208 of file RooBCPEffDecay.cxx. ◆ getCoefAnalyticalIntegral(). Int_t RooBCPEffDecay::getCoefAnalyticalIntegral ; (; Int_t ; coef, . RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Default implementation of function advertising integration capabilities. ; The interface is similar to that of getAnalyticalIntegral except that an integer code is added that designates the coefficient number for which the integration capabilities are requested; This default implementation advertises that no internal integrals are supported. ; Reimplemented from RooAbsAnaConvPdf.; Definition at line 146 of file RooBCPEffDecay.cxx. ◆ getGenerator(). Int_t RooBCPEffDecay::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ; A code of zero indicates that we cannot generate any of the directVars (in this case, nothing should be added to generatedVars). Any non-zero codes will be passed to our generateEvent() implementation, but otherwise its value is arbitrary. The default implementation of this method returns zero. Subclasses will usually implement this method using the matchArgs() methods to advertise the algorithms they provide. ; Reimplemented from RooAbsPdf.; Definition at line 182 of file RooBCPEffDecay.cxx. ◆ initGenerator(). void RooBCPEffDecay::initGenerator ; (; Int_t ; code). overridevirtual . Interface for one-time initialization to setup the generator for the specified code. ; Reimplemented from RooAbsPdf.; Definition at line 193 of file RooBCPEffDecay.cxx. ◆ IsA(). TClass * RooBCPEffDecay::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsAnaConvPdf.; Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBCPEffDecay.html:81800,Load,Load,81800,doc/master/classRooBCPEffDecay.html,https://root.cern,https://root.cern/doc/master/classRooBCPEffDecay.html,1,['Load'],['Load']
Performance,"s. size_t nEvents=0;; for (auto& i:{xData,meanData,sigmaData}); nEvents = std::max(nEvents,i.size());. Create the output batch by calling RunContext::makeBatch(). - auto output = _batchData.makeWritableBatchUnInit(begin, batchSize);; + auto output = evalData.makeBatch(this, nEvents);. DO NOT use RooSpan::isBatch() and RooSpan::empty() methods! Instead, distinguish between scalar (RooSpan of size 1) and vector (RooSpan of size>1) parameters as shown below. - const bool batchX = !xData.empty();; + const bool batchX = xData.size()>1;. Append RooBatchCompute:: to the classes that have been moved to the RooBatchCompute Library: RooSpan,BracketAdapterWithMask, BracketAdapter, RunContext. Alternatively, you can write. using namespace RooBatchCompute;. Replace _rf_fast_<function> with RooBatchCompute::fast_<function> and include RooVDTHeaders.h (if applicable). - output[i] = _rf_fast_exp(arg*arg * halfBySigmaSq);; + output[i] = RooBatchCompute::fast_exp(arg*arg * halfBySigmaSq);; Unbiased binned fits; When RooFit performs binned fits, it takes the probability density at the bin centre as a proxy for the probability in the bin. This can lead to a bias. To alleviate this, the new class RooBinSamplingPdf has been added to RooFit. Also see arxiv:2012.02746.; More accurate residual and pull distributions; When making residual or pull distributions with RooPlot::residHist or RooPlot::pullHist, the histogram is now compared with the curve’s average values within a given bin by default, ensuring that residual and pull distributions are valid for strongly curved distributions. The old default behaviour was to interpolate the curve at the bin centres, which can still be enabled by setting the useAverage parameter of RooPlot::residHist or RooPlot::pullHist to false.; Improved recovery from invalid parameters; When a function in RooFit is undefined (Poisson with negative mean, PDF with negative values, etc), RooFit can now pass information about the “badness” of the violation to the min",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:20908,perform,performs,20908,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['perform'],['performs']
Performance,"s. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Update contents of cache histogram by resampling the input function. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. void operModeHook(). RooCachedReal(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooCachedReal(*this,newname); }. void setCdfBoundaries(Bool_t flag); If flag is true the RooHistFunc that represent the cache histogram; will use special boundary conditions for use with cumulative distribution; functions: at the lower bound the function is forced to converge at zero and the upper; bound is the function is forced to converge at 1.0. Bool_t getCdfBoundaries() const; If true the c.d.f boundary mode is active. Bool_t cacheSource() const; { return _cacheSource ; }. void setCacheSource(Bool_t flag); { _cacheSource = flag ; }. const char* inputBaseName() const; Return base name for caches, i.e. the name of the cached function. Double_t evaluate() const; Dummy evaluate, it is never called. const char* payloadUniqueSuffix() const; { return func.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Tue Jun 30 14:31:55 2015 » Last generated: 2015-06-30 14:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedReal.html:41399,cache,cache,41399,root/html602/RooCachedReal.html,https://root.cern,https://root.cern/root/html602/RooCachedReal.html,4,['cache'],"['cache', 'cacheSource', 'cached', 'caches']"
Performance,"s.; 3785 ; 3786TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3787{; 3788 // Fast path, no lock? Classes load at creation time.; 3789 if ((!load || IsClassStructOrUnion()) && fUsingData); 3790 return fUsingData;; 3791 ; 3792 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3793}; 3794 ; 3795////////////////////////////////////////////////////////////////////////////////; 3796/// Return TListOfFunctionTemplates for a class.; 3797 ; 3798TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3799{; 3800 R__LOCKGUARD(gInterpreterMutex);; 3801 ; 3802 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3803 if (load) fFuncTemplate->Load();; 3804 return fFuncTemplate;; 3805}; 3806 ; 3807////////////////////////////////////////////////////////////////////////////////; 3808/// Return list containing the TMethods of a class.; 3809/// If load is true, the list is populated with all the defined function; 3810/// and currently instantiated function template.; 3811 ; 3812TList *TClass::GetListOfMethods(Bool_t load /* = kTRUE */); 3813{; 3814 R__LOCKGUARD(gInterpreterMutex);; 3815 ; 3816 if (!fMethod.load()) GetMethodList();; 3817 if (load) {; 3818 if (gDebug>0) Info(""GetListOfMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3819 (*fMethod).Load();; 3820 }; 3821 return fMethod;; 3822}; 3823 ; 3824////////////////////////////////////////////////////////////////////////////////; 3825/// Return the collection of functions named ""name"".; 3826 ; 3827TCollection *TClass::GetListOfMethodOverloads(const char* name) const; 3828{; 3829 return const_cast<TClass*>(this)->GetMethodList()->GetListForObject(name);; 3830}; 3831 ; 3832 ; 3833////////////////////////////////////////////////////////////////////////////////; 3834/// Returns a list of all public methods of this class and its base classes.; 3835/// Refers to a subset of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:144037,load,load,144037,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"s.; 3852 ; 3853TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3854{; 3855 // Fast path, no lock? Classes load at creation time.; 3856 if ((!load || IsClassStructOrUnion()) && fUsingData); 3857 return fUsingData;; 3858 ; 3859 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3860}; 3861 ; 3862////////////////////////////////////////////////////////////////////////////////; 3863/// Return TListOfFunctionTemplates for a class.; 3864 ; 3865TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3866{; 3867 R__LOCKGUARD(gInterpreterMutex);; 3868 ; 3869 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3870 if (load) fFuncTemplate->Load();; 3871 return fFuncTemplate;; 3872}; 3873 ; 3874////////////////////////////////////////////////////////////////////////////////; 3875/// Return list containing the TMethods of a class.; 3876/// If load is true, the list is populated with all the defined function; 3877/// and currently instantiated function template.; 3878 ; 3879TList *TClass::GetListOfMethods(Bool_t load /* = kTRUE */); 3880{; 3881 R__LOCKGUARD(gInterpreterMutex);; 3882 ; 3883 if (!fMethod.load()) GetMethodList();; 3884 if (load) {; 3885 if (gDebug>0) Info(""GetListOfMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3886 (*fMethod).Load();; 3887 }; 3888 return fMethod;; 3889}; 3890 ; 3891////////////////////////////////////////////////////////////////////////////////; 3892/// Return the collection of functions named ""name"".; 3893 ; 3894TCollection *TClass::GetListOfMethodOverloads(const char* name) const; 3895{; 3896 return const_cast<TClass*>(this)->GetMethodList()->GetListForObject(name);; 3897}; 3898 ; 3899 ; 3900////////////////////////////////////////////////////////////////////////////////; 3901/// Returns a list of all public methods of this class and its base classes.; 3902/// Refers to a subset of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:146788,load,load,146788,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"s.Definition TApplication.cxx:318; TApplication::fAppImpTApplicationImp * fAppImpDefinition TApplication.h:60; TApplication::TApplicationTApplication(const TApplication &)=delete; TApplication::EExitOnExceptionEExitOnExceptionDefinition TApplication.h:51; TApplication::kDontExit@ kDontExitDefinition TApplication.h:52; TApplication::kAbort@ kAbortDefinition TApplication.h:54; TApplication::kExit@ kExitDefinition TApplication.h:53; TApplication::ExecuteFilestatic Longptr_t ExecuteFile(const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE)Execute a file containing a C++ macro (static method).Definition TApplication.cxx:1729; TApplication::GetSignalHandlerTSignalHandler * GetSignalHandler() constDefinition TApplication.h:107; TApplication::InitializeGraphicsvoid InitializeGraphics(Bool_t only_web=kFALSE)Initialize the graphics environment.Definition TApplication.cxx:244; TApplication::Openvirtual void Open()Definition TApplication.h:132; TApplication::LoadGraphicsLibsvirtual void LoadGraphicsLibs()Load shared libs necessary for graphics.Definition TApplication.cxx:1333; TApplication::StopIdleingvirtual void StopIdleing()Called when system stops idleing.Definition TApplication.cxx:1907; TApplication::EStatusBitsEStatusBitsDefinition TApplication.h:43; TApplication::kProcessRemotely@ kProcessRemotelyDefinition TApplication.h:44; TApplication::kDefaultApplication@ kDefaultApplicationDefinition TApplication.h:45; TApplication::Iconifyvirtual void Iconify()Definition TApplication.h:131; TApplication::ReturnFromRunBool_t ReturnFromRun() constDefinition TApplication.h:153; TApplication::StartIdleingvirtual void StartIdleing()Called when system starts idleing.Definition TApplication.cxx:1896; TApplication::Runvirtual void Run(Bool_t retrn=kFALSE)Main application eventloop. Calls system dependent eventloop via gSystem.Definition TApplication.cxx:1860; TApplication::~TApplicationvirtual ~TApplication()TApplication dtor.Definition TApplication.cxx:210; TApplication::Lowervirt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8h_source.html:12730,Load,LoadGraphicsLibsvirtual,12730,doc/master/TApplication_8h_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html,3,['Load'],"['Load', 'LoadGraphicsLibs', 'LoadGraphicsLibsvirtual']"
Performance,"s.cxx. ◆ GetClass(). TClass * TListOfEnums::GetClass ; (; ); const. inlineprotected . Definition at line 62 of file TListOfEnums.h. ◆ GetIds(). TExMap * TListOfEnums::GetIds ; (; ). inlineprotected . Definition at line 63 of file TListOfEnums.h. ◆ GetObject(). TEnum * TListOfEnums::GetObject ; (; const char * ; name); const. virtual . Return an object from the list of enums if and only if is has already been loaded in the list. ; This is an internal routine. ; Reimplemented in TListOfEnumsWithLock.; Definition at line 268 of file TListOfEnums.cxx. ◆ IsA(). TClass * TListOfEnums::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from THashList.; Reimplemented in TListOfEnumsWithLock.; Definition at line 95 of file TListOfEnums.h. ◆ IsLoaded(). Bool_t TListOfEnums::IsLoaded ; (; ); const. inline . Definition at line 80 of file TListOfEnums.h. ◆ Load(). void TListOfEnums::Load ; (; ). private . Load all the DataMembers known to the interpreter for the scope 'fClass' into this collection. ; Definition at line 337 of file TListOfEnums.cxx. ◆ MapObject(). void TListOfEnums::MapObject ; (; TObject * ; obj). private . Add pair<id, object> to the map of functions and their ids. ; Definition at line 56 of file TListOfEnums.cxx. ◆ operator=(). TListOfEnums & TListOfEnums::operator= ; (; const TListOfEnums & ; ). privatedelete . ◆ RecursiveRemove(). void TListOfEnums::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; This function overrides TCollection::RecursiveRemove that calls the Remove function. THashList::Remove cannot be called because it uses the hash value of the hash table. This hash value is not available anymore when RecursiveRemove is called from the TObject destructor. ; Reimplemented from THashList.; Reimplemented in TListOfEnumsWithLock.; Definition at line 293 of file TListOfEnums.cxx. ◆ Remove()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnums.html:30187,Load,Load,30187,doc/master/classTListOfEnums.html,https://root.cern,https://root.cern/doc/master/classTListOfEnums.html,1,['Load'],['Load']
Performance,"s.cxx:5979; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassSizeInt_t GetClassSize() constDefinition TClass.h:425; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * GetConversionStreamerInfo(const char *onfile_classname, Int_t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::GetDeleteROOT::DelFunc_t GetDelete() constReturn the wrapper around delete ThiObject.Definition TClass.cxx:7530; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::kInitCapacity@ kInitCapacityDefinition TCollection.h:159; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDataTypeBasic data type descriptor (datatype information is obtained from CINT).Definition TDataType.h:44; TDataType::GetTypeInt_t GetType() constDefinition TDataType.h:68; TDataType::SizeInt_t Size() constGet size of basic typedef'ed type.Definition TDataType.cxx:375; TEnum::GetEnumstatic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::kNone@ kNoneDefinition TEnum.h:48; TGenBitsetProxyDefinition TGenCollectionProxy.cxx:135; TGenBitsetProxy::TGenBitsetProxyTGenBitsetProxy(const TGenCollectionProxy &c)Definition TGenCollectionProxy.cxx:138; TGenBitsetProxy::DeleteItemvoid DeleteItem(Bool_t force, void *ptr) const ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:73580,load,load,73580,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance,"s.h. ◆ Lock(). void TWebCanvas::Lock ; (; ). inlineoverrideprotectedvirtual . Reimplemented from TCanvasImp.; Definition at line 129 of file TWebCanvas.h. ◆ NewCanvas(). TCanvasImp * TWebCanvas::NewCanvas ; (; TCanvas * ; c, . const char * ; name, . Int_t ; x, . Int_t ; y, . UInt_t ; width, . UInt_t ; height . ). static . Static method to create TWebCanvas instance Used by plugin manager. ; Definition at line 2869 of file TWebCanvas.cxx. ◆ PerformUpdate(). Bool_t TWebCanvas::PerformUpdate ; (; Bool_t ; async). overrideprotectedvirtual . if canvas or any subpad was modified, scan all primitives in the TCanvas and subpads and convert them into the structure which will be delivered to JSROOT client ; Reimplemented from TCanvasImp.; Definition at line 2319 of file TWebCanvas.cxx. ◆ ProcessCustomScripts(). std::string TWebCanvas::ProcessCustomScripts ; (; bool ; batch). staticprotected . For batch mode special handling of scripts are required Headless browser not able to load modules from the file system Therefore custom web-canvas modules and scripts has to be loaded in advance and processed. ; Definition at line 389 of file TWebCanvas.cxx. ◆ ProcessData(). Bool_t TWebCanvas::ProcessData ; (; unsigned ; connid, . const std::string & ; arg . ). protectedvirtual . Handle data from web browser Returns kFALSE if message was not processed. ; Definition at line 1790 of file TWebCanvas.cxx. ◆ ProcessExecs(). void TWebCanvas::ProcessExecs ; (; TPad * ; pad, . TExec * ; extra = nullptr . ). protected . Process TExec objects in the pad. ; Definition at line 1727 of file TWebCanvas.cxx. ◆ ProcessLinesForObject(). void TWebCanvas::ProcessLinesForObject ; (; TObject * ; obj, . const std::string & ; lines . ). protected . Execute one or several methods for selected object String can be separated by "";;"" to let execute several methods at once. ; Definition at line 1759 of file TWebCanvas.cxx. ◆ ProcessObjectOptions(). TPad * TWebCanvas::ProcessObjectOptions ; (; TWebObjectOptions & ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebCanvas.html:31523,load,load,31523,doc/master/classTWebCanvas.html,https://root.cern,https://root.cern/doc/master/classTWebCanvas.html,2,['load'],"['load', 'loaded']"
Performance,"s.h:113; ROOT::GetClassTClass * GetClass(T *)Definition TClass.h:663; ROOT::CreateClassTClass * CreateClass(const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il)Global function called by a class' static Dictionary() method (see the ClassDef macro).Definition TClass.cxx:5869; ROOT::DelFunc_tvoid(* DelFunc_t)(void *)Definition Rtypes.h:111; ROOT::ESTLTypeESTLTypeDefinition ESTLType.h:28; ROOT::NewArrFunc_tvoid *(* NewArrFunc_t)(Long_t size, void *arena)Definition Rtypes.h:110; ROOT::EFunctionMatchModeEFunctionMatchModeDefinition TDictionary.h:161; ROOT::kConversionMatch@ kConversionMatchDefinition TDictionary.h:163; ROOT::ResetClassVersionvoid ResetClassVersion(TClass *, const char *, Short_t)Global function to update the version number.Definition TClassTable.cxx:951; ROOT::DelArrFunc_tvoid(* DelArrFunc_t)(void *)Definition Rtypes.h:112; ROOT::NewFunc_tvoid *(* NewFunc_t)(void *)Definition Rtypes.h:109; ROOT::MergeFunc_tLong64_t(* MergeFunc_t)(void *, TCollection *, TFileMergeInfo *)Definition Rtypes.h:115; whatstatic const char * whatDefinition stlLoader.cc:5; ROOT::Internal::TClassGetClassHelperDefinition TClass.h:630; ROOT::Internal::TClassGetClassHelper::GetClassstatic TClass * GetClass(Bool_t load, Bool_t silent)Definition TClass.h:631; TClass::ObjectPtrDefinition TClass.h:140; TClass::ObjectPtr::fPtrvoid * fPtrDefinition TClass.h:141; TClass::ObjectPtr::GetAllocatorTVirtualStreamerInfo * GetAllocator() constDefinition TClass.h:149; TClass::ObjectPtr::GetPtrvoid * GetPtr() constDefinition TClass.h:147; TClass::ObjectPtr::fAllocatorTVirtualStreamerInfo * fAllocatorDefinition TClass.h:143; TClass::ObjectPtr::ObjectPtrObjectPtr(void *ptr=nullptr, TVirtualStreamerInfo *allocator=nullptr)Definition TClass.h:145; Drawth1 Draw(); lTLine lDefinition textangle.C:4. coremetaincTClass.h. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:07:01 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:85886,load,load,85886,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['load'],['load']
Performance,"s.size();; 551 for (unsigned i = 0; i < N; ++i) {; 552 if (!fValues[i].fIsActive); 553 continue;; 554 ; 555 int nbytes;; 556 switch (fValues[i].fType) {; 557 case ETypes::kInteger: fValues[i].fInteger = sqlite3_column_int64(fDataSet->fQuery, i); break;; 558 case ETypes::kReal: fValues[i].fReal = sqlite3_column_double(fDataSet->fQuery, i); break;; 559 case ETypes::kText:; 560 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 561 if (nbytes == 0) {; 562 fValues[i].fText = """";; 563 } else {; 564 fValues[i].fText = reinterpret_cast<const char *>(sqlite3_column_text(fDataSet->fQuery, i));; 565 }; 566 break;; 567 case ETypes::kBlob:; 568 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 569 fValues[i].fBlob.resize(nbytes);; 570 if (nbytes > 0) {; 571 std::memcpy(fValues[i].fBlob.data(), sqlite3_column_blob(fDataSet->fQuery, i), nbytes);; 572 }; 573 break;; 574 case ETypes::kNull: break;; 575 default: throw std::runtime_error(""Unhandled column type"");; 576 }; 577 }; 578 return true;; 579}; 580 ; 581////////////////////////////////////////////////////////////////////////////////////////////////; 582/// Almost a no-op, many slots can in fact reduce the performance due to thread synchronization.; 583void RSqliteDS::SetNSlots(unsigned int nSlots); 584{; 585 if (nSlots > 1) {; 586 ::Warning(""SetNSlots"", ""Currently the SQlite data source faces performance degradation in multi-threaded mode. ""; 587 ""Consider turning off IMT."");; 588 }; 589 fNSlots = nSlots;; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////////////////////; 593/// Helper function to throw an exception if there is a fatal sqlite error, e.g. an I/O error.; 594void RSqliteDS::SqliteError(int errcode); 595{; 596 std::string errmsg = ""SQlite error: "";; 597#if SQLITE_VERSION_NUMBER < 3007015; 598 errmsg += std::to_string(errcode);; 599#else; 600 errmsg += sqlite3_errstr(errcode);; 601#endif; 602 throw std::runtime_error(errmsg);; 603}; 604 ; 605} // namespace RDF; 606",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSqliteDS_8cxx_source.html:24220,perform,performance,24220,doc/master/RSqliteDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html,1,['perform'],['performance']
Performance,"s: TGeoHype class; Cones: TGeoCone class; Cone Segments: TGeoConeSeg class; Sphere: TGeoSphere class; Torus: TGeoTorus class; Paraboloid: TGeoParaboloid class; Polycone: TGeoPcon class; Polygon: TGeoPgon class; Polygonal extrusion: TGeoXtru class; Half Spaces: TGeoHalfSpace class; Composite Shapes: TGeoCompositeShape class. Navigation Methods Performed By Shapes; Shapes are named objects and register themselves to the manager class at creation time. This is responsible for their final deletion. Shapes can be created without name if their retrieval by name is no needed. Generally shapes are objects that are useful only at geometry creation stage. The pointer to a shape is in fact needed only when referring to a given volume and it is always accessible at that level. Several volumes may reference a single shape; therefore its deletion is not possible once volumes were defined based on it.; The navigation features related for instance to tracking particles are performed in the following way: Each shape implement its specific algorithms for all required tasks in its local reference system. Note that the manager class handles global queries related to geometry. However, shape-related queries might be sometimes useful:; Bool_t TGeoShape::Contains(Double_t *point[3]);; Bool_tbool Bool_tDefinition RtypesCore.h:63; Double_tdouble Double_tDefinition RtypesCore.h:59; TGeoShape::Containsvirtual Bool_t Contains(const Double_t *point) const =0; The method above returns kTRUE if the point *point is actually inside the shape. The point has to be defined in the local shape reference. For instance, for a box having DX,DY and DZhalf-lengths a point will be considered inside if:; -DX <= point[0] <= DX; -DY <= point[1] <= DY; -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; Int_tint Int_tDefinition RtypesCore.h:45; TGeoShape::DistFromInsidevirtual Double_t DistFromInside(const Double_t *point, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Shapes__classes.html:4470,perform,performed,4470,doc/master/group__Shapes__classes.html,https://root.cern,https://root.cern/doc/master/group__Shapes__classes.html,1,['perform'],['performed']
Performance,"s::GetDict(const type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tTClass::GetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*TClass::GetFunctionTemplate(const char* name); UInt_tTClass::GetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tTClass::GetImplFileLine() const; const char*TClass::GetImplFileName() const; UInt_tTClass::GetInstanceCount() const; TVirtualIsAProxy*TClass::GetIsAProxy() const; TVirtualStreamerInfo*TClass::GetLastReadInfo() const; TList*TClass::GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*TClass::GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*TClass::GetListOfBases(); TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TClass::GetListOfDataMembers(Bool_t load = kTRUE); TList*TClass::GetListOfEnums(Bool_t load = kTRUE); TList*TClass::GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*TClass::GetListOfMethodOverloads(const char* name) const; TList*TClass::GetListOfMethods(Bool_t load = kTRUE); TList*TClass::GetListOfRealData() const; TList*TQObject::GetListOfSignals() const; voidTClass::GetMenuItems(TList* listitems); TList*TClass::GetMenuList() const; ROOT::MergeFunc_tTClass::GetMerge() const; TMethod*TClass::GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*TClass::GetMethodAllAny(const char* method); TMethod*TClass::GetMethodAny(const char* method); TMethod*TClass::GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); voidTClass::GetMissingDictionaries(THashTable& result, bool recurse = false); virtual const char*TNamed::GetName() const; Int_tTClass::GetNdata(); ROOT::NewFunc_tTClass::GetNew() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQClass.html:9996,load,load,9996,root/html602/TQClass.html,https://root.cern,https://root.cern/root/html602/TQClass.html,2,['load'],['load']
Performance,"s::TestStatSampler*RooStats::HypoTestCalculatorGeneric::fTestStatSampler. private:. RooAbsData*fAsimovDataasimov data set; RooArgSetfAsimovGlobObssnapshot of Asimov global observables; RooArgSetfBestFitParamssnapshot of all best fitted Parameter values; RooArgSetfBestFitPoisnapshot of best fitted POI values; doublefNLLAsimov; doublefNLLObs; boolfOneSidedfor one sided PL test statistic (upper limits); boolfOneSidedDiscoveryfor one sided PL test statistic (for discovery); intfUseQTildeflag to indicate if using qtilde or not (-1 (default based on RooRealVar)), 0 false, 1 (true); static intfgPrintLevelcontrol print level (0 minimal, 1 normal, 2 debug). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetPrintLevel(int level); set print level (static function); 0 minimal, 1 normal, 2 debug. AsymptoticCalculator(RooAbsData& data, const RooStats::ModelConfig& altModel, const RooStats::ModelConfig& nullModel, bool nominalAsimov = false); constructor for asymptotic calculator from Data set and ModelConfig; The constructor will perform a global fit of the model to the data; and build an Asimov data set.; It will then also fit the model to the Asimov data set to find the likelihood value; of the Asimov data set; nominalAsimov is an option for using Asimov data set obtained using nominal nuisance parameter values; By default the nuisance parameters are fitted to the data; NOTE: If a fit has been done before, one for speeding up could set all the initial prameters; to the fit value and in addition set the null snapshot to the best fit. Double_t EvaluateNLL(RooAbsPdf& pdf, RooAbsData& data, const RooArgSet* condObs, const RooArgSet* poiSet = 0). HypoTestResult* GetHypoTest() const; It performs an hypothesis tests using the likelihood function; and computes the p values for the null and the alternate using the asymptotic; formulae for the profile likelihood ratio.; See G. Cowan, K. Cranmer, E. Gross and O. Vitells.; Asymptotic formula",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__AsymptoticCalculator.html:5938,perform,perform,5938,root/html602/RooStats__AsymptoticCalculator.html,https://root.cern,https://root.cern/root/html602/RooStats__AsymptoticCalculator.html,1,['perform'],['perform']
Performance,"s::kDL, ""DL_CPU"", nnOptions);; }; if (Use[""DL_GPU""]) {; TString layoutString(""Layout=TANH|100,TANH|50,TANH|10,LINEAR"");; TString trainingStrategyString(""TrainingStrategy=Optimizer=ADAM,LearningRate=1e-3,""; ""TestRepetitions=1,ConvergenceSteps=10,BatchSize=100,MaxEpochs=20"");; TString nnOptions(""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:""; ""WeightInitialization=XAVIERUNIFORM:Architecture=GPU"");; nnOptions.Append("":"");; nnOptions.Append(layoutString);; nnOptions.Append("":"");; nnOptions.Append(trainingStrategyString);; factory->BookMethod(dataloader, TMVA::Types::kDL, ""DL_GPU"", nnOptions);; }; ; ; // Train MVAs using the set of training events; factory->TrainAllMethods();; ; // Evaluate all MVAs using the set of test events; factory->TestAllMethods();; ; // Evaluate and compare performance of all configured MVAs; factory->EvaluateAllMethods();; ; // --------------------------------------------------------------; ; // Save the output; outputFile->Close();; ; std::cout << ""==> Wrote root file: "" << outputFile->GetName() << std::endl;; std::cout << ""==> TMVAMulticlass is done!"" << std::endl;; ; delete factory;; delete dataloader;; ; // Launch the GUI for the root macros; if (!gROOT->IsBatch()) TMVAMultiClassGui( outfileName );; ; ; }; ; int main( int argc, char** argv ); {; // Select methods (don't look at this code - not of interest); TString methodList;; for (int i=1; i<argc; i++) {; TString regMethod(argv[i]);; if(regMethod==""-b"" || regMethod==""--batch"") continue;; if (!methodList.IsNull()) methodList += TString("","");; methodList += regMethod;; }; TMVAMulticlass(methodList);; return 0;; }; ; DataLoader.h; mainint main()Definition Prototype.cxx:12; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; TFile.h; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; TMVAMultiClassGui.h; TROOT.h; gROOT#define gROOTDefin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:37146,perform,performance,37146,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['perform'],['performance']
Performance,"s:; ClassDef(<ClassName>,<VersionNumber>); The version number identifies this particular version of the class. When a class has version 0 it is not stored in a root file but its base class(es) is(are). The reason can be that this class has no data members worth saving or all real info is in the base classes. The version number is written to the file in the Streamer by the call TBuffer::WriteVersion. You, as the designer of the class, do not need to do any manual modification in the Streamer. ROOT schema evolution mechanism is automatic and handled by the StreamerInfo.; 11.5.6 Manual Data Model Evolution Capabilities; The automatic data model schema evolution implemented in ROOT makes it possible to read back the serialized data object in the situation when the definition of the classes those objects represent changed slightly (some of the data members were removed or some new ones added). It is also possible to manually specify the rules for more sophisticated data transformations done while reading to load the serialized objects into data structures that changed quite significantly.; ROOT provides two interface enabling users to specify the conversion rules. The first way is to define a rule in the dictionary file and the second way is to insert it to the TClass object using the C++ API.; There are two types of conversion rules. The first of them, the normal rules, are the ones that should be used in the most of the cases. They provide a buffered input data and an address of the in-memory target object and allow user to specify the conversion function mapping the data being read to the output format. The second type of the rules, the raw rules, also provide the pointer to the target object but the input is a raw TBuffer object containing the input data member declared as an input to the rule. This type of a rule is provided mainly to handle the file format changes that couldn’t have been handled otherwise and in general should not be used unless there is no other op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:498530,load,load,498530,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['load']
Performance,"s; # -----------------------------; ; # Define signal range in which events counts are to be defined; x.setRange(""signalRange"", 4, 6); ; # Associated nsig/nbkg as expected number of events with sig/bkg _in_the_range_ ""signalRange""; nsig = ROOT.RooRealVar(""nsig"", ""number of signal events in signalRange"", 500, 0.0, 10000); nbkg = ROOT.RooRealVar(""nbkg"", ""number of background events in signalRange"", 500, 0, 10000); ; # Use AddPdf to extend the model. Giving as many coefficients as pdfs switches on extension.; model = ROOT.RooAddPdf(""model"", ""(g1+g2)+a"", [bkg, sig], [nbkg, nsig]); ; # Sample data, fit model; # -------------------------------------------; ; # Generate 1000 events from model so that nsig,nbkg come out to numbers <<500 in fit; data = model.generate(x, 1000); ; canv = ROOT.TCanvas(""Canvas"", ""Canvas"", 1500, 600); canv.Divide(3, 1); ; # Fit full range; # -------------------------------------------; ; # Perform unbinned ML fit to data, full range; ; # IMPORTANT:; # The model needs to be copied when fitting with different ranges because; # the interpretation of the coefficients is tied to the fit range; # that's used in the first fit; canv.cd(1); ; model1 = ROOT.RooAddPdf(model); r = model1.fitTo(data, Save=True, PrintLevel=-1); r.Print(); ; frame = x.frame(Title=""Full range fitted""); data.plotOn(frame); model1.plotOn(frame, VisualizeError=r); model1.plotOn(frame); model1.paramOn(frame); frame.Draw(); ; ; # Fit in two regions; # -------------------------------------------; ; canv.cd(2); x.setRange(""left"", 0.0, 4.0); x.setRange(""right"", 6.0, 10.0); ; model2 = ROOT.RooAddPdf(model); r2 = model2.fitTo(data, Range=""left,right"", Save=True, PrintLevel=-1); r2.Print(); ; frame2 = x.frame(Title=""Fit in left/right sideband""); data.plotOn(frame2); model2.plotOn(frame2, VisualizeError=r2); model2.plotOn(frame2); model2.paramOn(frame2); frame2.Draw(); ; ; # Fit in one region; # -------------------------------------------; # Note how restricting the region to only the left t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204a__extendedLikelihood_8py.html:2212,Perform,Perform,2212,doc/master/rf204a__extendedLikelihood_8py.html,https://root.cern,https://root.cern/doc/master/rf204a__extendedLikelihood_8py.html,1,['Perform'],['Perform']
Performance,"s; : Reading 100 signal efficiency bins for 4 variables; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_CutsD.weights.xml␛[0m; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_Likelihood.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_LikelihoodPCA.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_PDERS.weights.xml␛[0m; : signal and background scales: 0.001 0.001; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_PDEFoam.weights.xml␛[0m; : Read foams from file: ␛[0;36mdataset/weights/TMVAClassification_PDEFoam.weights_foams.root␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_KNN.weights.xml␛[0m; : Creating kd-tree with 2000 events; : Computing scale factor for 1d distributions: (ifrac, bottom, top) = (80%, 10%, 90%); ModulekNN : Optimizing tree for 4 variables with 2000 values; : <Fill> Class 1 has 1000 events; : <Fill> Class 2 has 1000 events; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_LD.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_FDA_GA.weights.xml␛[0m; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_MLPBNN.weights.xml␛[0m; MLPBNN : Building Network. ; : Initializing weights; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_DNN_CPU.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_SVM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_BDT.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_RuleFit.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: Cuts for Classification performa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:64303,Optimiz,Optimizing,64303,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['Optimiz'],['Optimizing']
Performance,s; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tTTree::fPacketSize! Number of entries in one packet for parallel root; TVirtualPerfStats*TTree::fPerfStats! pointer to the current perf stats object; TVirtualTreePlayer*TTree::fPlayer! Pointer to current Tree player; Long64_tTTree::fReadEntry! Number of the entry being processed; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tfTypeRWN (0) or CWN (1); Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); char*fXstorage area for RWN; Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THbookTree.html:25566,load,loading,25566,root/html534/THbookTree.html,https://root.cern,https://root.cern/root/html534/THbookTree.html,3,['load'],['loading']
Performance,"s; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 2, Bool_t clearCacheOnServerRedirect = kTRUE, Bool_t allowOptimize = kFALSE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. void doClearObsList(Bool_t flag); { _clearObsList = flag ; }. Bool_t clearObsList(); { return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooObjCacheManager.html:4999,cache,cache,4999,root/html534/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html534/RooObjCacheManager.html,3,['cache'],['cache']
Performance,"s; Libraries. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:22193,cache,cache,22193,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['cache'],['cache']
Performance,"s; Libraries. Function documentation; ~TGLCamera(); Base camera destructor. void SetViewport(const TGLRect& viewport); Set viewport extents from passed 'viewport' rect. void UpdateCache() const; Update internally cached frustum values. TGLBoundingBox Frustum(Bool_t asBox = kTRUE) const; Return the the current camera frustum. If asBox == kFALSE return; a true frustum (truncated square based pyramid). If asBox == kTRUE; return a true box, using the far clipping plane intersection projected; back to the near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap ViewportOverlap(const TGLBoundingBox& box) const; Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport; (as rect) against the viewport rect.; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLRect ViewportRect(const TGLBoundingBox& box, TGLBoundingBox::EFace face) const; Calculate viewport rectangle w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLCamera.html:7667,cache,cache,7667,root/html528/TGLCamera.html,https://root.cern,https://root.cern/root/html528/TGLCamera.html,3,['cache'],['cache']
Performance,"s; Libraries. Function documentation; ~TGLCamera(); Base camera destructor. void SetViewport(const TGLRect& viewport); Set viewport extents from passed 'viewport' rect. void UpdateCache() const; Update internally cached frustum values. TGLBoundingBox Frustum(Bool_t asBox = kTRUE) const; Return the the current camera frustum. If asBox == kFALSE return; a true frustum (truncated square based pyramid). If asBox == kTRUE; return a true box, using the far clipping plane intersection projected; back to the near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. Rgl::EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum cache - call Apply() after last modifcation, before using. Rgl::EOverlap ViewportOverlap(const TGLBoundingBox& box) const; Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport; (as rect) against the viewport rect.; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLRect ViewportRect(const TGLBoundingBox& box, TGLBoundingBox::EFace face) const; Calculate viewport r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLCamera.html:12312,cache,cache,12312,root/html534/TGLCamera.html,https://root.cern,https://root.cern/root/html534/TGLCamera.html,1,['cache'],['cache']
Performance,s; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dgamma; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; RooRealProxy_f0; RooRealProxy_f1; RooRealProxy_f2; RooRealProxy_f3; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBDecay.html:38169,cache,cache,38169,root/html526/RooBDecay.html,https://root.cern,https://root.cern/root/html526/RooBDecay.html,4,['cache'],['cache']
Performance,"s; after the closing of the file. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary.; Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFilePrefetch* GetPrefetchObj(). void WaitFinishPrefetc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFileCacheRead.html:10541,cache,cache,10541,root/html534/TFileCacheRead.html,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html,6,['cache'],['cache']
Performance,"s; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsData(); Destructor. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(RooCmdArg arg1, RooCmdArg arg2 = RooCmdArg(), RooCmdArg arg3 = RooCmdArg(), RooCmdArg arg4 = RooCmdArg(), RooCmdArg arg5 = RooCmdArg(), RooCmdArg arg6 = RooCmdArg(), RooCmdArg arg7 = RooCmdArg(), RooCmdArg arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsData.html:14299,cache,cached,14299,root/html526/RooAbsData.html,https://root.cern,https://root.cern/root/html526/RooAbsData.html,1,['cache'],['cached']
Performance,"s; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsData(); Destructor. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsData.html:14341,cache,cached,14341,root/html528/RooAbsData.html,https://root.cern,https://root.cern/root/html528/RooAbsData.html,1,['cache'],['cached']
Performance,"s; public:. enum TBuffer::EMode { kRead; kWrite; };; enum TBuffer::[unnamed] { kIsOwner; kCannotHandleMemberWiseStreaming; kInitialSize; kMinimalSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfArraySepar! depending from compression level, "", "" or "",""; char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Int_tfCompact! 0 - no any compression, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfNumericLocale! stored value of setlocale(LC_NUMERIC), which should be recovered at the end; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferJSON.html:19097,cache,cache,19097,root/html534/TBufferJSON.html,https://root.cern,https://root.cern/root/html534/TBufferJSON.html,1,['cache'],['cache']
Performance,"s; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. THashTable*fBasesLoaded! table of base classes already checked or loaded; TList*fHandlerslist of plugin handlers; Bool_tfReadingDirs! true if we are running LoadHandlersFromPluginDirs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TPluginManager(); Clean up the plugin manager. void LoadHandlersFromEnv(TEnv* env); Load plugin handlers specified in config file, like:; Plugin.TFile: ^rfio: TRFIOFile RFIO ""TRFIOFile(...)""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). void LoadHandlerMacros(const char* path); Load all plugin macros from the specified path/base directory. void LoadHandlersFromPluginDirs(const char* base = 0); Load plugin handlers specified via macros in a list of plugin; directories. The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPluginManager.html:9421,Load,LoadHandlerMacros,9421,root/html528/TPluginManager.html,https://root.cern,https://root.cern/root/html528/TPluginManager.html,8,['Load'],"['Load', 'LoadHandlerMacros']"
Performance,"s; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Int_t_cacheAllNDim! Cache all integrals with given numeric dimension; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cacheNumCache integral if numeric; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegrati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealIntegral.html:31947,cache,cache,31947,root/html532/RooRealIntegral.html,https://root.cern,https://root.cern/root/html532/RooRealIntegral.html,1,['cache'],['cache']
Performance,"s; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Int_t_cacheAllNDim! Cache all integrals with given numeric dimension; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cacheNumCache integral if numeric; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealInte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealIntegral.html:30586,cache,cache,30586,root/html526/RooRealIntegral.html,https://root.cern,https://root.cern/root/html526/RooRealIntegral.html,3,['cache'],['cache']
Performance,"s; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_t_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedPdf.html:43449,cache,cache,43449,root/html602/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html,2,['cache'],['cache']
Performance,"s; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_epsPrecision; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooFunctor*_ftor! Functor binding of RooAbsReal; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDerivative.html:35050,cache,cache,35050,root/html602/RooDerivative.html,https://root.cern,https://root.cern/root/html602/RooDerivative.html,6,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"s; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. private:. TClass*fClass! Context of this list. Not owned.; TExMap*fIds! Map from DeclId_t to TDataMember*; Bool_tfIsLoaded! Mark whether Load was executed.; ULong64_tfLastLoadMarker! Represent interpreter state when we last did a full load.; THashList*fUnloaded! Holder of TDataMember for unloaded DataMembers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TListOfDataMembers(TClass* cl = 0); Constructor. ~TListOfDataMembers(); Destructor. void MapObject(TObject* obj); Add a pair<id, object> to the map of data members and their ids. void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfDataMembers.html:11418,load,load,11418,root/html602/TListOfDataMembers.html,https://root.cern,https://root.cern/root/html602/TListOfDataMembers.html,2,['load'],['load']
Performance,"s; that can be integrated by all remaining components. If such a set exists, it reconfirms that; each component is capable of analytically integrating the common set, and combines the components; individual integration codes into a single integration code valid for RooProdPdf. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given scenario code. Bool_t checkObservables(const RooArgSet* nset) const; Obsolete. RooAbsPdf::ExtendMode extendMode() const; If this product contains exactly one extendable p.d.f return the extension abilities of; that p.d.f, otherwise return CanNotBeExtended. Double_t expectedEvents(const RooArgSet* nset); Return the expected number of events associated with the extentable input p.d.f; in the product. If there is no extendable term, return zero and issue and error. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return generator context optimized for generating events from product p.d.f.s. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Query internal generation capabilities of component p.d.f.s and aggregate capabilities; into master configuration passed to the generator context. void initGenerator(Int_t code); Forward one-time initialization call to component generation initialization; methods. void generateEvent(Int_t code); Generate a single event with configuration specified by 'code'; Defer internal generation to components as encoded in the _genCode; registry for given generator code. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Forward determination of safety of internal generator code to; component p.d.f that would generate the given observable. RooArgSet* findPdfNSet(RooAbsPdf& pdf) const; Look up user specified normalization set for given input PDF component. RooArgSet* getConst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProdPdf.html:51330,optimiz,optimized,51330,root/html526/RooProdPdf.html,https://root.cern,https://root.cern/root/html526/RooProdPdf.html,1,['optimiz'],['optimized']
Performance,"s; torch_spec = importlib.util.find_spec(""torch""); if torch_spec is not None and os.path.exists(pyTorchFileName):; #cmd = str(ROOT.TMVA.Python_Executable()) + "" "" + pyTorchFileName; #os.system(cmd); #import PyTorch_Generate_CNN_Model; ROOT.Info(""TMVA_CNN_Classification"", ""Booking PyTorch CNN model""); factory.BookMethod(; loader,; TMVA.Types.kPyTorch,; ""PyTorch"",; H=True,; V=False,; VarTransform=None,; FilenameModel=""PyTorchModelCNN.pt"",; FilenameTrainedModel=""PyTorchTrainedModelCNN.pt"",; NumEpochs=max_epochs,; BatchSize=100,; UserCode=str(pyTorchFileName); ); else:; ROOT.Warning(; ""TMVA_CNN_Classification"",; ""PyTorch is not installed or model building file is not existing - skip using PyTorch"",; ); ; if useKerasCNN:; ROOT.Info(""TMVA_CNN_Classification"", ""Building convolutional keras model""); # create python script which can be executed; # create 2 conv2d layer + maxpool + dense; import tensorflow; from tensorflow.keras.models import Sequential; from tensorflow.keras.optimizers import Adam; ; # from keras.initializers import TruncatedNormal; # from keras import initializations; from tensorflow.keras.layers import Input, Dense, Dropout, Flatten, Conv2D, MaxPooling2D, Reshape; ; # from keras.callbacks import ReduceLROnPlateau; model = Sequential(); model.add(Reshape((16, 16, 1), input_shape=(256,))); model.add(Conv2D(10, kernel_size=(3, 3), kernel_initializer=""TruncatedNormal"", activation=""relu"", padding=""same"")); model.add(Conv2D(10, kernel_size=(3, 3), kernel_initializer=""TruncatedNormal"", activation=""relu"", padding=""same"")); # stride for maxpool is equal to pool size; model.add(MaxPooling2D(pool_size=(2, 2))); model.add(Flatten()); model.add(Dense(64, activation=""tanh"")); # model.add(Dropout(0.2)); model.add(Dense(2, activation=""sigmoid"")); model.compile(loss=""binary_crossentropy"", optimizer=Adam(learning_rate=0.001), weighted_metrics=[""accuracy""]); model.save(""model_cnn.h5""); model.summary(); ; if not os.path.exists(""model_cnn.h5""):; raise FileNotFoundError(""Error c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:14200,optimiz,optimizers,14200,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['optimiz'],['optimizers']
Performance,"s=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""m""); ; model.plotOn(frame4); model.plotOn(frame4, Components=""bkg"", LineStyle=""--""); frame4.SetMinimum(0); ; c = ROOT.TCanvas(""rf610_visualerror"", ""rf610_visualerror"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame4.GetYaxis().SetTitleOffset(1.6); frame4.Draw(); ; c.SaveAs(""rf610_visualerror.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) INFO: visualizing 1-sigma uncertainties in parameters (m,s,fsig,m2,s2) from fit result fitresult_model_genData using 315 samplings.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) INFO: visualizing 1-sigma uncertainties in parameters (m,s,fsig,m2,s2) from fit result fitresult_model_genData using 315 samplings.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf610__visualerror_8py.html:6298,optimiz,optimization,6298,doc/master/rf610__visualerror_8py.html,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html,2,['optimiz'],['optimization']
Performance,"s=1,ConvergenceSteps=10,BatchSize=100,MaxEpochs=20""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""N"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : Layout: ""TANH|100,TANH|50,TANH|10,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : Architecture: ""GPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""Optimizer=ADAM,LearningRate=1e-3,TestRepetitions=1,ConvergenceSteps=10,BatchSize=100,MaxEpochs=20"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DL_CPU : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'var1' <---> Output : variable 'var1'; : Input : variable 'var2' <---> Output : vari",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:5429,Optimiz,Optimizer,5429,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['Optimiz'],['Optimizer']
Performance,"sActive(); Static function that returns kTRUE in case we are a PROOF server. TProofServ * This(); Static function returning pointer to global object gProofServ.; Mainly for use via CINT, where the gProofServ symbol might be; deleted from the symbol table. Int_t OldAuthSetup(TString& wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TProofQueryResult * MakeQueryResult(Long64_t nentries, const char* opt, TList* inl, Long64_t first, TDSet* dset, const char* selec, TObject* elist); Create a TProofQueryResult instance for this query. void SetQueryRunning(TProofQueryResult* pq); Set query in running state. void HandleArchive(TMessage* mess, TString* slb = 0); Handle archive request. void HandleProcess(TMessage* mess, TString* slb = 0); Handle processing request. Int_t SendResults(TSocket* sock, TList* outlist = 0, TQueryResult* pq = 0); Sends all objects from the given list to the specified socket. void ProcessNext(TString* slb = 0); process the next query from the queue of submitted jobs.; to be called on the top master only. Int_t RegisterDataSets(TList* in, TList* out); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. void HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. Int_t HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t ab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofServ.html:25879,queue,queue,25879,root/html530/TProofServ.html,https://root.cern,https://root.cern/root/html530/TProofServ.html,2,['queue'],['queue']
Performance,"sActive(); Static function that returns kTRUE in case we are a PROOF server. TProofServ * This(); Static function returning pointer to global object gProofServ.; Mainly for use via CINT, where the gProofServ symbol might be; deleted from the symbol table. Int_t OldAuthSetup(TString& wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TProofQueryResult * MakeQueryResult(Long64_t nentries, const char* opt, TList* inl, Long64_t first, TDSet* dset, const char* selec, TObject* elist); Create a TProofQueryResult instance for this query. void SetQueryRunning(TProofQueryResult* pq); Set query in running state. void HandleArchive(TMessage* mess, TString* slb = 0); Handle archive request. void HandleProcess(TMessage* mess, TString* slb = 0); Handle processing request. Int_t SendResults(TSocket* sock, TList* outlist = 0, TQueryResult* pq = 0); Sends all objects from the given list to the specified socket. void ProcessNext(TString* slb = 0); process the next query from the queue of submitted jobs.; to be called on the top master only. Int_t RegisterDataSets(TList* in, TList* out); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. void HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. void HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:25606,queue,queue,25606,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,1,['queue'],['queue']
Performance,sAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; RooRealProxy_correctQ; RooRealProxy_delC; RooRealProxy_delS; RooRealProxy_delW; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; Double_t_genRhoPlusFrac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNonCPEigenDecay.html:39536,cache,cache,39536,root/html526/RooNonCPEigenDecay.html,https://root.cern,https://root.cern/root/html526/RooNonCPEigenDecay.html,4,['cache'],['cache']
Performance,"sArg as a server to us, ie, declare that we depend on it. ;  ; void addServerList (RooAbsCollection &serverList, bool valueProp=true, bool shapeProp=false);  Register a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:38190,optimiz,optimizeCacheMode,38190,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,6,"['cache', 'optimiz']","['cache', 'optimization', 'optimizeCacheMode']"
Performance,"sArg as a server to us, ie, declare that we depend on it. ;  ; void addServerList (RooAbsCollection &serverList, bool valueProp=true, bool shapeProp=false);  Register a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddPdf.html:46094,optimiz,optimizeCacheMode,46094,doc/master/classRooAddPdf.html,https://root.cern,https://root.cern/doc/master/classRooAddPdf.html,27,"['cache', 'optimiz']","['cache', 'optimization', 'optimizeCacheMode']"
Performance,"sArg as a server to us, ie, declare that we depend on it. ;  ; void addServerList (RooAbsCollection &serverList, bool valueProp=true, bool shapeProp=false);  Register a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; bool isShapeDir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBCPEffDecay.html:48012,optimiz,optimizeCacheMode,48012,doc/master/classRooBCPEffDecay.html,https://root.cern,https://root.cern/doc/master/classRooBCPEffDecay.html,21,"['cache', 'optimiz']","['cache', 'optimization', 'optimizeCacheMode']"
Performance,"sArg as a server to us, ie, declare that we depend on it. ;  ; void addServerList (RooAbsCollection &serverList, bool valueProp=true, bool shapeProp=false);  Register a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddition.html:33139,optimiz,optimizeCacheMode,33139,doc/master/classRooAddition.html,https://root.cern,https://root.cern/doc/master/classRooAddition.html,405,"['cache', 'optimiz']","['cache', 'optimization', 'optimizeCacheMode']"
Performance,"sArg derived payload require special care as server redirects cache operation mode changes and constant term optimization calls may need to be forwarded to such cache payload. This cache manager takes care of all these operations by forwarding these calls to the RooAbsCacheElement interface functions, which have a sensible default implementation. ; Definition at line 29 of file RooObjCacheManager.h. Public Member Functions;  RooObjCacheManager (const RooObjCacheManager &other, RooAbsArg *owner=nullptr);  Copy constructor. ;  ;  RooObjCacheManager (RooAbsArg *owner=nullptr, Int_t maxSize=2, bool clearCacheOnServerRedirect=true, bool allowOptimize=false);  Constructor of object cache manager for given owner. ;  ;  ~RooObjCacheManager () override;  Destructor. ;  ; void findConstantNodes (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  If clearOnRedirect is false, forward constant term optimization calls to cache elements. ;  ; void insertObjectHook (RooAbsCacheElement &) override;  Set owner link on all object inserted into cache. ;  ; TClass * IsA () const override;  ; void operModeHook () override;  Intercept changes to cache operation mode and forward to cache elements. ;  ; void optimizeCacheMode (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  Intercept calls to perform automatic optimization of cache mode operation. ;  ; void printCompactTreeHook (std::ostream &, const char *) override;  Add details on cache contents when printing in tree mode. ;  ; bool redirectServersHook (const RooAbsCollection &, bool, bool, bool) override;  Intercept server redirect calls. ;  ; void setClearOnRedirect (bool flag);  ; void sterilize () override;  Clear the cache payload but retain slot mapping w.r.t to normalization and integration sets. ;  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooCacheManager< RooAbsCacheElement >;  RooCacheManager (const RooCac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:1551,cache,cache,1551,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['cache'],['cache']
Performance,"sArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedReal.html:22896,cache,cache,22896,root/html528/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedReal.html,1,['cache'],['cache']
Performance,"sArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsCategoryLValue::setBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); voidRooAbsCategoryLValue::setConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual Bool_tsetIndex(Int_t index, Bool_t printError = kTRUE); virtual Bool_tsetLabel(const char* label, Bool_t printError = kTRUE); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSuperCategory.html:16252,cache,cache,16252,root/html534/RooSuperCategory.html,https://root.cern,https://root.cern/root/html534/RooSuperCategory.html,1,['cache'],['cache']
Performance,"sArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsCategoryLValue::setBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); voidRooAbsCategoryLValue::setConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual Bool_tsetIndex(Int_t index, Bool_t printError = kTRUE); virtual Bool_tsetLabel(const char* label, Bool_t printError = kTRUE); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetRange(const char* rangeName, const char* stateNameList); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCategory.html:15926,cache,cache,15926,root/html534/RooCategory.html,https://root.cern,https://root.cern/root/html534/RooCategory.html,1,['cache'],['cache']
Performance,"sArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidsetEps(Double_t e); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); RooMoment*RooAbsReal::sigma(RooRealVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDerivative.html:22430,cache,cache,22430,root/html526/RooDerivative.html,https://root.cern,https://root.cern/root/html526/RooDerivative.html,1,['cache'],['cache']
Performance,"sArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction2Binding<double,double,double>&operator=(const RooCFunction2Binding<double,double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2Binding_double_double_double_.html:19880,optimiz,optimizeCacheMode,19880,root/html602/RooCFunction2Binding_double_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2Binding_double_double_double_.html,2,['optimiz'],['optimizeCacheMode']
Performance,"sArg* owner = 0, Int_t maxSize = 2, Bool_t clearCacheOnServerRedirect = kTRUE, Bool_t allowOptimize = kFALSE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. void doClearObsList(Bool_t flag); { _clearObsList = flag ; }. Bool_t clearObsList(); { return _clearObsList ; }. void setClearOnRedirect(Bool_t flag); { _clearOnRedi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooObjCacheManager.html:5057,cache,cache,5057,root/html534/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html534/RooObjCacheManager.html,6,['cache'],['cache']
Performance,"sArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_effEfficiency function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; RooArgSet*_fixedNset! Fixed normalization set overriding default normalization set (if provided); Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooEffProd.html:38563,cache,cache,38563,root/html532/RooEffProd.html,https://root.cern,https://root.cern/root/html532/RooEffProd.html,1,['cache'],['cache']
Performance,"sArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_effEfficiency function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; RooArgSet*_fixedNset! Fixed normalization set overriding default normalization set (if provided); static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to act",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooEffProd.html:36531,cache,cache,36531,root/html526/RooEffProd.html,https://root.cern,https://root.cern/root/html526/RooEffProd.html,3,['cache'],['cache']
Performance,"sArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_lowestOrder; static Int_tRooPri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooPolynomial.html:40070,cache,cache,40070,root/html534/RooPolynomial.html,https://root.cern,https://root.cern/root/html534/RooPolynomial.html,1,['cache'],['cache']
Performance,"sArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; TArrayD_limits; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_nBins; static I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooParametricStepFunction.html:40971,cache,cache,40971,root/html534/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html534/RooParametricStepFunction.html,1,['cache'],['cache']
Performance,sArg::_cacheListlist of caches; Bool_t_cdfBoundariesUse boundary conditions for CDFs.; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooSetProxy_depListList of observables mapped onto histogram observables; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; TIterator*_histObsIter!; RooArgSet_histObsListList of observables defining dimensions of histogram; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeR,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistFunc.html:35324,cache,cache,35324,root/html602/RooHistFunc.html,https://root.cern,https://root.cern/root/html602/RooHistFunc.html,8,"['Cache', 'cache']","['Cached', 'cache']"
Performance,sArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine ; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_nset! Normalization set to be passed along to contents; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; ma,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFormulaVar.html:31707,cache,cache,31707,root/html526/RooFormulaVar.html,https://root.cern,https://root.cern/root/html526/RooFormulaVar.html,2,['cache'],['cache']
Performance,sArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine ; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_nset! Normalization set to be passed along to contents; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*Roo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooFormulaVar.html:32374,cache,cache,32374,root/html530/RooFormulaVar.html,https://root.cern,https://root.cern/root/html530/RooFormulaVar.html,1,['cache'],['cache']
Performance,sArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine ; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_nset! Normalization set to be passed along to contents; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFormulaVar.html:32817,cache,cache,32817,root/html532/RooFormulaVar.html,https://root.cern,https://root.cern/root/html532/RooFormulaVar.html,1,['cache'],['cache']
Performance,sArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaCo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDecay.html:37921,cache,cache,37921,root/html526/RooDecay.html,https://root.cern,https://root.cern/root/html526/RooDecay.html,4,['cache'],['cache']
Performance,sArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine ; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenericPdf.html:37811,cache,cache,37811,root/html526/RooGenericPdf.html,https://root.cern,https://root.cern/root/html526/RooGenericPdf.html,1,['cache'],['cache']
Performance,sArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine ; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Pr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGenericPdf.html:38193,cache,cache,38193,root/html528/RooGenericPdf.html,https://root.cern,https://root.cern/root/html528/RooGenericPdf.html,3,['cache'],['cache']
Performance,"sArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction3Ref<VO,VI1,VI2,VI3> Streamer(TBuffer& ); C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction3Binding_double_unsigned_int_double_double_.html:35402,cache,cache,35402,root/html534/RooCFunction3Binding_double_unsigned_int_double_double_.html,https://root.cern,https://root.cern/root/html534/RooCFunction3Binding_double_unsigned_int_double_double_.html,2,['cache'],['cache']
Performance,"sArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,double,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction3PdfBinding_double_double_double_double_.html:40440,cache,cache,40440,root/html532/RooCFunction3PdfBinding_double_double_double_double_.html,https://root.cern,https://root.cern/root/html532/RooCFunction3PdfBinding_double_double_double_double_.html,2,['cache'],['cache']
Performance,"sArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_t_boolValue! Transient cache for bool values from tree branches ; UChar_t_byteValue! Transient cache for byte values from tree branches ; static Bool_t_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_t_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceNumIntForce numerical integration if flag set; static Bool_t_globalSelectCompGlobal activation switch for component selection; static Bool_t_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::Op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:30951,cache,cache,30951,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,7,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance,"sArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsMoment&operator=(const RooAbsMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsMoment.html:19421,optimiz,optimizeCacheMode,19421,root/html602/RooAbsMoment.html,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html,2,['optimiz'],['optimizeCacheMode']
Performance,"sArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction2Binding<double,unsigned int,double>&operator=(const RooCFunction2Binding<double,unsigned int,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2Binding_double_unsigned_int_double_.html:19844,optimiz,optimizeCacheMode,19844,root/html602/RooCFunction2Binding_double_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2Binding_double_unsigned_int_double_.html,2,['optimiz'],['optimizeCacheMode']
Performance,"sArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooLinearVar&operator=(const RooLinearVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLinearVar.html:23482,optimiz,optimizeCacheMode,23482,root/html602/RooLinearVar.html,https://root.cern,https://root.cern/root/html602/RooLinearVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"sArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooProfileLL&operator=(const RooProfileLL&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProfileLL.html:19821,optimiz,optimizeCacheMode,19821,root/html602/RooProfileLL.html,https://root.cern,https://root.cern/root/html602/RooProfileLL.html,2,['optimiz'],['optimizeCacheMode']
Performance,"sArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidupdateIndexList(). Data Members; public:. enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGenCategory.html:19900,Cache,CacheMode,19900,root/html534/RooGenCategory.html,https://root.cern,https://root.cern/root/html534/RooGenCategory.html,1,['Cache'],['CacheMode']
Performance,"sArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidupdateIndexList(). Data Members; public:. enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooSetProxy_catSetSet of input category; RooRefCountListRooAbsArg::_clien",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMultiCategory.html:19706,Cache,CacheMode,19706,root/html534/RooMultiCategory.html,https://root.cern,https://root.cern/root/html534/RooMultiCategory.html,1,['Cache'],['CacheMode']
Performance,"sArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); RooMoment*RooAbsReal::sigma(RooRealVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsHiddenReal.html:22254,cache,cache,22254,root/html526/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html526/RooAbsHiddenReal.html,41,['cache'],['cache']
Performance,"sArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; voidsetVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMembe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealMPFE.html:22839,cache,cache,22839,root/html526/RooRealMPFE.html,https://root.cern,https://root.cern/root/html526/RooRealMPFE.html,1,['cache'],['cache']
Performance,"sArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); virtual voidsetBin(Int_t ibin, const RooAbsBinning& binning); virtual voidsetBinFast(Int_t ibin, const RooAbsBinning& binning); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetConstant(Bool_t value = kTRUE); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); virtual voidsetVal(Double_t value); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidSho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsRealLValue.html:26585,cache,cache,26585,root/html532/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html532/RooAbsRealLValue.html,1,['cache'],['cache']
Performance,"sArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoErr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:55283,optimiz,optimizeDirtyHook,55283,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"sBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArray*TEntryList::fBlocksblocks with indices of passing events (TEntryListBlocks); TEntryList*TEntryList::fCurrent! currently filled entry list; TDirectory*TEntryList::fDirectory! Pointer to directory holding this tree; Long64_tTEntryList::fEntriesToProcessused on proof to set the number of entries to process in a packet; Long64_tfEntrythe entry number, when the list is used for subentries; TStringTEntryList::fFileNamename of the file, where the tree is; Long64_tTEntryList::fLastIndexQueried! used to optimize GetEntry() function from a loop ; Long64_tTEntryList::fLastIndexReturned! used to optimize GetEntry() function from a loop; TEntryListArray*fLastSubListQueried! last sublist checked by GetSubListForEntry; TList*TEntryList::fListsa list of underlying entry lists for each tree of a chain; Long64_tTEntryList::fNnumber of entries in the list; Int_tTEntryList::fNBlocksnumber of TEntryListBlocks; TStringTNamed::fNameobject identifier; Bool_tTEntryList::fReapplyIf true, TTree::Draw will 'reapply' the original cut; Bool_tTEntryList::fShift! true when some sub-lists don't correspond to trees; ULong_tTEntryList::fStringHash! Hash value of a string of treename and filename; TIter*fSubListIter! to iterate over fSubLists and keep last one checked; TList*fSubListsa list of underlying entry lists for each event of a TEntryList; TStringTNamed::fTitleobject title; TStringTEntryList::fTreeNamename of the tree; Int_tTEntryList::fTreeNumber! the index of the tree in the chain (used when the entry. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(); Initialize data members, called by Reset. TEntryListArray(); default c-tor. TEntryListArray(const char* name, const char* title); c-tor wit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEntryListArray.html:10812,optimiz,optimize,10812,root/html532/TEntryListArray.html,https://root.cern,https://root.cern/root/html532/TEntryListArray.html,4,['optimiz'],['optimize']
Performance,"sCategoryLValue.cxx. ◆ RooAbsCategoryLValue() [3/3]. RooAbsCategoryLValue::RooAbsCategoryLValue ; (; const RooAbsCategoryLValue & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 56 of file RooAbsCategoryLValue.cxx. Member Function Documentation. ◆ Class(). static TClass * RooAbsCategoryLValue::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCategoryLValue::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCategoryLValue::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 123 of file RooAbsCategoryLValue.h. ◆ copyCache(). void RooAbsCategoryLValue::copyCache ; (; const RooAbsArg * ; source, . bool ; valueOnly = false, . bool ; setValDirty = true . ). overrideprotectedvirtual . Copy the cached value from given source and raise dirty flag. ; It is the callers responsibility to ensure that the sources cache is clean(valid) before this function is called, e.g. by calling syncCache() on the source. ; Reimplemented from RooAbsCategory.; Definition at line 123 of file RooAbsCategoryLValue.cxx. ◆ DeclFileName(). static const char * RooAbsCategoryLValue::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 123 of file RooAbsCategoryLValue.h. ◆ getBin() [1/2]. Int_t RooAbsCategoryLValue::getBin ; (; const char * ; = nullptr); const. inlineoverridevirtual . Get the index of the plot bin for the current value of this category. ; Implements RooAbsLValue.; Definition at line 81 of file RooAbsCategoryLValue.h. ◆ getBin() [2/2]. Int_t RooAbsCategoryLValue::getBin ; (; const RooAbsBinning * ; ); const. inlineoverridevirtual . Implements RooAbsLValue.; Definition at line 97 of file RooAbsCategoryLValue.h. ◆ getBinningNames(). std::list< std::string > RooAbsCategoryLValue::getBinningNames ; (; ); const. inlineoverridevirtual . Implemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategoryLValue.html:48222,cache,cache,48222,doc/master/classRooAbsCategoryLValue.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategoryLValue.html,1,['cache'],['cache']
Performance,"sConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) final;; 296 void* GetInterfaceMethod(TClass* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE) final;; 297 void* GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) final;; 298 DeclId_t GetFunction(ClassInfo_t *cl, const char *funcname) final;; 299 DeclId_t GetFunctionWithPrototype(ClassInfo_t *cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) final;; 300 DeclId_t GetFunctionWithValues(ClassInfo_t *cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE) final;; 301 DeclId_t GetFunctionTemplate(ClassInfo_t *cl, const char *funcname) final;; 302 void GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector<DeclId_t>& res) const final;; 303 virtual void LoadFunctionTemplates(TClass* cl) const final;; 304 ; 305 std::vector<std::string> GetUsingNamespaces(ClassInfo_t *cl) const final;; 306 ; 307 void GetInterpreterTypeName(const char* name, std::string &output, Bool_t full = kFALSE) final;; 308 void Execute(const char* function, const char* params, int* error = nullptr) final;; 309 void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = nullptr) final;; 310 void Execute(TObject* obj, TClass* cl, const char* method, const char* params, Bool_t objectIsConst, int* error = nullptr);; 311 void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = nullptr) final;; 312 void ExecuteWithArgsAndReturn(TMethod* method, void* address, const void* args[] = nullptr, int nargs = 0, void* ret= nullptr) const final;; 313 Longptr_t ExecuteMacro(const char* filename, EErrorCode* error = nullptr) final;; 314 void RecursiveRemove(TObject* obj) final;; 315 Bool_t IsErrorMessagesEnabled() const final;; 316",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:14395,Load,LoadFunctionTemplates,14395,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['Load'],['LoadFunctionTemplates']
Performance,"sContainers()); 1214 SetVisLeaves();; 1215 if (option && option[0] > 0) {; 1216 painter->DrawVolume(this, option);; 1217 } else {; 1218 painter->DrawVolume(this, gEnv->GetValue(""Viewer3D.DefaultDrawOption"", """"));; 1219 }; 1220}; 1221 ; 1222////////////////////////////////////////////////////////////////////////////////; 1223/// draw only this volume; 1224 ; 1225void TGeoVolume::DrawOnly(Option_t *option); 1226{; 1227 if (IsAssembly()) {; 1228 Info(""DrawOnly"", ""Volume assemblies do not support this option."");; 1229 return;; 1230 }; 1231 if (gGeoManager != fGeoManager); 1232 gGeoManager = fGeoManager;; 1233 SetVisOnly();; 1234 TGeoAtt::SetVisRaytrace(kFALSE);; 1235 TVirtualGeoPainter *painter = fGeoManager->GetGeomPainter();; 1236 if (option && option[0] > 0) {; 1237 painter->DrawVolume(this, option);; 1238 } else {; 1239 painter->DrawVolume(this, gEnv->GetValue(""Viewer3D.DefaultDrawOption"", """"));; 1240 }; 1241}; 1242 ; 1243////////////////////////////////////////////////////////////////////////////////; 1244/// Perform an extensive sampling to find which type of voxelization is; 1245/// most efficient.; 1246 ; 1247Bool_t TGeoVolume::OptimizeVoxels(); 1248{; 1249 printf(""Optimizing volume %s ...\n"", GetName());; 1250 TVirtualGeoPainter *painter = fGeoManager->GetGeomPainter();; 1251 return painter->TestVoxels(this);; 1252}; 1253 ; 1254////////////////////////////////////////////////////////////////////////////////; 1255/// Print volume info; 1256 ; 1257void TGeoVolume::Print(Option_t *) const; 1258{; 1259 printf(""== Volume: %s type %s positioned %d times\n"", GetName(), ClassName(), fRefCount);; 1260 InspectShape();; 1261 InspectMaterial();; 1262}; 1263 ; 1264////////////////////////////////////////////////////////////////////////////////; 1265/// paint volume; 1266 ; 1267void TGeoVolume::Paint(Option_t *option); 1268{; 1269 TVirtualGeoPainter *painter = fGeoManager->GetGeomPainter();; 1270 painter->SetTopVolume(this);; 1271 // painter->Paint(option);; 1272 if (option &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:48322,Perform,Perform,48322,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['Perform'],['Perform']
Performance,"sCut(), you must use the pointer to the current TTree to call the method GetEntry(entry). The parameter entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use. fChain->GetTree()->GetEntry(entry);; To create a selector call:; root[] T->MakeSelector(""MySelector"");; Where T is the TTree and MySelector is the name of created class and the name of the .h and .C files. The resulting TSelector is the argument to TTree::Process. The argument can be the file name or a pointer to the selector object.; root[] T->Process(""MySelector.C"","""",1000,100);; This call will interpret the class defined in MySelector.C and process 1000 entries beginning with entry 100. The file name can be appended with a “+” or a “++” to use ACLiC.; root[] T->Process(""MySelector.C++"","""",1000,100);; When appending a “++”, the class will be compiled and dynamically loaded.; root[] T->Process(""MySelector.C+"","""",1000,100);; When appending a “+”, the class will also be compiled and dynamically loaded. When it is called again, it recompiles only if the macro (MySelector.C) has changed since it was compiled last. If not, it loads the existing library. The next example shows how to create a selector with a pointer:; MySelector *selector = (MySelector *)TSelector::GetSelector(""MySelector.C+"");; T->Process(selector);; Using this form, you can do things like:; selector->public_attribute1 = init_value;; for (int i=0; i<limit; i++) {; T->Process(selector);; selector->public_attribute1 =; function(selector->public_attribute2);; }; TTree::Process() is aware of PROOF, ROOT parallel processing facility. If PROOF is setup, it divides the processing amongst the slave CPUs.; 12.22.1 Performance Benchmarks. The program $ROOTSYS/test/bench.cxx compares the I/O performance of STL vectors to the ROOT native TClonesArrays collection class. It creates trees with and without compression for the following cases: vector<THit>, vector<THit*>, TClonesArray(TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:646318,load,loaded,646318,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance,"sData > RooAbsData::reduce ; (; const RooFormulaVar & ; cutVar); const. Create a subset of the data set by applying the given cut on the data points. ; The 'cutVar' formula variable is used to select the subset of data points to be retained in the reduced data collection. ; Definition at line 485 of file RooAbsData.cxx. ◆ reduceEng(). virtual std::unique_ptr< RooAbsData > RooAbsData::reduceEng ; (; const RooArgSet & ; varSubset, . const RooFormulaVar * ; cutVar, . const char * ; cutRange = nullptr, . std::size_t ; nStart = 0, . std::size_t ; = std::numeric_limits< std::size_t >::max() . ); const. protectedpure virtual . Implemented in RooDataHist, and RooDataSet. ◆ reset(). void RooAbsData::reset ; (; ). virtual . Reimplemented in RooDataHist.; Definition at line 330 of file RooAbsData.cxx. ◆ resetBuffers(). void RooAbsData::resetBuffers ; (; ). Definition at line 2344 of file RooAbsData.cxx. ◆ resetCache(). void RooAbsData::resetCache ; (; ). protectedvirtual . Internal method – Remove cached function values. ; Definition at line 354 of file RooAbsData.cxx. ◆ rmsVar(). RooRealVar * RooAbsData::rmsVar ; (; const RooRealVar & ; var, . const char * ; cutSpec = nullptr, . const char * ; cutRange = nullptr . ); const. Create a RooRealVar containing the RMS of observable 'var' in this dataset. ; If cutSpec and/or cutRange are specified the moment is calculated on the subset of the data which pass the C++ cut specification expression 'cutSpec' and/or are inside the range named 'cutRange' ; Definition at line 1094 of file RooAbsData.cxx. ◆ setArgStatus(). void RooAbsData::setArgStatus ; (; const RooArgSet & ; set, . bool ; active . ). protectedvirtual . Definition at line 370 of file RooAbsData.cxx. ◆ setDefaultStorageType(). void RooAbsData::setDefaultStorageType ; (; RooAbsData::StorageType ; s). static . Definition at line 130 of file RooAbsData.cxx. ◆ setDirtyProp(). void RooAbsData::setDirtyProp ; (; bool ; flag). Control propagation of dirty flags from observables in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:65639,cache,cached,65639,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['cache'],['cached']
Performance,"sDataStore::addColumns ; (; const RooArgList & ; varList). Definition at line 60 of file RooAbsDataStore.cxx. ◆ append(). virtual void RooAbsDataStore::append ; (; RooAbsDataStore & ; other). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ attachBuffers(). virtual void RooAbsDataStore::attachBuffers ; (; const RooArgSet & ; extObs). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ attachCache(). virtual void RooAbsDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ cacheArgs(). virtual void RooAbsDataStore::cacheArgs ; (; const RooAbsArg * ; cacheOwner, . RooArgSet & ; varSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = false . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ cachedVars(). const RooArgSet & RooAbsDataStore::cachedVars ; (; ); const. inline . Definition at line 130 of file RooAbsDataStore.h. ◆ cacheOwner(). virtual const RooAbsArg * RooAbsDataStore::cacheOwner ; (; ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ changeObservableName(). virtual bool RooAbsDataStore::changeObservableName ; (; const char * ; from, . const char * ; to . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ checkInit(). virtual void RooAbsDataStore::checkInit ; (; ); const. inlinevirtual . Reimplemented in RooTreeDataStore.; Definition at line 137 of file RooAbsDataStore.h. ◆ Class(). static TClass * RooAbsDataStore::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsDataStore::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsDataStore::Class_Version ; (; ). inli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsDataStore.html:19217,cache,cachedVars,19217,doc/master/classRooAbsDataStore.html,https://root.cern,https://root.cern/doc/master/classRooAbsDataStore.html,1,['cache'],['cachedVars']
Performance,"sEdit::ResolveTypedef (GetName(), kTRUE);; 1667 TIter next (fgClassTypedefHash->GetListForObject (resolvedThis));; 1668 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1669 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1670 fgClassTypedefHash->Remove (htmp);; 1671 delete htmp;; 1672 break;; 1673 }; 1674 }; 1675 }; 1676 ; 1677 // Not owning lists, don't call Delete(); 1678 // But this still need to be done first because the TList destructor; 1679 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1680 delete fStreamer; fStreamer =nullptr;; 1681 delete fAllPubData; fAllPubData =nullptr;; 1682 delete fAllPubMethod; fAllPubMethod=nullptr;; 1683 ; 1684 delete fPersistentRef.load();; 1685 ; 1686 if (fBase.load()); 1687 (*fBase).Delete();; 1688 delete fBase.load(); fBase = nullptr;; 1689 ; 1690 if (fData.load()); 1691 (*fData).Delete();; 1692 delete fData.load(); fData = nullptr;; 1693 ; 1694 if (fUsingData.load()); 1695 (*fUsingData).Delete();; 1696 delete fUsingData.load(); fUsingData = nullptr;; 1697 ; 1698 if (fEnums.load()); 1699 (*fEnums).Delete();; 1700 delete fEnums.load(); fEnums = nullptr;; 1701 ; 1702 if (fFuncTemplate); 1703 fFuncTemplate->Delete();; 1704 delete fFuncTemplate; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuList; fClassMenuList=nullptr;; 1727 ; 1728 fIsOffsetStreamerSet=kFALSE;; 1729 ; 1730 if ( fIsA ) delete fIsA;; 1731 ; 1732 if ( fRefProxy ) fRefPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:65202,load,load,65202,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"sEdit::ResolveTypedef (GetName(), kTRUE);; 1734 TIter next (fgClassTypedefHash->GetListForObject (resolvedThis));; 1735 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1736 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1737 fgClassTypedefHash->Remove (htmp);; 1738 delete htmp;; 1739 break;; 1740 }; 1741 }; 1742 }; 1743 ; 1744 // Not owning lists, don't call Delete(); 1745 // But this still need to be done first because the TList destructor; 1746 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1747 delete fStreamer; fStreamer =nullptr;; 1748 delete fAllPubData; fAllPubData =nullptr;; 1749 delete fAllPubMethod; fAllPubMethod=nullptr;; 1750 ; 1751 delete fPersistentRef.load();; 1752 ; 1753 if (fBase.load()); 1754 (*fBase).Delete();; 1755 delete fBase.load(); fBase = nullptr;; 1756 ; 1757 if (fData.load()); 1758 (*fData).Delete();; 1759 delete fData.load(); fData = nullptr;; 1760 ; 1761 if (fUsingData.load()); 1762 (*fUsingData).Delete();; 1763 delete fUsingData.load(); fUsingData = nullptr;; 1764 ; 1765 if (fEnums.load()); 1766 (*fEnums).Delete();; 1767 delete fEnums.load(); fEnums = nullptr;; 1768 ; 1769 if (fFuncTemplate); 1770 fFuncTemplate->Delete();; 1771 delete fFuncTemplate; fFuncTemplate = nullptr;; 1772 ; 1773 if (fMethod.load()); 1774 (*fMethod).Delete();; 1775 delete fMethod.load(); fMethod=nullptr;; 1776 ; 1777 if (fRealData); 1778 fRealData->Delete();; 1779 delete fRealData; fRealData=nullptr;; 1780 ; 1781 if (fStreamerInfo); 1782 fStreamerInfo->Delete();; 1783 delete fStreamerInfo; fStreamerInfo = nullptr;; 1784 ; 1785 if (fDeclFileLine >= -1); 1786 TClass::RemoveClass(this);; 1787 ; 1788 gCling->ClassInfo_Delete(fClassInfo);; 1789 fClassInfo=nullptr;; 1790 ; 1791 if (fClassMenuList); 1792 fClassMenuList->Delete();; 1793 delete fClassMenuList; fClassMenuList=nullptr;; 1794 ; 1795 fIsOffsetStreamerSet=kFALSE;; 1796 ; 1797 if ( fIsA ) delete fIsA;; 1798 ; 1799 if ( fRefProxy ) fRefPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:67953,load,load,67953,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"sEffective parameters of this p.d.f.; RooRealProxy_pdf1First input p.d.f; RooRealProxy_pdf2Second input p.d.f; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Double_t_shift1; Double_t_shift2; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_xConvolution observable; RooRealProxy_xprimeInput function representing value of convolution observable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFFTConvPdf(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFFTConvPdf.html:48817,cache,cache,48817,root/html534/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html534/RooFFTConvPdf.html,2,['cache'],['cache']
Performance,"sFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || nentries == tree->GetEntriesFast())) {; 3583 // Quickly copy the basket without decompression and streaming.; 3584 Long64_t totbytes = GetTotBytes();; 3585 for (Long64_t i = 0; i < nentries; i += tree->GetTree()->GetEntries()) {; 3586 if (tree->LoadTree(i) < 0) {; 3587 break;; 3588 }; 3589 if ( withIndex ) {; 3590 withIndex = R__HandleIndex( onIndexError, this, tree );; 3591 }; 3592 if (this->GetDirectory()) {; 3593 TFile* file2 = this->GetDirectory()->GetFile();; 3594 if (file2 && (file2->GetEND() > TTree::GetMaxTreeSize())) {; 3595 if (this->GetDirectory() == (TDirectory*) file2) {; 3596 this->ChangeFile(file2);; 3597 }; 3598 }; 3599 }; 3600 TTreeCloner cloner(tree->GetTree(), this, option, TTreeCloner::kNoWarnings);; 3601 if (cloner.IsValid()) {; 3602 this->SetEntries(this->GetEntries() + tree->GetTree()->GetEntries());; 3603 if (cacheSize != -1) cloner.SetCacheSize(cacheSize);; 3604 cloner.Exec();; 3605 } else {; 3606 if (i == 0) {; 3607 Warning(""CopyEntries"",""%s"",cloner.GetWarning());; 3608 // If the first cloning does not work, something is really wrong; 3609 // (since apriori the source and target are exactly the same structure!); 3610 return -1;; 3611 } else {; 3612 if (cloner.NeedConversion()) {; 3613 TTree *localtree = tree->GetTree();; 3614 Long64_t tentries = localtree->GetEntries();; 3615 if (needCopyAddresses) {; 3616 // Copy MakeClass status.; 3617 tree->SetMakeClass(fMakeClass);; 3618 // Copy branch addresses.; 3619 CopyAddresses(tree);; 3620 }; 3621 for (Long64_t ii = 0; ii < tentries; ii++) {; 3622 if (localtree->GetEntry(ii) <= 0) {; 3623 break;; 3624 }; 3625 this->Fill();; 3626 }; 3627 if (needCopyAddresses); 3628 tree->ResetBranchAddresses();; 3629 if (this->GetTreeIndex()) {; 3630 this->GetTreeIndex()->Append(tree->GetTree()->GetTreeIndex(), true);; 3631 }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:142779,cache,cacheSize,142779,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cacheSize']
Performance,"sFolder() const overrideTROOTinlinevirtual; IsInterrupted() constTROOTinline; IsLineProcessing() constTROOTinline; IsModified() constTDirectoryinlinevirtual; IsOnHeap() constTObjectinline; IsProofServ() constTROOTinline; IsRootFile(const char *filename) constTROOT; IsSortable() const overrideTNamedinlinevirtual; IsWebDisplay() constTROOTinline; IsWebDisplayBatch() constTROOTinline; IsWritable() constTDirectoryinlinevirtual; IsZombie() constTObjectinline; kBitMask enum valueTObject; kCanDelete enum valueTObject; kCannotPick enum valueTObject; kHasUUID enum valueTObject; kInconsistent enum valueTObject; kInvalidObject enum valueTObject; kIsOnHeap enum valueTObject; kIsReferenced enum valueTObject; kMustCleanup enum valueTObject; kNoContextMenu enum valueTObject; kNotDeleted enum valueTObject; kObjInCanvas enum valueTObject; kOnlyPrepStep enum valueTObjectprotected; kOverwrite enum valueTObject; kSingleKey enum valueTObject; kWriteDelete enum valueTObject; kZombie enum valueTObject; LoadClass(const char *classname, const char *libname, Bool_t check=kFALSE)TROOT; LoadClass(const char *name, Bool_t silent=kFALSE) constTROOT; LoadMacro(const char *filename, Int_t *error=nullptr, Bool_t check=kFALSE)TROOT; ls(Option_t *option="""") const overrideTROOTvirtual; Macro(const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE)TROOT; MakeDefCanvas() constTROOT; MakeZombie()TObjectinlineprotected; MayNotUse(const char *method) constTObject; Message(Int_t id, const TObject *obj)TROOT; mkdir(const char *name, const char *title="""", Bool_t returnExistingDirectory=kFALSE)TDirectoryvirtual; MustClean() constTROOTinline; Notify()TObjectvirtual; Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constTObject; OpenFile(const char *, Option_t *="""", const char *="""", Int_t=1, Int_t=0)TDirectoryinlinevirtual; operator delete(void *ptr)TObject; operator delete(void *ptr, void *vp)TObject; operator delete[](void *ptr)TObject; operator delete[](void *ptr, voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT-members.html:12732,Load,LoadClass,12732,doc/master/classTROOT-members.html,https://root.cern,https://root.cern/doc/master/classTROOT-members.html,1,['Load'],['LoadClass']
Performance,"sMapString += classHeaders.first + ""\"""";; 3392 for (auto const & header : classHeaders.second) {; 3393 headerName = (detectedUmbrella == header || payLoadOnly) ? ""payloadCode"" : ""\"""" + header + ""\"""";; 3394 headersClassesMapString += "", "" + headerName;; 3395 if (genreflex::verbose); 3396 std::cout << "", "" << headerName;; 3397 if (payLoadOnly); 3398 break;; 3399 }; 3400 if (genreflex::verbose); 3401 std::cout << std::endl;; 3402 headersClassesMapString += "", \""@\"",\n"";; 3403 }; 3404 headersClassesMapString += ""nullptr"";; 3405 return headersClassesMapString;; 3406}; 3407 ; 3408////////////////////////////////////////////////////////////////////////////////; 3409 ; 3410bool IsImplementationName(const std::string &filename); 3411{; 3412 return !ROOT::TMetaUtils::IsHeaderName(filename);; 3413}; 3414 ; 3415////////////////////////////////////////////////////////////////////////////////; 3416/// Check if the argument is a sane cling argument. Performing the following checks:; 3417/// 1) It does not start with ""--"" and is not the --param option.; 3418 ; 3419bool IsCorrectClingArgument(const std::string& argument); 3420{; 3421 if (ROOT::TMetaUtils::BeginsWith(argument,""--"") && !ROOT::TMetaUtils::BeginsWith(argument,""--param"")) return false;; 3422 return true;; 3423}; 3424 ; 3425////////////////////////////////////////////////////////////////////////////////; 3426bool NeedsSelection(const char* name); 3427{; 3428 static const std::vector<std::string> namePrfxes {; 3429 ""array<"",; 3430 ""unique_ptr<""};; 3431 auto pos = find_if(namePrfxes.begin(),; 3432 namePrfxes.end(),; 3433 [&](const std::string& str){return ROOT::TMetaUtils::BeginsWith(name,str);});; 3434 return namePrfxes.end() == pos;; 3435}; 3436 ; 3437////////////////////////////////////////////////////////////////////////////////; 3438 ; 3439bool IsSupportedClassName(const char* name); 3440{; 3441 static const std::vector<std::string> uclNamePrfxes {; 3442 ""chrono:"",; 3443 ""ratio<"",; 3444 ""shared_ptr<""};; 3445 static con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:135780,Perform,Performing,135780,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['Perform'],['Performing']
Performance,"sMembertrue if we proxy an unsplit data member; Bool_tfIsaPointertrue if we proxy a data member of pointer type; TTree*fLastTreeTTree containing the last entry read; Int_tfMemberOffset; Int_tfOffsetOffset inside the object; ROOT::TBranchProxy*fParentProxy to a parent object; Long64_tfReadLast entry read; void*fWherememory location of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchProxy(); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name = 0); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name, const char* membername); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, ROOT::TBranchProxy* parent, const char* membername, const char* top = 0, const char* name = 0); Constructor. ~TBranchProxy(); Typical Destructor. void Reset(); Completely reset the object. void Print(); Display the content of the object. Bool_t Setup(); Initialize/cache the necessary information. TBranchProxy(). TBranchProxy* GetProxy(); { return this; }. Bool_t IsInitialized(). Bool_t IsaPointer() const. Bool_t Read(). Bool_t ReadEntries(). TClass * GetClass(). void* GetWhere() const; { return fWhere; }. TVirtualCollectionProxy * GetCollection(); { return fCollection; }. void * GetStart(UInt_t = 0); protected:. void * GetClaStart(UInt_t i = 0); return the address of the start of the object being proxied. Assumes; that Setup() has been called. Assumes the object containing this data; member is held in TClonesArray. void * GetStlStart(UInt_t i = 0); return the address of the start of the object being proxied. Assumes; that Setup() has been called. Assumes the object containing this data; member is held in STL Collection. Int_t GetOffset(); { return fOffset; }. » Author: Philippe Canal 01/06/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-03-10 17:12; This page has ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__TBranchProxy.html:3070,cache,cache,3070,root/html534/ROOT__TBranchProxy.html,https://root.cern,https://root.cern/root/html534/ROOT__TBranchProxy.html,1,['cache'],['cache']
Performance,"sMembertrue if we proxy an unsplit data member; Bool_tfIsaPointertrue if we proxy a data member of pointer type; TTree*fLastTreeTTree containing the last entry read; Int_tfMemberOffset; Int_tfOffsetOffset inside the object; ROOT::TBranchProxy*fParentProxy to a parent object; Long64_tfReadLast entry read; void*fWherememory location of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchProxy(); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name = 0); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name, const char* membername); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, ROOT::TBranchProxy* parent, const char* membername, const char* top = 0, const char* name = 0); Constructor. ~TBranchProxy(); Typical Destructor. void Reset(); Completely reset the object. void Print(); Display the content of the object. Bool_t Setup(); Initialize/cache the necessary information. TBranchProxy(). TBranchProxy* GetProxy(); { return this; }. Bool_t IsInitialized(). Bool_t IsaPointer() const. Bool_t Read(). Bool_t ReadEntries(). TClass * GetClass(). void* GetWhere() const; { return fWhere; }. TVirtualCollectionProxy * GetCollection(); { return fCollection; }. void * GetStart(UInt_t = 0); protected:. void * GetClaStart(UInt_t i = 0); return the address of the start of the object being proxied. Assumes; that Setup() has been called. Assumes the object containing this data; member is held in TClonesArray. void * GetStlStart(UInt_t i = 0); return the address of the start of the object being proxied. Assumes; that Setup() has been called. Assumes the object containing this data; member is held in STL Collection. Int_t GetOffset(); { return fOffset; }. » Author: Philippe Canal 01/06/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id: TBranchProxy.h 36449 2010-10-28 20:52:17Z pcanal $",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__TBranchProxy.html:3070,cache,cache,3070,root/html528/ROOT__TBranchProxy.html,https://root.cern,https://root.cern/root/html528/ROOT__TBranchProxy.html,2,['cache'],['cache']
Performance,"sMembertrue if we proxy an unsplit data member; Bool_tfIsaPointertrue if we proxy a data member of pointer type; TTree*fLastTreeTTree containing the last entry read; Int_tfMemberOffset; Int_tfOffsetOffset inside the object; ROOT::TBranchProxy*fParentProxy to a parent object; Long64_tfReadLast entry read; void*fWherememory location of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchProxy(); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name = 0); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name, const char* membername); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, ROOT::TBranchProxy* parent, const char* membername, const char* top = 0, const char* name = 0); Constructor. ~TBranchProxy(); Typical Destructor. void Reset(); Completely reset the object. void Print(); Display the content of the object. Bool_t Setup(); Initialize/cache the necessary information. TBranchProxy(). TBranchProxy* GetProxy(); { return this; }. Bool_t IsInitialized(). Bool_t IsaPointer() const. Bool_t Read(). Bool_t ReadEntries(). TClass * GetClass(). void* GetWhere() const; { return fWhere; }. TVirtualCollectionProxy * GetCollection(); { return fCollection; }. void * GetStart(UInt_t = 0); protected:. void * GetClaStart(UInt_t i = 0); return the address of the start of the object being proxied. Assumes; that Setup() has been called. Assumes the object containing this data; member is held in TClonesArray. void * GetStlStart(UInt_t i = 0); return the address of the start of the object being proxied. Assumes; that Setup() has been called. Assumes the object containing this data; member is held in STL Collection. Int_t GetOffset(); { return fOffset; }. » Author: Philippe Canal 01/06/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id: TBranchProxy.h 41244 2011-10-06 19:42:35Z pcanal $",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__TBranchProxy.html:3070,cache,cache,3070,root/html532/ROOT__TBranchProxy.html,https://root.cern,https://root.cern/root/html532/ROOT__TBranchProxy.html,1,['cache'],['cache']
Performance,"sMembertrue if we proxy an unsplit data member; Bool_tfIsaPointertrue if we proxy a data member of pointer type; TTree*fLastTreeTTree containing the last entry read; Int_tfMemberOffset; Int_tfOffsetOffset inside the object; ROOT::TBranchProxy*fParentProxy to a parent object; Long64_tfReadLast entry read; void*fWherememory location of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchProxy(); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name = 0); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name, const char* membername); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, ROOT::TBranchProxy* parent, const char* membername, const char* top = 0, const char* name = 0); Constructor. ~TBranchProxy(); Typical Destructor. void Reset(); Completely reset the object. void Print(); Display the content of the object. Bool_t Setup(); Initialize/cache the necessary information. TBranchProxy(). TBranchProxy* GetProxy(); { return this; }. Bool_t IsInitialized(). Bool_t IsaPointer() const. Bool_t Read(). Bool_t ReadEntries(). TClass * GetClass(). void* GetWhere() const; { return fWhere; }. TVirtualCollectionProxy * GetCollection(); { return fCollection; }. void * GetStart(UInt_t = 0); protected:. void * GetClaStart(UInt_t i = 0); return the address of the start of the object being proxied. Assumes; that Setup() has been called. Assumes the object containing this data; member is held in TClonesArray. void * GetStlStart(UInt_t i = 0); return the address of the start of the object being proxied. Assumes; that Setup() has been called. Assumes the object containing this data; member is held in TClonesArray. » Author: Philippe Canal 01/06/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id: TBranchProxy.h 27129 2009-01-13 08:22:29Z pcanal $ » Last generated: 2009-12-07 13:44; This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__TBranchProxy.html:3052,cache,cache,3052,root/html526/ROOT__TBranchProxy.html,https://root.cern,https://root.cern/root/html526/ROOT__TBranchProxy.html,1,['cache'],['cache']
Performance,sMirror. TGaxis* TRatioPlot::fLowerGXaxisMirror = nullptr. protected . Lower mirror of the x axis. ; Definition at line 116 of file TRatioPlot.h. ◆ fLowerGYaxis. TGaxis* TRatioPlot::fLowerGYaxis = nullptr. protected . Lower graphical y axis. ; Definition at line 114 of file TRatioPlot.h. ◆ fLowerGYaxisMirror. TGaxis* TRatioPlot::fLowerGYaxisMirror = nullptr. protected . Lower mirror of the y axis. ; Definition at line 118 of file TRatioPlot.h. ◆ fLowerPad. TPad* TRatioPlot::fLowerPad = nullptr. protected . The pad which contains the calculated lower plot part. ; Definition at line 76 of file TRatioPlot.h. ◆ fLowTopMargin. Float_t TRatioPlot::fLowTopMargin = 0.05. protected . Stores the top margin of the lower pad. ; Definition at line 132 of file TRatioPlot.h. ◆ fLowYaxis. TAxis* TRatioPlot::fLowYaxis = nullptr. protected . Clone of the lower y axis. ; Definition at line 121 of file TRatioPlot.h. ◆ fMode. Int_t TRatioPlot::fMode = 0. protected . Stores which calculation is supposed to be performed as specified by user option. ; Definition at line 84 of file TRatioPlot.h. ◆ fOption. TString TRatioPlot::fOption. protected . Stores the option which is given in the constructor as a string. ; Definition at line 86 of file TRatioPlot.h. ◆ fParentPad. TVirtualPad* TRatioPlot::fParentPad = nullptr. protected . Stores the pad the ratio plot was created in. ; Definition at line 74 of file TRatioPlot.h. ◆ fRatioGraph. TGraph* TRatioPlot::fRatioGraph = nullptr. protected . Stores the lower plot's graph. ; Definition at line 94 of file TRatioPlot.h. ◆ fRightMargin. Float_t TRatioPlot::fRightMargin = 0.1. protected . Stores the common right margin of both pads. ; Definition at line 136 of file TRatioPlot.h. ◆ fSharedXAxis. TAxis* TRatioPlot::fSharedXAxis = nullptr. protected . X axis that stores the range for both plots. ; Definition at line 110 of file TRatioPlot.h. ◆ fShowConfidenceIntervals. Bool_t TRatioPlot::fShowConfidenceIntervals = kTRUE. protected . Stores whether to sho,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRatioPlot.html:49963,perform,performed,49963,doc/master/classTRatioPlot.html,https://root.cern,https://root.cern/doc/master/classTRatioPlot.html,1,['perform'],['performed']
Performance,"sMoment;  CRooAbsNumGenerator;  CRooAbsOptTestStatistic;  ►CRooAbsPdfRooAbsPdf is the abstract interface for all probability density functions The class provides hybrid analytical/numerical normalization for its implementations, error tracing and a MC generator interface ;  CCacheElemNormalization set with for above integral ;  CGenSpec;  CRooAbsProxy;  ►CRooAbsRealRooAbsReal is the common abstract base class for objects that represent a real value and implements functionality common to all real-valued objects such as the ability to plot them, to construct integrals of them, the ability to advertise (partial) analytical integrals etc ;  CEvalError;  CPlotOpt;  CRooAbsRealLValue;  CRooAbsRootFinder;  CRooAbsSelfCachedPdf;  CRooAbsSelfCachedReal;  CRooAbsString;  CRooAbsStudy;  CRooAbsTestStatistic;  CRooAcceptReject;  CRooAdaptiveGaussKronrodIntegrator1D;  CRooAdaptiveIntegratorND;  CRooAddGenContext;  ►CRooAddition;  CCacheElemIterator over set ;  ►CRooAddModel;  CCacheElemTransiet cache with transformed values of coefficients ;  CIntCacheElem;  ►CRooAddPdf;  CCacheElemTransiet cache with transformed values of coefficients ;  CRooAICRegistry;  CRooArgList;  CRooArgProxy;  CRooArgSet;  CRooArgusBGRooArgusBG is a RooAbsPdf implementation describing the ARGUS background shape ;  CRooBCPEffDecayPDF describing decay time distribution of B meson including effects of standard model CP violation ;  CRooBCPGenDecay;  CRooBDecay;  CRooBernstein;  CRooBifurGauss;  CRooBinIntegrator;  CRooBinnedGenContext;  CRooBinning;  CRooBinningCategory;  CRooBlindTools;  CRooBMixDecay;  CRooBreitWigner;  CRooBrentRootFinder;  CRooBukinPdf;  CRooCachedPdf;  CRooCachedReal;  CRooCacheManager;  CRooCategory;  CRooCategoryProxy;  CRooCategorySharedProperties;  CRooCatType;  CRooCBShape;  CRooCFunction1Binding;  CRooCFunction1Map;  CRooCFunction1PdfBinding;  CRooCFunction1Ref;  CRooCFunction2Binding;  CRooCFunction2Map;  CRooCFunction2PdfBinding;  CRooCFunction2Ref;  CRooCFunction3Binding;  CRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:81178,cache,cache,81178,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['cache'],['cache']
Performance,"sName); 337{; 338 return TClass::GetClass(className);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Return the current Process-ID.; 343 ; 344TProcessID *TBuffer::ReadProcessID(UShort_t pidf); 345{; 346 if (!pidf) return TProcessID::GetPID(); //may happen when cloning an object; 347 return nullptr;; 348}; 349 ; 350////////////////////////////////////////////////////////////////////////////////; 351/// Always return 0 (current processID).; 352 ; 353UShort_t TBuffer::WriteProcessID(TProcessID *); 354{; 355 return 0;; 356}; 357 ; 358////////////////////////////////////////////////////////////////////////////////; 359/// Push a new data cache area onto the list of area to be used for; 360/// temporarily store 'missing' data members.; 361 ; 362void TBuffer::PushDataCache(TVirtualArray *obj); 363{; 364 fCacheStack.push_back(obj);; 365}; 366 ; 367////////////////////////////////////////////////////////////////////////////////; 368/// Return the 'current' data cache area from the list of area to be used for; 369/// temporarily store 'missing' data members.; 370 ; 371TVirtualArray *TBuffer::PeekDataCache() const; 372{; 373 if (fCacheStack.empty()) return nullptr;; 374 return fCacheStack.back();; 375}; 376 ; 377////////////////////////////////////////////////////////////////////////////////; 378/// Pop and Return the 'current' data cache area from the list of area to be used for; 379/// temporarily store 'missing' data members.; 380 ; 381TVirtualArray *TBuffer::PopDataCache(); 382{; 383 TVirtualArray *val = PeekDataCache();; 384 fCacheStack.pop_back();; 385 return val;; 386}; 387 ; 388////////////////////////////////////////////////////////////////////////////////; 389/// Byte-swap N primitive-elements in the buffer.; 390/// Bulk API relies on this function.; 391 ; 392Bool_t TBuffer::ByteSwapBuffer(Long64_t n, EDataType type); 393{; 394 char *input_buf = GetCurrent();; 395 if ((type == EDataType::kShort_t) || (type == ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8cxx_source.html:12236,cache,cache,12236,doc/master/TBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html,1,['cache'],['cache']
Performance,"sPdf Class ReferenceRooFit » RooFit. ; Two-dimensional kernel estimation PDF. ; This function has been superseded by the more general RooNDKeysPdf. ; Definition at line 25 of file Roo2DKeysPdf.h. Public Member Functions;  Roo2DKeysPdf (const char *name, const char *title, RooAbsReal &xx, RooAbsReal &yy, RooDataSet &data, TString options=""a"", double widthScaleFactor=1.0);  Constructor. ;  ;  Roo2DKeysPdf (const Roo2DKeysPdf &other, const char *name=nullptr);  Copy constructor. ;  ;  ~Roo2DKeysPdf () override;  Destructor. ;  ; Int_t calculateBandWidth (Int_t kernel=-999);  Calculates the kernel bandwidth for x & y and the probability look up table _p[i][j]. ;  ; TObject * clone (const char *newname) const override;  ; double evaluate () const override;  Evaluates the kernel estimation for x,y, interpolating between the points if necessary. ;  ; Int_t getBandWidthType () const;  ; double getMean (const char *axis) const;  ; void getOptions (void) const;  ; double getSigma (const char *axis) const;  ; TClass * IsA () const override;  ; Int_t loadDataSet (RooDataSet &data, TString options);  Loads a new data set into the class instance. ;  ; void PrintInfo (std::ostream &) const;  Prints out _p[_nPoints][_nPoints] indicating the domain limits. ;  ; void setOptions (TString options);  ; void setWidthScaleFactor (double widthScaleFactor);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeHistToFile (char *outputFile, const char *histName) const;  Plots the PDF as a histogram and saves it to a file, so that it can be loaded in as a Roo2DHist PDF in the future to save on calculation time. ;  ; void writeNTupleToFile (char *outputFile, const char *name) const;  Saves the data and calculated bandwidths to a file, as a record of what produced the PDF and to give a reduced data set in order to facilitate re-calculation in the future. ;  ; void writeToFile (char *outputFile, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRoo2DKeysPdf.html:1359,load,loadDataSet,1359,doc/master/classRoo2DKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRoo2DKeysPdf.html,2,"['Load', 'load']","['Loads', 'loadDataSet']"
Performance,"sPdf.cxx. ◆ getSigma(). double Roo2DKeysPdf::getSigma ; (; const char * ; axis); const. Definition at line 493 of file Roo2DKeysPdf.cxx. ◆ highBoundaryCorrection(). double Roo2DKeysPdf::highBoundaryCorrection ; (; double ; thisVar, . double ; thisH, . double ; high, . double ; tVar . ); const. private . Apply the mirror at boundary correction to a dimension given the space position to evaluate at (thisVar), the bandwidth at this position (thisH), the boundary (high/low) and the value of the data kernel that this correction is being applied to tVar (i.e. ; the _x[ix] etc.). Parameters. [in]thisVar; [in]thisH; [in]high; [in]tVar. Definition at line 414 of file Roo2DKeysPdf.cxx. ◆ IsA(). TClass * Roo2DKeysPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 121 of file Roo2DKeysPdf.h. ◆ loadDataSet(). Int_t Roo2DKeysPdf::loadDataSet ; (; RooDataSet & ; data, . TString ; options . ). Loads a new data set into the class instance. ; Returns 1 in case of error, 0 otherwise. Parameters. [in]data; [in]options. Definition at line 131 of file Roo2DKeysPdf.cxx. ◆ lowBoundaryCorrection(). double Roo2DKeysPdf::lowBoundaryCorrection ; (; double ; thisVar, . double ; thisH, . double ; low, . double ; tVar . ); const. private . Definition at line 426 of file Roo2DKeysPdf.cxx. ◆ PrintInfo(). void Roo2DKeysPdf::PrintInfo ; (; std::ostream & ; out); const. Prints out _p[_nPoints][_nPoints] indicating the domain limits. ; Parameters. [out]outOutput stream where to print . Definition at line 610 of file Roo2DKeysPdf.cxx. ◆ setOptions(). void Roo2DKeysPdf::setOptions ; (; TString ; options). Definition at line 226 of file Roo2DKeysPdf.cxx. ◆ setWidthScaleFactor(). void Roo2DKeysPdf::setWidthScaleFactor ; (; double ; widthScaleFactor). inline . Definition at line 124 of file Roo2DKeysPdf.h. ◆ Streamer(). void Roo2DKeysPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRoo2DKeysPdf.html:80540,Load,Loads,80540,doc/master/classRoo2DKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRoo2DKeysPdf.html,1,['Load'],['Loads']
Performance,"sPdf::CacheElem Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; RooAbsPdf::CacheElem Class Reference. ; Normalization set with for above integral. ; Definition at line 322 of file RooAbsPdf.h. Public Member Functions;  CacheElem (RooAbsReal &norm);  ;  ~CacheElem () override;  Destructor of normalization cache element. ;  ; RooArgList containedArgs (Action) override;  ;  Public Member Functions inherited from RooAbsCacheElement;  RooAbsCacheElement ();  ; virtual ~RooAbsCacheElement ();  ; virtual void findConstantNodes (const RooArgSet &obs, RooArgSet &cacheList, RooLinkedList &processedNodes);  Interface for constant term optimization calls. ;  ; virtual TClass * IsA () const;  ; virtual void operModeHook (RooAbsArg::OperMode);  Interface for changes of operation mode. ;  ; virtual void optimizeCacheMode (const RooArgSet &obs, RooArgSet &optNodes, RooLinkedList &processedNodes);  Interface for cache optimization calls. ;  ; virtual void printCompactTreeHook (std::ostream &, const char *, Int_t curElem, Int_t totElem);  Hook function to print cache guts in tree printing mode of RooAbsArgs. ;  ; virtual bool redirectServersHook (const RooAbsCollection &, bool, bool, bool);  Interface for server redirect calls. ;  ; void setOwner (RooAbsArg *owner);  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Public Attributes; std::unique_ptr< RooAbsReal > _norm;  . Additional Inherited Members;  Public Types inherited from RooAbsCacheElement; enum  Action { OperModeChange; , OptimizeCaching; , FindConstantNodes; };  ;  Static Public Member Functions inherited from RooAbsCacheElement; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Protected Attributes inherited from RooAbsCac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf_1_1CacheElem.html:956,optimiz,optimizeCacheMode,956,doc/master/classRooAbsPdf_1_1CacheElem.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf_1_1CacheElem.html,3,"['cache', 'optimiz']","['cache', 'optimization', 'optimizeCacheMode']"
Performance,"sPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDecay.html:40535,cache,cache,40535,root/html526/RooDecay.html,https://root.cern,https://root.cern/root/html526/RooDecay.html,2,['cache'],['cache']
Performance,"sPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normIntMgrThe integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealSumPdf.html:39575,cache,cache,39575,root/html526/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html526/RooRealSumPdf.html,2,['cache'],['cache']
Performance,"sPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:41558,cache,cache,41558,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,2,['cache'],['cache']
Performance,"sPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyk; RooRealProxym0; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooLognormal.html:39377,cache,cache,39377,root/html528/RooLognormal.html,https://root.cern,https://root.cern/root/html528/RooLognormal.html,2,['cache'],['cache']
Performance,"sPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/Roo2DKeysPdf.html:40719,cache,cache,40719,root/html530/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html530/Roo2DKeysPdf.html,20,['cache'],['cache']
Performance,"sPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxysigma; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGaussian.html:39978,cache,cache,39978,root/html532/RooGaussian.html,https://root.cern,https://root.cern/root/html532/RooGaussian.html,4,['cache'],['cache']
Performance,"sPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxywidth; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBreitWigner.html:40106,cache,cache,40106,root/html532/RooBreitWigner.html,https://root.cern,https://root.cern/root/html532/RooBreitWigner.html,2,['cache'],['cache']
Performance,"sPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,double,unsigned int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction3PdfBinding_double_unsigned_int_double_unsigned_int_.html:39099,cache,cache,39099,root/html526/RooCFunction3PdfBinding_double_unsigned_int_double_unsigned_int_.html,https://root.cern,https://root.cern/root/html526/RooCFunction3PdfBinding_double_unsigned_int_double_unsigned_int_.html,4,['cache'],['cache']
Performance,"sPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,unsigned int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction3PdfBinding_double_unsigned_int_unsigned_int_double_.html:39099,cache,cache,39099,root/html526/RooCFunction3PdfBinding_double_unsigned_int_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html526/RooCFunction3PdfBinding_double_unsigned_int_unsigned_int_double_.html,4,['cache'],['cache']
Performance,"sPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,int>funcFunction pointer reference; RooRealProxyxArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction1PdfBinding_double_int_.html:40234,cache,cache,40234,root/html532/RooCFunction1PdfBinding_double_int_.html,https://root.cern,https://root.cern/root/html532/RooCFunction1PdfBinding_double_int_.html,2,['cache'],['cache']
Performance,"sPdf; extendedTerm(double sumEntries, RooArgSet const *nset, double sumEntriesW2=0.0, bool doOffset=false) constRooAbsPdf; extendedTerm(RooAbsData const &data, bool weightSquared, bool doOffset=false) constRooAbsPdf; extendMode() constRooAbsPdfinlinevirtual; ExtendMode enum nameRooAbsPdf; Fatal(const char *method, const char *msgfmt,...) constTObjectvirtual; fBitsTObjectprivate; fgDtorOnlyTObjectprivatestatic; fgObjectStatTObjectprivatestatic; FillBuffer(char *&buffer)TNamedvirtual; fillDataHist(RooDataHist *hist, const RooArgSet *nset, double scaleFactor, bool correctForBinVolume=false, bool showProgress=false) constRooAbsReal; fillHistogram(TH1 *hist, const RooArgList &plotVars, double scaleFactor=1, const RooArgSet *projectedVars=nullptr, bool scaling=true, const RooArgSet *condObs=nullptr, bool setError=true) constRooAbsReal; fillTreeBranch(TTree &t) overrideRooAbsRealprotectedvirtual; findConstantNodes(const RooArgSet &observables, RooArgSet &cacheList)RooAbsArg; findConstantNodes(const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes)RooAbsArg; findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constRooAbsRealprotected; findNewServer(const RooAbsCollection &newSet, bool nameChange) constRooAbsArg; FindObject(const char *name) constTObjectvirtual; FindObject(const TObject *obj) constTObjectvirtual; findRoot(RooRealVar &x, double xmin, double xmax, double yval)RooAbsReal; findServer(const char *name) constRooAbsArginline; findServer(const RooAbsArg &arg) constRooAbsArginline; findServer(Int_t index) constRooAbsArginline; fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)RooAbsPdfinline; fitToImpl(RooAbsData &data, const RooLinkedList &cmdList)RooAbsPdfprotectedvirtual; fixAddCoefNormalization(const RooArgSet &addNormSet=RooArgSet(), bool force=true)RooAbsRealvirtual; fixAddCoefRange(const char *rangeName=nullptr, bool force=true)RooAbsRealvirtual; fNameTNamedprotected; forceAnalyticalInt(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf-members.html:14266,cache,cacheList,14266,doc/master/classRooAbsPdf-members.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf-members.html,2,['cache'],['cacheList']
Performance,"sReal ;  ; RooRealProxy _func;  Input function. ;  ; RooSetProxy _nset;  Normalization set (optional) ;  ; Int_t _order = 1;  Derivation order. ;  ; std::unique_ptr< ROOT::Math::RichardsonDerivator > _rd;  ! Derivator ;  ; RooRealProxy _x;  Observable. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDerivative.html:55835,Cache,Cache,55835,doc/master/classRooDerivative.html,https://root.cern,https://root.cern/doc/master/classRooDerivative.html,1,['Cache'],['Cache']
Performance,"sReal.; Definition at line 310 of file RooGExpModel.cxx. ◆ generateEvent(). void RooGExpModel::generateEvent ; (; Int_t ; code). overridevirtual . Interface for generation of an event using the algorithm corresponding to the specified code. ; The meaning of each code is defined by the getGenerator() implementation. The default implementation does nothing. ; Reimplemented from RooAbsPdf.; Definition at line 944 of file RooGExpModel.cxx. ◆ getAnalyticalIntegral(). Int_t RooGExpModel::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 648 of file RooGExpModel.cxx. ◆ getGenerator(). Int_t RooGExpModel::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ; A code of zero indicates that we cannot generate any of the directVars (in this case, nothing should be added to generatedVars). Any non-zero codes will be passed to our generateEvent() implementation, but otherwise its value is arbitrary. The default implementation of this method returns zero. Subclasses will usually implement this method using the matchArgs() methods to advertise the algorithms they provide. ; Reimplemented from RooAbsPdf.; Definition at line 936 of file RooGExpModel.cxx. ◆ IsA(). TClass * RooGExpModel::IsA ; (; ); const. inlineov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGExpModel.html:86501,perform,performed,86501,doc/master/classRooGExpModel.html,https://root.cern,https://root.cern/doc/master/classRooGExpModel.html,1,['perform'],['performed']
Performance,"sReal::EvalErrorIterRooAbsReal::evalErrorIter(); static Bool_tRooAbsReal::evalErrorLoggingEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsCachedReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsSelfCachedReal.html:10908,cache,cacheList,10908,root/html526/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsSelfCachedReal.html,4,['cache'],['cacheList']
Performance,"sReal::EvalErrorIterRooAbsReal::evalErrorIter(); static Bool_tRooAbsReal::evalErrorLoggingEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooAbsReal&RooAbsOptTestStatistic::function(); const RooAbsReal&R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChi2Var.html:12448,cache,cacheList,12448,root/html526/RooChi2Var.html,https://root.cern,https://root.cern/root/html526/RooChi2Var.html,4,['cache'],['cacheList']
Performance,"sReal::EvalErrorIterRooAbsReal::evalErrorIter(); static Bool_tRooAbsReal::evalErrorLoggingEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooAbsReal&function(); const RooAbsReal&function() const; RooFunc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:11352,cache,cacheList,11352,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,1,['cache'],['cacheList']
Performance,"sReal::EvalErrorIterRooAbsReal::evalErrorIter(); static Bool_tRooAbsReal::evalErrorLoggingEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsHiddenReal.html:10538,cache,cacheList,10538,root/html526/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html526/RooAbsHiddenReal.html,44,['cache'],['cacheList']
Performance,"sReal::EvalErrorIterRooAbsReal::evalErrorIter(); static Bool_tRooAbsReal::evalErrorLoggingEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooPlot*RooAbsRealLValue::frame() const; RooPlot*RooAbsRealLValue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooLinearVar.html:12292,cache,cacheList,12292,root/html526/RooLinearVar.html,https://root.cern,https://root.cern/root/html526/RooLinearVar.html,1,['cache'],['cacheList']
Performance,"sReal::EvalErrorIterRooAbsReal::evalErrorIter(); static Bool_tRooAbsReal::evalErrorLoggingEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooPlot*frame() const; RooPlot*frame(const RooLinkedList& cmdList",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsRealLValue.html:11860,cache,cacheList,11860,root/html526/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsRealLValue.html,1,['cache'],['cacheList']
Performance,"sReal::EvalErrorIterRooAbsReal::evalErrorIter(); static Bool_tRooAbsReal::evalErrorLoggingEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); TString*format(const RooCmdArg& formatArg) const; TString*format(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealVar.html:11867,cache,cacheList,11867,root/html526/RooRealVar.html,https://root.cern,https://root.cern/root/html526/RooRealVar.html,1,['cache'],['cacheList']
Performance,"sReal::EvalErrorIterRooAbsReal::evalErrorIter(); static Bool_tRooAbsReal::evalErrorLoggingEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tforceAnalyticalInt(const RooAbsArg& dep) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProduct.html:10315,cache,cacheList,10315,root/html526/RooProduct.html,https://root.cern,https://root.cern/root/html526/RooProduct.html,1,['cache'],['cacheList']
Performance,"sReal::EvalErrorIterRooAbsReal::evalErrorIter(); static Bool_tRooAbsReal::evalErrorLoggingEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:11011,cache,cacheList,11011,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,1,['cache'],['cacheList']
Performance,"sReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooArgSet*_curNormSet! Current normalization set; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; TVectorD*_mref; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMomentMorph.html:42500,cache,cache,42500,root/html602/RooMomentMorph.html,https://root.cern,https://root.cern/root/html602/RooMomentMorph.html,6,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"sReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; const ROOT::Math::IBaseFunctionOneDim*funcFunctor; RooRealProxyvarArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFunctor1DBinding.html:33353,cache,cache,33353,root/html532/RooFunctor1DBinding.html,https://root.cern,https://root.cern/root/html532/RooFunctor1DBinding.html,1,['cache'],['cache']
Performance,"sReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooRealProxy_offsetOffset of transformation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooRealProxy_slopeSlope of transformation; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooRealProxy_varInput observable; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinearVar(const char* name, const char* title, RooAbsRealLValue& variable, const RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooLinearVar.html:39641,cache,cache,39641,root/html534/RooLinearVar.html,https://root.cern,https://root.cern/root/html534/RooLinearVar.html,2,['cache'],['cache']
Performance,"sReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealIntegral(). RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); Construct integral of 'function' over observables in 'depList'; in range 'rangeName' with normalization observables 'funcNormSet'; (for p.d.f.s). In the integral is performed to the maximum extent; possible the internal (analytical) integrals advertised by function.; The other integrations are performed numerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealIntegral.html:39280,perform,performed,39280,root/html602/RooRealIntegral.html,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html,2,['perform'],['performed']
Performance,"sReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TApplication::EStatusBitsTApplication::kProcessRemotely; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPyROOTApplication(const char* acn, Int_t* argc, char** argv, Bool_t bLoadLibs = kTRUE); Create a TApplication derived for use with interactive ROOT from python. A; set of standard, often used libs is loaded if bLoadLibs is true (default). Bool_t CreatePyROOTApplication(Bool_t bLoadLibs = kTRUE); Create a TPyROOTApplication. Returns false if gApplication is not null. Bool_t InitROOTGlobals(); Setup the basic ROOT globals gBenchmark, gStyle, gProgname, if not already; set. Always returns true. Bool_t InitROOTMessageCallback(); Install ROOT message handler which will turn ROOT error message into; python exceptions. Always returns true. void dummy(); {}. TPyROOTApplication(const char* acn, Int_t* argc, char** argv, Bool_t bLoadLibs = kTRUE); { }. » Last changed: Tue Jun 2 15:18:22 2015 » Last generated: 2015-06-02 15:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/PyROOT__TPyROOTApplication.html:14152,load,loaded,14152,root/html604/PyROOT__TPyROOTApplication.html,https://root.cern,https://root.cern/root/html604/PyROOT__TPyROOTApplication.html,1,['load'],['loaded']
Performance,"sSaved status of all classes.Definition TROOT.cxx:1096; TROOT::GetTTFFontDirstatic const TString & GetTTFFontDir()Get the fonts directory in the installation. Static utility function.Definition TROOT.cxx:3189; TROOT::GetGitBranchconst char * GetGitBranch() constDefinition TROOT.h:224; TROOT::fForceStyleBool_t fForceStyleForce setting of current style when reading objects.Definition TROOT.h:133; TROOT::FromPopUpBool_t FromPopUp() constDefinition TROOT.h:207; TROOT::GetSelectedPrimitiveconst TObject * GetSelectedPrimitive() constDefinition TROOT.h:270; TROOT::MakeDefCanvasTCanvas * MakeDefCanvas() constReturn a default canvas.Definition TROOT.cxx:1554; TROOT::fTypesTCollection * fTypesList of data types definition.Definition TROOT.h:141; TROOT::GetColorTColor * GetColor(Int_t color) constReturn address of color with index color.Definition TROOT.cxx:1536; TROOT::IsLineProcessingBool_t IsLineProcessing() constDefinition TROOT.h:284; TROOT::GetGlobalTGlobal * GetGlobal(const char *name, Bool_t load=kFALSE) constReturn pointer to global variable by name.Definition TROOT.cxx:1631; TROOT::FindSTLClassTClass * FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constreturn a TClass object corresponding to 'name' assuming it is an STL container.Definition TROOT.cxx:1484; TROOT::fStreamerInfoTSeqCollection * fStreamerInfoList of active StreamerInfo classes.Definition TROOT.h:159; TROOT::Appendvoid Append(TObject *obj, Bool_t replace=kFALSE) overrideAppend object to this directory.Definition TROOT.cxx:1047; TROOT::GetIconPathstatic const TString & GetIconPath()Get the icon path in the installation. Static utility function.Definition TROOT.cxx:3168; TROOT::GetListOfCanvasesTSeqCollection * GetListOfCanvases() constDefinition TROOT.h:240; TROOT::AListOfEnums_tstd::atomic< TListOfEnums * > AListOfEnums_tDefinition TROOT.h:109; TROOT::GetListOfGlobalFunctionsTCollection * GetListOfGlobalFunctions(Bool_t load=kFALSE)Return list containing the TFunctions currently defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:34004,load,load,34004,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,1,['load'],['load']
Performance,"sSaved status of all classes.Definition TROOT.cxx:1096; TROOT::GetTTFFontDirstatic const TString & GetTTFFontDir()Get the fonts directory in the installation. Static utility function.Definition TROOT.cxx:3193; TROOT::GetGitBranchconst char * GetGitBranch() constDefinition TROOT.h:224; TROOT::fForceStyleBool_t fForceStyleForce setting of current style when reading objects.Definition TROOT.h:133; TROOT::FromPopUpBool_t FromPopUp() constDefinition TROOT.h:207; TROOT::GetSelectedPrimitiveconst TObject * GetSelectedPrimitive() constDefinition TROOT.h:270; TROOT::MakeDefCanvasTCanvas * MakeDefCanvas() constReturn a default canvas.Definition TROOT.cxx:1554; TROOT::fTypesTCollection * fTypesList of data types definition.Definition TROOT.h:141; TROOT::GetColorTColor * GetColor(Int_t color) constReturn address of color with index color.Definition TROOT.cxx:1536; TROOT::IsLineProcessingBool_t IsLineProcessing() constDefinition TROOT.h:284; TROOT::GetGlobalTGlobal * GetGlobal(const char *name, Bool_t load=kFALSE) constReturn pointer to global variable by name.Definition TROOT.cxx:1631; TROOT::FindSTLClassTClass * FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constreturn a TClass object corresponding to 'name' assuming it is an STL container.Definition TROOT.cxx:1484; TROOT::fStreamerInfoTSeqCollection * fStreamerInfoList of active StreamerInfo classes.Definition TROOT.h:159; TROOT::Appendvoid Append(TObject *obj, Bool_t replace=kFALSE) overrideAppend object to this directory.Definition TROOT.cxx:1047; TROOT::GetIconPathstatic const TString & GetIconPath()Get the icon path in the installation. Static utility function.Definition TROOT.cxx:3172; TROOT::GetListOfCanvasesTSeqCollection * GetListOfCanvases() constDefinition TROOT.h:240; TROOT::AListOfEnums_tstd::atomic< TListOfEnums * > AListOfEnums_tDefinition TROOT.h:109; TROOT::GetListOfGlobalFunctionsTCollection * GetListOfGlobalFunctions(Bool_t load=kFALSE)Return list containing the TFunctions currently defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:34003,load,load,34003,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,1,['load'],['load']
Performance,"sShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooAbsData *dset;  ;  R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooArgSet *depList;  ;  R__DEPRECATED (6, 36, ""Use checkObservables()."") inline bool checkDependents(const RooArgSet *nset) const;  ;  R__DEPRECATED (6, 36, ""Use recursiveCheckObservables()."") inline bool recursiveCheckDependents(const RooArgSet *nset) const;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:40187,cache,cache,40187,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['cache'],['cache']
Performance,"sTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fBinData! binary data, assigned with http call; Long_tfBinDataLength! length of binary data; TConditionfCond! condition used to wait for processing; TStringfContent! text content (if any); TStringfContentType! type of content; TStringfFileName! file name; TStringfHeader! response header like ContentEncoding, Cache-Control and so on; TStringfMethod! request method like GET or POST; TStringfPathName! item path; void*fPostData! binary data received with post request; Long_tfPostDataLength! length of binary data; TStringfQuery! additional arguments; TStringfRequestHeader! complete header, provided with request; TStringfTopName! top item name; TStringfUserName! authenticated user name (if any); Int_tfZipping! indicate if content should be zipped. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THttpCallArg(); constructor. ~THttpCallArg(); destructor. TString AccessHeader(TString& buf, const char* name, const char* value = 0, Bool_t doing_set = kFALSE); method used to get or set http header in the string buffer; Header has following format:; field1 : value1\r\n; field2 : value2\r\n; Such format corresponds to header format in HTTP requests. TString CountHeader(const TString& buf, Int_t number = -1111) const; method used to counter number of headers or returns name of specified header. void SetPostData(void* data, L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THttpCallArg.html:7671,Cache,Cache-Control,7671,root/html604/THttpCallArg.html,https://root.cern,https://root.cern/root/html604/THttpCallArg.html,1,['Cache'],['Cache-Control']
Performance,"sTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static RooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; static RooAbsData::StorageTypeRooAbsData::defaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files); TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeData(); Constructors, factory methods etc. {}. const TTree * GetTree() const; { return _tree; }. » Last changed: Tue Jun 2 13:14:49 2015 » Last generated: 2015-06-02 13:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTreeData.html:16511,cache,cached,16511,root/html602/RooTreeData.html,https://root.cern,https://root.cern/root/html602/RooTreeData.html,2,['cache'],['cached']
Performance,"sTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static RooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; static RooAbsData::StorageTypeRooAbsData::defaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files); TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeData(); Constructors, factory methods etc. {}. const TTree * GetTree() const; { return _tree; }. » Last changed: Tue Jun 2 15:36:15 2015 » Last generated: 2015-06-02 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooTreeData.html:16511,cache,cached,16511,root/html604/RooTreeData.html,https://root.cern,https://root.cern/root/html604/RooTreeData.html,2,['cache'],['cached']
Performance,sTObject::kMustCleanup; static RooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; RooArgSetRooAbsDataStore::_cachedVars; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSetRooAbsDataStore::_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooVectorDataStore*_cache! Optimization cache; RooAbsArg*_cacheOwner! Cache owner; vector<RooVectorDataStore::CatVector*>_catStoreList; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; RooVectorDataStore::CatVector**_firstCat! do not persist; RooVectorDataStore::RealVector**_firstReal! do not persist; RooVectorDataStore::RealFullVector**_firstRealF! do not persist; Bool_t_forcedUpdate! Request for forced cache upd,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooVectorDataStore.html:11322,cache,cached,11322,root/html602/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html602/RooVectorDataStore.html,4,"['cache', 'load']","['cached', 'loading']"
Performance,sTestStatistic::_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_optimized!; RooAbsData*RooAbsOptTestStatistic::_origDataOriginal data; RooAbsReal*RooAbsOptTestStatistic::_origFuncOriginal function; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsA,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooXYChi2Var.html:42587,cache,cache,42587,root/html602/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html602/RooXYChi2Var.html,2,['cache'],['cache']
Performance,"sThe number of distinct computation graphs that have been processed; This function triggers the event loop of all computation graphs which relate to the given RResultHandles. The advantage compared to running the event loop implicitly by accessing the RResultPtr is that the event loops will run concurrently. Therefore, the overall computation of all results is generally more efficient. It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; ROOT::RDataFrame df1(""tree1"", ""file1.root"");; auto r1 = df1.Histo1D(""var1"");; ; ROOT::RDataFrame df2(""tree2"", ""file2.root"");; auto r2 = df2.Sum(""var2"");; ; // RResultPtr -> RResultHandle conversion is automatic; ROOT::RDF::RunGraphs({r1, r2});; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66. Definition at line 66 of file RDFHelpers.cxx. ◆ SaveGraph() [1/2]. template<typename NodeType > . std::string ROOT::RDF::SaveGraph ; (; NodeType ; node). Create a graphviz representation of the dataframe computation graph, return it as a string. ; Parameters. [in]nodeany node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to. The output can be displayed with a command akin to dot -Tpng output.dot > output.png && open output.png.; Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are effectively optimized away from the computation graph.; Note that SaveGraph is not thread-safe and must not be called concurrently from different threads. ; Definition at line 120 of file RDFHelpers.hxx. ◆ SaveGraph() [2/2]. template<typename NodeType > . void ROOT::RDF::Sav",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1RDF.html:14655,concurren,concurrently,14655,doc/master/namespaceROOT_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1RDF.html,2,['concurren'],['concurrently']
Performance,"sU1IntervalOverlappingByMinMax(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); static voidLoadMacro(const char* mac); static voidMacro(const char* mac); TEveUtil&operator=(const TEveUtil&); static voidSetColorBrightness(Float_t value, Bool_t full_redraw = kFALSE); static voidSetupEnvironment(); static voidSetupGUI(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. static TObjArray*fgDefaultColors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupEnvironment(); Setup Include and Macro paths.; Since inclusion into ROOT this does nothing but could; potentially be reactivated if some common macros are established; and shipped with binary ROOT (in macros/eve). For example, these; might be used to spawn specific GUI / GL configurations. void SetupGUI(); Setup icon pictures and mime-types. Bool_t CheckMacro(const char* mac); Checks if macro 'mac' is loaded. void AssertMacro(const char* mac); Load and execute macro 'mac' if it has not been loaded yet. void Macro(const char* mac); Execute macro 'mac'. Do not reload the macro. void LoadMacro(const char* mac); Makes sure that macro 'mac' is loaded, but do not reload it. void ColorFromIdx(Color_t ci, UChar_t* col, Bool_t alpha = kTRUE); Fill col with RGBA values corresponding to index ci. If alpha; is true, set alpha component of col to 255.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Color_t ci, UChar_t* col, Char_t transparency); Fill col with RGBA values corresponding to index ci and transparency.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2, UChar_t* col, Bool_t alpha = kTRUE); Fill col with weighted RGBA values corresponding to; color-indices c1 and c2. If alpha is true, set alpha component; of col to 255. Color_t* FindColorVar(TObject* obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveUtil.html:2299,load,loaded,2299,root/html534/TEveUtil.html,https://root.cern,https://root.cern/root/html534/TEveUtil.html,1,['load'],['loaded']
Performance,"sWithLock, TListOfFunctions, TListOfFunctionTemplates, and TSelectorList.; Definition at line 95 of file THashList.cxx. ◆ AddLast() [2/2]. void THashList::AddLast ; (; TObject * ; obj, . Option_t * ; opt . ). overridevirtual . Add object at the end of the list and also store option. ; Storing an option is useful when one wants to change the behaviour of an object a little without having to create a complete new copy of the object. This feature is used, for example, by the Draw() method. It allows the same object to be drawn in different ways. ; Reimplemented from TList.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, and TSelectorList.; Definition at line 110 of file THashList.cxx. ◆ AverageCollisions(). Float_t THashList::AverageCollisions ; (; ); const. Return the average collision rate. ; The higher the number the longer the linked lists in the hashtable, the slower the lookup. If the number is high, or lookup noticeably too slow, perform a Rehash(). ; Definition at line 178 of file THashList.cxx. ◆ Class(). static TClass * THashList::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * THashList::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t THashList::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 72 of file THashList.h. ◆ Clear(). void THashList::Clear ; (; Option_t * ; option = """"). overridevirtual . Remove all objects from the list. ; Does not delete the objects unless the THashList is the owner (set via SetOwner()). ; Implements TCollection.; Reimplemented in TListOfEnums, TListOfEnumsWithLock, TListOfDataMembers, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 189 of file THashList.cxx. ◆ DeclFileName(). static const char * THashList::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declara",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:27766,perform,perform,27766,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['perform'],['perform']
Performance,s[fBNb]; Long64_t*TFileCacheRead::fBSeek[fBNseek]; Int_t*TFileCacheRead::fBSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:19067,cache,cached,19067,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,2,['cache'],['cached']
Performance,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Types; using CacheElem = FuncCacheElem;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; virtual RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const =0;  ; virtual RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const =0;  ; virtual const char * binningName () const;  ; TString cacheNameSuffix (const RooArgSet &nset) const;  Construct unique suffix name for cache p.d.f object. ;  ; virtual FuncCacheElem * createCache (const RooArgSet *nset) const;  Interface function to create an internal cache object that represent each cached function configuration. ;  ; virtual void fillCacheObject (FuncCacheElem &cache) const =0;  ; FuncCacheElem * getCache (const RooArgSet *nset) const;  Retrieve cache corresponding to observables in nset. ;  ; virtual const char * inputBaseName () const =0;  ; virtual const char * payloadUniqueSuffix () const;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedReal.html:48687,Cache,CacheElem,48687,doc/master/classRooAbsCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedReal.html,1,['Cache'],['CacheElem']
Performance,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Private Attributes; bool _divideByBinWidth {false};  ; RooTemplateProxy< const RooHistFunc > _histFunc;  . Static Private Attributes; static bool _enabled = true;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinWidthFunction.html:48828,Cache,CacheMode,48828,doc/master/classRooBinWidthFunction.html,https://root.cern,https://root.cern/doc/master/classRooBinWidthFunction.html,1,['Cache'],['CacheMode']
Performance,"sa;; 763/// ia++;; 764/// ib++;; 765/// if (ia > na) {ok = kTRUE; break;}; 766/// if (ib > nb) {ok = kTRUE; break;}; 767/// }; 768/// rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; 769/// }; 770/// ~~~; 771///; 772/// For the last case, a=b, the algorithm advances each array by one index in an; 773/// attempt to move through the equality. However, this is incorrect when one or; 774/// the other of a or b (or both) have a repeated value, call it x. For the KS; 775/// statistic to be computed properly, rdiff needs to be calculated after all of; 776/// the a and b at x have been tallied (this is due to the definition of the; 777/// empirical distribution function; another way to convince yourself that the; 778/// old CERNLIB method is wrong is that it implies that the function defined as the; 779/// difference between a and b is multi-valued at x -- besides being ugly, this; 780/// would invalidate Kolmogorov's theorem).; 781///; 782/// The solution is to just add while-loops into the equality-case handling to; 783/// perform the tally:; 784///; 785/// ~~~ {.cpp}; 786/// } else {; 787/// double x = a[ia-1];; 788/// while(a[ia-1] == x && ia <= na) {; 789/// rdiff -= sa;; 790/// ia++;; 791/// }; 792/// while(b[ib-1] == x && ib <= nb) {; 793/// rdiff += sb;; 794/// ib++;; 795/// }; 796/// if (ia > na) {ok = kTRUE; break;}; 797/// if (ib > nb) {ok = kTRUE; break;}; 798/// }; 799/// ~~~; 800///; 801/// ### Note:; 802/// A good description of the Kolmogorov test can be seen at:; 803/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; 804 ; 805Double_t TMath::KolmogorovTest(Int_t na, const Double_t *a, Int_t nb, const Double_t *b, Option_t *option); 806{; 807// LM: Nov 2010: clean up and returns now a zero distance when vectors are the same; 808 ; 809 TString opt = option;; 810 opt.ToUpper();; 811 ; 812 Double_t prob = -1;; 813// Require at least two points in each graph; 814 if (!a || !b || na <= 2 || nb <= 2) {; 815 Error(""KolmogorovTest"",""Sets must have more ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:26229,perform,perform,26229,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['perform'],['perform']
Performance,"sage logger; TMVA::MethodBase *constfMethodThe MVA method to be evaluated; TH1D*fMvaBkgMVA distrituion for bakgr. events, used for spline fit; TH1D*fMvaBkgFineBinMVA distrituion for bakgr. events; TH1D*fMvaSigMVA distrituion for signal events, used for spline fit; TH1D*fMvaSigFineBinMVA distrituion for signal events; TStringfOptimizationFitTypewhich type of optimisation procedure to be used ; map<TString,TMVA::Interval>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distribu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__OptimizeConfigParameters.html:2940,optimiz,optimize,2940,root/html530/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html530/TMVA__OptimizeConfigParameters.html,2,['optimiz'],['optimize']
Performance,"sage logger; TMVA::MethodBase *constfMethodThe MVA method to be evaluated; TH1D*fMvaBkgMVA distrituion for bakgr. events, used for spline fit; TH1D*fMvaBkgFineBinMVA distrituion for bakgr. events; TH1D*fMvaSigMVA distrituion for signal events, used for spline fit; TH1D*fMvaSigFineBinMVA distrituion for signal events; TStringfOptimizationFitTypewhich type of optimisation procedure to be used ; map<TString,TMVA::Interval>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__OptimizeConfigParameters.html:2780,optimiz,optimize,2780,root/html528/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html528/TMVA__OptimizeConfigParameters.html,1,['optimiz'],['optimize']
Performance,"saging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsOptTestStatistic.html:38341,optimiz,optimizations,38341,root/html532/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsOptTestStatistic.html,2,['optimiz'],['optimizations']
Performance,"same object to be drawn in different ways. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a enum just by name or create it if its not already in the list. TObject* FindObject(const TObject* obj) const. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. TIterator* MakeIterator(Bool_t dir = kIterForward) const. TObject* At(Int_t idx) const. TObject* After(const TObject* obj) const. TObject* Before(const TObject* obj) const. TObject* First() const. TObjLink* FirstLink() const. TObject** GetObjectRef(const TObject* obj) const. TObject* Last() const. TObjLink* LastLink() const. Int_t GetLas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfEnumsWithLock.html:13136,load,loaded,13136,root/html602/TListOfEnumsWithLock.html,https://root.cern,https://root.cern/root/html602/TListOfEnumsWithLock.html,2,['load'],['loaded']
Performance,"same we could do by hand, but with a lot less effort.; This produces code that is type safe, but does have different drawbacks:. Templates make code harder to read.; At the time of writing this documentation, some compilers can be very slow when dealing with templates.; It does not solve the problem when a container has to hold a heterogeneous set of objects.; The system can end up generating a great deal of code; each container/object combination has its own code, a phenomenon that is sometimes referred to as code bloat.; The Standard Template Library (STL) is part on ANSI C++, and includes a set of template containers. 17 Physics Vectors; The physics vector classes describe vectors in three and four dimensions and their rotation algorithms. The classes were ported to root from CLHEP see:; http://www.cern.ch/clhep/manual/UserGuide/Vector/vector.html; 17.1 The Physics Vector Classes; In order to use the physics vector classes you will have to load the Physics library:; gSystem.Load(""libPhysics.so"");; There are four classes in this package. They are:; TVector3 is a general three-vector. A TVector3 may be expressed in Cartesian, polar, or cylindrical coordinates. Methods include dot and cross products, unit vectors and magnitudes, angles between vectors, and rotations and boosts. There are also functions of particular use to HEP, like pseudo-rapidity, projections, and transverse part of a TVector3, and kinetic methods on 4-vectors such as Invariant Mass of pairs or containers of particles.; TLorentzVector is a general four-vector class, which can be used either for the description of position and time (x, y, z, t) or momentum and energy (px, py, pz, E). TRotation is a class describing a rotation of a TVector3 object. TLorentzRotation is a class to describe the Lorentz transformations including Lorentz boosts and rotations. In addition, a TVector2 is a basic implementation of a vector in two dimensions and is not part of the CLHEP translation.; 17.2 TVector3. TVector3 i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:857919,Load,Load,857919,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Load'],['Load']
Performance,sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0193 sec ; Factory : Test method: DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.12216 0.20255 [ -1.0614 1.0246 ]; : myvar2: -0.12333 0.30492 [ -1.2280 0.99911 ]; : var3: 0.097148 0.21347 [ -1.0158 0.99984 ]; : var4: 0.17495 0.23851 [ -1.2661 1.0694 ]; : -----------------------------------------------------------; DNN_CPU : [dataset] : Evaluation of DNN_CPU on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.333 sec ; Factory : Test method: SVM for Classification performance; : ; SVM : [dataset] : Evaluation of SVM on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.287 sec ; Factory : Test method: BDT for Classification performance; : ; BDT : [dataset] : Evaluation of BDT on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.571 sec ; Factory : Test method: RuleFit for Classification performance; : ; RuleFit : [dataset] : Evaluation of RuleFit on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0137 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: Cuts; : ; <WARNING> : You have asked for histogram MVA_EFF_BvsS which does not seem to exist in *Results* .. better don't use it ; <WARNING> : You have asked for histogram EFF_BVSS_TR which does not seem to exist in *Results* .. better don't use it ; TFHandler_Cuts : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.21781 1.7248 [ -9.8605 7.9024 ]; : myvar2: -0.062175 1.1106 [ -4.0854 4.0259 ]; : var3: 0.16451 1.0589 [ -5.3563 4.6422 ]; : var4: 0.43566 1.2253 [ -6.9675 5.0307 ]; : -----------------------------------------------------------; Factory : Evalu,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:68225,perform,performance,68225,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['performance']
Performance,"scale is true (default), the corresponding; scaling gets calculated from the current window size. Bool_t SavePictureScale(const TString& fileName, Float_t scale, Bool_t pixel_object_scale = kTRUE); Save picture with given scale to current window size.; If pixel_object_scale is true (default), the same scaling is; used. void DrawGuides(); Draw reference marker and coordinate axes. void DrawDebugInfo(); If in debug mode draw camera aids and overall bounding box. void PreDraw(); Perform GL work which must be done before each draw. void PostDraw(); Perform GL work which must be done after each draw. void FadeView(Float_t alpha); Draw a rectangle (background color and given alpha) across the; whole viewport. void MakeCurrent() const; Make GL context current. void SwapBuffers() const; Swap GL buffers. Bool_t RequestSelect(Int_t x, Int_t y); Post request for selection render pass viewer, picking objects; around the window point (x,y). Bool_t DoSelect(Int_t x, Int_t y); Perform GL selection, picking objects overlapping WINDOW; area described by 'rect'. Return kTRUE if selection should be; changed, kFALSE otherwise.; Select lock should already been taken in other thread in; TGLViewer::ReqSelect(). Bool_t RequestSecondarySelect(Int_t x, Int_t y); Request secondary select. Bool_t DoSecondarySelect(Int_t x, Int_t y); Secondary selection. void ApplySelection(); Process result from last selection (in fSelRec) and; extract a new current selection from it.; Here we only use physical shape. Bool_t RequestOverlaySelect(Int_t x, Int_t y); Post request for secondary selection rendering of selected object; around the window point (x,y). Bool_t DoOverlaySelect(Int_t x, Int_t y); Perform GL selection, picking overlay objects only.; Return TRUE if the selected overlay-element has changed. void AutoFade(Float_t fade, Float_t time = 1, Int_t steps = 10); Animate fading from curernt value to fade over given time (sec); and number of steps. void UseDarkColorSet(); Use the dark color-set. void U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLViewer.html:27646,Perform,Perform,27646,root/html528/TGLViewer.html,https://root.cern,https://root.cern/root/html528/TGLViewer.html,6,['Perform'],['Perform']
Performance,"scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualViewer3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t operation); virtual Int_tAddObject(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualViewer3D.html:10290,cache,cache,10290,root/html528/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html528/TVirtualViewer3D.html,6,['cache'],['cache']
Performance,"sconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 2387/// If file is null the existing write cache is deleted.; 2388 ; 2389void TFile::SetCacheWrite(TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;; 2393}; 2394 ; 2395////////////////////////////////////////////////////////////////////////////////; 2396/// Return the size in bytes of the file header.; 2397 ; 2398Int_t TFile::Sizeof() const; 2399{; 2400 return 0;; 2401}; 2402 ; 2403////////////////////////////////////////////////////////////////////////////////; 2404/// Stream a TFile object.; 2405 ; 2406void TFile::Streamer(TB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:84384,cache,cache,84384,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,4,"['Cache', 'cache']","['Cache', 'cache']"
Performance,"screte) The binning used for the FFT sampling is controlled by the binning named ""cache"" in the convolution observable convVar. If such a binning is not set, the same number of bins as for convVar will be used. ; [in]pdfConvVarIf the variable used for convolution is a PDF, itself, pass the PDF here, and pass the convolution variable to convVar. See also rf210_angularconv.C in the roofit tutorials . Definition at line 248 of file RooFFTConvPdf.cxx. ◆ RooFFTConvPdf() [4/4]. RooFFTConvPdf::RooFFTConvPdf ; (; const RooFFTConvPdf & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 272 of file RooFFTConvPdf.cxx. ◆ ~RooFFTConvPdf(). RooFFTConvPdf::~RooFFTConvPdf ; (; ). override . Destructor. ; Definition at line 292 of file RooFFTConvPdf.cxx. Member Function Documentation. ◆ actualObservables(). RooFit::OwningPtr< RooArgSet > RooFFTConvPdf::actualObservables ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Return the observables to be cached given the normalization set nset. ; If the cache observable is in nset then this is; the convolution observable plus; any member of nset that is either a RooCategory,; or was previously specified through setCacheObservables(). In case the cache observable is not in nset, then it is; the convolution observable plus; all member of nset that are observables of this p.d.f. . Implements RooAbsCachedPdf.; Definition at line 778 of file RooFFTConvPdf.cxx. ◆ actualParameters(). RooFit::OwningPtr< RooArgSet > RooFFTConvPdf::actualParameters ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Return the parameters on which the cache depends given normalization set nset. ; For this p.d.f these are the parameters of the input p.d.f. but never the convolution variable, in case it is not part of nset. ; Implements RooAbsCachedPdf.; Definition at line 833 of file RooFFTConvPdf.cxx. ◆ bufferFraction(). double RooFFTConvPdf::bufferFraction ; (; ); const. inline . Return value of buffer ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:87042,cache,cached,87042,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cached']
Performance,"scribes ntrack to be written as a 16-bit integer (rather than a 32-bit integer).; ""ntrack/I2""; With this Branch method, you can also add a leaf that holds an entire array of variables. To add an array of floats use the f[n] notation when describing the leaf.; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; You can also add an array of variable length:; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; See “Example 2: A Tree with a C Structure” below ($ROOTSYS/tutorials/tree/tree2.C) and staff.C at the beginning of this chapter.; 12.10 Adding a TBranch to Hold an Object; To write a branch to hold an event object, we need to load the definition of the Event class, which is in $ROOTSYS/test/libEvent.so (if it doesn’t exist type make in $ROOTSYS/test). An object can be saved in a tree if a ROOT dictionary for its class has been generated and loaded.; root[] .L libEvent.so; First, we need to open a file and create a tree.; root[] TFile *f = new TFile(""AFile.root"",""RECREATE""); root[] TTree *tree = new TTree(""T"",""A Root Tree""); We need to create a pointer to an Event object that will be used as a reference in the TTree::Branch method. Then we create a branch with the TTree::Branch method.; root[] Event *event = new Event(); root[] tree->Branch(""EventBranch"",""Event"",&event,32000,99); To add a branch to hold an object we use the signature above. The first parameter is the name of the branch. The second parameter is the name of the class of the object to be stored. The third parameter is the address of a pointer to the object to be stored.; Note that it is an address of a pointer to the object, not just a pointer to the object.; The fourth parameter is the buffer size and is by default 32000 bytes. It is the number of bytes of data for that branch to save to a buffer until it is saved to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:541457,load,loaded,541457,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance,"scribinb the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. THashTable * GetClassShortTypedefHash(); Return the class' names massaged with TClassEdit::ShortType with kDropStlDefault. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. VoidFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. VoidFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:27234,load,load,27234,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,4,['load'],['load']
Performance,"scribing current object ; Reimplemented from TMVA::MethodBase.; Definition at line 165 of file MethodSVM.h. ◆ MakeClassSpecific(). void TMVA::MethodSVM::MakeClassSpecific ; (; std::ostream & ; fout, . const TString & ; className . ); const. protectedvirtual . write specific classifier response ; Reimplemented from TMVA::MethodBase.; Definition at line 635 of file MethodSVM.cxx. ◆ MakeKernelList(). std::vector< TMVA::SVKernelFunction::EKernelType > TMVA::MethodSVM::MakeKernelList ; (; std::string ; multiKernels, . TString ; kernel . ). MakeKernelList Function providing string manipulation for product or sum of kernels functions to take list of kernels specified in the booking of the method and provide a vector of SV kernels to iterate over in SVKernelFunction. ; Example:; ""KernelList=RBF*Polynomial"" would use a product of the RBF and Polynomial kernels. ; Definition at line 1054 of file MethodSVM.cxx. ◆ OptimizeTuningParameters(). std::map< TString, Double_t > TMVA::MethodSVM::OptimizeTuningParameters ; (; TString ; fomType = ""ROCIntegral"", . TString ; fitType = ""Minuit"" . ). virtual . Optimize Tuning Parameters This is used to optimise the kernel function parameters and cost. ; All kernel parameters are optimised by default with default ranges, however the parameters to be optimised can be set when booking the method with the option Tune.; Example:; ""Tune=Gamma[0.01;1.0;100]"" would only tune the RBF Gamma between 0.01 and 1.0 with 100 steps. ; Reimplemented from TMVA::MethodBase.; Definition at line 760 of file MethodSVM.cxx. ◆ ProcessOptions(). void TMVA::MethodSVM::ProcessOptions ; (; ). privatevirtual . option post processing (if necessary) ; Implements TMVA::MethodBase.; Definition at line 268 of file MethodSVM.cxx. ◆ ReadWeightsFromStream() [1/4]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; std::istream & ; ). virtual . Implements TMVA::MethodBase. ◆ ReadWeightsFromStream() [2/4]. void TMVA::MethodSVM::ReadWeightsFromStream ; (; std::istream & ; i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodSVM.html:35712,Optimiz,OptimizeTuningParameters,35712,doc/master/classTMVA_1_1MethodSVM.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodSVM.html,1,['Optimiz'],['OptimizeTuningParameters']
Performance,"scribing the data member corresponding to the Decl 'id'.; The skipChecks flag controls the consistency checks performed inspecting; the AST. In some cases, we explicitely alter the datamembers in the; typesystem with respect to the AST and therefore we must not enforce; consistency. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of data members and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Streamer(TBuffer& ); Stream an object of class TListOfDataMembers. void Update(TDictionary* member); Move the member or data member to the expect set of list. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TDictionary* member); Mark 'func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfDataMembers(const TListOfDataMembers& ). TListOfDataMembers& operator=(const TListOfDataMembers& ). Bool_t IsLoaded() const; { return fIsLoaded; }. TClass * GetClass() const; { return fClass; }. void SetClass(TClass* cl); { fClass = cl; }. » Author: Philippe Canal Aug 2013 » Copyright (C) 1995-2013, Rene Brun and Fons Rademaker",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfDataMembers.html:14994,Load,Load,14994,root/html604/TListOfDataMembers.html,https://root.cern,https://root.cern/root/html604/TListOfDataMembers.html,2,['Load'],['Load']
Performance,"scribing the data member corresponding to the Decl 'id'.; The skipChecks flag controls the consistency checks performed inspecting; the AST. In some cases, we explicitely alter the datamembers in the; typesystem with respect to the AST and therefore we must not enforce; consistency. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of data members and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Streamer(TBuffer& ); Stream an object of class TListOfDataMembers. void Update(TDictionary* member); Move the member or data member to the expect set of list. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TDictionary* member); Mark 'func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfDataMembers(const TListOfDataMembers& ). TListOfDataMembers& operator=(const TListOfDataMembers& ). Bool_t IsLoaded() const; { return fIsLoaded; }. void SetClass(TClass* cl); { fClass = cl; }. » Author: Philippe Canal Aug 2013 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last generate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfDataMembers.html:14735,Load,Load,14735,root/html602/TListOfDataMembers.html,https://root.cern,https://root.cern/root/html602/TListOfDataMembers.html,2,['Load'],['Load']
Performance,"scribing the enum corresponding to the Decl 'id'. ; Definition at line 205 of file TListOfEnums.cxx. ◆ GetClass(). TClass * TListOfEnums::GetClass ; (; ); const. inlineprotected . Definition at line 62 of file TListOfEnums.h. ◆ GetIds(). TExMap * TListOfEnums::GetIds ; (; ). inlineprotected . Definition at line 63 of file TListOfEnums.h. ◆ GetObject(). TEnum * TListOfEnums::GetObject ; (; const char * ; name); const. virtual . Return an object from the list of enums if and only if is has already been loaded in the list. ; This is an internal routine. ; Reimplemented in TListOfEnumsWithLock.; Definition at line 268 of file TListOfEnums.cxx. ◆ IsA(). TClass * TListOfEnums::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from THashList.; Reimplemented in TListOfEnumsWithLock.; Definition at line 95 of file TListOfEnums.h. ◆ IsLoaded(). Bool_t TListOfEnums::IsLoaded ; (; ); const. inline . Definition at line 80 of file TListOfEnums.h. ◆ Load(). void TListOfEnums::Load ; (; ). private . Load all the DataMembers known to the interpreter for the scope 'fClass' into this collection. ; Definition at line 337 of file TListOfEnums.cxx. ◆ MapObject(). void TListOfEnums::MapObject ; (; TObject * ; obj). private . Add pair<id, object> to the map of functions and their ids. ; Definition at line 56 of file TListOfEnums.cxx. ◆ operator=(). TListOfEnums & TListOfEnums::operator= ; (; const TListOfEnums & ; ). privatedelete . ◆ RecursiveRemove(). void TListOfEnums::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; This function overrides TCollection::RecursiveRemove that calls the Remove function. THashList::Remove cannot be called because it uses the hash value of the hash table. This hash value is not available anymore when RecursiveRemove is called from the TObject destructor. ; Reimplemented from THashList.; Reim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnums.html:30137,Load,Load,30137,doc/master/classTListOfEnums.html,https://root.cern,https://root.cern/doc/master/classTListOfEnums.html,1,['Load'],['Load']
Performance,"scription of TEveWindowSlot ;  CTEveWindowTabEncapsulates TGTab into an eve-window ;  CTExecTExec is a utility class that can be used to execute a C++ command when some event happens in a pad ;  ►CTExMapThis class stores a (key,value) pair using an external hash ;  CAssoc_t;  CTExMapIter;  CTF11-Dim function class ;  CTF12A projection of a TF2 along X or Y ;  CTF1ConvolutionClass wrapping convolution of two functions ;  CTF1Editor;  CTF1NormSumClass adding two functions: c1*f1+c2*f2 ;  CTF1ParametersTF1 Parameters class ;  CTF2A 2-Dim function with parameters ;  CTF2GLGL renderer for TF2 ;  CTF3A 3-Dim function with parameters ;  CTFastCgi;  CTFeldmanCousinsClass to calculate the CL upper limit using the Feldman-Cousins method as described in PRD V57 #7, p3873-3889 ;  CTFFTComplex;  CTFFTComplexReal;  CTFFTReal;  CTFFTRealComplex;  CTFileA ROOT file is a suite of consecutive data records (TKey instances) with a well defined format ;  CTFileCacheReadA cache when reading files over the network ;  CTFileCacheWriteA cache when writing files over the network ;  CTFileCollectionClass that contains a list of TFileInfo's and accumulated meta data information about its entries ;  CTFileDrawMapThis class is automatically called by TFile::DrawMap ;  CTFileHandler;  CTFileInfoClass describing a generic file including meta information ;  CTFileInfoMeta;  CTFileIter;  CTFileMergeInfo;  CTFileMergerThis class provides file copy and merging services ;  CTFileOpenHandleClass holding info about the file being opened ;  CTFilePrefetchThe prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a block of tree entries ;  CTFileSet;  CTFileStager;  ►CTFitEditor;  CFuncParamData_tTF1Convolution object ;  CTFitParametersDialog;  CTFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O ;  CTFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointer, i.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:135311,cache,cache,135311,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['cache'],['cache']
Performance,"scriptor;  ; struct  CudaConvolutionFwdAlgo;  ; struct  CudaDataType;  ; struct  CudaDropoutDescriptor;  ; struct  CudaEmptyDescriptor;  ; struct  CudaFilterDescriptor;  ; struct  CudaPoolingDescriptor;  ; struct  DummyConvolutionBwdDataAlgo;  ; struct  DummyConvolutionBwdFilterAlgo;  ; struct  DummyConvolutionDescriptor;  ; struct  DummyConvolutionFwdAlgo;  ; struct  DummyCudaDataType;  ; struct  DummyDataType;  ; struct  DummyDescriptor;  ; struct  DummyDropoutDescriptor;  ; struct  DummyEmptyDescriptor;  ; struct  DummyFilterDescriptor;  ; struct  DummyPoolingDescriptor;  ; class  Layer;  Layer defines the layout of a layer. More...;  ; class  LayerData;  LayerData holds the data of one layer. More...;  ; class  MeanVariance;  ; class  Net;  neural net More...;  ; class  Settings;  Settings for the training of the neural net. More...;  ; class  Steepest;  Steepest Gradient Descent algorithm (SGD) More...;  ; class  TAdadelta;  Adadelta Optimizer class. More...;  ; class  TAdagrad;  Adagrad Optimizer class. More...;  ; class  TAdam;  Adam Optimizer class. More...;  ; class  TBatch;  TBatch. More...;  ; class  TBatchIterator;  TBatchIterator. More...;  ; class  TBatchNormLayer;  Layer implementing Batch Normalization. More...;  ; class  TCpu;  The TCpu architecture class. More...;  ; class  TCpuBuffer;  TCpuBuffer. More...;  ; class  TCpuMatrix;  The TCpuMatrix class. More...;  ; class  TCpuTensor;  ; class  TCuda;  The TCuda architecture class. More...;  ; class  TCudaDeviceBuffer;  TCudaDeviceBuffer. More...;  ; class  TCudaDeviceReference;  TCudaDeviceReference. More...;  ; class  TCudaHostBuffer;  TCudaHostBuffer. More...;  ; class  TCudaMatrix;  TCudaMatrix Class. More...;  ; class  TCudaTensor;  TCudaTensor Class. More...;  ; class  TDataLoader;  TDataLoader. More...;  ; class  TDataLoader< AData, TReference< AReal > >;  ; class  TDeepNet;  Generic Deep Neural Network class. More...;  ; class  TDenseLayer;  Generic layer class. More...;  ; struct  TDescriptors",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html:1680,Optimiz,Optimizer,1680,doc/master/namespaceTMVA_1_1DNN.html,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html,2,['Optimiz'],['Optimizer']
Performance,"se = kFALSE, TString indent = """") const; Print fit result to stream 'os'. In Verbose mode, the contant parameters and; the initial and final values of the floating parameters are printed.; Standard mode only the final values of the floating parameters are printed. void fillCorrMatrix(const vector<double>& globalCC, const TMatrixDSym& corrs, const TMatrixDSym& covs); Function called by RooMinimizer. void fillLegacyCorrMatrix() const; Sanity check. void fillCorrMatrix(); Internal utility method to extract the correlation matrix and the; global correlation coefficients from the MINUIT memory buffer and; fill the internal arrays. Bool_t isIdentical(const RooFitResult& other, Double_t tol = 5e-5, Double_t tolCorr = 1e-4, Bool_t verbose = kTRUE) const; Return true if this fit result is identical to other within tolerance 'tol' on fitted values; and tolerance 'tolCor' on correlation coefficients. RooFitResult* lastMinuitFit(const RooArgList& varList = RooArgList()); Import the results of the last fit performed by gMinuit, interpreting; the fit parameters as the given varList of parameters. void setCovarianceMatrix(TMatrixDSym& V); Store externally provided correlation matrix in his RooFitResult ;. TH2* correlationHist(const char* name = ""correlation_matrix"") const; Return TH2D of correlation matrix. const TMatrixDSym& covarianceMatrix() const; Return covariance matrix. TMatrixDSym reducedCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix (Note that Vred _is_ a simple sub-matrix of V,; row/columns are ordered to matched the convention given in input argument 'params'. TMatrixDSym conditionalCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix, which is calculated as; ___ -1; Vred = V22 = V11 - V12 * V22 * V21. Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFitResult.html:14398,perform,performed,14398,root/html532/RooFitResult.html,https://root.cern,https://root.cern/root/html532/RooFitResult.html,2,['perform'],['performed']
Performance,"se = kFALSE, TString indent = """") const; Print fit result to stream 'os'. In Verbose mode, the contant parameters and; the initial and final values of the floating parameters are printed.; Standard mode only the final values of the floating parameters are printed. void fillCorrMatrix(const vector<double>& globalCC, const TMatrixDSym& corrs, const TMatrixDSym& covs); Function called by RooMinimizer. void fillLegacyCorrMatrix() const; Sanity check. void fillCorrMatrix(); Internal utility method to extract the correlation matrix and the; global correlation coefficients from the MINUIT memory buffer and; fill the internal arrays. Bool_t isIdentical(const RooFitResult& other, Double_t tol = 5e-5, Double_t tolCorr = 1e-4, Bool_t verbose = kTRUE) const; Return true if this fit result is identical to other within tolerance 'tol' on fitted values; and tolerance 'tolCor' on correlation coefficients. RooFitResult* lastMinuitFit(const RooArgList& varList = RooArgList()); Import the results of the last fit performed by gMinuit, interpreting; the fit parameters as the given varList of parameters. void setCovarianceMatrix(TMatrixDSym& V); Store externally provided correlation matrix in his RooFitResult ;. TH2* correlationHist(const char* name = ""correlation_matrix"") const; Return TH2D of correlation matrix. const TMatrixDSym& covarianceMatrix() const; Return covariance matrix. TMatrixDSym reducedCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix, which is calculated as; ___ -1; Vred = V22 = V11 - V12 * V22 * V21. Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; is the Shur complement of V22, calculated as shown above. (Note that Vred is _not_ a simple sub-matrix of V). const TMatrixDSym& correlationMatrix() const; Return correlation matrix ;. RooAbsPdf* createHessePdf(const RooArgSet& params) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFitResult.html:13878,perform,performed,13878,root/html526/RooFitResult.html,https://root.cern,https://root.cern/root/html526/RooFitResult.html,3,['perform'],['performed']
Performance,"se also __gnu_cxx:: ; Definition at line 3169 of file rootcling_impl.cxx. ◆ IsGoodLibraryName(). bool IsGoodLibraryName ; (; const std::string & ; name). Definition at line 5563 of file rootcling_impl.cxx. ◆ IsImplementationName(). bool IsImplementationName ; (; const std::string & ; filename). Definition at line 3410 of file rootcling_impl.cxx. ◆ IsLinkdefFile(). bool IsLinkdefFile ; (; const clang::PresumedLoc & ; PLoc). Definition at line 467 of file rootcling_impl.cxx. ◆ isPointerToPointer(). bool isPointerToPointer ; (; const clang::FieldDecl & ; m). Definition at line 1152 of file rootcling_impl.cxx. ◆ IsSelectionFile(). bool IsSelectionFile ; (; const char * ; filename). Definition at line 474 of file rootcling_impl.cxx. ◆ IsSelectionXml(). bool IsSelectionXml ; (; const char * ; filename). Definition at line 454 of file rootcling_impl.cxx. ◆ IsSupportedClassName(). bool IsSupportedClassName ; (; const char * ; name). Definition at line 3439 of file rootcling_impl.cxx. ◆ LoadLibraryMap(). void LoadLibraryMap ; (; const std::string & ; fileListName, . map< string, string > & ; autoloads . ). Fill the map of libraries to be loaded in presence of a class Transparently support the old and new rootmap file format. ; Definition at line 692 of file rootcling_impl.cxx. ◆ MaybeSuppressWin32CrashDialogs(). static void MaybeSuppressWin32CrashDialogs ; (; ). static . Definition at line 3675 of file rootcling_impl.cxx. ◆ ModuleContainsHeaders(). static bool ModuleContainsHeaders ; (; TModuleGenerator & ; modGen, . clang::HeaderSearch & ; headerSearch, . clang::Module * ; module, . std::vector< std::array< std::string, 2 > > & ; missingHeaders . ). static . Returns true iff a given module (and its submodules) contains all headers needed by the given ModuleGenerator. ; The names of all header files that are needed by the ModuleGenerator but are not in the given module will be inserted into the MissingHeader variable. Returns true iff the PCH was successfully generated. ; De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx.html:56059,Load,LoadLibraryMap,56059,doc/master/rootcling__impl_8cxx.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html,1,['Load'],['LoadLibraryMap']
Performance,"se class into the buffer. ;  ;  Public Member Functions inherited from TStreamerElement;  TStreamerElement ();  Default ctor. ;  ;  TStreamerElement (const char *name, const char *title, Int_t offset, Int_t dtype, const char *typeName);  Create a TStreamerElement object. ;  ; virtual ~TStreamerElement ();  TStreamerElement dtor. ;  ; virtual Bool_t CannotSplit () const;  Returns true if the element cannot be split, false otherwise. ;  ; Int_t GetArrayDim () const;  ; Int_t GetArrayLength () const;  ; TClass * GetClass () const;  ; virtual Int_t GetExecID () const;  Returns the TExec id for the EXEC instruction in the comment field of a TRef data member. ;  ; Double_t GetFactor () const;  ; virtual const char * GetFullName () const;  Return element name including dimensions, if any Note that this function stores the name into a static array. ;  ; Int_t GetMaxIndex (Int_t i) const;  ; TClass * GetNewClass () const;  ; Int_t GetNewType () const;  ; Int_t GetOffset () const;  ; void GetSequenceType (TString &type) const;  Fill type with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t HasCounter () const;  ; TClass * IsA () const override;  ; virtual Bool_t IsaPointer () const;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerBase.html:3142,cache,cached,3142,doc/master/classTStreamerBase.html,https://root.cern,https://root.cern/doc/master/classTStreamerBase.html,1,['cache'],['cached']
Performance,"se class of the object or a (non-static and non-transient) data member of the object. If the base class or data member is itself a class, then there will also be a streamerinfo object in the record for that class. In this way, each class is recursively decomposed into its atomic elements, each of which is a simple type (e.g. ""int""). A ""long"" or ""unsigned long"" member is always written as an 8 byte quantity, even if it occupies only 4 bytes in memory.; A data member of a class is marked transient on the line of its declaration by a comment beginning with ""//!"". Such members are not written to disk, nor is there any streamerinfo for such a member.; A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL) is written. If the declaration line has a comment beginning with ""//->"", this indicates that the pointer value will never be null, which allows a performance optimization. Another optimization is that if two or more pointers pointing to the same object are streamed in the same I/O operation, the object is written only once. The remaining pointers reference the object through a unique object identifier. This saves space and avoids the infinite loop that might otherwise arise if the directed graph of object instance pointer references contains a cycle.; If a data member is a pointer to a simple type, the Streamer presumes it is an array, with the dimension defined in a comment of the form ""//[<length>]"", where length is either an integer constant or a variable that is an integer data member of the class. If a variable is used, it must be defined ahead of its use or in a base class.; The above describes the function of the StreamerInfo record in decomposing a self-identifying object if the user uses the streamer generated by ""rootcint"". There are two reasons why a user may need",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootio.html:8544,perform,performance,8544,doc/master/rootio.html,https://root.cern,https://root.cern/doc/master/rootio.html,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"se of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:49784,load,loaded,49784,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,9,['load'],['loaded']
Performance,"se of the Student and F distributions ;  multidimSampling.C Example of sampling a multi-dim distribution using the DistSampler class NOTE: This tutorial must be run with ACLIC ;  normalDist.C Tutorial illustrating the new statistical distributions functions (pdf, cdf and quantile) ;  normalDist.py Tutorial illustrating the new statistical distributions functions (pdf, cdf and quantile) ;  permute.C Tutorial illustrating the use of TMath::Permute can be run with: ;  principal.C Principal Components Analysis (PCA) example ;  principal.py Principal Components Analysis (PCA) example ;  quantiles.C Demo for quantiles ;  quasirandom.C Example of generating quasi-random numbers ;  Rolke.C Example of the usage of the TRolke class The TRolke class computes the profile likelihood confidence limits for 7 different model assumptions on systematic/statistical uncertainties ;  testrandom.C Performance test of all the ROOT random generator (TRandom, TRandom1, TRandom2 and TRandom3) Tests the generator TRandom3 against some ref values and creates a timing table against TRandom, TRandom1 and TRandom2 ;  tStudent.C Example macro describing the student t distribution ;  tStudent.py Example macro describing the student t distribution ;  TSVDUnfoldExample.C Data unfolding using Singular Value Decomposition ;  vavilov.C Test of the TMath::Vavilov distribution ;  ► matrix;  invertMatrix.C This macro shows several ways to invert a matrix ;  solveLinear.C This macro shows several ways to perform a linear least-squares analysis ;  ► mc;  CompareMasses.CMacro to compare masses in ROOT data base to the values from pdg pdg ;  ► memstat;  memstatExample.CScript post-processing the file generated by TMemStat (default memstat.root) ;  ► mlp;  mlpHiggs.C Example of a Multi Layer Perceptron For a LEP search for invisible Higgs boson, a neural network was used to separate the signal from the background passing some selection cuts ;  mlpRegression.CThis macro shows the use of an ANN for regression ana",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:135132,Perform,Performance,135132,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,2,['Perform'],['Performance']
Performance,"se values can be changed; by SetNpx and SetNpy functions; Then, a minimization is used with starting values found by the grid search; The minimizer algorithm used (by default Minuit) can be changed by callinga; ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); Other option for the minimizer can be set using the static method of the MinimizerOptions class. Note that this method will always do first a grid search in contrast to GetMinimum. Double_t GetMaximumXY(Double_t& x, Double_t& y) const; Compute the X and Y values corresponding to the maximum value of the function; Return the maximum value of the function; See TF2::GetMinimumXY. Double_t GetMinimum(Double_t* x) const; return minimum/maximum value of the function; To find the minimum on a range, first set this range via the SetRange function; If a vector x of coordinate is passed it will be used as starting point for the minimum.; In addition on exit x will contain the coordinate values at the minimuma; If x is NULL or x is inifinity or NaN, first, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided into fNpx and fNpy; sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; by SetNpx and SetNpy functions; Then, a minimization is used with starting values found by the grid search; The minimizer algorithm used (by default Minuit) can be changed by callinga; ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); Other option for the minimizer can be set using the static method of the MinimizerOptions class. Double_t GetMaximum(Double_t* x) const; return maximum value of the function; See TF2::GetMinimum. char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the function value; corresponding to cursor position px,py. Double_t GetRandom(); Return a random number following this function shape*-; *-* ====================================================; -. Double_t GetRandom(Double_t xmin, Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF2.html:27543,perform,performed,27543,root/html604/TF2.html,https://root.cern,https://root.cern/root/html604/TF2.html,1,['perform'],['performed']
Performance,"se values can be changed; by SetNpx and SetNpy functions; Then, a minimization is used with starting values found by the grid search; The minimizer algorithm used (by default Minuit) can be changed by callinga; ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); Other option for the minimizer can be set using the static method of the MinimizerOptions class. Note that this method will always do first a grid search in contrast to GetMinimum. Double_t GetMaximumXY(Double_t& x, Double_t& y) const; Compute the X and Y values corresponding to the maximum value of the function; Return the maximum value of the function; See TF2::GetMinimumXY. Double_t GetMinimum(Double_t* x) const; return minimum/maximum value of the function; To find the minimum on a range, first set this range via the SetRange function; If a vector x of coordinate is passed it will be used as starting point for the minimum.; In addition on exit x will contain the coordinate values at the minimuma; If x is NULL or x is inifinity or NaN, first, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided into fNpx and fNpy; sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; by SetNpx and SetNpy functions; Then, a minimization is used with starting values found by the grid search; The minimizer algorithm used (by default Minuit) can be changed by callinga; ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); Other option for the minimizer can be set using the static method of the MinimizerOptions class. Double_t GetMaximum(Double_t* x) const; return maximum value of the function; See TF2::GetMinimum. char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the function value; corresponding to cursor position px,py. Double_t GetRandom(); Return a random number following this function shape. Double_t GetRandom(Double_t xmin, Double_t xmax); Return a random number following this function sh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF2.html:34166,perform,performed,34166,root/html602/TF2.html,https://root.cern,https://root.cern/root/html602/TF2.html,1,['perform'],['performed']
Performance,"se {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);; 3573 ; 3574 Long64_t nbytes = 0;; 3575 Long64_t treeEntries = tree->GetEntriesFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || nentries == tree->GetEntriesFast())) {; 3583 // Quickly copy the basket without decompression and streaming.; 3584 Long64_t totbytes = GetTotBytes();; 3585 for (Long64_t i = 0; i < nentries; i += tree->GetTree()->GetEntries()) {; 3586 if (tree->LoadTree(i) < 0) {; 3587 break;; 3588 }; 3589 if ( withIndex ) {; 3590 withIndex = R__HandleIndex( onIndexError, this, tree );; 3591 }; 3592 if (this->GetDirectory()) {; 3593 TFile* file2 = this->GetDirectory()->GetFile();; 3594 if (file2 && (file2->GetEND() > TTree::GetMaxTreeSize())) {; 3595 if (this->GetDirectory() == (TDirectory*)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:141509,cache,cacheSizeStr,141509,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cacheSizeStr']
Performance,"se"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mTMVA_CNN_CPU␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:InputLayout=1|16|16:Layout=CONV|10|3|3|1|1|1|1|RELU,BNORM,CONV|10|3|3|1|1|1|1|RELU,MAXPOOL|2|2|1|1,RESHAPE|FLAT,DENSE|100|RELU,DENSE|1|LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.9,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.0:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:InputLayout=1|16|16:Layout=CONV|10|3|3|1|1|1|1|RELU,BNORM,CONV|10|3|3|1|1|1|1|RELU,MAXPOOL|2|2|1|1,RESHAPE|FLAT,DENSE|100|RELU,DENSE|1|LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.9,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.0:Architecture=CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:5002,Optimiz,Optimizer,5002,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['Optimiz'],['Optimizer']
Performance,"se(const char* method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; TMVA::MethodCutsMethodCuts(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodCutsMethodCuts(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""MC:150:10000:"", TDirectory* theTargetFile = 0); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; voidPrintCuts(Double_t effS) const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; virtual voidProcessOptions(); voidTMVA::MethodBase::ProcessSetup(); virtual voidTMVA::IFitterTarget::ProgressNotifier(TString, TString); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& i); virtual voidReadWeightsFromXML(void* w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCuts.html:10822,Optimiz,OptimizeTuningParameters,10822,root/html528/TMVA__MethodCuts.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCuts.html,1,['Optimiz'],['OptimizeTuningParameters']
Performance,"se, bool gettreeheader=false);  Enable/Disable PROOF processing on the current default Proof (gProof). ;  ; void SetWeight (Double_t w=1, Option_t *option="""") override;  Set chain weight. ;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UseCache (Int_t maxCacheSize=10, Int_t pageSize=0);  Dummy function kept for back compatibility. ;  ;  Public Member Functions inherited from TTree;  TTree ();  Default constructor and I/O constructor. ;  ;  TTree (const char *name, const char *title, Int_t splitlevel=99, TDirectory *dir=(::ROOT::Internal::TDirectoryAtomicAdapter{}));  Normal tree constructor. ;  ;  TTree (const TTree &tt)=delete;  ;  ~TTree () override;  Destructor. ;  ; void AddAllocationCount (UInt_t count);  ; virtual Int_t AddBranchToCache (const char *bname, bool subbranches=false);  Add branch with name bname to the Tree cache. ;  ; virtual Int_t AddBranchToCache (TBranch *branch, bool subbranches=false);  Add branch b to the Tree cache. ;  ; void AddClone (TTree *);  Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ;  ; virtual void AddTotBytes (Int_t tot);  ; virtual void AddZipBytes (Int_t zip);  ; virtual Long64_t AutoSave (Option_t *option="""");  AutoSave tree header every fAutoSave bytes. ;  ; virtual Int_t Branch (const char *folder, Int_t bufsize=32000, Int_t splitlevel=99);  Create one branch for each element in the folder. ;  ; TBranch * Branch (const char *name, char *address, const char *leaflist, Int_t bufsize=32000);  ; template<class T > ; TBranch * Branch (const char *name, const char *classname, T **addobj, Int_t bufsize=32000, Int_t splitlevel=99);  ; template<class T > ; TBranch * Branch (const char *name, const char *classname, T *obj, Int_t bufsize=32000, Int_t splitlevel=99);  ; virtual TBranch * Branch (const char *name, const char *classname, void *addobj, Int_t bufsize=32",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:13067,cache,cache,13067,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,2,['cache'],['cache']
Performance,"se, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by the current volume. This is only insured in case a call to TGeoManager::FindNode() was performed for the current point. Therefore, the first step is to convert the global current point and direction in the local reference frame of the current volume and to compute the distance to exit its shape from inside. The returned value is again compared to the maximum allowed step (the proposed one) and in case the distance is safe no other action is performed and the proposed step is approved. In case the boundary is closer, the computed distance is taken as maximum allowed step. For optimization purposed, for particles starting very close to the current volume boundary (less than 0.01 microns) and exiting the algorithm stops here.; After computing the distance to exit the current node, the distance to the daughter of the current volume which is crossed next is computed by TGeoManager::FindNextDaughterBoundary(). This computes the distance to all daughter candidates that can be possibly crossed by using volume voxelization. The algorithm is efficient in average ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:133530,perform,performed,133530,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,2,['perform'],['performed']
Performance,"se. RooCompositeDataStore(const RooCompositeDataStore& other, const RooArgSet& vars, const char* newname = 0); Update index category pointer, if it is contained in input argument vars. ~RooCompositeDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Forward fill request to appropriate subset. Double_t sumEntries() const; Forward fill request to appropriate subset. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='idx') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight() const. Double_t weight(Int_t index) const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t isWeighted() const. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); WVE ownership issue here!! Caller (a RooAbsData) should take ownership of all; arguments, but only does for the first one here... RooArgSet* addColumns(const RooArgList& varList); WVE ownership issue here!! Caller (a RooAbsData) should take ownership of all; arguments, but only does for the first one here... RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList). void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0). void setArgStatus(const RooArgSet& set, Bool_t active). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCompositeDataStore.html:11147,load,loadValues,11147,root/html532/RooCompositeDataStore.html,https://root.cern,https://root.cern/root/html532/RooCompositeDataStore.html,1,['load'],['loadValues']
Performance,"se.; Nodes can be declared as ""overlapping"" in case they do overlap with other nodes inside the same container or extrude this container. Non-overlapping nodes can be created with:; TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; int; The creation of overlapping nodes can be done with a similar prototype:; TGeoVolume::AddNodeOverlap(same arguments);; TGeoVolume::AddNodeOverlapvirtual void AddNodeOverlap(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:1044; When closing the geometry, overlapping nodes perform a check of possible overlaps with their neighbours. These are stored and checked all the time during navigation, therefore navigation is slower when embedding such nodes into geometry.; Node have visualization attributes as volume have. When undefined by users, painting a node on a pad will take the corresponding volume attributes. Definition at line 39 of file TGeoNode.h. Public Types; enum  { ;   kGeoNodeMatrix = (1ULL << ( 14 )); , kGeoNodeOffset = (1ULL << ( 15 )); , kGeoNodeVC = (1ULL << ( 16 )); , kGeoNodeOverlap = (1ULL << ( 17 )); , ;   kGeoNodeCloned = (1ULL << ( 18 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNode.html:3531,perform,perform,3531,doc/master/classTGeoNode.html,https://root.cern,https://root.cern/doc/master/classTGeoNode.html,1,['perform'],['perform']
Performance,"se::GetXmaxDouble_t GetXmax(Int_t ivar) constDefinition MethodBase.h:357; TMVA::MethodBase::GetMulticlassTrainingEfficiencyvirtual std::vector< Float_t > GetMulticlassTrainingEfficiency(std::vector< std::vector< Float_t > > &purity)Definition MethodBase.cxx:2715; TMVA::MethodBase::fDataSetInfoDataSetInfo & fDataSetInfoDefinition MethodBase.h:607; TMVA::MethodBase::fHasMVAPdfsBool_t fHasMVAPdfsMVA Pdfs are created for this classifier.Definition MethodBase.h:680; TMVA::MethodBase::WriteStateToStreamvoid WriteStateToStream(std::ostream &tf) constgeneral method used in writing the header of the weight files where the used variables,...Definition MethodBase.cxx:1267; TMVA::MethodBase::GetRarityvirtual Double_t GetRarity(Double_t mvaVal, Types::ESBType reftype=Types::kBackground) constcompute rarity:Definition MethodBase.cxx:2285; TMVA::MethodBase::fUseDecorrBool_t fUseDecorrDefinition MethodBase.h:723; TMVA::MethodBase::SetTuneParametersvirtual void SetTuneParameters(std::map< TString, Double_t > tuneParameters)set the tuning parameters according to the argument This is just a dummy .Definition MethodBase.cxx:644; TMVA::MethodBase::GetTrainTimeDouble_t GetTrainTime() constDefinition MethodBase.h:162; TMVA::MethodBase::SetBaseDirvoid SetBaseDir(TDirectory *methodDir)Definition MethodBase.h:373; TMVA::MethodBase::ReadStateFromStreamvoid ReadStateFromStream(std::istream &tf)read the header from the weight files of the different MVA methodsDefinition MethodBase.cxx:1590; TMVA::MethodBase::AddVarsXMLTovoid AddVarsXMLTo(void *parent) constwrite variable info to XMLDefinition MethodBase.cxx:1762; TMVA::MethodBase::HelpBool_t Help() constDefinition MethodBase.h:504; TMVA::MethodBase::fSplRefBTSpline1 * fSplRefBDefinition MethodBase.h:703; TMVA::MethodBase::fJobNameTString fJobNameDefinition MethodBase.h:614; TMVA::MethodBase::fIPyCurrentIterUInt_t fIPyCurrentIterDefinition MethodBase.h:450; TMVA::MethodBase::GetTransformationHandlerTransformationHandler & GetTransformationHandle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodBase_8h_source.html:59654,tune,tuneParameters,59654,doc/master/MethodBase_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodBase_8h_source.html,1,['tune'],['tuneParameters']
Performance,"se::fFactory; TMatrixDSparsefKkt; Int_tTQpLinSolverBase::fMclo; Int_tTQpLinSolverBase::fMcup; Int_tTQpLinSolverBase::fMy; Int_tTQpLinSolverBase::fMz; TVectorDTQpLinSolverBase::fNomegaInvstores a critical diagonal matrix as a vector; Int_tTQpLinSolverBase::fNxdimensions of the vectors in the general QP formulation; Int_tTQpLinSolverBase::fNxlo; Int_tTQpLinSolverBase::fNxupdimensions of the upper and lower bound vectors; TVectorDTQpLinSolverBase::fRhsright-hand side of the system; TDecompSparsefSolveSparse; TVectorDTQpLinSolverBase::fXloIndex; TVectorDTQpLinSolverBase::fXupIndexindex matrices for the upper and lower bounds on x and Cx. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQpLinSolverSparse(TQpProbSparse* factory, TQpDataSparse* data); Constructor. TQpLinSolverSparse(const TQpLinSolverSparse& another); Copy constructor. void Factor(TQpDataBase* prob, TQpVar* vars); Sets up the matrix for the main linear system in ""augmented system"" form. void PutXDiagonal(TVectorD& xdiag); Places the diagonal resulting from the bounds on x into the augmented system matrix. void PutZDiagonal(TVectorD& zdiag); Places the diagonal resulting from the bounds on Cx into the augmented system matrix. void SolveCompressed(TVectorD& rhs); Perform the actual solve using the factors produced in factor.; rhs on input contains the aggregated right-hand side of the augmented system;; on output contains the solution in aggregated form . TQpLinSolverSparse & operator=(const TQpLinSolverSparse& source); Assignment operator. TQpLinSolverSparse(); {}. virtual ~TQpLinSolverSparse(); {}. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpLinSolverSparse.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpLinSolverSparse.html:7599,Perform,Perform,7599,root/html528/TQpLinSolverSparse.html,https://root.cern,https://root.cern/root/html528/TQpLinSolverSparse.html,1,['Perform'],['Perform']
Performance,"se::fFactory; TMatrixDSparsefKkt; Int_tTQpLinSolverBase::fMclo; Int_tTQpLinSolverBase::fMcup; Int_tTQpLinSolverBase::fMy; Int_tTQpLinSolverBase::fMz; TVectorDTQpLinSolverBase::fNomegaInvstores a critical diagonal matrix as a vector; Int_tTQpLinSolverBase::fNxdimensions of the vectors in the general QP formulation; Int_tTQpLinSolverBase::fNxlo; Int_tTQpLinSolverBase::fNxupdimensions of the upper and lower bound vectors; TVectorDTQpLinSolverBase::fRhsright-hand side of the system; TDecompSparsefSolveSparse; TVectorDTQpLinSolverBase::fXloIndex; TVectorDTQpLinSolverBase::fXupIndexindex matrices for the upper and lower bounds on x and Cx. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQpLinSolverSparse(TQpProbSparse* factory, TQpDataSparse* data); Constructor. TQpLinSolverSparse(const TQpLinSolverSparse& another); Copy constructor. void Factor(TQpDataBase* prob, TQpVar* vars); Sets up the matrix for the main linear system in ""augmented system"" form. void PutXDiagonal(TVectorD& xdiag); Places the diagonal resulting from the bounds on x into the augmented system matrix. void PutZDiagonal(TVectorD& zdiag); Places the diagonal resulting from the bounds on Cx into the augmented system matrix. void SolveCompressed(TVectorD& rhs); Perform the actual solve using the factors produced in factor.; rhs on input contains the aggregated right-hand side of the augmented system;; on output contains the solution in aggregated form . TQpLinSolverSparse & operator=(const TQpLinSolverSparse& source); Assignment operator. TQpLinSolverSparse(); {}. virtual ~TQpLinSolverSparse(); {}. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpLinSolverSparse.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TQpLinSolverSparse.html:7668,Perform,Perform,7668,root/html530/TQpLinSolverSparse.html,https://root.cern,https://root.cern/root/html530/TQpLinSolverSparse.html,1,['Perform'],['Perform']
Performance,"se::fFactory; TMatrixDSparsefKkt; Int_tTQpLinSolverBase::fMclo; Int_tTQpLinSolverBase::fMcup; Int_tTQpLinSolverBase::fMy; Int_tTQpLinSolverBase::fMz; TVectorDTQpLinSolverBase::fNomegaInvstores a critical diagonal matrix as a vector; Int_tTQpLinSolverBase::fNxdimensions of the vectors in the general QP formulation; Int_tTQpLinSolverBase::fNxlo; Int_tTQpLinSolverBase::fNxupdimensions of the upper and lower bound vectors; TVectorDTQpLinSolverBase::fRhsright-hand side of the system; TDecompSparsefSolveSparse; TVectorDTQpLinSolverBase::fXloIndex; TVectorDTQpLinSolverBase::fXupIndexindex matrices for the upper and lower bounds on x and Cx. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQpLinSolverSparse(TQpProbSparse* factory, TQpDataSparse* data); Constructor. TQpLinSolverSparse(const TQpLinSolverSparse& another); Copy constructor. void Factor(TQpDataBase* prob, TQpVar* vars); Sets up the matrix for the main linear system in ""augmented system"" form. void PutXDiagonal(TVectorD& xdiag); Places the diagonal resulting from the bounds on x into the augmented system matrix. void PutZDiagonal(TVectorD& zdiag); Places the diagonal resulting from the bounds on Cx into the augmented system matrix. void SolveCompressed(TVectorD& rhs); Perform the actual solve using the factors produced in factor.; rhs on input contains the aggregated right-hand side of the augmented system;; on output contains the solution in aggregated form . TQpLinSolverSparse & operator=(const TQpLinSolverSparse& source); Assignment operator. TQpLinSolverSparse(); {}. virtual ~TQpLinSolverSparse(); {}. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpLinSolverSparse.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQpLinSolverSparse.html:7668,Perform,Perform,7668,root/html532/TQpLinSolverSparse.html,https://root.cern,https://root.cern/root/html532/TQpLinSolverSparse.html,1,['Perform'],['Perform']
Performance,"se; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor; cout << ""deleting dataset "" << this << endl ;. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output datas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsData.html:14667,cache,cacheArgs,14667,root/html530/RooAbsData.html,https://root.cern,https://root.cern/root/html530/RooAbsData.html,2,"['Cache', 'cache']","['Cache', 'cacheArgs']"
Performance,"se; kTreeStructure; };. protected:. TString_convVarNameName of convolution variable; RooRealVar*_cvModelConvolution variable in resModel event; RooRealVar*_cvOutConvolution variable in output event; RooRealVar*_cvPdfConvolution variable in PDFxTruth event; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; RooDataSet*RooAbsGenContext::_genData! Data being generated; Bool_tRooAbsGenContext::_isValidIs context in valid state?; RooArgSet*_modelCloneSetOwner of resModel clone; RooAbsGenContext*_modelGenResolution model generator context; RooArgSet*_modelVarsHolder of resModel event; RooArgSet*_modelVarsOwnedOwning version of modelVars ;; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; RooArgSet*_pdfCloneSetOwner of PDF clone; RooAbsGenContext*_pdfGenPhysics model generator context; RooArgSet*_pdfVarsHolder of PDF x truth event; RooArgSet*_pdfVarsOwnedOwning version of pdfVars ;; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooConvGenContext(const RooAbsAnaConvPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor for specialized generator context for analytical convolutions. Builds a generator for the physics PDF convoluted with the truth model; and a generator for the res",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooConvGenContext.html:8704,load,load,8704,root/html528/RooConvGenContext.html,https://root.cern,https://root.cern/root/html528/RooConvGenContext.html,4,['load'],['load']
Performance,"seCount() << std::endl;; 1341 // should we apply droput to the loss ??; 1342 minValError += deepNet.Loss(inputTensor, outputMatrix, weights, false, includeRegularization);; 1343 }; 1344 // add Regularization term; 1345 Double_t regzTerm = (includeRegularization) ? deepNet.RegularizationTerm() : 0.0;; 1346 minValError /= (Double_t)(nValidationSamples / settings.batchSize);; 1347 minValError += regzTerm;; 1348 ; 1349 ; 1350 // create a pointer to base class VOptimizer; 1351 std::unique_ptr<DNN::VOptimizer<Architecture_t, Layer_t, DeepNet_t>> optimizer;; 1352 ; 1353 // initialize the base class pointer with the corresponding derived class object.; 1354 switch (O) {; 1355 ; 1356 case EOptimizer::kSGD:; 1357 optimizer = std::unique_ptr<DNN::TSGD<Architecture_t, Layer_t, DeepNet_t>>(; 1358 new DNN::TSGD<Architecture_t, Layer_t, DeepNet_t>(settings.learningRate, deepNet, settings.momentum));; 1359 break;; 1360 ; 1361 case EOptimizer::kAdam: {; 1362 optimizer = std::unique_ptr<DNN::TAdam<Architecture_t, Layer_t, DeepNet_t>>(; 1363 new DNN::TAdam<Architecture_t, Layer_t, DeepNet_t>(; 1364 deepNet, settings.learningRate, settings.optimizerParams[""ADAM_beta1""],; 1365 settings.optimizerParams[""ADAM_beta2""], settings.optimizerParams[""ADAM_eps""]));; 1366 break;; 1367 }; 1368 ; 1369 case EOptimizer::kAdagrad:; 1370 optimizer = std::unique_ptr<DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>>(; 1371 new DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1372 settings.optimizerParams[""ADAGRAD_eps""]));; 1373 break;; 1374 ; 1375 case EOptimizer::kRMSProp:; 1376 optimizer = std::unique_ptr<DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>>(; 1377 new DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate, settings.momentum,; 1378 settings.optimizerParams[""RMSPROP_rho""],; 1379 settings.optimizerParams[""RMSPROP_eps""]));; 1380 break;; 1381 ; 1382 case EOptimizer::kAdadelta:; 1383 optimizer = std::unique_ptr<DNN::TAdadelta<Architect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:53851,optimiz,optimizer,53851,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['optimiz'],['optimizer']
Performance,"seFunc. Definition at line 232 of file IParamFunction.h. ◆ BaseGradFunc. template<class T > . using ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::BaseGradFunc = IGradientFunctionMultiDimTempl<T>. Definition at line 231 of file IParamFunction.h. ◆ BaseParamFunc. template<class T > . using ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::BaseParamFunc = IParametricFunctionMultiDimTempl<T>. Definition at line 230 of file IParamFunction.h. Constructor & Destructor Documentation. ◆ ~IParametricGradFunctionMultiDimTempl(). template<class T > . ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::~IParametricGradFunctionMultiDimTempl ; (; ). inlineoverride . Virtual Destructor (no operations) ; Definition at line 238 of file IParamFunction.h. Member Function Documentation. ◆ DoEval(). template<class T > . T ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::DoEval ; (; const T * ; x); const. inlineoverrideprivatevirtual . Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. ; Reimplemented from ROOT::Math::IParametricFunctionMultiDimTempl< T >.; Reimplemented in ROOT::Math::WrappedMultiTF1Templ< T >.; Definition at line 307 of file IParamFunction.h. ◆ DoEvalPar(). template<class T > . T ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::DoEvalPar ; (; const T * ; x, . const double * ; p . ); const. overrideprivatepure virtual . Implementation of the evaluation function using the x values and the parameters. ; Must be implemented by derived classes ; Implements ROOT::Math::IParametricFunctionMultiDimTempl< T >.; Implemented in ROOT::Math::WrappedMultiTF1Templ< T >. ◆ DoParameterDerivative(). template<class T > . virtual T ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::DoParameterDerivative ; (; const T * ; x, . const double * ; p, . unsigned int ; ipar . ); const. privatepure virtual . Evaluate the partial derivative w.r.t a parameter ipar , to be implemented by the derived classes. ; Implemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionMultiDimTempl.html:5962,cache,cached,5962,doc/master/classROOT_1_1Math_1_1IParametricGradFunctionMultiDimTempl.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionMultiDimTempl.html,1,['cache'],['cached']
Performance,"seNonDerived = false . ); const. Fill supplied list with all leaf nodes of the arg tree, starting with ourself as top node. ; A leaf node is node that has no servers declared. ; Definition at line 472 of file RooAbsArg.cxx. ◆ localNoDirtyInhibit(). bool RooAbsArg::localNoDirtyInhibit ; (; ); const. inline . Definition at line 675 of file RooAbsArg.h. ◆ makeLegacyIterator(). RooAbsArg::RefCountListLegacyIterator_t * RooAbsArg::makeLegacyIterator ; (; const RefCountList_t & ; list); const. private . Definition at line 2464 of file RooAbsArg.cxx. ◆ namePtr(). const TNamed * RooAbsArg::namePtr ; (; ); const. inline . De-duplicated pointer to this object's name. ; This can be used for fast name comparisons. like if (namePtr() == other.namePtr()). NoteTNamed::GetName() will return a pointer that's different for each object, but namePtr() always points to a unique instance. ; Definition at line 535 of file RooAbsArg.h. ◆ numCaches(). Int_t RooAbsArg::numCaches ; (; ); const. Return number of registered caches. ; Definition at line 2136 of file RooAbsArg.cxx. ◆ numProxies(). Int_t RooAbsArg::numProxies ; (; ); const. Return the number of registered proxies. ; Definition at line 1457 of file RooAbsArg.cxx. ◆ observableOverlaps() [1/2]. bool RooAbsArg::observableOverlaps ; (; const RooAbsData * ; dset, . const RooAbsArg & ; testArg . ); const. Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ; Definition at line 914 of file RooAbsArg.cxx. ◆ observableOverlaps() [2/2]. bool RooAbsArg::observableOverlaps ; (; const RooArgSet * ; depList, . const RooAbsArg & ; testArg . ); const. Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ; Definition at line 924 of file RooAbsArg.cxx. ◆ operator=(). RooAbsArg & RooAbsArg::operator= ; (; const RooAbsArg & ; other). delete . ◆ operator==(). virtual bool RooAbsArg::operator== ; (; const RooAbsArg & ; other); c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:76519,cache,caches,76519,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['caches']
Performance,"seRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; vector<std::pair<Float_t,Float_t> >*fDeviationsFromTargetsdeviation from the targets, event weight; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; Float_tfWeightRangesuppress outliers for the estimator calculation; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodMLP.html:21940,perform,performed,21940,root/html530/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodMLP.html,3,['perform'],['performed']
Performance,"seTransform(const TMVA::Event*const , Int_t cls) const; apply the principal component analysis; TODO: implementation of inverse transformation; Log() << kFATAL << ""Inverse transformation for PCA transformation not yet implemented. Hence, this transformation cannot be applied together with regression. Please contact the authors if necessary."" << Endl;. void CalculatePrincipalComponents(const vector<TMVA::Event*>& ); calculate the principal components for the signal and the background data; it uses the MakePrincipal method of ROOT's TPrincipal class. void X2P(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Calculate the principal components from the original data vector; x, and return it in p (function extracted from TPrincipal::X2P); It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). void P2X(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Perform the back-transformation from the principal components; pc, and return x; It's the users responsibility to make sure that both x and pc are; of the right size (i.e., memory must be allocated for p). void WriteTransformationToStream(ostream& ) const; write mean values to stream. void AttachXMLTo(void* parent); create XML description of PCA transformation. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. void ReadTransformationFromStream(istream& , const TString& ); Read mean values from input stream. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates C++ code fragment of the PCA transform for inclusion in standalone C++ class. VariablePCATransform( DataSetInfo& dsi ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please sen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__VariablePCATransform.html:11811,Perform,Perform,11811,root/html604/TMVA__VariablePCATransform.html,https://root.cern,https://root.cern/root/html604/TMVA__VariablePCATransform.html,1,['Perform'],['Perform']
Performance,"seTransform(const TMVA::Event*const , Int_t cls) const; apply the principal component analysis; TODO: implementation of inverse transformation; Log() << kFATAL << ""Inverse transformation for PCA transformation not yet implemented. Hence, this transformation cannot be applied together with regression. Please contact the authors if necessary."" << Endl;. void CalculatePrincipalComponents(const vector<TMVA::Event*>& ); calculate the principal components for the signal and the background data; it uses the MakePrincipal method of ROOT's TPrincipal class. void X2P(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Calculate the principal components from the original data vector; x, and return it in p (function extracted from TPrincipal::X2P); It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). void P2X(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Perform the back-transformation from the principal components; pc, and return x; It's the users responsibility to make sure that both x and pc are; of the right size (i.e., memory must be allocated for p). void WriteTransformationToStream(ostream& ) const; write mean values to stream. void AttachXMLTo(void* parent); create XML description of PCA transformation. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. void ReadTransformationFromStream(istream& , const TString& ); Read mean values from input stream. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates C++ code fragment of the PCA transform for inclusion in standalone C++ class. VariablePCATransform( DataSetInfo& dsi ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please sen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__VariablePCATransform.html:11803,Perform,Perform,11803,root/html602/TMVA__VariablePCATransform.html,https://root.cern,https://root.cern/root/html602/TMVA__VariablePCATransform.html,1,['Perform'],['Perform']
Performance,sed by RooFit ;  CRooNumCdfClass RooNumCdf is an implementation of RooNumRunningInt specialized to calculate cumulative distribution functions from p.d.f.s ;  CRooNumConvolutionNumeric 1-dimensional convolution operator PDF ;  CRooNumConvPdfNumeric 1-dimensional convolution operator PDF ;  CRooNumGenConfigRooNumGenConfig holds the configuration parameters of the various numeric integrators used by RooRealIntegral ;  CRooNumGenFactoryRooNumGenFactory is a factory to instantiate numeric integrators from a given function binding and a given configuration ;  CRooNumIntConfigRooNumIntConfig holds the configuration parameters of the various numeric integrators used by RooRealIntegral ;  CRooNumIntFactoryRooNumIntFactory is a factory to instantiate numeric integrators from a given function binding and a given configuration ;  ►CRooNumRunningIntClass RooNumRunningInt is an implementation of RooAbsCachedReal that represents a running integral ;  CRICacheElem;  CRooObjCacheManagerClass RooObjCacheManager is an implementation of class RooCacheManager<RooAbsCacheElement> and specializes in the storage of cache elements that contain RooAbsArg objects ;  CRooParamBinningClass RooParamBinning is an implementation of RooAbsBinning that constructs a binning with a range definition that depends on external RooAbsReal objects ;  CRooParametricStepFunctionThe Parametric Step Function PDF is a binned distribution whose parameters are the heights of each bin ;  CRooParamHistFunc;  ►CRooPlotA RooPlot is a plot frame and a container for graphics objects within that frame ;  CDrawOpt;  CRooPlotableClass RooPotable is a base class for objects that can be inserted into RooPlots and take advantage of its internal normalization and axis range adjustment features ;  CRooPoissonPoisson pdf ;  CRooPolynomialRooPolynomial implements a polynomial p.d.f of the form ;  CRooPolyVarClass RooPolyVar is a RooAbsReal implementing a polynomial in terms of a list of RooAbsReal coefficients ;  CRooPrintableRoo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:122777,cache,cache,122777,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['cache'],['cache']
Performance,"sed bytes of a page into the memory buffer provided by sealedPage. ; The sealed page can be used subsequently in a call to RPageSink::CommitSealedPage. The fSize and fNElements member of the sealedPage parameters are always set. If sealedPage.fBuffer is nullptr, no data will be copied but the returned size information can be used by the caller to allocate a large enough buffer and call LoadSealedPage again. ; Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSourceDaos, and ROOT::Experimental::Internal::RPageSourceFile. ◆ LoadStructure(). void ROOT::Experimental::Internal::RPageSource::LoadStructure ; (; ). Loads header and footer without decompressing or deserializing them. ; This can be used to asynchronously open a file in the background. The method is idempotent and it is called as a first step in Attach(). Pages sources may or may not make use of splitting loading and processing meta-data. Therefore, LoadStructure() may do nothing and defer loading the meta-data to Attach(). ; Definition at line 188 of file RPageStorage.cxx. ◆ LoadStructureImpl(). virtual void ROOT::Experimental::Internal::RPageSource::LoadStructureImpl ; (; ). protectedpure virtual . Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSourceDaos, and ROOT::Experimental::Internal::RPageSourceFile. ◆ operator=() [1/2]. RPageSource & ROOT::Experimental::Internal::RPageSource::operator= ; (; const RPageSource & ; ). delete . ◆ operator=() [2/2]. RPageSource & ROOT::Experimental::Internal::RPageSource::operator= ; (; RPageSource && ; ). delete . ◆ PrepareLoadCluster(). void ROOT::Experimental::Internal::RPageSource::PrepareLoadCluster ; (; const RCluster::RKey & ; clusterKey, . ROnDiskPageMap & ; pageZeroMap, . std::function< void(DescriptorId_t, NTupleSize_t, const RClusterDescriptor::RPageRange::RPageInfo &)> ; perPageFunc . ). protected . Prepare a page range read for the column set in clusterKey. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:17440,Load,LoadStructure,17440,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,2,"['Load', 'load']","['LoadStructure', 'loading']"
Performance,"sed for spline fit. ; Definition at line 90 of file OptimizeConfigParameters.h. ◆ fMvaBkgFineBin. TH1D* TMVA::OptimizeConfigParameters::fMvaBkgFineBin. private . MVA distribution for bakgr. events. ; Definition at line 93 of file OptimizeConfigParameters.h. ◆ fMvaSig. TH1D* TMVA::OptimizeConfigParameters::fMvaSig. private . MVA distribution for signal events, used for spline fit. ; Definition at line 89 of file OptimizeConfigParameters.h. ◆ fMvaSigFineBin. TH1D* TMVA::OptimizeConfigParameters::fMvaSigFineBin. private . MVA distribution for signal events. ; Definition at line 92 of file OptimizeConfigParameters.h. ◆ fNotDoneYet. Bool_t TMVA::OptimizeConfigParameters::fNotDoneYet. private . flat to indicate of Method Transformations have been obtained yet or not (normally done in MethodBase::TrainMethod) ; Definition at line 95 of file OptimizeConfigParameters.h. ◆ fOptimizationFitType. TString TMVA::OptimizeConfigParameters::fOptimizationFitType. private . which type of optimisation procedure to be used ; Definition at line 88 of file OptimizeConfigParameters.h. ◆ fTunedParameters. std::map<TString,Double_t> TMVA::OptimizeConfigParameters::fTunedParameters. private . parameters included in the tuning ; Definition at line 85 of file OptimizeConfigParameters.h. ◆ fTuneParameters. std::map<TString,TMVA::Interval*> TMVA::OptimizeConfigParameters::fTuneParameters. private . parameters included in the tuning ; Definition at line 84 of file OptimizeConfigParameters.h. ◆ TestOptimizeConfigParameters. friend TMVA::OptimizeConfigParameters::TestOptimizeConfigParameters. Definition at line 52 of file OptimizeConfigParameters.h. Libraries for TMVA::OptimizeConfigParameters:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/OptimizeConfigParameters.h; tmva/tmva/src/OptimizeConfigParameters.cxx. TMVAOptimizeConfigParameters. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:39 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:12361,Optimiz,OptimizeConfigParameters,12361,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,10,['Optimiz'],['OptimizeConfigParameters']
Performance,"sed when a key (or basket) is transfered from one file to the other. ;  ; void SetReadParam (Int_t mapsize) override;  Set the initial size of the map used to store object and class references during reading. ;  ; void SetWriteParam (Int_t mapsize) override;  Set the initial size of the hashtable used to store object and class references during writing. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void TagStreamerInfo (TVirtualStreamerInfo *info) override;  Mark the classindex of the current file as using this TStreamerInfo. ;  ; Int_t WriteClones (TClonesArray *a, Int_t nobjects) override;  Interface to TStreamerInfo::WriteBufferClones. ;  ; template<class T > ; Int_t WriteObject (const T *objptr, Bool_t cacheReuse=kTRUE);  ; virtual void WriteObject (const TObject *obj, Bool_t cacheReuse)=0;  ; void WriteObject (const TObject *obj, Bool_t cacheReuse=kTRUE) override;  Write object to I/O buffer. ;  ; Int_t WriteObjectAny (const void *obj, const TClass *ptrClass, Bool_t cacheReuse=kTRUE) override;  Write object to I/O buffer. ;  ; UShort_t WriteProcessID (TProcessID *pid) override;  Check if the ProcessID pid is already in the file. ;  ;  Public Member Functions inherited from TBuffer;  TBuffer (EMode mode);  Create an I/O buffer object. ;  ;  TBuffer (EMode mode, Int_t bufsiz);  Create an I/O buffer object. ;  ;  TBuffer (EMode mode, Int_t bufsiz, void *buf, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr);  Create an I/O buffer object. ;  ; virtual ~TBuffer ();  Delete an I/O buffer object. ;  ; void AutoExpand (Int_t size_needed);  Automatically calculate a new size and expand the buffer to fit at least size_needed. ;  ; char * Buffer () const;  ; Int_t BufferSize () const;  ; Bool_t ByteSwapBuffer (Long64_t n, EDataType type);  Byte-swap N primitive-elements in the buffer. ;  ; virtual void ClassBegin (const TClass *, Version_t=-1)=0;  ; virtual void ClassEnd (const TClass *)=0;  ; virtual void ClassMember (const char *, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferText.html:10014,cache,cacheReuse,10014,doc/master/classTBufferText.html,https://root.cern,https://root.cern/doc/master/classTBufferText.html,1,['cache'],['cacheReuse']
Performance,"sed when a key (or basket) is transfered from one file to the other. ;  ; void SetReadParam (Int_t mapsize) override;  Set the initial size of the map used to store object and class references during reading. ;  ; void SetWriteParam (Int_t mapsize) override;  Set the initial size of the hashtable used to store object and class references during writing. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void TagStreamerInfo (TVirtualStreamerInfo *info) override;  Mark the classindex of the current file as using this TStreamerInfo. ;  ; Int_t WriteClones (TClonesArray *a, Int_t nobjects) override;  Interface to TStreamerInfo::WriteBufferClones. ;  ; template<class T > ; Int_t WriteObject (const T *objptr, Bool_t cacheReuse=kTRUE);  ; virtual void WriteObject (const TObject *obj, Bool_t cacheReuse)=0;  ; void WriteObject (const TObject *obj, Bool_t cacheReuse=kTRUE) override;  Write object to I/O buffer. ;  ; Int_t WriteObjectAny (const void *obj, const TClass *ptrClass, Bool_t cacheReuse=kTRUE) override;  Write object to I/O buffer. ;  ; UShort_t WriteProcessID (TProcessID *pid) override;  Check if the ProcessID pid is already in the file. ;  ;  Public Member Functions inherited from TBuffer;  TBuffer (EMode mode);  Create an I/O buffer object. ;  ;  TBuffer (EMode mode, Int_t bufsiz);  Create an I/O buffer object. ;  ;  TBuffer (EMode mode, Int_t bufsiz, void *buf, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr);  Create an I/O buffer object. ;  ; virtual ~TBuffer ();  Delete an I/O buffer object. ;  ; void AutoExpand (Int_t size_needed);  Automatically calculate a new size and expand the buffer to fit at least size_needed. ;  ; char * Buffer () const;  ; Int_t BufferSize () const;  ; Bool_t ByteSwapBuffer (Long64_t n, EDataType type);  Byte-swap N primitive-elements in the buffer. ;  ; void DetachBuffer ();  ; void Expand (Int_t newsize, Bool_t copy=kTRUE);  Expand (or shrink) the I/O buffer to newsize bytes. ;  ; Int_t GetBufferVersion",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:28273,cache,cacheReuse,28273,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,4,['cache'],['cacheReuse']
Performance,"sed; in the main training loop. void TrainAllMethods(); iterates through all booked methods and calls training. void TestAllMethods(). void MakeClass(const TString& methodTitle = """") const; Print predefined help message of classifier; iterate over methods and test. void PrintHelpMessage(const TString& methodTitle = """") const; Print predefined help message of classifier; iterate over methods and test. void EvaluateAllVariables(TString options = """"); iterates over all MVA input varables and evaluates them. void EvaluateAllMethods( void ); iterates over all MVAs that have been booked, and calls their evaluation methods. const char* GetName() const; { return ""Factory""; }. void AddRegressionTree(TTree* tree, Double_t weight = 1.0, TMVA::Types::ETreeType treetype = Types::kMaxTreeType); special case: regression. void AddRegressionTarget(const TString& expression, const TString& title = """", const TString& unit = """", Double_t min = 0, Double_t max = 0). MethodBase* BookMethod(TString theMethodName, TString methodTitle, TString theOption = """"). void OptimizeAllMethodsForClassification(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); { OptimizeAllMethods(fomType,fitType); }. void OptimizeAllMethodsForRegression(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); { OptimizeAllMethods(fomType,fitType); }. void TrainAllMethodsForClassification( void ); { TrainAllMethods(); }. void TrainAllMethodsForRegression( void ); { TrainAllMethods(); }. Bool_t Verbose( void ); { return fVerbose; }. TDirectory* RootBaseDir(); { return (TDirectory*)fgTargetFile; }. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Kai Voss, Eckhard von Toerne, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id: Factory.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__Factory.html:20503,Optimiz,OptimizeAllMethodsForClassification,20503,root/html532/TMVA__Factory.html,https://root.cern,https://root.cern/root/html532/TMVA__Factory.html,4,['Optimiz'],"['OptimizeAllMethods', 'OptimizeAllMethodsForClassification', 'OptimizeAllMethodsForRegression']"
Performance,"sed; in the main training loop. void TrainAllMethods(); iterates through all booked methods and calls training. void TestAllMethods(). void MakeClass(const TString& methodTitle = """") const; Print predefined help message of classifier; iterate over methods and test. void PrintHelpMessage(const TString& methodTitle = """") const; Print predefined help message of classifier; iterate over methods and test. void EvaluateAllVariables(TString options = """"); iterates over all MVA input varables and evaluates them. void EvaluateAllMethods( void ); iterates over all MVAs that have been booked, and calls their evaluation methods. const char* GetName() const; { return ""Factory""; }. void AddRegressionTree(TTree* tree, Double_t weight = 1.0, TMVA::Types::ETreeType treetype = Types::kMaxTreeType); special case: regression. void AddRegressionTarget(const TString& expression, const TString& title = """", const TString& unit = """", Double_t min = 0, Double_t max = 0). MethodBase* BookMethod(TString theMethodName, TString methodTitle, TString theOption = """"). void OptimizeAllMethodsForClassification(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); { OptimizeAllMethods(fomType,fitType); }. void OptimizeAllMethodsForRegression(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); { OptimizeAllMethods(fomType,fitType); }. void TrainAllMethodsForClassification( void ); { TrainAllMethods(); }. void TrainAllMethodsForRegression( void ); { TrainAllMethods(); }. Bool_t Verbose( void ); { return fVerbose; }. TDirectory* RootBaseDir(); { return (TDirectory*)fgTargetFile; }. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Kai Voss, Eckhard von Toerne, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id: Factory.h 40012 2011-06-27 16:03:11Z stelzer $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__Factory.html:20503,Optimiz,OptimizeAllMethodsForClassification,20503,root/html530/TMVA__Factory.html,https://root.cern,https://root.cern/root/html530/TMVA__Factory.html,4,['Optimiz'],"['OptimizeAllMethods', 'OptimizeAllMethodsForClassification', 'OptimizeAllMethodsForRegression']"
Performance,"sedObjectsTSeqCollection * fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.Definition TROOT.h:145; TROOT::fTasksTSeqCollection * fTasksList of tasks.Definition TROOT.h:152; TROOT::fClipboardTSeqCollection * fClipboardList of clipboard objects.Definition TROOT.h:163; TROOT::GetGitDateconst char * GetGitDate()Return date/time make was run.Definition TROOT.cxx:2474; TROOT::SetEditorModevoid SetEditorMode(const char *mode="""")Set editor mode.Definition TROOT.cxx:2704; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3115; TROOT::~TROOTvirtual ~TROOT()Clean up and free resources used by ROOT (files, network sockets, shared memory segments,...Definition TROOT.cxx:867; TROOT::fColorsTSeqCollection * fColorsList of colors.Definition TROOT.h:153; TROOT::GetGlobalFunctionWithPrototypeTFunction * GetGlobalFunctionWithPrototype(const char *name, const char *proto=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1718; TROOT::GetListOfBrowsersTSeqCollection * GetListOfBrowsers() constDefinition TROOT.h:245; TROOT::ReadingObjectBool_t ReadingObject() constDeprecated (will be removed in next release).Definition TROOT.cxx:2460; TROOT::fStylesTSeqCollection * fStylesList of styles.Definition TROOT.h:150; TROOT::fVersionDateInt_t fVersionDateDate of ROOT version (ex 951226)Definition TROOT.h:116; TROOT::GetListOfColorsTSeqCollection * GetListOfColors() constDefinition TROOT.h:232; TROOT::MacroLongptr_t Macro(const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE)Execute a macro in the interpreter.Definition TROOT.cxx:2316; TROOT::fBuiltTimeInt_t fBuiltTimeTime of ROOT built.Definition TROOT.h:119; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the inter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:155926,load,load,155926,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['load'],['load']
Performance,"sedObjectsTSeqCollection * fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.Definition TROOT.h:145; TROOT::fTasksTSeqCollection * fTasksList of tasks.Definition TROOT.h:152; TROOT::fClipboardTSeqCollection * fClipboardList of clipboard objects.Definition TROOT.h:163; TROOT::GetGitDateconst char * GetGitDate()Return date/time make was run.Definition TROOT.cxx:2474; TROOT::SetEditorModevoid SetEditorMode(const char *mode="""")Set editor mode.Definition TROOT.cxx:2704; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3119; TROOT::~TROOTvirtual ~TROOT()Clean up and free resources used by ROOT (files, network sockets, shared memory segments,...Definition TROOT.cxx:867; TROOT::fColorsTSeqCollection * fColorsList of colors.Definition TROOT.h:153; TROOT::GetGlobalFunctionWithPrototypeTFunction * GetGlobalFunctionWithPrototype(const char *name, const char *proto=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1718; TROOT::GetListOfBrowsersTSeqCollection * GetListOfBrowsers() constDefinition TROOT.h:245; TROOT::ReadingObjectBool_t ReadingObject() constDeprecated (will be removed in next release).Definition TROOT.cxx:2460; TROOT::fStylesTSeqCollection * fStylesList of styles.Definition TROOT.h:150; TROOT::fVersionDateInt_t fVersionDateDate of ROOT version (ex 951226)Definition TROOT.h:116; TROOT::GetListOfColorsTSeqCollection * GetListOfColors() constDefinition TROOT.h:232; TROOT::MacroLongptr_t Macro(const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE)Execute a macro in the interpreter.Definition TROOT.cxx:2316; TROOT::fBuiltTimeInt_t fBuiltTimeTime of ROOT built.Definition TROOT.h:119; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the inter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:156102,load,load,156102,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['load'],['load']
Performance,"sedvirtual void LineProcessed(const char *line)Emit signal when a line has been processed.Definition TApplication.cxx:1941; TApplication::ClearInputFilesvoid ClearInputFiles()Clear list containing macro files passed as program arguments.Definition TApplication.cxx:318; TApplication::fAppImpTApplicationImp * fAppImpDefinition TApplication.h:60; TApplication::EExitOnExceptionEExitOnExceptionDefinition TApplication.h:51; TApplication::kAbort@ kAbortDefinition TApplication.h:54; TApplication::kExit@ kExitDefinition TApplication.h:53; TApplication::ExecuteFilestatic Longptr_t ExecuteFile(const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE)Execute a file containing a C++ macro (static method).Definition TApplication.cxx:1729; TApplication::InitializeGraphicsvoid InitializeGraphics(Bool_t only_web=kFALSE)Initialize the graphics environment.Definition TApplication.cxx:244; TApplication::Openvirtual void Open()Definition TApplication.h:132; TApplication::LoadGraphicsLibsvirtual void LoadGraphicsLibs()Load shared libs necessary for graphics.Definition TApplication.cxx:1333; TApplication::StopIdleingvirtual void StopIdleing()Called when system stops idleing.Definition TApplication.cxx:1907; TApplication::kProcessRemotely@ kProcessRemotelyDefinition TApplication.h:44; TApplication::kDefaultApplication@ kDefaultApplicationDefinition TApplication.h:45; TApplication::StartIdleingvirtual void StartIdleing()Called when system starts idleing.Definition TApplication.cxx:1896; TApplication::Runvirtual void Run(Bool_t retrn=kFALSE)Main application eventloop. Calls system dependent eventloop via gSystem.Definition TApplication.cxx:1860; TApplication::~TApplicationvirtual ~TApplication()TApplication dtor.Definition TApplication.cxx:210; TApplication::OpenReferenceGuideForvoid OpenReferenceGuideFor(const TString &strippedClass)It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/st...Definition TApplication.cxx:1065; TApplication::Handle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:88181,Load,LoadGraphicsLibsvirtual,88181,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,3,['Load'],"['Load', 'LoadGraphicsLibs', 'LoadGraphicsLibsvirtual']"
Performance,"see our simple world:; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; 18.1.2 Example 2: A Geometrical Hierarchy Look and Feel; Before going further, let us get a look and feel of interacting with the modeller. For this, we will use one of the examples illustrating the geometry package. To get an idea on the geometry structure created in this example, just look at the link: http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html. You will notice that this is a bit more complex that just creating the “world” since several other volumes are created and put together in a hierarchy. The purpose here is just to learn how to interact with a geometry that is already built, but just few hints on the building steps in this example might be useful. The geometry here represents the word ROOT that is replicated in some symmetric manner. You might for instance ask some questions after having a first look:; Q: “OK, I understand the first lines that load the libGeom library and create a geometry manager object. I also recognize from the previous example the following lines creating some materials and media, but what about the geometrical transformations below?”; A: As explained before, the model that we are trying to create is a hierarchy of volumes based on containment. This is accomplished by positioning some volumes inside others. Any volume is an un-positioned object in the sense that it defines only a local frame (matching the one of its shape). In order to fully define the mother-daughter relationship between two volumes one has to specify how the daughter will be positioned inside. This is accomplished by defining a local geometrical transformation of the daughter with respect to the mother coordinate system. These transformations will be subsequently used in the example.; Q: “I see the lines defining the top level volume as in the previous example, but what about the other volumes named REPLICA and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:879621,load,load,879621,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['load']
Performance,"see tutorial math.exampleFunctor.C for an example of using this constructor. This constructor is used only when using CINT.; In compiled mode the template constructor is used and in that case className is not needed. void CreateFromCintClass(const char* name, void* ptr, Double_t xmin, Double_t xmax, Int_t npar, const char* cname, const char* fname); Internal function used to create from TF1 from an interpreter CINT class; with the specified type (className) and member function name (methodName). TF1& operator=(const TF1& rhs); Operator =. ~TF1(); TF1 default destructor. void AbsValue(Bool_t reject = kTRUE); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void Browse(TBrowser* b); Browse. void Copy(TObject& f1) const; Copy this F1 to a new F1.; Note that the cached integral with its related arrays are not copied; (they are also set as transient data members). Double_t Derivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the first derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TF1.html:31506,cache,cached,31506,root/html534/TF1.html,https://root.cern,https://root.cern/root/html534/TF1.html,1,['cache'],['cached']
Performance,"seen by the decompressor.; 63 Long64_t fUnzipObjSize; ///< Uncompressed bytes produced by the decompressor.; 64 Double_t fCompress; ///< Tree compression factor; 65 TString fName; ///< Name of this TTreePerfStats; 66 TString fHostInfo; ///< Name of the host system, ROOT version and date; 67 TFile *fFile; ///<! Pointer to the file containing the Tree; 68 TTree *fTree; ///<! Pointer to the Tree being monitored; 69 TGraphErrors *fGraphIO ; ///< Pointer to the graph with IO data; 70 TGraphErrors *fGraphTime ; ///< Pointer to the graph with timestamp info; 71 TPaveText *fPave; ///< Pointer to annotation pavetext; 72 TStopwatch *fWatch; ///< TStopwatch pointer; 73 TGaxis *fRealTimeAxis; ///< Pointer to TGaxis object showing real-time; 74 TText *fHostInfoText; ///< Graphics Text object with the fHostInfo data; 75 ; 76 std::unordered_map<TBranch*, size_t> fBranchIndexCache; // Cache the index of the branch in the cache's array.; 77 std::vector<std::vector<BasketInfo> > fBasketsInfo; // Details on which baskets was used, cached, 'miss-cached' or read uncached.Browse; 78 ; 79 BasketInfo &GetBasketInfo(TBranch *b, size_t basketNumber);; 80 BasketInfo &GetBasketInfo(size_t bi, size_t basketNumber);; 81 ; 82 void SetFile(TFile *newfile) override {; 83 fFile = newfile;; 84 }; 85 ; 86public:; 87 TTreePerfStats();; 88 TTreePerfStats(const char *name, TTree *T);; 89 ~TTreePerfStats() override;; 90 void Browse(TBrowser *b) override;; 91 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 92 void Draw(Option_t *option="""") override;; 93 void ExecuteEvent(Int_t event, Int_t px, Int_t py) override;; 94 virtual void Finish();; 95 Long64_t GetBytesRead() const override {return fBytesRead;}; 96 virtual Long64_t GetBytesReadExtra() const {return fBytesReadExtra;}; 97 virtual Double_t GetCpuTime() const {return fCpuTime;}; 98 virtual Double_t GetDiskTime() const {return fDiskTime;}; 99 TGraphErrors *GetGraphIO() {return fGraphIO;}; 100 TGraphErrors *GetGraphTime() {return fGraphTime;}; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8h_source.html:3486,cache,cached,3486,doc/master/TTreePerfStats_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html,2,['cache'],['cached']
Performance,"seful in determining a more efficient decomposition of the requested integral. ; Reimplemented from RooAbsReal.; Definition at line 455 of file RooAddModel.cxx. ◆ getCompIntList(). void RooAddModel::getCompIntList ; (; const RooArgSet * ; nset, . const RooArgSet * ; iset, . pRooArgList & ; compIntList, . Int_t & ; code, . const char * ; isetRangeName . ); const. protected . Check if this configuration was created before. ; Definition at line 477 of file RooAddModel.cxx. ◆ getGenerator(). Int_t RooAddModel::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Return pseud-code that indicates if all components can do internal generation (1) or not (0) ; Reimplemented from RooAbsPdf.; Definition at line 663 of file RooAddModel.cxx. ◆ getProjCache(). AddCacheElem * RooAddModel::getProjCache ; (; const RooArgSet * ; nset, . const RooArgSet * ; iset = nullptr . ); const. protected . Retrieve cache element with for calculation of p.d.f value with normalization set nset and integrated over iset in range 'rangeName'. ; If cache element does not exist, create and fill it on the fly. The cache contains suplemental normalization terms (in case not all added p.d.f.s have the same observables), projection integrals to calculated transformed fraction coefficients when a frozen reference frame is provided and projection integrals for similar transformations when a frozen reference range is provided. ; Definition at line 308 of file RooAddModel.cxx. ◆ IsA(). TClass * RooAddModel::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 131 of file RooAddModel.h. ◆ isDirectGenSafe(). bool RooAddModel::isDirectGenSafe ; (; const RooAbsArg & ; arg); const. overridevirtual . Direct generation is safe if all components say so. ; Reimplemented from RooAbsPdf.; Definition at line 646 of file RooAddModel.cxx. ◆ pdfList(). const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:87453,cache,cache,87453,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['cache'],['cache']
Performance,"sel); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfParListList of PARs to be loaded; TProof*fProofProof; TStringfSelNameName of the selector to be run. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TProofBenchRun(); destructor. const char * GetSelName(); { return fSelName; }. const char * GetParList(); { return fParList; }. void SetSelName(const char* sel); { fSelName = sel; }. void SetParList(const char* pars); { fParList = pars; }. void Run(Long64_t nevents, Int_t start = -1, Int_t stop = -1, Int_t step = -1, Int_t ntries = -1, Int_t debug = -1, Int_t draw = -1). void Print(Option_t* option = """") const. » Author: Sangsu Ryu 22/06/2010 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-03-14 16:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofBenchRun.html:5718,load,loaded,5718,root/html534/TProofBenchRun.html,https://root.cern,https://root.cern/root/html534/TProofBenchRun.html,1,['load'],['loaded']
Performance,"selector needs to initialize; // a new tree or chain. Typically here the branch addresses and branch; // pointers of the tree will be set.; // It is normally not necessary to make changes to the generated; // code, but the routine can be extended by the user if needed.; // Init() will be called many times when running on PROOF; // (once per file to be processed).;  ; // Associate the reader and the tree; fReader.SetTree(tree);; };  ; void TutorialSelector::SlaveBegin(TTree *tree); {; // SlaveBegin() is a good place to create histograms.; // For PROOF, this is called for each worker.; // The TTree* is there for backward compatibility; e.g. PROOF passes 0.;  ; fEff = new TEfficiency(""eff"", ""Moun trigger efficiency"", 100, 0., 10.);; // Add to output list (needed for PROOF); GetOutputList()->Add(fEff);; };  ; Bool_t TutorialSelector::Process(Long64_t entry); {; // The Process() function is called for each entry in the tree to be; // processed. The entry argument specifies which entry in the currently; // loaded tree is to be processed.; // It can be passed to either EventSelector::GetEntry() or TBranch::GetEntry(); // to read either all or the required parts of the TTree.; //; // This function should contain the ""body"" of the analysis: select relevant; // tree entries, run algorithms on the tree entry and typically fill histograms.;  ; // *** 1. *** Tell the reader to load the data for this entry:; fReader.SetEntry(entry);;  ; // *** 2. *** Do the actual analysis; int tagMuon = gRandom->Integer(fRaPt.GetSize());;  ; if (fRaTriggered[tagMuon]) {; for (int iMuon = 0, nMuons = fRaPt.GetSize(); iMuon < nMuons; ++iMuon) {; // All but the tag muon can be probe muons; if (iMuon != tagMuon) {; 	 // Fill the efficiency object with; 	 // - whether this muon has triggered; 	 // - the pT of this muon.; 	 fEff->Fill(fRaTriggered[iMuon], fRaPt[iMuon]);; }; }; };  ; return kTRUE;; };  ; void TutorialSelector::Terminate(); {; // The Terminate() function is the last function to be calle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/tutorialselectorc.html:4599,load,loaded,4599,d/tutorialselectorc.html,https://root.cern,https://root.cern/d/tutorialselectorc.html,1,['load'],['loaded']
Performance,"sename(macro).h or .hh, is also uploaded. The default is to load the macro also on the client; notOnClient can be used to avoid loading on the client. On masters, if uniqueWorkers is kTRUE, the macro is loaded on unique workers only, and collection is not done; if uniqueWorkers is kFALSE, collection from the previous request is done, and broadcasting + collection from the other workers is done. The wrks arg can be used on the master to limit the set of workers. Returns 0 in case of success and -1 in case of error. ; Reimplemented in TProofLite.; Definition at line 8628 of file TProof.cxx. ◆ LoadPackage(). Int_t TProof::LoadPackage ; (; const char * ; package, . Bool_t ; notOnClient = kFALSE, . TList * ; loadopts = 0, . TList * ; workers = 0 . ). private . Load specified package. ; Executes the PROOF-INF/SETUP.C script on all active nodes. If notOnClient = true, don't load package on the client. The default is to load the package also on the client. The argument 'loadopts' specify a list of objects to be passed to the SETUP. The objects in the list must be streamable; the SETUP macro will be executed like this: SETUP.C(loadopts). Returns 0 in case of success and -1 in case of error. ; Definition at line 8069 of file TProof.cxx. ◆ LogMessage(). void TProof::LogMessage ; (; const char * ; msg, . Bool_t ; all . ). Log a message into the appropriate window by emitting a signal. ; Definition at line 6414 of file TProof.cxx. ◆ LogViewer(). void TProof::LogViewer ; (; const char * ; url = 0, . Int_t ; sessionidx = 0 . ). static . Start the log viewer window usign the plugin manager. ; Definition at line 12470 of file TProof.cxx. ◆ MakePlayer(). TVirtualProofPlayer * TProof::MakePlayer ; (; const char * ; player = 0, . TSocket * ; s = 0 . ). protectedvirtual . Construct a TProofPlayer object. ; The player string specifies which player should be created: remote, slave, sm (supermaster) or base. Default is remote. Socket is needed in case a slave player is created. ; Reimplemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:115250,load,loadopts,115250,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['load'],['loadopts']
Performance,"sent the size of column columnname, and are not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an Alias(): df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""}). Example usage:; Types and columns specified: auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; double; Types inferred and columns specified (this invocation relies on jitting): auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; Types inferred and columns selected with a regexp (this invocation relies on jitting): auto cache_all_cols_df = df.Cache(myRegexp);. Definition at line 1459 of file RInterface.hxx. ◆ Cache() [2/4]. template<typename Proxied , typename DataSource = void> . RInterface< RLoopManager > ROOT::RDF::RInterface< Proxied, DataSource >::Cache ; (; const ColumnNames_t & ; columnList). inline . Save selected columns in memory. ; Parameters. [in]columnListcolumns to be cached in memory . Returnsa RDataFrame that wraps the cached dataset.; See the previous overloads for more information. ; Definition at line 1471 of file RInterface.hxx. ◆ Cache() [3/4]. template<typename Proxied , typename DataSource = void> . RInterface< RLoopManager > ROOT::RDF::RInterface< Proxied, DataSource >::Cache ; (; std::initializer_list< std::string > ; columnList). inline . Save selected columns in memory. ; Parameters. [in]columnListcolumns to be cached in memory. . Returnsa RDataFrame that wraps the cached dataset.; See the previous overloads for more information. ; Definition at line 1546 of file RInterface.hxx. ◆ Cache() [4/4]. template<typename Proxied , typename DataSource = void> . RInterface< RLoopManager > ROOT::RDF::RInterface< Proxied, DataSource >::Cache ; (; std::string_view ; columnNameRegexp = """"). inline . Save selected columns in memory. ; Parameters. [in]columnNameRegexpThe regular expression to match the column names to be selected. The presence of a '^' and a '$' at the end of the string is impli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:43703,cache,cached,43703,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['cache'],['cached']
Performance,"sequence is that now when an object is stored in a split branch the rule is associtated with the branch of the last of the rule’s sources rather than the last of the object’s data member.; Properly support TStreamerInfo written by ROOT v4.00.; Fix the ordering of the keys in a TFile being written; in particular fixing the result of GetKey and FindKey which were no longer returning the lastest cycle for a TFile being written since v5.34/11. Networking Libraries; HTTP Server; Command Interface; One can now register an arbitrary command to the server, which become visible in the web browser. Then, when the item is clicked by the user, the command ends-up in a gROOT->ProcessLineSync() call.; Custom Properties; Custom properties can be configured for any item in the server. For example, one could configure an icon for each item visible in the browser. Or one could ‘hide’ any item from the user (but keep access with normal http requests). With such properties one could specify which item is drawn when web page is loaded, or configure monitoring. See tutorials/http/httpcontrol.C macro for more details.; Method Calls; Implement exe.json requests to be able to execute any method of registered objects. This request is used to provide remote TTree::Draw() functionality.; Misc; Correctly set ‘Cache-Control’ headers when replying to http requests. Better support of STL containers when converting objects into json with TBufferJSON class.; JavaScript ROOT. Several files can now be loaded simultaneously; Use d3.time.scale to display time scales; Implemented drag and drop to superimpose histograms or graphs; Allow selection of drawing option via context menu; Better support of touch devices; Provide simple layout, making it default; Allow to open ROOT files in online session (via url parameter); One could monitor simultaneously objects from server and root files; Implement ‘autocol’ draw option - when superimposing histograms, their line colors will be automatically assigned; Impleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:9276,load,loaded,9276,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['load'],['loaded']
Performance,"ser function accessing the TTree data directly; If the formula contains a file name, TTree::MakeProxy will be used to load and execute this file. In particular it will draw the result of a function with the same name as the file. The function will be executed in a context where the name of the branches can be used as a C++ variable.; For example draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; hsimpleDefinition hsimple.py:1; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; Drawth1 Draw(); A more complete example is available in the tutorials directory: h1analysisProxy.cxx, h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C; The main features of this facility are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bound; ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram; In case of a 2-Dim expression, one can generate a TProfile histogram instead of a TH2F histogram by specifying option=prof or option=profs or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of y:x>>pf where pf is an existing TProfile histogram. Making a 2D Profile histogram; In case of a 3-Dim expression, one can generate a TProfile2D histogram instead of a TH3F histogram by specifying option=prof or option=profs. or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of z:y:x>>pf where pf is an existing TProf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:128137,load,loading,128137,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['load'],['loading']
Performance,"serData.cxx:43; ROOT::RBrowserDataCleanup::fDataRBrowserData & fDataDefinition RBrowserData.cxx:45; ROOT::RBrowserDataCleanup::RBrowserDataCleanupRBrowserDataCleanup(RBrowserData &_data)Definition RBrowserData.cxx:48; ROOT::RBrowserDataCleanup::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from a list.Definition RBrowserData.cxx:50; ROOT::RBrowserDataWay to browse (hopefully) everything in ROOT.Definition RBrowserData.hxx:37; ROOT::RBrowserData::SetTopElementvoid SetTopElement(std::shared_ptr< Browsable::RElement > elem)set top element for browsingDefinition RBrowserData.cxx:88; ROOT::RBrowserData::fLastSortedItemsstd::vector< const Browsable::RItem * > fLastSortedItems! sorted child items, used in requestsDefinition RBrowserData.hxx:51; ROOT::RBrowserData::fWorkingPathBrowsable::RElementPath_t fWorkingPath! path showed in BreadcrumbDefinition RBrowserData.hxx:43; ROOT::RBrowserData::RemoveFromCachebool RemoveFromCache(void *obj)Remove object from cache If nullptr specified - removes no-longer-valid elements Returns true if any ...Definition RBrowserData.cxx:380; ROOT::RBrowserData::GetSubElementstd::shared_ptr< Browsable::RElement > GetSubElement(const Browsable::RElementPath_t &path)Returns sub-element starting from top, using cached data.Definition RBrowserData.cxx:308; ROOT::RBrowserData::fCachestd::vector< std::pair< Browsable::RElementPath_t, std::shared_ptr< Browsable::RElement > > > fCache! already requested elementsDefinition RBrowserData.hxx:45; ROOT::RBrowserData::fCleanupHandlestd::unique_ptr< TObject > fCleanupHandle! cleanup handle for RecursiveRemoveDefinition RBrowserData.hxx:54; ROOT::RBrowserData::DecomposePathBrowsable::RElementPath_t DecomposePath(const std::string &path, bool relative_to_work_element)Decompose path to elements Returns array of names for each element in the path, first element either ...Definition RBrowserData.cxx:155; ROOT::RBrowserData::fLastAllChildsbool fLastAllChilds! if all chlds w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBrowserData_8cxx_source.html:15948,cache,cache,15948,doc/master/RBrowserData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html,2,['cache'],['cache']
Performance,"sert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t CheckCachePath(const char* ); Validate the input file cache path. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). TMutex* GetMutexSynch() const; { return fMutexSynch; }. » Author: Elvin Sindrilaru 19/05/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TFilePrefetch.h 41698 2011-11-01 21:22:54Z pcanal $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFilePrefetch.html:7985,cache,cache,7985,root/html532/TFilePrefetch.html,https://root.cern,https://root.cern/root/html532/TFilePrefetch.html,5,['cache'],['cache']
Performance,"sert(clinfo);; 3840 }; 3841 }; 3842 }; 3843 }; 3844 ; 3845 // Write the StreamerInfo list even if it is empty.; 3846 fClassIndex->fArray[0] = 2; //to prevent adding classes in TStreamerInfo::TagFile; 3847 ; 3848 if (listOfRules.GetEntries()) {; 3849 // Only add the list of rules if we have something to say.; 3850 list.Add(&listOfRules);; 3851 }; 3852 ; 3853 //free previous StreamerInfo record; 3854 if (fSeekInfo) MakeFree(fSeekInfo,fSeekInfo+fNbytesInfo-1);; 3855 //Create new key; 3856 TKey key(&list,""StreamerInfo"",GetBestBuffer(), this);; 3857 fKeys->Remove(&key);; 3858 fSeekInfo = key.GetSeekKey();; 3859 fNbytesInfo = key.GetNbytes();; 3860 SumBuffer(key.GetObjlen());; 3861 key.WriteFile(0);; 3862 ; 3863 fClassIndex->fArray[0] = 0;; 3864 ; 3865 list.RemoveLast(); // remove the listOfRules.; 3866}; 3867 ; 3868////////////////////////////////////////////////////////////////////////////////; 3869/// Open a file for reading through the file cache.; 3870///; 3871/// The file will be downloaded to the cache and opened from there.; 3872/// If the download fails, it will be opened remotely.; 3873/// The file will be downloaded to the directory specified by SetCacheFileDir().; 3874 ; 3875TFile *TFile::OpenFromCache(const char *name, Option_t *, const char *ftitle,; 3876 Int_t compress, Int_t netopt); 3877{; 3878 TFile *f = nullptr;; 3879 ; 3880 if (fgCacheFileDir == """") {; 3881 ::Warning(""TFile::OpenFromCache"",; 3882 ""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:140714,cache,cache,140714,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"serted in a TList. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TSeqCollection.h""; 26#include ""TString.h""; 27 ; 28#include <iterator>; 29#include <memory>; 30 ; 31const Bool_t kSortAscending = kTRUE;; 32const Bool_t kSortDescending = !kSortAscending;; 33 ; 34class TObjLink;; 35class TListIter;; 36 ; 37 ; 38class TList : public TSeqCollection {; 39 ; 40friend class TListIter;; 41 ; 42protected:; 43 using TObjLinkPtr_t = std::shared_ptr<TObjLink>;; 44 using TObjLinkWeakPtr_t = std::weak_ptr<TObjLink>;; 45 ; 46 TObjLinkPtr_t fFirst; //! pointer to first entry in linked list; 47 TObjLinkPtr_t fLast; //! pointer to last entry in linked list; 48 TObjLinkWeakPtr_t fCache; //! cache to speedup sequential calling of Before() and After() functions; 49 Bool_t fAscending; //! sorting order (when calling Sort() or for TSortedList); 50 ; 51 TObjLink *LinkAt(Int_t idx) const;; 52 TObjLink *FindLink(const TObject *obj, Int_t &idx) const;; 53 ; 54 TObjLinkPtr_t *DoSort(TObjLinkPtr_t *head, Int_t n);; 55 ; 56 Bool_t LnkCompare(const TObjLinkPtr_t &l1, const TObjLinkPtr_t &l2);; 57 TObjLinkPtr_t NewLink(TObject *obj, const TObjLinkPtr_t &prev = nullptr);; 58 TObjLinkPtr_t NewOptLink(TObject *obj, Option_t *opt, const TObjLinkPtr_t &prev = nullptr);; 59 TObjLinkPtr_t NewLink(TObject *obj, TObjLink *prev);; 60 TObjLinkPtr_t NewOptLink(TObject *obj, Option_t *opt, TObjLink *prev);; 61 // virtual void DeleteLink(TObjLink *lnk);; 62 ; 63 void InsertAfter(const TObjLinkPtr_t &newlink, const TObjLinkPtr_t &prev);; 64 ; 65private:; 66 TList(const TList&) = delete;; 67 TList& operator=(const TList&) = delete;; 68 ; 69public:; 70 typedef TListIter Iterator_t;; 71 ; 72 TList() : fAscending(kTRUE) { }; 73 ; 74 TList(TObject *) R__DEPRECATED(6, 34, ""The argument is ignored. Use the default constructor TList::TList()."") : fAscending(kTRUE) { } // for backward compatibility, don't use; 75 ; 76 virtual ~TList();; 77 void Clear(Option_t *op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8h_source.html:1601,cache,cache,1601,doc/master/TList_8h_source.html,https://root.cern,https://root.cern/doc/master/TList_8h_source.html,1,['cache'],['cache']
Performance,"servableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsCachedReal&operator=(const RooAbsCachedReal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedReal.html:20117,optimiz,optimizeCacheMode,20117,root/html602/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html,2,['optimiz'],['optimizeCacheMode']
Performance,"servableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsHiddenReal&operator=(const RooAbsHiddenReal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsHiddenReal.html:19675,optimiz,optimizeCacheMode,19675,root/html602/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html,2,['optimiz'],['optimizeCacheMode']
Performance,"servableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooChangeTracker&operator=(const RooChangeTracker&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); RooArgSetparameters() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChangeTracker.html:19815,optimiz,optimizeCacheMode,19815,root/html602/RooChangeTracker.html,https://root.cern,https://root.cern/root/html602/RooChangeTracker.html,2,['optimiz'],['optimizeCacheMode']
Performance,"servableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooConstraintSum&operator=(const RooConstraintSum&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConstraintSum.html:19517,optimiz,optimizeCacheMode,19517,root/html602/RooConstraintSum.html,https://root.cern,https://root.cern/root/html602/RooConstraintSum.html,2,['optimiz'],['optimizeCacheMode']
Performance,"servableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooFracRemainder&operator=(const RooFracRemainder&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFracRemainder.html:19450,optimiz,optimizeCacheMode,19450,root/html602/RooFracRemainder.html,https://root.cern,https://root.cern/root/html602/RooFracRemainder.html,2,['optimiz'],['optimizeCacheMode']
Performance,"servableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooMultiBinomial&operator=(const RooMultiBinomial&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiBinomial.html:19817,optimiz,optimizeCacheMode,19817,root/html602/RooMultiBinomial.html,https://root.cern,https://root.cern/root/html602/RooMultiBinomial.html,2,['optimiz'],['optimizeCacheMode']
Performance,"servableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooNumRunningInt&operator=(const RooNumRunningInt&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumRunningInt.html:19957,optimiz,optimizeCacheMode,19957,root/html602/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html602/RooNumRunningInt.html,2,['optimiz'],['optimizeCacheMode']
Performance,"servableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooParamHistFunc&operator=(const RooParamHistFunc&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooParamHistFunc.html:19260,optimiz,optimizeCacheMode,19260,root/html602/RooParamHistFunc.html,https://root.cern,https://root.cern/root/html602/RooParamHistFunc.html,2,['optimiz'],['optimizeCacheMode']
Performance,"servableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooUnblindOffset&operator=(const RooUnblindOffset&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindOffset.html:19793,optimiz,optimizeCacheMode,19793,root/html602/RooUnblindOffset.html,https://root.cern,https://root.cern/root/html602/RooUnblindOffset.html,2,['optimiz'],['optimizeCacheMode']
Performance,"servables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Interface function to create an internal cache object that represent; each cached function configuration. This interface allows to create and; return a class derived from RooAbsCachedReal::FuncCacheElem so that; a derived class fillCacheObject implementation can utilize extra functionality; defined in such a derived cache class. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Update contents of cache histogram by resampling the input function. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. void operModeHook(). RooCachedReal(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooCachedReal(*this,newname); }. void setCdfBoundaries(Bool_t flag); If flag is true the RooHistFunc that rep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedReal.html:38873,cache,cacheFunc,38873,root/html534/RooCachedReal.html,https://root.cern,https://root.cern/root/html534/RooCachedReal.html,4,['cache'],"['cache', 'cacheFunc']"
Performance,"servables of the function. RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Update contents of cache histogram by resampling the input function. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. RooCachedReal(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooCachedReal(*this,newname); }. void setCdfBoundaries(Bool_t flag); If flag is true the RooHistFunc that represent the cache hist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCachedReal.html:35739,cache,cacheFunc,35739,root/html530/RooCachedReal.html,https://root.cern,https://root.cern/root/html530/RooCachedReal.html,4,['cache'],"['cache', 'cacheFunc']"
Performance,"servables of the function. RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Update contents of cache histogram by resampling the input function. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. RooCachedReal(); {}. TObject* clone(const char* newname) const; { return new RooCachedReal(*this,newname); }. void setCdfBoundaries(Bool_t flag); If flag is true the RooHistFunc that represent the cache histogram; will use spe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedReal.html:34933,cache,cacheFunc,34933,root/html526/RooCachedReal.html,https://root.cern,https://root.cern/root/html526/RooCachedReal.html,4,['cache'],"['cache', 'cacheFunc']"
Performance,"servables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealMPFE.html:36002,cache,cache,36002,doc/master/classRooRealMPFE.html,https://root.cern,https://root.cern/doc/master/classRooRealMPFE.html,1,['cache'],['cache']
Performance,"servables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:39372,cache,cache,39372,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['cache'],['cache']
Performance,"served from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; bool areIdentical (const RooDataHist &dh1, const RooDataHist &dh2);  ; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; double evaluate () const override;  Return the current value: The value of the bin enclosing the current coordinates of the dependents, normalized by the histograms contents. ;  ; bool importWorkspaceHook (RooWorkspace &ws) override;  Check if our datahist is already in the workspace. ;  ; void ioStreamerPass2 () override;  Schema evolution: if histObsList wasn't filled from persistence (v1) then fill it here. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:50154,cache,cached,50154,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,2,['cache'],"['cache', 'cached']"
Performance,"server socket (unless we will use it; // later to wait for another connection).; ss->Close();. TMonitor *mon = new TMonitor;; mon->Add(s0);; mon->Add(s1);. while (1) {; TMessage *mess;; TSocket *s;; s = mon->Select();; s->Recv(mess);; ...; }; }; The full code for the example above is in $ROOTSYS/tutorials/net/hserv.C and; $ROOTSYS/tutorials/net/hclient.C.; 23 Threads; A thread is an independent flow of control that operates within the same address space as other independent flows of controls within a process. In most UNIX systems, thread and process characteristics are grouped into a single entity called a process. Sometimes, threads are called ""lightweight processes’’.; Note: This introduction is adapted from the AIX 4.3 Programmer’s Manual.; 23.1 Threads and Processes; In traditional single-threaded process systems, a process has a set of properties. In multi-threaded systems, these properties are divided between processes and threads.; 23.1.1 Process Properties; A process in a multi-threaded system is the changeable entity. It must be considered as an execution frame. It has all traditional process attributes, such as:. Process ID, process group ID, user ID, and group ID; Environment; Working directory. A process also provides a common address space and common system resources:. File descriptors; Signal actions; Shared libraries; Inter-process communication tools (such as message queues, pipes, semaphores, or shared memory). 23.1.2 Thread Properties; A thread is the schedulable entity. It has only those properties that are required to ensure its independent flow of control. These include the following properties:. Stack; Scheduling properties (such as policy or priority); Set of pending and blocked signals; Some thread-specific data (TSD). An example of thread-specific data is the error indicator, errno. In multi-threaded systems, errno is no longer a global variable, but usually a subroutine returning a thread-specific errno value. Some other systems may provide",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1101590,multi-thread,multi-threaded,1101590,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['multi-thread'],['multi-threaded']
Performance,"server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache ()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealMPFE.html:35642,Cache,CacheMode,35642,doc/master/classRooRealMPFE.html,https://root.cern,https://root.cern/doc/master/classRooRealMPFE.html,2,"['Cache', 'cache']","['CacheMode', 'cache']"
Performance,"server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:39012,Cache,CacheMode,39012,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,2,"['Cache', 'cache']","['CacheMode', 'cache']"
Performance,"ses; A user’s own classes can be accessed after loading, either directly or indirectly, the library that contains the dictionary. One easy way of obtaining such a library, is by using ACLiC:; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; Then you can use it, for example, like so:; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); You can also load a macro directly, but if you do not use ACLiC, you will be restricted to use the default constructor of your class, which is otherwise fully functional. For example:; from ROOT import gROOT. # load MyClass definition macro (append '+' to use ACLiC); gROOT.LoadMacro('MyClass.C'). # get MyClass from ROOT; from ROOT import MyClass. # use MyClass; m = MyClass(); m.SetValue(42); print(m.GetValue()); 20 The Tutorials and Tests; This chapter is a guide to the examples that come with the installation of ROOT. They are located in two directories: $ROOTSYS/tutorials and $ROOTSYS/test.; 20.1 $ROOTSYS/tutorials. The tutorials directory contains many example scripts. To have all examples working you must have write permission and you will need to executehsimple.C first. If you do not have write permission in the directory$ROOTSYS/tutorials, copy the entire directory to your area. The script hsimple.C displays a histogram as it is being filled, and creates a ROOT file used by the other examples.; To execute it type:; $ cd $ROOTSYS/tutorials; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1073556,load,load,1073556,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['load']
Performance,"set in range named rangeName with integrand normalized over observables in nset. ; Definition at line 211 of file RooAbsReal.h. ◆ createIntegral() [3/6]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooArgSet & ; nset, . const RooNumIntConfig & ; cfg, . const char * ; rangeName = nullptr . ); const. inline . Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while using specified configuration for any numeric integration. ; Definition at line 216 of file RooAbsReal.h. ◆ createIntegral() [4/6]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooArgSet * ; nset = nullptr, . const RooNumIntConfig * ; cfg = nullptr, . const char * ; rangeName = nullptr . ); const. virtual . Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the return object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over. If nset is specified the integrand is request to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified the integral is performed over the named range, otherwise it is performed over the domain of each integrated observable. If cfg is specified it will be used to configure any numeric integration aspect of the integral. It will not force the integral to be performed numerically, which is decided automatically by RooRealIntegral. ; Reimplemented in RooAbsRealLValue, RooBinSamplingPdf, and RooRealIntegral.; Definition at line 551 of file RooAbsReal.cxx. ◆ createIntegral() [5/6]. RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:88298,perform,performed,88298,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['perform'],['performed']
Performance,"set in range named rangeName with integrand normalized over observables in nset. ; Definition at line 211 of file RooAbsReal.h. ◆ createIntegral() [3/6]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooArgSet & ; nset, . const RooNumIntConfig & ; cfg, . const char * ; rangeName = nullptr . ); const. inline . Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while using specified configuration for any numeric integration. ; Definition at line 216 of file RooAbsReal.h. ◆ createIntegral() [4/6]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooArgSet * ; nset = nullptr, . const RooNumIntConfig * ; cfg = nullptr, . const char * ; rangeName = nullptr . ); const. virtual . Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the return object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over. If nset is specified the integrand is request to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified the integral is performed over the named range, otherwise it is performed over the domain of each integrated observable. If cfg is specified it will be used to configure any numeric integration aspect of the integral. It will not force the integral to be performed numerically, which is decided automatically by RooRealIntegral. ; Reimplemented in RooAbsRealLValue, RooBinSamplingPdf, and RooRealIntegral.; Definition at line 553 of file RooAbsReal.cxx. ◆ createIntegral() [5/6]. RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:87030,perform,performed,87030,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['perform'],['performed']
Performance,set of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsOptTestStatistic.html:38723,cache,cache,38723,root/html602/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html,2,['cache'],['cache']
Performance,"set the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPluginHandler::LoadPluginInt_t LoadPlugin()Load the plugin library for this handler.Definition TPluginManager.cxx:293; TSpline3Class to create third splines to interpolate knots Arbitrary conditions can be introduced for first a...Definition TSpline.h:182; TSpline3::EvalDouble_t Eval(Double_t x) const overrideEval this spline at x.Definition TSpline.cxx:786; TSplineBase class for spline implementation containing the Draw/Paint methods.Definition TSpline.h:31; TSpline::Evalvirtual Double_t Eval(Double_t x) const =0; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::EndsWithBool_t EndsWith(const char *pat, ECaseCompare cmp=kExact) constReturn true if string ends with the specified string.Definition TString.cxx:2244; TString::AtofDouble_t Atof() constReturn floating-point value c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:132776,Load,LoadPlugin,132776,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,2,['Load'],"['Load', 'LoadPlugin']"
Performance,"set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_t * fBSeekLen;  [fBNseek] ;  ; Int_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:29236,cache,cache,29236,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,4,['cache'],['cache']
Performance,"set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyrlife; RooRealProxyrsf; RooRealProxysigma; RooRealProxyssf; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGExpModel.html:45950,cache,cache,45950,root/html534/RooGExpModel.html,https://root.cern,https://root.cern/root/html534/RooGExpModel.html,1,['cache'],['cache']
Performance,"set) const override;  Parameters of the cache. ;  ; PdfCacheElem * createCache (const RooArgSet *nset) const override;  Create and return a derived MorphCacheElem. ;  ; double evaluate () const override;  Dummy. ;  ; void fillCacheObject (PdfCacheElem &cache) const override;  Fill the cache with the interpolated shape. ;  ; const char * inputBaseName () const override;  Return base name component for cache components in this case a string encoding the names of both end point p.d.f.s. ;  ;  Protected Member Functions inherited from RooAbsCachedPdf; virtual const char * binningName () const;  ; std::string cacheNameSuffix (const RooArgSet &nset) const;  Construct string with unique suffix for cache objects based on observable names that define cache configuration. ;  ; void disableCache (bool flag);  ; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; PdfCacheElem * getCache (const RooArgSet *nset, bool recalculate=true) const;  Retrieve cache object associated with given choice of observables. ;  ; virtual TString histNameSuffix () const;  ; virtual const char * payloadUniqueSuffix () const;  ; virtual RooAbsArg & pdfObservable (RooAbsArg &histObservable) const;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooIntegralMorph.html:65843,cache,cache,65843,doc/master/classRooIntegralMorph.html,https://root.cern,https://root.cern/doc/master/classRooIntegralMorph.html,1,['cache'],['cache']
Performance,"set, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor; cout << ""deleting dataset "" << this << endl ;. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsData.html:13805,cache,cached,13805,root/html530/RooAbsData.html,https://root.cern,https://root.cern/root/html530/RooAbsData.html,2,['cache'],['cached']
Performance,"set, the automatically generated Streamercan call directly the method TClass::WriteBuffer. Bypassing the Streamer improves the performance when writing/reading the objects in the TClonesArray. However, the drawback is when a TClonesArray is written with split=0 bypassing the Streamer, the StreamerInfoof the class in the array being optimized, one cannot later use the TClonesArray with split > 0. For example, there is a problem with the following scenario: a class Foo has a TClonesArray of Bar objects the Foo object is written with split=0 to Tree T1. In this case the StreamerInfo for the class Bar is created in optimized mode in such a way that data members of the same type are written as an array improving the I/O performance. In a new program, T1 is read and a new Tree T2 is created with the object Foo in split > 1.; When the T2branch is created, the StreamerInfo for the class Bar is created with no optimization (mandatory for the split mode). The optimized Bar StreamerInfo is going to be used to read the TClonesArray in T1. The result will be Bar objects with data member values not in the right sequence. The solution to this problem is to call BypassStreamer(kFALSE) for the TClonesArray. In this case, the normal Bar::Streamer function will be called. The Bar::Streamer function works OK independently if the Bar StreamerInfohad been generated in optimized mode or not.; 11.4 Pointers and References in Persistency; An object pointer as a data member presents a challenge to the streaming software. If the object pointed to is saved every time, it could create circular dependencies and consume a large amount of disk space. The network of references must be preserved on disk and recreated upon reading the file.; If you use independent I/O operations for pointers and their referenced objects you can use the TRef class. Later in this section is an example that compares disk space, memory usage, and I/O times of C++ pointers and TRefs. In general, a TRef is faster than C++ b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:477779,optimiz,optimized,477779,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimized']
Performance,"set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetSet of parameters to which constraints apply; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of constraint terms; TIterator*_setIter1! do not persist; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooConstraintSum.html:32871,cache,cache,32871,root/html530/RooConstraintSum.html,https://root.cern,https://root.cern/root/html530/RooConstraintSum.html,1,['cache'],['cache']
Performance,"set; static TDictionary::ESTLTypeTDictionary::kUnorderedSet; static TDictionary::ESTLTypeTDictionary::kVector; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TClass*fClass!pointer to parent class; TClassReffClassPtrpointer to the base class TClass; Int_tfDeltaBaseClassInfo_t offset (INT_MAX if unset); BaseClassInfo_t*fInfo!pointer to CINT base class info; Int_tfPropertyBaseClassInfo_t's properties; Int_tfSTLTypecache of IsSTLContainer(). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBaseClass(BaseClassInfo_t* info = 0, TClass* cl = 0); Default TBaseClass ctor. TBaseClasses are constructed in TClass; via a call to TCling::CreateListOfBaseClasses(). ~TBaseClass(); TBaseClass dtor deletes adopted CINT BaseClassInfo object. void Browse(TBrowser* b); Called by the browser, to browse a baseclass. TClass * GetClassPointer(Bool_t load = kTRUE); Get pointer to the base class TClass. Int_t GetDelta(); Get offset from ""this"" to part of base class. const char * GetTitle() const; Get base class description (comment). ROOT::ESTLType IsSTLContainer(); Return which type (if any) of STL container the data member is. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void Streamer(TBuffer& ); Stream an object of TBaseClass. Triggers the calculation of the; cache variables to store them. TBaseClass(const TBaseClass& ). TBaseClass& operator=(const TBaseClass& ). Bool_t IsFolder() const; {return kTRUE;}. void SetClass(TClass* cl); { fClass = cl; }. » Author: Fons Rademakers 08/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TBaseClass.html:8066,load,load,8066,root/html604/TBaseClass.html,https://root.cern,https://root.cern/root/html604/TBaseClass.html,2,"['cache', 'load']","['cache', 'load']"
Performance,"set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsHiddenReal.html:33347,cache,cache,33347,root/html534/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html,4,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsSelfCachedPdf.html:38253,cache,cache,38253,root/html526/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsSelfCachedPdf.html,4,['cache'],['cache']
Performance,"set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedReal::_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsSelfCachedReal.html:31618,cache,cache,31618,root/html526/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsSelfCachedReal.html,12,['cache'],['cache']
Performance,"set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; static RooCategory*RooAbsHiddenReal::_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindCPAsymVar.html:35493,cache,cache,35493,root/html602/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html602/RooUnblindCPAsymVar.html,32,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TMatrixDSym_cov; TMatrixDSym_covI; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Double_t_det; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; map<int,RooMultiVarGaussian::GenData>_genCache!; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiVarGaussian.html:42425,cache,cache,42425,root/html602/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html602/RooMultiVarGaussian.html,2,['cache'],['cache']
Performance,"setErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetErrorTolerance(Double_t t); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidSetForceSum(Bool_t flag); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidSetMaxIters(Int_t mi); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNonCentralChiSquare.html:28356,cache,cache,28356,root/html528/RooNonCentralChiSquare.html,https://root.cern,https://root.cern/root/html528/RooNonCentralChiSquare.html,1,['cache'],['cache']
Performance,set] : Elapsed time for evaluation of 4000 events: 0.105 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : ␛[1mEvaluate all methods␛[0m; : Evaluate multiclass classification method: BDTG; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_BDTG : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.070153 1.0224 [ -4.0592 3.5808 ]; : var2: 0.30372 1.0460 [ -3.6952 3.7877 ]; : var3: 0.12152 1.1222 [ -3.6800 3.9200 ]; : var4: -0.072602 1.2766 [ -4.8486 4.2221 ]; : -----------------------------------------------------------; : Evaluate multiclass classification method: MLP; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_MLP : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.070153 1.0224 [ -4.0592 3.5808 ]; : var2: 0.30372 1.0460 [ -3.6952 3.7877 ]; : var3: 0.12152 1.1222 [ -3.6800 3.9200 ]; : var4: -0.072602 1.2766 [ -4.8486 4.2221 ]; : -----------------------------------------------------------; : Evaluate multiclass classification method: PDEFoam; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_PDEFoam : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.070153 1.0224 [ -4.0592 3.5808 ]; : var2: 0.30372 1.0460 [ -3.6952 3.7877 ]; : var3: 0.12152 1.1222 [ -3.6800 3.9200 ]; : var4: -0.072602 1.2766 [ -4.8486 4.2221 ]; : -----------------------------------------------------------; : Evaluate multiclass classif,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:21655,perform,performance,21655,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['perform'],['performance']
Performance,"sets;  ; TTreeReader * fTreeReader;  Tree reader we belong to. ;  . #include <TTreeReaderValue.h>. Inheritance diagram for TTreeReaderValue< T >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ NonConstT_t. template<typename T > . using TTreeReaderValue< T >::NonConstT_t = typename std::remove_const<T>::type. Definition at line 178 of file TTreeReaderValue.h. Constructor & Destructor Documentation. ◆ TTreeReaderValue() [1/2]. template<typename T > . TTreeReaderValue< T >::TTreeReaderValue ; (; ). delete . ◆ TTreeReaderValue() [2/2]. template<typename T > . TTreeReaderValue< T >::TTreeReaderValue ; (; TTreeReader & ; tr, . const char * ; branchname . ). inline . Definition at line 180 of file TTreeReaderValue.h. Member Function Documentation. ◆ Get(). template<typename T > . T * TTreeReaderValue< T >::Get ; (; ). inline . Return a pointer to the value of the current entry. ; Return a nullptr and print an error if no entry has been loaded yet. The returned address is guaranteed to stay constant while a given TTree is being read from a given file, unless the branch addresses are manipulated directly (e.g. through TTree::SetBranchAddress()). The address might also change when the underlying TTree/TFile is switched, e.g. when a TChain switches files. ; Definition at line 189 of file TTreeReaderValue.h. ◆ GetDerivedTypeName(). template<typename T > . const char * TTreeReaderValue< T >::GetDerivedTypeName ; (; ); const. inlineoverrideprotectedvirtual . Get the template argument as a string. ; Implements ROOT::Internal::TTreeReaderValueBase.; Definition at line 211 of file TTreeReaderValue.h. ◆ operator*(). template<typename T > . T & TTreeReaderValue< T >::operator* ; (; ). inline . Return a reference to the value of the current entry. ; Equivalent to dereferencing the pointer returned by Get(). Behavior is undefined if no entry has been loaded yet. Most likely a crash will occur. ; Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReaderValue.html:6416,load,loaded,6416,doc/master/classTTreeReaderValue.html,https://root.cern,https://root.cern/doc/master/classTTreeReaderValue.html,1,['load'],['loaded']
Performance,settings in a variable object (like ROOT::Fit::ParamsSettings) ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 367 of file Minuit2Minimizer.cxx. ◆ GlobalCC(). double ROOT::Minuit2::Minuit2Minimizer::GlobalCC ; (; unsigned int ; i); const. overridevirtual . get global correlation coefficient for the variable i. ; This is a number between zero and one which gives the correlation between the i-th variable and that linear combination of all other variables which is most strongly correlated with i. If the variable is fixed or const the return value is zero ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 835 of file Minuit2Minimizer.cxx. ◆ Hesse(). bool ROOT::Minuit2::Minuit2Minimizer::Hesse ; (; ). overridevirtual . perform a full calculation of the Hessian matrix for error calculation If a valid minimum exists the calculation is done on the minimum point otherwise is performed in the current set values of parameters Status code of minimizer is updated according to the following convention (in case Hesse failed) status += 100*hesseStatus where hesse status is: status = 1 : hesse failed status = 2 : matrix inversion failed status = 3 : matrix is not pos defined ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 1204 of file Minuit2Minimizer.cxx. ◆ IsFixedVariable(). bool ROOT::Minuit2::Minuit2Minimizer::IsFixedVariable ; (; unsigned int ; ivar); const. overridevirtual . query if an existing variable is fixed (i.e. ; considered constant in the minimization) note that by default all variables are not fixed ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 356 of file Minuit2Minimizer.cxx. ◆ MinGradient(). const double * ROOT::Minuit2::Minuit2Minimizer::MinGradient ; (; ); const. inlineoverridevirtual . return pointer to gradient values at the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 146 of file Minuit2Minimizer.h. ◆ Minimize(). bool ROOT::Minuit2::Minuit2Minimizer::Minimize ; (; ). over,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html:19113,perform,perform,19113,doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,2,['perform'],"['perform', 'performed']"
Performance,se}. protected . ! true if cache was automatically created ; Definition at line 66 of file TTreeCache.h. ◆ fBranches. TObjArray* TTreeCache::fBranches {nullptr}. protected . ! List of branches to be stored in the cache ; Definition at line 51 of file TTreeCache.h. ◆ fBrNames. TList* TTreeCache::fBrNames {nullptr}. protected . ! list of branch names in the cache ; Definition at line 52 of file TTreeCache.h. ◆ fCurrentClusterStart. Long64_t TTreeCache::fCurrentClusterStart {-1}. protected . ! Start of the cluster(s) where the current content was picked out ; Definition at line 42 of file TTreeCache.h. ◆ fEnabled. bool TTreeCache::fEnabled {true}. protected . ! cache enabled for cached reading ; Definition at line 63 of file TTreeCache.h. ◆ fEntryCurrent. Long64_t TTreeCache::fEntryCurrent {-1}. protected . ! current lowest entry number in the cache ; Definition at line 40 of file TTreeCache.h. ◆ fEntryMax. Long64_t TTreeCache::fEntryMax {1}. protected . ! last entry in the cache ; Definition at line 39 of file TTreeCache.h. ◆ fEntryMin. Long64_t TTreeCache::fEntryMin {0}. protected . ! first entry in the cache ; Definition at line 38 of file TTreeCache.h. ◆ fEntryNext. Long64_t TTreeCache::fEntryNext {-1}. protected . ! next entry number where cache must be filled ; Definition at line 41 of file TTreeCache.h. ◆ fFillTimes. Int_t TTreeCache::fFillTimes {0}. protected . ! how many times we can fill the current buffer ; Definition at line 59 of file TTreeCache.h. ◆ fFirstBuffer. bool TTreeCache::fFirstBuffer {true}. protected . ! true if first buffer is used for prefetching ; Definition at line 56 of file TTreeCache.h. ◆ fFirstEntry. Long64_t TTreeCache::fFirstEntry {-1}. protected . ! save the value of the first entry ; Definition at line 61 of file TTreeCache.h. ◆ fFirstMiss. Long64_t TTreeCache::fFirstMiss {-1}. protected . ! set to the event # of the first miss. ; Definition at line 73 of file TTreeCache.h. ◆ fFirstTime. bool TTreeCache::fFirstTime {true}. protected ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:52936,cache,cache,52936,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,['cache'],['cache']
Performance,"sg = ""p.d.f normalization integral is zero or negative: "" + std::to_string(normVal);; 287 logEvalError(msg.c_str());; 288 clearValueAndShapeDirty();; 289 return RooNaNPacker::packFloatIntoNaN(-normVal + (rawVal < 0. ? -rawVal : 0.));; 290 }; 291 ; 292 if (rawVal < 0.) {; 293 logEvalError(Form(""p.d.f value is less than zero (%f), trying to recover"", rawVal));; 294 clearValueAndShapeDirty();; 295 return RooNaNPacker::packFloatIntoNaN(-rawVal);; 296 }; 297 ; 298 if (TMath::IsNaN(rawVal)) {; 299 logEvalError(""p.d.f value is Not-a-Number"");; 300 clearValueAndShapeDirty();; 301 return rawVal;; 302 }; 303 ; 304 return (rawVal == 0. && normVal == 0.) ? 0. : rawVal / normVal;; 305}; 306 ; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Return current value, normalized by integrating over; 310/// the observables in `nset`. If `nset` is 0, the unnormalized value; 311/// is returned. All elements of `nset` must be lvalues.; 312///; 313/// Unnormalized values are not cached.; 314/// Doing so would be complicated as `_norm->getVal()` could; 315/// spoil the cache and interfere with returning the cached; 316/// return value. Since unnormalized calls are typically; 317/// done in integration calls, there is no performance hit.; 318 ; 319double RooAbsPdf::getValV(const RooArgSet* nset) const; 320{; 321 ; 322 // Special handling of case without normalization set (used in numeric integration of pdfs); 323 if (!nset) {; 324 RooArgSet const* tmp = _normSet ;; 325 _normSet = nullptr ;; 326 double val = evaluate() ;; 327 _normSet = tmp ;; 328 ; 329 return TMath::IsNaN(val) ? 0. : val;; 330 }; 331 ; 332 ; 333 // Process change in last data set used; 334 bool nintChanged(false) ;; 335 if (!isActiveNormSet(nset) || _norm==nullptr) {; 336 nintChanged = syncNormalization(nset) ;; 337 }; 338 ; 339 // Return value of object. Calculated if dirty, otherwise cached value is returned.; 340 if (isValueDirty() || nintChanged || _norm->isValueDirty()) {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:11849,cache,cached,11849,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['cache'],['cached']
Performance,"sgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EEventType { kUnDefined; kPacket; kStart; kStop; kFile; kFileOpen; kFileRead; kRate; kNumEventType; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualPerfStats *& CurrentPerfStats(); Return the current ROOT perf stats if any. const char * EventType(TVirtualPerfStats::EEventType type); Return the name of the event type. virtual ~TVirtualPerfStats(); {}. void SimpleEvent(TVirtualPerfStats::EEventType type). void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead). void FileOpenEvent(TFile* file, const char* filename, Double_t start). void FileReadEvent(TFile* file, Int_t len, Double_t start). void UnzipEvent(TObject* tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen). void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead). Long64_t GetBytesRead() const. void SetNumEvents(Long64_t num). Long64_t GetNumEvents() const. » Author: Kristjan Gulbrandsen 11/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-15 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualPerfStats.html:6885,latency,latency,6885,root/html534/TVirtualPerfStats.html,https://root.cern,https://root.cern/root/html534/TVirtualPerfStats.html,1,['latency'],['latency']
Performance,"sgfmt,...) const;  Issue warning message. ;  . Static Public Member Functions; static TFileOpenHandle * AsyncOpen (const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0);  Submit an asynchronous open request. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Cp (const char *src, const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000);  Allows to copy file from src to dst URL. ;  ; static TFile *& CurrentFile ();  Return the current ROOT file if any. ;  ; static const char * DeclFileName ();  ; static EAsyncOpenStatus GetAsyncOpenStatus (const char *name);  Get status of the async open request related to 'name'. ;  ; static EAsyncOpenStatus GetAsyncOpenStatus (TFileOpenHandle *handle);  Get status of the async open request related to 'handle'. ;  ; static const char * GetCacheFileDir ();  Get the directory where to locally stage/cache remote files. ;  ; static const TUrl * GetEndpointUrl (const char *name);  Get final URL for file being opened asynchronously. ;  ; static Long64_t GetFileBytesRead ();  Static function returning the total number of bytes read from all files. ;  ; static Long64_t GetFileBytesWritten ();  Static function returning the total number of bytes written to all files. ;  ; static Long64_t GetFileCounter ();  ; static Int_t GetFileReadCalls ();  Static function returning the total number of read calls from all files. ;  ; static Bool_t GetOnlyStaged ();  Returns staged only flag. ;  ; static UInt_t GetOpenTimeout ();  Returns open timeout (in ms). ;  ; static Int_t GetReadaheadSize ();  Static function returning the readahead buffer size. ;  ; static Bool_t GetReadStreamerInfo ();  If the streamerinfos are to be read at file opening. ;  ; static EFileType GetType (const char *name, Option_t *option="""", TString *prefix=nullptr);  Resolve the file type as a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:31319,cache,cache,31319,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['cache'],['cache']
Performance,"sh value returned by the TString::Hash() after converting name to a TString. ; Reimplemented from THashList.; Definition at line 51 of file THashList.cxx. ◆ FindObject() [2/3]. TObject * TListOfDataMembers::FindObject ; (; const char * ; name); const. overridevirtual . Specialize FindObject to do search for the a data member just by name or create it if its not already in the list. ; Reimplemented from THashList.; Definition at line 182 of file TListOfDataMembers.cxx. ◆ FindObject() [3/3]. TObject * THashList::FindObject ; (; const TObject * ; obj); const. overridevirtual . Find object using its hash value (returned by its Hash() member). ; Reimplemented from THashList.; Definition at line 52 of file THashList.cxx. ◆ Get() [1/2]. TDictionary * TListOfDataMembers::Get ; (; DataMemberInfo_t * ; info, . bool ; skipChecks = kFALSE . ). Return (after creating it if necessary) the TDataMember describing the data member corresponding to the Decl 'id'. ; The skipChecks flag controls the consistency checks performed inspecting the AST. In some cases, we explicitly alter the datamembers in the typesystem with respect to the AST and therefore we must not enforce consistency. ; Definition at line 273 of file TListOfDataMembers.cxx. ◆ Get() [2/2]. TDictionary * TListOfDataMembers::Get ; (; DeclId_t ; id). Return (after creating it if necessary) the TDataMember describing the data member corresponding to the Decl 'id'. ; Definition at line 216 of file TListOfDataMembers.cxx. ◆ GetClass(). TClass * TListOfDataMembers::GetClass ; (; ); const. inline . Definition at line 90 of file TListOfDataMembers.h. ◆ IsA(). TClass * TListOfDataMembers::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from THashList.; Definition at line 102 of file TListOfDataMembers.h. ◆ IsLoaded(). Bool_t TListOfDataMembers::IsLoaded ; (; ); const. inline . Definition at line 79 of file TListOfDataMembers.h. ◆ Load(). void TListOfDataMembers::Load ; (; ). Load ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfDataMembers.html:29878,perform,performed,29878,doc/master/classTListOfDataMembers.html,https://root.cern,https://root.cern/doc/master/classTListOfDataMembers.html,1,['perform'],['performed']
Performance,"sh.; 8167///; 8168/// ### CASE 1 : autof > 0; 8169///; 8170/// autof is the number of consecutive entries after which TTree::Fill will; 8171/// flush all branch buffers to disk.; 8172///; 8173/// ### CASE 2 : autof < 0; 8174///; 8175/// When filling the Tree the branch buffers will be flushed to disk when; 8176/// more than autof bytes have been written to the file. At the first FlushBaskets; 8177/// TTree::Fill will replace fAutoFlush by the current value of fEntries.; 8178///; 8179/// Calling this function with autof<0 is interesting when it is hard to estimate; 8180/// the size of one entry. This value is also independent of the Tree.; 8181///; 8182/// The Tree is initialized with fAutoFlush=-30000000, ie that, by default,; 8183/// the first AutoFlush will be done when 30 MBytes of data are written to the file.; 8184///; 8185/// ### CASE 3 : autof = 0; 8186///; 8187/// The AutoFlush mechanism is disabled.; 8188///; 8189/// Flushing the buffers at regular intervals optimize the location of; 8190/// consecutive entries on the disk by creating clusters of baskets.; 8191///; 8192/// A cluster of baskets is a set of baskets that contains all; 8193/// the data for a (consecutive) set of entries and that is stored; 8194/// consecutively on the disk. When reading all the branches, this; 8195/// is the minimum set of baskets that the TTreeCache will read.; 8196 ; 8197void TTree::SetAutoFlush(Long64_t autof /* = -30000000 */ ); 8198{; 8199 // Implementation note:; 8200 //; 8201 // A positive value of autoflush determines the size (in number of entries) of; 8202 // a cluster of baskets.; 8203 //; 8204 // If the value of autoflush is changed over time (this happens in; 8205 // particular when the TTree results from fast merging many trees),; 8206 // we record the values of fAutoFlush in the data members:; 8207 // fClusterRangeEnd and fClusterSize.; 8208 // In the code we refer to a range of entries where the size of the; 8209 // cluster of baskets is the same (i.e the value o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:318223,optimiz,optimize,318223,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['optimiz'],['optimize']
Performance,"shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooIntegralMorph.html:5895,cache,cacheUniqueSuffix,5895,root/html532/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html532/RooIntegralMorph.html,1,['cache'],['cacheUniqueSuffix']
Performance,"shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooIntegralMorph.html:5895,cache,cacheUniqueSuffix,5895,root/html528/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html528/RooIntegralMorph.html,2,['cache'],['cacheUniqueSuffix']
Performance,"shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; const RooArgList&boundaries(); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStepFunction.html:2471,cache,cacheUniqueSuffix,2471,root/html528/RooStepFunction.html,https://root.cern,https://root.cern/root/html528/RooStepFunction.html,1,['cache'],['cacheUniqueSuffix']
Performance,"shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; const RooArgList&boundaries(); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStepFunction.html:2471,cache,cacheUniqueSuffix,2471,root/html530/RooStepFunction.html,https://root.cern,https://root.cern/root/html530/RooStepFunction.html,2,['cache'],['cacheUniqueSuffix']
Performance,"shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProduct.html:24066,cache,cache,24066,root/html534/RooProduct.html,https://root.cern,https://root.cern/root/html534/RooProduct.html,1,['cache'],['cache']
Performance,"shapes at the end points of the interpolation parameter alpha; If doCacheAlpha is true, a two-dimensional cache is constructed in; both alpha and x. RooIntegralMorph(const RooIntegralMorph& other, const char* name = 0); Copy constructor. RooArgSet* actualObservables(const RooArgSet& nset) const; Observable to be cached for given choice of normalization.; Returns the 'x' observable unless doCacheAlpha is set in which; case a set with both x and alpha. RooArgSet* actualParameters(const RooArgSet& nset) const; Parameters of the cache. Returns parameters of both pdf1 and pdf2; and parameter cache, in case doCacheAlpha is not set. const char* inputBaseName() const; Return base name component for cache components in this case; a string encoding the names of both end point p.d.f.s. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill the cache with the interpolated shape. RooAbsCachedPdf::PdfCacheElem* createCache(const RooArgSet* nset) const; Create and return a derived MorphCacheElem. Double_t evaluate() const; Dummy. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Indicate to the RooAbsCachedPdf base class that for the filling of the; cache the traversal of the x should be in the innermost loop, to minimize; recalculation of the one-dimensional internal cache for a fixed value of alpha. RooIntegralMorph(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooIntegralMorph(*this,newname); }. virtual ~RooIntegralMorph(); { }. Bool_t selfNormalized() const; P.d.f is self normalized. void setCacheAlpha(Bool_t flag); Activate caching of p.d.f. shape for all values of alpha as well. Bool_t cacheAlpha() const; If true caching of p.d.f for all alpha values is active. » Last changed: Mon Jul 4 15:23:08 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooIntegralMorph.html:47517,cache,cache,47517,root/html530/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html530/RooIntegralMorph.html,3,['cache'],"['cache', 'cacheAlpha']"
Performance,"shapes at the end points of the interpolation parameter alpha; If doCacheAlpha is true, a two-dimensional cache is constructed in; both alpha and x. RooIntegralMorph(const RooIntegralMorph& other, const char* name = 0); Copy constructor. RooArgSet* actualObservables(const RooArgSet& nset) const; Observable to be cached for given choice of normalization.; Returns the 'x' observable unless doCacheAlpha is set in which; case a set with both x and alpha. RooArgSet* actualParameters(const RooArgSet& nset) const; Parameters of the cache. Returns parameters of both pdf1 and pdf2; and parameter cache, in case doCacheAlpha is not set. const char* inputBaseName() const; Return base name component for cache components in this case; a string encoding the names of both end point p.d.f.s. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill the cache with the interpolated shape. RooAbsCachedPdf::PdfCacheElem* createCache(const RooArgSet* nset) const; Create and return a derived MorphCacheElem. Double_t evaluate() const; Dummy. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Indicate to the RooAbsCachedPdf base class that for the filling of the; cache the traversal of the x should be in the innermost loop, to minimize; recalculation of the one-dimensional internal cache for a fixed value of alpha. RooIntegralMorph(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooIntegralMorph(*this,newname); }. virtual ~RooIntegralMorph(); { }. Bool_t selfNormalized() const; P.d.f is self normalized. void setCacheAlpha(Bool_t flag); Activate caching of p.d.f. shape for all values of alpha as well. Bool_t cacheAlpha() const; If true caching of p.d.f for all alpha values is active. » Last changed: Sat Oct 9 06:58:30 2010 » Last generated: 2010-10-09 06:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooIntegralMorph.html:46957,cache,cache,46957,root/html528/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html528/RooIntegralMorph.html,3,['cache'],"['cache', 'cacheAlpha']"
Performance,"shapes at the end points of the interpolation parameter alpha; If doCacheAlpha is true, a two-dimensional cache is constructed in; both alpha and x. RooIntegralMorph(const RooIntegralMorph& other, const char* name = 0); Copy constructor. RooArgSet* actualObservables(const RooArgSet& nset) const; Observable to be cached for given choice of normalization.; Returns the 'x' observable unless doCacheAlpha is set in which; case a set with both x and alpha. RooArgSet* actualParameters(const RooArgSet& nset) const; Parameters of the cache. Returns parameters of both pdf1 and pdf2; and parameter cache, in case doCacheAlpha is not set. const char* inputBaseName() const; Return base name component for cache components in this case; a string encoding the names of both end point p.d.f.s. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill the cache with the interpolated shape. RooAbsCachedPdf::PdfCacheElem* createCache(const RooArgSet* nset) const; Create and return a derived MorphCacheElem. Double_t evaluate() const; Dummy. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Indicate to the RooAbsCachedPdf base class that for the filling of the; cache the traversal of the x should be in the innermost loop, to minimize; recalculation of the one-dimensional internal cache for a fixed value of alpha. RooIntegralMorph(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooIntegralMorph(*this,newname); }. virtual ~RooIntegralMorph(); { }. Bool_t selfNormalized() const; P.d.f is self normalized. void setCacheAlpha(Bool_t flag); Activate caching of p.d.f. shape for all values of alpha as well. Bool_t cacheAlpha() const; If true caching of p.d.f for all alpha values is active. » Last changed: Thu Nov 3 20:08:25 2011 » Last generated: 2011-11-03 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooIntegralMorph.html:47924,cache,cache,47924,root/html532/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html532/RooIntegralMorph.html,3,['cache'],"['cache', 'cacheAlpha']"
Performance,"shapes at the end points of the interpolation parameter alpha; If doCacheAlpha is true, a two-dimensional cache is constructed in; both alpha and x. RooIntegralMorph(const RooIntegralMorph& other, const char* name = 0); Copy constructor. RooArgSet* actualObservables(const RooArgSet& nset) const; Observable to be cached for given choice of normalization.; Returns the 'x' observable unless doCacheAlpha is set in which; case a set with both x and alpha. RooArgSet* actualParameters(const RooArgSet& nset) const; Parameters of the cache. Returns parameters of both pdf1 and pdf2; and parameter cache, in case doCacheAlpha is not set. const char* inputBaseName() const; Return base name component for cache components in this case; a string encoding the names of both end point p.d.f.s. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill the cache with the interpolated shape. RooAbsCachedPdf::PdfCacheElem* createCache(const RooArgSet* nset) const; Create and return a derived MorphCacheElem. Double_t evaluate() const; Dummy. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Indicate to the RooAbsCachedPdf base class that for the filling of the; cache the traversal of the x should be in the innermost loop, to minimize; recalculation of the one-dimensional internal cache for a fixed value of alpha. RooIntegralMorph(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooIntegralMorph(*this,newname); }. virtual ~RooIntegralMorph(); { }. Bool_t selfNormalized() const; P.d.f is self normalized. void setCacheAlpha(Bool_t flag); Activate caching of p.d.f. shape for all values of alpha as well. Bool_t cacheAlpha() const; If true caching of p.d.f for all alpha values is active. » Last changed: Tue Jun 2 15:31:37 2015 » Last generated: 2015-06-02 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooIntegralMorph.html:51958,cache,cache,51958,root/html604/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html604/RooIntegralMorph.html,3,['cache'],"['cache', 'cacheAlpha']"
Performance,"shared_ptr will be removed. ; Remove canvas from global canvas lists, will be destroyed once last shared_ptr is disappear. ; Definition at line 225 of file RCanvas.cxx. ◆ ResolveSharedPtrs(). void ROOT::Experimental::RCanvas::ResolveSharedPtrs ; (; ). To resolve problem with storing of shared pointers Call this method when reading canvas from the file Can be called many times - after reinitialization of shared pointers no changes will be performed. ; Definition at line 299 of file RCanvas.cxx. ◆ Run(). void ROOT::Experimental::RCanvas::Run ; (; double ; tm = 0.). Run canvas functionality for given time (in seconds) ; Run canvas functionality for the given time (in seconds) Used to process canvas-related actions in the appropriate thread context.; Must be regularly called when canvas created and used in extra thread. Time parameter specifies minimal execution time in seconds - if default value 0 is used, just all pending actions will be performed. When canvas is not yet displayed - just performs sleep for given time interval.; Example of usage:; void draw_canvas(bool &run_loop, std::make_shared<RH1D> hist); {; auto canvas = RCanvas::Create(""Canvas title"");; canvas->Draw(hist)->SetLineColor(RColor::kBlue);; canvas->Show();; while (run_loop) {; pHist->Fill(1);; canvas->Modified();; canvas->Update();; canvas->Run(0.1); // process canvas events; }; ; canvas->Remove();; }; ; int main(); {; RAxisConfig xaxis(100, -10., 10.);; auto pHist = std::make_shared<RH1D>(xaxis);; bool run_loop = true;; ; std::thread thrd(draw_canvas, run_loop, pHist);; std::this_thread::sleep_for(std::chrono::seconds(100));; run_loop = false;; thrd.join();; return 0;; }; mainint main()Definition Prototype.cxx:12; ROOT::Experimental::RCanvas::Createstatic std::shared_ptr< RCanvas > Create(const std::string &title)Create new canvas instance.Definition RCanvas.cxx:89; ROOT::Experimental::RColor::kBluestatic R__DLLEXPORT constexpr RGB_t kBlueDefinition RColor.hxx:186. Definition at line 285 of file RCan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvas.html:15854,perform,performs,15854,doc/master/classROOT_1_1Experimental_1_1RCanvas.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvas.html,1,['perform'],['performs']
Performance,"sher, ""Category_Fisher_2"",""!H:!V:Fisher"" );; ; // Likelihood with categories; TMVA::MethodBase* liCat = factory->BookMethod( dataloader, TMVA::Types::kCategory, ""LikelihoodCat"","""" );; mcat = dynamic_cast<TMVA::MethodCategory*>(liCat);; mcat->AddMethod( ""abs(eta)<=1.3"",theCat1Vars, TMVA::Types::kLikelihood,; ""Category_Likelihood_1"",""!H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50"" );; mcat->AddMethod( ""abs(eta)>1.3"", theCat2Vars, TMVA::Types::kLikelihood,; ""Category_Likelihood_2"",""!H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50"" );; ; // Now you can tell the factory to train, test, and evaluate the MVAs; ; // Train MVAs using the set of training events; factory->TrainAllMethods();; ; // Evaluate all MVAs using the set of test events; factory->TestAllMethods();; ; // Evaluate and compare performance of all configured MVAs; factory->EvaluateAllMethods();; ; // --------------------------------------------------------------; ; // Save the output; outputFile->Close();; ; std::cout << ""==> Wrote root file: "" << outputFile->GetName() << std::endl;; std::cout << ""==> TMVAClassificationCategory is done!"" << std::endl;; ; // Clean up; delete factory;; delete dataloader;; ; // Launch the GUI for the root macros; if (!gROOT->IsBatch()) TMVA::TMVAGui( outfileName );; }; int main( int argc, char** argv ); {; TMVAClassificationCategory();; return 0;; }; DataLoader.h; MethodCategory.h; mainint main()Definition Prototype.cxx:12; Bool_tbool Bool_tDefinition RtypesCore.h:63; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TChain.h; TFile.h; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; TMVAGui.h; TObjString.h; TROOT.h; gROOT#defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:33149,perform,performance,33149,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,1,['perform'],['performance']
Performance,"shevPol.h:34; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; . To control the bar width (default is the bin width) TH1::SetBarWidth() should be used.; To control the bar offset (default is 0) TH1::SetBarOffset() should be used.; These two parameters are useful when several histograms are plotted using the option SAME. They allow to plot the histograms next to each other. The SCATter plot option (legacy draw option); AttentionUse of option SCAT has been deprecated. It was the default drawing option for 2D and 3D histograms. The new default option is COL (heat-map).; For each cell (i,j) a number of points proportional to the cell content is drawn. A maximum of kNMAX points per cell is drawn. If the maximum is above kNMAX contents are normalized to kNMAX (kNMAX=2000). If option is of the form scat=ff, (eg scat=1.8, scat=1e-3), then ff is used as a scale factor to compute the number of dots. scat=1 is the default.; By default the scatter plot is painted with a ""dot marker"" which not scalable (see the TAttMarker documentation). To change the marker size, a scalable marker type should be used. For instance a circle (marker style 20).; {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hscat = new TH2F(""hscat"",""Option SCATter example (default for 2D histograms) "",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hscat->Fill(px,5*py);; hscat->Fill(3+0.5*px,2*py-10.);; }; hscat->Draw(""scat=0.5""); // This a legacy draw option. Please consider using TScatter; }. The ARRow option; Shows gradient between adjacent cells. For each cell (i,j) an arrow is drawn The orientation of the arrow follows the cell gradient.; {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto harr = new TH2F(""harr"",""Option ARRow example"",20,-4,4,20,-20,20);; harr->SetLineColor(kRed);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; harr->Fill(px,5*py);; harr->Fill(3+0.5*px,2*py-10.,0.1);; }; harr->Draw(""ARR"");; }.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:38084,scalab,scalable,38084,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['scalab'],['scalable']
Performance,"sholds ();  Update the cumulative threshold table from the current coefficient values. ;  ;  Protected Member Functions inherited from RooAbsGenContext; virtual RooDataSet * createDataSet (const char *name, const char *title, const RooArgSet &obs);  Create an empty dataset to hold the events that will be generated. ;  ; void resampleData (double &ratio);  Rescale existing output buffer with given ratio. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; std::vector< double > _coefThresh;  [_nComp] Array of coefficient thresholds ;  ; std::vector< std::unique_ptr< RooAbsGenContext > > _gcList;  List of component generator contexts. ;  ; bool _isModel;  Are we generating from a RooAddPdf or a RooAddModel. ;  ; Int_t _nComp;  Number of PDF components. ;  ; AddCacheElem * _pcache = nullptr;  ! RooAddPdf cache element ;  ; RooAbsPdf * _pdf;  Pointer to cloned p.d.f. ;  ; std::unique_ptr< RooArgSet > _pdfSet;  Set owned all nodes of internal clone of p.d.f. ;  ; std::unique_ptr< RooArgSet > _vars;  ;  Protected Attributes inherited from RooAbsGenContext; UInt_t _expectedEvents;  Number of expected events from extended p.d.f. ;  ; RooAbsPdf::ExtendMode _extendMode;  Extended mode capabilities of p.d.f. ;  ; RooDataSet * _genData = nullptr;  ! Data being generated ;  ; bool _isValid;  Is context in valid state? ;  ; Int_t _nextProtoIndex;  Next prototype event to load according to LUT. ;  ; TString _normRange;  Normalization range of pdf. ;  ; std::vector< Int_t > _protoOrder;  LUT with traversal order of prototype data. ;  ; const RooDataSet * _prototype;  Pointer to prototype dataset. ;  ; RooArgSet _protoVars;  Prototype observables. ;  ; RooArgSet _theEvent;  Pointer to observable event being generated. ;  ; bool _verbose;  Verbose messaging? ;  ;  Protected Attributes inherited from TNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddGenContext.html:15861,cache,cache,15861,doc/master/classRooAddGenContext.html,https://root.cern,https://root.cern/doc/master/classRooAddGenContext.html,1,['cache'],['cache']
Performance,"short, int or unsigned short, int When a leaf is of type integer, the generated histogram is forced to have an integer bin width. ; Definition at line 4678 of file TTreeFormula.cxx. ◆ IsLeafString(). bool TTreeFormula::IsLeafString ; (; Int_t ; code); const. protectedvirtual . Return TRUE if the leaf or data member corresponding to code is a string. ; Definition at line 4748 of file TTreeFormula.cxx. ◆ IsQuickLoad(). bool TTreeFormula::IsQuickLoad ; (; ); const. inline . Definition at line 204 of file TTreeFormula.h. ◆ IsString() [1/2]. bool TTreeFormula::IsString ; (; ); const. virtual . Return TRUE if the formula is a string. ; Definition at line 4726 of file TTreeFormula.cxx. ◆ IsString() [2/2]. bool TTreeFormula::IsString ; (; Int_t ; oper); const. overrideprotectedvirtual . Return true if the expression at the index 'oper' is to be treated as as string. ; Reimplemented from ROOT::v5::TFormula.; Definition at line 4736 of file TTreeFormula.cxx. ◆ LoadBranches(). void TTreeFormula::LoadBranches ; (; ). protected . Make sure that all the branches have been loaded properly. ; Definition at line 5369 of file TTreeFormula.cxx. ◆ LoadCurrentDim(). bool TTreeFormula::LoadCurrentDim ; (; ). protected . Calculate the actual dimension for the current entry. ; Definition at line 5393 of file TTreeFormula.cxx. ◆ Notify(). bool TTreeFormula::Notify ; (; ). inlineoverridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 206 of file TTreeFormula.h. ◆ operator=(). TTreeFo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormula.html:44688,Load,LoadBranches,44688,doc/master/classTTreeFormula.html,https://root.cern,https://root.cern/doc/master/classTTreeFormula.html,1,['Load'],['LoadBranches']
Performance,"shotMutexState(ROOT::TVirtualRWMutex* mtx) final;; 326 void ForgetMutexState() final;; 327 ; 328 void ApplyToInterpreterMutex(void* delta);; 329 void *RewindInterpreterMutex();; 330 ; 331 static void UpdateClassInfo(char* name, Long_t tagnum);; 332 static void UpdateClassInfoWork(const char* name);; 333 void RefreshClassInfo(TClass *cl, const clang::NamedDecl *def, bool alias);; 334 void UpdateClassInfoWithDecl(const clang::NamedDecl* ND);; 335 static void UpdateAllCanvases();; 336 ; 337 // Misc; 338 int DisplayClass(FILE* fout, const char* name, int base, int start) const final;; 339 int DisplayIncludePath(FILE* fout) const final;; 340 void* FindSym(const char* entry) const final;; 341 void GenericError(const char* error) const final;; 342 Long_t GetExecByteCode() const final;; 343 const char* GetTopLevelMacroName() const final;; 344 const char* GetCurrentMacroName() const final;; 345 int GetSecurityError() const final;; 346 int LoadFile(const char* path) const final;; 347 Bool_t LoadText(const char* text) const final;; 348 const char* MapCppName(const char*) const final;; 349 void SetAlloclockfunc(void (*)()) const final;; 350 void SetAllocunlockfunc(void (*)()) const final;; 351 int SetClassAutoLoading(int) const final;; 352 int SetClassAutoparsing(int) final;; 353 Bool_t IsAutoParsingSuspended() const final { return fIsAutoParsingSuspended; }; 354 void SetErrmsgcallback(void* p) const final;; 355 void ReportDiagnosticsToErrorHandler(bool enable = true) final;; 356 void SetTempLevel(int val) const final;; 357 int UnloadFile(const char* path) const final;; 358 ; 359 void CodeComplete(const std::string&, size_t&,; 360 std::vector<std::string>&) final;; 361 int Evaluate(const char*, TInterpreterValue&) final;; 362 std::unique_ptr<TInterpreterValue> MakeInterpreterValue() const final;; 363 void RegisterTemporary(const TInterpreterValue& value);; 364 void RegisterTemporary(const cling::Value& value);; 365 const ROOT::TMetaUtils::TNormalizedCtxt& GetNormalizedContext() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:16712,Load,LoadText,16712,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['Load'],['LoadText']
Performance,"should be set to true for parallel minimization of likelihoods!; 928 * Note that it is currently not recommended to use Modular likelihoods without any parallelization enabled in the minimization, since; 929 * some features such as offsetting might not yet work in this case.; 930 * </table>; 931 */; 932 ; 933 ; 934/** @brief Protected implementation of the NLL creation routine.; 935 *; 936 * This virtual function can be overridden in case you want to change the NLL creation logic for custom PDFs.; 937 *; 938 * \note Never call this function directly. Instead, call RooAbsPdf::createNLL().; 939 */; 940 ; 941std::unique_ptr<RooAbsReal> RooAbsPdf::createNLLImpl(RooAbsData &data, const RooLinkedList &cmdList); 942{; 943 return RooFit::FitHelpers::createNLL(*this, data, cmdList);; 944}; 945 ; 946 ; 947/** @fn RooAbsPdf::fitTo(); 948 *; 949 * @brief Fit PDF to given dataset.; 950 *; 951 * If dataset is unbinned, an unbinned maximum likelihood is performed.; 952 * If the dataset is binned, a binned maximum likelihood is performed.; 953 * By default the fit is executed through the MINUIT commands MIGRAD, HESSE in succession.; 954 *; 955 * @param data Reference to a RooAbsData object representing the dataset.; 956 * @param cmdArgs Variadic template arguments representing optional command arguments.; 957 * You can pass either an arbitrary number of RooCmdArg instances; 958 * or a single RooLinkedList that points to the RooCmdArg objects.; 959 * @return An owning pointer to the created RooAbsReal NLL object.; 960 * @return RooFitResult with fit status and parameters if option Save() is used, `nullptr` otherwise. The user takes ownership of the fit result.; 961 *; 962 * @tparam CmdArgs_t Template types for optional command arguments.; 963 * Can either be an arbitrary number of RooCmdArg or a single RooLinkedList.; 964 *; 965 * \note This front-end function should not be re-implemented in derived PDF types.; 966 * If you mean to customize the likelihood fitting routine,; 967 * you",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:43712,perform,performed,43712,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['perform'],['performed']
Performance,"should you encounter them. RNTuple is still in pre-production. The on-disk format is scheduled to be finalized by the end of 2024. Thus, we appreciate feedback and suggestions for improvement.; Histogram Libraries. Implement the FLT_MAX mechanism for THStack::GetMaximum() and THStack::GetMiniumum().; Print a warning when the range given to TAxis::SetRange is invalid.; Fix projection name in TH3 as requested here. Parallelism. The ROOT::Experimental::TFuture template has been removed. RooFit Libraries; New CPU likelihood evaluation backend by default; The new vectorizing CPU evaluation backend is not the default for RooFit likelihoods. Likelihood minimization is now up to 10x faster on a single CPU core.; If you experience unexpected problems related to the likelihood evaluation, you can revert back to the old backend by passing RooFit::EvalBackend(""legacy"") to RooAbsPdf::fitTo() or RooAbsPdf::createNLL().; In case you observe any slowdowns with the new likelihood evaluation, please open a GitHub issue about this, as such a performance regression is considered a bug.; Asymptotically correct uncertainties for extended unbinned likelihood fits; Added correct treatment of extended term in asymptotically correct method for uncertainty determination in the presence of weights. This improvement will allow for extended unbinned maximum likelihood fits to use the asymptotically correct method when using the RooFit::AsymptoticError() command argument in RooAbsPdf::fitTo(). See also this writeup on extended weighted fits that is also linked from the reference guide. The pull request that introduced this feature might also be a good reference.; Compile your code with memory safe interfaces; If you define the ROOFIT_MEMORY_SAFE_INTERFACES preprocessor macro, the RooFit interface changes in a way such that memory leaks are avoided.; The most prominent effect of this change is that many functions that used to return an owning pointer (e.g., a pointer to an object that you need to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:8539,perform,performance,8539,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['perform'],['performance']
Performance,"sian"", p, meanP, sigma);; ; // configure proposal function; PdfProposal pdfProposal(pGaussian);; pdfProposal.AddMapping(meanP, p); // each call of Propose(xPrime, x), meanP in; // the proposal function will be updated to; // the value of p in x. this will center the; // proposal function about x's p when; // proposing for xPrime; ; // To improve performance, PdfProposal has the ability to cache a specified; // number of proposals. If you don't call this function, the default cache size; // is 1, which can be slow.; pdfProposal.SetCacheSize(desiredCacheSize);; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooStats::PdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface.Definition PdfProposal.h:30; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; PdfProposal currently uses a fixed cache size. Adaptive caching methods are in the works for future versions. ; Definition at line 30 of file PdfProposal.h. Public Member Functions;  PdfProposal ();  By default, PdfProposal does NOT own the PDF that serves as the proposal density function. ;  ;  PdfProposal (RooAbsPdf &pdf);  By default, PdfProposal does NOT own the PDF that serves as the proposal density function. ;  ;  ~PdfProposal () override;  ; virtual void AddMapping (RooRealVar &proposalParam, RooAbsReal &update);  specify a mapping between a parameter of the proposal function and a parameter of interest. ;  ; virtual const RooAbsPdf * GetPdf () const;  Get the PDF is the proposal density function. ;  ; double GetProposalDensity (RooArgSet &x1, RooArgSet &x2) override;  Return the probability of proposing the point x1 given the starting point x2. ;  ; TClass * IsA () const override;  ; bool IsSymmetric (RooArgSet &x1, RooArgSet &x2) override;  Determine whether or not the proposal density is symmet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1PdfProposal.html:1906,cache,cache,1906,doc/master/classRooStats_1_1PdfProposal.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1PdfProposal.html,1,['cache'],['cache']
Performance,"sible alternative name (default template; 1482/// parameter, typedefs template arguments, typedefed name).; 1483 ; 1484TClass *TROOT::FindSTLClass(const char *name, Bool_t load, Bool_t silent) const; 1485{; 1486 // Example of inputs are; 1487 // vector<int> (*); 1488 // vector<Int_t>; 1489 // vector<long long>; 1490 // vector<Long_64_t> (*); 1491 // vector<int, allocator<int> >; 1492 // vector<Int_t, allocator<int> >; 1493 //; 1494 // One of the possibly expensive operation is the resolving of the typedef; 1495 // which can provoke the parsing of the header files (and/or the loading; 1496 // of clang pcms information).; 1497 ; 1498 R__LOCKGUARD(gInterpreterMutex);; 1499 ; 1500 // Remove std::, allocator, typedef, add Long64_t, etc. in just one call.; 1501 std::string normalized;; 1502 TClassEdit::GetNormalizedName(normalized, name);; 1503 ; 1504 TClass *cl = nullptr;; 1505 if (normalized != name) cl = TClass::GetClass(normalized.c_str(),load,silent);; 1506 ; 1507 if (load && cl==nullptr) {; 1508 // Create an Emulated class for this container.; 1509 cl = gInterpreter->GenerateTClass(normalized.c_str(), kTRUE, silent);; 1510 }; 1511 ; 1512 return cl;; 1513}; 1514 ; 1515////////////////////////////////////////////////////////////////////////////////; 1516/// Return pointer to class with name. Obsolete, use TClass::GetClass directly; 1517 ; 1518TClass *TROOT::GetClass(const char *name, Bool_t load, Bool_t silent) const; 1519{; 1520 return TClass::GetClass(name,load,silent);; 1521}; 1522 ; 1523 ; 1524////////////////////////////////////////////////////////////////////////////////; 1525/// Return pointer to class from its name. Obsolete, use TClass::GetClass directly; 1526/// See TClass::GetClass; 1527 ; 1528TClass *TROOT::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t silent) const; 1529{; 1530 return TClass::GetClass(typeinfo,load,silent);; 1531}; 1532 ; 1533////////////////////////////////////////////////////////////////////////////////; 1534/// Return add",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:58113,load,load,58113,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,4,['load'],['load']
Performance,"sible for deleting it. ; Definition at line 923 of file RooAbsRealLValue.cxx. ◆ createHistogram() [11/11]. TH1 * RooAbsRealLValue::createHistogram ; (; const char * ; name, . RooArgList & ; vars, . const char * ; tAxisLabel, . double * ; xlo, . double * ; xhi, . Int_t * ; nBins . ). static . Create 1-, 2- or 3-d ROOT histogram with labels taken from the variables in 'vars' and the with range and binning specified in xlo,xhi and nBins. ; The dimensions of the arrays xlo,xhi, nBins should match the number of objects in vars. ; Definition at line 897 of file RooAbsRealLValue.cxx. ◆ createIntegral(). RooFit::OwningPtr< RooAbsReal > RooAbsRealLValue::createIntegral ; (; const RooArgSet & ; iset, . const RooArgSet * ; nset = nullptr, . const RooNumIntConfig * ; cfg = nullptr, . const char * ; rangeName = nullptr . ); const. overridevirtual . Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the return object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over. If nset is specified the integrand is request to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified the integral is performed over the named range, otherwise it is performed over the domain of each integrated observable. If cfg is specified it will be used to configure any numeric integration aspect of the integral. It will not force the integral to be performed numerically, which is decided automatically by RooRealIntegral. ; Reimplemented from RooAbsReal.; Definition at line 1056 of file RooAbsRealLValue.cxx. ◆ DeclFileName(). static const char * RooAbsRealLValue::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 164 of file RooAbsRealLValue.h. ◆ fitRangeOKForPlotting(). bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsRealLValue.html:75526,perform,performed,75526,doc/master/classRooAbsRealLValue.html,https://root.cern,https://root.cern/doc/master/classRooAbsRealLValue.html,1,['perform'],['performed']
Performance,"sient) override;; 561};; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Print value of member mname.; 565///; 566/// This method is called by the ShowMembers() method for each; 567/// data member when object.Dump() is invoked.; 568///; 569/// - cl is the pointer to the current class; 570/// - pname is the parent name (in case of composed objects); 571/// - mname is the data member name; 572/// - add is the data member address; 573 ; 574void TDumpMembers::Inspect(TClass *cl, const char *pname, const char *mname, const void *add, Bool_t /* isTransient */); 575{; 576 const Int_t kvalue = 30;; 577#ifdef R__B64; 578 const Int_t ktitle = 50;; 579#else; 580 const Int_t ktitle = 42;; 581#endif; 582 const Int_t kline = 1024;; 583 Int_t cdate = 0;; 584 Int_t ctime = 0;; 585 UInt_t *cdatime = nullptr;; 586 char line[kline];; 587 ; 588 TDataType *membertype;; 589 EDataType memberDataType = kNoType_t;; 590 const char *memberName;; 591 const char *memberFullTypeName;; 592 const char *memberTitle;; 593 Bool_t isapointer;; 594 Bool_t isbasic;; 595 Bool_t isarray;; 596 ; 597 if (TDataMember *member = cl->GetDataMember(mname)) {; 598 if (member->GetDataType()) {; 599 memberDataType = (EDataType)member->GetDataType()->GetType();; 600 }; 601 memberName = member->GetName();; 602 memberFullTypeName = member->GetFullTypeName();; 603 memberTitle = member->GetTitle();; 604 isapointer = member->IsaPointer();; 605 isbasic = member->IsBasic();; 606 membertype = member->GetDataType();; 607 isarray = member->GetArrayDim();; 608 } else if (!cl->IsLoaded()) {; 609 // The class is not loaded, hence it is 'emulated' and the main source of; 610 // information is the StreamerInfo.; 611 TVirtualStreamerInfo *info = cl->GetStreamerInfo();; 612 if (!info) return;; 613 const char *cursor = mname;; 614 while ( (*cursor)=='*' ) ++cursor;; 615 TString elname( cursor );; 616 Ssiz_t pos = elname.Index(""["");; 617 if ( pos != kNPOS ) {; 618 elname.Remove( pos );;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:21131,load,loaded,21131,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"sient) override;; 628};; 629 ; 630////////////////////////////////////////////////////////////////////////////////; 631/// Print value of member mname.; 632///; 633/// This method is called by the ShowMembers() method for each; 634/// data member when object.Dump() is invoked.; 635///; 636/// - cl is the pointer to the current class; 637/// - pname is the parent name (in case of composed objects); 638/// - mname is the data member name; 639/// - add is the data member address; 640 ; 641void TDumpMembers::Inspect(TClass *cl, const char *pname, const char *mname, const void *add, Bool_t /* isTransient */); 642{; 643 const Int_t kvalue = 30;; 644#ifdef R__B64; 645 const Int_t ktitle = 50;; 646#else; 647 const Int_t ktitle = 42;; 648#endif; 649 const Int_t kline = 1024;; 650 Int_t cdate = 0;; 651 Int_t ctime = 0;; 652 UInt_t *cdatime = nullptr;; 653 char line[kline];; 654 ; 655 TDataType *membertype;; 656 EDataType memberDataType = kNoType_t;; 657 const char *memberName;; 658 const char *memberFullTypeName;; 659 const char *memberTitle;; 660 Bool_t isapointer;; 661 Bool_t isbasic;; 662 Bool_t isarray;; 663 ; 664 if (TDataMember *member = cl->GetDataMember(mname)) {; 665 if (member->GetDataType()) {; 666 memberDataType = (EDataType)member->GetDataType()->GetType();; 667 }; 668 memberName = member->GetName();; 669 memberFullTypeName = member->GetFullTypeName();; 670 memberTitle = member->GetTitle();; 671 isapointer = member->IsaPointer();; 672 isbasic = member->IsBasic();; 673 membertype = member->GetDataType();; 674 isarray = member->GetArrayDim();; 675 } else if (!cl->IsLoaded()) {; 676 // The class is not loaded, hence it is 'emulated' and the main source of; 677 // information is the StreamerInfo.; 678 TVirtualStreamerInfo *info = cl->GetStreamerInfo();; 679 if (!info) return;; 680 const char *cursor = mname;; 681 while ( (*cursor)=='*' ) ++cursor;; 682 TString elname( cursor );; 683 Ssiz_t pos = elname.Index(""["");; 684 if ( pos != kNPOS ) {; 685 elname.Remove( pos );;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:23829,load,loaded,23829,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"sientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:31069,cache,cache,31069,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,61,['cache'],['cache']
Performance,"sification; Double_tfStep! step to be done from current point and direction; Int_tfThreadId! thread id for this navigator; TGeoNode*fTopNode! top physical node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNavigator(); dummy constructor. TGeoNavigator(TGeoManager* geom); Default constructor. TGeoNavigator(const TGeoNavigator& ); Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdDown(TGeoNode* node); Make a daughter of current node current. Can be called only with a valid; daughter node (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * Cr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoNavigator.html:13615,perform,performance,13615,root/html602/TGeoNavigator.html,https://root.cern,https://root.cern/root/html602/TGeoNavigator.html,1,['perform'],['performance']
Performance,"sification; Double_tfStep! step to be done from current point and direction; Int_tfThreadId! thread id for this navigator; TGeoNode*fTopNode! top physical node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNavigator(); dummy constructor. TGeoNavigator(TGeoManager* geom); Default constructor. TGeoNavigator(const TGeoNavigator& ); Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoNavigator.html:13035,perform,performance,13035,root/html532/TGeoNavigator.html,https://root.cern,https://root.cern/root/html532/TGeoNavigator.html,1,['perform'],['performance']
Performance,"sification_PyKeras_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_BDTG.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: TMVA_LSTM for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0494 sec ; Factory : Test method: TMVA_DNN for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0212 sec ; Factory : Test method: PyKeras_LSTM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00597 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it is larger than 200; Factory : Evaluate classifier: TMVA_DNN; : ; TMVA_DNN : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:45851,Load,Loading,45851,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,2,['Load'],"['Loaded', 'Loading']"
Performance,"signal componentforced to zero; # and save those parameters too; ; bkgfrac.setVal(1); bkgfrac.setConstant(True); bkgfrac.removeError(); model.fitTo(refData, PrintLevel=-1); ; w.saveSnapshot(""reference_fit_bkgonly"", params, True); ; ; # Create model and dataset; # -----------------------------------------------; ; w = ROOT.RooWorkspace(""w""); fillWorkspace(w); ; # Exploit convention encoded in named set ""parameters"" and ""observables""; # to use workspace contents w/o need for introspected; model = w[""model""]; ; # Generate data from p.d.f. in given observables; data = model.generate(w.set(""observables""), 1000); ; # Fit model to data; model.fitTo(data, PrintLevel=-1); ; # Plot fitted model and data on frame of first (only) observable; frame = (w.set(""observables"").first()).frame(); data.plotOn(frame); model.plotOn(frame); ; # Overlay plot with model with reference parameters as stored in snapshots; w.loadSnapshot(""reference_fit""); model.plotOn(frame, LineColor=""r""); w.loadSnapshot(""reference_fit_bkgonly""); model.plotOn(frame, LineColor=""r"", LineStyle=""--""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf510_wsnamedsets"", ""rf503_wsnamedsets"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf510_wsnamedsets.png""); ; # Print workspace contents; w.Print(); ; # Workspace will remain in memory after macro finishes; ROOT.gDirectory.Add(w); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:Obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf510__wsnamedsets_8py.html:4361,load,loadSnapshot,4361,doc/master/rf510__wsnamedsets_8py.html,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html,1,['load'],['loadSnapshot']
Performance,"signal model is constructed by a weighted sum over N input distributions. The calculation of the weights is based on Matrix Elements evaluated for the different input scenarios. The number of input files depends on the number of couplings in production and decay vertices, and also whether the decay and production vertices describe the same process or not. ; Definition at line 77 of file RooLagrangianMorphFunc.h. Classes; class  CacheElem;  ; struct  Config;  . Public Types; typedef std::map< const std::string, FlagSet > FlagMap;  ; typedef std::map< const std::string, int > FlagSet;  ; typedef std::map< const std::string, ParamSet > ParamMap;  ; typedef std::map< const std::string, double > ParamSet;  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:1762,Cache,CacheMode,1762,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,1,['Cache'],['CacheMode']
Performance,"signed integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useDefaultGenUse default or distributed event generator; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProdPdf(); Default constructor. RooProdPdf(const char* name, const char* title, Double_t cutOff = 0); Dummy constructor. RooProdPdf(const char* name, const char* title, RooAbsPdf& pdf1, RooAbsPdf& pdf2, Double_t cutOff = 0); Constructor with 2 PDFs (most frequent use case). The optional cutOff parameter can be used as a speed optimization if; one or more of the PDF have sizable regions with very small values,; which would pull the entire product of PDFs to zero in those regions. After each PDF multiplication, the running product is compared with; the cutOff parameter. If the running product is smaller than the; cutOff value, the product series is terminated and remaining PDFs; are not evaluated. There is no magic value of the cutOff, the user should experiment; to find the appropriate balance between speed and precision.; If a cutoff is specified, the PDFs most likely to be small should; be put first in the product. The default cutOff value is zero. RooProdPdf(const char* name, const char* title, const RooArgList& pdfList, Double_t cutOff = 0); Constructor from a list of PDFs. The optional cutOff parameter can be used as a speed optimization if; one or more of the PDF have sizable regions with very small values,; which would pull the entire product of PDFs to zero in those regions. After each PDF multiplication, the running product is compared with; the cut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:47548,optimiz,optimization,47548,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,1,['optimiz'],['optimization']
Performance,"silent . ). static . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5749 of file TClass.cxx. ◆ LoadClassCustom(). TClass * TClass::LoadClassCustom ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5801 of file TClass.cxx. ◆ LoadClassDefault(). TClass * TClass::LoadClassDefault ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the TClassTable or the autoloader. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5771 of file TClass.cxx. ◆ LoadClassInfo(). void TClass::LoadClassInfo ; (; ); const. private . Try to load the ClassInfo if available. ; This function may require parsing the header file and/or loading data from the clang pcm. If further calls to this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set to false. ; Definition at line 5824 of file TClass.cxx. ◆ ls(). void TClass::ls ; (; Option_t * ; options = """"); const. overridevirtual . The ls function lists the contents of a class on stdout. ; Ls output is typically much less ve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:102627,Load,LoadClassDefault,102627,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['Load'],['LoadClassDefault']
Performance,"silent . ). static . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5816 of file TClass.cxx. ◆ LoadClassCustom(). TClass * TClass::LoadClassCustom ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5868 of file TClass.cxx. ◆ LoadClassDefault(). TClass * TClass::LoadClassDefault ; (; const char * ; requestedname, . Bool_t ; silent . ). staticprivate . Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' from the TClassTable or the autoloader. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 5838 of file TClass.cxx. ◆ LoadClassInfo(). void TClass::LoadClassInfo ; (; ); const. private . Try to load the ClassInfo if available. ; This function may require parsing the header file and/or loading data from the clang pcm. If further calls to this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set to false. ; Definition at line 5891 of file TClass.cxx. ◆ ls(). void TClass::ls ; (; Option_t * ; options = """"); const. overridevirtual . The ls function lists the contents of a class on stdout. ; Ls output is typically much less ve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:102628,Load,LoadClassDefault,102628,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['Load'],['LoadClassDefault']
Performance,"simply a number); or relative to the number of input nodes to the neural net (N); * there is always a single node in the output layer; example: a net with 6 input nodes and ""Hiddenlayers=N-1,N-2"" has 6,5,4,1 nodes in the; layers 1,2,3,4, repectively. void ProcessOptions(); builds the neural network as specified by the user. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); rebuild temporary textfile from xml weightfile and load this; file into MLP. void ReadWeightsFromStream(istream& istr); read weights from stream; since the MLP can not read from the stream, we; 1st: write the weights to temporary file. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for classifier -> overwrites base class function; create specific class for TMultiLayerPerceptron. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response; nothing to do here - all taken care of by TMultiLayerPerceptron. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodTMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0). void SetHiddenLayer(TString hiddenlayer = """"); { fHiddenLayer=hiddenlayer; }. const Ranking* CreateRanking(); ranking o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodTMlpANN.html:20213,load,load,20213,root/html602/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodTMlpANN.html,2,['load'],['load']
Performance,"simply a number); or relative to the number of input nodes to the neural net (N); * there is always a single node in the output layer; example: a net with 6 input nodes and ""Hiddenlayers=N-1,N-2"" has 6,5,4,1 nodes in the; layers 1,2,3,4, repectively. void ProcessOptions(); builds the neural network as specified by the user. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); rebuild temporary textfile from xml weightfile and load this; file into MLP. void ReadWeightsFromStream(istream& istr); read weights from stream; since the MLP can not read from the stream, we; 1st: write the weights to temporary file. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for classifier -> overwrites base class function; create specific class for TMultiLayerPerceptron. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response; nothing to do here - all taken care of by TMultiLayerPerceptron. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". void SetHiddenLayer(TString hiddenlayer = """"); { fHiddenLayer=hiddenlayer; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodTMlpANN.html:19026,load,load,19026,root/html534/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodTMlpANN.html,1,['load'],['load']
Performance,"simply a number); or relative to the number of input nodes to the neural net (N); * there is always a single node in the output layer; example: a net with 6 input nodes and ""Hiddenlayers=N-1,N-2"" has 6,5,4,1 nodes in the; layers 1,2,3,4, repectively. void ProcessOptions(); builds the neural network as specified by the user. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); rebuild temporary textfile from xml weightfile and load this; file into MLP. void ReadWeightsFromStream(istream& istr); read weights from stream; since the MLP can not read from the stream, we; 1st: write the weights to temporary file. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for classifier -> overwrites base class function; create specific class for TMultiLayerPerceptron. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response; nothing to do here - all taken care of by TMultiLayerPerceptron. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". void SetHiddenLayer(TString hiddenlayer = """"); { fHiddenLayer=hiddenlayer; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodTMlpANN.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodTMlpANN.html:18343,load,load,18343,root/html528/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodTMlpANN.html,3,['load'],['load']
Performance,"sing Keras""); else:; # book PyKeras method only if Keras model could be created; print(""Booking Keras model "", rnn_types[i]); factory.BookMethod(; dataloader,; TMVA.Types.kPyKeras,; ""PyKeras_"" + rnn_types[i],; H=True,; V=False,; VarTransform=None,; FilenameModel=modelName,; FilenameTrainedModel=""trained_"" + modelName,; NumEpochs=maxepochs,; BatchSize=batchSize,; GpuOptions=""allow_growth=True"",; ); ; ; # use BDT in case not using Keras or TMVA DL; if not useKeras or not useTMVA_BDT:; useTMVA_BDT = True; ; ; ## Book TMVA BDT; ; ; if useTMVA_BDT:; factory.BookMethod(; dataloader,; TMVA.Types.kBDT,; ""BDTG"",; H=True,; V=False,; NTrees=100,; MinNodeSize=""2.5%"",; BoostType=""Grad"",; Shrinkage=0.10,; UseBaggedBoost=True,; BaggedSampleFraction=0.5,; nCuts=20,; MaxDepth=2,; ); ; ; ## Train all methods; factory.TrainAllMethods(); ; print(""nthreads = {}"".format(ROOT.GetThreadPoolSize())); ; # ---- Evaluate all MVAs using the set of test events; factory.TestAllMethods(); ; # ----- Evaluate and compare performance of all configured MVAs; factory.EvaluateAllMethods(); ; # check method; ; # plot ROC curve; c1 = factory.GetROCCurve(dataloader); c1.Draw(); ; if outputFile:; outputFile.Close(); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGW",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:61363,perform,performance,61363,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['perform'],['performance']
Performance,"sing remote repositories. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataSetManagerFile(const char* group, const char* user, const char* ins). Main constructor. TDataSetManagerFile(const char* ins). Main constructor. void Init(); Do the real inititialization. void InitLocalCache(); Init the local cache if required. void ParseInitOpts(const char* opts); Parse the input string and set the init bits accordingly; Format is; dir:<datasetdir> [mss:<mss-url>] [opt:<base-options>]; The <datasetdir> is mandatory.; See TDataSetManager::ParseInitOpts for the available; base options.; The base options are already initialized by the base constructor. const char * GetDataSetPath(const char* group, const char* user, const char* dsName, TString& md5path, Bool_t local = kFALSE); Returns path of the indicated dataset. The extension is '.root' for all files; except for 'dsName==ls' which have extension '.txt'.; If 'local' is kTRUE the local cache path is returned instead in the form; <cachedir>/<group>.<user>.<dsName>.<ext>.; NB: contains a static TString for result, so copy result before using twice. Int_t NotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); Save into the <datasetdir>/kDataSet_DataSetList file the name of the updated; or created or modified dataset. For still existing datasets, fill the; modification date in seconds anf the checksum.; Returns 0 on success, -1 on error. Int_t CreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); Create or recreate the dataset lists for 'uri'.; The list are saved in text form in 'uri'/ls.txt for fast browsing and in; 'uri'/ls.root in form of TMacro for optimized and portable transfer.; Return 0 on success, 1 if the file was empty, -1 on error. Bool_t BrowseDataSets(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Adds the dataset in the folder of group, user to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDataSetManagerFile.html:13298,cache,cache,13298,root/html534/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html534/TDataSetManagerFile.html,6,['cache'],"['cache', 'cachedir']"
Performance,"sing remote repositories. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataSetManagerFile(const char* group, const char* user, const char* ins). Main constructor. TDataSetManagerFile(const char* ins). Main constructor. void Init(); Do the real inititialization. void InitLocalCache(); Init the local cache if required. void ParseInitOpts(const char* opts); Parse the input string and set the init bits accordingly; Format is; dir:<datasetdir> [mss:<mss-url>] [opt:<base-options>]; The <datasetdir> is mandatory.; See TDataSetManager::ParseInitOpts for the available; base options.; The base options are laready initialized by the base constructor. const char * GetDataSetPath(const char* group, const char* user, const char* dsName, TString& md5path, Bool_t local = kFALSE); Returns path of the indicated dataset. The extension is '.root' for all files; except for 'dsName==ls' which have extension '.txt'.; If 'local' is kTRUE the local cache path is returned instead in the form; <cachedir>/<group>.<user>.<dsName>.<ext>.; NB: contains a static TString for result, so copy result before using twice. Int_t NotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); Save into the <datasetdir>/kDataSet_DataSetList file the name of the updated; or created or modified dataset. For still existing datasets, fill the; modification date in seconds anf the checksum.; Returns 0 on success, -1 on error. Int_t CreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); Create or recreate the dataset lists for 'uri'.; The list are saved in text form in 'uri'/ls.txt for fast browsing and in; 'uri'/ls.root in form of TMacro for optimized and portable transfer.; Return 0 on success, 1 if the file was empty, -1 on error. Bool_t BrowseDataSets(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Adds the dataset in the folder of group, user to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManagerFile.html:12676,cache,cache,12676,root/html528/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html528/TDataSetManagerFile.html,6,['cache'],"['cache', 'cachedir']"
Performance,"singNamespaces (ClassInfo_t *cl) const =0;  ; virtual Bool_t HasPCMForLibrary (const char *libname) const =0;  ; virtual void Initialize ()=0;  ; virtual void InspectMembers (TMemberInspector &, const void *obj, const TClass *cl, Bool_t isTransient)=0;  ; TClass * IsA () const override;  ; virtual Bool_t IsAutoParsingSuspended () const =0;  ; virtual Bool_t IsErrorMessagesEnabled () const =0;  ; virtual Bool_t IsFloatingType (const void *) const;  ; virtual Bool_t IsIntegerType (const void *) const;  ; virtual Bool_t IsLibraryLoaded (const char *libname) const =0;  ; virtual Bool_t IsLoaded (const char *filename) const =0;  ; virtual Bool_t IsPointerType (const void *) const;  ; virtual Bool_t IsProcessLineLocked () const =0;  ; virtual Bool_t IsSameType (const void *, const void *) const;  ; virtual Bool_t IsSignedIntegerType (const void *) const;  ; virtual Bool_t IsUnsignedIntegerType (const void *) const;  ; virtual Bool_t IsVoidPointerType (const void *) const;  ; virtual Int_t Load (const char *filenam, Bool_t system=kFALSE)=0;  ; virtual void LoadEnums (TListOfEnums &cl) const =0;  ; virtual int LoadFile (const char *) const;  ; virtual void LoadFunctionTemplates (TClass *cl) const =0;  ; virtual Int_t LoadLibraryMap (const char *rootmapfile=nullptr)=0;  ; virtual void LoadMacro (const char *filename, EErrorCode *error=nullptr)=0;  ; virtual Bool_t LoadText (const char *) const;  ; virtual std::unique_ptr< TInterpreterValue > MakeInterpreterValue () const;  ; virtual const char * MapCppName (const char *) const;  ; virtual const char * MethodArgInfo_DefaultValue (MethodArgInfo_t *) const;  ; virtual void MethodArgInfo_Delete (MethodArgInfo_t *) const;  ; virtual MethodArgInfo_t * MethodArgInfo_Factory () const;  ; virtual MethodArgInfo_t * MethodArgInfo_Factory (MethodInfo_t *) const;  ; virtual MethodArgInfo_t * MethodArgInfo_FactoryCopy (MethodArgInfo_t *) const;  ; virtual Bool_t MethodArgInfo_IsValid (MethodArgInfo_t *) const;  ; virtual const char * Metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTInterpreter.html:18123,Load,Load,18123,doc/master/classTInterpreter.html,https://root.cern,https://root.cern/doc/master/classTInterpreter.html,1,['Load'],['Load']
Performance,"sion tree will modified such that all nodes that depend directly or indirectly on any of the listed observables will be set to ADirty, as they are expected to change every time. This save change tracking overhead for nodes that are a priori known to change every time ; Definition at line 1782 of file RooAbsArg.cxx. ◆ optimizeCacheMode() [2/2]. void RooAbsArg::optimizeCacheMode ; (; const RooArgSet & ; observables, . RooArgSet & ; optimizedNodes, . RooLinkedList & ; processedNodes . ). virtual . Activate cache mode optimization with given definition of observables. ; The cache operation mode of all objects in the expression tree will modified such that all nodes that depend directly or indirectly on any of the listed observables will be set to ADirty, as they are expected to change every time. This save change tracking overhead for nodes that are a priori known to change every time ; Definition at line 1801 of file RooAbsArg.cxx. ◆ optimizeDirtyHook(). virtual void RooAbsArg::optimizeDirtyHook ; (; const RooArgSet * ; ). inlineprotectedvirtual . Definition at line 564 of file RooAbsArg.h. ◆ overlaps(). bool RooAbsArg::overlaps ; (; const RooAbsArg & ; testArg, . bool ; valueOnly = false . ); const. Test if any of the nodes of tree are shared with that of the given tree. ; Definition at line 900 of file RooAbsArg.cxx. ◆ ownedComponents(). const RooArgSet * RooAbsArg::ownedComponents ; (; ); const. inline . Definition at line 519 of file RooAbsArg.h. ◆ Print(). void RooAbsArg::Print ; (; Option_t * ; options = nullptr); const. inlineoverridevirtual . Print the object to the defaultPrintStream(). ; Parameters. [in]optionsV print verbose. T print a tree structure with all children. . Reimplemented from TObject.; Definition at line 294 of file RooAbsArg.h. ◆ printAddress(). void RooAbsArg::printAddress ; (; std::ostream & ; os); const. overridevirtual . Print address of this RooAbsArg. ; Reimplemented from RooPrintable.; Definition at line 1546 of file RooAbsArg.cxx. ◆ pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:79155,optimiz,optimizeDirtyHook,79155,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"sions(). TList * TSessionViewer::GetSessions ; (; ); const. inline . Definition at line 580 of file TSessionViewer.h. ◆ GetStatusBar(). TGStatusBar * TSessionViewer::GetStatusBar ; (; ); const. inline . Definition at line 592 of file TSessionViewer.h. ◆ HandleTimer(). Bool_t TSessionViewer::HandleTimer ; (; TTimer * ; ). overridevirtual . Handle animation timer. ; Reimplemented from TGWindow.; Definition at line 5011 of file TSessionViewer.cxx. ◆ IsA(). TClass * TSessionViewer::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGMainFrame.; Definition at line 631 of file TSessionViewer.h. ◆ IsAutoSave(). Bool_t TSessionViewer::IsAutoSave ; (; ); const. inline . Definition at line 605 of file TSessionViewer.h. ◆ IsBusy(). Bool_t TSessionViewer::IsBusy ; (; ); const. inline . Definition at line 604 of file TSessionViewer.h. ◆ LogMessage(). void TSessionViewer::LogMessage ; (; const char * ; msg, . Bool_t ; all . ). Load/append a log msg in the log frame. ; Definition at line 5051 of file TSessionViewer.cxx. ◆ MyHandleMenu(). void TSessionViewer::MyHandleMenu ; (; Int_t ; id). Handle session viewer custom popup menus. ; Definition at line 5500 of file TSessionViewer.cxx. ◆ OnCascadeMenu(). void TSessionViewer::OnCascadeMenu ; (; ). Handle feedback histograms configuration menu. ; Definition at line 5564 of file TSessionViewer.cxx. ◆ OnListTreeClicked(). void TSessionViewer::OnListTreeClicked ; (; TGListTreeItem * ; entry, . Int_t ; btn, . Int_t ; x, . Int_t ; y . ). Handle mouse clicks in list tree. ; Definition at line 4635 of file TSessionViewer.cxx. ◆ OnListTreeDoubleClicked(). void TSessionViewer::OnListTreeDoubleClicked ; (; TGListTreeItem * ; entry, . Int_t ; btn . ). Handle mouse double clicks in list tree (connect to server). ; Definition at line 4895 of file TSessionViewer.cxx. ◆ ProcessMessage(). Bool_t TSessionViewer::ProcessMessage ; (; Longptr_t ; msg, . Longptr_t ; parm1, . Longptr_t ;  . ). overridevi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionViewer.html:46450,Load,Load,46450,doc/master/classTSessionViewer.html,https://root.cern,https://root.cern/doc/master/classTSessionViewer.html,1,['Load'],['Load']
Performance,"sis code is running. When called from main thread and can_run_immediately==kTRUE, will be executed immediately.; Returns kTRUE when was executed. ; Definition at line 681 of file THttpServer.cxx. ◆ Unregister(). Bool_t THttpServer::Unregister ; (; TObject * ; obj). Unregister object. ; Unregister object in folders hierarchy.; See TRootSniffer::UnregisterObject() for more details ; Definition at line 1253 of file THttpServer.cxx. ◆ UnregisterWS(). void THttpServer::UnregisterWS ; (; std::shared_ptr< THttpWSHandler > ; ws). Unregister WS handler. ; Unregister WS handler to the THttpServer. ; Definition at line 1272 of file THttpServer.cxx. ◆ VerifyFilePath(). Bool_t THttpServer::VerifyFilePath ; (; const char * ; fname). staticprotected . Checked that filename does not contains relative path below current directory. ; Used to prevent access to files below current directory ; Definition at line 562 of file THttpServer.cxx. Member Data Documentation. ◆ fArgs. std::queue<std::shared_ptr<THttpCallArg> > THttpServer::fArgs. protected . ! submitted arguments ; Definition at line 58 of file THttpServer.h. ◆ fCors. std::string THttpServer::fCors. protected . ! CORS: sets Access-Control-Allow-Origin header for ProcessRequest responses ; Definition at line 54 of file THttpServer.h. ◆ fCorsCredentials. std::string THttpServer::fCorsCredentials. protected . ! CORS: add Access-Control-Allow-Credentials: true response header ; Definition at line 55 of file THttpServer.h. ◆ fDefaultPage. std::string THttpServer::fDefaultPage. protected . ! file name for default page name ; Definition at line 50 of file THttpServer.h. ◆ fDefaultPageCont. std::string THttpServer::fDefaultPageCont. protected . ! content of default html page ; Definition at line 51 of file THttpServer.h. ◆ fDrawPage. std::string THttpServer::fDrawPage. protected . ! file name for drawing of single element ; Definition at line 52 of file THttpServer.h. ◆ fDrawPageCont. std::string THttpServer::fDrawPageCont. protected . !",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:39314,queue,queue,39314,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['queue'],['queue']
Performance,"sistency checks, default fit range as the whole histogram but without under- and overflows, and declaration of the fit parameters). Note that the histograms are not copied, only references are used. Parameters. [in]datahistogram to be fitted ; [in]MCsarray of TH1* corresponding template distributions ; [in]optioncan be used to control the print level of the minimization algorithm; option = ""Q"" : quite - no message is printed; option = ""V"" : verbose - max print out; option = """" : default: print initial fraction values and result . Definition at line 193 of file TFractionFitter.cxx. ◆ ~TFractionFitter(). TFractionFitter::~TFractionFitter ; (; ). override . TFractionFitter default destructor. ; Definition at line 257 of file TFractionFitter.cxx. Member Function Documentation. ◆ CheckConsistency(). void TFractionFitter::CheckConsistency ; (; ). private . Function used internally to check the consistency between the various histograms. ; Checks are performed on nonexistent or empty histograms, the precise histogram class, and the number of bins. In addition, integrals over the ""allowed"" bin ranges are computed. Any inconsistency results in a error. ; Definition at line 484 of file TFractionFitter.cxx. ◆ CheckParNo(). void TFractionFitter::CheckParNo ; (; Int_t ; parm); const. private . Function for internal use, checking parameter validity An invalid parameter results in an error. ; Definition at line 327 of file TFractionFitter.cxx. ◆ Class(). static TClass * TFractionFitter::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TFractionFitter::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TFractionFitter::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 112 of file TFractionFitter.h. ◆ ComputeChisquareLambda(). void TFractionFitter::ComputeChisquareLambda ; (; ). private . Method used internally to compute the likelihood rat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFractionFitter.html:22830,perform,performed,22830,doc/master/classTFractionFitter.html,https://root.cern,https://root.cern/doc/master/classTFractionFitter.html,1,['perform'],['performed']
Performance,"siteFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; Bool_tTGWidget::IsEnabled() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTGTextView::IsMarked() const; Bool_tTObject::IsOnHeap() const; Bool_tTGTextView::IsReadOnly() const; virtual Bool_tTGTextView::IsSaved(); virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; long&ios_base::iword(int __ix); virtual voidTGTextView::Layout(); virtual Bool_tTGTextView::LoadBuffer(const char* txtbuf); virtual Bool_tTGTextView::LoadFile(const char* fname, long startpos = 0, long length = -1); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); virtual voidTGTextView::Marked(Bool_t mark)SIGNAL ; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; charbasic_ios<char,char_traits<char> >::narrow(basic_ios<char,char_traits<char> >::char_type __c, char __dfault) const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGTextViewostream.html:12465,Load,LoadFile,12465,root/html604/TGTextViewostream.html,https://root.cern,https://root.cern/root/html604/TGTextViewostream.html,1,['Load'],['LoadFile']
Performance,"sition on file of buffers to be prefetched (sorted); Int_t*fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheRead(); Default Constructor. TFileCacheRead(TFile* file, Int_t buffersize); Creates a TFileCacheRead data structure. ~TFileCacheRead(); Destructor. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFileCacheRead(const TFileCacheRead& ). TFileCacheRead& operator=(const TFileCacheRead& ). void AddBranch(TBranch* , Bool_t = kFALSE); {}. void AddBranch(const char* , Bool_t = kFALSE); {}. Int_t GetBufferSize(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileCacheRead.html:8065,cache,cache,8065,root/html528/TFileCacheRead.html,https://root.cern,https://root.cern/root/html528/TFileCacheRead.html,1,['cache'],['cache']
Performance,"sityCorrection);  Import data from given set of TH1/2/3 into this RooDataHist. ;  ; void initialize (const char *binningName=nullptr, bool fillTree=true);  Initialization procedure: allocate weights array, calculate multipliers needed for N-space to 1-dim array jump table, and fill the internal tree with all bin center coordinates. ;  ; double interpolateDim (int iDim, double xval, size_t centralIdx, int intOrder, bool correctForBinSize, bool cdfBoundaries);  Perform boundary safe 'intOrder'-th interpolation of weights in dimension 'dim' at current value 'xval'. ;  ; std::unique_ptr< RooAbsData > reduceEng (const RooArgSet &varSubset, const RooFormulaVar *cutVar, const char *cutRange=nullptr, std::size_t nStart=0, std::size_t nStop=std::numeric_limits< std::size_t >::max()) const override;  Implementation of RooAbsData virtual method that drives the RooAbsData::reduce() methods. ;  ;  Protected Member Functions inherited from RooAbsData; bool allClientsCached (RooAbsArg *, const RooArgSet &);  Utility function that determines if all clients of object 'var' appear in given list of cached nodes. ;  ; virtual void attachCache (const RooAbsArg *newOwner, const RooArgSet &cachedVars);  Internal method – Attach dataset copied with cache contents to copied instances of functions. ;  ; virtual void cacheArgs (const RooAbsArg *owner, RooArgSet &varSet, const RooArgSet *nset=nullptr, bool skipZeroWeights=false);  Internal method – Cache given set of functions with data. ;  ; double corrcov (const RooRealVar &x, const RooRealVar &y, const char *cutSpec, const char *cutRange, bool corr) const;  Internal method to calculate single correlation and covariance elements. ;  ; RooFit::OwningPtr< TMatrixDSym > corrcovMatrix (const RooArgList &vars, const char *cutSpec, const char *cutRange, bool corr) const;  Return covariance matrix from data for given list of observables. ;  ; RooRealVar * dataRealVar (const char *methodname, const RooRealVar &extVar) const;  Internal method to check",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:35824,cache,cached,35824,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['cache'],['cached']
Performance,"siveObjectCache::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 81 of file RooExpensiveObjectCache.h. ◆ clearAll(). void RooExpensiveObjectCache::clearAll ; (; ). Clear all cache elements. ; Definition at line 164 of file RooExpensiveObjectCache.cxx. ◆ clearObj(). bool RooExpensiveObjectCache::clearObj ; (; Int_t ; uniqueID). Clear cache element with given unique ID Retrieve payload object of cache element with given unique ID. ; Definition at line 131 of file RooExpensiveObjectCache.cxx. ◆ DeclFileName(). static const char * RooExpensiveObjectCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 81 of file RooExpensiveObjectCache.h. ◆ empty(). bool RooExpensiveObjectCache::empty ; (; ); const. inline . Definition at line 44 of file RooExpensiveObjectCache.h. ◆ getObj(). const TObject * RooExpensiveObjectCache::getObj ; (; Int_t ; uniqueID). Retrieve payload object of cache element with given unique ID. ; Definition at line 115 of file RooExpensiveObjectCache.cxx. ◆ importCacheObjects(). void RooExpensiveObjectCache::importCacheObjects ; (; RooExpensiveObjectCache & ; other, . const char * ; ownerName, . bool ; verbose = false . ). Definition at line 296 of file RooExpensiveObjectCache.cxx. ◆ instance(). RooExpensiveObjectCache & RooExpensiveObjectCache::instance ; (; ). static . Return reference to singleton instance. ; Definition at line 58 of file RooExpensiveObjectCache.cxx. ◆ IsA(). TClass * RooExpensiveObjectCache::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 81 of file RooExpensiveObjectCache.h. ◆ print(). void RooExpensiveObjectCache::print ; (; ); const. Definition at line 259 of file RooExpensiveObjectCache.cxx. ◆ registerObject(). bool RooExpensiveObjectCache::registerObject ; (; const char * ; ownerName, . const char * ; objectName, . TObject & ; cacheObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExpensiveObjectCache.html:13638,cache,cache,13638,doc/master/classRooExpensiveObjectCache.html,https://root.cern,https://root.cern/doc/master/classRooExpensiveObjectCache.html,1,['cache'],['cache']
Performance,"size = (height*width); ; # Then one add Convolutional layers and MaxPool layers.; ; # - For Convolutional layer the option string has to be:; # - CONV | number of units | filter height | filter width | stride height | stride width | padding height | paddig; # width | activation function; ; # - note in this case we are using a filer 3x3 and padding=1 and stride=1 so we get the output dimension of the; # conv layer equal to the input; ; # - note we use after the first convolutional layer a batch normalization layer. This seems to help significantly the; # convergence; ; # - For the MaxPool layer:; # - MAXPOOL | pool height | pool width | stride height | stride width; ; # The RESHAPE layer is needed to flatten the output before the Dense layer; ; # Note that to run the CNN is required to have CPU or GPU support; ; ; if useTMVACNN:; # Training strategies.; trainingString1 = ROOT.TString(; ""LearningRate=1e-3,Momentum=0.9,Repetitions=1,""; ""ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,""; ""WeightDecay=1e-4,Regularization=None,""; ""Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.0""; ); trainingString1 += "",MaxEpochs="" + str(max_epochs); ; ## New DL (CNN); cnnMethodName = ""TMVA_CNN_CPU""; cnnOptions = ""CPU""; # use GPU if available; if hasGPU:; cnnOptions = ""GPU""; cnnMethodName = ""TMVA_CNN_GPU""; ; factory.BookMethod(; loader,; TMVA.Types.kDL,; cnnMethodName,; H=False,; V=True,; ErrorStrategy=""CROSSENTROPY"",; VarTransform=None,; WeightInitialization=""XAVIER"",; InputLayout=""1|16|16"",; Layout=""CONV|10|3|3|1|1|1|1|RELU,BNORM,CONV|10|3|3|1|1|1|1|RELU,MAXPOOL|2|2|1|1,RESHAPE|FLAT,DENSE|100|RELU,DENSE|1|LINEAR"",; TrainingStrategy=trainingString1,; Architecture=cnnOptions,; ); ; ; ### Book Convolutional Neural Network in Keras using a generated model; ; ; if usePyTorchCNN:; ROOT.Info(""TMVA_CNN_Classification"", ""Using Convolutional PyTorch Model""); pyTorchFileName = str(ROOT.gROOT.GetTutorialDir()); pyTorchFileName += ""/tmva/PyTorch_Generate_CNN_Model.py""; # check that pytorch can be impor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:12226,Optimiz,Optimizer,12226,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['Optimiz'],['Optimizer']
Performance,"size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 1899 of file TTreeCache.cxx. ◆ ProcessMiss(). bool TTreeCache::ProcessMiss ; (; Long64_t ; pos, . int ; len . ). private . ! Given a file read not in the miss cache, handle (possibly) loading the data. ; Process a cache miss; (pos, len) isn't in the buffer.; The first time we have a miss, we buffer as many baskets we can (up to the maximum size of the TTreeCache) in memory from all branches that are not in the prefetch list.; Subsequent times, we fetch all the buffers corresponding to branches that had previously seen misses. If it turns out the (pos, len) isn't in the list of branches, we treat this as if it was the first miss.; Returns true if we were able to pull the data into the miss cache. ; Definition at line 863 of file TTreeCache.cxx. ◆ ReadBuffer(). Int_t TTreeCache::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). overridevi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:45508,cache,cachedbranches,45508,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,4,['cache'],"['cached', 'cachedbranches']"
Performance,"size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TTreeCache.; Definition at line 947 of file TTreeCacheUnzip.cxx. ◆ ReadBufferExt(). Int_t TTreeCacheUnzip::ReadBufferExt ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). overridevirtual . Reimplemented from TFileCacheRead.; Definition at line 961 of file TTreeCacheUnzip.cxx. ◆ ResetCache(). void TTreeCacheUnzip::ResetCache ; (; ). overridevirtual . This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ; This name is ambiguos because the method doesn't reset the whole cache, only the part related to the unzipping Note: This method is completely different from TTreeCache::ResetCache(), in that method we were cleaning the prefetching buffer while here we delete the information about the unzipped buffers ; Reimplemented from TTreeCache.; Definition at line 501 of file TTreeCacheUnzip.cxx. ◆ SetBufferSize(). Int_t TTreeCacheUnzip::SetBufferSize ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:33724,cache,cachedbranches,33724,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,2,['cache'],"['cached', 'cachedbranches']"
Performance,"size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TTreeCache.; Definition at line 948 of file TTreeCacheUnzip.cxx. ◆ ReadBufferExt(). Int_t TTreeCacheUnzip::ReadBufferExt ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). overridevirtual . Reimplemented from TFileCacheRead.; Definition at line 962 of file TTreeCacheUnzip.cxx. ◆ ResetCache(). void TTreeCacheUnzip::ResetCache ; (; ). overridevirtual . This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ; This name is ambiguos because the method doesn't reset the whole cache, only the part related to the unzipping Note: This method is completely different from TTreeCache::ResetCache(), in that method we were cleaning the prefetching buffer while here we delete the information about the unzipped buffers ; Reimplemented from TTreeCache.; Definition at line 502 of file TTreeCacheUnzip.cxx. ◆ SetBufferSize(). Int_t TTreeCacheUnzip::SetBufferSize ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:33728,cache,cachedbranches,33728,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,2,['cache'],"['cached', 'cachedbranches']"
Performance,"size of branches in cache; static Int_tTTreeCache::fgLearnEntriesNumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:12624,cache,cache,12624,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"size of branches in cache; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCacheUnzip.html:14605,cache,cache,14605,root/html530/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html530/TTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"size of the existing parameters); 187 virtual bool SetVariableValues(const double * x) {; 188 bool ret = true;; 189 unsigned int i = 0;; 190 while ( i <= NDim() && ret) {; 191 ret &= SetVariableValue(i,x[i] ); i++;; 192 }; 193 return ret;; 194 }; 195 virtual bool SetVariableStepSize(unsigned int ivar, double value );; 196 virtual bool SetVariableLowerLimit(unsigned int ivar, double lower);; 197 virtual bool SetVariableUpperLimit(unsigned int ivar, double upper);; 198 /// set the limits of an already existing variable; 199 virtual bool SetVariableLimits(unsigned int ivar, double lower, double upper) {; 200 return SetVariableLowerLimit(ivar,lower) && SetVariableUpperLimit(ivar,upper);; 201 }; 202 virtual bool FixVariable(unsigned int ivar);; 203 virtual bool ReleaseVariable(unsigned int ivar);; 204 virtual bool IsFixedVariable(unsigned int ivar) const;; 205 virtual bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings & pars) const;; 206 ; 207 /// set the initial range of an existing variable; 208 virtual bool SetVariableInitialRange(unsigned int /* ivar */, double /* mininitial */, double /* maxinitial */) {; 209 return false;; 210 }; 211 ; 212 /// method to perform the minimization; 213 virtual bool Minimize() = 0;; 214 ; 215 /// return minimum function value; 216 virtual double MinValue() const = 0;; 217 ; 218 /// return pointer to X values at the minimum; 219 virtual const double * X() const = 0;; 220 ; 221 /// return expected distance reached from the minimum (re-implement if minimizer provides it; 222 virtual double Edm() const { return -1; }; 223 ; 224 /// return pointer to gradient values at the minimum; 225 virtual const double * MinGradient() const { return nullptr; }; 226 ; 227 /// number of function calls to reach the minimum; 228 virtual unsigned int NCalls() const { return 0; }; 229 ; 230 /// number of iterations to reach the minimum; 231 virtual unsigned int NIterations() const { return NCalls(); }; 232 ; 233 /// this is <= Function().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Minimizer_8h_source.html:9924,perform,perform,9924,doc/master/Minimizer_8h_source.html,https://root.cern,https://root.cern/doc/master/Minimizer_8h_source.html,1,['perform'],['perform']
Performance,"size was not fixed (old files and; 606/// case where autoflush was explicitly set to zero), we need estimate; 607/// a cluster size in relation to the size of the cache.; 608///; 609/// After this value is calculated once for the TClusterIterator, it is; 610/// cached and reused in future calls.; 611 ; 612Long64_t TTree::TClusterIterator::GetEstimatedClusterSize(); 613{; 614 auto autoFlush = fTree->GetAutoFlush();; 615 if (autoFlush > 0) return autoFlush;; 616 if (fEstimatedSize > 0) return fEstimatedSize;; 617 ; 618 Long64_t zipBytes = fTree->GetZipBytes();; 619 if (zipBytes == 0) {; 620 fEstimatedSize = fTree->GetEntries() - 1;; 621 if (fEstimatedSize <= 0); 622 fEstimatedSize = 1;; 623 } else {; 624 Long64_t clusterEstimate = 1;; 625 Long64_t cacheSize = fTree->GetCacheSize();; 626 if (cacheSize == 0) {; 627 // Humm ... let's double check on the file.; 628 TFile *file = fTree->GetCurrentFile();; 629 if (file) {; 630 TFileCacheRead *cache = fTree->GetReadCache(file);; 631 if (cache) {; 632 cacheSize = cache->GetBufferSize();; 633 }; 634 }; 635 }; 636 // If neither file nor tree has a cache, use the current default.; 637 if (cacheSize <= 0) {; 638 cacheSize = 30000000;; 639 }; 640 clusterEstimate = fTree->GetEntries() * cacheSize / zipBytes;; 641 // If there are no entries, then just default to 1.; 642 fEstimatedSize = clusterEstimate ? clusterEstimate : 1;; 643 }; 644 return fEstimatedSize;; 645}; 646 ; 647////////////////////////////////////////////////////////////////////////////////; 648/// Move on to the next cluster and return the starting entry; 649/// of this next cluster; 650 ; 651Long64_t TTree::TClusterIterator::Next(); 652{; 653 fStartEntry = fNextEntry;; 654 if (fTree->fNClusterRange || fTree->GetAutoFlush() > 0) {; 655 if (fClusterRange == fTree->fNClusterRange) {; 656 // We are looking at a range which size; 657 // is defined by AutoFlush itself and goes to the GetEntries.; 658 fNextEntry += GetEstimatedClusterSize();; 659 } else {; 660 if (fStartEnt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:24586,cache,cache,24586,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,5,['cache'],"['cache', 'cacheSize']"
Performance,"size=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; Int_t AddBranch (const char *branch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; Int_t AddBranch (TBranch *b, bool subgbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; virtual bool FillBuffer ();  Fill the cache buffer with the branches in the cache. ;  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:13048,cache,cache,13048,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,4,['cache'],['cache']
Performance,"sizeof(Double_t));; 198 }; 199 void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); 200 {; 201 fLastSafety = safe;; 202 fLastPoint[0] = x;; 203 fLastPoint[1] = y, fLastPoint[2] = z;; 204 }; 205 ; 206 // Check if we have a cached safety value from parallel world, and if this can still be used.; 207 // Return negative value if no cache available.; 208 Double_t GetPWSafetyEstimateFromCache(Double_t cpoint[3]) const; 209 {; 210 // disregard too small or invalid safeties; 211 if (fLastPWSafety < TGeoShape::Tolerance()) {; 212 return -1.;; 213 }; 214 const auto d0 = fLastPWSaftyPnt[0] - cpoint[0];; 215 const auto d1 = fLastPWSaftyPnt[1] - cpoint[1];; 216 const auto d2 = fLastPWSaftyPnt[2] - cpoint[2];; 217 const auto d_sq = d0 * d0 + d1 * d1 + d2 * d2;; 218 // if we have moved too much return -1 as ""invalid""; 219 if (d_sq >= (fLastPWSafety * fLastPWSafety)) {; 220 return -1.;; 221 }; 222 // or return a reasonable cache estimate for safety; 223 return fLastPWSafety - std::sqrt(d_sq);; 224 }; 225 ; 226 // Wrapper for getting the safety from the parallel world.; 227 // Takes care of caching mechanics and talking to the Safety function of parallel world.; 228 Double_t GetPWSafety(Double_t cpoint[3], Double_t saf_max);; 229 ; 230 // enable/disable parallel world safety caching; 231 static void SetPWSafetyCaching(Bool_t b) { fgUsePWSafetyCaching = b; }; 232 static Bool_t IsPWSafetyCaching() { return fgUsePWSafetyCaching; }; 233 ; 234 //--- point/vector reference frame conversion; 235 void LocalToMaster(const Double_t *local, Double_t *master) const { fCache->LocalToMaster(local, master); }; 236 void LocalToMasterVect(const Double_t *local, Double_t *master) const { fCache->LocalToMasterVect(local, master); }; 237 void LocalToMasterBomb(const Double_t *local, Double_t *master) const { fCache->LocalToMasterBomb(local, master); }; 238 void MasterToLocal(const Double_t *master, Double_t *local) const { fCache->MasterToLocal(master, local); }; 239 void Maste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:10991,cache,cache,10991,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['cache'],['cache']
Performance,"sk; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. stringRooAbsTestStatistic::_addCoefRangeNameName of reference to be used for RooAddPdf components; list<RooAbsBinning*>_binList! Bin ranges; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooArgSetRooAbsOptTestStatistic::_cachedNodes! List of nodes that are cached as constant expressions; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_t_extendedIs the input function and extended p.d.f.; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if fla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooXYChi2Var.html:33217,cache,cache,33217,root/html532/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html532/RooXYChi2Var.html,4,['cache'],"['cache', 'cached', 'caches']"
Performance,"sket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; f#define f(i)Definition RSh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:6352,cache,cache,6352,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,['cache'],['cache']
Performance,"slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0); Build specified package on the client. Executes the PROOF-INF/BUILD.sh; script if it exists on the client.; If opt == 0, both the preparation and building phases are run.; If opt == 1, only the preparation phase (asserting and, eventually, downloading; of the package) is done; '*path' contains the full path to the; package to be passed in the next call; If opt == 2, only the building phase is run using *path .; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kBuildPackage; case). Keep in sync in case of changes. Int_t LoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0); Load specified package. Executes the PROOF-INF/SETUP.C script; on all active nodes. If notOnClient = true, don't load package; on the client. The default is to load the package also on the client.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t LoadPackageOnClient(const char* package, TList* loadopts = 0); Load specified package in the client. Executes the PROOF-INF/SETUP.C; script on the client. Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kLoadPackage; case). Keep in sync in case of changes.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:62403,Load,LoadPackage,62403,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,9,"['Load', 'load']","['Load', 'LoadPackage', 'loadopts']"
Performance,"slicedData)); simPdf.plotOn(frame2, Components=""px_ctl"", ProjWData=(sample, slicedData), LineStyle=""--""); ; # The same plot for all the phase space. Here, we can just use the original; # combined dataset.; frame3 = x.frame(Title=""Both samples""); combData.plotOn(frame3); simPdf.plotOn(frame3, ProjWData=(sample, combData)); simPdf.plotOn(frame3, Components=""px,px_ctl"", ProjWData=(sample, combData), LineStyle=""--""); ; c = ROOT.TCanvas(""rf501_simultaneouspdf"", ""rf501_simultaneouspdf"", 1200, 400); c.Divide(3); ; ; def draw(i, frame):; c.cd(i); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; ; draw(1, frame1); draw(2, frame2); draw(3, frame3); ; c.SaveAs(""rf501_simultaneouspdf.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(simPdf) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_simPdf_combData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 8630.62, estimated distance to minimum: 0.000174671; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 6.7634e-02 +/- 6.04e-02; a0_ctl -1.5627e-01 +/- 5.53e-02; a1 -3.8353e-03 +/- 6.32e-02; a1_ctl 3.8442e-01 +/- 4.35e-02; f 1.7952e-01 +/- 1.55e-02; f_ctl 5.2710e-01 +/- 1.25e-02; mean 1.4991e-02 +/- 3.34e-02; mean_ctl -3.0079e+00 +/- 1.04e-02; sigma 3.0450e-01 +/- 8.33e-03; ; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 1000 events out of 3000 total events; [#1] INFO:Plotting -- RooSimultaneous::plotOn(simPdf) plot on x represents a slice in the index category (sample); [#",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html:5699,optimiz,optimization,5699,doc/master/rf501__simultaneouspdf_8py.html,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html,2,['optimiz'],['optimization']
Performance,"slot); Int_tTProof::Collect(TProof::ESlaves list = kActive, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tTProof::Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TList*TProof::GetEnabledPackages() const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); virtual Int_tTProof::PollForNewWorkers(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofSuperMaster.html:21534,cache,cachedir,21534,root/html534/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html534/TProofSuperMaster.html,1,['cache'],['cachedir']
Performance,"slot); Int_tTProof::Collect(TProof::ESlaves list = kActive, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tTProof::Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TList*TProof::GetEnabledPackages() const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TStringGetJobAd(); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); virtual Int_tTProof::PollForNewWorkers(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofCondor.html:21704,cache,cachedir,21704,root/html534/TProofCondor.html,https://root.cern,https://root.cern/root/html534/TProofCondor.html,1,['cache'],['cachedir']
Performance,"slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; virtual void DeletePlayer ();  Delete player instance. ;  ; virtual Int_t Fork ();  Fork a child. ;  ; Int_t GetSessionStatus ();  Return the status of this session: 0 idle 1 running 2 being terminated (currently unused) 3 queued 4 idle timed-out (not set in here but in TIdleTOTimer::Notify) This is typically run in the reader thread, so access needs to be protected. ;  ; virtual void HandleArchive (TMessage *mess, TString *slb=0);  Handle archive request. ;  ; virtual Int_t HandleCache (TMessage *mess, TString *slb=0);  Handle here all cache and package requests. ;  ; virtual void HandleCheckFile (TMessage *mess, TString *slb=0);  Handle file checking request. ;  ; virtual Int_t HandleDataSets (TMessage *mess, TString *slb=0);  Handle here requests about datasets. ;  ; virtual void HandleFork (TMessage *mess);  Cloning itself via fork. Not implemented. ;  ; virtual Int_t HandleLibIncPath (TMessage *mess);  Handle lib, inc search paths modification request. ;  ; virtual void HandleProcess (TMessage *mess, TString *slb=0);  Handle processing request. ;  ; virtual void HandleQueryList (TMessage *mess);  Handle request for list of queries. ;  ; virtual void HandleRemove (TMessage *mess, TString *slb=0);  Handle remove request. ;  ; virtual void HandleRetrieve (TMessage *mess, TString *slb=0);  Handle retrieve request. ;  ; virtual void HandleSubmerger (TMessage *mess);  Handle a message of type kPROOF_SUBMERGER. ;  ; virtual Int_t HandleWorkerLists (TMessage *mess);  Handle here all requests t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:23295,cache,cache,23295,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['cache'],['cache']
Performance,"slot_name = 0); voidTClass::IgnoreTObjectStreamer(Bool_t ignore = kTRUE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTClass::InheritsFrom(const char* cl) const; virtual Bool_tTClass::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTClass::InterpretedShowMembers(void* obj, TMemberInspector& insp, Bool_t isTransient); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static TClass::ENewTypeTClass::IsCallingNew(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTClass::IsFolder() const; Bool_tTClass::IsFolder(void* obj) const; Bool_tTClass::IsForeign() const; Bool_tTClass::IsLoaded() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTClass::IsStartingWithTObject() const; Bool_tTClass::IsTObject() const; Bool_tTClass::IsVersioned() const; Bool_tTObject::IsZombie() const; static TClass*TClass::Load(TBuffer& b); static TClass*TClass::LoadClass(const char* requestedname, Bool_t silent); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTClass::ls(Option_t* opt = """") const; voidTClass::MakeCustomMenuList(); Bool_tTClass::MatchLegacyCheckSum(UInt_t checksum) const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; voidTClass::Move(void* arenaFrom, void* arenaTo) const; void*TClass::New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; void*TClass::New(void* arena, TClass::ENewType defConstructor = kClassNew) const; void*TClass::NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; void*TClass::NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQClass.html:13642,Load,LoadClass,13642,root/html602/TQClass.html,https://root.cern,https://root.cern/root/html602/TQClass.html,2,['Load'],['LoadClass']
Performance,"small compared to the bin content; (see TProfile2D::GetBinError). Int_t BufferEmpty(Int_t action = 0); Fill histogram with all entries in the buffer.; action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); action = 0 histogram is filled from the buffer; action = 1 histogram is filled and buffer is deleted; The buffer is automatically deleted when the number of entries; in the buffer is greater than the number of entries in the histogram. Int_t BufferFill(Double_t x, Double_t y, Double_t z, Double_t w); accumulate arguments in buffer. When buffer is full, empty the buffer; fBuffer[0] = number of entries in buffer; fBuffer[1] = w of first entry; fBuffer[2] = x of first entry; fBuffer[3] = y of first entry; fBuffer[4] = z of first entry. void Copy(TObject& hnew) const; -*-*-*-*Copy a Profile2D histogram to a new profile2D histogram; *-* =======================================================. Bool_t Divide(TF1* h1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); This function is not implemented. Bool_t Divide(const TH1* h1); Divide this profile2D by h1*-*-; *-* ===========================. this = this/h1. This function return kFALSE if the divide operation failed. Bool_t Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*Replace contents of this profile2D by the division of h1 by h2; *-* ==============================================================. this = c1*h1/(c2*h2). This function return kFALSE if the divide operation failed. Int_t Fill(Double_t x, Double_t y, Double_t z); -*-*-*Fill a Profile2D histogram (no weights); *-* =======================================. Int_t Fill(Double_t x, const char* namey, Double_t z); Fill a Profile2D histogram (no weights). Int_t Fill(const char* namex, const char* namey, Double_t z); Fill a Profile2D histogram (no weights). Int_t Fill(const char* namex, Double_t y, Double_t z); Fill a Profile2D histogram (no weights). Int_t Fill(D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProfile2D.html:36260,Perform,Performs,36260,root/html602/TProfile2D.html,https://root.cern,https://root.cern/root/html602/TProfile2D.html,2,['Perform'],['Performs']
Performance,"small compared to the bin content; (see TProfile2D::GetBinError). Int_t BufferEmpty(Int_t action = 0); Fill histogram with all entries in the buffer.; action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); action = 0 histogram is filled from the buffer; action = 1 histogram is filled and buffer is deleted; The buffer is automatically deleted when the number of entries; in the buffer is greater than the number of entries in the histogram. Int_t BufferFill(Double_t x, Double_t y, Double_t z, Double_t w); accumulate arguments in buffer. When buffer is full, empty the buffer; fBuffer[0] = number of entries in buffer; fBuffer[1] = w of first entry; fBuffer[2] = x of first entry; fBuffer[3] = y of first entry; fBuffer[4] = z of first entry. void Copy(TObject& hnew) const; -*-*-*-*Copy a Profile2D histogram to a new profile2D histogram; *-* =======================================================. Bool_t Divide(TF1* h1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); This function is not implemented. Bool_t Divide(const TH1* h1); Divide this profile2D by h1*-*-; *-* ===========================. this = this/h1. This function return kFALSE if the divide operation failed. Bool_t Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*Replace contents of this profile2D by the division of h1 by h2; *-* ==============================================================. this = c1*h1/(c2*h2). This function return kFALSE if the divide operation failed. TH1 * DrawCopy(Option_t* option = """") const; Draw a copy of this profile2D histogram*-*-*-; *-* =======================================. Int_t Fill(Double_t x, Double_t y, Double_t z); -*-*-*Fill a Profile2D histogram (no weights); *-* =======================================. Int_t Fill(Double_t x, const char* namey, Double_t z); Fill a Profile2D histogram (no weights). Int_t Fill(const char* namex, const char* namey, Double_t z); Fill a Profi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile2D.html:34524,Perform,Performs,34524,root/html534/TProfile2D.html,https://root.cern,https://root.cern/root/html534/TProfile2D.html,1,['Perform'],['Performs']
Performance,"snow.tv_sec,; 1702 (unsigned long)tsnow.tv_nsec,; 1703 thread_id,; 1704 func,; 1705 line);; 1706 va_start(args, fmt);; 1707 vfprintf(DEBUG_TRACE_STREAM, fmt, args);; 1708 va_end(args);; 1709 putc('\n', DEBUG_TRACE_STREAM);; 1710 fflush(DEBUG_TRACE_STREAM);; 1711 funlockfile(DEBUG_TRACE_STREAM);; 1712}; 1713#endif /* NEED_DEBUG_TRACE_FUNC */; 1714 ; 1715 ; 1716#define MD5_STATIC static; 1717#include ""md5.inl""; 1718 ; 1719/* Darwin prior to 7.0 and Win32 do not have socklen_t */; 1720#if defined(NO_SOCKLEN_T); 1721typedef int socklen_t;; 1722#endif /* NO_SOCKLEN_T */; 1723 ; 1724#define IP_ADDR_STR_LEN (50) /* IPv6 hex string is 46 chars */; 1725 ; 1726#if !defined(MSG_NOSIGNAL); 1727#define MSG_NOSIGNAL (0); 1728#endif; 1729 ; 1730 ; 1731/* SSL: mbedTLS vs. no-ssl vs. OpenSSL */; 1732#if defined(USE_MBEDTLS); 1733/* mbedTLS */; 1734#include ""mod_mbedtls.inl""; 1735 ; 1736#elif defined(NO_SSL); 1737/* no SSL */; 1738typedef struct SSL SSL; /* dummy for SSL argument to push/pull */; 1739typedef struct SSL_CTX SSL_CTX;; 1740 ; 1741#elif defined(NO_SSL_DL); 1742/* OpenSSL without dynamic loading */; 1743#include <openssl/bn.h>; 1744#include <openssl/conf.h>; 1745#include <openssl/crypto.h>; 1746#include <openssl/dh.h>; 1747#include <openssl/engine.h>; 1748#include <openssl/err.h>; 1749#include <openssl/opensslv.h>; 1750#include <openssl/pem.h>; 1751#include <openssl/ssl.h>; 1752#include <openssl/tls1.h>; 1753#include <openssl/x509.h>; 1754 ; 1755#if defined(WOLFSSL_VERSION); 1756/* Additional defines for WolfSSL, see; 1757 * https://github.com/civetweb/civetweb/issues/583 */; 1758#include ""wolfssl_extras.inl""; 1759#endif; 1760 ; 1761#if defined(OPENSSL_IS_BORINGSSL); 1762/* From boringssl/src/include/openssl/mem.h:; 1763 *; 1764 * OpenSSL has, historically, had a complex set of malloc debugging options.; 1765 * However, that was written in a time before Valgrind and ASAN. Since we now; 1766 * have those tools, the OpenSSL allocation functions are simply macros around; 1767",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:53350,load,loading,53350,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['load'],['loading']
Performance,"snow.tv_sec,; 1702 (unsigned long)tsnow.tv_nsec,; 1703 thread_id,; 1704 func,; 1705 line);; 1706 va_start(args, fmt);; 1707 vfprintf(DEBUG_TRACE_STREAM, fmt, args);; 1708 va_end(args);; 1709 putc('\n', DEBUG_TRACE_STREAM);; 1710 fflush(DEBUG_TRACE_STREAM);; 1711 funlockfile(DEBUG_TRACE_STREAM);; 1712}; 1713#endif /* NEED_DEBUG_TRACE_FUNC */; 1714 ; 1715 ; 1716#define MD5_STATIC static; 1717#include ""md5.inl""; 1718 ; 1719/* Darwin prior to 7.0 and Win32 do not have socklen_t */; 1720#if defined(NO_SOCKLEN_T); 1721typedef int socklen_t;; 1722#endif /* NO_SOCKLEN_T */; 1723 ; 1724#define IP_ADDR_STR_LEN (50) /* IPv6 hex string is 46 chars */; 1725 ; 1726#if !defined(MSG_NOSIGNAL); 1727#define MSG_NOSIGNAL (0); 1728#endif; 1729 ; 1730 ; 1731/* SSL: mbedTLS vs. no-ssl vs. OpenSSL */; 1732#if defined(USE_MBEDTLS); 1733/* mbedTLS */; 1734#include ""mod_mbedtls.inl""; 1735 ; 1736#elif defined(NO_SSL); 1737/* no SSL */; 1738typedef struct SSL SSL; /* dummy for SSL argument to push/pull */; 1739typedef struct SSL_CTX SSL_CTX;; 1740 ; 1741#elif defined(NO_SSL_DL); 1742/* OpenSSL without dynamic loading */; 1743#include <openssl/bn.h>; 1744#include <openssl/conf.h>; 1745#include <openssl/crypto.h>; 1746#include <openssl/dh.h>; 1747#include <openssl/err.h>; 1748#include <openssl/opensslv.h>; 1749#include <openssl/pem.h>; 1750#include <openssl/ssl.h>; 1751#include <openssl/tls1.h>; 1752#include <openssl/x509.h>; 1753 ; 1754#if defined(WOLFSSL_VERSION); 1755/* Additional defines for WolfSSL, see; 1756 * https://github.com/civetweb/civetweb/issues/583 */; 1757#include ""wolfssl_extras.inl""; 1758#endif; 1759 ; 1760#if defined(OPENSSL_IS_BORINGSSL); 1761/* From boringssl/src/include/openssl/mem.h:; 1762 *; 1763 * OpenSSL has, historically, had a complex set of malloc debugging options.; 1764 * However, that was written in a time before Valgrind and ASAN. Since we now; 1765 * have those tools, the OpenSSL allocation functions are simply macros around; 1766 * the standard memory functions.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:53351,load,loading,53351,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['load'],['loading']
Performance,"so if you do not; 2348/// already have a pointer to the previous cache (and there was a previous; 2349/// cache), you ought to retrieve (and delete it if needed) using:; 2350///; 2351/// TFileCacheRead *older = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 238",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:83808,cache,cache,83808,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"so re-uses concepts and ideas from the CMS Common Vector package. In contrast to CLHEP or the ROOT physics libraries, GenVector provides class templates for modeling the vectors. The user can control how the vector is internally represented. This is expressed by a choice of coordinate system, which is supplied as a template parameter when the vector is constructed. Furthermore, each coordinate system is itself a template, so that the user can specify the underlying scalar type.; The GenVector classes do not inherit from TObject, therefore cannot be used as in the case of the physics vector classes in ROOT collections.; In addition, to optimize performances, no virtual destructors are provided. In the following paragraphs, the main characteristics of GenVector are described. A more detailed description of all the GenVector classes is available also at http://seal.cern.ch/documents/mathlib/GenVector.pdf; 13.12.1 Main Characteristics; 13.12.1.1 Optimal Runtime Performances; We try to minimize any overhead in the run-time performance. We have deliberately avoided the use of any virtual function and even virtual destructors in the classes. In addition, as much as possible functions are defined as inline. For this reason, we have chosen to use template classes to implement the GenVector concepts instead of abstract or base classes and virtual functions. It is then recommended to avoid using the GenVector classes polymorphically and developing classes inheriting from them.; 13.12.1.2 Points and Vector Concept; Mathematically vectors and points are two distinct concepts. They have different transformations, as vectors only rotate while points rotate and translate. You can add two vectors but not two points and the difference between two points is a vector. We then distinguish for the 3 dimensional case, between points and vectors, modeling them with different classes:. ROOT::Math::DisplacementVector2D and ROOT::Math::DisplacementVector3D template classes describing 2 and 3 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:719649,Perform,Performances,719649,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['Perform', 'perform']","['Performances', 'performance']"
Performance,"sociated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* parIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve object from cache that was registered under given name with given parameters, _if_; current parameter values match those that were stored in the registry for this object.; The return object is owned by the cache instance. const TObject* getObj(Int_t uniqueID); Retrieve payload object of cache element with given unique ID. Bool_t clearObj(Int_t uniqueID); Clear cache element with given unique ID; Retrieve payload object of cache element with given unique ID. Bool_t setObj(Int_t uniqueID, TObject* obj); Place new payload object in cache element with given unique ID. Cache; will take ownership of provided object!. void clearAll(); Clear all cache elements. void print() const. void importCacheObjects(RooExpensiveObjectCache& other, const char* ownerName, Bool_t verbose = kFALSE). Int_t size() const; { return _map.size() ; }. » Last changed: Mon Dec 7 13:47:31 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooExpensiveObjectCache.html:7941,cache,cache,7941,root/html526/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html526/RooExpensiveObjectCache.html,7,"['Cache', 'cache']","['Cache', 'cache']"
Performance,"solutionModel::_basisCodeIdentifier code for selected basis function; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of component analytical integration codes; Double_t*_coefCache! Transiet cache with transformed values of coefficients; Int_t_coefErrCount! Coefficient error counter; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoefFlag indicating if last PDFs coefficient was supplied in the ctor; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:38301,cache,cache,38301,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,4,['cache'],['cache']
Performance,"son distribution; SeparationType the separation criterion applied in the node splitting. Known:; GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB. MinNodeSize: minimum percentage of training events in a leaf node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then step size is determined by the events); UseFisherCuts: use multivariate splits using the Fisher criterion; UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine misclassification error rate); PruneMethod The Pruning method. Known:; NoPruning // switch off pruning completely; ExpectedError; CostComplexity. PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; PruningValFraction number of events to use for optimizing pruning (only if PruneStrength < 0, i.e. automatic pruning); NegWeightTreatment; IgnoreNegWeightsInTraining Ignore negative weight events in the training.; DecreaseBoostWeight Boost ev. with neg. weight with 1/boostweight instead of boostweight; PairNegWeightsGlobal Pair ev. with neg. and pos. weights in training sample and ""annihilate"" them. MaxDepth maximum depth of the decision tree allowed before further splitting is stopped; SkipNormalization Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events . Implements TMVA::MethodBase.; Definition at line 333 of file MethodBDT.cxx. ◆ DeclFileName(). static const char * TMVA::MethodBDT::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 305 of file MethodBDT.h. ◆ DeterminePreselectionCuts(). void TMVA::MethodBDT::DeterminePreselectionCuts ; (; const std::vector< const TMVA::Event * > & ; eventSample). private ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:47599,optimiz,optimizing,47599,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['optimiz'],['optimizing']
Performance,"sorDataLoader(TTensorDataLoader &&)=default; TMVA::DNN::TTensorDataLoader::fBatchSizesize_t fBatchSizeThe size of a batch.Definition TensorDataLoader.h:144; TMVA::DNN::TTensorDataLoader::fInputLayoutShape_t fInputLayoutThe input data layout (does not include batch size)Definition TensorDataLoader.h:145; TMVA::DNN::TTensorDataLoader::CopyTensorWeightsvoid CopyTensorWeights(HostBuffer_t &buffer, IndexIterator_t begin)Copy weight matrix into the given host buffer.; TMVA::DNN::TTensorDataLoader::Matrix_ttypename Architecture_t::Matrix_t Matrix_tDefinition TensorDataLoader.h:137; TMVA::DNN::TTensorDataLoader::HostBuffer_ttypename Architecture_t::HostBuffer_t HostBuffer_tDefinition TensorDataLoader.h:135; TMVA::DNN::TTensorDataLoader::fBatchDepthsize_t fBatchDepthThe number of matrices in the tensor.Definition TensorDataLoader.h:146; TMVA::DNN::TTensorDataLoader::fNStreamssize_t fNStreamsNumber of buffer pairs.Definition TensorDataLoader.h:153; TMVA::DNN::TTensorDataLoader::fDataconst Data_t & fDataThe data that should be loaded in the batches.Definition TensorDataLoader.h:142; TMVA::DNN::TTensorDataLoader::operator=TTensorDataLoader & operator=(TTensorDataLoader &&)=default; TMVA::DNN::TTensorDataLoader::Tensor_ttypename Architecture_t::Tensor_t Tensor_tDefinition TensorDataLoader.h:138; TMVA::DNN::TTensorDataLoader::endBatchIterator_t end()Definition TensorDataLoader.h:180; TMVA::DNN::TTensorDataLoader::fNSamplessize_t fNSamplesThe total number of samples in the dataset.Definition TensorDataLoader.h:143; TMVA::DNN::TTensorDataLoader::CopyTensorInputvoid CopyTensorInput(HostBuffer_t &buffer, IndexIterator_t begin)Copy input tensor into the given host buffer.; TMVA::DataSetInfoClass that contains all the data information.Definition DataSetInfo.h:62; TMatrixTTMatrixT.Definition TMatrixT.h:40; TMVA::DNN::TensorInputstd::tuple< const std::vector< TMatrixT< Double_t > > &, const TMatrixT< Double_t > &, const TMatrixT< Double_t > & > TensorInputDefinition TensorDataLoader.h:44",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TensorDataLoader_8h_source.html:19640,load,loaded,19640,doc/master/TensorDataLoader_8h_source.html,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html,1,['load'],['loaded']
Performance,"source. For a given development platform there can be more than one adequate generator. If you use Visual Studio, “NMake Makefiles” is a generator you can use for building with NMake. By default, CMake chooses the most specific generator supported by your development environment. If you want an alternative generator, you must tell this to CMake with the -G option.; Options and variables; Variables customize how the build will be generated. Options are boolean variables, with possible values ON/OFF. Options and variables are defined on the CMake command line like this:; $ cmake -DVARIABLE=value path/to/source. You can set a variable after the initial CMake invocation to change its value. You can also undefine a variable:; $ cmake -UVARIABLE path/to/source. Variables are stored in the CMake cache. This is a file named CMakeCache.txt stored at the root of your build directory that is generated by cmake. Editing it yourself is not recommended.; Variables are listed in the CMake cache with the variable name and type separated by a colon. You can also specify the variable and type on the CMake command line:; $ cmake -DVARIABLE:TYPE=value path/to/source. Variables in the CMake cache are 'remembered', so you do not need to type them if you execute cmake command again. It is recommended to delete the file CMakeCache.txt to start from a clean configuration. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate wit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:23210,cache,cache,23210,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['cache'],['cache']
Performance,"sp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidwriteHistToFile(char* outputFile, const char* histName) const; voidwriteNTupleToFile(char* outputFile, const char* name) const; voidwriteToFile(char* outputFile, const char* name) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo2DKeysPdf.html:31955,cache,cache,31955,root/html602/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html602/Roo2DKeysPdf.html,2,['cache'],['cache']
Performance,"space Internal {; 623template <typename T>; 624TClass *GetClassHelper(Bool_t, Bool_t, std::true_type); 625{; 626 return T::Class();; 627}; 628 ; 629template <typename T>; 630struct TClassGetClassHelper {; 631 static TClass *GetClass(Bool_t load, Bool_t silent) {; 632 return TClass::GetClass(typeid(T), load, silent);; 633 }; 634};; 635 ; 636template <typename F, typename S>; 637struct TClassGetClassHelper<std::pair<F, S> > {; 638 static TClass *GetClass(Bool_t load, Bool_t silent) {; 639 using pair_t = std::pair<F,S>;; 640 size_t hint_offset = offsetof(pair_t, second);; 641 return TClass::GetClass(typeid(std::pair<F, S>), load, silent, hint_offset, sizeof(std::pair<F,S>));; 642 }; 643};; 644 ; 645template <typename T>; 646TClass *GetClassHelper(Bool_t load, Bool_t silent, std::false_type); 647{; 648 return TClassGetClassHelper<T>::GetClass(load, silent);; 649}; 650 ; 651} // namespace Internal; 652} // namespace ROOT; 653 ; 654template <typename T>; 655TClass *TClass::GetClass(Bool_t load, Bool_t silent); 656{; 657 typename std::is_base_of<TObject, T>::type tag;; 658 return ROOT::Internal::GetClassHelper<T>(load, silent, tag);; 659}; 660 ; 661namespace ROOT {; 662 ; 663template <typename T> TClass *GetClass(T * /* dummy */) { return TClass::GetClass<T>(); }; 664template <typename T> TClass *GetClass(const T * /* dummy */) { return TClass::GetClass<T>(); }; 665 ; 666#ifndef R__NO_CLASS_TEMPLATE_SPECIALIZATION; 667 // This can only be used when the template overload resolution can distinguish between T* and T**; 668 template <typename T> TClass* GetClass( T** /* dummy */) { return TClass::GetClass<T>(); }; 669 template <typename T> TClass* GetClass(const T** /* dummy */) { return TClass::GetClass<T>(); }; 670 template <typename T> TClass* GetClass( T* const* /* dummy */) { return TClass::GetClass<T>(); }; 671 template <typename T> TClass* GetClass(const T* const* /* dummy */) { return TClass::GetClass<T>(); }; 672#endif; 673 ; 674 extern TClass *CreateClass(const char *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:33124,load,load,33124,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['load'],['load']
Performance,"space  TestSupport;  ; namespace  TF1Helper;  ; namespace  TMetaUtils;  ; namespace  TreeUtils;  ; namespace  TThreadedObjectUtils;  ; namespace  TypeTraits;  ROOT type_traits extensions. ;  ; namespace  v5;  ; namespace  VecOps;  . Classes; struct  RCompressionSetting;  The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. More...;  ; class  RDataFrame;  ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. More...;  ; class  ROpaqueTaskArena;  ; class  RRangeCast;  Wraps any collection that can be used in range-based loops and applies static_cast<T> or dynamic_cast<T> to each element. More...;  ; class  TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TClassAlt;  ; class  TClassRec;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TForNamespace;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:2349,queue,queue,2349,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['queue'],['queue']
Performance,"space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete possible MVA ouput values.; (I still leave the code here, but use this with care!!! The default; however is to use the distributions!!!. Double_t GetSigEffAtBkgEff(Double_t bkgEff = 0.1); calculate the signal efficiency for a given background efficiency. Double_t GetBkgEffAtSigEff(Double_t sigEff = 0.5); calculate the background efficiency for a given signal efficiency. Double_t GetBkgRejAtSigEff(Double_t sigEff = 0.5); calculate the background rejection for a given signal efficiency. OptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); default constructor. MethodBase* GetMethod(); {return fMethod;}. » Last changed: Sat Mar 14 16:44:05 2015 » Last generated: 2015-03-14 16:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__OptimizeConfigParameters.html:4780,Optimiz,OptimizeConfigParameters,4780,root/html534/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html534/TMVA__OptimizeConfigParameters.html,3,"['Optimiz', 'optimiz', 'tune']","['OptimizeConfigParameters', 'optimizationType', 'tuneParameters']"
Performance,"specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.d.f being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. The dimensions; of the cache are automatically matched to the number of observables used; in each use context. Multiple cache in different observable may exists; simultanously if the cached p.d.f is used with multiple observable; configurations simultaneously. RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedPdf.html:40953,cache,cached,40953,root/html526/RooCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooCachedPdf.html,4,['cache'],['cached']
Performance,"specified in the booking of the method and provide a vector of SV kernels to iterate over in SVKernelFunction. ;  ; virtual std::map< TString, Double_t > OptimizeTuningParameters (TString fomType=""ROCIntegral"", TString fitType=""Minuit"");  Optimize Tuning Parameters This is used to optimise the kernel function parameters and cost. ;  ; virtual void ReadWeightsFromStream (std::istream &)=0;  ; void ReadWeightsFromStream (std::istream &istr);  ; virtual void ReadWeightsFromStream (TFile &);  ; void ReadWeightsFromStream (TFile &fFin);  TODO write IT. ;  ; void ReadWeightsFromXML (void *wghtnode);  ; void Reset (void);  ; void SetCost (Double_t c);  ; void SetGamma (Double_t g);  ; void SetKappa (Double_t k);  ; void SetMGamma (std::string &mg);  Takes as input a string of values for multigaussian gammas and splits it, filling the gamma vector required by the SVKernelFunction. ;  ; void SetMult (Double_t m);  ; void SetOrder (Double_t o);  ; void SetTheta (Double_t t);  ; virtual void SetTuneParameters (std::map< TString, Double_t > tuneParameters);  Set the tuning parameters according to the argument. ;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Train (void);  Train SVM. ;  ; void WriteWeightsToStream (TFile &fout) const;  TODO write IT write training sample (TTree) to file. ;  ;  Public Member Functions inherited from TMVA::MethodBase;  MethodBase (const TString &jobName, Types::EMVA methodType, const TString &methodTitle, DataSetInfo &dsi, const TString &theOption="""");  standard constructor ;  ;  MethodBase (Types::EMVA methodType, DataSetInfo &dsi, const TString &weightFile);  constructor used for Testing + Application of the MVA, only (no training), using given WeightFiles ;  ; virtual ~MethodBase ();  destructor ;  ; void AddOutput (Types::ETreeType type, Types::EAnalysisType analysisType);  ; TDirectory * BaseDir () const;  returns the ROOT directory where info/histograms etc of the corresponding",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodSVM.html:2941,tune,tuneParameters,2941,doc/master/classTMVA_1_1MethodSVM.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodSVM.html,1,['tune'],['tuneParameters']
Performance,"specified, 'option' can also contain a sorting; 3100/// order for the baskets in the output file.; 3101///; 3102/// There are currently 3 supported sorting order:; 3103///; 3104/// - SortBasketsByOffset (the default); 3105/// - SortBasketsByBranch; 3106/// - SortBasketsByEntry; 3107///; 3108/// When using SortBasketsByOffset the baskets are written in the; 3109/// output file in the same order as in the original file (i.e. the; 3110/// baskets are sorted by their offset in the original file; Usually; 3111/// this also means that the baskets are sorted by the index/number of; 3112/// the _last_ entry they contain); 3113///; 3114/// When using SortBasketsByBranch all the baskets of each individual; 3115/// branches are stored contiguously. This tends to optimize reading; 3116/// speed when reading a small number (1->5) of branches, since all; 3117/// their baskets will be clustered together instead of being spread; 3118/// across the file. However it might decrease the performance when; 3119/// reading more branches (or the full entry).; 3120///; 3121/// When using SortBasketsByEntry the baskets with the lowest starting; 3122/// entry are written first. (i.e. the baskets are sorted by the; 3123/// index/number of the first entry they contain). This means that on; 3124/// the file the baskets will be in the order in which they will be; 3125/// needed when reading the whole tree sequentially.; 3126///; 3127/// For examples of CloneTree, see tutorials:; 3128///; 3129/// - copytree.C:; 3130/// A macro to copy a subset of a TTree to a new TTree.; 3131/// The input file has been generated by the program in; 3132/// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3133///; 3134/// - copytree2.C:; 3135/// A macro to copy a subset of a TTree to a new TTree.; 3136/// One branch of the new Tree is written to a separate file.; 3137/// The input file has been generated by the program in; 3138/// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3139 ; 3140TTree* TTree::CloneTree(Long64_t nent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:124915,perform,performance,124915,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['perform'],['performance']
Performance,"specified. One always can install JSROOT on private web server. When JSROOT is used with THttpServer, the address looks like:; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; Loading main module is enough to get public JSROOT functionality - reading files and drawing objects. One also can load some special components directly like:; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; After script loading one can configure different parameters in gStyle object. It is instance of the TStyle object and behaves like gStyle variable in ROOT. For instance, to change stat format using to display value in stats box:; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; There is also settings object which contains all other JSROOT settings. For instance, one can configure custom format for different axes:; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; One also can use build/jsroot.js bundle to load all functionality at one and access it via JSROOT global handle:; <script src=""https://root.cern/js/latest/build/jsroot.js""></script>; <script>; // getting json string from somewhere; let obj = JSROOT.parse(root_json);; JSROOT.draw('plain', obj, 'colz');; </script>; 1.11.2 Use of JSON; It is strongly recommended to use JSON when communicating with ROOT app",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:24229,load,loading,24229,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['load'],['loading']
Performance,"speed-up the reading of ROOT datasets. . A cache to speed-up the reading of ROOT datasets. Table of Contents. Motivation; General Description; Changes in behaviour; Self-optimization; Examples of usage; Check performance and stats. Motivation: why having a cache is needed?; When writing a TTree, the branch buffers are kept in memory. A typical branch buffersize (before compression) is typically 32 KBytes. After compression, the zipped buffer may be just a few Kbytes. The branch buffers cannot be much larger in case of TTrees with several hundred or thousand branches.; When writing, this does not generate a performance problem because branch buffers are always written sequentially and, thanks to OS optimisations, content is flushed to the output file when a few MBytes of data are available. On the other hand, when reading, one may hit performance problems because of latencies e.g imposed by network. For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each with no cache will imply 10s penalty where a local read of the 10 MBytes would take about 1 second.; The TreeCache tries to prefetch all the buffers for the selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all entries such that not all branch buffers are read. General Description; This class acts as a file cache, registering automatically the baskets from the branches being processed via direct manipulation of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:1329,latency,latency,1329,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,4,"['cache', 'latency']","['cache', 'latency']"
Performance,"splacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name compatibil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:24992,perform,perform,24992,root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,1,['perform'],['perform']
Performance,"splay Proof session logs from the Proof progress dialog. ; It uses TProofMgr::GetSessionLogs() mechanism internally ; Definition at line 31 of file TProofProgressLog.h. Public Member Functions;  TProofProgressLog (const char *url=nullptr, Int_t sessionidx=0, Int_t w=700, Int_t h=600);  Create a window frame for log messages. ;  ;  TProofProgressLog (TProofProgressDialog *d, Int_t w=700, Int_t h=600);  Create a window frame for log messages. ;  ;  ~TProofProgressLog () override;  Destructor. ;  ; void AddBuffer (const char *buffer);  Add text to the window. ;  ; void BuildLogList (Bool_t create=kFALSE);  Build the list of workers. ;  ; void Clear (Option_t *=nullptr) override;  Clear log window. ;  ; void CloseWindow () override;  Handle close button or when closed via window manager action. ;  ; void DoLog (Bool_t grep=kFALSE);  Display logs. ;  ; TClass * IsA () const override;  ; void LoadBuffer (const char *buffer);  Load a text buffer in the window. ;  ; void LoadFile (const char *file);  Load a file in the window. ;  ; void LogMessage (const char *msg, Bool_t all);  Load/append a log msg in the log frame, if open. ;  ; void NoLineEntry ();  Enable/disable the line number entry. ;  ; void Popup ();  Show log window. ;  ; void Rebuild ();  Rebuild the log info for a new entered session. ;  ; void SaveToFile ();  Save the logs to a file Only the name of the file is taken, no expansion. ;  ; void Select (Int_t id, Bool_t all=kTRUE);  actions of select all/clear all button ;  ; void SetGrepView ();  Sets the view of grep filters according to the value of checkboxes. ;  ; void SetUrl (const char *url);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGTransientFrame;  TGTransientFrame (const TGWindow *p=nullptr, const TGWindow *main=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=kVerticalFrame);  Create a transient window. ;  ; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofProgressLog.html:1349,Load,LoadFile,1349,doc/master/classTProofProgressLog.html,https://root.cern,https://root.cern/doc/master/classTProofProgressLog.html,2,['Load'],"['Load', 'LoadFile']"
Performance,"splay; }; 277 void Idle(UInt_t idleTimeInSec, const char *command = nullptr);; 278 Int_t IgnoreInclude(const char *fname, const char *expandedfname);; 279 Bool_t IsBatch() const { return fBatch; }; 280 Bool_t IsExecutingMacro() const { return fExecutingMacro; }; 281 Bool_t IsFolder() const override { return kTRUE; }; 282 Bool_t IsInterrupted() const { return fInterrupt; }; 283 Bool_t IsEscaped() const { return fEscape; }; 284 Bool_t IsLineProcessing() const { return fLineIsProcessing ? kTRUE : kFALSE; }; 285 Bool_t IsProofServ() const { return fName == ""proofserv"" ? kTRUE : kFALSE; }; 286 Bool_t IsRootFile(const char *filename) const;; 287 Bool_t IsWebDisplay() const { return fIsWebDisplay; }; 288 Bool_t IsWebDisplayBatch() const { return fIsWebDisplayBatch; }; 289 void ls(Option_t *option = """") const override;; 290 Int_t LoadClass(const char *classname, const char *libname, Bool_t check = kFALSE);; 291 TClass *LoadClass(const char *name, Bool_t silent = kFALSE) const;; 292 Int_t LoadMacro(const char *filename, Int_t *error = nullptr, Bool_t check = kFALSE);; 293 Longptr_t Macro(const char *filename, Int_t *error = nullptr, Bool_t padUpdate = kTRUE);; 294 TCanvas *MakeDefCanvas() const;; 295 void Message(Int_t id, const TObject *obj);; 296 Bool_t MustClean() const { return fMustClean; }; 297 Longptr_t ProcessLine(const char *line, Int_t *error = nullptr);; 298 Longptr_t ProcessLineSync(const char *line, Int_t *error = nullptr);; 299 Longptr_t ProcessLineFast(const char *line, Int_t *error = nullptr);; 300 Bool_t ReadingObject() const;; 301 void RecursiveRemove(TObject *obj) override;; 302 void RefreshBrowsers();; 303 static void RegisterModule(const char* modulename,; 304 const char** headers,; 305 const char** includePaths,; 306 const char* payLoadCode,; 307 const char* fwdDeclCode,; 308 void (*triggerFunc)(),; 309 const FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,; 310 const char** classesHeaders,; 311 bool hasCxxModule = false);; 312 TObject *Remove(TObject*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:14771,Load,LoadMacro,14771,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,2,['Load'],['LoadMacro']
Performance,"split in N pieces,; // that are calculated in parallel and added a posteriori before passing; // it back to MINUIT.; ; // Use four processes and time results both in wall time and CPU time; model.fitTo(*data, NumCPU(4), Timer(true), PrintLevel(-1));; ; // P a r a l l e l M C p r o j e c t i o n s; // ----------------------------------------------; ; // Construct signal, total likelihood projection on (y,z) observables and likelihood ratio; RooAbsPdf *sigyz = sig.createProjection(x);; RooAbsPdf *totyz = model.createProjection(x);; RooFormulaVar llratio_func(""llratio"", ""log10(@0)-log10(@1)"", RooArgList(*sigyz, *totyz));; ; // Calculate likelihood ratio for each event, define subset of events with high signal likelihood; data->addColumn(llratio_func);; std::unique_ptr<RooAbsData> dataSel{data->reduce(Cut(""llratio>0.7""))};; ; // Make plot frame and plot data; RooPlot *frame = x.frame(Title(""Projection on X with LLratio(y,z)>0.7""), Bins(40));; dataSel->plotOn(frame);; ; // Perform parallel projection using MC integration of pdf using given input dataSet.; // In this mode the data-weighted average of the pdf is calculated by splitting the; // input dataset in N equal pieces and calculating in parallel the weighted average; // one each subset. The N results of those calculations are then weighted into the; // final result; ; // Use four processes; model.plotOn(frame, ProjWData(*dataSel), NumCPU(4));; ; new TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.6);; frame->Draw();; }; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooPolynomial.h; RooProdPdf.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract interface for all probability density function",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf603__multicpu_8C.html:2655,Perform,Perform,2655,doc/master/rf603__multicpu_8C.html,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html,1,['Perform'],['Perform']
Performance,"srel, Double_t epsabs, Double_t& relerr, Int_t& nfnevl, Int_t& ifail). This function computes, to an attempted specified accuracy, the value of; the integral. Input parameters:. n : Number of dimensions [2,15]; a,b : One-dimensional arrays of length >= N . On entry A[i], and B[i],; contain the lower and upper limits of integration, respectively.; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epsrel : Specified relative accuracy.; epsabs : Specified absolute accuracy.; The integration algorithm will attempt to reach either the relative or the absolute accuracy.; In case the maximum funcion called is reached the algorithm will stop earlier without having reached; the desired accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. The default method used is the Genz-Mallik adaptive multidimensional algorithm; using the class ROOT::Math::AdaptiveIntegratorMultiDim; (see the reference documentation of the class); Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); to different integrators.; Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; Possible methods are : Vegas, Miser or Plain; IN case of MC integration the accuracy is determined by the number of function calls, one should be; careful not to use a too large value of maxpts. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF1.html:60494,perform,performed,60494,root/html602/TF1.html,https://root.cern,https://root.cern/root/html602/TF1.html,1,['perform'],['performed']
Performance,"srel, Double_t epsabs, Double_t& relerr, Int_t& nfnevl, Int_t& ifail). This function computes, to an attempted specified accuracy, the value of; the integral. Input parameters:. n : Number of dimensions [2,15]; a,b : One-dimensional arrays of length >= N . On entry A[i], and B[i],; contain the lower and upper limits of integration, respectively.; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epsrel : Specified relative accuracy.; epsabs : Specified absolute accuracy.; The integration algorithm will attempt to reach either the relative or the absolute accuracy.; In case the maximum funcion called is reached the algorithm will stop earlier without having reached; the desired accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. The defult method used is the Genz-Mallik adaptive multidimensional algorithm; using the class ROOT::Math::AdaptiveIntegratorMultiDim; (see the reference documentation of the class); Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); to different integrators.; Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; Possible methods are : Vegas, Miser or Plain; IN case of MC integration the accuracy is determined by the number of function calls, one should be; careful not to use a too large value of maxpts. Bool_t IsValid() const; Return kTRUE if the function is valid. void Print(Option_t* option = """") const. void Paint(Option_t* option = """"); Paint this function with its current attributes.; The fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF1.html:53277,perform,performed,53277,root/html604/TF1.html,https://root.cern,https://root.cern/root/html604/TF1.html,1,['perform'],['performed']
Performance,"ss * TTreeIndex::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 73 of file TTreeIndex.h. ◆ IsValidFor(). bool TTreeIndex::IsValidFor ; (; const TTree * ; parent). overridevirtual . Return true if index can be applied to the TTree. ; Implements TVirtualIndex.; Definition at line 526 of file TTreeIndex.cxx. ◆ operator=(). TTreeIndex & TTreeIndex::operator= ; (; const TTreeIndex & ; ). privatedelete . ◆ Print(). void TTreeIndex::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print the table with : serial number, majorname, minorname. . if option = ""10"" print only the first 10 entries; if option = ""100"" print only the first 100 entries; if option = ""1000"" print only the first 1000 entries . Reimplemented from TNamed.; Definition at line 542 of file TTreeIndex.cxx. ◆ SetTree(). void TTreeIndex::SetTree ; (; TTree * ; T). overridevirtual . this function is called by TChain::LoadTree and TTreePlayer::UpdateFormulaLeaves when a new Tree is loaded. ; Because Trees in a TChain may have a different list of leaves, one must update the leaves numbers in the TTreeFormula used by the TreeIndex. ; Implements TVirtualIndex.; Definition at line 638 of file TTreeIndex.cxx. ◆ Streamer(). void TTreeIndex::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TTreeIndex. ; Note that this Streamer should be changed to an automatic Streamer once TStreamerInfo supports an index of type Long64_t ; Reimplemented from TNamed.; Definition at line 583 of file TTreeIndex.cxx. ◆ StreamerNVirtual(). void TTreeIndex::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 73 of file TTreeIndex.h. ◆ UpdateFormulaLeaves(). void TTreeIndex::UpdateFormulaLeaves ; (; const TTree * ; parent). overridevirtual . Called by TChain::LoadTree when the parent chain changes it's tree. ; Implements TVirtualIndex.; Definition at line 619 of file TTreeIndex.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeIndex.html:24716,Load,LoadTree,24716,doc/master/classTTreeIndex.html,https://root.cern,https://root.cern/doc/master/classTTreeIndex.html,2,"['Load', 'load']","['LoadTree', 'loaded']"
Performance,"ss * IsA () const override;  ; Bool_t IsColorSetDark () const;  Returns true if current color set is dark. ;  ; Bool_t IsUsingDefaultColorSet () const;  Check if the viewer is using the default color set. ;  ; virtual void MouseIdle (TGLPhysicalShape *, UInt_t, UInt_t);  Emit MouseIdle signal. ;  ; virtual void MouseOver (TGLPhysicalShape *);  Emit MouseOver signal. ;  ; virtual void MouseOver (TGLPhysicalShape *, UInt_t state);  Emit MouseOver signal. ;  ; virtual void MouseOver (TObject *obj, UInt_t state);  Emit MouseOver signal. ;  ; Bool_t OpenComposite (const TBuffer3D &, Bool_t *=nullptr) override;  ; virtual void OverlayDragFinished ();  An overlay operation can result in change to an object. ;  ; void PadPaint (TVirtualPad *pad) override;  Entry point for updating viewer contents via VirtualViewer3D interface. ;  ; void PickAnnotate ();  ; void PickCameraCenter ();  ; void PostRender () override;  Restore state set in PreRender(). ;  ; virtual void PostSceneBuildSetup (Bool_t resetCameras);  Perform post scene-build setup. ;  ; Bool_t PreferLocalFrame () const override;  ; void PreRender () override;  Initialize objects that influence rendering. ;  ; void PrintObjects () override;  Pass viewer for print capture by TGLOutput. ;  ; virtual void ReClicked (TObject *obj, UInt_t button, UInt_t state);  Emit ReClicked signal with button id and modifier state. ;  ; TGLCamera & RefCamera (ECameraType camera);  Return camera reference by type. ;  ; TGLColorSet & RefDarkColorSet ();  ; TGLColorSet & RefLightColorSet ();  ; virtual void RefreshPadEditor (TObject *obj=nullptr);  Update GED editor if it is set. ;  ; const TGLRect & RefViewport () const;  ; void ReinitializeCurrentCamera (const TGLVector3 &hAxis, const TGLVector3 &vAxis, Bool_t redraw=kTRUE);  Change base-vectors defining the camera-base transformation of current camera. ;  ; virtual void ReMouseOver (TObject *obj, UInt_t state);  Emit MouseOver signal. ;  ; void RemoveOverlayElement (TGLOverlayElement *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLEmbeddedViewer.html:6595,Perform,Perform,6595,doc/master/classTGLEmbeddedViewer.html,https://root.cern,https://root.cern/doc/master/classTGLEmbeddedViewer.html,3,['Perform'],['Perform']
Performance,"ss ;  ;  Public Member Functions inherited from TStreamerElement;  TStreamerElement ();  Default ctor. ;  ;  TStreamerElement (const char *name, const char *title, Int_t offset, Int_t dtype, const char *typeName);  Create a TStreamerElement object. ;  ; virtual ~TStreamerElement ();  TStreamerElement dtor. ;  ; virtual Bool_t CannotSplit () const;  Returns true if the element cannot be split, false otherwise. ;  ; Int_t GetArrayDim () const;  ; Int_t GetArrayLength () const;  ; TClass * GetClass () const;  ; virtual Int_t GetExecID () const;  Returns the TExec id for the EXEC instruction in the comment field of a TRef data member. ;  ; Double_t GetFactor () const;  ; virtual const char * GetFullName () const;  Return element name including dimensions, if any Note that this function stores the name into a static array. ;  ; virtual const char * GetInclude () const;  ; Int_t GetMaxIndex (Int_t i) const;  ; TClass * GetNewClass () const;  ; Int_t GetNewType () const;  ; Int_t GetOffset () const;  ; void GetSequenceType (TString &type) const;  Fill type with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; TClass * IsA () const override;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the eleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerBasicPointer.html:2940,cache,cached,2940,doc/master/classTStreamerBasicPointer.html,https://root.cern,https://root.cern/doc/master/classTStreamerBasicPointer.html,1,['cache'],['cached']
Performance,"ss ;  ;  Public Member Functions inherited from TStreamerElement;  TStreamerElement ();  Default ctor. ;  ;  TStreamerElement (const char *name, const char *title, Int_t offset, Int_t dtype, const char *typeName);  Create a TStreamerElement object. ;  ; virtual ~TStreamerElement ();  TStreamerElement dtor. ;  ; virtual Bool_t CannotSplit () const;  Returns true if the element cannot be split, false otherwise. ;  ; Int_t GetArrayDim () const;  ; Int_t GetArrayLength () const;  ; TClass * GetClass () const;  ; virtual Int_t GetExecID () const;  Returns the TExec id for the EXEC instruction in the comment field of a TRef data member. ;  ; Double_t GetFactor () const;  ; virtual const char * GetFullName () const;  Return element name including dimensions, if any Note that this function stores the name into a static array. ;  ; virtual const char * GetInclude () const;  ; Int_t GetMaxIndex (Int_t i) const;  ; TClass * GetNewClass () const;  ; Int_t GetNewType () const;  ; Int_t GetOffset () const;  ; void GetSequenceType (TString &type) const;  Fill type with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t HasCounter () const;  ; virtual void Init (TVirtualStreamerInfo *obj=nullptr);  Initliaze the element. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsaPointer () const;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerBasicType.html:2428,cache,cached,2428,doc/master/classTStreamerBasicType.html,https://root.cern,https://root.cern/doc/master/classTStreamerBasicType.html,1,['cache'],['cached']
Performance,"ss Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Member Functions |; List of all members ; ROOT::Math::GSLMultiRootBaseSolver Class ReferenceabstractMath » MathCore | Math » MathMore » Numerical Algorithms » Multidimensional ROOT finding. ; GSLMultiRootBaseSolver, internal class for implementing GSL multi-root finders This is the base class for GSLMultiRootSolver (solver not using derivatives) and GSLMUltiRootDerivSolver (solver using derivatives) ; Definition at line 57 of file GSLMultiRootSolver.h. Public Member Functions; virtual ~GSLMultiRootBaseSolver ();  virtual Destructor ;  ; const double * Dx () const;  return function steps ;  ; const double * FVal () const;  return function values ;  ; bool InitSolver (const std::vector< ROOT::Math::IMultiGenFunction * > &funcVec, const double *x);  init the solver with function list and initial values ;  ; virtual int Iterate ()=0;  perform an iteration ;  ; virtual const std::string & Name () const =0;  return name ;  ; int TestDelta (double absTol, double relTol) const;  test using abs and relative tolerance |dx| < absTol + relTol*|x| for every component ;  ; int TestResidual (double absTol) const;  test using abs tolerance Sum |f|_i < absTol ;  ; const double * X () const;  solution values at the current iteration ;  . Private Member Functions; virtual gsl_vector * GetDx () const =0;  ; virtual gsl_vector * GetF () const =0;  ; virtual gsl_vector * GetRoot () const =0;  ; virtual int SetSolver (const std::vector< ROOT::Math::IMultiGenFunction * > &funcVec, const double *x)=0;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/math/mathmore/src/GSLMultiRootSolver.h>. Inheritance diagram for ROOT::Math::GSLMultiRootBaseSolver:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ~GSLMultiRootBaseS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiRootBaseSolver.html:1042,perform,perform,1042,doc/master/classROOT_1_1Math_1_1GSLMultiRootBaseSolver.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiRootBaseSolver.html,1,['perform'],['perform']
Performance,"ss T> Int_t SetBranchAddress(const char *bname, T *add, TBranch **ptr = nullptr) {; 638 TClass *cl = TClass::GetClass<T>();; 639 EDataType type = kOther_t;; 640 if (!cl) type = TDataType::GetType(typeid(T));; 641 return SetBranchAddress(bname,add,ptr,cl,type,false);; 642 }; 643#endif; 644 virtual void SetBranchStatus(const char* bname, bool status = true, UInt_t* found = nullptr);; 645 static void SetBranchStyle(Int_t style = 1); //style=0 for old branch, =1 for new branch style; 646 virtual Int_t SetCacheSize(Long64_t cachesize = -1);; 647 virtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last);; 648 virtual void SetCacheLearnEntries(Int_t n=10);; 649 virtual void SetChainOffset(Long64_t offset = 0) { fChainOffset=offset; }; 650 virtual void SetCircular(Long64_t maxEntries);; 651 virtual void SetClusterPrefetch(bool enabled) { fCacheDoClusterPrefetch = enabled; }; 652 virtual void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); // *MENU*; 653 virtual void SetDefaultEntryOffsetLen(Int_t newdefault, bool updateExisting = false);; 654 virtual void SetDirectory(TDirectory* dir);; 655 virtual Long64_t SetEntries(Long64_t n = -1);; 656 virtual void SetEstimate(Long64_t nentries = 1000000);; 657 ROOT::TIOFeatures SetIOFeatures(const ROOT::TIOFeatures &);; 658 virtual void SetFileNumber(Int_t number = 0);; 659 virtual void SetEventList(TEventList* list);; 660 virtual void SetEntryList(TEntryList* list, Option_t *opt="""");; 661 virtual void SetImplicitMT(bool enabled) { fIMTEnabled = enabled; }; 662 virtual void SetMakeClass(Int_t make);; 663 virtual void SetMaxEntryLoop(Long64_t maxev = kMaxEntries) { fMaxEntryLoop = maxev; } // *MENU*; 664 static void SetMaxTreeSize(Long64_t maxsize = 100000000000LL);; 665 virtual void SetMaxVirtualSize(Long64_t size = 0) { fMaxVirtualSize = size; } // *MENU*; 666 void SetName(const char* name) override; // *MENU*; 667 ; 668 /**; 669 * @brief Sets the address of the object to be notified when the tree is loaded.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:37846,load,loaded,37846,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['load'],['loaded']
Performance,"ss TTreeFormula: public ROOT::v5::TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidROOT::v5::TFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tROOT::v5::TFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidROOT::v5::TFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tROOT::v5::TFormula::Compile(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeFormula.html:1570,load,loading,1570,root/html604/TTreeFormula.html,https://root.cern,https://root.cern/root/html604/TTreeFormula.html,1,['load'],['loading']
Performance,ss code and instance factory; RooCmdArg Generic named argument container; RooCmdConfig Configurable parse of RooCmdArg objects; RooComplex a non-persistent bare-bones complex class; RooCompositeDataStore Composite Data Storage class; RooConstVar Constant RooAbsReal value object; RooConstraintSum sum of -log of set of RooAbsPdf representing parameter constraints; RooConvCoefVar Auxiliary class representing the coefficient of a RooAbsAnaConvPdf as a RooAbsReal; RooConvGenContext Context for generating a dataset from a PDF; RooConvIntegrandBinding RooAbsFunc representation of convolution integrands; RooCurve 1-dimensional smooth curve for use in RooPlots; RooCustomizer Editing tool for RooAbsArg composite object expressions; RooDLLSignificanceMCSModule MCStudy module to calculate Delta(-logL) significance w.r.t given null hypothesis; RooDataHist Binned data set; RooDataHistSliceIter Iterator over a one-dimensional slice of a RooDataHist; RooDataProjBinding RealFunc/Dataset binding for data projection of a real function; RooDataSet Unbinned data set; RooDataWeightedAverage Optimized calculator of data weighted average of a RooAbsReal; RooDecay General decay function p.d.f; RooDerivative Representation of derivative of any RooAbsReal; RooDirItem Base class for RooFit objects that are listed TDirectories; RooDouble Container class for Double_t; RooDstD0BG D*-D0 mass difference background PDF; RooEffGenContext Context for generating a dataset from a PDF; RooEffProd Product operator p.d.f of (PDF x efficiency) implementing optimized generator context; RooEfficiency Generic PDF defined by string expression and list of variables; RooEllipse 2-dimensional contour; RooErrorVar RooAbsRealLValue representation of an error of a RooRealVar; RooExpensiveObjectCache Singleton class that serves as session repository for expensive objects; RooExpensiveObjectCache::ExpensiveObject Cache element containing expensive object and parameter values for which object is valid; RooExponential Exp,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:31717,Optimiz,Optimized,31717,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['Optimiz'],['Optimized']
Performance,"ss declaration ; Definition at line 112 of file RooMultiVarGaussian.h. ◆ decodeCode(). void RooMultiVarGaussian::decodeCode ; (; Int_t ; code, . std::vector< int > & ; map1, . std::vector< int > & ; map2 . ); const. protected . Decode analytical integration/generation code into index map of integrated/generated (map2) and non-integrated/generated observables (map1) ; Definition at line 600 of file RooMultiVarGaussian.cxx. ◆ evaluate(). double RooMultiVarGaussian::evaluate ; (; ); const. overrideprotectedvirtual . Do not persist. ; Represent observables as vector. ; Implements RooAbsReal.; Definition at line 175 of file RooMultiVarGaussian.cxx. ◆ genData(). RooMultiVarGaussian::GenData & RooMultiVarGaussian::genData ; (; Int_t ; code); const. protected . WVE – CHECK THAT GENDATA IS VALID GIVEN CURRENT VALUES OF _MU. ; Definition at line 501 of file RooMultiVarGaussian.cxx. ◆ generateEvent(). void RooMultiVarGaussian::generateEvent ; (; Int_t ; code). overridevirtual . Retrieve generator config from cache. ; Reimplemented from RooAbsPdf.; Definition at line 434 of file RooMultiVarGaussian.cxx. ◆ getAnalyticalIntegral(). Int_t RooMultiVarGaussian::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 194 of file RooMultiVarGaussian.cxx. ◆ getGenerator(). Int_t RooMultiVarGaussian::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Special case: gene",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMultiVarGaussian.html:78973,cache,cache,78973,doc/master/classRooMultiVarGaussian.html,https://root.cern,https://root.cern/doc/master/classRooMultiVarGaussian.html,1,['cache'],['cache']
Performance,"ss description. RooAddPdf(const char* name, const char* title, const RooArgList& pdfList); Generic constructor from list of extended PDFs. There are no coefficients as the expected; number of events from each components determine the relative weight of the PDFs. All PDFs must inherit from RooAbsPdf. RooAddPdf(const RooAddPdf& other, const char* name); Copy constructor. ~RooAddPdf(); Destructor. void fixCoefNormalization(const RooArgSet& refCoefNorm); By default the interpretation of the fraction coefficients is; performed in the contextual choice of observables. This makes the; shape of the p.d.f explicitly dependent on the choice of; observables. This method instructs RooAddPdf to freeze the; interpretation of the coefficients to be done in the given set of; observables. If frozen, fractions are automatically transformed; from the reference normalization set to the contextual normalization; set by ratios of integrals. void fixCoefRange(const char* rangeName); By default the interpretation of the fraction coefficients is; performed in the default range. This make the shape of a RooAddPdf; explicitly dependent on the range of the observables. To allow; a range independent definition of the fraction this function; instructs RooAddPdf to freeze its interpretation in the given; named range. If the current normalization range is different; from the reference range, the appropriate fraction coefficients; are automically calculation from the reference fractions using; ratios if integrals. void updateCoefficients(RooAddPdf::CacheElem& cache, const RooArgSet* nset) const; Update the coefficient values in the given cache element: calculate new remainder; fraction, normalize fractions obtained from extended ML terms to unity and; multiply these the various range and dimensional corrections needed in the; current use context. Double_t evaluate() const; Calculate and return the current value. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddPdf.html:43700,perform,performed,43700,root/html526/RooAddPdf.html,https://root.cern,https://root.cern/root/html526/RooAddPdf.html,1,['perform'],['performed']
Performance,"ss of the value at index 'idx'.Definition TGenCollectionProxy.cxx:243; TGenSetProxy::~TGenSetProxy~TGenSetProxy() overrideDefinition TGenCollectionProxy.cxx:239; TGenSetProxy::TGenSetProxyTGenSetProxy(const TGenCollectionProxy &c)Definition TGenCollectionProxy.cxx:235; TGenVectorBoolProxyLocal optimization class.Definition TGenCollectionProxy.cxx:88; TGenVectorBoolProxy::fLastValueBool_t fLastValueDefinition TGenCollectionProxy.cxx:89; TGenVectorBoolProxy::Atvoid * At(UInt_t idx) overrideReturn the address of the value at index 'idx'.Definition TGenCollectionProxy.cxx:100; TGenVectorBoolProxy::TGenVectorBoolProxyTGenVectorBoolProxy(const TGenCollectionProxy &c)Definition TGenCollectionProxy.cxx:92; TGenVectorBoolProxy::~TGenVectorBoolProxy~TGenVectorBoolProxy() overrideDefinition TGenCollectionProxy.cxx:96; TGenVectorBoolProxy::DeleteItemvoid DeleteItem(Bool_t force, void *ptr) const overrideCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:115; TGenVectorProxyLocal optimization class.Definition TGenCollectionProxy.cxx:39; TGenVectorProxy::DeleteItemvoid DeleteItem(Bool_t force, void *ptr) const overrideCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:66; TGenVectorProxy::Atvoid * At(UInt_t idx) overrideReturn the address of the value at index 'idx'.Definition TGenCollectionProxy.cxx:50; TGenVectorProxy::~TGenVectorProxy~TGenVectorProxy() overrideDefinition TGenCollectionProxy.cxx:46; TGenVectorProxy::TGenVectorProxyTGenVectorProxy(const TGenCollectionProxy &c)Definition TGenCollectionProxy.cxx:42; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreter::TypeInfo_Initvirtual void TypeInfo_Init(TypeInfo_t *, const char *) constDefinition TInterpreter.h:528; TInterpreter::TypeInfo_Deletevirtual void TypeInfo_Delete(TypeInfo_t *) constDefinition TInterpreter.h:524; TInterpreter::TypeInfo_Factoryvirtual TypeInf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:88529,optimiz,optimization,88529,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['optimiz'],['optimization']
Performance,"ss or struct and requestListLoading is true, the list is immutable (and thus safe to access from multiple thread without taking the global lock at all).; In the case the TClass represents a class or struct and requestListLoading is false, the list is mutable and thus we return a TListOfEnumsWithLock which will implicit take the ROOT global lock upon any access. ; Definition at line 3686 of file TClass.cxx. ◆ GetListOfFunctionTemplates(). TList * TClass::GetListOfFunctionTemplates ; (; Bool_t ; load = kTRUE). Return TListOfFunctionTemplates for a class. ; Definition at line 3798 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 3827 of file TClass.cxx. ◆ GetListOfMethods(). TList * TClass::GetListOfMethods ; (; Bool_t ; load = kTRUE). Return list containing the TMethods of a class. ; If load is true, the list is populated with all the defined function and currently instantiated function template. ; Definition at line 3812 of file TClass.cxx. ◆ GetListOfRealData(). TList * TClass::GetListOfRealData ; (; ); const. inline . Definition at line 453 of file TClass.h. ◆ GetListOfUsingDataMembers(). TList * TClass::GetListOfUsingDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of using declarations of a class. ; Definition at line 3786 of file TClass.cxx. ◆ GetMenuItems(). void TClass::GetMenuItems ; (; TList * ; listitems). Returns list of methods accessible by context menu. ; Definition at line 3874 of file TClass.cxx. ◆ GetMenuList(). TList * TClass::GetMenuList ; (; ); const. Return the list of menu items associated with the class. ; Definition at line 4341 of file TClass.cxx. ◆ GetMerge(). ROOT::MergeFunc_t TClass::GetMerge ; (; ); const. Return the wrapper around Merge. ; Definition at line 7431 of file TClass.cxx. ◆ GetMethod(). TMethod * TClass::GetMethod ; (; const char * ; method, . con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:83660,load,load,83660,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['load']
Performance,"ss or struct and requestListLoading is true, the list is immutable (and thus safe to access from multiple thread without taking the global lock at all).; In the case the TClass represents a class or struct and requestListLoading is false, the list is mutable and thus we return a TListOfEnumsWithLock which will implicit take the ROOT global lock upon any access. ; Definition at line 3753 of file TClass.cxx. ◆ GetListOfFunctionTemplates(). TList * TClass::GetListOfFunctionTemplates ; (; Bool_t ; load = kTRUE). Return TListOfFunctionTemplates for a class. ; Definition at line 3865 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 3894 of file TClass.cxx. ◆ GetListOfMethods(). TList * TClass::GetListOfMethods ; (; Bool_t ; load = kTRUE). Return list containing the TMethods of a class. ; If load is true, the list is populated with all the defined function and currently instantiated function template. ; Definition at line 3879 of file TClass.cxx. ◆ GetListOfRealData(). TList * TClass::GetListOfRealData ; (; ); const. inline . Definition at line 453 of file TClass.h. ◆ GetListOfUsingDataMembers(). TList * TClass::GetListOfUsingDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of using declarations of a class. ; Definition at line 3853 of file TClass.cxx. ◆ GetMenuItems(). void TClass::GetMenuItems ; (; TList * ; listitems). Returns list of methods accessible by context menu. ; Definition at line 3941 of file TClass.cxx. ◆ GetMenuList(). TList * TClass::GetMenuList ; (; ); const. Return the list of menu items associated with the class. ; Definition at line 4408 of file TClass.cxx. ◆ GetMerge(). ROOT::MergeFunc_t TClass::GetMerge ; (; ); const. Return the wrapper around Merge. ; Definition at line 7498 of file TClass.cxx. ◆ GetMethod(). TMethod * TClass::GetMethod ; (; const char * ; method, . con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:83661,load,load,83661,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['load']
Performance,"ss to Python objects from Cling is not completely fleshed out. Currently, ROOT objects and built-in types can cross the boundary between the two interpreters, but other objects are much more restricted. For example, for a Python object to cross, it has to be a class instance, and its class has to be known to Cling first (i.e. the class has to cross first, before the instance can). All other cross-coding is based on strings that are run on the Python interpreter and vise-versa.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first before use. It is possible to switch between interpreters by calling TPython::Prompt() on the ROOT side, while returning with ^D (EOF). State is preserved between successive switches, and string based cross calls can nest as long as shared resources are properly handled.; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; 19.1.4 Installation; There are several ways of obtaining PyROOT, and which is best depends on your specific situation. If you work at CERN, you can use the installation available on afs. Otherwise, you will want to build from source, as PyROOT is not build by default in the binaries distributed from the ROOT project site. If you download the ROOT binaries, take care to download and install the Python distribution from http://www.python.org/ against which they were built.; 19.1.4.1 Environment Settings; ROOT installations with the build of PyROOT enabled are available from the CERN afs ce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1045991,load,load,1045991,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,"['Load', 'load']","['Load', 'load', 'loading']"
Performance,"ss&operator=(const TBaseClass&). Data Members; public:. enum TDictionary::ESTLType { kNone; kVector; kList; kDeque; kMap; kMultimap; kSet; kMultiset; kBitset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TClass*fClasspointer to parent class; TClassReffClassPtrpointer to the base class TClass; BaseClassInfo_t*fInfopointer to CINT base class info; Long_tfOffset!Cache offset of the baseClassInfo.; Long_tfProperty!Cache property of the baseClassInfo. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBaseClass(BaseClassInfo_t* info = 0, TClass* cl = 0); Default TBaseClass ctor. TBaseClasses are constructed in TClass; via a call to TCint::CreateListOfBaseClasses(). ~TBaseClass(); TBaseClass dtor deletes adopted CINT BaseClassInfo object. void Browse(TBrowser* b); Called by the browser, to browse a baseclass. TClass * GetClassPointer(Bool_t load = kTRUE); Get pointer to the base class TClass. Int_t GetDelta() const; Get offset from ""this"" to part of base class. const char * GetTitle() const; Get base class description (comment). int IsSTLContainer(); Return which type (if any) of STL container the data member is. Long_t Property() const; Get property description word. For meaning of bits see EProperty. TBaseClass(const TBaseClass& ). TBaseClass& operator=(const TBaseClass& ). Bool_t IsFolder() const; {return kTRUE;}. » Author: Fons Rademakers 08/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-03-12 16:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBaseClass.html:6861,load,load,6861,root/html534/TBaseClass.html,https://root.cern,https://root.cern/root/html534/TBaseClass.html,1,['load'],['load']
Performance,"ss()->IsSyntheticPair()) {; 3706 printf(""ReadStreamerInfo, class:%s, illegal uid=%d\n"",info->GetName(),uid);; 3707 }; 3708 if (gDebug > 0) printf("" -class: %s version: %d info read at slot %d\n"",info->GetName(), info->GetClassVersion(),uid);; 3709 }; 3710 lnk = lnk->Next();; 3711 }; 3712 }; 3713 fClassIndex->fArray[0] = 0;; 3714 list->Clear(); //this will delete all TStreamerInfo objects with kCanDelete bit set; 3715 delete list;; 3716 ; 3717 // We are done processing the record, let future calls and other threads that it; 3718 // has been done.; 3719 fgTsSIHashes.Insert(listRetcode.fHash, std::move(si_uids));; 3720}; 3721 ; 3722////////////////////////////////////////////////////////////////////////////////; 3723/// Specify if the streamerinfos must be read at file opening.; 3724///; 3725/// If fgReadInfo is true (default) TFile::ReadStreamerInfo is called; 3726/// when opening the file.; 3727/// It may be interesting to set fgReadInfo to false to speedup the file; 3728/// opening time or in case libraries containing classes referenced; 3729/// by the file have not yet been loaded.; 3730/// if fgReadInfo is false, one can still read the StreamerInfo with; 3731/// myfile.ReadStreamerInfo();; 3732 ; 3733void TFile::SetReadStreamerInfo(Bool_t readinfo); 3734{; 3735 fgReadInfo = readinfo;; 3736}; 3737 ; 3738////////////////////////////////////////////////////////////////////////////////; 3739/// If the streamerinfos are to be read at file opening.; 3740///; 3741/// See TFile::SetReadStreamerInfo for more documentation.; 3742 ; 3743Bool_t TFile::GetReadStreamerInfo(); 3744{; 3745 return fgReadInfo;; 3746}; 3747 ; 3748////////////////////////////////////////////////////////////////////////////////; 3749/// Show the StreamerInfo of all classes written to this file.; 3750 ; 3751void TFile::ShowStreamerInfo(); 3752{; 3753 TList *list = GetStreamerInfoList();; 3754 if (!list) return;; 3755 ; 3756 list->ls();; 3757 delete list;; 3758}; 3759 ; 3760/////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:135776,load,loaded,135776,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['load'],['loaded']
Performance,"ss(). static TClass * TDirectory::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDirectory::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDirectory::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 308 of file TDirectory.h. ◆ CleanTargets(). void TDirectory::CleanTargets ; (; ). protected . Clean the pointers to this object (gDirectory, TContext, etc.). ; Definition at line 264 of file TDirectory.cxx. ◆ Clear(). void TDirectory::Clear ; (; Option_t * ; option = """"). overridevirtual . Delete all objects from a Directory list. ; Reimplemented from TObject.; Definition at line 634 of file TDirectory.cxx. ◆ CloneObject(). TObject * TDirectory::CloneObject ; (; const TObject * ; obj, . Bool_t ; autoadd = kTRUE . ). virtual . Clone an object. ; This function is called when the directory is not a TDirectoryFile. This version has to load the I/O package, hence via Cling.; If autoadd is true and if the object class has a DirectoryAutoAdd function, it will be called at the end of the function with the parameter gDirector. This usually means that the object will be appended to the current ROOT directory. ; Reimplemented in TDirectoryFile.; Definition at line 364 of file TDirectory.cxx. ◆ Close(). void TDirectory::Close ; (; Option_t * ; option = """"). virtual . Delete all objects from memory and directory structure itself. ; if option is ""slow"", iterate through the containers in a way to can handle 'external' modification (induced by recursions) if option is ""nodelete"", write the TDirectory but do not delete the contained objects. ; Reimplemented in TSQLFile, TXMLFile, TDirectoryFile, TFile, TNetFile, TParallelMergingFile, and TWebFile.; Definition at line 645 of file TDirectory.cxx. ◆ Copy(). void TDirectory::Copy ; (; TObject & ; object); const. inlineoverridevirtual . Copy this to obj. ; Reimplemented from TObject.; Reimple",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTDirectory.html:27944,load,load,27944,doc/v632/classTDirectory.html,https://root.cern,https://root.cern/doc/v632/classTDirectory.html,2,['load'],['load']
Performance,"ss(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidUpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLObject.html:2390,cache,cached,2390,root/html534/TGLObject.html,https://root.cern,https://root.cern/root/html534/TGLObject.html,1,['cache'],['cached']
Performance,"ss();; 627}; 628 ; 629template <typename T>; 630struct TClassGetClassHelper {; 631 static TClass *GetClass(Bool_t load, Bool_t silent) {; 632 return TClass::GetClass(typeid(T), load, silent);; 633 }; 634};; 635 ; 636template <typename F, typename S>; 637struct TClassGetClassHelper<std::pair<F, S> > {; 638 static TClass *GetClass(Bool_t load, Bool_t silent) {; 639 using pair_t = std::pair<F,S>;; 640 size_t hint_offset = offsetof(pair_t, second);; 641 return TClass::GetClass(typeid(std::pair<F, S>), load, silent, hint_offset, sizeof(std::pair<F,S>));; 642 }; 643};; 644 ; 645template <typename T>; 646TClass *GetClassHelper(Bool_t load, Bool_t silent, std::false_type); 647{; 648 return TClassGetClassHelper<T>::GetClass(load, silent);; 649}; 650 ; 651} // namespace Internal; 652} // namespace ROOT; 653 ; 654template <typename T>; 655TClass *TClass::GetClass(Bool_t load, Bool_t silent); 656{; 657 typename std::is_base_of<TObject, T>::type tag;; 658 return ROOT::Internal::GetClassHelper<T>(load, silent, tag);; 659}; 660 ; 661namespace ROOT {; 662 ; 663template <typename T> TClass *GetClass(T * /* dummy */) { return TClass::GetClass<T>(); }; 664template <typename T> TClass *GetClass(const T * /* dummy */) { return TClass::GetClass<T>(); }; 665 ; 666#ifndef R__NO_CLASS_TEMPLATE_SPECIALIZATION; 667 // This can only be used when the template overload resolution can distinguish between T* and T**; 668 template <typename T> TClass* GetClass( T** /* dummy */) { return TClass::GetClass<T>(); }; 669 template <typename T> TClass* GetClass(const T** /* dummy */) { return TClass::GetClass<T>(); }; 670 template <typename T> TClass* GetClass( T* const* /* dummy */) { return TClass::GetClass<T>(); }; 671 template <typename T> TClass* GetClass(const T* const* /* dummy */) { return TClass::GetClass<T>(); }; 672#endif; 673 ; 674 extern TClass *CreateClass(const char *cname, Version_t id,; 675 const char *dfil, const char *ifil,; 676 Int_t dl, Int_t il);; 677}; 678 ; 679#endif // ROOT_TClass;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:33250,load,load,33250,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['load'],['load']
Performance,"ss(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTProofServ::DeletePlayer(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tTProofServ::Fork(); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; Int_tTProofServ::GetSessionStatus(); virtual voidTProofServ::HandleArchive(TMessage* mess, TString* slb = 0); virtual Int_tTProofServ::HandleCache(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleCheckFile(TMessage* mess, TString* slb = 0); virtual Int_tTProofServ::HandleDataSets(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleLibIncPath(TMessage* mess); virtual voidTProofServ::HandleProcess(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleQueryList(TMessage* mess); virtual voidTProofServ::HandleRemove(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleRetrieve(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleSubmerger(TMessage* mess); virtual Int_tTProofServ::HandleWorkerLists(TMessage* mess); virtual voidTApplication::Help(const char* line); Bool_tTProofServ::IsIdle(); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); virtual voidTProofServ::MakePlayer(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual voidTProofServ::ProcessNext(TString* slb = 0); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh); Int_tTProofServ::SetupCommon(); Bool_tTProofServ::UnlinkDataDir(const char* path).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofServLite.html:15048,Load,LoadGraphicsLibs,15048,root/html530/TProofServLite.html,https://root.cern,https://root.cern/root/html530/TProofServLite.html,3,['Load'],['LoadGraphicsLibs']
Performance,"ss) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimTemplGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxiliary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integration ;  CIntegratorMultiDimOptionsNumerical multi dimensional integration options ;  CIntegratorOneDimUser Class for performing numerical integration of a function in one dimension ;  CIntegratorOneDimOptionsNumerical one dimensional integration options ;  CInterpolatorClass for performing function interpolation of points ;  CInverterMatrix Inverter class Class to specialize calls to Dinv ;  CInverter< 0 >Inverter<0> ;  CInverter< 1 >1x1 matrix inversion \(a_{11} \to 1/a_{11}\) ;  CInverter< 2 >2x2 matrix inversion using Cramers rule ;  CIOptionsGeneric interface for defining configuration options of a numerical algorithm ;  CIParametricFunctionMultiDimTemplIParamFunction interface (abstract class) describing multi-dimensional parameteric functions It is a derived class from ROOT::Math::IBaseFunctionMultiDim and ROOT::Math::IBaseParam ;  CIParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is a derived class from ROOT::Math::IBaseFunctionOneDim and ROOT::Math::IBaseParam ;  CIParametricGradFunctionMultiDimTemplInterface (abstract class) for parametric gradient multi-dimensional functions providing in addition to function evaluation with respect to the coordinates also the gradient with respect to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:44958,perform,performing,44958,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,4,['perform'],['performing']
Performance,"ss* cl); Check whether cl is a namespace. void LoadAllLibs(); Load all libraries known to ROOT via the rootmap system. void MakeAll(Bool_t force = kFALSE, const char* filter = ""*"", int numthreads = 1); Produce documentation for all the classes specified in the filter (by default ""*""); To process all classes having a name starting with XX, do:; html.MakeAll(kFALSE,""XX*"");; If force=kFALSE (default), only the classes that have been modified since; the previous call to this function will be generated.; If force=kTRUE, all classes passing the filter will be processed.; If numthreads is != -1, use numthreads threads, else decide automatically; based on the number of CPUs. void MakeClass(const char* className, Bool_t force = kFALSE); Make HTML files for a single class. Input: className - name of the class to process. void MakeClass(void* cdi, Bool_t force = kFALSE); Make HTML files for a single class. Input: cdi - doc info for class to process. void* MakeClassThreaded(void* info); Entry point of worker threads for multi-threaded MakeAll().; info points to an (internal) THtmlThreadInfo object containing the current; THtml object, and whether ""force"" was passed to MakeAll().; The thread will poll GetNextClass() until no further class is available. void MakeIndex(const char* filter = ""*""); Create the index files for the product, modules, all types, etc.; By default all classes are indexed (if filter=""*"");; to generate an index for all classes starting with ""XX"", do; html.MakeIndex(""XX*"");. void MakeTree(const char* className, Bool_t force = kFALSE); Make an inheritance tree. Input: className - name of the class to process. void SetFoundDot(Bool_t found = kTRUE); Set whether ""dot"" (a GraphViz utility) is available. void SetLocalFiles() const; Fill the files available in the file system below fPathInfo.fInputPath. void SetModuleDefinition(const THtml::TModuleDefinition& md); Set the module defining object to be used; can also be a user derived; object (a la traits). void SetFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THtml.html:32816,multi-thread,multi-threaded,32816,root/html534/THtml.html,https://root.cern,https://root.cern/root/html534/THtml.html,3,['multi-thread'],['multi-threaded']
Performance,"ss* cl); Check whether cl is a namespace. void LoadAllLibs(); Load all libraries known to ROOT via the rootmap system. void MakeAll(Bool_t force = kFALSE, const char* filter = ""*"", int numthreads = 1); Produce documentation for all the classes specified in the filter (by default ""*""); To process all classes having a name starting with XX, do:; html.MakeAll(kFALSE,""XX*"");; If force=kFALSE (default), only the classes that have been modified since; the previous call to this function will be generated.; If force=kTRUE, all classes passing the filter will be processed.; If numthreads is != -1, use numthreads threads, else decide automatically; based on the number of CPUs. void MakeClass(const char* className, Bool_t force = kFALSE); Make HTML files for a single class. Input: className - name of the class to process. void MakeClass(void* cdi, Bool_t force = kFALSE); Make HTML files for a single class. Input: cdi - doc info for class to process. void* MakeClassThreaded(void* info); Entry point of worker threads for multi-threaded MakeAll().; info points to an (internal) THtmlThreadInfo object containing the current; THtml object, and whether ""force"" was passed to MakeAll().; The thread will poll GetNextClass() until no further class is available. void MakeIndex(const char* filter = ""*""); Create the index files for the product, modules, all types, etc.; By default all classes are indexed (if filter=""*"");; to generate an index for all classes starting with ""XX"", do; html.MakeIndex(""XX*"");. void MakeTree(const char* className, Bool_t force = kFALSE); Make an inheritance tree. Input: className - name of the class to process. void SetFoundDot(Bool_t found = kTRUE); Set whether ""dot"" (a GraphViz utility) is avaliable. void SetLocalFiles() const; Fill the files available in the file system below fPathInfo.fInputPath. void SetModuleDefinition(const THtml::TModuleDefinition& md); Set the module defining object to be used; can also be a user derived; object (a la traits). void SetFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THtml.html:32915,multi-thread,multi-threaded,32915,root/html528/THtml.html,https://root.cern,https://root.cern/root/html528/THtml.html,3,['multi-thread'],['multi-threaded']
Performance,"ss* sender_class, const char* signal, TClass* receiver_class, const char* slot); static voidTApplication::Close(TApplication* app); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidDeletePlayer(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tFork(); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; Int_tGetSessionStatus(); virtual voidHandleArchive(TMessage* mess, TString* slb = 0); virtual Int_tHandleCache(TMessage* mess, TString* slb = 0); virtual voidHandleCheckFile(TMessage* mess, TString* slb = 0); virtual Int_tHandleDataSets(TMessage* mess, TString* slb = 0); virtual voidHandleFork(TMessage* mess); virtual voidHandleLibIncPath(TMessage* mess); virtual voidHandleProcess(TMessage* mess, TString* slb = 0); virtual voidHandleQueryList(TMessage* mess); virtual voidHandleRemove(TMessage* mess, TString* slb = 0); virtual voidHandleRetrieve(TMessage* mess, TString* slb = 0); virtual voidHandleSubmerger(TMessage* mess); virtual voidHandleWorkerLists(TMessage* mess); virtual voidTApplication::Help(const char* line); Bool_tIsIdle(); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); virtual voidMakePlayer(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual voidProcessNext(TString* slb = 0); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh); virtual Int_tSetup(); Int_tSetupCommon(); Bool_tUnlinkDataDir(const char* path).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:13794,Load,LoadGraphicsLibs,13794,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,1,['Load'],['LoadGraphicsLibs']
Performance,"ss*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tDLOffset(Short_t lod) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; TGLCylinder&operator=(const TGLCylinder&); virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tQuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesSupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TGLCylinder(const TBuffer3DTube& buffer); TGLCylinder(const TGLCylinder&); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLCylinder.html:1878,cache,cached,1878,root/html602/TGLCylinder.html,https://root.cern,https://root.cern/root/html602/TGLCylinder.html,2,['cache'],['cached']
Performance,"ss*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Tue Mar 10 17:13:51 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCacheElement.html:2008,cache,cache,2008,root/html534/RooAbsCacheElement.html,https://root.cern,https://root.cern/root/html534/RooAbsCacheElement.html,1,['cache'],['cache']
Performance,"ss. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the foll",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:52581,Load,LoadClassCustom,52581,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['Load'],['LoadClassCustom']
Performance,"ss. The first data member is fChain. Once this class is instantiated, fChain will point to the original tree or chain this class was made from. In our case, this is “T” in “Event.root”. If the class is instantiated with a tree as a parameter to the constructor, fChain will point to the tree named in the parameter. Next is fCurrent, which is also a pointer to the current tree/chain. Its role is only relevant when we have multiple trees chained together in a TChain. The class definition shows us that this tree has one branch and one leaf per data member. The methods of MyClass are:. MyClass(TTree *tree=0) - this constructor has an optional tree for a parameter. If you pass a tree, MyClass will use it rather than the tree from which it was created.; void Init(TTree *tree) - it is called by the constructor to initialize the tree for reading. It associates each branch with the corresponding leaf data member.; ~MyClass() -the destructor, nothing special.; Int_t GetEntry(Int_t entry) - it loads the class with the entry specified. Once you have executed GetEntry, the leaf data members in MyClass are set to the values of the entry. For example, GetEntry(12) loads the 13th event into the event data member of MyClass (note that the first entry is 0). GetEntry returns the number of bytes read from the file. In case the same entry is read twice, ROOT does not have to do any I/O. In this case GetEntry returns 1. It does not return 0, because many people assume a return of 0 means an error has occurred while reading.; Int_t LoadTree(Int_t entry) and void Notify() - these two methods are related to chains. LoadTree will load the tree containing the specified entry from a chain of trees. Notify is called by LoadTree to adjust the branch addresses.; void Loop() - it is the skeleton method that loops through each entry of the tree. This is interesting to us, because we will need to customize it for our analysis. 12.21.3 MyClass.C; MyClass::Loop consists of a for-loop calling GetEntry ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:639500,load,loads,639500,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loads']
Performance,"ss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:5447,cache,cache,5447,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,['cache'],['cache']
Performance,"ss. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Update contents of cache histogram by resampling the input function. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. void operModeHook(). RooCachedReal(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooCachedReal(*this,newname); }. void setCdfBoundaries(Bool_t flag); If flag is true the RooHistFunc that represent the cache histogram; will use special boundary conditions for use with cumulative distribution; functions: at the lower bound the function is forced to converge at zero and the upper; bound is the function is forced to converge at 1.0. Bool_t getCdfBoundaries() const; If true the c.d.f boundary mode is active. Bool_t cacheSource() const; { return _cacheSource ; }. void setCacheSource(Bool_t flag); { _cacheSource = flag ; }. const char* inputBaseName() const; Return base name for caches, i.e. the name of the cached function. Double_t evaluate() const; Dummy evaluate, it is never called. const char* payloadUniqueSuffix() const; { return func.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Sat Sep 5 16:40:23 2015 » Last generated: 2015-09-05 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedReal.html:39900,cache,cache,39900,root/html534/RooCachedReal.html,https://root.cern,https://root.cern/root/html534/RooCachedReal.html,4,['cache'],"['cache', 'cacheSource', 'cached', 'caches']"
Performance,"ss.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf201_compositeDefinition rf201_composite.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); 0x7fff963ebea0 RooAddPdf::model = 0.898624/1 [Auto,Clean] ; 0x7fff963eb588/V- RooChebychev::bkg = 0.79893 [Auto,Dirty] ; 0x7fff963ebab8/V- RooRealVar::x = 5; 0x7fff963e9588/V- RooRealVar::a0 = 0.441621 +/- 0.0731875; 0x7fff963e9970/V- RooRealVar::a1 = 0.20107 +/- 0.117637; 0x7fff963eac48/V- RooRealVar::bkgfrac = 0.504184 +/- 0.0359091; 0x7fff963e9d58/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7fff963e8860/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x7fff963ebab8/V- RooRealVar::x = 5; 0x7fff963ea478/V- RooRealVar::mean = 5; 0x7fff963e8db8/V- RooRealVar::sigma1 = 0.5; 0x7fff963ea8",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf201__composite_8C.html:6844,optimiz,optimization,6844,doc/master/rf201__composite_8C.html,https://root.cern,https://root.cern/doc/master/rf201__composite_8C.html,2,['optimiz'],['optimization']
Performance,"ss; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_t_defShapeServer; Bool_t_defValueServer; TIterator*_iter! do not persist; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsProxy::_nset! Normalization set to be used for evaluation of RooAbsPdf contents; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; RooAbsArg*_owner; static char*RooArgSet::_poolBegin! Start of memory pool; static char*RooArgSet::_poolCur! Next free slot in memory pool; static char*RooArgSet::_poolEnd! End of memory pool . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void* operator new(size_t bytes); Overload new operator must be implemented because it is overloaded; in the RooArgSet base class. Perform standard memory allocation; here instead of memory pool management performed in RooArgSet. void operator delete(void* ptr). RooSetProxy(const char* name, const char* desc, RooAbsArg* owner, Bool_t defValueServer = kTRUE, Bool_t defShapeServer = kFALSE); Construct proxy with given name and description, with given owner; The default value and shape dirty propagation of the set contents; to the set owner is controlled by flags defValueServer and defShapeServer. RooSetProxy(const char* name, RooAbsArg* owner, const RooSetProxy& other); Copy constructor. ~RooSetProxy(); Destructor. Bool_t add(const RooAbsArg& var, Bool_t valueServer, Bool_t shapeServer, Bool_t silent); Overloaded RooArgSet::add() method insert object into set; and registers object as server to owner with given value; and shape dirty flag propagation requests. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Overloaded RooArgSet::addOwned() method insert object into owning set; and registers object as server to owner with default value; and shape dirty flag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSetProxy.html:12796,Perform,Perform,12796,root/html528/RooSetProxy.html,https://root.cern,https://root.cern/root/html528/RooSetProxy.html,4,"['Perform', 'perform']","['Perform', 'performed']"
Performance,"ss; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_t_defShapeServer; Bool_t_defValueServer; TIterator*_iter! do not persist; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsProxy::_nset! Normalization set to be used for evaluation of RooAbsPdf contents; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; RooAbsArg*_owner; static char*RooArgSet::_poolBegin! Start of memory pool; static char*RooArgSet::_poolCur! Next free slot in memory pool; static char*RooArgSet::_poolEnd! End of memory pool . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void* operator new(size_t bytes); Overload new operator must be implemented because it is overloaded; in the RooArgSet base class. Perform standard memory allocation; here instead of memory pool management performed in RooArgSet. void operator delete(void* ptr). RooSetProxy(const char* name, const char* desc, RooAbsArg* owner, Bool_t defValueServer = kTRUE, Bool_t defShapeServer = kFALSE); Construct proxy with given name and description, with given owner; The default value and shape dirty propagation of the set contents; to the set owner is controlled by flags defValueServer and defShapeServer. RooSetProxy(const char* name, RooAbsArg* owner, const RooSetProxy& other); Copy constructor. ~RooSetProxy(); Destructor. Bool_t add(const RooAbsArg& var, Bool_t valueServer, Bool_t shapeServer, Bool_t silent); Overloaded RooArgSet::add() method insert object into set; and registers object as server to owner with given value; and shape dirty flag propagation requests. Bool_t addOwned(RooAbsArg& var, Bool_t silent); Overloaded RooArgSet::addOwned() method insert object into owning set; and registers object as server to owner with default value; and shape dirty flag propagat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSetProxy.html:12759,Perform,Perform,12759,root/html526/RooSetProxy.html,https://root.cern,https://root.cern/root/html526/RooSetProxy.html,2,"['Perform', 'perform']","['Perform', 'performed']"
Performance,"ssInfo_t *cl = gCling->ClassInfo_Factory(localname);; 198 bool ok = false;; 199 bool nameFound = false;; 200 if (cl && gCling->ClassInfo_IsValid(cl)) {; 201 if (localname == gCling->ClassInfo_FullName(cl)) {; 202 nameFound = true;; 203 if (gCling->ClassInfo_IsBase(cl,""TSelector"")) ok = true;; 204 }; 205 }; 206 if (!ok) {; 207 if (fromFile) {; 208 if (nameFound) {; 209 ::Error(""TSelector::GetSelector"",; 210 ""The class %s in file %s does not derive from TSelector."", localname.Data(), filename);; 211 } else {; 212 ::Error(""TSelector::GetSelector"",; 213 ""The file %s does not define a class named %s."", filename, localname.Data());; 214 }; 215 } else {; 216 if (autoloaderr); 217 ::Error(""TSelector::GetSelector"", ""class %s could not be loaded"", filename);; 218 else; 219 ::Error(""TSelector::GetSelector"",; 220 ""class %s does not exist or does not derive from TSelector"", filename);; 221 }; 222 gCling->ClassInfo_Delete(cl);; 223 return nullptr;; 224 }; 225 ; 226 // we can now create an instance of the class; 227 TSelector *selector = (TSelector*)gCling->ClassInfo_New(cl);; 228 gCling->ClassInfo_Delete(cl);; 229 return selector;; 230 }; 231}; 232 ; 233////////////////////////////////////////////////////////////////////////////////; 234/// Find out if this is a standard selection used for Draw actions; 235/// (either TSelectorDraw, TProofDraw or deriving from them).; 236 ; 237bool TSelector::IsStandardDraw(const char *selec); 238{; 239 // Make sure we have a name; 240 if (!selec) {; 241 ::Info(""TSelector::IsStandardDraw"",; 242 ""selector name undefined - do nothing"");; 243 return false;; 244 }; 245 ; 246 bool stdselec = false;; 247 if (!strchr(selec, '.')) {; 248 if (strstr(selec, ""TSelectorDraw"")) {; 249 stdselec = true;; 250 } else {; 251 TClass *cl = TClass::GetClass(selec);; 252 if (cl && (cl->InheritsFrom(""TProofDraw"") ||; 253 cl->InheritsFrom(""TSelectorDraw""))); 254 stdselec = true;; 255 }; 256 }; 257 ; 258 // We are done; 259 return stdselec;; 260}; 261 ; 262//////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:8930,load,loaded,8930,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,1,['load'],['loaded']
Performance,ss_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  Return observable in nset to be cached by RooAbsCachedPdf this is always the x observable that is integrated. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  Return the parameters of the cache created by RooAbsCachedPdf. ;  ; const char * binningName () const override;  ; FuncCacheElem * createCache (const RooArgSet *nset) const override;  Create custom cache element for running integral calculations. ;  ; double evaluate () const override;  Dummy function that is never called. ;  ; void fillCacheObject (FuncCacheElem &cacheFunc) const override;  Fill the cache object by calling its calculate() method. ;  ; const char * inputBaseName () const override;  Return unique name for RooAbsCachedPdf cache components constructed from input function name. ;  ; const char * payloadUniqueSuffix () const override;  ;  Protected Member Functions inherited from RooAbsCachedReal; TString cacheNameSuffix (const RooArgSet &nset) const;  Construct unique,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumRunningInt.html:49294,cache,cached,49294,doc/master/classRooNumRunningInt.html,https://root.cern,https://root.cern/doc/master/classRooNumRunningInt.html,1,['cache'],['cached']
Performance,"ssed entry, passing in the aggregator variable and the value of the column columnName. If the signature is U(U,T) the aggregator variable is then copy-assigned the result of the execution of the callable. Otherwise the signature of aggregator must be void(U&,T).; The merger callable is used to merge the partial accumulation results of each processing thread. It is only called in multi-thread executions. If its signature is U(U,U) the aggregator variables of each thread are merged two by two. If its signature is void(std::vector<U>& a) it is assumed that it merges all aggregators in a[0].; This action is lazy: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr.; Example usage: auto aggregator = [](double acc, double x) { return acc * x; };; ROOT::EnableImplicitMT();; // If multithread is enabled, the aggregator function will be called by more threads; // and will produce a vector of partial accumulators.; // The merger function performs the final aggregation of these partial results.; auto merger = [](std::vector<double> &accumulators) {; for (auto i : ROOT::TSeqU(1u, accumulators.size())) {; accumulators[0] *= accumulators[i];; }; };; ; // The accumulator is initialized at this value by every thread.; double initValue = 1.;; ; // Multiplies all elements of the column ""x""; auto result = d.Aggregate(aggregator, merger, ""x"", initValue);; d#define d(i)Definition RSha256.hxx:102; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; ROOT::TSeqA pseudo container class which is a generator of indices.Definition TSeq.hxx:67; xDouble_t x[n]Definition legend1.C:17; ROOTtbb::task_arena is an alias of tb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:33361,perform,performs,33361,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['perform'],['performs']
Performance,"sses and create branches for each one.; 6095 TObjArray* blist = this->GetListOfBranches();; 6096 TIter next(sinfo->GetElements());; 6097 TStreamerElement* element = nullptr;; 6098 TString bname;; 6099 for (Int_t id = 0; (element = (TStreamerElement*) next()); ++id) {; 6100 if (element->IsA() == TStreamerArtificial::Class()) {; 6101 continue;; 6102 }; 6103 if (element->TestBit(TStreamerElement::kRepeat)) {; 6104 continue;; 6105 }; 6106 if (element->TestBit(TStreamerElement::kCache) && !element->TestBit(TStreamerElement::kWrite)) {; 6107 continue;; 6108 }; 6109 char* pointer = (char*) (objptr + element->GetOffset());; 6110 // FIXME: This is not good enough, an STL container can be; 6111 // a base, and the test will fail.; 6112 // See TBranchElement::InitializeOffsets() for the; 6113 // correct test.; 6114 bool isBase = (element->IsA() == TStreamerBase::Class());; 6115 if (isBase) {; 6116 TClass* clbase = element->GetClassPointer();; 6117 if ((clbase == TObject::Class()) && cl->CanIgnoreTObjectStreamer()) {; 6118 // Note: TStreamerInfo::Compile() leaves this element; 6119 // out of the optimized info, although it does; 6120 // exists in the non-compiled and non-optimized info.; 6121 // FIXME: The test that TStreamerInfo::Compile() uses; 6122 // is element->GetType() < 0, so that is what; 6123 // we should do as well.; 6124 continue;; 6125 }; 6126 if (clbase->GetListOfRealData()->GetSize() == 0) {; 6127 // Do not create a branch for empty bases.; 6128 continue;; 6129 }; 6130 }; 6131 if (dot) {; 6132 if (dotlast) {; 6133 bname.Form(""%s%s"", name, element->GetFullName());; 6134 } else {; 6135 // FIXME: We are in the case where we have a top-level; 6136 // branch name that was created by the branch; 6137 // constructor which takes a folder as input.; 6138 // The internal dots in the name are in place of; 6139 // of the original slashes and represent the; 6140 // folder hierarchy.; 6141 if (isBase) {; 6142 // FIXME: This is very strange, this is the only case where; 6143 // ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:228981,optimiz,optimized,228981,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,2,['optimiz'],['optimized']
Performance,"ssification example; /// @param nevts : number of signal/background events. Use by default a low value (1000); /// but increase to at least 5000 to get a good result; /// @param opt : vector of bool with method used (default all on if available). The order is:; /// - TMVA CNN; /// - Keras CNN; /// - TMVA DNN; /// - TMVA BDT; /// - PyTorch CNN; void TMVA_CNN_Classification(int nevts = 1000, std::vector<bool> opt = {1, 1, 1, 1, 1}); {; ; int imgSize = 16 * 16;; TString inputFileName = ""images_data_16x16.root"";; ; bool fileExist = !gSystem->AccessPathName(inputFileName);; ; // if file does not exists create it; if (!fileExist) {; MakeImagesTree(nevts, 16, 16);; }; ; bool useTMVACNN = (opt.size() > 0) ? opt[0] : false;; bool useKerasCNN = (opt.size() > 1) ? opt[1] : false;; bool useTMVADNN = (opt.size() > 2) ? opt[2] : false;; bool useTMVABDT = (opt.size() > 3) ? opt[3] : false;; bool usePyTorchCNN = (opt.size() > 4) ? opt[4] : false;; #ifndef R__HAS_TMVACPU; #ifndef R__HAS_TMVAGPU; Warning(""TMVA_CNN_Classification"",; ""TMVA is not build with GPU or CPU multi-thread support. Cannot use TMVA Deep Learning for CNN"");; useTMVACNN = false;; #endif; #endif; ; bool writeOutputFile = true;; ; #ifdef R__USE_IMT; int num_threads = 4; // use by default 4 threads if value is not set before; // switch off MT in OpenBLAS to avoid conflict with tbb; gSystem->Setenv(""OMP_NUM_THREADS"", ""1"");; ; // do enable MT running; if (num_threads >= 0) {; ROOT::EnableImplicitMT(num_threads);; }; #endif; ; TMVA::Tools::Instance();; ; ; std::cout << ""Running with nthreads = "" << ROOT::GetThreadPoolSize() << std::endl;; ; #ifdef R__HAS_PYMVA; gSystem->Setenv(""KERAS_BACKEND"", ""tensorflow"");; // for using Keras; TMVA::PyMethodBase::PyInitialize();; #else; useKerasCNN = false;; usePyTorchCNN = false;; #endif; ; TFile *outputFile = nullptr;; if (writeOutputFile); outputFile = TFile::Open(""TMVA_CNN_ClassificationOutput.root"", ""RECREATE"");; ; /***; ## Create TMVA Factory; ; Create the Factory class. Later yo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:48381,multi-thread,multi-thread,48381,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['multi-thread'],['multi-thread']
Performance,"ssing();; 73 void DisableParBranchProcessing();; 74 Bool_t IsParBranchProcessingEnabled();; 75 class TParBranchProcessingRAII {; 76 public:; 77 TParBranchProcessingRAII() { EnableParBranchProcessing(); }; 78 ~TParBranchProcessingRAII() { DisableParBranchProcessing(); }; 79 };; 80} } // End ROOT::Internal; 81 ; 82namespace ROOT {; 83 /// \brief Enable support for multi-threading within the ROOT code; 84 /// in particular, enables the global mutex to make ROOT thread safe/aware.; 85 void EnableThreadSafety();; 86 /// \brief Enable ROOT's implicit multi-threading for all objects and methods that provide an internal; 87 /// parallelisation mechanism.; 88 void EnableImplicitMT(UInt_t numthreads = 0);; 89 void DisableImplicitMT();; 90 Bool_t IsImplicitMTEnabled();; 91 UInt_t GetThreadPoolSize();; 92}; 93 ; 94class TROOT : public TDirectory {; 95 ; 96friend class TCling;; 97friend TROOT *ROOT::Internal::GetROOT2();; 98 ; 99private:; 100 Int_t fLineIsProcessing; ///< To synchronize multi-threads; 101 ; 102 static Int_t fgDirLevel; ///< Indentation level for ls(); 103 static Bool_t fgRootInit; ///< Singleton initialization flag; 104 ; 105 TROOT(const TROOT&) = delete;; 106 TROOT& operator=(const TROOT&) = delete;; 107 ; 108protected:; 109 typedef std::atomic<TListOfEnums*> AListOfEnums_t;; 110 ; 111 TString fConfigOptions; ///< ROOT ./configure set build options; 112 TString fConfigFeatures; ///< ROOT ./configure detected build features; 113 TString fVersion; ///< ROOT version (from CMZ VERSQQ) ex 0.05/01; 114 Int_t fVersionInt; ///< ROOT version in integer format (501); 115 Int_t fVersionCode; ///< ROOT version code as used in RVersion.h; 116 Int_t fVersionDate; ///< Date of ROOT version (ex 951226); 117 Int_t fVersionTime; ///< Time of ROOT version (ex 1152); 118 Int_t fBuiltDate; ///< Date of ROOT built; 119 Int_t fBuiltTime; ///< Time of ROOT built; 120 TString fGitCommit; ///< Git commit SHA1 of built; 121 TString fGitBranch; ///< Git branch; 122 TString fGitDate; ///< D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:3222,multi-thread,multi-threads,3222,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,2,['multi-thread'],['multi-threads']
Performance,"ssion level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& b); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The link",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFile.html:38986,cache,cache,38986,root/html530/TFile.html,https://root.cern,https://root.cern/root/html530/TFile.html,4,['cache'],['cache']
Performance,"ssion, functor class or any other callable object performing user defined calculations. ; [in]columnsNames of the columns/branches in input to the user function. The callable f is invoked once per entry. This is an instant action: upon invocation, an event loop as well as execution of all scheduled actions is triggered. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled (i.e. ROOT::EnableImplicitMT). Example usage:; myDf.Foreach([](int i){ std::cout << i << std::endl;}, {""myIntColumn""});. Definition at line 1611 of file RInterface.hxx. ◆ ForeachSlot(). template<typename Proxied , typename DataSource = void> . template<typename F > . void ROOT::RDF::RInterface< Proxied, DataSource >::ForeachSlot ; (; F ; f, . const ColumnNames_t & ; columns = {} . ). inline . Execute a user-defined function requiring a processing slot index on each entry (instant action). ; Parameters. [in]fFunction, lambda expression, functor class or any other callable object performing user defined calculations. ; [in]columnsNames of the columns/branches in input to the user function. Same as Foreach, but the user-defined function takes an extra unsigned int as its first parameter, the processing slot index. This slot index will be assigned a different value, 0 to poolSize - 1, for each thread of execution. This is meant as a helper in writing thread-safe Foreach actions when using RDataFrame after ROOT::EnableImplicitMT(). The user-defined processing callable is able to follow different streams of processing indexed by the first parameter. ForeachSlot works just as well with single-thread execution: in that case slot will always be 0. Example usage:; myDf.ForeachSlot([](unsigned int s, int i){ std::cout << ""Slot "" << s << "": ""<< i << std::endl;}, {""myIntColumn""});. Definition at line 1641 of file RInterface.hxx. ◆ GetFilterNames(). template<typename Proxied , typename DataSource = void> . std::vector< std::string > ROOT::RDF::RInterfac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:77200,perform,performing,77200,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['perform'],['performing']
Performance,"ssionAlgorithm () const;  ; Float_t GetCompressionFactor ();  Return the file compression factor. ;  ; Int_t GetCompressionLevel () const;  ; Int_t GetCompressionSettings () const;  ; virtual Long64_t GetEND () const;  ; virtual const TUrl * GetEndpointUrl () const;  ; virtual Int_t GetErrno () const;  Method returning errno. ;  ; Int_t GetFd () const;  ; TList * GetListOfFree () const;  ; TObjArray * GetListOfProcessIDs () const;  ; virtual Int_t GetNbytesFree () const;  ; virtual Int_t GetNbytesInfo () const;  ; virtual TString GetNewUrl ();  ; virtual Int_t GetNfree () const;  ; virtual Int_t GetNProcessIDs () const;  ; Option_t * GetOption () const override;  ; virtual Int_t GetReadCalls () const;  ; Int_t GetRecordHeader (char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header starting at a certain postion. ;  ; Long64_t GetRelOffset () const;  ; virtual Long64_t GetSeekFree () const;  ; virtual Long64_t GetSeekInfo () const;  ; const TList * GetStreamerInfoCache ();  Returns the cached list of StreamerInfos used in this file. ;  ; virtual TList * GetStreamerInfoList () final;  Read the list of TStreamerInfo objects written to this file. ;  ; Int_t GetVersion () const;  ; virtual void IncrementProcessIDs ();  ; virtual Bool_t IsArchive () const;  ; Bool_t IsBinary () const;  ; Bool_t IsRaw () const;  ; void ls (Option_t *option="""") const override;  List file contents. ;  ; virtual void MakeFree (Long64_t first, Long64_t last);  Mark unused bytes on the file. ;  ; virtual void MakeProject (const char *dirname, const char *classes=""*"", Option_t *option=""new"");  Generate source code necessary to access the objects stored in the file. ;  ; virtual void Map ();  ; virtual void Map (Option_t *opt);  List the contents of a file sequentially. ;  ; virtual Bool_t Matches (const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:7465,cache,cached,7465,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,2,['cache'],['cached']
Performance,"ssionAlgorithm () const;  ; Float_t GetCompressionFactor ();  Return the file compression factor. ;  ; Int_t GetCompressionLevel () const;  ; Int_t GetCompressionSettings () const;  ; virtual Long64_t GetEND () const;  ; virtual const TUrl * GetEndpointUrl () const;  ; virtual Int_t GetErrno () const;  Method returning errno. ;  ; Int_t GetFd () const;  ; TList * GetListOfFree () const;  ; TObjArray * GetListOfProcessIDs () const;  ; virtual Int_t GetNbytesFree () const;  ; virtual Int_t GetNbytesInfo () const;  ; virtual TString GetNewUrl ();  ; virtual Int_t GetNfree () const;  ; virtual Int_t GetNProcessIDs () const;  ; Option_t * GetOption () const override;  ; virtual Int_t GetReadCalls () const;  ; Int_t GetRecordHeader (char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header starting at a certain postion. ;  ; Long64_t GetRelOffset () const;  ; virtual Long64_t GetSeekFree () const;  ; virtual Long64_t GetSeekInfo () const;  ; const TList * GetStreamerInfoCache ();  Returns the cached list of StreamerInfos used in this file. ;  ; virtual TList * GetStreamerInfoList () final;  Read the list of TStreamerInfo objects written to this file. ;  ; Int_t GetVersion () const;  ; virtual void IncrementProcessIDs ();  ; virtual Bool_t IsArchive () const;  ; Bool_t IsBinary () const;  ; virtual Bool_t IsOpen () const;  Returns kTRUE in case file is open and kFALSE if file is not open. ;  ; Bool_t IsRaw () const;  ; void ls (Option_t *option="""") const override;  List file contents. ;  ; virtual void MakeFree (Long64_t first, Long64_t last);  Mark unused bytes on the file. ;  ; virtual void MakeProject (const char *dirname, const char *classes=""*"", Option_t *option=""new"");  Generate source code necessary to access the objects stored in the file. ;  ; virtual void Map ();  ; virtual void Map (Option_t *opt);  List the contents of a file sequentially. ;  ; virtual Bool_t Matches (const char *name);  Return kTRU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMemFile.html:7603,cache,cached,7603,doc/master/classTMemFile.html,https://root.cern,https://root.cern/doc/master/classTMemFile.html,5,['cache'],['cached']
Performance,"ssociated TEventList or TEntryList, the minimum is computed for the entries in this list. ; Reimplemented in TChain.; Definition at line 6275 of file TTree.cxx. ◆ GetNbranches(). virtual Int_t TTree::GetNbranches ; (; ). inlinevirtual . Reimplemented in TChain.; Definition at line 502 of file TTree.h. ◆ GetNewlineValue(). char TTree::GetNewlineValue ; (; std::istream & ; inputStream). protected . Determine which newline this file is using. ; Return '\r' for Windows '\r\n' as that already terminates. ; Definition at line 7588 of file TTree.cxx. ◆ GetNotify(). TObject * TTree::GetNotify ; (; ); const. inline . Definition at line 503 of file TTree.h. ◆ GetPacketSize(). virtual Int_t TTree::GetPacketSize ; (; ); const. inlinevirtual . Definition at line 505 of file TTree.h. ◆ GetPerfStats(). virtual TVirtualPerfStats * TTree::GetPerfStats ; (; ); const. inlinevirtual . Definition at line 506 of file TTree.h. ◆ GetPlayer(). TVirtualTreePlayer * TTree::GetPlayer ; (; ). Load the TTreePlayer (if not already done). ; Definition at line 6305 of file TTree.cxx. ◆ GetReadCache() [1/2]. TTreeCache * TTree::GetReadCache ; (; TFile * ; file); const. Find and return the TTreeCache registered with the file and which may contain branches for us. ; Definition at line 6318 of file TTree.cxx. ◆ GetReadCache() [2/2]. TTreeCache * TTree::GetReadCache ; (; TFile * ; file, . bool ; create . ). Find and return the TTreeCache registered with the file and which may contain branches for us. ; If create is true and there is no cache a new cache is created with default size. ; Definition at line 6331 of file TTree.cxx. ◆ GetReadEntry(). virtual Long64_t TTree::GetReadEntry ; (; ); const. inlinevirtual . Reimplemented in TProofChain, and TChain.; Definition at line 509 of file TTree.h. ◆ GetReadEvent(). virtual Long64_t TTree::GetReadEvent ; (; ); const. inlinevirtual . Definition at line 510 of file TTree.h. ◆ GetScanField(). virtual Int_t TTree::GetScanField ; (; ); const. inlinevirtual . Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:163442,Load,Load,163442,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['Load'],['Load']
Performance,"ssociated TEventList or TEntryList, the minimum is computed for the entries in this list. ; Reimplemented in TChain.; Definition at line 6275 of file TTree.cxx. ◆ GetNbranches(). virtual Int_t TTree::GetNbranches ; (; ). inlinevirtual . Reimplemented in TChain.; Definition at line 542 of file TTree.h. ◆ GetNewlineValue(). char TTree::GetNewlineValue ; (; std::istream & ; inputStream). protected . Determine which newline this file is using. ; Return '\r' for Windows '\r\n' as that already terminates. ; Definition at line 7588 of file TTree.cxx. ◆ GetNotify(). TObject * TTree::GetNotify ; (; ); const. inline . Definition at line 543 of file TTree.h. ◆ GetPacketSize(). virtual Int_t TTree::GetPacketSize ; (; ); const. inlinevirtual . Definition at line 545 of file TTree.h. ◆ GetPerfStats(). virtual TVirtualPerfStats * TTree::GetPerfStats ; (; ); const. inlinevirtual . Definition at line 546 of file TTree.h. ◆ GetPlayer(). TVirtualTreePlayer * TTree::GetPlayer ; (; ). Load the TTreePlayer (if not already done). ; Definition at line 6305 of file TTree.cxx. ◆ GetReadCache() [1/2]. TTreeCache * TTree::GetReadCache ; (; TFile * ; file); const. Find and return the TTreeCache registered with the file and which may contain branches for us. ; Definition at line 6318 of file TTree.cxx. ◆ GetReadCache() [2/2]. TTreeCache * TTree::GetReadCache ; (; TFile * ; file, . bool ; create . ). Find and return the TTreeCache registered with the file and which may contain branches for us. ; If create is true and there is no cache a new cache is created with default size. ; Definition at line 6331 of file TTree.cxx. ◆ GetReadEntry(). virtual Long64_t TTree::GetReadEntry ; (; ); const. inlinevirtual . Reimplemented in TProofChain, and TChain.; Definition at line 549 of file TTree.h. ◆ GetReadEvent(). virtual Long64_t TTree::GetReadEvent ; (; ); const. inlinevirtual . Definition at line 550 of file TTree.h. ◆ GetScanField(). virtual Int_t TTree::GetScanField ; (; ); const. inlinevirtual . Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:165630,Load,Load,165630,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['Load'],['Load']
Performance,"ssociative) && read); 1658 return TGenCollectionProxy__StagingCopyIterator;; 1659 else; 1660 return fFunctionCopyIterator = TGenCollectionProxy__SlowCopyIterator;; 1661}; 1662 ; 1663////////////////////////////////////////////////////////////////////////////////; 1664/// See typedef void* (*Next_t)(void *iter, void *end);; 1665/// iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end(); 1666/// 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end.; 1667/// If the end is not reached, 'Next' will return the address of the content unless the collection contains pointers in; 1668/// which case 'Next' will return the value of the pointer.; 1669 ; 1670TVirtualCollectionProxy::Next_t TGenCollectionProxy::GetFunctionNext(Bool_t read); 1671{; 1672 if (read) {; 1673 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1674 if ( (fProperties & kIsAssociative) && read); 1675 return TGenCollectionProxy__StagingNext;; 1676 }; 1677 ; 1678 if ( fFunctionNextIterator ) return fFunctionNextIterator;; 1679 ; 1680 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1681 ; 1682 // TODO can we do better than the default for RVec?; 1683 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1684 return fFunctionNextIterator = TGenCollectionProxy__VectorNext;; 1685 else if ( (fProperties & kIsAssociative) && read); 1686 return TGenCollectionProxy__StagingNext;; 1687 else; 1688 return fFunctionNextIterator = TGenCollectionProxy__SlowNext;; 1689}; 1690 ; 1691////////////////////////////////////////////////////////////////////////////////; 1692/// See typedef void (*DeleteIterator_t)(void *iter);; 1693/// If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; 1694/// Otherwise just call the iterator's destructor.; 1695 ; 1696TVirtualCollectionProxy::DeleteIterator_t TGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:55433,load,load,55433,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance,"ss . ). protected . Definition at line 300 of file TBranch.cxx. ◆ IsA(). TClass * TBranch::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in THbookBranch, TBranchClones, TBranchElement, TBranchObject, TBranchRef, and TBranchSTL.; Definition at line 295 of file TBranch.h. ◆ IsAutoDelete(). bool TBranch::IsAutoDelete ; (; ); const. Return true if an existing object in a TBranchObject must be deleted. ; Definition at line 2263 of file TBranch.cxx. ◆ IsFolder(). bool TBranch::IsFolder ; (; ); const. overridevirtual . Return true if more than one leaf or browsables, false otherwise. ; Reimplemented from TObject.; Reimplemented in TBranchClones, TBranchElement, TBranchObject, and TBranchSTL.; Definition at line 2271 of file TBranch.cxx. ◆ KeepCircular(). void TBranch::KeepCircular ; (; Long64_t ; maxEntries). virtual . keep a maximum of fMaxEntries in memory ; Definition at line 2283 of file TBranch.cxx. ◆ LoadBaskets(). Int_t TBranch::LoadBaskets ; (; ). virtual . Baskets associated to this branch are forced to be in memory. ; You can call TTree::SetMaxVirtualSize(maxmemory) to instruct the system that the total size of the imported baskets does not exceed maxmemory bytes.; The function returns the number of baskets that have been put in memory. This method may be called to force all baskets of one or more branches in memory when random access to entries in this branch is required. See also TTree::LoadBaskets to load all baskets of all branches in memory. ; Definition at line 2309 of file TBranch.cxx. ◆ operator=(). TBranch & TBranch::operator= ; (; const TBranch & ; ). privatedelete . ◆ Print(). void TBranch::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print TBranch parameters. ; If options contains ""basketsInfo"" print the entry number, location and size of each baskets. ; Reimplemented from TObject.; Reimplemented in TBranchSTL, TBranchClones, TBranchElement, TBranchObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:57372,Load,LoadBaskets,57372,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,1,['Load'],['LoadBaskets']
Performance,"st != """") {; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) it->second = 0;; ; std::vector<TString> mlist = TMVA::gTools().SplitString( myMethodList, ',' );; for (UInt_t i=0; i<mlist.size(); i++) {; std::string regMethod(mlist[i]);; ; if (Use.find(regMethod) == Use.end()) {; std::cout << ""Method \"""" << regMethod << ""\"" not known in TMVA under this name. Choose among the following:"" << std::endl;; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) std::cout << it->first << "" "";; std::cout << std::endl;; return 1;; }; Use[regMethod] = 1;; }; }; ; // --------------------------------------------------------------------------------------------------; ; // Here the preparation phase begins; ; // Read training and test data; // (it is also possible to use ASCII format as input -> see TMVA Users Guide); // Set the cache directory for the TFile to the current directory. The input; // data file will be downloaded here if not present yet, then it will be read; // from the cache path directly.; TFile::SetCacheFileDir(""."");; std::unique_ptr<TFile> input{TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD"")};; if (!input || input->IsZombie()) {; throw std::runtime_error(""ERROR: could not open data file"");; }; std::cout << ""--- TMVAClassification : Using input file: "" << input->GetName() << std::endl;; ; // Register the training and test trees; ; TTree *signalTree = (TTree*)input->Get(""TreeS"");; TTree *background = (TTree*)input->Get(""TreeB"");; ; // Create a ROOT output file where TMVA will store ntuples, histograms, etc.; TString outfileName(""TMVAC.root"");; std::unique_ptr<TFile> outputFile{TFile::Open(outfileName, ""RECREATE"")};; if (!outputFile || outputFile->IsZombie()) {; throw std::runtime_error(""ERROR: could not open output file"");; }; ; // Create the factory object. Later you can choose the methods; // whose performance you'd like to investigate. The factory is; // the only TMVA object you",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:85038,cache,cache,85038,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['cache'],['cache']
Performance,"st * fListDefinition TDirectory.h:142; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TFileCacheReadA cache when reading files over the network.Definition TFileCacheRead.h:22; TFileCacheRead::ReadBuffervirtual Int_t ReadBuffer(char *buf, Long64_t pos, Int_t len)Read buffer at position pos.Definition TFileCacheRead.cxx:364; TFileCacheRead::Closevirtual void Close(Option_t *option="""")Close out any threads or asynchronous fetches used by the underlying implementation.Definition TFileCacheRead.cxx:189; TFileCacheRead::GetBufferSizevirtual Int_t GetBufferSize() constDefinition TFileCacheRead.h:88; TFileCacheRead::GetFileTFile * GetFile() constDefinition TFileCacheRead.h:92; TFileCacheRead::SetFilevirtual void SetFile(TFile *file, TFile::ECacheAction action=TFile::kDisconnect)Set the file using this cache and reset the current blocks (if any).Definition TFileCacheRead.cxx:545; TFileCacheWriteA cache when writing files over the network.Definition TFileCacheWrite.h:19; TFileCacheWrite::Flushvirtual Bool_t Flush()Flush the current write buffer to the file.Definition TFileCacheWrite.cxx:79; TFileCacheWrite::ReadBuffervirtual Int_t ReadBuffer(char *buf, Long64_t pos, Int_t len)Called by the read cache to check if the requested data is not in the write cache buffer.Definition TFileCacheWrite.cxx:108; TFileCacheWrite::GetBytesInCachevirtual Int_t GetBytesInCache() constDefinition TFileCacheWrite.h:38; TFileCacheWrite::WriteBuffervirtual Int_t WriteBuffer(const char *buf, Long64_t pos, Int_t len)Write buffer at position pos in the write buffer.Definition TFileCacheWrite.cxx:121; TFileOpenHandleClass holding info about the file being opened.Definition TFile.h:354; TFileOpenHandle::fFileTFile * fFileTFile instance of the file being opened.Definition TFile.h:362; TFileOpenHandle::GetNetOptInt_t GetNetOpt() constDefinition TFile.h:381; TFileOpenHandle::GetFileTFile * GetFile() constDefinition T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:208940,cache,cache,208940,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"st * h1analysisTreeReader::GetOutputList ; (; ); const. inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 73 of file h1analysisTreeReader.h. ◆ Init(). void h1analysisTreeReader::Init ; (; TTree * ; myTree). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 67 of file h1analysisTreeReader.h. ◆ IsA(). TClass * h1analysisTreeReader::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 77 of file h1analysisTreeReader.h. ◆ Notify(). Bool_t h1analysisTreeReader::Notify ; (; ). overridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject. ◆ Process(). Bool_t h1analysisTreeReader::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classh1analysisTreeReader.html:15667,load,load,15667,doc/master/classh1analysisTreeReader.html,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html,2,['load'],['load']
Performance,"st = nullptr;; 2807 return;; 2808 }; 2809 fEntryList = elist;; 2810 TList *elists = elist->GetLists();; 2811 bool shift = false;; 2812 TIter next(elists);; 2813 ; 2814 //check, if there are sub-lists in the entry list, that don't; 2815 //correspond to any trees in the chain; 2816 while((templist = (TEntryList*)next())){; 2817 if (templist->GetTreeNumber() < 0){; 2818 shift = true;; 2819 break;; 2820 }; 2821 }; 2822 fEntryList->SetShift(shift);; 2823 ; 2824}; 2825 ; 2826////////////////////////////////////////////////////////////////////////////////; 2827/// Set the input entry list (processing the entries of the chain will then be; 2828/// limited to the entries in the list). This function creates a special kind; 2829/// of entry list (TEntryListFromFile object) that loads lists, corresponding; 2830/// to the chain elements, one by one, so that only one list is in memory at a time.; 2831///; 2832/// If there is an error opening one of the files, this file is skipped and the; 2833/// next file is loaded; 2834///; 2835/// File naming convention:; 2836///; 2837/// - by default, filename_elist.root is used, where filename is the; 2838/// name of the chain element; 2839/// - xxx$xxx.root - $ sign is replaced by the name of the chain element; 2840///; 2841/// If the list name is not specified (by passing filename_elist.root/listname to; 2842/// the TChain::SetEntryList() function, the first object of class TEntryList; 2843/// in the file is taken.; 2844///; 2845/// It is assumed, that there are as many list files, as there are elements in; 2846/// the chain and they are in the same order; 2847 ; 2848void TChain::SetEntryListFile(const char *filename, Option_t * /*opt*/); 2849{; 2850 ; 2851 if (fEntryList){; 2852 //check, if the chain is the owner of the previous entry list; 2853 //(it happens, if the previous entry list was created from a user-defined; 2854 //TEventList in SetEventList() function); 2855 if (fEntryList->TestBit(kCanDelete)) {; 2856 TEntryList *tmp = fEntryL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:102661,load,loaded,102661,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['load'],['loaded']
Performance,"st > createEmptyResidHist (const RooCurve &curve, bool normalize=false) const;  ; void fillResidHist (RooHist &residHist, const RooCurve &curve, bool normalize=false, bool useAverage=false) const;  ; void initialize ();  Perform common initialization for all constructors. ;  ; Int_t roundBin (double y);  Return the nearest positive integer to the input value and print a warning if an adjustment is required. ;  ;  Protected Member Functions inherited from TGraphAsymmErrors; Double_t ** Allocate (Int_t size) override;  Allocate internal data structures for size points. ;  ; void CopyAndRelease (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy and release. ;  ; Bool_t CopyPoints (Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy errors from fE*** to arrays[***] or to f*** Copy points. ;  ; Bool_t CtorAllocate ();  Should be called from ctors after fNpoints has been set. ;  ; Bool_t DoMerge (const TGraph *g) override;  Protected function to perform the merge operation of a graph with asymmetric errors. ;  ; void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) override;  Set zero values for point arrays in the range [begin, end] ;  ; void SwapPoints (Int_t pos1, Int_t pos2) override;  Swap points. ;  ; void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void Sa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHist.html:37890,perform,perform,37890,doc/master/classRooHist.html,https://root.cern,https://root.cern/doc/master/classRooHist.html,1,['perform'],['perform']
Performance,"st RooAbsArg &other) const override;  Equality operator when comparing to another RooAbsArg. ;  ; bool operator== (double value) const;  Equality operator comparing to a double. ;  ; virtual RooPlot * plotSliceOn (RooPlot *frame, const RooArgSet &sliceSet, Option_t *drawOptions=""L"", double scaleFactor=1.0, ScaleType stype=Relative, const RooAbsData *projData=nullptr) const;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the special",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:30468,cache,cache,30468,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['cache'],['cache']
Performance,"st RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; value_type _defCat {NoCatIdx};  Default (unmapped) output type. ;  ; RooCategoryProxy _inputCat;  Input category. ;  ; std::map< std::string, RooMappedCategory::Entry > _mapArray;  List of mapping rules. ;  ; std::unique_ptr< RooMappedCategoryCache > _mapcache;  ! transient member: cache the mapping ;  ;  Protected Attributes inherited from RooAbsCategory; value_type _currentIndex {std::numeric_limits<int>::min()};  Current category state. ;  ; std::vector< std::string > _insertionOrder;  Keeps track in which order state numbers have been inserted. Make sure this is updated in recomputeShape(). ;  ; std::map< value_type, std::unique_ptr< RooCatType, std::function< void(RooCatType *)> > > _legacyStates;  ! Map holding pointers to RooCatType instances. Only for legacy interface. Don't use if possible. ;  ; std::map< std::string, value_type > _stateNames;  Map state names to index numbers. Make sure state names are updated in recomputeShape(). ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which wor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMappedCategory.html:40291,cache,cache,40291,doc/master/classRooMappedCategory.html,https://root.cern,https://root.cern/doc/master/classRooMappedCategory.html,1,['cache'],['cache']
Performance,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); RooAbsReal&pdf() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvolution.html:21787,optimiz,optimizeCacheMode,21787,root/html534/RooNumConvolution.html,https://root.cern,https://root.cern/root/html534/RooNumConvolution.html,1,['optimiz'],['optimizeCacheMode']
Performance,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); RooArgSetparameters() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChangeTracker.html:20042,optimiz,optimizeCacheMode,20042,root/html534/RooChangeTracker.html,https://root.cern,https://root.cern/root/html534/RooChangeTracker.html,1,['optimiz'],['optimizeCacheMode']
Performance,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:19969,optimiz,optimizeCacheMode,19969,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,3,['optimiz'],['optimizeCacheMode']
Performance,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo1DMomentMorphFunction.html:19573,optimiz,optimizeCacheMode,19573,root/html534/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html534/Roo1DMomentMorphFunction.html,50,['optimiz'],['optimizeCacheMode']
Performance,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistFunc.html:19714,optimiz,optimizeCacheMode,19714,root/html534/RooHistFunc.html,https://root.cern,https://root.cern/root/html534/RooHistFunc.html,3,['optimiz'],['optimizeCacheMode']
Performance,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddition.html:19790,optimiz,optimizeCacheMode,19790,root/html534/RooAddition.html,https://root.cern,https://root.cern/root/html534/RooAddition.html,2,['optimiz'],['optimizeCacheMode']
Performance,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_tRooAbsMoment::order() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFirstMoment.html:19700,optimiz,optimizeCacheMode,19700,root/html534/RooFirstMoment.html,https://root.cern,https://root.cern/root/html534/RooFirstMoment.html,3,['optimiz'],['optimizeCacheMode']
Performance,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsMoment.html:19454,optimiz,optimizeCacheMode,19454,root/html534/RooAbsMoment.html,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html,2,['optimiz'],['optimizeCacheMode']
Performance,"st RooArgSet& compSet, const RooArgSet& intSet, RooArgSet& saveSet, const char* isetRangeName); voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidoperModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenProdProj.html:27363,optimiz,optimizeDirtyHook,27363,root/html526/RooGenProdProj.html,https://root.cern,https://root.cern/root/html526/RooGenProdProj.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"st RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidreset(); Int_tsetObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp); voidsterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_t_lastIndexLast slot accessed; Int_t_maxSizeMaximum size; RooNormSetCache*_nsetCache! Normalization/Integration set manager; RooAbsCacheElement**_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCacheManager_RooAbsCacheElement_.html:3303,cache,cache,3303,root/html528/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html528/RooCacheManager_RooAbsCacheElement_.html,1,['cache'],['cache']
Performance,"st RooArgSet* normSet = 0); virtual~RooDataProjBinding(); virtual list<Double_t>*RooRealBinding::binBoundaries(Int_t) const; static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tRooRealBinding::getMaxLimit(UInt_t dimension) const; virtual Double_tRooRealBinding::getMinLimit(UInt_t dimension) const; virtual const char*RooRealBinding::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&RooAbsFunc::operator=(const RooAbsFunc&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidRooRealBinding::loadValues(const Double_t* xvector) const. Data Members; protected:. Roo1DTable*_catTableSupercategory table generated from _data; Bool_tRooRealBinding::_clipInvalid; list<RooAbsReal*>RooRealBinding::_compList!; list<Double_t>RooRealBinding::_compSave!; const RooAbsData*_dataDataset used for projection; UInt_tRooAbsFunc::_dimensionNumber of observables; Bool_t_firstBit indicating if operator() has been called yet; const RooAbsReal*RooRealBinding::_func; Double_tRooRealBinding::_funcSave!; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*_nsetNormalization set for real function; const RooArgSet*RooRealBinding::_nset; const TNamed*RooRealBinding::_rangeName!; const RooAbsReal*_realReal function to be projected; RooSuperCategory*_superCatSupercategory constructed from _data's category variables; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**RooRealBinding::_vars; Double_t*RooRealBinding::_xsave; Bool_tRooRealBinding::_xvecValid. Class Charts. Inheritance; Inherit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataProjBinding.html:1929,load,loadValues,1929,root/html534/RooDataProjBinding.html,https://root.cern,https://root.cern/root/html534/RooDataProjBinding.html,1,['load'],['loadValues']
Performance,"st T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; UInt_t GetImplicitMTPoolSize ();  Returns the size of the pool used for implicit multi-threading. More...;  ; TString & GetMacroPath ();  ; TROOT * GetROOT ();  ; void GetRuleIncludes (std::list< std::string > &result);  Get the list of includes specified in the shema rules. More...;  ; UInt_t GetThreadPoolSize ();  Returns the size of ROOT's thread pool. More...;  ; bool HasValidDataMembers (SchemaRuleMap_t &rule, MembersTypeMap_t &members, std::string &error_string);  Check if given rule contains references to valid data members. More...;  ; Bool_t IsImplicitMTEnabled ();  Returns true if the implicit multi-threading in ROOT is enabled. More...;  ; template<class T > ; TSeq< T > MakeSeq (T begin, T end, T step=1);  ; template<class T > ; TSeq< T > MakeSeq (T end);  ; bool ParseRule (std::string command, ROOT::Internal::MembersMap_t &result, std::string &error_string);  Parse the schema rule as specified in the LinkDef file. More...;  ; void ProcessReadPragma (const char *args, std::string &error_string);  I am being called when a read pragma is encountered. More...;  ; void ProcessReadRawPragma (const char *args, std::string &error_string);  I am being called then a readraw pragma is encountered. More...;  ; TNamed * RegisterClassTemplate (const char *name, const char *file, Int_t line);  Global function to register the implementation file and line of a class template (i.e. More...;  ; void RemoveClass (const char *cname);  Global function called by the dtor of a class's init class (see the ClassImp macro). More...;  ; void ResetClassVersion (TClass *, const char *, S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:9281,multi-thread,multi-threading,9281,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"st TGenCollectionProxy& c) : TGenVectorProxy(c); 236 {; 237 }; 238 // Standard Destructor; 239 ~TGenSetProxy() override; 240 {; 241 }; 242 // Return the address of the value at index 'idx'; 243 void* At(UInt_t idx) override; 244 {; 245 if ( fEnv && fEnv->fObject ) {; 246 if ( fEnv->fUseTemp ) {; 247 return (((char*)fEnv->fTemp)+idx*fValDiff);; 248 }; 249 switch( idx ) {; 250 case 0:; 251 fEnv->fIdx = idx;; 252 return fEnv->fStart = fFirst.invoke(fEnv);; 253 default: {; 254 fEnv->fIdx = idx - fEnv->fIdx;; 255 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 256 void* result = fNext.invoke(fEnv);; 257 fEnv->fIdx = idx;; 258 return result;; 259 }; 260 }; 261 }; 262 Fatal(""TGenSetProxy"",""At> Logic error - no proxy object set."");; 263 return nullptr;; 264 }; 265};; 266 ; 267/**; 268\class TGenMapProxy; 269\ingroup IO; 270Localoptimization class.; 271 ; 272Collection proxies get copied. On copy we switch the type of the; 273proxy to the concrete STL type. The concrete types are optimized; 274for element access.; 275*/; 276 ; 277class TGenMapProxy : public TGenSetProxy {; 278public:; 279 // Standard Destructor; 280 TGenMapProxy(const TGenCollectionProxy& c) : TGenSetProxy(c); 281 {; 282 }; 283 // Standard Destructor; 284 ~TGenMapProxy() override; 285 {; 286 }; 287 // Call to delete/destruct individual item; 288 void DeleteItem(Bool_t force, void* ptr) const override; 289 {; 290 if (force) {; 291 if ( fKey->fProperties&kNeedDelete) {; 292 TVirtualCollectionProxy *proxy = fKey->fType->GetCollectionProxy();; 293 TPushPop helper(proxy,fKey->fCase&kIsPointer ? *(void**)ptr : ptr);; 294 proxy->Clear(""force"");; 295 }; 296 if ( fVal->fProperties&kNeedDelete) {; 297 TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionProxy();; 298 char *addr = ((char*)ptr)+fValOffset;; 299 TPushPop helper(proxy,fVal->fCase&kIsPointer ? *(void**)addr : addr);; 300 proxy->Clear(""force"");; 301 }; 302 }; 303 if ( fKey->fCase&kIsPointer ) {; 304 fKey->DeleteItem(*(void**)ptr);; 305 }; 306",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:7684,optimiz,optimized,7684,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"st TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from RooAbsCategory; using value_type = int;  The type used to denote a specific category state. ;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSing",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinningCategory.html:42153,Cache,CacheMode,42153,doc/master/classRooBinningCategory.html,https://root.cern,https://root.cern/doc/master/classRooBinningCategory.html,2,['Cache'],['CacheMode']
Performance,"st TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tTClass::GetCheckSum(Bool_t& isvalid) const; UInt_tTClass::GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tTClass::GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() const; TMethod*TClass::GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*TClass::GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tTClass::GetClassSize() const; Version_tTClass::GetClassVersion() const; TVirtualCollectionProxy*TClass::GetCollectionProxy() const; ROOT::ESTLTypeTClass::GetCollectionType() const; const char*TClass::GetContextMenuTitle() const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tTClass::GetConvStreamerFunc() const; TVirtualStreamerInfo*TClass::GetCurrentStreamerInfo()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TQClass.html:7609,load,load,7609,root/html604/TQClass.html,https://root.cern,https://root.cern/root/html604/TQClass.html,1,['load'],['load']
Performance,"st TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tTClass::GetCheckSum(Bool_t& isvalid) const; UInt_tTClass::GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tTClass::GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() const; TMethod*TClass::GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*TClass::GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tTClass::GetClassSize() const; Version_tTClass::GetClassVersion() const; TVirtualCollectionProxy*TClass::GetCollectionProxy() const; const char*TClass::GetContextMenuTitle() const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tTClass::GetConvStreamerFunc() const; TVirtualStreamerInfo*TClass::GetCurrentStreamerInfo(); TDataMember*TClass::GetDataMember(const char* d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQClass.html:7609,load,load,7609,root/html602/TQClass.html,https://root.cern,https://root.cern/root/html602/TQClass.html,1,['load'],['load']
Performance,"st TString & THtml::GetMacroPath ; (; ); const. inline . Definition at line 302 of file THtml.h. ◆ GetMakeClassMutex(). TVirtualMutex * THtml::GetMakeClassMutex ; (; ); const. inline . Definition at line 343 of file THtml.h. ◆ GetModuleDefinition(). const THtml::TModuleDefinition & THtml::GetModuleDefinition ; (; ); const. Return the TModuleDefinition (or derived) object as set by SetModuleDefinition(); create and return a TModuleDefinition object if none was set. ; Definition at line 1311 of file THtml.cxx. ◆ GetModuleDocPath(). const TString & THtml::GetModuleDocPath ; (; ); const. inline . Definition at line 298 of file THtml.h. ◆ GetModuleMacroPath(). void THtml::GetModuleMacroPath ; (; const TString & ; module, . TString & ; out_path . ); const. inline . Definition at line 324 of file THtml.h. ◆ GetModuleNameForClass(). void THtml::GetModuleNameForClass ; (; TString & ; module, . TClass * ; cl . ); const. virtual . Return the module name for a given class. ; Use the cached information from fDocEntityInfo.fClasses. ; Definition at line 1540 of file THtml.cxx. ◆ GetNextClass(). TClassDocInfo * THtml::GetNextClass ; (; ). protected . Return the next class to be generated for MakeClassThreaded. ; Definition at line 1369 of file THtml.cxx. ◆ GetOutputDir(). const TString & THtml::GetOutputDir ; (; Bool_t ; createDir = kTRUE); const. Return the output directory as set by SetOutputDir(). ; Create it if it doesn't exist and if createDir is kTRUE. ; Definition at line 2177 of file THtml.cxx. ◆ GetPathDefinition(). const THtml::TPathDefinition & THtml::GetPathDefinition ; (; ); const. Return the TModuleDefinition (or derived) object as set by SetModuleDefinition(); create and return a TModuleDefinition object if none was set. ; Definition at line 1339 of file THtml.cxx. ◆ GetPathInfo(). const PathInfo_t & THtml::GetPathInfo ; (; ); const. inline . Definition at line 345 of file THtml.h. ◆ GetProductName(). const TString & THtml::GetProductName ; (; ); const. inline . Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHtml.html:45841,cache,cached,45841,doc/master/classTHtml.html,https://root.cern,https://root.cern/doc/master/classTHtml.html,2,['cache'],['cached']
Performance,"st TString &containerName);  Constructor. ;  ; void AddDescriptor (TBranchProxyDescriptor *desc, bool isBase);  Add a descriptor to this proxy. ;  ; const char * GetBranchName () const;  Get the branch name. ;  ; TString GetContainerName () const;  Return the name of the container holding this class, if any. ;  ; TVirtualStreamerInfo * GetInfo () const;  ; ELocation GetIsClones () const;  Return whether the branch is inside, nested in or outside of a TClonesArray. ;  ; const char * GetRawSymbol () const;  Get the real symbol name. ;  ; UInt_t GetSplitLevel () const;  Return the split level of the branch. ;  ; const char * GetSubBranchPrefix () const;  Get the prefix from the branch name. ;  ; TClass * IsA () const override;  ; bool IsClones () const;  Return true if this proxy is for a TClonesArray. ;  ; virtual bool IsEquivalent (const TBranchProxyClassDescriptor *other);  Return true if this description is the 'same' as the other decription. ;  ; bool IsLoaded () const;  Return true if the class needed by the branch is loaded. ;  ; bool IsSTL () const;  Return true if this proxy is for a TClonesArray. ;  ; void OutputDecl (FILE *hf, int offset, UInt_t);  Output the declaration and implementation of this emulation class. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1TBranchProxyClassDescriptor.html:2724,load,loaded,2724,doc/master/classROOT_1_1Internal_1_1TBranchProxyClassDescriptor.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1TBranchProxyClassDescriptor.html,1,['load'],['loaded']
Performance,"st TVectorD& rho, TString options = ""a"", Double_t nSigma = 3, Bool_t rotate = kTRUE); Constructor. RooNDKeysPdf(const char* name, const char* title, RooAbsReal& x, RooDataSet& data, RooNDKeysPdf::Mirror mirror = NoMirror, Double_t rho = 1, Double_t nSigma = 3, Bool_t rotate = kTRUE); Backward compatibility constructor for (1-dim) RooKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const char* name, const char* title, RooAbsReal& x, RooAbsReal& y, RooDataSet& data, TString options = ""a"", Double_t rho = 1., Double_t nSigma = 3, Bool_t rotate = kTRUE); Backward compatibility constructor for Roo2DKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const RooNDKeysPdf& other, const char* name = 0); Constructor. ~RooNDKeysPdf(). createPdf(Bool_t firstCall = kTRUE) const; evaluation order of constructor. setOptions() const; set the configuration. initialize() const; initialization. loadDataSet(Bool_t firstCall) const; copy the dataset and calculate some useful variables. mirrorDataSet() const; determine mirror dataset.; mirror points are added around the physical boundaries of the dataset; Two steps:; 1. For each entry, determine if it should be mirrored (the mirror configuration).; 2. For each mirror configuration, make the mirror points. loadWeightSet() const. calculateShell(RooNDKeysPdf::BoxInfo* bi) const; determine points in +/- nSigma shell around the box determined by the variable; ranges. These points are needed in the normalization, to determine probability; leakage in and out of the box. calculatePreNorm(RooNDKeysPdf::BoxInfo* bi) const; bi->nEventsBMSW=0.;; bi->nEventsBW=0.;. sortDataIndices(RooNDKeysPdf::BoxInfo* bi = 0) const; sort entries, as needed for loopRange(). calculateBandWidth() const. gauss(vector<Double_t>& x, vector<vector<Double_t> >& weights) const; loop over all closest point to x, as determined by loopRange(). loopRange(vector<Double_t>& x, map<Int_t,Bool_t>& ibMap) const; deter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNDKeysPdf.html:50853,load,loadDataSet,50853,root/html602/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html602/RooNDKeysPdf.html,2,['load'],['loadDataSet']
Performance,"st away, fCache should be mutable; 340 } else {; 341 Int_t idx;; 342 t = FindLink(obj, idx);; 343 if (t) ((TList*)this)->fCache = t->fNext;; 344 }; 345 ; 346 if (t && t->Next()); 347 return t->Next()->GetObject();; 348 else; 349 return nullptr;; 350}; 351 ; 352////////////////////////////////////////////////////////////////////////////////; 353/// Returns the object at position idx. Returns 0 if idx is out of range.; 354 ; 355TObject *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// Returns the object before object obj. Obj is found using the; 367/// object's IsEqual() method. Returns 0 if obj is first in list.; 368 ; 369TObject *TList::Before(const TObject *obj) const; 370{; 371 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 372 R__COLLECTION_WRITE_GUARD();; 373 ; 374 TObjLink *t;; 375 ; 376 auto cached = fCache.lock();; 377 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 378 t = cached.get();; 379 ((TList*)this)->fCache = cached->fPrev; //cast const away, fCache should be mutable; 380 } else {; 381 Int_t idx;; 382 t = FindLink(obj, idx);; 383 if (t) ((TList*)this)->fCache = t->fPrev;; 384 }; 385 ; 386 if (t && t->Prev()); 387 return t->Prev()->GetObject();; 388 else; 389 return nullptr;; 390}; 391 ; 392////////////////////////////////////////////////////////////////////////////////; 393/// Remove all objects from the list. Does not delete the objects; 394/// unless the TList is the owner (set via SetOwner()) and option; 395/// ""nodelete"" is not set.; 396/// If option=""nodelete"" then don't delete any heap objects that were; 397/// marked with the kCanDelete bit, otherwise these objects will be; 398/// deleted (this option is used by THashTable::Clear()).; 39",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:10952,cache,cached,10952,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,1,['cache'],['cached']
Performance,"st char * GetSoExt() const; Get the shared library extension. const char * GetObjExt() const; Get the object file extension. void SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); Set the location where ACLiC will create libraries and use as; a scratch area.; If isflast is flase, then the libraries are actually stored in; sub-directories of 'build_dir' including the full pathname of the; script. If the script is location at /full/path/name/macro.C; the library will be located at 'build_dir+/full/path/name/macro_C.so'; If 'isflat' is true, then no subdirectory is created and the library; is created directly in the directory 'build_dir'. Note that in this; mode there is a risk than 2 script of the same in different source; directory will over-write each other. void SetFlagsDebug(const char* ); FlagsDebug should contain the options to pass to the C++ compiler; in order to compile the library in debug mode. void SetFlagsOpt(const char* ); FlagsOpt should contain the options to pass to the C++ compiler; in order to compile the library in optimized mode. void SetAclicMode(TSystem::EAclicMode mode); AclicMode indicates whether the library should be built in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell comm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:44582,optimiz,optimized,44582,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,6,['optimiz'],['optimized']
Performance,"st char * TProofProgressLog::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 93 of file TProofProgressLog.h. ◆ DoLog(). void TProofProgressLog::DoLog ; (; Bool_t ; grep = kFALSE). Display logs. ; 'grep' is set to kTRUE if it is invoked by pressing the 'Filter' button. ; Definition at line 388 of file TProofProgressLog.cxx. ◆ Init(). void TProofProgressLog::Init ; (; Int_t ; w = 700, . Int_t ; h = 600 . ). private . Init window frame for log messages. ; Definition at line 70 of file TProofProgressLog.cxx. ◆ IsA(). TClass * TProofProgressLog::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGTransientFrame.; Definition at line 93 of file TProofProgressLog.h. ◆ LoadBuffer(). void TProofProgressLog::LoadBuffer ; (; const char * ; buffer). Load a text buffer in the window. ; Definition at line 280 of file TProofProgressLog.cxx. ◆ LoadFile(). void TProofProgressLog::LoadFile ; (; const char * ; file). Load a file in the window. ; Definition at line 289 of file TProofProgressLog.cxx. ◆ LogMessage(). void TProofProgressLog::LogMessage ; (; const char * ; msg, . Bool_t ; all . ). Load/append a log msg in the log frame, if open. ; Definition at line 519 of file TProofProgressLog.cxx. ◆ NoLineEntry(). void TProofProgressLog::NoLineEntry ; (; ). Enable/disable the line number entry. ; Definition at line 599 of file TProofProgressLog.cxx. ◆ Popup(). void TProofProgressLog::Popup ; (; ). Show log window. ; Definition at line 263 of file TProofProgressLog.cxx. ◆ Rebuild(). void TProofProgressLog::Rebuild ; (; ). Rebuild the log info for a new entered session. ; Definition at line 635 of file TProofProgressLog.cxx. ◆ SaveToFile(). void TProofProgressLog::SaveToFile ; (; ). Save the logs to a file Only the name of the file is taken, no expansion. ; Definition at line 534 of file TProofProgressLog.cxx. ◆ Select(). void TProofProgressLog::Select ; (; Int_t ; id, . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofProgressLog.html:41244,Load,LoadFile,41244,doc/master/classTProofProgressLog.html,https://root.cern,https://root.cern/doc/master/classTProofProgressLog.html,1,['Load'],['LoadFile']
Performance,"st char *ctor, const char *origin);  Create a plugin handler. Called by TPluginManager. ;  ;  TPluginHandler (const TPluginHandler &)=delete;  ;  ~TPluginHandler ();  Cleanup plugin handler object. ;  ; Bool_t CanHandle (const char *base, const char *uri);  Check if regular expression appears in the URI, if so return kTRUE. ;  ; template<typename T0 > ; bool CheckExactMatch (int iarg, const T0 &);  ; template<typename T0 , typename... T> ; bool CheckExactMatch (int iarg, const T0 &, const T &... params);  ; Bool_t CheckForExecPlugin (Int_t nargs);  Check that we can properly run ExecPlugin. ;  ; bool CheckNameMatch (int iarg, const std::type_info &ti);  Return true if the name of the iarg-th argument's type match type_name ;  ; template<typename... T> ; bool ExactArgMatch (const T &... params);  ; template<typename... T> ; Longptr_t ExecPluginImpl (const T &... params);  ; const char * GetBase () const;  ; const char * GetCtor () const;  ; const char * GetOrigin () const;  ; const char * GetPlugin () const;  ; const char * GetRegexp () const;  ; void LoadPluginImpl ();  Load the plugin library for this handler. ;  ; TPluginHandler & operator= (const TPluginHandler &)=delete;  ; void SetupCallEnv ();  Setup ctor or static method call environment. ;  . Private Attributes; std::vector< std::string > fArgTupleTypeInfo;  ctor method or global function ;  ; TString fBase;  ; TMethodCall * fCallEnv;  ; AtomicInt_t fCanCall;  ; TString fClass;  ; TString fCtor;  ; Bool_t fIsGlobal;  ; Bool_t fIsMacro;  if 1 fCallEnv is ok, -1 fCallEnv is not ok, 0 fCallEnv not setup yet. ;  ; Int_t fLoadStatus;  ; std::once_flag fLoadStatusFlag;  ; TFunction * fMethod;  ctor method call environment ;  ; TString fOrigin;  ; TString fPlugin;  ; TString fRegexp;  . Friends; class TPluginManager;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPluginHandler.html:10439,Load,LoadPluginImpl,10439,doc/master/classTPluginHandler.html,https://root.cern,https://root.cern/doc/master/classTPluginHandler.html,2,['Load'],"['Load', 'LoadPluginImpl']"
Performance,"st char *name, const char *title, const RooArgSet &obs);  Create an empty dataset to hold the events that will be generated. ;  ; void resampleData (double &ratio);  Rescale existing output buffer with given ratio. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; bool _expectedData;  Asimov? ;  ; std::unique_ptr< RooDataHist > _hist;  Histogram. ;  ; RooAbsPdf * _pdf;  Pointer to cloned p.d.f. ;  ; RooArgSet _pdfSet;  Set owned all nodes of internal clone of p.d.f. ;  ; std::unique_ptr< RooArgSet > _vars;  ;  Protected Attributes inherited from RooAbsGenContext; UInt_t _expectedEvents;  Number of expected events from extended p.d.f. ;  ; RooAbsPdf::ExtendMode _extendMode;  Extended mode capabilities of p.d.f. ;  ; RooDataSet * _genData = nullptr;  ! Data being generated ;  ; bool _isValid;  Is context in valid state? ;  ; Int_t _nextProtoIndex;  Next prototype event to load according to LUT. ;  ; TString _normRange;  Normalization range of pdf. ;  ; std::vector< Int_t > _protoOrder;  LUT with traversal order of prototype data. ;  ; const RooDataSet * _prototype;  Pointer to prototype dataset. ;  ; RooArgSet _protoVars;  Prototype observables. ;  ; RooArgSet _theEvent;  Pointer to observable event being generated. ;  ; bool _verbose;  Verbose messaging? ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 ))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinnedGenContext.html:15190,load,load,15190,doc/master/classRooBinnedGenContext.html,https://root.cern,https://root.cern/doc/master/classRooBinnedGenContext.html,1,['load'],['load']
Performance,"st char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static void AutoBinFunc (TString &key, Double_t &xmin, Double_t &xmax, Double_t &ymin, Double_t &ymax, Double_t &zmin, Double_t &zmax);  Get bining information. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from THLimitsFinder; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static THLimitsFinder * GetLimitsFinder ();  Return pointer to the current finder. ;  ; static void Optimize (Double_t A1, Double_t A2, Int_t nold, Double_t &BinLow, Double_t &BinHigh, Int_t &nbins, Double_t &BWID, Option_t *option="""");  Static function to compute reasonable axis limits. ;  ; static void OptimizeLimits (Int_t nbins, Int_t &newbins, Double_t &xmin, Double_t &xmax, Bool_t isInteger);  Optimize axis limits. ;  ; static void SetLimitsFinder (THLimitsFinder *finder);  This static function can be used to specify a finder derived from THLimitsFinder. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLimitsFinder.html:9431,Optimiz,Optimize,9431,doc/master/classTProofLimitsFinder.html,https://root.cern,https://root.cern/doc/master/classTProofLimitsFinder.html,1,['Optimiz'],['Optimize']
Performance,"st char *option=nullptr, Int_t maxUnrolling=3)Generate a skeleton analysis class for this Tree using TBranchProxy.Definition TTree.cxx:6768; TTree::kSplitCollectionOfPointers@ kSplitCollectionOfPointersDefinition TTree.h:266; TTree::ReadStreamvirtual Long64_t ReadStream(std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ')Create or simply read branches from an input stream.Definition TTree.cxx:7615; TTree::SetDebugvirtual void SetDebug(Int_t level=1, Long64_t min=0, Long64_t max=9999999)Set the debug level and the debug range.Definition TTree.cxx:8928; TTree::fScanFieldInt_t fScanFieldNumber of runs before prompting in Scan.Definition TTree.h:92; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTree::GetFriendvirtual TTree * GetFriend(const char *) constReturn a pointer to the TTree friend whose name or alias is friendname.Definition TTree.cxx:5975; TTree::SetNotifyvirtual void SetNotify(TObject *obj)Sets the address of the object to be notified when the tree is loaded.Definition TTree.cxx:9231; TTree::GetMaximumvirtual Double_t GetMaximum(const char *columname)Return maximum of column with name columname.Definition TTree.cxx:6235; TTree::GetEntryNumberWithBestIndexvirtual Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor=0) constReturn entry number corresponding to major and minor number.Definition TTree.cxx:5890; TTree::SetMaxTreeSizestatic void SetMaxTreeSize(Long64_t maxsize=100000000000LL)Set the maximum size in bytes of a Tree file (static function).Definition TTree.cxx:9197; TTree::Printvoid Print(Option_t *option="""") const overridePrint a summary of the tree contents.Definition TTree.cxx:7219; TTree::UnbinnedFitvirtual Int_t UnbinnedFit(const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Unbinned fit of one or more variable(s) from a tree.Definition TTree.cxx:9702; TTree:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:442348,load,loaded,442348,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['load'],['loaded']
Performance,"st char *signal, const char *receiver_class, void *receiver, const char *slot);  This method allows to make a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions;  TProofLite ();  ; Int_t CopyMacroToCache (const char *macro, Int_t headerRequired=0, TSelector **selector=0, Int_t opt=0, TList *wrks=0);  Copy a macro, and its possible associated .h[h] file, to the cache directory, from where the workers can get the file. ;  ; Int_t Init (const char *masterurl, const char *conffile, const char *confdir, Int_t loglevel, const char *alias=0);  Start the PROOF environment. ;  ; TProofQueryResult * MakeQueryResult (Long64_t nent, const char *opt, Long64_t fst, TDSet *dset, const char *selec);  Create a TProofQueryResult instance for this query. ;  ; Int_t PollForNewWorkers () override;  Simulate dynamic addition, for test purposes. ;  ; void SetQueryRunning (TProofQueryResult *pq);  Set query in running state. ;  ; Int_t SetupWorkers (Int_t opt=0, TList *wrks=0);  Start up PROOF workers. ;  ;  Protected Member Functions inherited from TProof;  TProof ();  Protected constructor to be used by classes deriving from TProof (they have to call Init themselves and override StartSlaves appropriately). ;  ; Int_t AddWorkers (TList *wrks);  Works on the master node only. ;  ; Int_t AssertPath (const char *path, Bool_t writable);  Make sure that 'path' exists; if 'writable' is kTR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:35314,cache,cache,35314,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['cache'],['cache']
Performance,"st char * ; newName = nullptr, . const char * ; newTitle = nullptr, . const RooArgSet * ; vars = nullptr, . const char * ; = nullptr . ); const. inlineoverridevirtual . Return empty clone of this RooDataHist. ; Implements RooAbsData.; Definition at line 67 of file RooDataHist.h. ◆ get() [1/3]. const RooArgSet * RooDataHist::get ; (; ); const. inlineoverridevirtual . Get bin centre of current bin. ; Reimplemented from RooAbsData.; Definition at line 82 of file RooDataHist.h. ◆ get() [2/3]. const RooArgSet * RooDataHist::get ; (; const RooArgSet & ; coord); const. virtual . Return a RooArgSet with whose coordinates denote the bin centre of the bin enclosing the point in coord. ; NoteThe argset is owned by this data hist, and this function has a side effect, because it alters the currently active bin. ; Definition at line 2194 of file RooDataHist.cxx. ◆ get() [3/3]. const RooArgSet * RooDataHist::get ; (; Int_t ; binNumber); const. overridevirtual . Load bin binNumber, and return an argset with the coordinates of the bin centre. ; NoteThe argset is owned by this data hist, and this function has a side effect, because it alters the currently active bin. ; Reimplemented from RooAbsData.; Definition at line 2179 of file RooDataHist.cxx. ◆ getBinnings(). std::vector< std::unique_ptr< const RooAbsBinning > > const & RooDataHist::getBinnings ; (; ); const. inline . Definition at line 213 of file RooDataHist.h. ◆ getIndex() [1/2]. Int_t RooDataHist::getIndex ; (; const RooAbsCollection & ; coord, . bool ; fast = false . ); const. Calculate bin number of the given coordinates. ; If only a subset of the internal coordinates are passed, the missing coordinates are taken at their current value. Parameters. [in]coordVariables that are representing the coordinates. ; [in]fastIf the variables in coord and the ones of the data hist have the same size and layout, fast can be set to skip checking that all variables are present in coord. . Definition at line 990 of file RooDataHist.cxx. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:58293,Load,Load,58293,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['Load'],['Load']
Performance,"st char * ; title, . int ; imin1, . int ; imax1, . int ; imin2, . int ; imax2, . const TAxis * ; projAxis, . const TAxis * ; axis1, . const TAxis * ; axis2, . Option_t * ; option . ); const. protectedvirtual . internal method performing the projection to 1D histogram called from TH3::Project3D ; Definition at line 1829 of file TH3.cxx. ◆ DoProject1D() [3/3]. TH1D * TH3::DoProject1D ; (; const TH3 & ; h, . const char * ; name, . const char * ; title, . const TAxis * ; projX, . bool ; computeErrors, . bool ; originalRange, . bool ; useUF, . bool ; useOF . ). staticprotected . static methdod performing the projection to 1D histogram ; Definition at line 3504 of file TH3.cxx. ◆ DoProject2D() [1/2]. TH2D * TH3::DoProject2D ; (; const char * ; name, . const char * ; title, . const TAxis * ; projX, . const TAxis * ; projY, . bool ; computeErrors, . bool ; originalRange, . bool ; useUF, . bool ; useOF . ); const. protectedvirtual . internal method performing the projection to a 2D histogram called from TH3::Project3D ; Definition at line 2103 of file TH3.cxx. ◆ DoProject2D() [2/2]. TH2D * TH3::DoProject2D ; (; const TH3 & ; h, . const char * ; name, . const char * ; title, . const TAxis * ; projX, . const TAxis * ; projY, . bool ; computeErrors, . bool ; originalRange, . bool ; useUF, . bool ; useOF . ). staticprotected . static methdod performing the projection to 2D histogram ; Definition at line 3513 of file TH3.cxx. ◆ DoProjectProfile2D(). TProfile2D * TH3::DoProjectProfile2D ; (; const char * ; name, . const char * ; title, . const TAxis * ; projX, . const TAxis * ; projY, . bool ; originalRange, . bool ; useUF, . bool ; useOF . ); const. protectedvirtual . internal method to project to a 2D Profile called from TH3::Project3DProfile ; Reimplemented in TProfile3D.; Definition at line 2576 of file TH3.cxx. ◆ Fill() [1/15]. Int_t TH3::Fill ; (; const char * ; , . const char * ; , . Double_t ;  . ). inlineprotected . Definition at line 63 of file TH3.h. ◆ Fill() [2/15]. In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:67778,perform,performing,67778,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,1,['perform'],['performing']
Performance,"st char * fDeclFileName;  ; ROOT::DelFunc_t fDelete;  ; ROOT::DelArrFunc_t fDeleteArray;  ; ROOT::DesFunc_t fDestructor;  ; ROOT::DirAutoAdd_t fDirAutoAdd;  ; std::atomic< TListOfEnums * > fEnums;  ; TListOfFunctionTemplates * fFuncTemplate;  ; IsAGlobalFunc_t fGlobalIsA;  pointer to the class's IsA proxy. ;  ; Bool_t fHasCustomStreamerMember: 1;  The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer. ;  ; std::atomic< Bool_t > fHasRootPcmInfo;  C++ Property of the class (is abstract, has virtual table, etc.) ;  ; Short_t fImplFileLine;  ; const char * fImplFileName;  ; UInt_t fInstanceCount;  ; TVirtualIsAProxy * fIsA;  ; std::atomic< TMethodCall * > fIsAMethod;  ; std::atomic< Bool_t > fIsOffsetStreamerSet;  Indicates whether the ClassInfo is supposed to be available. ;  ; Bool_t fIsSyntheticPair: 1;  Indicates whether this class can be split or not. Values are -1, 0, 1, 2. ;  ; std::atomic< TVirtualStreamerInfo * > fLastReadInfo;  cached current streamer info. ;  ; ROOT::MergeFunc_t fMerge;  saved info to call a IsA member function ;  ; std::atomic< TListOfFunctions * > fMethod;  ; ROOT::NewFunc_t fNew;  ; ROOT::NewArrFunc_t fNewArray;  ; RepoCont_t fObjectVersionRepository;  ; Longptr_t fOffsetStreamer;  Properties that can only be evaluated at run-time. ;  ; UInt_t fOnHeap;  ; TVirtualMutex * fOVRMutex = nullptr;  ; std::atomic< TClass ** > fPersistentRef;  ; std::atomic< Long_t > fProperty;  ; TList * fRealData;  ; TVirtualRefProxy * fRefProxy;  cached streamer info used in the last read. ;  ; ROOT::ResetAfterMergeFunc_t fResetAfterMerge;  ; std::atomic< UChar_t > fRuntimeProperties;  ; ROOT::Detail::TSchemaRuleSet * fSchemaRules;  Pointer to reference proxy if this class represents a reference. ;  ; TString fSharedLibs;  ; ShowMembersFunc_t fShowMembers;  ; Int_t fSizeof;  ; EState fState;  cached of the streaming method to use ;  ; TClassStreamer * fStreamer;  ; ClassStreamerFunc_t fStreamerF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:45042,cache,cached,45042,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,2,['cache'],['cached']
Performance,"st char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; [#0] WARNING:InputArguments -- The parameter 'sigG' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model0_over_model0_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model0_over_model0_Int[x]_sumData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2388.31039421315518; Edm = 3.25299757922590944e-06; Nfcn = 60; Abkg = 0.0614547 +/- 0.00211669 (limited); Asig = 0.833778 +/- 0.1898 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (hc_sig,hc_bkg); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (Abkg,Asig,p_ph_bkg_gamma_bin_0,p_ph_bkg_gamma_bin_1,p_ph_bkg_gamma_bin_10,p_ph_bkg_gamma_bin_11,p_ph_bkg_gamma_bin_12,p_ph_bkg_gamma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html:8888,optimiz,optimization,8888,doc/master/rf709__BarlowBeeston_8py.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html,1,['optimiz'],['optimization']
Performance,"st char* aliasName, const char* aliasFormula); virtual voidSetAutoDelete(Bool_t autodel = kTRUE); virtual voidTTree::SetAutoFlush(Long64_t autof = 30000000); virtual voidTTree::SetAutoSave(Long64_t autos = 300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* elist, Option_t* opt = """"); virtual voidSetEntryListFile(const char* filename = """", Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 10000); virtual voidSetEventList(TEventList* evlist); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttribut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TChain.html:15246,cache,cachesize,15246,root/html526/TChain.html,https://root.cern,https://root.cern/root/html526/TChain.html,4,['cache'],['cachesize']
Performance,"st char* fmt, va_list va) const; voidFillPerfStatPerfPlots(TTree* t, Int_t nactive); voidTObject::MakeZombie(); Int_tSetParameters(). private:. voidBuildHistos(Int_t start, Int_t stop, Int_t step, Bool_t nx). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTProofBenchRun::fParListList of PARs to be loaded; TProof*TProofBenchRun::fProofProof; TStringTProofBenchRun::fSelNameName of the selector to be run. private:. TCanvas*fCanvascanvas for performance plots; Int_tfDebugdebug switch; TDirectory*fDirProofBenchdirectory for proof outputs; Int_tfDrawdraw switch; TPBHistType*fHistTypehistogram type; TH2*fHist_perfstat_event; TList*fListPerfPlotslist of performance plots; Long64_tfNEventsnumber of events to generate; Int_tfNHistsnumber of histograms; Int_tfNTriesnumber of tries ; TStringfNamename of CPU run; TProofNodes*fNodesnode information; TProfile*fNorm_queryresult_event; TProfile*fProfile_perfstat_event; TProfile*fProfile_queryresult_event; Int_tfStartstart number of workers to scan; Int_tfSteptest to be performed every fStep workers; Int_tfStopstop number of workers to scan. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBenchRunCPU(TPBHistType* histtype = 0, Int_t nhists = 16, TDirectory* dirproofbench = 0, TProof* proof = 0, TProofNodes* nodes = 0, Long64_t nevents = 1000000, Int_t ntries = 2, Int_t start = 1, Int_t stop = -1, Int_t step = 1, Int_t draw = 0, Int_t debug = 0); Default constructor. ~TProofBenchRunCPU(); Destructor. void BuildHistos(Int_t start, Int_t stop, Int_t step, Bool_t nx); Build histograms, profiles and graphs needed for this run. void Run(Long64_t nevents, Int_t start, Int_t stop, Int_t step, Int_t ntries, Int_t debug, Int_t draw); Run benchmark; Inpu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofBenchRunCPU.html:6935,perform,performance,6935,root/html530/TProofBenchRunCPU.html,https://root.cern,https://root.cern/root/html530/TProofBenchRunCPU.html,6,['perform'],"['performance', 'performed']"
Performance,"st char* fmt, va_list va) const; voidGetFileName(const char* filename, TString& fn, Bool_t* = 0); voidTObject::MakeZombie(). private:. TEntryList&operator=(const TEntryList&). Data Members; public:. enum { kBlockSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArray*fBlocksblocks with indices of passing events (TEntryListBlocks); TEntryList*fCurrent! currently filled entry list; TDirectory*fDirectory! Pointer to directory holding this tree; Long64_tfEntriesToProcessused on proof to set the number of entries to process in a packet; TStringfFileNamename of the file, where the tree is; Long64_tfLastIndexQueried! used to optimize GetEntry() function from a loop ; Long64_tfLastIndexReturned! used to optimize GetEntry() function from a loop; TList*fListsa list of underlying entry lists for each tree of a chain; Long64_tfNnumber of entries in the list; Int_tfNBlocksnumber of TEntryListBlocks; TStringTNamed::fNameobject identifier; Bool_tfReapplyIf true, TTree::Draw will 'reapply' the original cut; Bool_tfShift! true when some sub-lists don't correspond to trees; ULong_tfStringHash! Hash value of a string of treename and filename; TStringTNamed::fTitleobject title; TStringfTreeNamename of the tree; Int_tfTreeNumber! the index of the tree in the chain (used when the entry. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEntryList(); default c-tor. TEntryList(const char* name, const char* title); c-tor with name and title. TEntryList(const char* name, const char* title, const TTree* tree); constructor with name and title, which also sets the tree. TEntryList(const char* name, const char* title, const char* treename, const char* filename); c-tor with name and title, which also sets the treename and the filen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEntryList.html:16787,optimiz,optimize,16787,root/html534/TEntryList.html,https://root.cern,https://root.cern/root/html534/TEntryList.html,2,['optimiz'],['optimize']
Performance,"st char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*sigma(RooRealVar& obs); RooAbsMoment*sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*specialIntegratorConfig() const; RooNumIntConfig*specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsReal.html:25501,cache,cache,25501,root/html602/RooAbsReal.html,https://root.cern,https://root.cern/root/html602/RooAbsReal.html,2,['cache'],['cache']
Performance,"st char* libname, Bool_t check = kFALSE); Check if class ""classname"" is known to the interpreter (in fact,; this check is not needed anymore, so classname is ignored). If; not it will load library ""libname"". If the library name does; not start with ""lib"", ""lib"" will be prepended and a search will; be made in the DynamicPath (see .rootrc). If not found a search; will be made on libname (without ""lib"" prepended) and if not found; a direct try of libname will be made (in case it contained an; absolute path).; If check is true it will only check if libname exists and is; readable.; Returns 0 on successful loading, -1 in case libname does not; exist or in case of error and -2 in case of version mismatch. void ls(Option_t* option = """") const; To list all objects of the application.; Loop on all objects created in the ROOT linked lists.; Objects may be files and windows or any other object directly; attached to the ROOT linked list. Int_t LoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); Load a macro in the interpreter's memory. Equivalent to the command line; command "".L filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]].; The possible error codes are defined by TInterpreter::EErrorCode.; If check is true it will only check if filename exists and is; readable.; Returns 0 on successful loading and -1 in case filename does not; exist or in case of error. Long_t Macro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); Execute a macro in the interpreter. Equivalent to the command line; command "".x filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]][(args)].; The possible error codes are defined by TInterpreter::EErrorCode.; If padUpdate is true (default) update the current pad.; Returns the macro return value. void Message(Int_t id, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:27537,Load,LoadMacro,27537,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,8,['Load'],"['Load', 'LoadMacro']"
Performance,"st char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGeoManager(const TGeoManager&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TGeoManager&operator=(const TGeoManager&). private:. voidInit(); Bool_tInitArrayPNE() const; Bool_tInsertPNEId(Int_t uid, Int_t ientry); Bool_tIsLoopingVolumes() const; voidSetLoopVolumes(Bool_t flag = kTRUE); voidUpdateElements(); voidVoxelize(Option_t* option = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. vector<ThreadData_t*>fThreadData! Thread private data; Int_tfThreadSize! Length of thread data. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static Bool_tfgLock! Lock preventing a second geometry to be loaded; static Int_tfgVerboseLevel! Verbosity level for Info messages (no IO). private:. Bool_tfActivity! switch ON/OFF volume activity (default OFF - all volumes active)); TObjArray*fArrayPNE! array of phisical node entries; UChar_t*fBits! bits used for voxelization; TGeoShape*fClippingShape! clipping shape for raytracing; Bool_tfClosed! flag that geometry is closed; TGeoNavigator*fCurrentNavigator! current navigator; TVirtualGeoTrack*fCurrentTrack! current track; TGeoVolume*fCurrentVolume! current volume; Bool_tfDrawExtra! flag that the list of physical nodes has to be drawn; TGeoElementTable*fElementTable! table of elements; Int_tfExplodedViewexploded view mode; TGeoHMatrix*fGLMatrixmatrix to be used for view transformations; TObjArray*fGShapes! list of runtime shapes; TObjArray*fGVolumes! list of runtime volumes; THashList*fHashGVolumes! hash list of group volumes providing fast search; THashList*fHashPNE-> hash list of phisical node entries; THashList*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoManager.html:32703,load,loaded,32703,root/html532/TGeoManager.html,https://root.cern,https://root.cern/root/html532/TGeoManager.html,1,['load'],['loaded']
Performance,"st char* name); Return (after creating it if necessary) the TEnum; describing the enum corresponding to the Decl 'id'. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TEnum* e); Mark enum 'e' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfEnums(const TListOfEnums& ). TListOfEnums& operator=(const TListOfEnums& ). void SetClass(TClass* cl); { fClass = cl; }. TClass * GetClass() const; {return fClass;}. TExMap * GetIds(); { return fIds;}. TEnum * FindUnloaded(const char* name); { return (TEnum*)fUnloaded->FindObject(name);}. Bool_t IsLoaded() const; { return fIsLoaded; }. » Author: Bianca-Cristina Cristescu February 2014 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last generated: 2015-06-0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfEnums.html:14473,Load,Load,14473,root/html604/TListOfEnums.html,https://root.cern,https://root.cern/root/html604/TListOfEnums.html,2,['Load'],['Load']
Performance,"st char* name); Return (after creating it if necessary) the TEnum; describing the enum corresponding to the Decl 'id'. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TEnum* e); Mark enum 'e' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfEnums(const TListOfEnums& ). TListOfEnums& operator=(const TListOfEnums& ). void SetClass(TClass* cl); { fClass = cl; }. TClass * GetClass() const; {return fClass;}. TExMap * GetIds(); { return fIds;}. TEnum * FindUnloaded(const char* name); { return (TEnum*)fUnloaded->FindObject(name);}. Bool_t IsLoaded() const; { return fIsLoaded; }. » Author: Bianca-Cristina Cristescu February 2014 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last generated: 2015-06-3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfEnums.html:14302,Load,Load,14302,root/html602/TListOfEnums.html,https://root.cern,https://root.cern/root/html602/TListOfEnums.html,2,['Load'],['Load']
Performance,"st char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategory.html:16316,cache,cache,16316,root/html534/RooAbsCategory.html,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html,1,['cache'],['cache']
Performance,"st char* namecycle, const char* classname); virtual void*TDirectory::GetObjectChecked(const char* namecycle, const TClass* cl); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual void*TDirectory::GetObjectUnchecked(const char* namecycle); virtual Option_t*TObject::GetOption() const; virtual const char*TDirectory::GetPath() const; virtual const char*TDirectory::GetPathStatic() const; TPluginManager*GetPluginManager() const; TFolder*GetRootFolder() const; virtual Long64_tTDirectory::GetSeekDir() const; virtual Long64_tTDirectory::GetSeekKeys() const; virtual Long64_tTDirectory::GetSeekParent() const; TVirtualPad*GetSelectedPad() const; const TObject*GetSelectedPrimitive() const; TStyle*GetStyle(const char* name) const; const char*GetSvnBranch() const; const char*GetSvnDate(); Int_tGetSvnRevision() const; virtual const char*TNamed::GetTitle() const; static const char*GetTutorialsDir(); TDataType*GetType(const char* name, Bool_t load = kFALSE) const; virtual UInt_tTObject::GetUniqueID() const; TUUIDTDirectory::GetUUID() const; TProcessUUID*GetUUIDs() const; const char*GetVersion() const; Int_tGetVersionCode() const; Int_tGetVersionDate() const; Int_tGetVersionInt() const; Int_tGetVersionTime() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; voidIdle(UInt_t idleTimeInSec, const char* command = 0); Int_tIgnoreInclude(const char* fname, const char* expandedfname); static Int_tIncreaseDirLevel(); static voidIndentLevel(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; static Bool_tInitialized(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsBatch() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; Bool_tIsEscaped() const; Bool_tIsExecutingM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TROOT.html:9041,load,load,9041,root/html534/TROOT.html,https://root.cern,https://root.cern/root/html534/TROOT.html,1,['load'],['load']
Performance,"st char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tEnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tEnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tEnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tExec(const char* cmd, Bool_t plusMaster = kFALSE); Int_tExec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tFinalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tFinalize(const char* queryref, Bool_t force = kFALSE); TList*FindDataSets(const char* searchString, const char* optStr = """"",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:5796,load,loadopts,5796,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['load'],['loadopts']
Performance,"st char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; const RooArgList&boundaries(); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStepFunction.html:2612,Cache,CacheModeRooAbsArg,2612,root/html534/RooStepFunction.html,https://root.cern,https://root.cern/root/html534/RooStepFunction.html,1,['Cache'],['CacheModeRooAbsArg']
Performance,"st char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); RooAbsCategoryLValue&operator=(const RooAbsCategoryLValue&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategoryLValue.html:12075,optimiz,optimizeCacheMode,12075,root/html602/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html,2,['optimiz'],['optimizeCacheMode']
Performance,"st char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tEnablePackage(const char* package, Bool_t notOnClient = kFALSE); Int_tEnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Int_tEnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tExec(const char* cmd, Bool_t plusMaster = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tFinalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tFinalize(const char* queryref, Bool_t force = kFALSE); TList*FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:5548,load,loadopts,5548,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,3,['load'],['loadopts']
Performance,"st char* slot); static voidTApplication::Close(TApplication* app); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidDeletePlayer(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tFork(); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; Int_tGetSessionStatus(); virtual voidHandleArchive(TMessage* mess, TString* slb = 0); virtual Int_tHandleCache(TMessage* mess, TString* slb = 0); virtual voidHandleCheckFile(TMessage* mess, TString* slb = 0); virtual Int_tHandleDataSets(TMessage* mess, TString* slb = 0); virtual voidHandleFork(TMessage* mess); virtual Int_tHandleLibIncPath(TMessage* mess); virtual voidHandleProcess(TMessage* mess, TString* slb = 0); virtual voidHandleQueryList(TMessage* mess); virtual voidHandleRemove(TMessage* mess, TString* slb = 0); virtual voidHandleRetrieve(TMessage* mess, TString* slb = 0); virtual voidHandleSubmerger(TMessage* mess); virtual Int_tHandleWorkerLists(TMessage* mess); virtual voidTApplication::Help(const char* line); Bool_tIsIdle(); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); virtual voidMakePlayer(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual voidProcessNext(TString* slb = 0); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh); virtual Int_tSetup(); Int_tSetupCommon(); Bool_tUnlinkDataDir(const char* path).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofServ.html:14380,Load,LoadGraphicsLibs,14380,root/html604/TProofServ.html,https://root.cern,https://root.cern/root/html604/TProofServ.html,1,['Load'],['LoadGraphicsLibs']
Performance,"st char* title, RooAbsPdf& _pdf); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExtendedBinding.html:24054,cache,cache,24054,root/html602/RooExtendedBinding.html,https://root.cern,https://root.cern/root/html602/RooExtendedBinding.html,2,['cache'],['cache']
Performance,"st char* title, RooDataSet* ntuple, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, int nStart, int nStop, Bool_t copyCache, const char* wgtVarName = 0); RooArgSetaddWgtVar(const RooArgSet& origVars, const RooAbsArg* wgtVar); Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); voidRooDirItem::appendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidinitialize(const char* wgtVarName); voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); voidRooDirItem::removeFromDir(TObject* obj); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataSet.html:14986,optimiz,optimizeReadingWithCaching,14986,root/html526/RooDataSet.html,https://root.cern,https://root.cern/root/html526/RooDataSet.html,4,"['cache', 'optimiz']","['cacheList', 'optimizeReadingWithCaching']"
Performance,"st char* title, const RooArgList& _prodSet); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProduct.html:24028,cache,cache,24028,root/html602/RooProduct.html,https://root.cern,https://root.cern/root/html602/RooProduct.html,2,['cache'],['cache']
Performance,"st double * ; params = nullptr, . unsigned int ; dataSize = 0, . int ; fitType = 0 . ). Fit using the a generic FCN function as a C++ callable object implementing double () (const double *) Note that the function dimension (i.e. ; the number of parameter) is needed in this case For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..) ; Definition at line 649 of file Fitter.h. ◆ GetDataFromFCN(). template<class ObjFuncType > . bool ROOT::Fit::Fitter::GetDataFromFCN. protected . internal functions to get data set and model function from FCN useful for fits done with customized FCN classes ; Definition at line 584 of file Fitter.h. ◆ GetFCN(). ROOT::Math::IMultiGenFunction * ROOT::Fit::Fitter::GetFCN ; (; ); const. inline . return pointer to last used objective function (is NULL in case fit is not yet done) This pointer will be valid as far as the fitter class has not been deleted. ; To be used after the fitting. The pointer should not be stored and will be invalided after performing a new fitting. In this case a new instance of the function pointer will be re-created and can be obtained calling again GetFCN() ; Definition at line 455 of file Fitter.h. ◆ GetMinimizer(). ROOT::Math::Minimizer * ROOT::Fit::Fitter::GetMinimizer ; (; ); const. inline . return pointer to last used minimizer (is NULL in case fit is not yet done) This pointer is guaranteed to be valid as far as the fitter class is valid and a new fit is not redone. ; To be used only after fitting. The pointer should not be stored and will be invalided after performing a new fitting. In this case a new instance of ROOT::Math::Minimizer will be re-created and can be obtained calling again GetMinimizer() ; Definition at line 444 of file Fitter.h. ◆ GetNCallsFromFCN(). int ROOT::Fit::Fitter::GetNCallsFromFCN ; (; ). protected . Definition at line 870 of file Fitter.cxx. ◆ IsBinFit(). bool ROOT::Fit::Fitter::IsBinFit ; (; ); const. inline . query if fit is binned. ; In cse of false",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html:26967,perform,performing,26967,doc/master/classROOT_1_1Fit_1_1Fitter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html,1,['perform'],['performing']
Performance,"st entry to process for this element; Long64_tTEventIter::fElemNumnumber of entries to process for this element; TEntryList*TEventIter::fEntryList! entry list for processing; Long64_tTEventIter::fEntryListPos! current position in the entrylist; TEventList*TEventIter::fEventList! eventList for processing; Int_tTEventIter::fEventListPos! current position in the eventList; TFile*TEventIter::fFileCurrent file; TStringTEventIter::fFilenameName of the current file; Long64_tTEventIter::fFirstfirst entry to process; Long64_tTEventIter::fNumnumber of entries to process; Long64_tTEventIter::fOldBytesReadlast reported number of bytes read; TStringTEventIter::fPathPath to current TDirectory; TSelector*TEventIter::fSelselector to be used; Bool_tTEventIter::fStoptermination of run requested. private:. Long64_tfCacheSizeCache size; TList*fFileTreesFiles && Trees currently open; TTree*fTreetree we are iterating over; TTreeCache*fTreeCacheinstance of the tree cache for the tree; Bool_tfTreeCacheIsLearningWhether cache is in learning phase; TStringfTreeNamename of the tree object to iterate over; Bool_tfUseParallelUnzipControl usage of parallel unzip; Bool_tfUseTreeCacheControl usage of the tree cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIterTree(); Default ctor. TEventIterTree(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIterTree(); Destructor. Long64_t GetCacheSize(); Return the size in bytes of the cache, if any; Return -1 if not used. Int_t GetLearnEntries(); Return the number of entries in the learning phase. TTree* GetTrees(TDSetElement* elem); Create a Tree for the main TDSetElement and for all the friends.; Returns the main tree or 0 in case of an error. TTree* Load(TDSetElement* elem, Bool_t& localfile); Load a tree from s TDSetElement. Long64_t GetNextEvent(); Get next event. TEventIterTree(). » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rade",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEventIterTree.html:6859,cache,cache,6859,root/html528/TEventIterTree.html,https://root.cern,https://root.cern/root/html528/TEventIterTree.html,3,['cache'],['cache']
Performance,"st of all members |; Public Member Functions |; Static Public Member Functions |; Private Attributes |; List of all members ; TFoamVect Class Reference. ; Auxiliary class TFoamVect of n-dimensional vector, with dynamic allocation used for the cartesian geometry of the TFoam cells. ; Definition at line 10 of file TFoamVect.h. Public Member Functions;  TFoamVect ();  Default constructor for streamer. ;  ;  TFoamVect (const TFoamVect &);  Copy constructor. ;  ;  TFoamVect (Int_t);  User constructor creating n-dimensional vector and allocating dynamically array of components. ;  ;  ~TFoamVect () override;  Destructor. ;  ; Double_t GetCoord (Int_t i) const;  ; Int_t GetDim () const;  ; TClass * IsA () const override;  ; TFoamVect & operator*= (const Double_t &);  unary multiplication operator *= ;  ; TFoamVect operator+ (const TFoamVect &);  addition operator +; sum of 2 vectors: c=a+b, a=a+b, NEVER USE IT, VERY SLOW!!! ;  ; TFoamVect & operator+= (const TFoamVect &);  unary addition operator +=; adding vector c*=x, ;  ; TFoamVect operator- (const TFoamVect &);  subtraction operator -; difference of 2 vectors; c=a-b, a=a-b, NEVER USE IT, VERY SLOW!!! ;  ; TFoamVect & operator-= (const TFoamVect &);  unary subtraction operator -= ;  ; TFoamVect & operator= (const TFoamVect &);  substitution operator ;  ; TFoamVect & operator= (Double_t);  Loading in double prec. number, sometimes can be useful. ;  ; TFoamVect & operator= (Double_t[]);  Loading in ordinary double prec. vector, sometimes can be useful. ;  ; Double_t & operator[] (Int_t);  [] is for access to elements as in ordinary matrix like a[j]=b[j] (Perhaps against some strict rules but rather practical.) Range protection is built in, consequently for substitution one should use rather use a=b than explicit loop! ;  ; void Print (Option_t *option) const override;  Printout of all vector components on ""std::cout"". ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFoamVect.html:1474,Load,Loading,1474,doc/master/classTFoamVect.html,https://root.cern,https://root.cern/doc/master/classTFoamVect.html,1,['Load'],['Loading']
Performance,st of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramsEffective parameters of this p.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:43693,cache,cache,43693,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,3,['cache'],['cache']
Performance,"st of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:18522,Cache,Cache,18522,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,3,['Cache'],['Cache']
Performance,"st of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. private:. void*fD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDCacheSystem.html:17416,Cache,Cache,17416,root/html528/TDCacheSystem.html,https://root.cern,https://root.cern/root/html528/TDCacheSystem.html,8,['Cache'],['Cache']
Performance,"st of physical nodes, so that we can start over with a new list. ; If MUSTDELETE is true, delete previous nodes. ; Definition at line 3542 of file TGeoManager.cxx. ◆ ClearShape(). void TGeoManager::ClearShape ; (; const TGeoShape * ; shape). Remove a shape from the list of shapes. ; Definition at line 1617 of file TGeoManager.cxx. ◆ ClearThreadData(). void TGeoManager::ClearThreadData ; (; ); const. Definition at line 953 of file TGeoManager.cxx. ◆ ClearThreadsMap(). void TGeoManager::ClearThreadsMap ; (; ). static . Clear the current map of threads. ; This will be filled again by the calling threads via ThreadId calls. ; Definition at line 984 of file TGeoManager.cxx. ◆ ClearTracks(). void TGeoManager::ClearTracks ; (; ). inline . Definition at line 415 of file TGeoManager.h. ◆ CloseGeometry(). void TGeoManager::CloseGeometry ; (; Option_t * ; option = ""d""). Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-time shapes)building the cache manager, voxelizing all volumes, counting the total number of physical nodes and registering the manager class to the browser. ; Definition at line 1480 of file TGeoManager.cxx. ◆ ConvertReflections(). void TGeoManager::ConvertReflections ; (; ). Convert all reflections in geometry to normal rotations + reflected shapes. ; Definition at line 1723 of file TGeoManager.cxx. ◆ CountLevels(). void TGeoManager::CountLevels ; (; ). Count maximum number of nodes per volume, maximum depth and maximum number of xtru vertices. ; Definition at line 1759 of file TGeoManager.cxx. ◆ CountNodes(). Int_t TGeoManager::CountNodes ; (; const TGeoVolume * ; vol = nullptr, . Int_t ; nlevels = 10000, . Int_t ; option = 0 . ). Count the total number of nodes starting from a volume, nlevels down. ; Definition at line 1803 of file TGeoManager.cxx. ◆ CreateParallelWorld(). TGeoParallelWorld * TGeoManager::CreateParallelWorld ; (; const char * ; name). Create a parallel world for prioritised navigation. ; This",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:79208,cache,cache,79208,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['cache'],['cache']
Performance,"st of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooWrapperPdf.h>. Inheritance diagram for RooWrapperPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooWrapperPdf() [1/3]. RooWrapperPdf::RooWrapperPdf ; (; ). inline . Definition at line 27 of file RooWrapperPdf.h. ◆ RooWrapperPdf() [2/3]. RooWrapperPdf::RooWrapperPdf ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; inputFunction, . bool ; selfNormalized = false . ). inline . Construct a new RooWrapperPdf. ; Parameters. [in]nameA name to identify this object. ; [in]titleTitle (for e.g. plotting) ; [in]inputFunctionAny RooAbsReal that should be converted into a PDF. Although it's possible ; [in]selfNormalizedThe return value the RooAbsPdf::selfNormalized() function for the wrapped PDF object. If it is true, then no automatic normalization will be performed when evaluating the function. In this case, the effect RooWrapperPdf is not to change the evaluated values, but only to wrap the function in something that is of type RooAbsPdf, which can be useful if some interface reqiures it. to pass a PDF, it only makes sense for non-PDF functions. . Definition at line 39 of file RooWrapperPdf.h. ◆ RooWrapperPdf() [3/3]. RooWrapperPdf::RooWrapperPdf ; (; const RooWrapperPdf & ; other, . const char * ; name = nullptr . ). inline . Definition at line 44 of file RooWrapperPdf.h. Member Function Documentation. ◆ analyticalIntegral(). double RooWrapperPdf::analyticalIntegral ; (; Int_t ; code, . const char * ; rangeName = nullptr . ); const. inlineoverridevirtual . Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ; This functions will only be called with codes returned by getAnalyticalIntegral, except code zero. ; Reimplemented from RooAbsReal.; Definition at line 70 of file RooWrapperPdf.h. ◆ analytica",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWrapperPdf.html:74513,perform,performed,74513,doc/master/classRooWrapperPdf.html,https://root.cern,https://root.cern/doc/master/classRooWrapperPdf.html,1,['perform'],['performed']
Performance,"st of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; TStringfMsgGetHeadcache GetHead() msg; TStringfMsgReadBuffercache ReadBuffer() msg; TStringfMsgReadBuffer10cache ReadBuffer10() msg; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Bool_tfNoProxydon't use proxy; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; TUrlfProxyproxy URL; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Long64_tfSizefile size; TSocket*fSocketsocket for HTTP/1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TWebFile.html:21021,cache,cache,21021,root/html532/TWebFile.html,https://root.cern,https://root.cern/root/html532/TWebFile.html,4,['cache'],['cache']
Performance,"st override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; virtual void recomputeShape ()=0;  If a category depends on the shape of others, i.e. its state numbers or names depend on the states of other categories, this function has to be implemented to recompute _stateNames and _insertionOrder. ;  ; RooCatType * retrieveLegacyState (value_type index) const;  Return the legacy RooCatType corresponding to index. If it doesn't exist, create one. ;  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)activate associate tree branch ;  ; std::map< std::string, value_type > & stateNames ();  Access the map of state names to index numbers. ;  ; const std::map< std::string, value_type > & stateNames () const;  Access the map of state names to index numbers. ;  ; void syncCache (const RooArgSet *set=nullptr) override;  Explicitly synchronize RooAbsCategory internal cache. ;  ; virtual bool isValid (const RooCatType &value) const;  Check if given state is defined for this object. ;  ; const RooCatType * defineType (const char *label);  ; const RooCatType * defineType (const char *label, int index);  ; const RooCatType * defineTypeUnchecked (const char *label, value_type index);  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategoryLValue.html:39268,cache,cache,39268,doc/master/classRooAbsCategoryLValue.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategoryLValue.html,1,['cache'],['cache']
Performance,"st override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; virtual void recomputeShape ()=0;  If a category depends on the shape of others, i.e. its state numbers or names depend on the states of other categories, this function has to be implemented to recompute _stateNames and _insertionOrder. ;  ; RooCatType * retrieveLegacyState (value_type index) const;  Return the legacy RooCatType corresponding to index. If it doesn't exist, create one. ;  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)activate associate tree branch ;  ; std::map< std::string, value_type > & stateNames ();  Access the map of state names to index numbers. ;  ; const std::map< std::string, value_type > & stateNames () const;  Access the map of state names to index numbers. ;  ; void syncCache (const RooArgSet *set=nullptr) override;  Explicitly synchronize RooAbsCategory internal cache. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategory.html:38253,cache,cache,38253,doc/master/classRooAbsCategory.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategory.html,1,['cache'],['cache']
Performance,"st the histogram; # counts and the list of variables. The binning is optional: the default; # binning of the RooRealVars is used if not explicitly specified.; datahist_new_1 = ROOT.RooDataHist.from_numpy(counts, [x]); ; print(""RooDataHist imported with default binning and exported back to numpy:""); print_histogram_output(datahist_new_1.to_numpy()); ; ; # It's also possible to pass custom bin edges to `RooDataHist.from_numpy`, just; # like you pass them to `numpy.histogramdd` when you get the counts to fill the; # RooDataHist with:; bins = [np.linspace(-10, 10, 21)]; counts, _ = np.histogramdd([x_arr], bins=bins); datahist_new_2 = ROOT.RooDataHist.from_numpy(counts, [x], bins=bins); ; print(""RooDataHist imported with linspace binning and exported back to numpy:""); print_histogram_output(datahist_new_2.to_numpy()); ; # Alternatively, you can specify only the number of bins and the range if your; # binning is uniform. This is preferred over passing the full list of bin; # edges, because RooFit will know that the binning is uniform and do some; # optimizations.; bins = [20]; ranges = [(-10, 10)]; counts, _ = np.histogramdd([x_arr], bins=bins, range=ranges); datahist_new_3 = ROOT.RooDataHist.from_numpy(counts, [x], bins=bins, ranges=ranges); ; print(""RooDataHist imported with uniform binning and exported back to numpy:""); print_histogram_output(datahist_new_3.to_numpy()); [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 14250.1, estimated distance to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf409__NumPyPandasToRooFit_8py.html:5602,optimiz,optimizations,5602,doc/master/rf409__NumPyPandasToRooFit_8py.html,https://root.cern,https://root.cern/doc/master/rf409__NumPyPandasToRooFit_8py.html,1,['optimiz'],['optimizations']
Performance,"st trees; -> same cuts for signal and background. void PrepareTrainingAndTestTree(TCut sigcut, TCut bkgcut, const TString& splitOpt); prepare the training and test trees. TMVA::MethodBase* BookMethod(TString theMethodName, TString methodTitle, TString theOption = """"); Book a classifier or regression method. TMVA::MethodBase* BookMethod(TMVA::Types::EMVA theMethod, TString methodTitle, TString theOption = """"); books MVA method; the option configuration string is custom for each MVA; the TString field ""theNameAppendix"" serves to define (and distinguish); several instances of a given MVA, eg, when one wants to compare the; performance of various configurations. TMVA::IMethod* GetMethod(const TString& title) const; returns pointer to MVA that corresponds to given method title. void WriteDataInformation(); put correlations of input data and a few (default + user; selected) transformations into the root file. void OptimizeAllMethods(TString fomType = ""ROCIntegral"", TString fitType = ""Scan""); iterates through all booked methods and sees if they use parameter tuning and if so..; does just that i.e. calls ""Method::Train()"" for different parameter setttings and; keeps in mind the ""optimal one""... and that's the one that will later on be used; in the main training loop. void TrainAllMethods(); iterates through all booked methods and calls training. void TestAllMethods(). void MakeClass(const TString& methodTitle = """") const; Print predefined help message of classifier; iterate over methods and test. void PrintHelpMessage(const TString& methodTitle = """") const; Print predefined help message of classifier; iterate over methods and test. void EvaluateAllVariables(TString options = """"); iterates over all MVA input varables and evaluates them. void EvaluateAllMethods( void ); iterates over all MVAs that have been booked, and calls their evaluation methods. const char* GetName() const; { return ""Factory""; }. void AddRegressionTree(TTree* tree, Double_t weight = 1.0, TMVA::Types::ETre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__Factory.html:19251,Optimiz,OptimizeAllMethods,19251,root/html528/TMVA__Factory.html,https://root.cern,https://root.cern/root/html528/TMVA__Factory.html,1,['Optimiz'],['OptimizeAllMethods']
Performance,"st unsigned char *p = (const unsigned char*)Data();; 667 while (i--) {; 668 Mash(hv, toupper(*p));; 669 ++p;; 670 }; 671 return hv;; 672}; 673 ; 674////////////////////////////////////////////////////////////////////////////////; 675/// Return hash value.; 676 ; 677UInt_t TString::Hash(ECaseCompare cmp) const; 678{; 679 return (cmp == kExact) ? HashCase() : HashFoldCase();; 680}; 681 ; 682 // MurmurHash3 - a blazingly fast public domain hash!; 683 // See http://code.google.com/p/smhasher/; 684 // There are two versions, one optimized for 32 bit and one for 64 bit.; 685 // They give different hash results!; 686 // We use only the 64 bit version which also works on 32 bit.; 687 ; 688 //-----------------------------------------------------------------------------; 689 // MurmurHash3 was written by Austin Appleby, and is placed in the public; 690 // domain. The author hereby disclaims copyright to this source code.; 691 ; 692 // Note - The x86 and x64 versions do _not_ produce the same results, as the; 693 // algorithms are optimized for their respective platforms. You can still; 694 // compile and run any of them on any platform, but your performance with the; 695 // non-native version will be less than optimal.; 696 ; 697 //-----------------------------------------------------------------------------; 698 // Platform-specific functions and macros; 699 ; 700 // From MurmurHash.h:; 701 ; 702#if defined(_MSC_VER) && (_MSC_VER < 1800); 703 // Microsoft Visual Studio; 704 typedef unsigned char uint8_t;; 705 typedef unsigned long uint32_t;; 706 typedef unsigned __int64 uint64_t;; 707#else // defined(_MSC_VER); 708 // Other compilers; 709#include <stdint.h>; 710#endif // !defined(_MSC_VER); 711 ; 712 // From MurmurHash.cpp:; 713#if defined(_MSC_VER); 714 // Microsoft Visual Studio; 715#include <stdlib.h>; 716#define ROTL64(x,y) _rotl64(x,y); 717#define BIG_CONSTANT(x) (x); 718#else // defined(_MSC_VER); 719 // Other compilers; 720 inline uint64_t rotl64 ( uint64_t x, int8_t r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:20597,optimiz,optimized,20597,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"st va) const; voidTObject::MakeZombie(); voidresampleData(Double_t& ratio). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. UInt_t_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendMode_extendModeExtended mode capabilities of p.d.f.; RooDataSet*_genData! Data being generated; Bool_t_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_t_nextProtoIndexNext prototype event to load according to LUT; TString_normRangeNormalization range of pdf; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsGenContext.html:7864,load,load,7864,root/html534/RooAbsGenContext.html,https://root.cern,https://root.cern/root/html534/RooAbsGenContext.html,1,['load'],['load']
Performance,"st() function); 2855 if (fEntryList->TestBit(kCanDelete)) {; 2856 TEntryList *tmp = fEntryList;; 2857 fEntryList = nullptr; // Avoid problem with RecursiveRemove.; 2858 delete tmp;; 2859 } else {; 2860 fEntryList = nullptr;; 2861 }; 2862 }; 2863 ; 2864 fEventList = nullptr;; 2865 ; 2866 TString basename(filename);; 2867 ; 2868 Int_t dotslashpos = basename.Index("".root/"");; 2869 TString behind_dot_root = """";; 2870 if (dotslashpos>=0) {; 2871 // Copy the list name specification; 2872 behind_dot_root = basename(dotslashpos+6,basename.Length()-dotslashpos+6);; 2873 // and remove it from basename; 2874 basename.Remove(dotslashpos+5);; 2875 }; 2876 fEntryList = new TEntryListFromFile(basename.Data(), behind_dot_root.Data(), fNtrees);; 2877 fEntryList->SetBit(kCanDelete, true);; 2878 fEntryList->SetDirectory(nullptr);; 2879 ((TEntryListFromFile*)fEntryList)->SetFileNames(fFiles);; 2880}; 2881 ; 2882////////////////////////////////////////////////////////////////////////////////; 2883/// This function transfroms the given TEventList into a TEntryList; 2884///; 2885/// NOTE, that this function loads all tree headers, because the entry numbers; 2886/// in the TEventList are global and have to be recomputed, taking into account; 2887/// the number of entries in each tree.; 2888///; 2889/// The new TEntryList is owned by the TChain and gets deleted when the chain; 2890/// is deleted. This TEntryList is returned by GetEntryList() function, and after; 2891/// GetEntryList() function is called, the TEntryList is not owned by the chain; 2892/// any more and will not be deleted with it.; 2893 ; 2894void TChain::SetEventList(TEventList *evlist); 2895{; 2896 fEventList = evlist;; 2897 if (fEntryList) {; 2898 if (fEntryList->TestBit(kCanDelete)) {; 2899 TEntryList *tmp = fEntryList;; 2900 fEntryList = nullptr; // Avoid problem with RecursiveRemove.; 2901 delete tmp;; 2902 } else {; 2903 fEntryList = nullptr;; 2904 }; 2905 }; 2906 ; 2907 if (!evlist) {; 2908 fEntryList = nullptr;; 2909 f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:104662,load,loads,104662,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['load'],['loads']
Performance,"st(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. Int_t HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. Int_t HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player instance. Int_t GetPriority(); Get the processing priority for the group the user belongs too. This; priority is a number (0 - 100) determined by a scheduler (third; party process) based on some basic priority the group has, e.g.; we might want to give users in a specific group (e.g. promptana); a higher priority than users in other groups, and on the analysis; of historical logg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:28100,cache,cache,28100,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,2,['cache'],['cache']
Performance,"st); 3875{; 3876 if (!HasInterpreterInfo()) return;; 3877 ; 3878 // get the base class; 3879 TIter nextBase(GetListOfBases(), kIterBackward);; 3880 TBaseClass *baseClass;; 3881 while ((baseClass = (TBaseClass *) nextBase())) {; 3882 TClass *base = baseClass->GetClassPointer();; 3883 if (base) base->GetMenuItems(list);; 3884 }; 3885 ; 3886 // remove methods redefined in this class with no menu; 3887 TMethod *method, *m;; 3888 TIter next(GetListOfMethods(), kIterBackward);; 3889 while ((method = (TMethod*)next())) {; 3890 m = (TMethod*)list->FindObject(method->GetName());; 3891 if (method->IsMenuItem() != kMenuNoMenu) {; 3892 if (!m); 3893 list->AddFirst(method);; 3894 } else {; 3895 if (m && m->GetNargs() == method->GetNargs()); 3896 list->Remove(m);; 3897 }; 3898 }; 3899}; 3900 ; 3901////////////////////////////////////////////////////////////////////////////////; 3902/// Check whether a class has a dictionary or not.; 3903/// This is equivalent to ask if a class is coming from a bootstrapping; 3904/// procedure initiated during the loading of a library.; 3905 ; 3906Bool_t TClass::HasDictionary() const; 3907{; 3908 return IsLoaded();; 3909}; 3910 ; 3911////////////////////////////////////////////////////////////////////////////////; 3912/// Check whether a class has a dictionary or ROOT can load one.; 3913/// This is equivalent to ask HasDictionary() or whether a library is known; 3914/// where it can be loaded from, or whether a Dictionary function is; 3915/// available because the class's dictionary library was already loaded.; 3916 ; 3917Bool_t TClass::HasDictionarySelection(const char* clname); 3918{; 3919 if (TClass* cl = (TClass*)gROOT->GetListOfClasses()->FindObject(clname)); 3920 return cl->IsLoaded();; 3921 return gClassTable->GetDict(clname) || gInterpreter->GetClassSharedLibs(clname);; 3922}; 3923 ; 3924////////////////////////////////////////////////////////////////////////////////; 3925/// Verify the base classes always.; 3926 ; 3927void TClass::GetMissi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:147855,load,loading,147855,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loading']
Performance,"st); 3942{; 3943 if (!HasInterpreterInfo()) return;; 3944 ; 3945 // get the base class; 3946 TIter nextBase(GetListOfBases(), kIterBackward);; 3947 TBaseClass *baseClass;; 3948 while ((baseClass = (TBaseClass *) nextBase())) {; 3949 TClass *base = baseClass->GetClassPointer();; 3950 if (base) base->GetMenuItems(list);; 3951 }; 3952 ; 3953 // remove methods redefined in this class with no menu; 3954 TMethod *method, *m;; 3955 TIter next(GetListOfMethods(), kIterBackward);; 3956 while ((method = (TMethod*)next())) {; 3957 m = (TMethod*)list->FindObject(method->GetName());; 3958 if (method->IsMenuItem() != kMenuNoMenu) {; 3959 if (!m); 3960 list->AddFirst(method);; 3961 } else {; 3962 if (m && m->GetNargs() == method->GetNargs()); 3963 list->Remove(m);; 3964 }; 3965 }; 3966}; 3967 ; 3968////////////////////////////////////////////////////////////////////////////////; 3969/// Check whether a class has a dictionary or not.; 3970/// This is equivalent to ask if a class is coming from a bootstrapping; 3971/// procedure initiated during the loading of a library.; 3972 ; 3973Bool_t TClass::HasDictionary() const; 3974{; 3975 return IsLoaded();; 3976}; 3977 ; 3978////////////////////////////////////////////////////////////////////////////////; 3979/// Check whether a class has a dictionary or ROOT can load one.; 3980/// This is equivalent to ask HasDictionary() or whether a library is known; 3981/// where it can be loaded from, or whether a Dictionary function is; 3982/// available because the class's dictionary library was already loaded.; 3983 ; 3984Bool_t TClass::HasDictionarySelection(const char* clname); 3985{; 3986 if (TClass* cl = (TClass*)gROOT->GetListOfClasses()->FindObject(clname)); 3987 return cl->IsLoaded();; 3988 return gClassTable->GetDict(clname) || gInterpreter->GetClassSharedLibs(clname);; 3989}; 3990 ; 3991////////////////////////////////////////////////////////////////////////////////; 3992/// Verify the base classes always.; 3993 ; 3994void TClass::GetMissi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:150606,load,loading,150606,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loading']
Performance,"st* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occured while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton ana",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:98437,load,loading,98437,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,1,['load'],['loading']
Performance,st* TTreeCache::fBrNames {nullptr}. protected . ! list of branch names in the cache ; Definition at line 52 of file TTreeCache.h. ◆ fCurrentClusterStart. Long64_t TTreeCache::fCurrentClusterStart {-1}. protected . ! Start of the cluster(s) where the current content was picked out ; Definition at line 42 of file TTreeCache.h. ◆ fEnabled. bool TTreeCache::fEnabled {true}. protected . ! cache enabled for cached reading ; Definition at line 63 of file TTreeCache.h. ◆ fEntryCurrent. Long64_t TTreeCache::fEntryCurrent {-1}. protected . ! current lowest entry number in the cache ; Definition at line 40 of file TTreeCache.h. ◆ fEntryMax. Long64_t TTreeCache::fEntryMax {1}. protected . ! last entry in the cache ; Definition at line 39 of file TTreeCache.h. ◆ fEntryMin. Long64_t TTreeCache::fEntryMin {0}. protected . ! first entry in the cache ; Definition at line 38 of file TTreeCache.h. ◆ fEntryNext. Long64_t TTreeCache::fEntryNext {-1}. protected . ! next entry number where cache must be filled ; Definition at line 41 of file TTreeCache.h. ◆ fFillTimes. Int_t TTreeCache::fFillTimes {0}. protected . ! how many times we can fill the current buffer ; Definition at line 59 of file TTreeCache.h. ◆ fFirstBuffer. bool TTreeCache::fFirstBuffer {true}. protected . ! true if first buffer is used for prefetching ; Definition at line 56 of file TTreeCache.h. ◆ fFirstEntry. Long64_t TTreeCache::fFirstEntry {-1}. protected . ! save the value of the first entry ; Definition at line 61 of file TTreeCache.h. ◆ fFirstMiss. Long64_t TTreeCache::fFirstMiss {-1}. protected . ! set to the event # of the first miss. ; Definition at line 73 of file TTreeCache.h. ◆ fFirstTime. bool TTreeCache::fFirstTime {true}. protected . ! save the fact that we processes the first entry ; Definition at line 60 of file TTreeCache.h. ◆ fgLearnEntries. Int_t TTreeCache::fgLearnEntries = 100. staticprotected . number of entries used for learning mode ; Definition at line 65 of file TTreeCache.h. ◆ fIsLearning. bool ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:53212,cache,cache,53212,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,['cache'],['cache']
Performance,"st+len). ; This implementation will fill a vector with every event retrieved one by one (even if the weight is constant). Then, it returns a span. ; Implements RooAbsDataStore.; Definition at line 473 of file RooCompositeDataStore.cxx. ◆ hasFilledCache(). bool RooCompositeDataStore::hasFilledCache ; (; ); const. overridevirtual . Reimplemented from RooAbsDataStore.; Definition at line 159 of file RooCompositeDataStore.cxx. ◆ index(). RooCategory * RooCompositeDataStore::index ; (; ). inline . Definition at line 79 of file RooCompositeDataStore.h. ◆ IsA(). TClass * RooCompositeDataStore::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsDataStore.; Definition at line 127 of file RooCompositeDataStore.h. ◆ isWeighted(). bool RooCompositeDataStore::isWeighted ; (; ); const. overridevirtual . Implements RooAbsDataStore.; Definition at line 269 of file RooCompositeDataStore.cxx. ◆ loadValues(). void RooCompositeDataStore::loadValues ; (; const RooAbsDataStore * ; tds, . const RooFormulaVar * ; select = nullptr, . const char * ; rangeName = nullptr, . std::size_t ; nStart = 0, . std::size_t ; nStop = std::numeric_limits<std::size_t>::max() . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 280 of file RooCompositeDataStore.cxx. ◆ merge(). RooAbsDataStore * RooCompositeDataStore::merge ; (; const RooArgSet & ; allvars, . std::list< RooAbsDataStore * > ; dstoreList . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 335 of file RooCompositeDataStore.cxx. ◆ numEntries(). Int_t RooCompositeDataStore::numEntries ; (; ); const. overridevirtual . Implements RooAbsDataStore.; Definition at line 359 of file RooCompositeDataStore.cxx. ◆ recalculateCache(). void RooCompositeDataStore::recalculateCache ; (; const RooArgSet * ; proj, . Int_t ; firstEvent, . Int_t ; lastEvent, . Int_t ; stepSize, . bool ; skipZeroWeights . ). overridevirtual . Forward recalculate request to all subsets. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCompositeDataStore.html:26946,load,loadValues,26946,doc/master/classRooCompositeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooCompositeDataStore.html,1,['load'],['loadValues']
Performance,"st-read callback. ; Definition at line 175 of file RFieldBase.hxx. ◆ fName. std::string ROOT::Experimental::RFieldBase::fName. private . The field name relative to its parent field. ; Definition at line 167 of file RFieldBase.hxx. ◆ fNRepetitions. std::size_t ROOT::Experimental::RFieldBase::fNRepetitions. private . For fixed sized arrays, the array length. ; Definition at line 173 of file RFieldBase.hxx. ◆ fOnDiskId. DescriptorId_t ROOT::Experimental::RFieldBase::fOnDiskId = kInvalidDescriptorId. private . When the columns are connected to a page source or page sink, the field represents a field id in the corresponding RNTuple descriptor. ; This on-disk ID is set in RPageSink::Create() for writing and by RFieldDescriptor::CreateField() when recreating a field / model from the stored descriptor. ; Definition at line 179 of file RFieldBase.hxx. ◆ fOnDiskTypeChecksum. std::uint32_t ROOT::Experimental::RFieldBase::fOnDiskTypeChecksum = 0. protected . TClass checksum cached from the descriptor after a call to ConnectPageSource(). ; Only set for classes with dictionaries. ; Definition at line 246 of file RFieldBase.hxx. ◆ fOnDiskTypeVersion. std::uint32_t ROOT::Experimental::RFieldBase::fOnDiskTypeVersion = kInvalidTypeVersion. protected . C++ type version cached from the descriptor after a call to ConnectPageSource() ; Definition at line 243 of file RFieldBase.hxx. ◆ fParent. RFieldBase* ROOT::Experimental::RFieldBase::fParent. protected . Sub fields point to their mother field. ; Definition at line 222 of file RFieldBase.hxx. ◆ fPrincipalColumn. Internal::RColumn* ROOT::Experimental::RFieldBase::fPrincipalColumn = nullptr. protected . All fields that have columns have a distinct main column. ; E.g., for simple fields (float, int, ...), the principal column corresponds to the field type. For collection fields except fixed-sized arrays, the main column is the offset field. Class fields have no column of their own. When reading, points to any column of the column team of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html:55525,cache,cached,55525,doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,1,['cache'],['cached']
Performance,"st. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 98 of file TDataMember.h. ◆ IsaPointer(). Bool_t TDataMember::IsaPointer ; (; ); const. Return true if data member is a pointer. ; Definition at line 542 of file TDataMember.cxx. ◆ IsBasic(). Bool_t TDataMember::IsBasic ; (; ); const. Return true if data member is a basic type, e.g. char, int, long... ; Definition at line 524 of file TDataMember.cxx. ◆ IsEnum(). Bool_t TDataMember::IsEnum ; (; ); const. Return true if data member is an enum. ; Definition at line 533 of file TDataMember.cxx. ◆ IsPersistent(). Bool_t TDataMember::IsPersistent ; (; ); const. inline . Definition at line 91 of file TDataMember.h. ◆ IsSTLContainer(). int TDataMember::IsSTLContainer ; (; ). The return type is defined in TDictionary (kVector, kList, etc.) ; Definition at line 551 of file TDataMember.cxx. ◆ IsValid(). Bool_t TDataMember::IsValid ; (; ). Return true if this data member object is pointing to a currently loaded data member. ; If a function is unloaded after the TDataMember is created, the TDataMember will be set to be invalid. ; Definition at line 564 of file TDataMember.cxx. ◆ operator=(). TDataMember & TDataMember::operator= ; (; const TDataMember & ; dm). protected . assignment operator ; Definition at line 298 of file TDataMember.cxx. ◆ Property(). Long_t TDataMember::Property ; (; ); const. overridevirtual . Get property description word. For meaning of bits see EProperty. ; Implements TDictionary.; Definition at line 588 of file TDataMember.cxx. ◆ SetClass(). void TDataMember::SetClass ; (; TClass * ; cl). inline . Definition at line 95 of file TDataMember.h. ◆ SetterMethod(). TMethodCall * TDataMember::SetterMethod ; (; TClass * ; cl). Return a TMethodCall method responsible for setting the value of data member. ; The cl argument specifies the class of the object which will be used to call this method (in case of multiple inheritance TMethodCall needs to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataMember.html:29253,load,loaded,29253,doc/master/classTDataMember.html,https://root.cern,https://root.cern/doc/master/classTDataMember.html,1,['load'],['loaded']
Performance,"st. inlineprivate . Definition at line 136 of file TPluginManager.h. ◆ GetClass(). const char * TPluginHandler::GetClass ; (; ); const. inline . Definition at line 212 of file TPluginManager.h. ◆ GetCtor(). const char * TPluginHandler::GetCtor ; (; ); const. inlineprivate . Definition at line 139 of file TPluginManager.h. ◆ GetOrigin(). const char * TPluginHandler::GetOrigin ; (; ); const. inlineprivate . Definition at line 140 of file TPluginManager.h. ◆ GetPlugin(). const char * TPluginHandler::GetPlugin ; (; ); const. inlineprivate . Definition at line 138 of file TPluginManager.h. ◆ GetRegexp(). const char * TPluginHandler::GetRegexp ; (; ); const. inlineprivate . Definition at line 137 of file TPluginManager.h. ◆ IsA(). TClass * TPluginHandler::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 254 of file TPluginManager.h. ◆ LoadPlugin(). Int_t TPluginHandler::LoadPlugin ; (; ). Load the plugin library for this handler. ; Returns 0 on successful loading and -1 in case the library does not exist or in case of error. ; Definition at line 293 of file TPluginManager.cxx. ◆ LoadPluginImpl(). void TPluginHandler::LoadPluginImpl ; (; ). private . Load the plugin library for this handler. ; Sets status to 0 on successful loading and -1 in case the library does not exist or in case of error. ; Definition at line 274 of file TPluginManager.cxx. ◆ operator=(). TPluginHandler & TPluginHandler::operator= ; (; const TPluginHandler & ; ). privatedelete . ◆ Print(). void TPluginHandler::Print ; (; Option_t * ; opt = """"); const. overridevirtual . Print info about the plugin handler. ; If option is ""a"" print also the ctor's that will be used. ; Reimplemented from TObject.; Definition at line 341 of file TPluginManager.cxx. ◆ SetupCallEnv(). void TPluginHandler::SetupCallEnv ; (; ). private . Setup ctor or static method call environment. ; Definition at line 198 of file TPluginManager.cxx. ◆ Stream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPluginHandler.html:17085,Load,Load,17085,doc/master/classTPluginHandler.html,https://root.cern,https://root.cern/doc/master/classTPluginHandler.html,1,['Load'],['Load']
Performance,"st. inlinevirtual . Reimplemented in TCling.; Definition at line 558 of file TInterpreter.h. ◆ IsProcessLineLocked(). virtual Bool_t TInterpreter::IsProcessLineLocked ; (; ); const. pure virtual . Implemented in TCling. ◆ IsSameType(). virtual Bool_t TInterpreter::IsSameType ; (; const void * ; , . const void * ;  . ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 553 of file TInterpreter.h. ◆ IsSignedIntegerType(). virtual Bool_t TInterpreter::IsSignedIntegerType ; (; const void * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 555 of file TInterpreter.h. ◆ IsUnsignedIntegerType(). virtual Bool_t TInterpreter::IsUnsignedIntegerType ; (; const void * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 556 of file TInterpreter.h. ◆ IsVoidPointerType(). virtual Bool_t TInterpreter::IsVoidPointerType ; (; const void * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 559 of file TInterpreter.h. ◆ Load(). virtual Int_t TInterpreter::Load ; (; const char * ; filenam, . Bool_t ; system = kFALSE . ). pure virtual . Implemented in TCling. ◆ LoadEnums(). virtual void TInterpreter::LoadEnums ; (; TListOfEnums & ; cl); const. pure virtual . Implemented in TCling. ◆ LoadFile(). virtual int TInterpreter::LoadFile ; (; const char * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 259 of file TInterpreter.h. ◆ LoadFunctionTemplates(). virtual void TInterpreter::LoadFunctionTemplates ; (; TClass * ; cl); const. pure virtual . Implemented in TCling. ◆ LoadLibraryMap(). virtual Int_t TInterpreter::LoadLibraryMap ; (; const char * ; rootmapfile = nullptr). pure virtual . Implemented in TCling. ◆ LoadMacro(). virtual void TInterpreter::LoadMacro ; (; const char * ; filename, . EErrorCode * ; error = nullptr . ). pure virtual . Implemented in TCling. ◆ LoadText(). virtual Bool_t TInterpreter::LoadText ; (; const char * ; ); const. inlinevirtual . Reimplemented in TCling.; D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTInterpreter.html:78311,Load,Load,78311,doc/master/classTInterpreter.html,https://root.cern,https://root.cern/doc/master/classTInterpreter.html,1,['Load'],['Load']
Performance,"st::TObjLinkPtr_t TList::NewOptLink(TObject *obj, Option_t *opt, const TObjLinkPtr_t &prev); 747{; 748 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 749 R__COLLECTION_WRITE_GUARD();; 750 ; 751 auto newlink = std::make_shared<TObjOptLink>(obj, opt);; 752 if (prev) {; 753 InsertAfter(newlink, prev);; 754 }; 755 return newlink;; 756}; 757 ; 758////////////////////////////////////////////////////////////////////////////////; 759/// Remove object from this collection and recursively remove the object; 760/// from all other objects (and collections).; 761 ; 762void TList::RecursiveRemove(TObject *obj); 763{; 764 // Note, we can assume that the Collection Read lock is held, see; 765 // THashList::RecursiveRemove for a more complete discussion.; 766 if (!obj || (fSize == 0 && fCache.expired())); 767 return;; 768 ; 769 R__COLLECTION_WRITE_GUARD();; 770 ; 771 // When fCache is set and has no previous and next node, it represents; 772 // the node being cleared and/or deleted.; 773 {; 774 auto cached = fCache.lock();; 775 if (cached && cached->fNext.get() == nullptr && cached->fPrev.lock().get() == nullptr) {; 776 TObject *ob = cached->GetObject();; 777 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 778 ob->RecursiveRemove(obj);; 779 }; 780 }; 781 }; 782 ; 783 auto lnk = fFirst;; 784 decltype(lnk) next;; 785 while (lnk.get()) {; 786 next = lnk->fNext;; 787 TObject *ob = lnk->GetObject();; 788 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 789 if (ob->IsEqual(obj)) {; 790 lnk->SetObject(nullptr);; 791 if (lnk == fFirst) {; 792 fFirst = next;; 793 if (lnk == fLast); 794 fLast = fFirst;; 795 else; 796 fFirst->fPrev.reset();; 797 // DeleteLink(lnk);; 798 } else if (lnk == fLast) {; 799 fLast = lnk->fPrev.lock();; 800 fLast->fNext.reset();; 801 // DeleteLink(lnk);; 802 } else {; 803 lnk->Prev()->fNext = next;; 804 lnk->Next()->fPrev = lnk->fPrev;; 805 // DeleteLink(lnk);; 806 }; 807 fSize--;; 808 fCache.reset();; 809 Changed();; 810 } else; 811 ob->RecursiveRemove(obj);; 812 }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:23828,cache,cached,23828,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,1,['cache'],['cached']
Performance,"st; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Special handling of integral of integral, return RooRealIntegral that represents integral over all dimensions in one pass. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealIntegral.html:37460,Perform,Perform,37460,root/html532/RooRealIntegral.html,https://root.cern,https://root.cern/root/html532/RooRealIntegral.html,1,['Perform'],['Perform']
Performance,"st; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* nset); Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. void setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); Activate caching of normalization integral values in a interpolated histogram; for integrals that exceed the specified minimum number of numerically integrated; dimensions, _and_ of which the integral has at most 2 parameters. The cache is scanned with a granularity defined by a binning named ""cache"" in the; scanned integral parameters and is interpolated to given order.; The cache values are kept for the livetime of the ROOT session/application; and are persisted along with the object in case the p.d.f. i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:43891,cache,cached,43891,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['cache'],['cached']
Performance,"st; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTMVA::MethodBase::MakeClass(const TString& classFileName = TString("""")) const; voidTObject::MayNotUse(const char* method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; virtual voidPrintNetwork() const; voidTMVA::Configurable::PrintOptions() const; virtual voidProcessOptions(); voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodANNBase.html:8906,Optimiz,OptimizeTuningParameters,8906,root/html530/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodANNBase.html,2,['Optimiz'],['OptimizeTuningParameters']
Performance,"st; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTMVA::MethodBase::MakeClass(const TString& classFileName = TString("""")) const; voidTObject::MayNotUse(const char* method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::RerouteTransformationHandler(TMVA::Transformatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodCompositeBase.html:9198,Optimiz,OptimizeTuningParameters,9198,root/html530/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodCompositeBase.html,2,['Optimiz'],['OptimizeTuningParameters']
Performance,"st; Return the label color number in the axis. Style_t GetLabelFont(Option_t* axis = ""X"") const; Return label font. Float_t GetLabelOffset(Option_t* axis = ""X"") const; Return label offset. Float_t GetLabelSize(Option_t* axis = ""X"") const; Return label size. const char * GetLineStyleString(Int_t i = 1) const; Return line style string (used by PostScript).; See SetLineStyleString for more explanations. Int_t GetNumberOfColors() const; Return number of colors in the color palette. void GetPaperSize(Float_t& xsize, Float_t& ysize) const; Set paper size for PostScript output. Float_t GetTickLength(Option_t* axis = ""X"") const; Return tick length. Color_t GetTitleColor(Option_t* axis = ""X"") const; Return title color. Style_t GetTitleFont(Option_t* axis = ""X"") const; Return title font. Float_t GetTitleOffset(Option_t* axis = ""X"") const; Return title offset. Float_t GetTitleSize(Option_t* axis = ""X"") const; Return title size. void Paint(Option_t* option = """"); Show the options from the current style; if (TClass::GetClass(""TStyleManager"")) gSystem->Load(""libGed"");. void SetColorModelPS(Int_t c = 0); Define the color model used by TPostScript and TPDF (RGB or CMYK).; CMY and CMYK models are subtractive color models unlike RGB which is; additive. They are mainly used for printing purposes. CMY means Cyan Magenta; Yellow. To convert RGB to CMY it is enough to do: C=1-R, M=1-G and Y=1-B.; CMYK has one more component K (black). The conversion from RGB to CMYK is:. Double_t Black = TMath::Min(TMath::Min(1-Red,1-Green),1-Blue);; Double_t Cyan = (1-Red-Black)/(1-Black);; Double_t Magenta = (1-Green-Black)/(1-Black);; Double_t Yellow = (1-Blue-Black)/(1-Black);. CMYK adds the black component which allows better quality for black; printing. PostScript and PDF support the CMYK model. c = 0 means TPostScript and TPDF will use RGB color model (default); c = 1 means TPostScript and TPDF will use CMYK color model. void SetHistMinimumZero(Bool_t zero = kTRUE); If the argument zero=kTRUE the m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyle.html:25227,Load,Load,25227,root/html528/TStyle.html,https://root.cern,https://root.cern/root/html528/TStyle.html,6,['Load'],['Load']
Performance,"st; Return value of object. Calculated if dirty, otherwise cached value is returned. Bool_t operator==(const char* ) const; Equality operator comparing with a TString. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t operator==(const RooAbsArg& other); Equality operator comparing to another RooAbsArg. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print value. Bool_t isValid() const; Check if current value is valid. Bool_t isValidString(const char* , Bool_t printError = kFALSE) const; Check if given string value is valid. Bool_t traceEvalHook(const char* value) const; Hook function for trace evaluation. const char* traceEval() const; Calculate current value of object, with error tracing wrapper. void syncCache(const RooArgSet* nset = 0); Forcibly bring internal cache up-to-date. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = kTRUE); Copy cache of another RooAbsArg to our cache. Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. void fillTreeBranch(TTree& t); Fill tree branch associated with this object. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooStringVar fundamental object with our properties. TString evaluate() const; { return """" ; }. void attachToVStore(RooVectorDataStore& ); {}. » Last changed: Tue Jun 2 15:27:32 2015 » Last generated: 2015-06-02 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsString.html:23596,cache,cache,23596,root/html604/RooAbsString.html,https://root.cern,https://root.cern/root/html604/RooAbsString.html,1,['cache'],['cache']
Performance,"st; Return value of object. Calculated if dirty, otherwise cached value is returned. Bool_t operator==(const char* ) const; Equality operator comparing with a TString. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t operator==(const RooAbsArg& other); Equality operator comparing to another RooAbsArg. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print value. Bool_t isValid() const; Check if current value is valid. Bool_t isValidString(const char* , Bool_t printError = kFALSE) const; Check if given string value is valid. Bool_t traceEvalHook(const char* value) const; Hook function for trace evaluation. const char* traceEval() const; Calculate current value of object, with error tracing wrapper. void syncCache(const RooArgSet* nset = 0); Forcibly bring internal cache up-to-date. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = kTRUE); Copy cache of another RooAbsArg to our cache. Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. void fillTreeBranch(TTree& t); Fill tree branch associated with this object. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooStringVar fundamental object with our properties. TString evaluate() const; { return """" ; }. void attachToVStore(RooVectorDataStore& ); {}. » Last changed: Tue Jun 30 14:30:34 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsString.html:23596,cache,cache,23596,root/html602/RooAbsString.html,https://root.cern,https://root.cern/root/html602/RooAbsString.html,1,['cache'],['cache']
Performance,"st; Return value of object. Calculated if dirty, otherwise cached value is returned. Bool_t operator==(const char* ) const; Equality operator comparing with a TString. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t operator==(const RooAbsArg& other); Equality operator comparing to another RooAbsArg. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print value. Bool_t isValid() const; Check if current value is valid. Bool_t isValidString(const char* , Bool_t printError = kFALSE) const; Check if given string value is valid. Bool_t traceEvalHook(const char* value) const; Hook function for trace evaluation. const char* traceEval() const; Calculate current value of object, with error tracing wrapper. void syncCache(const RooArgSet* nset = 0); Forcibly bring internal cache up-to-date. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = kTRUE); Copy cache of another RooAbsArg to our cache. Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. void fillTreeBranch(TTree& t); Fill tree branch associated with this object. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooStringVar fundamental object with our properties. TString evaluate() const; { return """" ; }. void attachToVStore(RooVectorDataStore& ); {}. » Last changed: Tue Mar 10 17:14:14 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsString.html:22014,cache,cache,22014,root/html534/RooAbsString.html,https://root.cern,https://root.cern/root/html534/RooAbsString.html,1,['cache'],['cache']
Performance,"st; TDirectory*TMVA::MethodBase::MethodBaseDir() const; TMVA::MethodFisherMethodFisher(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodFisherMethodFisher(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; voidPrintCoefficients(); virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& i); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::RerouteTransformationHandl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodFisher.html:11399,Optimiz,OptimizeTuningParameters,11399,root/html534/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodFisher.html,1,['Optimiz'],['OptimizeTuningParameters']
Performance,"st; const type_info*GetTypeInfo() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tHasDefaultConstructor() const; virtual ULong_tTNamed::Hash() const; voidIgnoreTObjectStreamer(Bool_t ignore = kTRUE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tInheritsFrom(const char* cl) const; virtual Bool_tInheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInterpretedShowMembers(void* obj, TMemberInspector& insp); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static TClass::ENewTypeIsCallingNew(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsFolder(void* obj) const; Bool_tIsForeign() const; Bool_tIsLoaded() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tIsStartingWithTObject() const; Bool_tIsTObject() const; Bool_tTObject::IsZombie() const; static TClass*Load(TBuffer& b); virtual voidls(Option_t* opt = """") const; voidMakeCustomMenuList(); voidTObject::MayNotUse(const char* method) const; voidMove(void* arenaFrom, void* arenaTo) const; void*New(TClass::ENewType defConstructor = kClassNew) const; void*New(void* arena, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:7774,Load,Load,7774,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,1,['Load'],['Load']
Performance,"st; const type_info*GetTypeInfo() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tHasDefaultConstructor() const; virtual ULong_tTNamed::Hash() const; voidIgnoreTObjectStreamer(Bool_t ignore = kTRUE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tInheritsFrom(const char* cl) const; virtual Bool_tInheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInterpretedShowMembers(void* obj, TMemberInspector& insp); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static TClass::ENewTypeIsCallingNew(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsFolder(void* obj) const; Bool_tIsForeign() const; Bool_tIsLoaded() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tIsStartingWithTObject() const; Bool_tIsTObject() const; Bool_tTObject::IsZombie() const; static TClass*Load(TBuffer& b); virtual voidls(Option_t* opt = """") const; voidMakeCustomMenuList(); voidTObject::MayNotUse(const char* method) const; voidMove(void* arenaFrom, void* arenaTo) const; void*New(TClass::ENewType defConstructor = kClassNew) const; void*New(void* arena, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TClass.html:7809,Load,Load,7809,root/html530/TClass.html,https://root.cern,https://root.cern/root/html530/TClass.html,2,['Load'],['Load']
Performance,"st; evaluate the derivative of the function with respect to the parameters. double DoDerivative(double x) const; return the function derivatives w.r.t. x. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const; evaluate the derivative of the function with respect to the parameters; IMPORTANT NOTE: TF1::GradientPar returns 0 for fixed parameters to avoid computing useless derivatives; BUT the TLinearFitter wants to have the derivatives also for fixed parameters.; so in case of fLinear (or fPolynomial) a non-zero value will be returned for fixed parameters. void SetDerivPrecision(double eps); { fgEps = eps; }. double GetDerivPrecision(); { return fgEps; }. virtual ~WrappedTF1(). Destructor (no operations). TF1 Function pointer is not owned. {}. ROOT::Math::IGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cachen inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (this is stored in TF1). void FdF(double x, double& f, double& deriv) const; calculate function and derivative at same time (required by IGradient interface). double DoEvalPar(double x, const double* p) const; evaluate function passing coordinates x and vector of parameters. double DoEval(double x) const; evaluate function using the cached parameter values of this class (not of TF1); re-implement for better efficiency. » Author: L. Moneta Wed Sep 6 09:52:26 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-06-30 14:27; This page has been automatically generated. For comments or sugges",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__WrappedTF1.html:5056,cache,cachen,5056,root/html602/ROOT__Math__WrappedTF1.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__WrappedTF1.html,1,['cache'],['cachen']
Performance,"st; evaluate the derivative of the function with respect to the parameters. double DoDerivative(double x) const; return the function derivatives w.r.t. x. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const; evaluate the derivative of the function with respect to the parameters; IMPORTANT NOTE: TF1::GradientPar returns 0 for fixed parameters to avoid computing useless derivatives; BUT the TLinearFitter wants to have the derivatives also for fixed parameters.; so in case of fLinear (or fPolynomial) a non-zero value will be returned for fixed parameters. void SetDerivPrecision(double eps); { fgEps = eps; }. double GetDerivPrecision(); { return fgEps; }. virtual ~WrappedTF1(). Destructor (no operations). TF1 Function pointer is not owned. {}. ROOT::Math::IGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cachen inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values; need to call also SetParameters in TF1 in ace some other operations (re-normalizations) are needed. unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (this is stored in TF1). void FdF(double x, double& f, double& deriv) const; calculate function and derivative at same time (required by IGradient interface). double DoEvalPar(double x, const double* p) const; evaluate function passing coordinates x and vector of parameters. double DoEval(double x) const; evaluate function using the cached parameter values (of TF1); re-implement for better efficiency. » Author: L. Moneta Wed Sep 6 09:52:26 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__WrappedTF1.html:5078,cache,cachen,5078,root/html604/ROOT__Math__WrappedTF1.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__WrappedTF1.html,1,['cache'],['cachen']
Performance,"st; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidapplyNLLWeightSquared(Bool_t flag); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidcalculate() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealMPFE.html:2905,Cache,CacheModeRooAbsArg,2905,root/html602/RooRealMPFE.html,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html,2,['Cache'],['CacheModeRooAbsArg']
Performance,"st; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tGetClassSize() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; ROOT::ESTLTypeGetCollectionType() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tGetConvStreamerFunc() const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataMember*GetDataMember(const char* datamember) const; Long_tGetDataMemberOffset(const char* membern",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClass.html:5139,load,load,5139,root/html604/TClass.html,https://root.cern,https://root.cern/root/html604/TClass.html,1,['load'],['load']
Performance,"st; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tGetClassSize() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tGetConvStreamerFunc() const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataMember*GetDataMember(const char* datamember) const; Long_tGetDataMemberOffset(const char* membername) const; Short_tGetDeclFileLine() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:4542,load,load,4542,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,1,['load'],['load']
Performance,"st; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tTClass::GetCheckSum(Bool_t& isvalid) const; UInt_tTClass::GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tTClass::GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() const; TMethod*TClass::GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*TClass::GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tTClass::GetClassSize() const; Version_tTClass::GetClassVersion() const; TVirtualCollectionProxy*TClass::GetCollectionProxy() const; ROOT::ESTLTypeTClass::GetCollectionType() const; const char*TClass::GetContextMenuTitle() const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TQClass.html:7505,load,load,7505,root/html604/TQClass.html,https://root.cern,https://root.cern/root/html604/TQClass.html,1,['load'],['load']
Performance,"st; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tTClass::GetCheckSum(Bool_t& isvalid) const; UInt_tTClass::GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tTClass::GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() const; TMethod*TClass::GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*TClass::GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tTClass::GetClassSize() const; Version_tTClass::GetClassVersion() const; TVirtualCollectionProxy*TClass::GetCollectionProxy() const; const char*TClass::GetContextMenuTitle() const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tTClass::GetConvStreamerFunc() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQClass.html:7505,load,load,7505,root/html602/TQClass.html,https://root.cern,https://root.cern/root/html602/TQClass.html,1,['load'],['load']
Performance,"st; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo position = kBeg); virtual voidSetAsyncOpenStatus(TFile::EAsyncOpenStatus status); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetXNGFile.html:12283,cache,cache,12283,root/html534/TNetXNGFile.html,https://root.cern,https://root.cern/root/html534/TNetXNGFile.html,3,['cache'],['cache']
Performance,"st; virtual voidTFormula::GetParameters(Double_t* params); virtual const char*TFormula::GetParName(Int_t ipar) const; virtual Int_tTFormula::GetParNumber(const char* name) const; virtual const char*TNamed::GetTitle() const; virtual TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsInteger(Bool_t fast = kTRUE) const; virtual Bool_tTFormula::IsLinear(); virtual Bool_tTFormula::IsNormalized(); Bool_tTObject::IsOnHeap() const; Bool_tIsQuickLoad() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsString() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); voidTFormula::Optimize(); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTFormula::Print(Option_t* option = """") constMENU ; virtual char*PrintValue(Int_t mode = 0) const; virtual char*PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeFormula.html:6606,Optimiz,Optimize,6606,root/html530/TTreeFormula.html,https://root.cern,https://root.cern/root/html530/TTreeFormula.html,3,['Optimiz'],['Optimize']
Performance,"st; voidTObject::MakeZombie(). private:. TCint(); TCint(const TCint&); virtual voidExecute(TMethod*, TObjArray*, int* = 0); TCint&operator=(const TCint&). Data Members; public:. enum TInterpreter::EErrorCode { kNoError; kRecoverable; kDangerous; kFatal; kProcessing; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. G__dictpositionfDictPosCINT dictionary context after init; G__dictpositionfDictPosGlobalsCINT dictionary context after ResetGlobals(); Int_tfExitCodevalue passed to exit() in interpreter; TStringfIncludePathlist of CINT include paths; Bool_tfLockProcessLinetrue if ProcessLine should lock gCINTMutex; TEnv*fMapfilemap of classes and libraries; Int_tfMore1 if more input is required; charfPrompt[64]proposed prompt string; TObjArray*fRootmapFileslist of non-default rootmap files loaded; TStringfRootmapLoadPathdynamic load path used for loading rootmap files; TStringfSharedLibslist of shared libraries loaded by G__loadfile; Int_tfSharedLibsSerialIndicator of the last time we set fSharedLibs; static void*fgSetOfSpecialsset of TObject*s used in CINT variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCint(const char* name, const char* title); Initialize the CINT interpreter interface. ~TCint(); Destroy the CINT interpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableAutoLoading(); Enable the automatic loading of shar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TCint.html:19119,load,loaded,19119,root/html528/TCint.html,https://root.cern,https://root.cern/root/html528/TCint.html,8,['load'],"['load', 'loaded', 'loading']"
Performance,"st;  ; Int_t GetStop () const;  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print the content of this object. ;  ; void Run (const char *dset, Int_t start, Int_t stop, Int_t step, Int_t ntries, Int_t debug, Int_t) override;  Run benchmark Input parameters dset: Dataset on which to run start: Start scan with 'start' workers. ;  ; void Run (Long64_t, Int_t, Int_t, Int_t, Int_t, Int_t, Int_t) override;  ; void SetDebug (Int_t debug);  ; void SetDirProofBench (TDirectory *dir);  ; void SetFilesPerWrk (Int_t fpw);  ; void SetNEvents (Long64_t nevents);  ; void SetNTries (Int_t ntries);  ; void SetReadType (TPBReadType *readtype);  ; void SetReleaseCache (Bool_t on=kTRUE);  ; void SetStart (Int_t start);  ; void SetStep (Int_t step);  ; void SetStop (Int_t stop);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofBenchRun;  TProofBenchRun (TProof *proof=0, const char *sel=0);  Constructor: check PROOF and load selectors PAR. ;  ;  ~TProofBenchRun () override;  destructor ;  ; virtual const char * GetParList ();  ; virtual const char * GetSelName ();  ; virtual void SetParList (const char *pars);  ; virtual void SetSelName (const char *sel);  ; virtual void SetSelOption (const char *opt);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t Ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofBenchRunDataRead.html:2737,load,load,2737,doc/master/classTProofBenchRunDataRead.html,https://root.cern,https://root.cern/doc/master/classTProofBenchRunDataRead.html,1,['load'],['load']
Performance,"st;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooObjCacheManager _cacheMgr;  ; RooListProxy _compCSet;  ; RooListProxy _compRSet;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProduct.html:54942,cache,cached,54942,doc/master/classRooProduct.html,https://root.cern,https://root.cern/doc/master/classRooProduct.html,1,['cache'],['cached']
Performance,"st;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; bool _cdfBoundaries = false;  Use boundary conditions for CDFs. ;  ; RooAICRegistry _codeReg;  ! Auxiliary class keeping tracking of analytical integration code ;  ; RooDataHist * _dataHist = nullptr;  Unowned pointer to underl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:55771,cache,cached,55771,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,1,['cache'],['cached']
Performance,"st;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from TEveElement; static const char * ToString (Bool_t b);  Convert Bool_t to string - kTRUE or kFALSE. ;  . #include <TEveCaloData.h>. Inheritance diagram for TEveCaloDataHist:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TEveCaloDataHist() [1/2]. TEveCaloDataHist::TEveCaloDataHist ; (; const TEveCaloDataHist & ; ). private . ◆ TEveCaloDataHist() [2/2]. TEveCaloDataHist::TEveCaloDataHist ; (; ). Constructor. ; Definition at line 739 of file TEveCaloData.cxx. ◆ ~TEveCaloDataHist(). TEveCaloDataHist::~TEveCaloDataHist ; (; ). override . Destructor. ; Definition at line 751 of file TEveCaloData.cxx. Member Function Documentation. ◆ AddHistogram(). Int_t TEveCaloDataHist::AddHistogram ; (; TH2F * ; hist). Add new slice to calo tower. ; Updates cached variables fMaxValE and fMaxValEt Return last index in the vector of slice infos. ; Definition at line 900 of file TEveCaloData.cxx. ◆ Class(). static TClass * TEveCaloDataHist::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TEveCaloDataHist::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TEveCaloDataHist::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 329 of file TEveCaloData.h. ◆ DataChanged(). void TEveCaloDataHist::DataChanged ; (; ). overridevirtual . Update limits and notify data users. ; Reimplemented from TEveCaloData.; Definition at line 759 of file TEveCaloData.cxx. ◆ DeclFileName(). static const char * TEveCaloDataHist::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 329 of file TEveCaloData.h. ◆ GetCellData(). void TEveCaloDataHist::GetCellData ; (; const TEveCaloData::CellId_t & ; id, . T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCaloDataHist.html:34515,cache,cached,34515,doc/master/classTEveCaloDataHist.html,https://root.cern,https://root.cern/doc/master/classTEveCaloDataHist.html,1,['cache'],['cached']
Performance,"st;  get index number for a given daughter ;  ; TGeoMaterial * GetMaterial () const;  ; TGeoMedium * GetMedium () const;  ; Int_t GetNdaughters () const;  ; virtual Int_t GetNextNodeIndex () const;  ; TGeoNode * GetNode (const char *name) const;  get the pointer to a daughter node ;  ; TGeoNode * GetNode (Int_t i) const;  ; Int_t GetNodeIndex (const TGeoNode *node, Int_t *check_list, Int_t ncheck) const;  Get the index of a daughter within check_list by providing the node pointer. ;  ; TObjArray * GetNodes ();  ; Int_t GetNtotal () const;  ; Int_t GetNumber () const;  ; char * GetObjectInfo (Int_t px, Int_t py) const override;  Get volume info for the browser. ;  ; Bool_t GetOptimalVoxels () const;  Returns true if cylindrical voxelization is optimal. ;  ; Option_t * GetOption () const override;  ; const char * GetPointerName () const;  Provide a pointer name containing uid. ;  ; Int_t GetRefCount () const;  ; TGeoShape * GetShape () const;  ; Char_t GetTransparency () const;  ; TGeoExtension * GetUserExtension () const;  ; TGeoVoxelFinder * GetVoxels () const;  Getter for optimization structure. ;  ; void Grab ();  ; void GrabFocus ();  Move perspective view focus to this volume. ;  ; TGeoExtension * GrabFWExtension () const;  Get a copy of the framework extension pointer. ;  ; TGeoExtension * GrabUserExtension () const;  Get a copy of the user extension pointer. ;  ; void Gsord (Int_t);  ; void InspectMaterial () const;  Inspect the material for this volume. ;  ; void InspectShape () const;  ; void InvisibleAll (Bool_t flag=kTRUE);  Make volume and each of it daughters (in)visible. ;  ; Bool_t IsActive () const;  ; Bool_t IsActiveDaughters () const;  ; Bool_t IsAdded () const;  ; Bool_t IsAllInvisible () const;  Return TRUE if volume and all daughters are invisible. ;  ; virtual Bool_t IsAssembly () const;  Returns true if the volume is an assembly or a scaled assembly. ;  ; Bool_t IsCylVoxels () const;  ; Bool_t IsFolder () const override;  Return TRUE if volume ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeMulti.html:14737,optimiz,optimization,14737,doc/master/classTGeoVolumeMulti.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeMulti.html,1,['optimiz'],['optimization']
Performance,"st;  get index number for a given daughter ;  ; TGeoMaterial * GetMaterial () const;  ; TGeoMedium * GetMedium () const;  ; Int_t GetNdaughters () const;  ; virtual Int_t GetNextNodeIndex () const;  ; TGeoNode * GetNode (const char *name) const;  get the pointer to a daughter node ;  ; TGeoNode * GetNode (Int_t i) const;  ; Int_t GetNodeIndex (const TGeoNode *node, Int_t *check_list, Int_t ncheck) const;  Get the index of a daughter within check_list by providing the node pointer. ;  ; TObjArray * GetNodes ();  ; Int_t GetNtotal () const;  ; Int_t GetNumber () const;  ; char * GetObjectInfo (Int_t px, Int_t py) const override;  Get volume info for the browser. ;  ; Bool_t GetOptimalVoxels () const;  Returns true if cylindrical voxelization is optimal. ;  ; Option_t * GetOption () const override;  ; const char * GetPointerName () const;  Provide a pointer name containing uid. ;  ; Int_t GetRefCount () const;  ; TGeoShape * GetShape () const;  ; Char_t GetTransparency () const;  ; TGeoExtension * GetUserExtension () const;  ; TGeoVoxelFinder * GetVoxels () const;  Getter for optimization structure. ;  ; void Grab ();  ; void GrabFocus ();  Move perspective view focus to this volume. ;  ; TGeoExtension * GrabFWExtension () const;  Get a copy of the framework extension pointer. ;  ; TGeoExtension * GrabUserExtension () const;  Get a copy of the user extension pointer. ;  ; void Gsord (Int_t);  ; void InspectMaterial () const;  Inspect the material for this volume. ;  ; void InspectShape () const;  ; void InvisibleAll (Bool_t flag=kTRUE);  Make volume and each of it daughters (in)visible. ;  ; TClass * IsA () const override;  ; Bool_t IsActive () const;  ; Bool_t IsActiveDaughters () const;  ; Bool_t IsAdded () const;  ; Bool_t IsAllInvisible () const;  Return TRUE if volume and all daughters are invisible. ;  ; virtual Bool_t IsAssembly () const;  Returns true if the volume is an assembly or a scaled assembly. ;  ; Bool_t IsCylVoxels () const;  ; Bool_t IsFolder () cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:18047,optimiz,optimization,18047,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['optimiz'],['optimization']
Performance,"st<TClass*>(this)->GetBaseClassOffsetRecurse(TObject::Class());; 2192 if (fStreamerType == kTObject) {; 2193 fStreamerImpl = &TClass::StreamerTObjectInitialized;; 2194 }; 2195 fIsOffsetStreamerSet = kTRUE;; 2196 }; 2197}; 2198 ; 2199 ; 2200////////////////////////////////////////////////////////////////////////////////; 2201/// Call ShowMembers() on the obj of this class type, passing insp and parent.; 2202/// isATObject is -1 if unknown, 0 if it is not a TObject, and 1 if it is a TObject.; 2203/// The function returns whether it was able to call ShowMembers().; 2204 ; 2205Bool_t TClass::CallShowMembers(const void* obj, TMemberInspector &insp, Bool_t isTransient) const; 2206{; 2207 if (fShowMembers) {; 2208 // This should always works since 'pointer' should be pointing; 2209 // to an object of the actual type of this TClass object.; 2210 fShowMembers(obj, insp, isTransient);; 2211 return kTRUE;; 2212 } else {; 2213 ; 2214 if (fCanLoadClassInfo) LoadClassInfo();; 2215 if (fClassInfo) {; 2216 ; 2217 if (strcmp(GetName(), ""string"") == 0) {; 2218 // For std::string we know that we do not have a ShowMembers; 2219 // function and that it's okay.; 2220 return kTRUE;; 2221 }; 2222 // Since we do have some dictionary information, let's; 2223 // call the interpreter's ShowMember.; 2224 // This works with Cling to support interpreted classes.; 2225 gInterpreter->InspectMembers(insp, obj, this, isTransient);; 2226 return kTRUE;; 2227 ; 2228 } else if (TVirtualStreamerInfo* sinfo = GetStreamerInfo()) {; 2229 sinfo->CallShowMembers(obj, insp, isTransient);; 2230 return kTRUE;; 2231 } // isATObject; 2232 } // fShowMembers is set; 2233 ; 2234 return kFALSE;; 2235}; 2236 ; 2237////////////////////////////////////////////////////////////////////////////////; 2238/// Do a ShowMembers() traversal of all members and base classes' members; 2239/// using the reflection information from the interpreter. Works also for; 2240/// interpreted objects.; 2241 ; 2242void TClass::InterpretedShowMe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:83745,Load,LoadClassInfo,83745,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['Load'],['LoadClassInfo']
Performance,"st<TClass*>(this)->GetBaseClassOffsetRecurse(TObject::Class());; 2259 if (fStreamerType == kTObject) {; 2260 fStreamerImpl = &TClass::StreamerTObjectInitialized;; 2261 }; 2262 fIsOffsetStreamerSet = kTRUE;; 2263 }; 2264}; 2265 ; 2266 ; 2267////////////////////////////////////////////////////////////////////////////////; 2268/// Call ShowMembers() on the obj of this class type, passing insp and parent.; 2269/// isATObject is -1 if unknown, 0 if it is not a TObject, and 1 if it is a TObject.; 2270/// The function returns whether it was able to call ShowMembers().; 2271 ; 2272Bool_t TClass::CallShowMembers(const void* obj, TMemberInspector &insp, Bool_t isTransient) const; 2273{; 2274 if (fShowMembers) {; 2275 // This should always works since 'pointer' should be pointing; 2276 // to an object of the actual type of this TClass object.; 2277 fShowMembers(obj, insp, isTransient);; 2278 return kTRUE;; 2279 } else {; 2280 ; 2281 if (fCanLoadClassInfo) LoadClassInfo();; 2282 if (fClassInfo) {; 2283 ; 2284 if (strcmp(GetName(), ""string"") == 0) {; 2285 // For std::string we know that we do not have a ShowMembers; 2286 // function and that it's okay.; 2287 return kTRUE;; 2288 }; 2289 // Since we do have some dictionary information, let's; 2290 // call the interpreter's ShowMember.; 2291 // This works with Cling to support interpreted classes.; 2292 gInterpreter->InspectMembers(insp, obj, this, isTransient);; 2293 return kTRUE;; 2294 ; 2295 } else if (TVirtualStreamerInfo* sinfo = GetStreamerInfo()) {; 2296 sinfo->CallShowMembers(obj, insp, isTransient);; 2297 return kTRUE;; 2298 } // isATObject; 2299 } // fShowMembers is set; 2300 ; 2301 return kFALSE;; 2302}; 2303 ; 2304////////////////////////////////////////////////////////////////////////////////; 2305/// Do a ShowMembers() traversal of all members and base classes' members; 2306/// using the reflection information from the interpreter. Works also for; 2307/// interpreted objects.; 2308 ; 2309void TClass::InterpretedShowMe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:86496,Load,LoadClassInfo,86496,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['Load'],['LoadClassInfo']
Performance,"stBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; const char*TApplication::WorkingDirectory() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static voidTApplication::Close(TApplication* app); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTApplication::Help(const char* line); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). private:. Int_tBroadcast(const TMessage& mess); Int_tBroadcast(Int_t kind, Int_t type = kRRT_Undef); Int_tBroadcast(const char* mess, Int_t kind = kMESS_STRING, Int_t type = kRRT_Undef); Int_tBroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Int_tBroadcastRaw(const void* buffer, Int_t length); Bool_tCheckFile(const char* file, Long_t modtime); Int_tCollect(Long_t tim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TApplicationRemote.html:11174,Load,LoadGraphicsLibs,11174,root/html602/TApplicationRemote.html,https://root.cern,https://root.cern/root/html602/TApplicationRemote.html,2,['Load'],['LoadGraphicsLibs']
Performance,"stFromFile::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TEntryList.; Definition at line 97 of file TEntryListFromFile.h. ◆ LoadList(). Int_t TEntryListFromFile::LoadList ; (; Int_t ; listnumber). virtual . Loads the list #listnumber This is the only function that can modify fCurrent and fFile data members. ; Definition at line 231 of file TEntryListFromFile.cxx. ◆ Merge(). Int_t TEntryListFromFile::Merge ; (; TCollection * ; list). inlineoverridevirtual . Merge this list with the lists from the collection. ; Reimplemented from TEntryList.; Definition at line 82 of file TEntryListFromFile.h. ◆ Next(). Long64_t TEntryListFromFile::Next ; (; ). overridevirtual . Returns the next entry in the list. ; Faster than GetEntry() ; Reimplemented from TEntryList.; Definition at line 184 of file TEntryListFromFile.cxx. ◆ operator=(). TEntryListFromFile & TEntryListFromFile::operator= ; (; const TEntryListFromFile & ; ). private . ◆ OptimizeStorage(). void TEntryListFromFile::OptimizeStorage ; (; ). inlineoverridevirtual . Checks if the array representation is more economical and if so, switches to it. ; Reimplemented from TEntryList.; Definition at line 85 of file TEntryListFromFile.h. ◆ Print(). void TEntryListFromFile::Print ; (; const Option_t * ; option = """"); const. override . Print info about this list. ; Definition at line 305 of file TEntryListFromFile.cxx. ◆ Remove(). bool TEntryListFromFile::Remove ; (; Long64_t ; entry, . TTree * ; tree . ). inlineoverridevirtual . Remove entry #entry from the list. . When tree = 0, removes from the current list; When tree != 0, finds the list, corresponding to this tree; When tree is a chain, the entry is assumed to be global index and the local entry is recomputed from the treeoffset information of the chain . Reimplemented from TEntryList.; Definition at line 86 of file TEntryListFromFile.h. ◆ SetFileNames(). virtual void TEntryListFromFile::SetFileNames ; (; TObjArray * ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryListFromFile.html:26930,Optimiz,OptimizeStorage,26930,doc/master/classTEntryListFromFile.html,https://root.cern,https://root.cern/doc/master/classTEntryListFromFile.html,1,['Optimiz'],['OptimizeStorage']
Performance,"stMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TProofLimitsFinder&operator=(const TProofLimitsFinder&); static voidTHLimitsFinder::Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BWID, Option_t* option = """"); static voidTHLimitsFinder::OptimizeLimits(Int_t nbins, Int_t& newbins, Double_t& xmin, Double_t& xmax, Bool_t isInteger); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTHLimitsFinder::SetLimitsFinder(THLimitsFinder* finder); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofLimitsFinder.html:4023,Optimiz,Optimize,4023,root/html530/TProofLimitsFinder.html,https://root.cern,https://root.cern/root/html530/TProofLimitsFinder.html,3,['Optimiz'],['Optimize']
Performance,"stNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,unsigned int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction2Ref<VO,VI1,VI2> Streamer(TBuffer& ); Custom streamer for funct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction2Binding_double_unsigned_int_double_.html:35314,cache,cache,35314,root/html534/RooCFunction2Binding_double_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html534/RooCFunction2Binding_double_unsigned_int_double_.html,2,['cache'],['cache']
Performance,"stNSet!; RooMinuit*_minuit! Internal minuit instance; static Int_tRooPrintable::_nameLength; RooRealProxy_nllInput -log(L) function; RooSetProxy_obsParameters of profile likelihood; RooArgSet_obsAbsMinObservable values at absolute minimum; TIterator*_oiter! Iterator of profile likelihood output parameter(s); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_parMarginialized parameters of likelihood; RooArgSet_paramAbsMinParameter values at absolute minimum; map<std::string,bool>_paramFixedParameter constant status at last time of use; TIterator*_piter! Iterator over profile likelihood parameters to be minimized ; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_startFromMinAlways start minimization for global minimum?; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProfileLL.html:32983,cache,cache,32983,root/html526/RooProfileLL.html,https://root.cern,https://root.cern/root/html526/RooProfileLL.html,2,['cache'],['cache']
Performance,"stProxies = kTRUE) const; Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooResolutionModel::traceEvalHook(Double_t value) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooGaussBasis { noBasis; expBasisMinus; expBasisSum; expBasisPlus; sinBasisMinus; sinBasisSum; sinBasisPlus; cosBasisMinus; cosBasisSum; cosBasisPlus; linBasisPlus; quadBasisPlus; coshBasisMinus; coshBasisSum; coshBasisPlus; sinhBasisMinus; sinhBasisSum; sinhBasisPlus; };; enum BasisType { none; expBasis; sinBasis; cosBasis; linBasis; quadBasis; coshBasis; sinhBasis; };; enum BasisSign { Both; Plus; Minus; };; enum RooAbsPdf::ExtendMode { CanNotBeExtended; CanBeExtended; MustBeExtended; };; enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. Bool_t_asympIntadded FMV,07/24/03; RooFor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGaussModel.html:39885,Cache,CacheMode,39885,root/html534/RooGaussModel.html,https://root.cern,https://root.cern/root/html534/RooGaussModel.html,1,['Cache'],['CacheMode']
Performance,"stReturns the integer value for a resource.Definition TEnv.cxx:491; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TObjectMother of all ROOT objects.Definition TObject.h:41; TPluginHandlerDefinition TPluginManager.h:103; TStringBasic string class.Definition TString.h:139; TVirtualFitterAbstract Base Class for Fitting.Definition TVirtualFitter.h:29; TVirtualFitter::fOptionFoption_t fOptionStruct with the fit options.Definition TVirtualFitter.h:32; TVirtualFitter::SetDefaultFitterstatic void SetDefaultFitter(const char *name="""")static: set name of default fitterDefinition TVirtualFitter.cxx:245; TVirtualFitter::SetPrecisionstatic void SetPrecision(Double_t prec=1e-6)static: Set the tolerance used in the minimization algorithm For example for MIGRAD this is tolerance...Definition TVirtualFitter.cxx:323; TVirtualFitter::fPointSizeInt_t fPointSizeNumber of words per point in the cache.Definition TVirtualFitter.h:40; TVirtualFitter::GetConfidenceIntervalsvirtual void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t *x, Double_t *ci, Double_t cl=0.95)return confidence intervals in array x of dimension ndim implemented in TFitter and TLinearFitterDefinition TVirtualFitter.cxx:185; TVirtualFitter::fUserFuncTObject * fUserFuncPointer to user theoretical function (a TF1*)Definition TVirtualFitter.h:44; TVirtualFitter::fMethodCallTMethodCall * fMethodCallPointer to MethodCall in case of interpreted function.Definition TVirtualFitter.h:45; TVirtualFitter::GetMaxIterationsstatic Int_t GetMaxIterations()static: Return the maximum number of iterations actually max number of function callsDefinition TVirtualFitter.cxx:218; TVirtualFitter::GetPrecisionstatic Double_t GetPrecision()static: Return the fit relative precisionDefinition TVirtualFitter.cxx:236; TVirtualFitter::fYlastInt_t fYlastLast bin on Y axis.Definition TVirtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html:13453,cache,cache,13453,doc/master/TVirtualFitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html,1,['cache'],['cache']
Performance,stStatistic::_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_optimized!; RooAbsData*RooAbsOptTestStatistic::_origDataOriginal data ; RooAbsReal*RooAbsOptTestStatistic::_origFuncOriginal function ; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooA,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooXYChi2Var.html:40946,cache,cache,40946,root/html534/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html534/RooXYChi2Var.html,1,['cache'],['cache']
Performance,"stalled). ;  ; virtual void SetMsgReadBuffer10 (const char *redirectLocation=nullptr, Bool_t tempRedirect=kFALSE);  Set GET command for use by ReadBuffer(s)10(), handle redirection if needed. ;  ;  Protected Member Functions inherited from TFile; virtual Long64_t DirCreateEntry (TDirectory *);  ; virtual Int_t DirReadKeys (TDirectory *);  ; virtual void DirWriteHeader (TDirectory *);  ; virtual void DirWriteKeys (TDirectory *);  ; Bool_t FlushWriteCache ();  Flush the write cache if active. ;  ; virtual EAsyncOpenStatus GetAsyncOpenStatus ();  ; virtual InfoListRet GetStreamerInfoListImpl (bool lookupSICache);  See documentation of GetStreamerInfoList for more details. ;  ; Int_t MakeProjectParMake (const char *packname, const char *filename);  Create makefile at 'filemake' for PAR package 'pack'. ;  ; Int_t MakeProjectParProofInf (const char *packname, const char *proofinfdir);  Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'. ;  ; Int_t ReadBufferViaCache (char *buf, Int_t len);  Read buffer via cache. ;  ; virtual Int_t SysClose (Int_t fd);  Interface to system close. All arguments like in POSIX close(). ;  ; virtual Int_t SysOpen (const char *pathname, Int_t flags, UInt_t mode);  Interface to system open. All arguments like in POSIX open(). ;  ; virtual Int_t SysRead (Int_t fd, void *buf, Int_t len);  Interface to system read. All arguments like in POSIX read(). ;  ; virtual Long64_t SysSeek (Int_t fd, Long64_t offset, Int_t whence);  Interface to system lseek. ;  ; virtual Int_t SysStat (Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime);  Return file stat information. ;  ; virtual Int_t SysSync (Int_t fd);  Interface to system fsync. All arguments like in POSIX fsync(). ;  ; virtual Int_t SysWrite (Int_t fd, const void *buf, Int_t len);  Interface to system write. All arguments like in POSIX write(). ;  ; Int_t WriteBufferViaCache (const char *buf, Int_t len);  Write buffer via cache. ;  ;  Protected Member Functions inhe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebFile.html:32000,cache,cache,32000,doc/master/classTWebFile.html,https://root.cern,https://root.cern/doc/master/classTWebFile.html,1,['cache'],['cache']
Performance,"stamp_t fSendStamp; ///<! last server operation, always used from window thread; 78 bool fActive{false}; ///<! flag indicates if connection is active; 79 unsigned fWSId{0}; ///<! websocket id; 80 int fReady{0}; ///<! 0 - not ready, 1..9 - interim, 10 - done; 81 mutable std::mutex fMutex; ///<! mutex must be used to protect all following data; 82 timestamp_t fRecvStamp; ///<! last receive operation, protected with connection mutex; 83 int fRecvCount{0}; ///<! number of received packets, should return back with next sending; 84 int fSendCredits{0}; ///<! how many send operation can be performed without confirmation from other side; 85 int fClientCredits{0}; ///<! number of credits received from client; 86 bool fDoingSend{false}; ///<! true when performing send operation; 87 unsigned long fRecvSeq{0}; ///<! sequence id of last received packet; 88 unsigned long fSendSeq{1}; ///<! sequence id of last send packet; 89 std::queue<QueueItem> fQueue; ///<! output queue; 90 std::map<int,std::shared_ptr<RWebWindow>> fEmbed; ///<! map of embed window for that connection, key value is channel id; 91 WebConn() = default;; 92 WebConn(unsigned connid) : fConnId(connid) {}; 93 WebConn(unsigned connid, unsigned wsid) : fConnId(connid), fActive(true), fWSId(wsid) {}; 94 WebConn(unsigned connid, bool headless_mode, const std::string &key); 95 : fConnId(connid), fHeadlessMode(headless_mode), fKey(key); 96 {; 97 ResetStamps();; 98 }; 99 ~WebConn();; 100 ; 101 void ResetStamps() { fSendStamp = fRecvStamp = std::chrono::system_clock::now(); }; 102 ; 103 void ResetData(); 104 {; 105 fActive = false;; 106 fWSId = 0;; 107 fReady = 0;; 108 fDoingSend = false;; 109 fSendCredits = 0;; 110 fClientCredits = 0;; 111 fRecvSeq = 0;; 112 fSendSeq = 1;; 113 while (!fQueue.empty()); 114 fQueue.pop();; 115 }; 116 };; 117 ; 118 struct MasterConn {; 119 unsigned connid{0};; 120 int channel{-1};; 121 MasterConn(unsigned _connid, int _channel) : connid(_connid), channel(_channel) {}; 122 };; 123 ; 124 enum EQ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:3692,perform,performed,3692,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,5,"['Queue', 'perform', 'queue']","['QueueItem', 'performed', 'performing', 'queue']"
Performance,"standard deviation in Y is zero.; In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; 1./SQRT(12*N).; This approximation assumes that the Y values are integer (e.g. ADC counts); and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12). 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin J; W is obtained as from TProfile::GetBinEntries(ibin); This errors corresponds to the standard deviation of weighted mean where each; measurement Y is uncorrelated and has an error sigma, which is expressed in the; weight used to fill the Profile: w = 1/sigma^2; The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ). TProfile(const TProfile& profile); Copy constructor. Bool_t Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1. Bool_t Add(const TH1* h1, Double_t c1 = 1); Performs the operation: this = this + c1*h1. Bool_t Add(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); -*-*Replace contents of this profile by the addition of h1 and h2; *-* =============================================================. this = c1*h1 + c2*h2. c1 and c2 are considered as weights applied to the two summed profiles.; The operation acts therefore like merging the two profiles with a weight c1 and c2. void Approximate(Bool_t approx = kTRUE); static function; set the fgApproximate flag. When the flag is true, the function GetBinError; will approximate the bin error with the average profile error on all bins; in the following situation only; - the number of bins in the profile is less than 1002; - the bin number of entries is small ( <5); - the estimated bin error is extremely small compared to the bin content; (see TProfile::GetBinError). Int_t BufferEmpty(Int_t action = 0); Fill histogram with all entries in the buffer.; action = -1 histogram is reset and r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile.html:32201,Perform,Performs,32201,root/html534/TProfile.html,https://root.cern,https://root.cern/root/html534/TProfile.html,3,['Perform'],['Performs']
Performance,"stant"") of parameters 'params'; If importValues is FALSE, the present values from the object in the workspace are; saved. If importValues is TRUE, the values of the objects passed in the 'params'; argument are saved. Bool_t saveSnapshot(const char* name, const RooArgSet& params, Bool_t importValues = kFALSE); Save snapshot of values and attributes (including ""Constant"") of parameters 'params'; If importValues is FALSE, the present values from the object in the workspace are; saved. If importValues is TRUE, the values of the objects passed in the 'params'; argument are saved. Bool_t loadSnapshot(const char* name); Load the values and attributes of the parameters in the snapshot saved with; the given name. const RooArgSet* getSnapshot(const char* name) const; Return the RooArgSet containgin a snapshot of variables contained in the workspace. Note that the variables of the objects in the snapshots are _copies_ of the; variables in the workspace. To load the values of a snapshot in the workspace; variables use loadSnapshot() instead. RooAbsPdf* pdf(const char* name) const; Retrieve p.d.f (RooAbsPdf) with given name. A null pointer is returned if not found. RooAbsReal* function(const char* name) const; Retrieve function (RooAbsReal) with given name. Note that all RooAbsPdfs are also RooAbsReals. A null pointer is returned if not found. RooRealVar* var(const char* name) const; Retrieve real-valued variable (RooRealVar) with given name. A null pointer is returned if not found. RooCategory* cat(const char* name) const; Retrieve discrete variable (RooCategory) with given name. A null pointer is returned if not found. RooAbsCategory* catfunc(const char* name) const; Retrieve discrete function (RooAbsCategory) with given name. A null pointer is returned if not found. RooAbsArg* arg(const char* name) const; Return RooAbsArg with given name. A null pointer is returned if none is found. RooArgSet argSet(const char* nameList) const; Return set of RooAbsArgs matching to given list o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooWorkspace.html:20208,load,load,20208,root/html534/RooWorkspace.html,https://root.cern,https://root.cern/root/html534/RooWorkspace.html,6,['load'],"['load', 'loadSnapshot']"
Performance,"stant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBitsfAlreadyFound! cache for information; Double_t*fConst[fNconst] Array of fNconst formula constants; TString*fExpr[fNoper] List of expressions; TString*fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfFunctionsArray of function calls to make; TObjArrayfLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_tfNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*fNames[fNpar] Array of parameter names; Int_tfNconstNumber of constants; Int_tfNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNoperNumber of operators; Int_tfNparNumber of parameters; Int_tfNstringNumber of different constants character strings; Int_tfNumberformula number identifier; Int_tfNvalNumber of different variables in expression; TOperOffset*fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncfOptimal!pointer to optimal function; Double_t*fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**fPredefined![fNPar] predefined function ; TStringTNamed::fTitleobject title. private:. Int_t*fOper[fNoper] List of operators. (See documentation for changes made at version 7). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFormula(); Formula default constructor*-*-*-; *-* ============================. TFormula(const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFormula.html:13001,cache,cache,13001,root/html528/TFormula.html,https://root.cern,https://root.cern/root/html528/TFormula.html,6,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"stant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBitsfAlreadyFound! cache for information; Double_t*fConst[fNconst] Array of fNconst formula constants; TString*fExpr[fNoper] List of expressions; TString*fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfFunctionsArray of function calls to make; TObjArrayfLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_tfNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*fNames[fNpar] Array of parameter names; Int_tfNconstNumber of constants; Int_tfNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNoperNumber of operators; Int_tfNparNumber of parameters; Int_tfNstringNumber of different constants character strings; Int_tfNumberformula number identifier; Int_tfNvalNumber of different variables in expression; TOperOffset*fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncfOptimal!pointer to optimal function; Double_t*fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**fPredefined![fNPar] predefined function ; TStringTNamed::fTitleobject title. private:. Int_t*fOper[fNoper] List of operators. (See documentation for changes made at version 7). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFormula(); Formula default constructor. TFormula(const char* name, const char* formula); Normal Fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFormula.html:12535,cache,cache,12535,root/html534/TFormula.html,https://root.cern,https://root.cern/root/html534/TFormula.html,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsRealLValue.html:36173,cache,cache,36173,root/html534/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsRealLValue.html,189,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance,"starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on the norm of the problem data) and the; remaining variables to zero. void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); perform monitor operation at each interior-point iteration. TQpLinSolverBase * GetLinearSystem(); default method for checking status. May be replaced; by a user-defined method. { return fSys; }. void SetMuTol(Double_t m); { fMutol = m; }. Double_t GetMuTol(); { return fMutol; }. void SetArTol(Double_t ar); { fArtol = ar; }. Double_t GetArTol(); { return fArtol; }. Double_t DataNorm(); { return fDnorm; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpSolverBase.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpSolverBase.html:9828,perform,perform,9828,root/html528/TQpSolverBase.html,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html,1,['perform'],['perform']
Performance,"starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on the norm of the problem data) and the; remaining variables to zero. void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); perform monitor operation at each interior-point iteration. TQpLinSolverBase * GetLinearSystem(); default method for checking status. May be replaced; by a user-defined method. { return fSys; }. void SetMuTol(Double_t m); { fMutol = m; }. Double_t GetMuTol(); { return fMutol; }. void SetArTol(Double_t ar); { fArtol = ar; }. Double_t GetArTol(); { return fArtol; }. Double_t DataNorm(); { return fDnorm; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpSolverBase.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TQpSolverBase.html:9897,perform,perform,9897,root/html530/TQpSolverBase.html,https://root.cern,https://root.cern/root/html530/TQpSolverBase.html,1,['perform'],['perform']
Performance,"starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on the norm of the problem data) and the; remaining variables to zero. void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); perform monitor operation at each interior-point iteration. TQpLinSolverBase * GetLinearSystem(); default method for checking status. May be replaced; by a user-defined method. { return fSys; }. void SetMuTol(Double_t m); { fMutol = m; }. Double_t GetMuTol(); { return fMutol; }. void SetArTol(Double_t ar); { fArtol = ar; }. Double_t GetArTol(); { return fArtol; }. Double_t DataNorm(); { return fDnorm; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpSolverBase.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQpSolverBase.html:9897,perform,perform,9897,root/html532/TQpSolverBase.html,https://root.cern,https://root.cern/root/html532/TQpSolverBase.html,1,['perform'],['perform']
Performance,"state permutations of a list of categories; RooMultiCategory Product operator for categories; RooMultiGenFunction Export RooAbsReal as functor; RooMultiVarGaussian Multivariate Gaussian PDF with correlations; RooMultiVarGaussian::AnaIntData ; RooMultiVarGaussian::GenData ; RooNDKeysPdf General N-dimensional non-parametric kernel estimation p.d.f; RooNLLVar Function representing (extended) -log(L) of p.d.f and dataset; RooNameReg String name registry; RooNameSet A sterile version of RooArgSet, containing only the names of the contained RooAbsArgs; RooNonCPEigenDecay PDF to model CP-violating decays to final states which are not CP eigenstates; RooNonCentralChiSquare non-central chisquare pdf; RooNormSetCache Management tool for tracking sets of similar integration/normalization sets; RooNovosibirsk Novosibirsk PDF; RooNumCdf Numeric calculator for CDF for a given PDF; RooNumConvPdf Operator PDF implementing numeric convolution of 2 input PDFs; RooNumConvolution Operator PDF implementing numeric convolution of 2 input functions; RooNumGenConfig Numeric (MC) Event generator configuration; RooNumGenFactory Numeric Generator factory; RooNumIntConfig Numeric Integrator configuration; RooNumIntFactory Numeric Integrator factory; RooNumRunningInt Numeric calculator for running integral of a given function; RooNumber wrapper class for portable numerics; RooObjCacheManager Cache manager for generic caches that contain RooAbsArg objects; RooParamBinning Binning specification with ranges parameterized by external RooAbsReal functions; RooParamHistFunc Your description goes here...; RooParametricStepFunction Parametric Step Function Pdf; RooPlot Plot frame and container for graphics objects; RooPlotable Abstract interface for plotable objects in a RooPlot; RooPoisson A Poisson PDF; RooPolyVar Polynomial function; RooPolynomial Polynomial PDF; RooPrintable Interface for printable objects; RooProdGenContext Context for efficient generation of a a dataset from a RooProdPdf; RooProd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:38162,Cache,Cache,38162,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,4,"['Cache', 'cache']","['Cache', 'caches']"
Performance,"static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderDerivation order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; ROOT::Math::RichardsonDerivator*_rd! Derivator ; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDerivative.html:33030,cache,cache,33030,root/html530/RooDerivative.html,https://root.cern,https://root.cern/root/html530/RooDerivative.html,1,['cache'],['cache']
Performance,static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooNumIntConfig_intConfigNumeric integrator configuration for integration of function over bin; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_t_integrateIs integration over the bin volume requested; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooAbsData*RooAbsOptTestStatistic::_origDataOriginal data ; RooAbsReal*RooAbsOptTestStatistic::_origFuncOriginal function ; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooXYChi2Var.html:36792,cache,cache,36792,root/html532/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html532/RooXYChi2Var.html,1,['cache'],['cache']
Performance,"static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDerivative.html:18477,optimiz,optimizeCacheMode,18477,root/html530/RooDerivative.html,https://root.cern,https://root.cern/root/html530/RooDerivative.html,4,['optimiz'],['optimizeCacheMode']
Performance,"static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; Bool_tok() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooFormulaVar&operator=(const RooFormulaVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFormulaVar.html:20100,optimiz,optimizeCacheMode,20100,root/html602/RooFormulaVar.html,https://root.cern,https://root.cern/root/html602/RooFormulaVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); PiecewiseInterpolation&operator=(const PiecewiseInterpolation&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; PiecewiseInterpolation(); PiecewiseInterpolation(const PiecewiseInterpolation& other, const char* name = 0); PiecewiseInterpolation(const char* name, const char* title, const RooAbsReal& nominal, const RooArgList& lowSet, const RooArgList& highSet, const RooArgList& paramSet, Bool_t takeOwnerShip = kFALSE); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/PiecewiseInterpolation.html:19229,optimiz,optimizeCacheMode,19229,root/html602/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html602/PiecewiseInterpolation.html,2,['optimiz'],['optimizeCacheMode']
Performance,"static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfObsIter! ; RooSetProxy_pdfObsListList of observables mapped onto histogram observables; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Double_t_totVolume! Total volume of space (product of ranges of observables); Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_unitNormAssume c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistPdf.html:39664,cache,cache,39664,root/html528/RooHistPdf.html,https://root.cern,https://root.cern/root/html528/RooHistPdf.html,2,['cache'],['cache']
Performance,"static TClass*Class(); static voidcleanup(); static RooComplexComplexErrFunc(const RooComplex& z); static RooComplexComplexErrFunc(Double_t re, Double_t im = 0); static Double_terf(Double_t x); static Double_terfc(Double_t x); static RooComplexFastComplexErrFunc(const RooComplex& z); static Double_tFastComplexErrFuncIm(const RooComplex& z); static Double_tFastComplexErrFuncRe(const RooComplex& z); static Double_tinterpolate(Double_t* yArr, Int_t nOrder, Double_t x); static Double_tinterpolate(Double_t* xa, Double_t* ya, Int_t n, Double_t x); virtual TClass*IsA() const; static RooComplexITPComplexErrFunc(const RooComplex& z, Int_t nOrder); static Double_tITPComplexErrFuncIm(const RooComplex& z, Int_t nOrder); static Double_tITPComplexErrFuncRe(const RooComplex& z, Int_t nOrder); RooMath&operator=(const RooMath&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. static const char*cacheFileName(); static voidinitFastCERF(Int_t reBins = 800, Double_t reMin = -4.0, Double_t reMax = 4.0, Int_t imBins = 1000, Double_t imMin = -4.0, Double_t imMax = 6.0); static Bool_tloadCache(); static voidstoreCache(). Data Members; private:. static Bool_t_cacheTableSwitch activating use of file cache for CERF-LUT; static Int_t_imBinsNumber of grid points in imaginary dimension of CERF-LUT ; static double**_imCerfArrayLookup table for Im part of complex error function; static Double_t_imMaxHigh edge of imaginary dimension of CERF-LUT; static Double_t_imMinLow edge of imaginary dimension of CERF-LUT; static Double_t_imRangeRange in imaginary dimension of CERF-LUT; static Double_t_imStepGrid spacing in imaginary dimension of CERF-LUT; static Int_t_reBinsNumber of grid points in real dimension of CERF-LUT; static double**_reCerfArrayLookup table for Re part of complex error function; static Double_t_reMaxHigh edge of real dimension of CERF-LUT; static Double_t_reMinLow edge of real dimension of CERF-LUT; static Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMath.html:1378,cache,cacheFileName,1378,root/html528/RooMath.html,https://root.cern,https://root.cern/root/html528/RooMath.html,3,['cache'],['cacheFileName']
Performance,"static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQCommand. ←; TQUndoManager. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. TQCommand & operator=(const TQUndoManager& ). void Add(TObject* obj, Option_t* opt). TQUndoManager(). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:31; This page has been automatically generated. For comments or suggestions regarding the documentation or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TQUndoManager.html:20256,Perform,Performs,20256,root/html604/TQUndoManager.html,https://root.cern,https://root.cern/root/html604/TQUndoManager.html,1,['Perform'],['Performs']
Performance,"static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQCommand. ←; TQUndoManager. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. TQCommand & operator=(const TQUndoManager& ). void Add(TObject* obj, Option_t* opt). TQUndoManager(). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQUndoManager.html:20256,Perform,Performs,20256,root/html602/TQUndoManager.html,https://root.cern,https://root.cern/root/html602/TQUndoManager.html,1,['Perform'],['Performs']
Performance,"static TF1*fgFp3Function with varying Rcpu; static TF1*fgFp3nNormalized Function with varying Rcpu; static TList*fgGraphsList of TGraphErrors created by Draw actions. private:. Bool_tfUnlinkOutfileWhether to remove empty output files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBench(const char* url, const char* outfile = ""<default>"", const char* proofopt = 0); Constructor: check PROOF and load selectors PAR. ~TProofBench(); Destructor. Int_t OpenOutFile(Bool_t wrt = kFALSE, Bool_t verbose = kTRUE); Set the otuput file; Return 0 on success, -1 on error. Int_t SetOutFile(const char* outfile, Bool_t verbose = kTRUE); Set the output file; Return 0 on success, -1 on error. void CloseOutFile(); Close output file. Int_t RunCPU(Long64_t nevents = -1, Int_t start = -1, Int_t stop = -1, Int_t step = -1); Perform the CPU run; Return 0 on success, -1 on error. Int_t RunCPUx(Long64_t nevents = -1, Int_t start = -1, Int_t stop = -1); Perform the CPU run scanning over the number of workers per node; Return 0 on success, -1 on error. void DrawCPU(const char* outfile, const char* opt = ""std:"", Bool_t verbose = kFALSE, Int_t dofit = 0, Int_t n0 = -1, Int_t n1 = -1); Draw the CPU speedup plot.; opt = 'typewhat', e.g. 'std:max:'; type = 'std:' draw standard evt/s plot; 'stdx:' draw standard evt/s plot, 1 worker per node; 'norm:' draw normalized plot; 'normx:' draw normalized plot, 1 worker per node; what = 'max:' draw max rate; 'avg:' draw average rate; 'all:' draw max and average rate on same plot (default); dofit = 0 no fit; 1 fit with the relevant '1st degree related' function; 2 fit with the relevant '2nd degree related' function; 3 fit with varying rcpu function; n0 = for dofit == 3, number of real cores; n1 = for dofit == 3, number of total cores (real + hyperthreaded). TGraphErrors * GetGraph(TDirectory* d, const char* pfn, Int_t& nb, Double_t& xmi, Double_t& xmx, Double_t& ymi, Double_t& ymx, Int_t& kmx, TProfile*& pf); Get f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofBench.html:9790,Perform,Perform,9790,root/html534/TProofBench.html,https://root.cern,https://root.cern/root/html534/TProofBench.html,3,['Perform'],['Perform']
Performance,"static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_t*fAllocSize![fNumPIDs] allocated size of array fParentIDs for each ProcessID; Int_tfDefaultSize!default size for a new PID array; vector<Int_t>fMapPIDtoInternal! cache of pid to index in fProcessGUIDs; Int_t*fN![fNumPIDs] current maximum number of IDs in array fParentIDs for each ProcessID; Int_tfNumPIDs!number of known ProcessIDs; TObject*fOwnerObject owning this TRefTable; Int_tfParentID!current parent ID in fParents (latest call to SetParent); Int_t**fParentIDs![fNumPIDs][fAllocSize] array of Parent IDs; TObjArray*fParentsarray of Parent objects (eg TTree branch) holding the referenced objects; vector<string>fProcessGUIDsUUIDs of TProcessIDs used in fParentIDs; Int_tfSizedummy for backward compatibility; UInt_tfUID!Current uid (set by TRef::GetObject); TProcessID*fUIDContext!TProcessID the current uid is referring to; static TRefTable*fgRefTablePointer to current TRefTable. Class Charts. Inheritance Chart:. TObject. ←; TRefTable. Function documentation; TRefTable(); Default constructor for I/O. TRefTable(TObject* owner, Int_t size); Create a TRefTable with initial size. ~TRefTable(); Destructor. Int_t Add(Int_t uid, TProcessID* context = 0); Add a new uid to the table.; we add a new pair (uid,fparent) to the map; This function is called by TObject::Streamer or TStreamerInfo::WriteBuffer. Int_t AddInternalIdxForPID(TProcessID* procid); Add the internal index for fProcessIDs, fAllocSize, etc given a PID. void Clear(Op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRefTable.html:7994,cache,cache,7994,root/html602/TRefTable.html,https://root.cern,https://root.cern/root/html602/TRefTable.html,2,['cache'],['cache']
Performance,"static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; RooCategoryProxy_rhoQ; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tag; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooNonCPEigenDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_wQ; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNonCPEigenDecay.html:47663,cache,cache,47663,root/html602/RooNonCPEigenDecay.html,https://root.cern,https://root.cern/root/html602/RooNonCPEigenDecay.html,2,['cache'],['cache']
Performance,"static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxydm; RooRealProxydm0; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDstD0BG.html:40145,cache,cache,40145,root/html532/RooDstD0BG.html,https://root.cern,https://root.cern/root/html532/RooDstD0BG.html,2,['cache'],['cache']
Performance,"static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  THttpWSHandler (const char *name, const char *title, Bool_t syncmode=kTRUE);  normal constructor ;  ; virtual void CompleteWSSend (UInt_t);  Method called when multi-threaded send operation is completed. ;  ; virtual std::string GetCodeVersion ();  Method generate extra suffix for all kinds of loaded code. ;  ; virtual Bool_t ProcessBatchHolder (std::shared_ptr< THttpCallArg > &);  Method used to accept or reject root_batch_holder.js request. ;  ; virtual void VerifyDefaultPageContent (std::shared_ptr< THttpCallArg > &arg);  Method called when default page content is prepared for use By default no-cache header is provided. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; Int_t CompleteSend (std::shared_ptr< THttpWSEngine > &engine);  Complete current send operation. ;  ; std::shared_ptr< THttpWSEngine > FindEngine (UInt_t id, Bool_t book_send=kFALSE);  Find websocket connection handle with given id If book_send parameter specified, have to book send operation under the mutex. ;  ; Bool_t HandleWS (std::shared_ptr< THttpCallArg > &arg);  Process request to websocket Different kind of requests coded into THttpCallArg::Method: ;  ; Int_t PerformSend (std::shared_ptr< THttpWSEngine > engine);  Perform send operation, stored in buffer. ;  ; void RemoveEngine (std::shared_ptr< THttpWSEngine > &engine, Bool_t terminate=kFALSE);  R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpWSHandler.html:14148,cache,cache,14148,doc/master/classTHttpWSHandler.html,https://root.cern,https://root.cern/doc/master/classTHttpWSHandler.html,1,['cache'],['cache']
Performance,"static voidSetHinting(Bool_t state); static voidSetKerning(Bool_t state); static voidSetRotationMatrix(Float_t angle); static voidSetSmoothing(Bool_t state); static voidSetTextFont(Font_t fontnumber); static Int_tSetTextFont(const char* fontname, Int_t italic = 0); static voidSetTextSize(Float_t textsize); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); static voidVersion(Int_t& major, Int_t& minor, Int_t& patch). Data Members; public:. enum { kTTMaxFonts; kMaxGlyphs; };. private:. static Int_tfgAscentstring ascent, used to compute Y alignment; static FT_BBoxfgCBoxstring control box; static void*fgCharMap[32]font character map; static Int_tfgCurFontIdxcurrent font index; static void*fgFace[32]font face; static Int_tfgFontCountnumber of fonts loaded; static char*fgFontName[32]font name; static TTGlyphfgGlyphs[1024]glyphs; static Bool_tfgHintinguse hinting (true by default); static Bool_tfgInittrue if the Init has been called; static Bool_tfgKerninguse kerning (true by default); static void*fgLibraryFreeType font library; static Int_tfgNumGlyphsnumber of glyphs in the string; static FT_Matrix*fgRotMatrixrotation matrix; static Bool_tfgSmoothinguse anti-aliasing (true when >8 planes, false otherwise); static Int_tfgSymbItaFontIdxSymbol italic font index; static Int_tfgTBlankWtrailing blanks width; static Int_tfgWidthstring width, used to compute X alignment. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TTF(); Cleanup TTF environment. void Init(); Initialise the TrueType fonts interface. void Cleanup(); Cleanup. Is called by the gCleanupTTF destructor. Short_t CharToUnicode(UInt_t code); Map char to unicode. Returns 0 in case no mapping exists. void GetTextExtent(UInt_t& w, UInt_t& h, char* text); Get width (w) and height (h) when text is horizontal. void GetTextAdvance(UInt_t& a, char* text); Get advance (a) when text is horizontal. void LayoutGlyphs(); Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTF.html:1821,load,loaded,1821,root/html528/TTF.html,https://root.cern,https://root.cern/root/html528/TTF.html,3,['load'],['loaded']
Performance,"static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategory.html:15193,cache,cache,15193,root/html528/RooAbsCategory.html,https://root.cern,https://root.cern/root/html528/RooAbsCategory.html,2,['cache'],['cache']
Performance,"static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&RooAbsCategoryLValue::operator=(int index); RooAbsArg&RooAbsCategoryLValue::operator=(const char* label); RooAbsArg&RooAbsCategoryLValue::operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCategory.html:11049,optimiz,optimizeCacheMode,11049,root/html526/RooCategory.html,https://root.cern,https://root.cern/root/html526/RooCategory.html,10,['optimiz'],['optimizeCacheMode']
Performance,"static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TMessage (void *buf, Int_t bufsize);  Create a TMessage object for reading objects. ;  ; void SetLength () const;  Set the message length at the beginning of the message buffer. ;  ;  Protected Member Functions inherited from TBufferFile;  TBufferFile ();  ;  TBufferFile (const TBufferFile &)=delete;  not implemented ;  ; Int_t CheckByteCount (UInt_t startpos, UInt_t bcnt, const TClass *clss, const char *classname);  Check byte count with current buffer position. ;  ; void CheckCount (UInt_t offset) override;  Check if offset is not too large (< kMaxMapCount) when writing. ;  ; UInt_t CheckObject (UInt_t offset, const TClass *cl, Bool_t readClass=kFALSE);  Check for object in the read map. ;  ; void operator= (const TBufferFile &)=delete;  not implemented ;  ; void WriteObjectClass (const void *actualObjStart, const TClass *actualClass, Bool_t cacheReuse) override;  Write object to I/O buffer. ;  ;  Protected Member Functions inherited from TBufferIO;  TBufferIO ();  ;  TBufferIO (TBuffer::EMode mode);  constructor ;  ;  TBufferIO (TBuffer::EMode mode, Int_t bufsiz);  constructor ;  ;  TBufferIO (TBuffer::EMode mode, Int_t bufsiz, void *buf, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr);  constructor ;  ; Long64_t GetObjectTag (const void *obj);  Returns tag for specified object from objects map (if exists) Returns 0 if object not included into objects map. ;  ;  Protected Member Functions inherited from TBuffer;  TBuffer ();  ;  TBuffer (const TBuffer &)=delete;  ; void operator= (const TBuffer &)=delete;  ; Int_t Read (const char *name) override;  Read contents of object with specified name from the current directory. ;  ; Int_t Write (const char *name, Int_t opt, Int_t bufs) const override;  Write this object to the current directory. ;  ; Int_t Write (cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMessage.html:35372,cache,cacheReuse,35372,doc/master/classTMessage.html,https://root.cern,https://root.cern/doc/master/classTMessage.html,1,['cache'],['cacheReuse']
Performance,"static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Calculate and return value of polynomial. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1FlexibleInterpVar.html:49268,cache,cached,49268,doc/master/classRooStats_1_1HistFactory_1_1FlexibleInterpVar.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1FlexibleInterpVar.html,4,['cache'],"['cache', 'cached']"
Performance,"static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Return sum of -log of constraint p.d.f.s. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooConstraintSum.html:48677,cache,cached,48677,doc/master/classRooConstraintSum.html,https://root.cern,https://root.cern/doc/master/classRooConstraintSum.html,2,['cache'],"['cache', 'cached']"
Performance,staticprivate . frustum basis (as box) of current interest box (DEBUG) ; Definition at line 65 of file TGLCamera.h. ◆ fInterestBox. TGLBoundingBox TGLCamera::fInterestBox. protected . viewport (GL coords - origin bottom left) ; Definition at line 105 of file TGLCamera.h. ◆ fInterestFrustum. TGLBoundingBox TGLCamera::fInterestFrustum. private . previous interest box (DEBUG) ; Definition at line 62 of file TGLCamera.h. ◆ fInterestFrustumAsBox. TGLBoundingBox TGLCamera::fInterestFrustumAsBox. private . frustum basis of current interest box - NOT a true BB! (DEBUG) ; Definition at line 63 of file TGLCamera.h. ◆ fLargestSeen. Double_t TGLCamera::fLargestSeen. mutableprotected . the interest box - created in UpdateInterest() ; Definition at line 106 of file TGLCamera.h. ◆ fLastNoPickProjM. TGLMatrix TGLCamera::fLastNoPickProjM. mutableprotected . timestamp ; Definition at line 97 of file TGLCamera.h. ◆ fModVM. TGLMatrix TGLCamera::fModVM. mutableprotected . projection matrix (cached) ; Definition at line 99 of file TGLCamera.h. ◆ fNearClip. Double_t TGLCamera::fNearClip. mutableprotected . current camera center ; Definition at line 86 of file TGLCamera.h. ◆ fPreviousInterestBox. TGLBoundingBox TGLCamera::fPreviousInterestBox. private . Definition at line 61 of file TGLCamera.h. ◆ fProjM. TGLMatrix TGLCamera::fProjM. mutableprotected . no-pick projection matrix (cached) ; Definition at line 98 of file TGLCamera.h. ◆ fTimeStamp. UInt_t TGLCamera::fTimeStamp. mutableprotected . cached items dirty? ; Definition at line 96 of file TGLCamera.h. ◆ fVAxisMinAngle. Float_t TGLCamera::fVAxisMinAngle. protected . Definition at line 92 of file TGLCamera.h. ◆ fViewport. TGLRect TGLCamera::fViewport. protected . frustum planes (cached) ; Definition at line 103 of file TGLCamera.h. ◆ fWasArcBalled. Bool_t TGLCamera::fWasArcBalled. protected . Definition at line 80 of file TGLCamera.h. Libraries for TGLCamera:. [legend]; The documentation for this class was generated from the following f,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLCamera.html:43960,cache,cached,43960,doc/master/classTGLCamera.html,https://root.cern,https://root.cern/doc/master/classTGLCamera.html,1,['cache'],['cached']
Performance,"statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:19990,cache,cache,19990,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,1,['cache'],['cache']
Performance,"status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_lowestOrder; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooPolyVar.html:31988,cache,cache,31988,root/html526/RooPolyVar.html,https://root.cern,https://root.cern/root/html526/RooPolyVar.html,2,['cache'],['cache']
Performance,"status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; TString_rangeName; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRangeBoolean.html:31944,cache,cache,31944,root/html528/RooRangeBoolean.html,https://root.cern,https://root.cern/root/html528/RooRangeBoolean.html,1,['cache'],['cache']
Performance,status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this objec,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooResolutionModel.html:39610,cache,cache,39610,root/html526/RooResolutionModel.html,https://root.cern,https://root.cern/root/html526/RooResolutionModel.html,1,['cache'],['cache']
Performance,status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNu,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooResolutionModel.html:39992,cache,cache,39992,root/html528/RooResolutionModel.html,https://root.cern,https://root.cern/root/html528/RooResolutionModel.html,1,['cache'],['cache']
Performance,status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAb,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooResolutionModel.html:40461,cache,cache,40461,root/html530/RooResolutionModel.html,https://root.cern,https://root.cern/root/html530/RooResolutionModel.html,1,['cache'],['cache']
Performance,"std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TTreePerfStats.cxx:657; TTreePerfStats::PrintBasketInfovoid PrintBasketInfo(Option_t *option="""") const overridePrint the TTree basket information.Definition TTreePerfStats.cxx:581; TTreePerfStats::GetReadaheadSizevirtual Int_t GetReadaheadSize() constDefinition TTreePerfStats.h:106; TTreePerfStats::fFileTFile * fFile! Pointer to the file containing the TreeDefinition TTreePerfStats.h:67; TTreePerfStats::GetHostInfoconst char * GetHostInfo() constDefinition TTreePerfStats.h:101; TTreePerfStats::GetUnzipTimevirtual Double_t GetUnzipTime() constDefinition TTreePerfStats.h:111; TTreePerfStats::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideReturn distance to one of the objects in the TTreePerfStats.Definition TTreePerfStats.cxx:217; TTreePerfStats::fRealTimeDouble_t fRealTimeReal time.Definition TTreePerfStats.h:58; TTreePerfStats::fReadaheadSizeInt_t fReadaheadSizeRead-ahead cache size.Definition TTreePerfStats.h:54; TTreePerfStats::SetLoadedMissvoid SetLoadedMiss(size_t bi, size_t basketNumber) overrideDefinition TTreePerfStats.h:148; TTreePerfStats::GetRealTimevirtual Double_t GetRealTime() constDefinition TTreePerfStats.h:108; TTreePerfStats::SetUnzipTimevirtual void SetUnzipTime(Double_t uztime)Definition TTreePerfStats.h:142; TTreePerfStats::SetReadCallsvirtual void SetReadCalls(Int_t ncalls)Definition TTreePerfStats.h:138; TTreePerfStats::GetDiskTimevirtual Double_t GetDiskTime() constDefinition TTreePerfStats.h:98; TTreePerfStats::fBranchIndexCachestd::unordered_map< TBranch *, size_t > fBranchIndexCacheDefinition TTreePerfStats.h:76; TTreePerfStats::~TTreePerfStats~TTreePerfStats() overrideDestructor.Definition TTreePerfStats.cxx:188; TTreePerfStats::FileOpenEventvoid FileOpenEvent(TFile *, const char *, Double_t) overrideDefinition TTreePerfStats.h:119; TTreePerfStats::SetGraphTimevirtual void SetGraphTime(TGraphErrors ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8h_source.html:18287,cache,cache,18287,doc/master/TTreePerfStats_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html,1,['cache'],['cache']
Performance,"std::string();}. int VariableIndex(const string& ) const; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls(); max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations(); max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fUp; }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit). { return fValidError; }. void SetPrintLevel(int level); set print level. { fDebug = level; }. void SetMaxFunctionCalls(unsigned int maxfcn); set maximum of function calls. { if (maxfcn > 0) fMaxCalls = maxfcn; }. void SetMaxIterations(unsigned int maxiter); set maximum iterations (one iteration can have many function calls). { if (maxiter > 0) fMaxIter = maxiter; }. void SetTolerance(double tol); set the tolerance. { fTol = tol; }. void SetPrecision(double prec); set in the minimizer the objective function evaluation precision; ( a value <=0 means the minimizer will choose its optimal value automatically, i.e. default case). { fPrec = prec; }. void SetStrategy(int strategyLevel); set the strategy. { fStrategy = strategyLevel; }. void SetErrorDef(double up); set scale for calculating the errors. { fUp = up; }. void SetValidError(bool on); flag to check if minimizer needs to perform accurate error analysis (e.g. r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Minimizer.html:9731,perform,performed,9731,root/html526/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Minimizer.html,1,['perform'],['performed']
Performance,"std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; vector<double>_high; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; vector<double>_low; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__LinInterpVar.html:33239,cache,cache,33239,root/html534/RooStats__HistFactory__LinInterpVar.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__LinInterpVar.html,4,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"std::vector< Matrix_t > & ; biasGradients . ). protectedvirtual . Update the biases, given the current bias gradients. ; Implements TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >.; Definition at line 169 of file Adam.h. ◆ UpdateWeights(). template<typename Architecture_t , typename Layer_t , typename DeepNet_t > . auto TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::UpdateWeights ; (; size_t ; layerIndex, . std::vector< Matrix_t > & ; weights, . const std::vector< Matrix_t > & ; weightGradients . ). protectedvirtual . Update the weights, given the current weight gradients. ; Implements TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >.; Definition at line 141 of file Adam.h. Member Data Documentation. ◆ fBeta1. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::fBeta1. protected . The Beta1 constant used by the optimizer. ; Definition at line 51 of file Adam.h. ◆ fBeta2. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::fBeta2. protected . The Beta2 constant used by the optimizer. ; Definition at line 52 of file Adam.h. ◆ fEpsilon. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::fEpsilon. protected . The Smoothing term used to avoid division by zero. ; Definition at line 53 of file Adam.h. ◆ fFirstMomentBiases. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TAdam< Architecture_t, Layer_t, DeepNet_t >::fFirstMomentBiases. protecte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html:10436,optimiz,optimizer,10436,doc/master/classTMVA_1_1DNN_1_1TAdam.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html,1,['optimiz'],['optimizer']
Performance,"stdir=0);  Download a PROOF archive (PAR file) from the master package repository. ;  ; Long64_t DrawSelect (const char *dsetname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0, TObject *enl=0);  Execute the specified drawing action on a data set which is stored on the master with name 'dsetname'. ;  ; virtual Int_t Echo (const char *str);  Sends a string to master and workers and expect them to echo it back to the client via a message. ;  ; virtual Int_t Echo (const TObject *obj);  Sends an object to master and workers and expect them to send back a message with the output of its TObject::Print(). ;  ; Int_t EnablePackage (const char *package, Bool_t notOnClient=kFALSE, TList *workers=0);  Enable specified package. ;  ; Int_t EnablePackage (const char *package, const char *loadopts, Bool_t notOnClient=kFALSE, TList *workers=0);  Enable specified package. ;  ; Int_t EnablePackage (const char *package, TList *loadopts, Bool_t notOnClient=kFALSE, TList *workers=0);  Enable specified package. ;  ; Int_t Exec (const char *cmd, Bool_t plusMaster=kFALSE);  Send command to be executed on the PROOF master and/or slaves. ;  ; Int_t Exec (const char *cmd, const char *ord, Bool_t logtomacro=kFALSE);  Send command to be executed on node of ordinal 'ord' (use ""0"" for master). ;  ; void Feedback (TList *objs);  Get list of feedback objects. ;  ; Long64_t Finalize (const char *queryref, Bool_t force=kFALSE);  Finalize query with reference ref. ;  ; Long64_t Finalize (Int_t query=-1, Bool_t force=kFALSE);  Finalize the qry-th query in fQueries. ;  ; TList * FindDataSets (const char *searchString, const char *optStr="""");  Find datasets, returns in a TList all found datasets. ;  ; Long64_t GetBytesRead () const;  ; Int_t GetClientProtocol () const;  ; const char * GetConfDir () const;  ; const char * GetConfFile () const;  ; Float_t GetCpuTime () const;  ; const char * GetDataPoolUrl () const;  ; TMap * GetDataSetQuota (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:9653,load,loadopts,9653,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['load'],['loadopts']
Performance,"stead.Definition TCling.cxx:2648; TCling::fCxxModulesEnabledBool_t fCxxModulesEnabledDefinition TCling.h:128; TCling::BaseClassInfo_Nextint BaseClassInfo_Next(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8492; TCling::RefreshClassInfovoid RefreshClassInfo(TClass *cl, const clang::NamedDecl *def, bool alias)Internal function. Actually do the update of the ClassInfo when seeing.Definition TCling.cxx:6635; TCling::CallFunc_FactoryCopyCallFunc_t * CallFunc_FactoryCopy(CallFunc_t *func) const finalDefinition TCling.cxx:7917; TCling::CallFunc_ExecDoubleDouble_t CallFunc_ExecDouble(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7901; TCling::CallFunc_ResetArgvoid CallFunc_ResetArg(CallFunc_t *func) const finalDefinition TCling.cxx:7966; TCling::GetCurrentMacroNameconst char * GetCurrentMacroName() const finalReturn the file name of the currently interpreted file, included or not.Definition TCling.cxx:5463; TCling::IsLoadedBool_t IsLoaded(const char *filename) const finalReturn true if the file has already been loaded by cint.Definition TCling.cxx:3172; TCling::SaveGlobalsContextvoid SaveGlobalsContext() finalSave the current Cling state of global objects.Definition TCling.cxx:3872; TCling::CallFunc_IgnoreExtraArgsvoid CallFunc_IgnoreExtraArgs(CallFunc_t *func, bool ignore) const finalDefinition TCling.cxx:7932; TCling::ApplyToInterpreterMutexvoid ApplyToInterpreterMutex(void *delta)Re-apply the lock count delta that TCling__ResetInterpreterMutex() caused.Definition TCling.cxx:9634; TCling::LazyFunctionCreatorAutoloadvoid * LazyFunctionCreatorAutoload(const std::string &mangled_name)Autoload a library based on a missing symbol.Definition TCling.cxx:6591; TCling::GenerateDictionaryInt_t GenerateDictionary(const char *classes, const char *includes="""", const char *options=nullptr) finalGenerate the dictionary for the C++ classes listed in the first argument (in a semi-colon separated l...Definition TCling.cxx:4723; TCling::ClassInfo_ContainsBool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:426341,load,loaded,426341,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loaded']
Performance,"stead.Definition TCling.cxx:2648; TCling::fCxxModulesEnabledBool_t fCxxModulesEnabledDefinition TCling.h:128; TCling::BaseClassInfo_Nextint BaseClassInfo_Next(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8492; TCling::RefreshClassInfovoid RefreshClassInfo(TClass *cl, const clang::NamedDecl *def, bool alias)Internal function. Actually do the update of the ClassInfo when seeing.Definition TCling.cxx:6635; TCling::CallFunc_FactoryCopyCallFunc_t * CallFunc_FactoryCopy(CallFunc_t *func) const finalDefinition TCling.cxx:7917; TCling::CallFunc_ExecDoubleDouble_t CallFunc_ExecDouble(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7901; TCling::CallFunc_ResetArgvoid CallFunc_ResetArg(CallFunc_t *func) const finalDefinition TCling.cxx:7966; TCling::GetCurrentMacroNameconst char * GetCurrentMacroName() const finalReturn the file name of the currently interpreted file, included or not.Definition TCling.cxx:5463; TCling::IsLoadedBool_t IsLoaded(const char *filename) const finalReturn true if the file has already been loaded by cint.Definition TCling.cxx:3172; TCling::SaveGlobalsContextvoid SaveGlobalsContext() finalSave the current Cling state of global objects.Definition TCling.cxx:3872; TCling::CallFunc_IgnoreExtraArgsvoid CallFunc_IgnoreExtraArgs(CallFunc_t *func, bool ignore) const finalDefinition TCling.cxx:7932; TCling::fExitCodeInt_t fExitCodeDefinition TCling.h:109; TCling::ApplyToInterpreterMutexvoid ApplyToInterpreterMutex(void *delta)Re-apply the lock count delta that TCling__ResetInterpreterMutex() caused.Definition TCling.cxx:9634; TCling::LazyFunctionCreatorAutoloadvoid * LazyFunctionCreatorAutoload(const std::string &mangled_name)Autoload a library based on a missing symbol.Definition TCling.cxx:6591; TCling::GenerateDictionaryInt_t GenerateDictionary(const char *classes, const char *includes="""", const char *options=nullptr) finalGenerate the dictionary for the C++ classes listed in the first argument (in a semi-colon separated l...De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:52054,load,loaded,52054,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['load'],['loaded']
Performance,"stem.; Definition at line 1643 of file TUnixSystem.cxx. ◆ Link(). int TUnixSystem::Link ; (; const char * ; from, . const char * ; to . ). overridevirtual . Create a link from file1 to file2. ; Returns 0 when successful, -1 in case of failure. ; Reimplemented from TSystem.; Definition at line 1686 of file TUnixSystem.cxx. ◆ ListLibraries(). void TUnixSystem::ListLibraries ; (; const char * ; regexp = """"). overridevirtual . List all loaded shared libraries. ; Reimplemented from TSystem.; Definition at line 2848 of file TUnixSystem.cxx. ◆ ListSymbols(). void TUnixSystem::ListSymbols ; (; const char * ; module, . const char * ; re = """" . ). overridevirtual . List symbols in a shared library. ; Reimplemented from TSystem.; Definition at line 2840 of file TUnixSystem.cxx. ◆ Load(). int TUnixSystem::Load ; (; const char * ; module, . const char * ; entry = """", . Bool_t ; system = kFALSE . ). overridevirtual . Load a shared library. ; Returns 0 on successful loading, 1 in case lib was already loaded and -1 in case lib does not exist or in case of error. ; Reimplemented from TSystem.; Definition at line 2824 of file TUnixSystem.cxx. ◆ MakeDirectory(). int TUnixSystem::MakeDirectory ; (; const char * ; name). overridevirtual . Make a Unix file system directory. ; Returns 0 in case of success and -1 if the directory could not be created. ; Reimplemented from TSystem.; Definition at line 1380 of file TUnixSystem.cxx. ◆ Now(). TTime TUnixSystem::Now ; (; ). overridevirtual . Get current time in milliseconds since 0:00 Jan 1 1995. ; Reimplemented from TSystem.; Definition at line 2970 of file TUnixSystem.cxx. ◆ OpenConnection(). int TUnixSystem::OpenConnection ; (; const char * ; server, . int ; port, . int ; tcpwindowsize = -1, . const char * ; protocol = ""tcp"" . ). overridevirtual . Open a connection to a service on a server. ; Returns -1 in case connection cannot be opened. Use tcpwindowsize to specify the size of the receive buffer, it has to be specified here to make sure th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:58886,load,loading,58886,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,2,['load'],"['loaded', 'loading']"
Performance,"stemDefinition TSystem.h:561; TTree.h; Tools.h; TCutA specialized string object used for TTree selections.Definition TCut.h:25; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TMVA::CrossValidationClass to perform cross validation, splitting the dataloader into folds.Definition CrossValidation.h:124; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataLoader::AddRegressionTreevoid AddRegressionTree(TTree *tree, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)Definition DataLoader.h:103; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddTargetvoid AddTarget(const TString &expression, const TString &title="""", const TString &unit="""", Double_t min=0, Double_t max=0)user inserts target in data set infoDefinition DataLoader.cxx:512; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::Tools::Instance",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html:21006,perform,perform,21006,doc/master/TMVACrossValidationRegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html,1,['perform'],['perform']
Performance,"steps. ;  ; Int_t fGA_preCalc;  GA settings: number of pre-calc steps. ;  ; Double_t fGA_SC_factor;  GA settings: SC_factor. ;  ; Int_t fGA_SC_rate;  GA settings: SC_rate. ;  ; Int_t fGA_SC_steps;  GA settings: SC_steps. ;  ; Double_t fLastAlpha;  line search variable ;  ; Double_t fLearnRate;  learning rate for synapse weight adjustments ;  ; Double_t fPrior;  zjh ;  ; std::vector< Double_t > fPriorDev;  zjh ;  ; Int_t fResetStep;  reset time (how often we clear hessian matrix) ;  ; Float_t fSamplingEpoch;  fraction of epochs where sampling is used ;  ; Float_t fSamplingFraction;  fraction of events which is sampled for training ;  ; Bool_t fSamplingTesting;  The testing sample is sampled. ;  ; Bool_t fSamplingTraining;  The training sample is sampled. ;  ; Float_t fSamplingWeight;  changing factor for event weights when sampling is turned on ;  ; Double_t fTau;  line search variable ;  ; Int_t fTestRate;  test for overtraining performed at each #th epochs ;  ; ETrainingMethod fTrainingMethod;  method of training, BP or GA ;  ; TString fTrainMethodS;  training method option param ;  ; Int_t fUpdateLimit;  zjh ;  ; bool fUseRegulator;  zjh ;  ; Float_t fWeightRange;  suppress outliers for the estimator calculation ;  . Static Private Attributes; static const Bool_t fgPRINT_BATCH = kFALSE;  debug flags ;  ; static const Int_t fgPRINT_ESTIMATOR_INC = 10;  debug flags ;  ; static const Bool_t fgPRINT_SEQ = kFALSE;  debug flags ;  . Additional Inherited Members;  Public Attributes inherited from TMVA::MethodANNBase; TObjArray * fNetwork;  ;  Public Attributes inherited from TMVA::MethodBase; Bool_t fSetupCompleted;  ; TrainingHistory fTrainHistory;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Attributes inherited from TMVA::MethodANNBase; TActivation * fActivation;  ; std::vector< TH1 * > fEpochMonHistB;  ; std::vector< TH1 * > fEpochMonHistS;  ; std::vector< TH1 * > fEpochMonHistW;  ; EEstimator fEstimator;  ; TH1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:35406,perform,performed,35406,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['perform'],['performed']
Performance,"sterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). private:. Double_tevaluateFull(Double_t thisX, Double_t thisY) const; Double_tg(Double_t var1, Double_t* _var1, Double_t sigma1, Double_t var2, Double_t* _var2, Double_t sigma2) const; Double_thighBoundaryCorrection(Double_t thisVar, Double_t thisH, Double_t high, Double_t tVar) const; Double_tlowBoundaryCorrection(Double_t thisVar, Double_t thisH, Double_t low, Double_t tVar) const. Data Members; public:. enum RooAbsPdf::ExtendMode { CanNotBeExtended; CanBeExtended; MustBeExtended; };; enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start; RooRealProxyx; RooRealProxyy. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DKeysPdf.html:38879,Cache,CacheMode,38879,root/html534/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html534/Roo2DKeysPdf.html,1,['Cache'],['CacheMode']
Performance,"sterRangeEnd = new Long64_t[fMaxClusterRange];; 8276 fClusterSize = new Long64_t[fMaxClusterRange];; 8277 }; 8278 }; 8279 fClusterRangeEnd[fNClusterRange] = fEntries - 1;; 8280 // If we are auto-flushing, then the cluster size is the same as the current auto-flush setting.; 8281 if (fAutoFlush > 0) {; 8282 // Even if the user triggers MarkEventRange prior to fAutoFlush being present, the TClusterIterator; 8283 // will appropriately go to the next event range.; 8284 fClusterSize[fNClusterRange] = fAutoFlush;; 8285 // Otherwise, assume there is one cluster per event range (e.g., user is manually controlling the flush).; 8286 } else if (fNClusterRange == 0) {; 8287 fClusterSize[fNClusterRange] = fEntries;; 8288 } else {; 8289 fClusterSize[fNClusterRange] = fClusterRangeEnd[fNClusterRange] - fClusterRangeEnd[fNClusterRange-1];; 8290 }; 8291 ++fNClusterRange;; 8292}; 8293 ; 8294/// Estimate the median cluster size for the TTree.; 8295/// This value provides e.g. a reasonable cache size default if other heuristics fail.; 8296/// Clusters with size 0 and the very last cluster range, that might not have been committed to fClusterSize yet,; 8297/// are ignored for the purposes of the calculation.; 8298Long64_t TTree::GetMedianClusterSize(); 8299{; 8300 std::vector<Long64_t> clusterSizesPerRange;; 8301 clusterSizesPerRange.reserve(fNClusterRange);; 8302 ; 8303 // We ignore cluster sizes of 0 for the purposes of this function.; 8304 // We also ignore the very last cluster range which might not have been committed to fClusterSize.; 8305 std::copy_if(fClusterSize, fClusterSize + fNClusterRange, std::back_inserter(clusterSizesPerRange),; 8306 [](Long64_t size) { return size != 0; });; 8307 ; 8308 std::vector<double> nClustersInRange; // we need to store doubles because of the signature of TMath::Median; 8309 nClustersInRange.reserve(clusterSizesPerRange.size());; 8310 ; 8311 auto clusterRangeStart = 0ll;; 8312 for (int i = 0; i < fNClusterRange; ++i) {; 8313 const auto size = fCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:323224,cache,cache,323224,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"sterurl, . const char * ; conffile, . const char * ; confdir, . Int_t ; loglevel, . const char * ; alias = 0 . ). protected . Start the PROOF environment. ; Starting PROOF involves either connecting to a master server, which in turn will start a set of slave servers, or directly starting as master server (if master = """"). For a description of the arguments see the TProof ctor. Returns the number of started master or slave servers, returns 0 in case of error, in which case fValid remains false. ; Definition at line 154 of file TProofLite.cxx. ◆ InitDataSetManager(). Int_t TProofLite::InitDataSetManager ; (; ). private . Initialize the dataset manager from directives or from defaults Return 0 on success, -1 on failure. ; Definition at line 1412 of file TProofLite.cxx. ◆ IsA(). TClass * TProofLite::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TProof.; Definition at line 170 of file TProofLite.h. ◆ Load(). Int_t TProofLite::Load ; (; const char * ; macro, . Bool_t ; notOnClient = kFALSE, . Bool_t ; uniqueOnly = kTRUE, . TList * ; wrks = 0 . ). overridevirtual . Copy the specified macro in the cache directory. ; The macro file is uploaded if new or updated. If existing, the corresponding header basename(macro).h or .hh, is also uploaded. For the other arguments see TProof::Load(). Returns 0 in case of success and -1 in case of error. ; Reimplemented from TProof.; Definition at line 1539 of file TProofLite.cxx. ◆ MakeQueryResult(). TProofQueryResult * TProofLite::MakeQueryResult ; (; Long64_t ; nent, . const char * ; opt, . Long64_t ; fst, . TDSet * ; dset, . const char * ; selec . ). protected . Create a TProofQueryResult instance for this query. ; Definition at line 1000 of file TProofLite.cxx. ◆ NotifyStartUp(). void TProofLite::NotifyStartUp ; (; const char * ; action, . Int_t ; done, . Int_t ; tot . ). private . Notify setting-up operation message. ; Definition at line 667 of file TProofLite.cxx. ◆ operator=(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:54654,Load,Load,54654,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['Load'],['Load']
Performance,"stexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  Return the observables to be cached given the normalization set nset. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  Return the parameters on which the cache depends given normalization set nset. ;  ; void calcParams ();  (Re)calculate effective parameters of this p.d.f. ;  ; PdfCacheElem * createCache (const RooArgSet *nset) const override;  Return specialized cache subclass for FFT calculations. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void fillCacheObject (PdfCacheElem &cache) const override;  Fill the contents of the cache the FFT convolution output. ;  ; void fillCacheSlice (FFTCacheElem &cache, const RooArgSet &slicePosition) const;  Fill a slice of cachePdf with the output of the FFT convolution calculation. ;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:68208,cache,cached,68208,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cached']
Performance,stic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; Double_t_offsetCarrySaveW2!; Double_t_offsetSaveW2!; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_optimized!; RooAbsData*RooAbsOptTestStatistic::_origDataOriginal data ; RooAbsReal*RooAbsOptTestStatistic::_origFuncOriginal function ; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of serve,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNLLVar.html:41220,cache,cache,41220,root/html534/RooNLLVar.html,https://root.cern,https://root.cern/root/html534/RooNLLVar.html,1,['cache'],['cache']
Performance,stlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooRealProxy_nNumber of expected events; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooRealProxy_pdfInput p.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooExtendPdf.html:37413,cache,cache,37413,root/html526/RooExtendPdf.html,https://root.cern,https://root.cern/root/html526/RooExtendPdf.html,2,['cache'],['cache']
Performance,stlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TMatrixDSym*_corrMat; TMatrixDSym*_covMat; Double_t_d; RooDataSet&_data; vector<vector<Double_t> >_dataPts; vector<TVectorD>_dataPtsR; RooArgSet_dataVars; Bool_t_debug; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; TVectorD*_dx; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_fixedShape; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooNDKeysPdf::BoxInfo_fullBoxInfo; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; vector<Int_t>_idx; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Double_t_maxWeight; vector<Double_t>_mean; Double_t_minWeight; Bool_t_mirror; Double_t_n; Int_t_nDim; Int_t_nEvents; Double_t_nEventsBMSW; Double_t_nEventsBW; Int_t_nEventsM; Double_t_nEventsW; Double_t_nSigma; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNDKeysPdf.html:44943,cache,cache,44943,root/html602/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html602/RooNDKeysPdf.html,4,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"stly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf103_interprfuncsDefinition rf103_interprfuncs.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(genpdf_over_genpdf_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_genpdf_over_genpdf_Int[x]_genpdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genpdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(g2_over_g2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_g2_over_g2_Int[x]_g1Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2551.39, estimated distance to minimum: 4.39288e-06; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; ------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf103__interprfuncs_8C.html:6654,optimiz,optimization,6654,doc/master/rf103__interprfuncs_8C.html,https://root.cern,https://root.cern/doc/master/rf103__interprfuncs_8C.html,4,['optimiz'],['optimization']
Performance,"stribution for signal events, used for spline fit. ;  ; TH1D * fMvaSigFineBin;  MVA distribution for signal events. ;  ; Bool_t fNotDoneYet;  flat to indicate of Method Transformations have been obtained yet or not (normally done in MethodBase::TrainMethod) ;  ; TString fOptimizationFitType;  which type of optimisation procedure to be used ;  ; std::map< TString, Double_t > fTunedParameters;  parameters included in the tuning ;  ; std::map< TString, TMVA::Interval * > fTuneParameters;  parameters included in the tuning ;  . #include <TMVA/OptimizeConfigParameters.h>. Inheritance diagram for TMVA::OptimizeConfigParameters:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ OptimizeConfigParameters(). TMVA::OptimizeConfigParameters::OptimizeConfigParameters ; (; MethodBase *const ; method, . std::map< TString, TMVA::Interval * > ; tuneParameters, . TString ; fomType = ""Separation"", . TString ; optimizationType = ""GA"" . ). Constructor which sets either ""Classification or Regression"". ; Definition at line 60 of file OptimizeConfigParameters.cxx. ◆ ~OptimizeConfigParameters(). TMVA::OptimizeConfigParameters::~OptimizeConfigParameters ; (; ). virtual . the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it) ; Definition at line 96 of file OptimizeConfigParameters.cxx. Member Function Documentation. ◆ Class(). static TClass * TMVA::OptimizeConfigParameters::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::OptimizeConfigParameters::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::OptimizeConfigParameters::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 100 of file OptimizeConfigParameters.h. ◆ DeclFileName(). static const char * TMVA::OptimizeConfigParameters::DeclFileName ; (; ). inlinestatic . Ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:4694,optimiz,optimizationType,4694,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['optimiz'],['optimizationType']
Performance,"string * ; FullFileName = nullptr . ). static . Checks if there is an ASTFile on disk for the given module M. ; Definition at line 1065 of file TCling.cxx. ◆ hasParsedRootmapForLibrary(). static bool hasParsedRootmapForLibrary ; (; llvm::StringRef ; lib). static . Definition at line 7252 of file TCling.cxx. ◆ hasPrecomputedLibraryDeps(). static bool hasPrecomputedLibraryDeps ; (; llvm::StringRef ; lib). static . Definition at line 7273 of file TCling.cxx. ◆ IsFromRootCling(). static bool IsFromRootCling ; (; ). static . Definition at line 1058 of file TCling.cxx. ◆ IsTupleAscending(). static ETupleOrdering IsTupleAscending ; (; ). static . Definition at line 3923 of file TCling.cxx. ◆ loadGlobalModuleIndex(). static GlobalModuleIndex * loadGlobalModuleIndex ; (; cling::Interpreter & ; interp). static . Definition at line 1080 of file TCling.cxx. ◆ LoadModule(). static bool LoadModule ; (; const std::string & ; ModuleName, . cling::Interpreter & ; interp . ). static . Returnstrue if the module was loaded. ; Definition at line 1030 of file TCling.cxx. ◆ LoadModules(). static void LoadModules ; (; const std::vector< std::string > & ; modules, . cling::Interpreter & ; interp . ). static . Loads the C++ modules that we require to run any ROOT program. ; This is just supposed to make a C++ module from a modulemap available to the interpreter. ; Definition at line 1052 of file TCling.cxx. ◆ PrintDlError(). static void PrintDlError ; (; const char * ; dyLibName, . const char * ; modulename . ). static . Definition at line 1964 of file TCling.cxx. ◆ R__InitStreamerInfoFactory(). static bool R__InitStreamerInfoFactory ; (; ). static . Helper to initialize TVirtualStreamerInfo's factor early. ; Use static initialization to insure only one TStreamerInfo is created. ; Definition at line 1664 of file TCling.cxx. ◆ RegisterCxxModules(). static void RegisterCxxModules ; (; cling::Interpreter & ; clingInterp). static . Definition at line 1183 of file TCling.cxx. ◆ RegisterPreInclude",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx.html:15053,load,loaded,15053,doc/master/TCling_8cxx.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx.html,1,['load'],['loaded']
Performance,"string of Python code that is executed as a statement. There is no return value, but an error message will be printed if there are problems such as syntax errors.; Eval(const char* expr)- the argument is a string of Python code that is evaluated as an expression. The result of the expression is returned, if it is either a builtin type (int, long, float, double, and const char* are supported), a Python type that can cross, or a ROOT type. If a ROOT type is returned, an explicit cast to void* is needed to assign the return value to a local pointer (which may have a different type), whereas builtin types will be cast implicitly, if possible, to the type of the local variable to which they are assigned.; Bind(TObject* obj,const char* label) - transfer a ROOT object from the Cling to the Python interpreter, where it will be referenced with a variable called “label”.; Prompt() - Transfer the interactive prompt to Python.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first with gSystem->Load() before use. Refer back to the other example of the use of TPython that was given in “Access to Python from ROOT”.; To show in detail how Python access can be used, an example Python module is needed, as follows:; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; This module can now be loaded into a Cling session, the class used to instantiate objects, and their member functions called for showing how different types can cross:; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; Note that the LoadMacro() call makes the class automatically available, such that it can be used directly. Otherwise, a gROOT->GetClass() call is required first.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1057953,load,loaded,1057953,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance,"string that matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfObsIter!; RooSetProxy_pdfObsListList of observables mapped onto histogram observables; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Double_t_totVolume! Total volume of space (product of ranges of observables); Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_unitNormAssume contents is u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistPdf.html:44437,cache,cache,44437,root/html602/RooHistPdf.html,https://root.cern,https://root.cern/root/html602/RooHistPdf.html,2,['cache'],['cache']
Performance,"string, value_type >::const_iterator RooAbsCategory::begin ; (; ); const. inline . Iterator for category state names. Points to pairs of index and name. ; Definition at line 91 of file RooAbsCategory.h. ◆ Class(). static TClass * RooAbsCategory::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCategory::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCategory::Class_Version ; (; ). inlinestaticconstexpr . A buffer for reading values from trees. ; ReturnsVersion of this class ; Definition at line 226 of file RooAbsCategory.h. ◆ clearTypes(). void RooAbsCategory::clearTypes ; (; ). protected . Delete all currently defined states. ; Definition at line 277 of file RooAbsCategory.cxx. ◆ copyCache(). void RooAbsCategory::copyCache ; (; const RooAbsArg * ; source, . bool ; valueOnly = false, . bool ; setValDirty = true . ). overrideprotectedvirtual . Copy the cached value from given source and raise dirty flag. ; It is the callers responsibility to ensure that the sources cache is clean(valid) before this function is called, e.g. by calling syncCache() on the source. ; Implements RooAbsArg.; Reimplemented in RooAbsCategoryLValue.; Definition at line 560 of file RooAbsCategory.cxx. ◆ createFundamental(). RooFit::OwningPtr< RooAbsArg > RooAbsCategory::createFundamental ; (; const char * ; newname = nullptr); const. overridevirtual . Create a RooCategory fundamental object with our properties. ; Implements RooAbsArg.; Definition at line 642 of file RooAbsCategory.cxx. ◆ createTable(). Roo1DTable * RooAbsCategory::createTable ; (; const char * ; label); const. Create a table matching the shape of this category. ; Definition at line 371 of file RooAbsCategory.cxx. ◆ DeclFileName(). static const char * RooAbsCategory::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 226 of file RooAbsCategory.h. ◆ defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategory.html:48295,cache,cached,48295,doc/master/classRooAbsCategory.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategory.html,1,['cache'],['cached']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddition.html:33351,cache,cache,33351,root/html534/RooAddition.html,https://root.cern,https://root.cern/root/html534/RooAddition.html,4,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxyRooAbsMoment::_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooRealProxy_ixfInt((X-offset)*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsMom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSecondMoment.html:34924,cache,cache,34924,root/html602/RooSecondMoment.html,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html,2,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxyRooAbsMoment::_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooRealProxy_ixfInt(X*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsMoment::_mea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFirstMoment.html:34810,cache,cache,34810,root/html602/RooFirstMoment.html,https://root.cern,https://root.cern/root/html602/RooFirstMoment.html,4,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsMoment.html:34741,cache,cache,34741,root/html602/RooAbsMoment.html,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html,2,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFormulaVar.html:35578,cache,cache,35578,root/html602/RooFormulaVar.html,https://root.cern,https://root.cern/root/html602/RooFormulaVar.html,2,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TVectorD_frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Int_t_ixmax; Int_t_ixmin; Int_t_iymax; Int_t_iymin; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; TMatrixD_mref; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo2DMomentMorphFunction.html:36125,cache,cache,36125,root/html602/Roo2DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html602/Roo2DMomentMorphFunction.html,2,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooListProxy_highSetHigh-side varaition; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; vector<int>_interpCode; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooListProxy_lowSetLow-side variation; static Int_tRooPrintable::_nameLengt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/PiecewiseInterpolation.html:34923,cache,cache,34923,root/html602/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html602/PiecewiseInterpolation.html,2,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; vector<double>_high; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Double_t_interpBoundary; vector<int>_interpCode; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Bool_t_logInit! flag used for chaching polynomial coefficients; vector",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__FlexibleInterpVar.html:35760,cache,cache,35760,root/html602/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__FlexibleInterpVar.html,2,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_epsPrecision; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooFunctor*_ftor! Functor binding of RooAbsReal; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLeng",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDerivative.html:34848,cache,cache,34848,root/html602/RooDerivative.html,https://root.cern,https://root.cern/root/html602/RooDerivative.html,2,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_errorSymmetric error associated with current value; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealVar.html:40491,cache,cache,40491,root/html602/RooRealVar.html,https://root.cern,https://root.cern/root/html602/RooRealVar.html,2,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_flatSFInt; Bool_t_flip; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGExpModel.html:45419,cache,cache,45419,root/html602/RooGExpModel.html,https://root.cern,https://root.cern/root/html602/RooGExpModel.html,2,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_flatSFInt; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_loc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGaussModel.html:44548,cache,cache,44548,root/html602/RooGaussModel.html,https://root.cern,https://root.cern/root/html602/RooGaussModel.html,2,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooListProxy_gamma; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistConstraint.html:41416,cache,cache,41416,root/html602/RooHistConstraint.html,https://root.cern,https://root.cern/root/html602/RooHistConstraint.html,2,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TF1*_func; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTFnPdfBinding.html:41358,cache,cache,41358,root/html602/RooTFnPdfBinding.html,https://root.cern,https://root.cern/root/html602/RooTFnPdfBinding.html,2,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenericPdf.html:42290,cache,cache,42290,root/html602/RooGenericPdf.html,https://root.cern,https://root.cern/root/html602/RooGenericPdf.html,2,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooCategoryProxyRooSimultaneous::_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__HistFactorySimultaneous.html:43407,cache,cache,43407,root/html602/RooStats__HistFactory__HistFactorySimultaneous.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__HistFactorySimultaneous.html,2,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooCategoryProxy_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimultaneous.html:42478,cache,cache,42478,root/html602/RooSimultaneous.html,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html,2,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_nNumber of expected events;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExtendedTerm.html:41489,cache,cache,41489,root/html602/RooExtendedTerm.html,https://root.cern,https://root.cern/root/html602/RooExtendedTerm.html,4,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo2DKeysPdf.html:42457,cache,cache,42457,root/html602/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html602/Roo2DKeysPdf.html,80,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTruthModel.html:44074,cache,cache,44074,root/html602/RooTruthModel.html,https://root.cern,https://root.cern/root/html602/RooTruthModel.html,2,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooResolutionModel.html:43928,cache,cache,43928,root/html602/RooResolutionModel.html,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html,2,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsPdf.html:44674,cache,cache,44674,root/html602/RooAbsPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html,2,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooDataHist_dataSet; RooListProxy_dataVarsThe RooRealVars; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ParamHistFunc.html:35399,cache,cache,35399,root/html602/ParamHistFunc.html,https://root.cern,https://root.cern/root/html602/ParamHistFunc.html,8,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedReal.html:34528,cache,cache,34528,root/html534/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html,1,['cache'],['cache']
Performance,"string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedReal.html:34707,cache,cache,34707,root/html534/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html,4,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooListProxy_highSetHigh-side varaition; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; vector<int>_interpCode; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooListProxy_lowSetLow-side variation; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/PiecewiseInterpolation.html:33565,cache,cache,33565,root/html534/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html534/PiecewiseInterpolation.html,3,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"struct a Polynomial of degree 3 : a*x**3 + b*x**2 + c*x + d. Polynomial(double a, double b, double c, double d, double e). Construct a Polynomial of degree 4 : a*x**4 + b*x**3 + c*x**2 + dx + e. virtual ~Polynomial(); {}. const std::vector<std::complex <double> > & FindRoots(); use default copy-ctor and assignment operators; using ParamFunction::operator();. Find the polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). std::vector<double > FindRealRoots(). Find the only the real polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). const std::vector<std::complex <double> > & FindNumRoots(). Find the polynomial roots using always an iterative numerical methods; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). unsigned int Order() const. Order of Polynomial. { return fOrder; }. IGenFunction * Clone() const. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Implement the interface specified bby ROOT::Math::IGradientOneDim.; In the case of polynomial there is no advantage to compute both at the same time. double DoEvalPar(double x, const double* p) const. double DoDerivative(double x) const. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const. » Last changed: root/mathmore:$Id: Polynomial.h 37160 2010-12-01 21:52:04Z moneta $ » Last generated: 2010-12-02 00:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__Polynomial.html:5560,Optimiz,Optimized,5560,root/html528/ROOT__Math__Polynomial.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__Polynomial.html,1,['Optimiz'],['Optimized']
Performance,"struct a Polynomial of degree 3 : a*x**3 + b*x**2 + c*x + d. Polynomial(double a, double b, double c, double d, double e). Construct a Polynomial of degree 4 : a*x**4 + b*x**3 + c*x**2 + dx + e. virtual ~Polynomial(); {}. const std::vector<std::complex <double> > & FindRoots(); use default copy-ctor and assignment operators; using ParamFunction::operator();. Find the polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). std::vector<double > FindRealRoots(). Find the only the real polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). const std::vector<std::complex <double> > & FindNumRoots(). Find the polynomial roots using always an iterative numerical methods; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). unsigned int Order() const. Order of Polynomial. { return fOrder; }. IGenFunction * Clone() const. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Implement the interface specified bby ROOT::Math::IGradientOneDim.; In the case of polynomial there is no advantage to compute both at the same time. double DoEvalPar(double x, const double* p) const. double DoDerivative(double x) const. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const. » Last changed: root/mathmore:$Id: Polynomial.h 37160 2010-12-01 21:52:04Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__Polynomial.html:5562,Optimiz,Optimized,5562,root/html530/ROOT__Math__Polynomial.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__Polynomial.html,1,['Optimiz'],['Optimized']
Performance,"struct a Polynomial of degree 3 : a*x**3 + b*x**2 + c*x + d. Polynomial(double a, double b, double c, double d, double e). Construct a Polynomial of degree 4 : a*x**4 + b*x**3 + c*x**2 + dx + e. virtual ~Polynomial(); {}. const std::vector<std::complex <double> > & FindRoots(); use default copy-ctor and assignment operators; using ParamFunction::operator();. Find the polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). std::vector<double > FindRealRoots(). Find the only the real polynomial roots.; For n <= 4, the roots are found analytically while for larger order an iterative numerical method is used; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). const std::vector<std::complex <double> > & FindNumRoots(). Find the polynomial roots using always an iterative numerical methods; The numerical method used is from GSL (see <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_6.html#SEC53"" ). unsigned int Order() const. Order of Polynomial. { return fOrder; }. IGenFunction * Clone() const. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Implement the interface specified bby ROOT::Math::IGradientOneDim.; In the case of polynomial there is no advantage to compute both at the same time. double DoEvalPar(double x, const double* p) const. double DoDerivative(double x) const. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const. » Last changed: root/mathmore:$Id: Polynomial.h 37160 2010-12-01 21:52:04Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__Polynomial.html:5562,Optimiz,Optimized,5562,root/html532/ROOT__Math__Polynomial.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__Polynomial.html,1,['Optimiz'],['Optimized']
Performance,"structor Documentation. ◆ Value(). TGenCollectionProxy::Value::Value ; (; const std::string & ; info, . Bool_t ; silent, . size_t ; hint_pair_offset = 0, . size_t ; hint_pair_size = 0 . ). Constructor. ; Definition at line 316 of file TGenCollectionProxy.cxx. Member Function Documentation. ◆ DeleteItem(). void TGenCollectionProxy::Value::DeleteItem ; (; void * ; ptr). Definition at line 518 of file TGenCollectionProxy.cxx. ◆ IsValid(). Bool_t TGenCollectionProxy::Value::IsValid ; (; ). Return true if the Value has been properly initialized. ; Definition at line 511 of file TGenCollectionProxy.cxx. Member Data Documentation. ◆ fCase. UInt_t TGenCollectionProxy::Value::fCase. type of data of Value_type ; Definition at line 64 of file TGenCollectionProxy.h. ◆ fCtor. ROOT::NewFunc_t TGenCollectionProxy::Value::fCtor. Method cache for containee constructor. ; Definition at line 61 of file TGenCollectionProxy.h. ◆ fDelete. ROOT::DelFunc_t TGenCollectionProxy::Value::fDelete. Method cache for containee delete. ; Definition at line 63 of file TGenCollectionProxy.h. ◆ fDtor. ROOT::DesFunc_t TGenCollectionProxy::Value::fDtor. Method cache for containee destructor. ; Definition at line 62 of file TGenCollectionProxy.h. ◆ fKind. EDataType TGenCollectionProxy::Value::fKind. kind of ROOT-fundamental type ; Definition at line 67 of file TGenCollectionProxy.h. ◆ fProperties. UInt_t TGenCollectionProxy::Value::fProperties. Additional properties of the value type (kNeedDelete) ; Definition at line 65 of file TGenCollectionProxy.h. ◆ fSize. size_t TGenCollectionProxy::Value::fSize. fSize of the contained object ; Definition at line 68 of file TGenCollectionProxy.h. ◆ fType. TClassRef TGenCollectionProxy::Value::fType. TClass reference of Value_type in collection. ; Definition at line 66 of file TGenCollectionProxy.h. Collaboration diagram for TGenCollectionProxy::Value:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structTGenCollectionProxy_1_1Value.html:2270,cache,cache,2270,doc/master/structTGenCollectionProxy_1_1Value.html,https://root.cern,https://root.cern/doc/master/structTGenCollectionProxy_1_1Value.html,1,['cache'],['cache']
Performance,"structor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Calculate value. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDerivative.html:48402,cache,cached,48402,doc/master/classRooDerivative.html,https://root.cern,https://root.cern/doc/master/classRooDerivative.html,10,['cache'],"['cache', 'cached']"
Performance,"structor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ;  ; RooFit::OwningPtr< RooAbsFunc > bindVars (const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) const;  Create an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order). ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a \( \chi^2 \) fit to given histogram. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooLinkedList &cmdList);  Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooLinkedList &cmdList);  Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ;  ; virtual RooFit::OwningPtr< RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:5947,Perform,Perform,5947,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,1,['Perform'],['Perform']
Performance,"structor. ; Definition at line 213 of file TMehrotraSolver.cxx. Member Function Documentation. ◆ Class(). static TClass * TMehrotraSolver::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMehrotraSolver::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMehrotraSolver::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 85 of file TMehrotraSolver.h. ◆ DeclFileName(). static const char * TMehrotraSolver::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 85 of file TMehrotraSolver.h. ◆ DefMonitor(). void TMehrotraSolver::DefMonitor ; (; TQpDataBase * ; data, . TQpVar * ; vars, . TQpResidual * ; resids, . Double_t ; alpha, . Double_t ; sigma, . Int_t ; i, . Double_t ; mu, . Int_t ; status_code, . Int_t ; level . ). overridevirtual . Print information about the optimization process and monitor the convergence status of thye algorithm. ; Implements TQpSolverBase.; Definition at line 171 of file TMehrotraSolver.cxx. ◆ IsA(). TClass * TMehrotraSolver::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 85 of file TMehrotraSolver.h. ◆ operator=(). TMehrotraSolver & TMehrotraSolver::operator= ; (; const TMehrotraSolver & ; source). Assignment operator. ; Definition at line 222 of file TMehrotraSolver.cxx. ◆ Solve(). Int_t TMehrotraSolver::Solve ; (; TQpDataBase * ; prob, . TQpVar * ; iterate, . TQpResidual * ; resid . ). overridevirtual . Solve the quadratic programming problem as formulated through prob, store the final solution in iterate->fX . ; Monitor the residuals during the iterations through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . ; Implements TQpSolverBase.; Definition at line 97 of file TMehrotraSolver.cxx. ◆ Streamer(). void TMehrotraSolver:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMehrotraSolver.html:15386,optimiz,optimization,15386,doc/master/classTMehrotraSolver.html,https://root.cern,https://root.cern/doc/master/classTMehrotraSolver.html,1,['optimiz'],['optimization']
Performance,"structor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; virtual void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients)=0;  Update the biases, given the current bias gradients. ;  ; virtual void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients)=0;  Update the weights, given the current weight gradients. ;  . Protected Attributes; DeepNet_t & fDeepNet;  The reference to the deep net. ;  ; size_t fGlobalStep;  The current global step count during training. ;  ; Scalar_t fLearningRate;  The learning rate used for training. ;  . #include <TMVA/DNN/Optimizer.h>. Inheritance diagram for TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Matrix_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::Matrix_t = typename Architecture_t::Matrix_t. Definition at line 47 of file Optimizer.h. ◆ Scalar_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::Scalar_t = typename Architecture_t::Scalar_t. Definition at line 48 of file Optimizer.h. Constructor & Destructor Documentation. ◆ VOptimizer(). template<typename Architecture_t , typename Layer_t , typename DeepNet_t > . TMVA::DNN::VOp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VOptimizer.html:2052,Optimiz,Optimizer,2052,doc/master/classTMVA_1_1DNN_1_1VOptimizer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VOptimizer.html,1,['Optimiz'],['Optimizer']
Performance,"sts; 41 std::thread fThrd; ///<! own thread; 42 Bool_t fWSOnly{kFALSE}; ///<! when true, handle only websockets / longpoll engine; 43 ; 44 TString fJSROOTSYS; ///<! location of local JSROOT files; 45 TString fTopName{""ROOT""}; ///<! name of top folder, default - ""ROOT""; 46 TString fJSROOT; ///<! location of external JSROOT files; 47 ; 48 std::map<std::string, std::string> fLocations; ///<! list of local directories, which could be accessed via server; 49 ; 50 std::string fDefaultPage; ///<! file name for default page name; 51 std::string fDefaultPageCont; ///<! content of default html page; 52 std::string fDrawPage; ///<! file name for drawing of single element; 53 std::string fDrawPageCont; ///<! content of draw html page; 54 std::string fCors; ///<! CORS: sets Access-Control-Allow-Origin header for ProcessRequest responses; 55 std::string fCorsCredentials; ///<! CORS: add Access-Control-Allow-Credentials: true response header; 56 ; 57 std::mutex fMutex; ///<! mutex to protect list with arguments; 58 std::queue<std::shared_ptr<THttpCallArg>> fArgs; ///<! submitted arguments; 59 ; 60 std::mutex fWSMutex; ///<! mutex to protect WS handler lists; 61 std::vector<std::shared_ptr<THttpWSHandler>> fWSHandlers; ///<! list of WS handlers; 62 ; 63 virtual void MissedRequest(THttpCallArg *arg);; 64 ; 65 virtual void ProcessRequest(std::shared_ptr<THttpCallArg> arg);; 66 ; 67 virtual void ProcessBatchHolder(std::shared_ptr<THttpCallArg> &arg);; 68 ; 69 void StopServerThread();; 70 ; 71 std::string BuildWSEntryPage();; 72 ; 73 void ReplaceJSROOTLinks(std::shared_ptr<THttpCallArg> &arg, const std::string &version = """");; 74 ; 75 static Bool_t VerifyFilePath(const char *fname);; 76 ; 77 THttpServer(const THttpServer &) = delete;; 78 THttpServer &operator=(const THttpServer &) = delete;; 79 ; 80public:; 81 THttpServer(const char *engine = ""http:8080"");; 82 virtual ~THttpServer();; 83 ; 84 Bool_t CreateEngine(const char *engine);; 85 ; 86 Bool_t IsAnyEngine() const { return fEngines.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8h_source.html:2634,queue,queue,2634,doc/master/THttpServer_8h_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html,1,['queue'],['queue']
Performance,"stsDataSet(const char* uri); Returns kTRUE if 'dataset' described by 'uri' exists, kFALSE otherwise. TMap * GetDataSets(const char* uri = """", const char* = 0); lists all datasets that match given uri. void ShowDataSets(const char* uri = """", const char* = 0); Shows datasets in locations that match the uri; By default shows the user's datasets and global ones. TFileCollection * GetDataSet(const char* uri, const char* = 0); Get a list of TFileInfo objects describing the files of the specified; dataset. Int_t RemoveDataSet(const char* uri, const char* = 0); Remove the specified dataset from the PROOF cluster.; Files are not deleted. Int_t VerifyDataSet(const char* uri, const char* = 0); Verify if all files in the specified dataset are available.; Print a list and return the number of missing files. void ClearDataSetCache(const char* dataset = 0); Clear the content of the dataset cache, if any (matching 'dataset', if defined). void ShowDataSetCache(const char* dataset = 0); Display the content of the dataset cache, if any (matching 'dataset', if defined). void SendInputDataFile(); Make sure that the input data objects are available to the workers in a; dedicated file in the cache; the objects are taken from the dedicated list; and / or the specified file.; If the fInputData is empty the specified file is sent over.; If there is no specified file, a file named ""inputdata.root"" is created locally; with the content of fInputData and sent over to the master.; If both fInputData and the specified file are not empty, a copy of the file; is made locally and augmented with the content of fInputData. Int_t Remove(const char* ref, Bool_t all); Handle remove request. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. TProofLite(const TProofLite& ). void operator=(const TProofLite& ). TProofLite(); { }. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); { return TProo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:31360,cache,cache,31360,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,1,['cache'],['cache']
Performance,"stsDataSet(const char* uri); Returns kTRUE if 'dataset' described by 'uri' exists, kFALSE otherwise. TMap * GetDataSets(const char* uri = """", const char* = 0); lists all datasets that match given uri. void ShowDataSets(const char* uri = """", const char* = 0); Shows datasets in locations that match the uri; By default shows the user's datasets and global ones. TFileCollection * GetDataSet(const char* uri, const char* = 0); Get a list of TFileInfo objects describing the files of the specified; dataset. Int_t RemoveDataSet(const char* uri, const char* = 0); Remove the specified dataset from the PROOF cluster.; Files are not deleted. Int_t VerifyDataSet(const char* uri, const char* = 0); Verify if all files in the specified dataset are available.; Print a list and return the number of missing files. void ClearDataSetCache(const char* dataset = 0); Clear the content of the dataset cache, if any (matching 'dataset', if defined). void ShowDataSetCache(const char* dataset = 0); Display the content of the dataset cache, if any (matching 'dataset', if defined). void SendInputDataFile(); Make sure that the input data objects are available to the workers in a; dedicated file in the cache; the objects are taken from the dedicated list; and / or the specified file.; If the fInputData is empty the specified file is sent over.; If there is no specified file, a file named ""inputdata.root"" is created locally; with the content of fInputData and sent over to the master.; If both fInputData and the specified file are not empty, a copy of the file; is made locally and augmented with the content of fInputData. Int_t Remove(const char* ref, Bool_t all); Handle remove request. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. void FindUniqueSlaves(); Add to the fUniqueSlave list the active slaves that have a unique; (user) file system image. This information is used to transfer files; only once to nodes that share a file system",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofLite.html:31823,cache,cache,31823,root/html530/TProofLite.html,https://root.cern,https://root.cern/root/html530/TProofLite.html,2,['cache'],['cache']
Performance,"style; static Long64_tfgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:34577,cache,cache,34577,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,1,['cache'],['cache']
Performance,"style; static Long64_tfgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:35063,cache,cache,35063,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['cache'],['cache']
Performance,"style; static Long64_tfgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filenam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:36309,cache,cache,36309,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,1,['cache'],['cache']
Performance,"sualization; are those defined before closing the geometry. void CloseGeometry(Option_t* option = ""d""); Closing geometry implies checking the geometry validity, fixing shapes; with negative parameters (run-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the current navigator. void ConvertReflections(); Convert all reflections in geometry to normal rotations + reflected shapes. Int_t CountNodes(const TGeoVolume* vol = 0, Int_t nlevels = 10000, Int_t option = 0); Count the total number of nodes starting from a volume, nlevels down. void DefaultAngles(); Set default angles for a given view. void DrawCurrentPoint(Int_t color = 2); Draw current point in the same view. void AnimateTracks(Double_t tmin = 0, Double_t tmax = 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:44433,cache,cache,44433,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,3,['cache'],['cache']
Performance,"sualization; are those defined before closing the geometry. void CloseGeometry(Option_t* option = ""d""); Closing geometry implies checking the geometry validity, fixing shapes; with negative parameters (run-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the current navigator. void ConvertReflections(); Convert all reflections in geometry to normal rotations + reflected shapes. void CountLevels(); Count maximum number of nodes per volume, maximum depth and maximum; number of xtru vertices. Int_t CountNodes(const TGeoVolume* vol = 0, Int_t nlevels = 10000, Int_t option = 0); Count the total number of nodes starting from a volume, nlevels down. void DefaultAngles(); Set default angles for a given view. void DrawCurrentPo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoManager.html:46779,cache,cache,46779,root/html534/TGeoManager.html,https://root.cern,https://root.cern/root/html534/TGeoManager.html,3,['cache'],['cache']
Performance,subset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*_dataPointer to original input dataset; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*_funcPointer to original input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; const RooArgSet*_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; string_rangeNameName of range in which to calculate test statistic; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value ne,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsTestStatistic.html:32498,cache,cache,32498,root/html526/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsTestStatistic.html,1,['cache'],['cache']
Performance,subset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*_dataPointer to original input dataset; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*_funcPointer to original input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; const RooArgSet*_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; string_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRoo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsTestStatistic.html:33040,cache,cache,33040,root/html528/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html528/RooAbsTestStatistic.html,2,['cache'],['cache']
Performance,"subset of dimensions ;  CTHistViewOutOfRange;  CTLogEntry;  CTLogHandlerAbstract TLogHandler base class ;  CTLogManager;  ►NFitNamespace for the fitting classes ;  CBasicFCNBasicFCN class: base class for the objective functions used in the fits It has a reference to the data and th emodel function used in the fit ;  CBinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y values and error on coordinates The dimension of the coordinate is free There are 4 different options: ;  CBinPointObsolete class, no more in use ;  CChi2FCNChi2FCN class for binnned fits using the least square methods ;  CDataOptionsDataOptions : simple structure holding the options on how the data are filled ;  CDataRangeClass describing the range in the coordinates it supports multiple range in a coordinate ;  CDataVectorClass holding the fit data points ;  CDataWrapperClass maintaining a pointer to external data Using this class avoids copying the data when performing a fit NOTE: this class is not thread-safe and should not be used in parallel fits ;  CDummyDeleter;  CFcnAdapter;  CFitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::ParameterSettings class ;  CFitDataBase class for all the fit data types ;  CFitResultClass containg the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values ;  CFitterFitter class, entry point for performing all type of fits ;  CLogLikelihoodFCNLogLikelihoodFCN class for likelihood fits ;  CParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/retrieve values, step sizes, limits and fix the parameters ;  CPoissonLikelihoodFCNClass evaluating the log likelihood for binned Poisson likelihood fits it is template to distinguish g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:17279,perform,performing,17279,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['perform'],['performing']
Performance,"such a binning is not set, the same number of bins as for convVar will be used. ; [in]pdfConvVarIf the variable used for convolution is a PDF, itself, pass the PDF here, and pass the convolution variable to convVar. See also rf210_angularconv.C in the roofit tutorials . Definition at line 248 of file RooFFTConvPdf.cxx. ◆ RooFFTConvPdf() [4/4]. RooFFTConvPdf::RooFFTConvPdf ; (; const RooFFTConvPdf & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 272 of file RooFFTConvPdf.cxx. ◆ ~RooFFTConvPdf(). RooFFTConvPdf::~RooFFTConvPdf ; (; ). override . Destructor. ; Definition at line 292 of file RooFFTConvPdf.cxx. Member Function Documentation. ◆ actualObservables(). RooFit::OwningPtr< RooArgSet > RooFFTConvPdf::actualObservables ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Return the observables to be cached given the normalization set nset. ; If the cache observable is in nset then this is; the convolution observable plus; any member of nset that is either a RooCategory,; or was previously specified through setCacheObservables(). In case the cache observable is not in nset, then it is; the convolution observable plus; all member of nset that are observables of this p.d.f. . Implements RooAbsCachedPdf.; Definition at line 778 of file RooFFTConvPdf.cxx. ◆ actualParameters(). RooFit::OwningPtr< RooArgSet > RooFFTConvPdf::actualParameters ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Return the parameters on which the cache depends given normalization set nset. ; For this p.d.f these are the parameters of the input p.d.f. but never the convolution variable, in case it is not part of nset. ; Implements RooAbsCachedPdf.; Definition at line 833 of file RooFFTConvPdf.cxx. ◆ bufferFraction(). double RooFFTConvPdf::bufferFraction ; (; ); const. inline . Return value of buffer fraction applied in FFT calculation array beyond either end of the observable domain to reduce cyclical effects. ; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:87092,cache,cache,87092,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cache']
Performance,"such as the object’s name, the object’s type, its coordinates, etc.).; Colors: creates a new canvas showing the color palette.; Markers: creates a new canvas showing the various marker styles.; Iconify: create the canvas window icon, does not close the canvas; View With…: If the last selected pad contains a 3-d structure, a new canvas is created with a 3-D picture according to the selection made from the cascaded menu: X3D or OpenGL. The 3-D image can be interactively rotated, zoomed in wire-frame, solid, hidden line or stereo mode. 2.3.1.4 Options Menu. Auto Resize Canvas: turns auto-resize of the canvas on/off:. on - the canvas fits to the window when changing the window size;; off - the canvas stays fixed when changing the window size. Resize Canvas: resizes and fits the canvas to the window size.; Move Opaque: if selected, graphics objects are moved in opaque mode; otherwise, only the outline of objects is drawn when moving them. The option opaque produces the best effect but it requires a reasonably fast workstation or response time.; Resize Opaque: if selected, graphics objects are resized in opaque mode; otherwise, only the outline of objects is drawn when resizing them.; Interrupt: interrupts the current drawing process.; Refresh: redraws the canvas contents.; Pad Auto Exec: executes the list of TExecs in the current pad.; Statistics: toggles the display of the histogram statistics box.; Histogram Title: toggles the display of the histogram title.; Fit Parameters: toggles the display of the histogram or graph fit parameters.; Can Edit Histogram: enables/disables the possibility to edit histogram bin contents. 2.3.1.5 Inspect Menu. ROOT: inspects the top-level gROOT object (in a new canvas).; Start Browser: starts a new object browser (in a separate window).; GUI Builder: starts the GUI builder application (in a separate window). 2.3.1.6 Help Menu. Canvas: help on canvas as a whiteboard area for drawing.; Menus: help on canvas menus.; Graphics Editor: help on ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:39831,response time,response time,39831,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['response time'],['response time']
Performance,"such; and will be precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeDataStore.html:16925,cache,cacheArgs,16925,root/html532/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html,3,"['Cache', 'cache']","['Cache', 'cache', 'cacheArgs']"
Performance,"suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:215097,cache,cacheSize,215097,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,4,['cache'],"['cacheFactor', 'cacheSize']"
Performance,"sult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; Long64_t DrawSelect (TDSet *set, const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Draw (may not be used in this class). ;  ; void Feedback (TList *objs) override;  Set feedback list (may not be used in this class). ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize query (may not be used in this class). ;  ; Long64_t Finalize (TQueryResult *qr) override;  Finalize query (may not be used in this class). ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TDSetElement * GetNextPacket (TSlave *slave, TMessage *r) override;  Get next packet (may not be used in this class). ;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override;  Get output list. ;  ; TVirtualPacketizer * GetPacketizer () const override;  ; TProofProgressStatus * GetProgressStatus () const override;  ; TQueryResul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:3590,cache,cache,3590,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,3,['cache'],['cache']
Performance,"sult of this action (of type; 2941 /// Result_t). The RResultPtr returned by Book will point to this object. Note that this method can be called; 2942 /// _before_ Initialize(), because the RResultPtr is constructed before the event loop is started.; 2943 /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; 2944 /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; 2945 /// or copies of it, might be used for multiple event loops (e.g. in the presence of systematic variations).; 2946 /// * `void InitTask(TTreeReader *, unsigned int slot)`: each working thread shall call this method during the event; 2947 /// loop, before processing a batch of entries. The pointer passed as argument, if not null, will point to the TTreeReader; 2948 /// that RDataFrame has set up to read the task's batch of entries. It is passed to the helper to allow certain advanced optimizations; 2949 /// it should not usually serve any purpose for the Helper. This method is often no-op for simple helpers.; 2950 /// * `void Exec(unsigned int slot, ColumnTypes...columnValues)`: each working thread shall call this method; 2951 /// during the event-loop, possibly concurrently. No two threads will ever call Exec with the same 'slot' value:; 2952 /// this parameter is there to facilitate writing thread-safe helpers. The other arguments will be the values of; 2953 /// the requested columns for the particular entry being processed.; 2954 /// * `void Finalize()`: this method is called at the end of the event loop. Commonly used to finalize the contents of the result.; 2955 /// * `std::string GetActionName()`: it returns a string identifier for this type of action that RDataFrame will use in; 2956 /// diagnostics, SaveGraph(), etc.; 2957 ///; 2958 /// ### Optional methods; 2959 ///; 2960 /// If these methods are implemented they enable extra functionality as per the description below.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:166764,optimiz,optimizations,166764,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['optimiz'],['optimizations']
Performance,"suppress its failures and warning messages from stdout. ;  ; bool IsFloatingType (const void *QualTypePtr) const;  ; bool IsIntegerType (const void *QualTypePtr) const;  ; Bool_t IsLibraryLoaded (const char *libname) const final;  ; Bool_t IsLoaded (const char *filename) const final;  Return true if the file has already been loaded by cint. ;  ; bool IsPointerType (const void *QualTypePtr) const;  ; Bool_t IsProcessLineLocked () const final;  ; bool IsSameType (const void *QualTypePtr1, const void *QualTypePtr2) const;  ; bool IsSignedIntegerType (const void *QualTypePtr) const;  ; bool IsUnsignedIntegerType (const void *QualTypePtr) const;  ; bool IsVoidPointerType (const void *QualTypePtr) const;  ; void * LazyFunctionCreatorAutoload (const std::string &mangled_name);  Autoload a library based on a missing symbol. ;  ; void LibraryLoaded (const void *dyLibHandle, const char *canonicalName);  ; bool LibraryLoadingFailed (const std::string &, const std::string &, bool, bool);  ; void LibraryUnloaded (const void *dyLibHandle, const char *canonicalName);  ; Int_t Load (const char *filenam, Bool_t system=kFALSE) final;  Load a library file in cling's memory. ;  ; void LoadEnums (TListOfEnums &cl) const final;  Create list of pointers to enums for TClass cl. ;  ; int LoadFile (const char *path) const final;  Load a source file or library called path into the interpreter. ;  ; virtual void LoadFunctionTemplates (TClass *cl) const final;  Create list of pointers to function templates for TClass cl. ;  ; Int_t LoadLibraryMap (const char *rootmapfile=nullptr) final;  Load map between class and library. ;  ; void LoadMacro (const char *filename, EErrorCode *error=nullptr) final;  Load a macro file in cling's memory. ;  ; Bool_t LoadText (const char *text) const final;  Load the declarations from text into the interpreter. ;  ; std::unique_ptr< TInterpreterValue > MakeInterpreterValue () const final;  ; const char * MapCppName (const char *) const final;  Interface to cling f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:23631,Load,Load,23631,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,2,['Load'],['Load']
Performance,"sy to make and mismatches between Streamer writers and readers are frequent and increase as the number of classes increase. We recommend you use rootcling generated Streamers whenever you can, and profit from the automatic schema evolution.; 11.5.8 Building Class Definitions with the StreamerInfo; A ROOT file’s StreamerInfolist contains the description of all versions of all classes in the file. When a file is opened the StreamerInfois read into memory and it provides enough information to make the file browsable. The TStreamerInfoenables us to recreate a header file for the class in case the compiled class is not available. This is done with the TFile::MakeProject method. It creates a directory with the header files for the named classes and a makefile to compile a shared library with the class definitions.; 11.5.9 Example: MakeProject; To explain the details, we use the example of the ATLFast project that is a fast simulation for the ATLAS experiment. The complete source for ATLFast can be down loaded at ftp://root.cern.ch/root/atlfast.tar.gz. Once we compile and run ATLFast we get a ROOT file called atlfast.root, containing the ATLFast objects. When we open the file, we get a warning that the file contains classes that are not in the dictionary. This is correct since we did not load the class definitions.; root[] TFile f(""atlfast.root""); Warning in <TClass::TClass>: no dictionary for class TMCParticle is available; Warning in <TClass::TClass>: no dictionary for class ATLFMuon available; We can see the StreamerInfofor the classes:; root[] f.ShowStreamerInfo(); ...; StreamerInfo for class: ATLFMuon, version=1; BASE TObject offset= 0 type=66 Basic ROOT object; BASE TAtt3D offset= 0 type= 0 3D attributes; Int_t m_KFcode offset= 0 type= 3 Muon KF-code; Int_t m_MCParticle offset= 0 type= 3 Muon position in MCParticles list; Int_t m_KFmother offset= 0 type= 3 Muon mother KF-code; Int_t m_UseFlag offset= 0 type= 3 Muon energy usage flag; Int_t m_Isolated offset= 0 type= ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:506344,load,loaded,506344,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance,"sym, RooAbsCategory& blindState); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindCPAsymVar.html:24829,cache,cache,24829,root/html602/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html602/RooUnblindCPAsymVar.html,2,['cache'],['cache']
Performance,"system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Find a dynamic library called lib using the system search paths.; Appends known extensions if needed. Returned string must be deleted; by the user!. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Find a dynamic library using the system search paths. lib will be updated; to contain the absolute filename if found. Returns lib if found, or NULL; if a library called lib was not found.; This function does not open the library. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSystem.html:35427,load,loaded,35427,root/html602/TSystem.html,https://root.cern,https://root.cern/root/html602/TSystem.html,2,['load'],['loaded']
Performance,"system.rootrc,; //it will appear in the GL viewer; //#Viewer3D.DefaultDrawOption: ogl; ; geom->SetVisLevel(4);; if (vis) top->Draw(""ogle"");; }; ; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; kYellow@ kYellowDefinition Rtypes.h:66; gGeoIdentityR__EXTERN TGeoIdentity * gGeoIdentityDefinition TGeoMatrix.h:537; R; TGeoArb8Definition TGeoArb8.h:17; TGeoArb8::SetVertexvirtual void SetVertex(Int_t vnum, Double_t x, Double_t y); TGeoCombiTransClass describing rotation + translation.Definition TGeoMatrix.h:317; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::TGeoManagerTGeoManager()Default constructor.Definition TGeoManager.cxx:311; TGeoManager::MakeArb8TGeoVolume * MakeArb8(const char *name, TGeoMedium *medium, Double_t dz, Double_t *vertices=nullptr)Make an TGeoArb8 volume.Definition TGeoManager.cxx:3161; TGeoManager::SetVisLevelvoid SetVisLevel(Int_t level=3)set default level down to which visualization is performedDefinition TGeoManager.cxx:2459; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoManager::SetTopVolumevoid SetTopVolume(TGeoVolume *vol)Set the top volume and corresponding node as starting point of the geometry.Definition TGeoManager.cxx:3655; TGeoManager::MakeTubsTGeoVolume * MakeTubs(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2)Make in one step a volume pointing to a tube segment shape with given medium.Definition TGeoManager.cxx:3213; TGeoMaterialBase class describing materials.Definition TGeoMateri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:10847,perform,performedDefinition,10847,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['perform'],['performedDefinition']
Performance,"systematic uncertainties. ; Given a nominal distribution and one or more altered or distorted ones, it computes a new shape depending on the value of the nuisance parameters \( \alpha_i \): ; \[; A = \sum_i \mathrm{Interpolate}(\mathrm{low}_i, \mathrm{nominal}, \mathrm{high}_i, \alpha_i).; \]. If an \( \alpha_i \) is zero, the distribution is identical to the nominal distribution, at \( \pm 1 \) it is identical to the up/down distribution for that specific \( i \).; The class supports several interpolation methods, which can be selected for each parameter separately using setInterpCode(). The default interpolation code is 4. This performs; \( |\alpha | > 1 \): Linear extrapolation.; \( |\alpha | < 1 \): Polynomial interpolation. A sixth-order polynomial is used. Its coefficients are chosen such that function, first, and second derivative at \( \alpha \pm 1 \) match the values that the extrapolation procedure uses. . Definition at line 30 of file PiecewiseInterpolation.h. Classes; class  CacheElem;  . Public Member Functions;  PiecewiseInterpolation ();  ;  PiecewiseInterpolation (const char *name, const char *title, const RooAbsReal &nominal, const RooArgList &lowSet, const RooArgList &highSet, const RooArgList &paramSet);  Construct a new interpolation. ;  ;  PiecewiseInterpolation (const PiecewiseInterpolation &other, const char *name=nullptr);  Copy constructor. ;  ;  ~PiecewiseInterpolation () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Implement analytical integrations by doing appropriate weighting from component integrals functions to integrators of components. ;  ; std::list< double > * binBoundaries (RooAbsRealLValue &, double, double) const override;  WVE note: assumes nominal and alternates have identical structure, must add explicit check. ;  ; TObject * clone (const char *newname) const override;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classPiecewiseInterpolation.html:1487,Cache,CacheElem,1487,doc/master/classPiecewiseInterpolation.html,https://root.cern,https://root.cern/doc/master/classPiecewiseInterpolation.html,1,['Cache'],['CacheElem']
Performance,"t 'coord'. Double_t binVolume(const RooArgSet& bin); Return the volume of the bin enclosing coordinates 'coord'. void setAllWeights(Double_t value); Set all the event weight of all bins to the specified value. TIterator* sliceIterator(RooAbsArg& sliceArg, const RooArgSet& otherArgs); Create an iterator over all bins in a slice defined by the subset of observables; listed in sliceArg. The position of the slice is given by otherArgs. void SetName(const char* name); Change the name of the RooDataHist. void SetNameTitle(const char* name, const char* title); Change the title of this RooDataHist. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. void cacheValidEntries(); Cache the datahist entries with bin centers that are inside/outside the; current observable definitio. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Bool_t isNonPoissonWeighted() const; Returns true if datasets contains entries with a non-integer weight. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print the details on the dataset contents. void Streamer(TBuffer& ); Stream an object of class RooDataHist. TObject* Clone(const char* newname = 0) const; { return new RooDataHist(*this,newname?newname:GetName()) ; }. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* = 0) const; Return empty clone of this RooDataHist. void add(const RooArgSet& row, Double_t wgt = 1.); Add one ore more rows of data. const RooArgSet* get() const; Return set with coordinates of center of current bin. Bool_t isWeighted() const; Return true as all histograms have in principle events weight != 1. Double_t weight() const; Return weight of current bin. Double_t binVolume() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataHist.html:35864,load,loaded,35864,root/html602/RooDataHist.html,https://root.cern,https://root.cern/root/html602/RooDataHist.html,2,['load'],['loaded']
Performance,"t 'coord'. Double_t binVolume(const RooArgSet& bin); Return the volume of the bin enclosing coordinates 'coord'. void setAllWeights(Double_t value); Set all the event weight of all bins to the specified value. TIterator* sliceIterator(RooAbsArg& sliceArg, const RooArgSet& otherArgs); Create an iterator over all bins in a slice defined by the subset of observables; listed in sliceArg. The position of the slice is given by otherArgs. void SetName(const char* name); Change the name of the RooDataHist. void SetNameTitle(const char* name, const char* title); Change the title of this RooDataHist. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. void cacheValidEntries(); Cache the datahist entries with bin centers that are inside/outside the; current observable definitio. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Bool_t isNonPoissonWeighted() const; Returns true if datasets contains entries with a non-integer weight. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print the details on the dataset contents. void Streamer(TBuffer& ); Stream an object of class RooDataHist. TObject* Clone(const char* newname = 0) const; { return new RooDataHist(*this,newname?newname:GetName()) ; }. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* = 0) const; Return empty clone of this RooDataHist. void add(const RooArgSet& row, Double_t wgt = 1.0); Add one ore more rows of data. const RooArgSet* get() const; Return set with coordinates of center of current bin. Bool_t isWeighted() const; Return true as all histograms have in principle events weight != 1. Double_t weight() const; Return weight of current bin. Double_t binVolume() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataHist.html:34659,load,loaded,34659,root/html534/RooDataHist.html,https://root.cern,https://root.cern/root/html534/RooDataHist.html,1,['load'],['loaded']
Performance,"t 'coord'. Double_t binVolume(const RooArgSet& bin); Return the volume of the bin enclosing coordinates 'coord'. void setAllWeights(Double_t value); Set all the event weight of all bins to the specified value. TIterator* sliceIterator(RooAbsArg& sliceArg, const RooArgSet& otherArgs); Create an iterator over all bins in a slice defined by the subset of observables; listed in sliceArg. The position of the slice is given by otherArgs. void SetName(const char* name); Change the name of the RooDataHist. void SetNameTitle(const char* name, const char* title); Change the title of this RooDataHist. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. void cacheValidEntries(); Cache the datahist entries with bin centers that are inside/outside the; current observable definitio. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Bool_t isNonPoissonWeighted() const; Returns true if datasets contains entries with a non-integer weight. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print the details on the dataset contents. void Streamer(TBuffer& b); Stream an object of class RooDataHist. TObject* Clone(const char* newname = 0) const; { return new RooDataHist(*this,newname?newname:GetName()) ; }. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const; Return empty clone of this RooDataHist. void add(const RooArgSet& row, Double_t wgt = 1.0); Add one ore more rows of data. const RooArgSet* get() const; Return set with coordinates of center of current bin. Bool_t isWeighted() const; Return true as all histograms have in principle events weight != 1. Double_t weight() const; Return weight of current bin. Double_t binVolume() const; { return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataHist.html:31350,load,loaded,31350,root/html526/RooDataHist.html,https://root.cern,https://root.cern/root/html526/RooDataHist.html,4,['load'],['loaded']
Performance,"t 'nevt' controls the number of events per file (-1 for the default, which is 30000). Return 0 on success, -1 on error ; Definition at line 1343 of file TProofBench.cxx. ◆ OpenOutFile(). Int_t TProofBench::OpenOutFile ; (; Bool_t ; wrt = kFALSE, . Bool_t ; verbose = kTRUE . ). Set the otuput file Return 0 on success, -1 on error. ; Definition at line 261 of file TProofBench.cxx. ◆ ReleaseCache(). Int_t TProofBench::ReleaseCache ; (; const char * ; dset). Release memory cache for dataset 'dset' Return 0 on success, -1 on error. ; Definition at line 1303 of file TProofBench.cxx. ◆ RemoveDataSet(). Int_t TProofBench::RemoveDataSet ; (; const char * ; dset). Physically remove the dataset 'dset', i.e. ; remove the dataset and the files it describes Return 0 on success, -1 on error ; Definition at line 1315 of file TProofBench.cxx. ◆ RunCPU(). Int_t TProofBench::RunCPU ; (; Long64_t ; nevents = -1, . Int_t ; start = -1, . Int_t ; stop = -1, . Int_t ; step = -1 . ). Perform the CPU run Return 0 on success, -1 on error. ; Definition at line 336 of file TProofBench.cxx. ◆ RunCPUx(). Int_t TProofBench::RunCPUx ; (; Long64_t ; nevents = -1, . Int_t ; start = -1, . Int_t ; stop = -1 . ). Perform the CPU run scanning over the number of workers per node Return 0 on success, -1 on error. ; Definition at line 365 of file TProofBench.cxx. ◆ RunDataSet(). Int_t TProofBench::RunDataSet ; (; const char * ; dset = ""BenchDataSet"", . Int_t ; start = 1, . Int_t ; stop = -1, . Int_t ; step = 1 . ). Perform a test using dataset 'dset' Return 0 on success, -1 on error Open the file for the results. ; Definition at line 897 of file TProofBench.cxx. ◆ RunDataSetx(). Int_t TProofBench::RunDataSetx ; (; const char * ; dset = ""BenchDataSet"", . Int_t ; start = 1, . Int_t ; stop = -1 . ). Perform a test using dataset 'dset' scanning over the number of workers per node. ; Return 0 on success, -1 on error Open the file for the results ; Definition at line 932 of file TProofBench.cxx. ◆ SetCPUPar(). vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofBench.html:21259,Perform,Perform,21259,doc/master/classTProofBench.html,https://root.cern,https://root.cern/doc/master/classTProofBench.html,1,['Perform'],['Perform']
Performance,"t (Option_t *option="""") override;  Reset this histogram: contents, errors, etc. ;  ; void SetBinContent (Int_t bin, Double_t content) override;  Set bin content. ;  ; void SetBinContent (Int_t bin, Int_t, Double_t content) override;  ; void SetBinContent (Int_t binx, Int_t biny, Int_t binz, Double_t content) override;  ; virtual void SetShowProjection (const char *option=""xy"", Int_t nbins=1);  When the mouse is moved in a pad containing a 3-d view of this histogram a second canvas shows a projection type given as option. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TH3. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TH1;  ~TH1 () override;  Histogram default destructor. ;  ; virtual Bool_t Add (const TH1 *h, const TH1 *h2, Double_t c1=1, Double_t c2=1);  Replace contents of this histogram by the addition of h1 and h2. ;  ; virtual Bool_t Add (const TH1 *h1, Double_t c1=1);  Performs the operation: this = this + c1*h1 If errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Bool_t Add (TF1 *h1, Double_t c1=1, Option_t *option="""");  Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Double_t &advalue) const;  Same function as above but returning also the test statistic value. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Option_t *option="""") const;  Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ;  ; void Browse (TBrowser *b) override;  Browse the Histogram object. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:10555,Perform,Performs,10555,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,1,['Perform'],['Performs']
Performance,"t (RooAbsData const &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={});  Import a dataset (RooDataSet or RooDataHist) into the workspace. ;  ; bool import (TObject const &object, bool replaceExisting=false);  Import a clone of a generic TObject into workspace generic object container. ;  ; bool import (TObject const &object, const char *aliasName, bool replaceExisting=false);  Import a clone of a generic TObject into workspace generic object container. ;  ; bool importClassCode (const char *pat=""*"", bool doReplace=false);  Import code of all classes in the workspace that have a class name that matches pattern 'pat' and which are not found to be part of the standard ROOT distribution. ;  ; bool importClassCode (TClass *theClass, bool doReplace=false);  ; TClass * IsA () const override;  ; bool loadSnapshot (const char *name);  Load the values and attributes of the parameters in the snapshot saved with the given name. ;  ; bool makeDir ();  Create transient TDirectory representation of this workspace. ;  ; void merge (const RooWorkspace &);  ; TObject * obj (RooStringView name) const;  Return any type of object (RooAbsArg, RooAbsData or generic object) with given name) ;  ; RooAbsPdf * pdf (RooStringView name) const;  Retrieve p.d.f (RooAbsPdf) with given name. A null pointer is returned if not found. ;  ; void Print (Option_t *opts=nullptr) const override;  Print contents of the workspace. ;  ; void RecursiveRemove (TObject *obj) override;  If one of the TObject we have a referenced to is deleted, remove the reference. ;  ; bool removeSet (const char *name);  Remove a named set from the workspace. ;  ; bool renameSet (const char *name, const char *newName);  Rename set to a new name. ;  ; bool saveSnapshot (RooStringView, const char *paramNames);  Save snapshot of values and attrib",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWorkspace.html:7928,load,loadSnapshot,7928,doc/master/classRooWorkspace.html,https://root.cern,https://root.cern/doc/master/classRooWorkspace.html,2,"['Load', 'load']","['Load', 'loadSnapshot']"
Performance,"t * frame(Double_t lo, Double_t hi) const; Create a new RooPlot on the heap with a drawing frame initialized for this; object, but no plot contents. Use x.frame() as the first argument to a; y.plotOn(...) method, for example. The caller is responsible for deleting; the returned object. RooPlot * frame(Int_t nbins) const; Create a new RooPlot on the heap with a drawing frame initialized for this; object, but no plot contents. Use x.frame() as the first argument to a; y.plotOn(...) method, for example. The caller is responsible for deleting; the returned object. The current fit range may not be open ended or empty. RooPlot * frame() const; Create a new RooPlot on the heap with a drawing frame initialized for this; object, but no plot contents. Use x.frame() as the first argument to a; y.plotOn(...) method, for example. The caller is responsible for deleting; the returned object. The current fit range may not be open ended or empty. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy cache of another RooAbsArg to our cache. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Structure printing. void randomize(const char* rangeName = 0); Set a new value sampled from a uniform distribution over the fit range.; Prints a warning and does nothing if the fit range is not finite. void setBin(Int_t ibin, const char* rangeName = 0); Set value to center of bin 'ibin' of binning 'rangeName' (or of; default binning if no range is specified). void setBin(Int_t ibin, const RooAbsBinning& binning); Set value to center of bin 'ibin' of binning 'binning'. void randomize(const RooAbsBinning& binning); Set a new value sampled from a uniform distribution over the fit range.; Prints a warning and does nothing if the fit range is not finite. void setBinFast(Int_t ibin, const RooAbsBinning& binning); Set value to center of bin 'ibin' of binning 'rangeName' (or of; default binning if no range is specified). Bool_t fitRange",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsRealLValue.html:39959,cache,cache,39959,root/html528/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html528/RooAbsRealLValue.html,4,['cache'],['cache']
Performance,"t *) const =0;  ; virtual Bool_t FuncTempInfo_IsValid (FuncTempInfo_t *) const =0;  ; virtual void FuncTempInfo_Name (FuncTempInfo_t *, TString &name) const =0;  ; virtual Long_t FuncTempInfo_Property (FuncTempInfo_t *) const =0;  ; virtual UInt_t FuncTempInfo_TemplateMinReqArgs (FuncTempInfo_t *) const =0;  ; virtual UInt_t FuncTempInfo_TemplateNargs (FuncTempInfo_t *) const =0;  ; virtual void FuncTempInfo_Title (FuncTempInfo_t *, TString &title) const =0;  ; virtual Bool_t FunctionDeclId_IsMethod (DeclId_t) const;  ; virtual Int_t GenerateDictionary (const char *classes, const char *includes=nullptr, const char *options=nullptr)=0;  ; virtual TClass * GenerateTClass (ClassInfo_t *classinfo, Bool_t silent=kFALSE)=0;  ; virtual TClass * GenerateTClass (const char *classname, Bool_t emulation, Bool_t silent=kFALSE)=0;  ; virtual void GenericError (const char *) const;  ; virtual void * GetAutoLoadCallBack () const;  ; virtual TClass * GetClass (const std::type_info &typeinfo, Bool_t load) const =0;  ; virtual const char * GetClassSharedLibs (const char *cls, bool skipCore=true)=0;  ; virtual const char * GetCurrentMacroName () const;  ; virtual DeclId_t GetDataMember (ClassInfo_t *cl, const char *name) const =0;  ; virtual DeclId_t GetDataMemberAtAddr (const void *addr) const =0;  ; virtual DeclId_t GetDataMemberWithValue (const void *ptrvalue) const =0;  ; virtual DeclId_t GetDeclId (CallFunc_t *info) const =0;  ; virtual DeclId_t GetDeclId (ClassInfo_t *info) const =0;  ; virtual DeclId_t GetDeclId (DataMemberInfo_t *info) const =0;  ; virtual DeclId_t GetDeclId (FuncTempInfo_t *info) const =0;  ; virtual DeclId_t GetDeclId (MethodInfo_t *info) const =0;  ; virtual DeclId_t GetDeclId (TypedefInfo_t *info) const =0;  ; virtual DeclId_t GetEnum (TClass *cl, const char *name) const =0;  ; virtual Long_t GetExecByteCode () const;  ; virtual Int_t GetExitCode () const =0;  ; virtual DeclId_t GetFunction (ClassInfo_t *cl, const char *funcname)=0;  ; virtual void GetFunct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTInterpreter.html:14268,load,load,14268,doc/master/classTInterpreter.html,https://root.cern,https://root.cern/doc/master/classTInterpreter.html,1,['load'],['load']
Performance,"t *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// Returns the object before object obj. Obj is found using the; 367/// object's IsEqual() method. Returns 0 if obj is first in list.; 368 ; 369TObject *TList::Before(const TObject *obj) const; 370{; 371 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 372 R__COLLECTION_WRITE_GUARD();; 373 ; 374 TObjLink *t;; 375 ; 376 auto cached = fCache.lock();; 377 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 378 t = cached.get();; 379 ((TList*)this)->fCache = cached->fPrev; //cast const away, fCache should be mutable; 380 } else {; 381 Int_t idx;; 382 t = FindLink(obj, idx);; 383 if (t) ((TList*)this)->fCache = t->fPrev;; 384 }; 385 ; 386 if (t && t->Prev()); 387 return t->Prev()->GetObject();; 388 else; 389 return nullptr;; 390}; 391 ; 392////////////////////////////////////////////////////////////////////////////////; 393/// Remove all objects from the list. Does not delete the objects; 394/// unless the TList is the owner (set via SetOwner()) and option; 395/// ""nodelete"" is not set.; 396/// If option=""nodelete"" then don't delete any heap objects that were; 397/// marked with the kCanDelete bit, otherwise these objects will be; 398/// deleted (this option is used by THashTable::Clear()).; 399 ; 400void TList::Clear(Option_t *option); 401{; 402 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 403 R__COLLECTION_WRITE_GUARD();; 404 ; 405 Bool_t nodel = option ? (!strcmp(option, ""nodelete"") ? kTRUE : kFALSE) : kFALSE;; 406 ; 407 if (!nodel && IsOwner()) {; 408 Delete(option);; 409 return;; 410 }; 411 ; 412 // In some case, for example TParallelCoord, a list (the pad's list of; 413 // primitives) will contain both the conta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:11114,cache,cached,11114,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,1,['cache'],['cached']
Performance,"t *info, Bool_t load = kTRUE, Bool_t silent = kFALSE);; 585 template<typename T>; 586 static TClass *GetClass(Bool_t load = kTRUE, Bool_t silent = kFALSE);; 587 static Bool_t GetClass(DeclId_t id, std::vector<TClass*> &classes);; 588 static DictFuncPtr_t GetDict (const char *cname);; 589 static DictFuncPtr_t GetDict (const std::type_info &info);; 590 ; 591 static Int_t AutoBrowse(TObject *obj, TBrowser *browser);; 592 static ENewType IsCallingNew();; 593 static TClass *Load(TBuffer &b);; 594 void Store(TBuffer &b) const;; 595 ; 596 // Pseudo-method apply to the 'obj'. In particular those are used to; 597 // implement TObject like methods for non-TObject classes.; 598 Int_t Browse(void *obj, TBrowser *b) const;; 599 void DeleteArray(void *ary, Bool_t dtorOnly = kFALSE);; 600 void DeleteArray(ObjectPtr ary, Bool_t dtorOnly = kFALSE);; 601 void Destructor(void *obj, Bool_t dtorOnly = kFALSE);; 602 void Destructor(ObjectPtr obj, Bool_t dtorOnly = kFALSE);; 603 void *DynamicCast(const TClass *base, void *obj, Bool_t up = kTRUE);; 604 const void *DynamicCast(const TClass *base, const void *obj, Bool_t up = kTRUE);; 605 Bool_t IsFolder(void *obj) const;; 606 ; 607 inline void Streamer(void *obj, TBuffer &b, const TClass *onfile_class = nullptr) const; 608 {; 609 // Inline for performance, skipping one function call.; 610#ifdef R__NO_ATOMIC_FUNCTION_POINTER; 611 fStreamerImpl(this,obj,b,onfile_class);; 612#else; 613 auto t = fStreamerImpl.load();; 614 t(this,obj,b,onfile_class);; 615#endif; 616 }; 617 ; 618 ClassDefOverride(TClass,0) //Dictionary containing class information; 619};; 620 ; 621namespace ROOT {; 622namespace Internal {; 623template <typename T>; 624TClass *GetClassHelper(Bool_t, Bool_t, std::true_type); 625{; 626 return T::Class();; 627}; 628 ; 629template <typename T>; 630struct TClassGetClassHelper {; 631 static TClass *GetClass(Bool_t load, Bool_t silent) {; 632 return TClass::GetClass(typeid(T), load, silent);; 633 }; 634};; 635 ; 636template <typename F, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:31780,perform,performance,31780,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['perform'],['performance']
Performance,"t *info, const char *name) const finalDefinition TCling.cxx:8261; TCling::ClassInfo_DeleteArrayvoid ClassInfo_DeleteArray(ClassInfo_t *info, void *arena, bool dtorOnly) const finalDefinition TCling.cxx:8199; TCling::fClassesHeadersMapstd::map< size_t, std::vector< const char * > > fClassesHeadersMapDefinition TCling.h:119; TCling::DataMemberInfo_TypeTrueNameconst char * DataMemberInfo_TypeTrueName(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8690; TCling::ShutDownvirtual void ShutDown() finalDefinition TCling.cxx:1655; TCling::GetInterpreterStateMarkerunsigned long long GetInterpreterStateMarker() const finalDefinition TCling.h:224; TCling::UpdateListOfTypesvoid UpdateListOfTypes() finalNo op: see TClingCallbacks (used to update the list of types)Definition TCling.cxx:3899; TCling::TypedefInfo_PropertyLong_t TypedefInfo_Property(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9498; TCling::RegisterRdictForLoadPCMvoid RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent)Register Rdict data for future loading by LoadPCM;.Definition TCling.cxx:1678; TCling::ProcessLineSynchLongptr_t ProcessLineSynch(const char *line, EErrorCode *error=nullptr) finalLet cling process a command line synchronously, i.e we are waiting it will be finished.Definition TCling.cxx:3569; TCling::GetMangledNameWithPrototypeTString GetMangledNameWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn the cling mangled name for a method of a class with a certain prototype, i....Definition TCling.cxx:4989; TCling::UpdateAllCanvasesstatic void UpdateAllCanvases()Update all canvases at end the terminal input command.Definition TCling.cxx:6754; TCling::LoadLibraryMapInt_t LoadLibraryMap(const char *rootmapfile=nullptr) finalLoad map between class and library.Definition TCling.cxx:5741; TCling::BaseClassInfo_TagnumLongptr_t BaseClassInfo_Tagnu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:90767,load,loading,90767,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,2,"['Load', 'load']","['LoadPCM', 'loading']"
Performance,"t *minfo) const final;  ; std::string MethodInfo_TypeNormalizedName (MethodInfo_t *minfo) const final;  ; void PrintIntro () final;  No-op; see TRint instead. ;  ; Longptr_t ProcessLine (const char *line, EErrorCode *error=nullptr) final;  ; Longptr_t ProcessLineAsynch (const char *line, EErrorCode *error=nullptr);  Let cling process a command line asynch. ;  ; Longptr_t ProcessLineSynch (const char *line, EErrorCode *error=nullptr) final;  Let cling process a command line synchronously, i.e we are waiting it will be finished. ;  ; void RecursiveRemove (TObject *obj) final;  Delete object from cling symbol table so it can not be used anymore. ;  ; void RefreshClassInfo (TClass *cl, const clang::NamedDecl *def, bool alias);  Internal function. Actually do the update of the ClassInfo when seeing. ;  ; void RegisterModule (const char *modulename, const char **headers, const char **includePaths, const char *payloadCode, const char *fwdDeclsCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, Bool_t lateRegistration=false, Bool_t hasCxxModule=false) final;  Inject the module named ""modulename"" into cling; load all headers. ;  ; bool RegisterPrebuiltModulePath (const std::string &FullPath, const std::string &ModuleMapName=""module.modulemap"") const final;  ; void RegisterTClassUpdate (TClass *oldcl, DictFuncPtr_t dict) final;  Register classes that already existed prior to their dictionary loading and that already had a ClassInfo (and thus would not be refresh via UpdateClassInfo. ;  ; void RegisterTemporary (const cling::Value &value);  Register value as a temporary, extending its lifetime to that of the interpreter. ;  ; void RegisterTemporary (const TInterpreterValue &value);  ; Int_t ReloadAllSharedLibraryMaps () final;  Reload the library map entries coming from all the loaded shared libraries, after first unloading the current ones. ;  ; void ReportDiagnosticsToErrorHandler (bool enable=true) final;  Report ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:28105,load,load,28105,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['load'],['load']
Performance,"t *obj);  Emit Clicked signal. ;  ; virtual void Clicked (TObject *obj, UInt_t button, UInt_t state);  Emit Clicked signal with button id and modifier state. ;  ; void CloseComposite () override;  ; TGLColorSet & ColorSet ();  ; virtual void CreateGLWidget ();  ; TGLCamera & CurrentCamera () const;  ; virtual void DestroyGLWidget ();  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Calculate and return pixel distance to nearest viewer object from window location px, py This is provided for use when embedding GL viewer into pad. ;  ; void DoDraw (Bool_t swap_buffers=kTRUE);  Draw out the viewer. ;  ; void DoDrawMono (Bool_t swap_buffers);  Draw out in monoscopic mode. ;  ; void DoDrawStereo (Bool_t swap_buffers);  Draw out in stereoscopic mode. ;  ; Bool_t DoOverlaySelect (Int_t x, Int_t y);  Perform GL selection, picking overlay objects only. ;  ; Bool_t DoSecondarySelect (Int_t x, Int_t y);  Secondary selection. ;  ; Bool_t DoSelect (Int_t x, Int_t y);  Perform GL selection, picking objects overlapping WINDOW area described by 'rect'. ;  ; virtual void DoubleClicked ();  ; void DrawDebugInfo ();  If in debug mode draw camera aids and overall bounding box. ;  ; void DrawGuides ();  Draw reference marker and coordinate axes. ;  ; void EndScene () override;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Process event of type 'event' - one of EEventType types, occurring at window location px, py This is provided for use when embedding GL viewer into pad. ;  ; TGLAutoRotator * GetAutoRotator ();  Get the auto-rotator for this viewer. ;  ; TGLCameraOverlay * GetCameraOverlay () const;  ; Bool_t GetClipAutoUpdate () const;  ; TGLClipSet * GetClipSet () const;  ; TGLOverlayElement * GetCurrentOvlElm () const;  ; Int_t GetDev () const;  ; EDragAction GetDragAction () const;  ; Bool_t GetDrawCameraCenter ();  ; TGEventHandler * GetEventHandler () const;  ; Float_t GetFader () const;  ; TGedEditor * GetGedEditor () const;  ; TGLWidget * GetGLWidg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLViewer.html:4618,Perform,Perform,4618,doc/master/classTGLViewer.html,https://root.cern,https://root.cern/doc/master/classTGLViewer.html,1,['Perform'],['Perform']
Performance,"t *option="""") const;  Return total number of bytes in the branch (excluding current buffer) if option =""*"" includes all sub-branches of this branch too. ;  ; TBuffer * GetTransientBuffer (Int_t size);  Returns the transient buffer currently used by this TBranch for reading/writing baskets. ;  ; TTree * GetTree () const;  ; Int_t GetWriteBasket () const;  ; Long64_t GetZipBytes (Option_t *option="""") const;  Return total number of zip bytes in the branch if option =""*"" includes all sub-branches of this branch too. ;  ; bool IsAutoDelete () const;  Return true if an existing object in a TBranchObject must be deleted. ;  ; bool IsFolder () const override;  Return true if more than one leaf or browsables, false otherwise. ;  ; virtual void KeepCircular (Long64_t maxEntries);  keep a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetAddress (void *add);  Set address of this branch. ;  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBasketSize (Int_t buffsize);  Set the basket size The function makes sure that the basket size is greater than fEntryOffsetlen. ;  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchRef.html:8183,cache,cached,8183,doc/master/classTBranchRef.html,https://root.cern,https://root.cern/doc/master/classTBranchRef.html,2,['cache'],"['cache', 'cached']"
Performance,"t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Execute the specified drawing action on a data set (TDSet). ;  ; Bool_t ExistsDataSet (const char *uri) override;  Returns kTRUE if 'dataset' described by 'uri' exists, kFALSE otherwise. ;  ; TFileCollection * GetDataSet (const char *uri, const char *=0) override;  Get a list of TFileInfo objects describing the files of the specified dataset. ;  ; TMap * GetDataSets (const char *uri="""", const char *=0) override;  lists all datasets that match given uri ;  ; TList * GetListOfQueries (Option_t *opt="""") override;  Get the list of queries. ;  ; TFileCollection * GetStagingStatusDataSet (const char *dataset) override;  Obtains a TFileCollection showing the staging status of the specified dataset. ;  ; TTree * GetTreeHeader (TDSet *tdset) override;  Creates a tree header (a tree with nonexisting files) object for the DataSet. ;  ; TClass * IsA () const override;  ; Int_t Load (const char *macro, Bool_t notOnClient=kFALSE, Bool_t uniqueOnly=kTRUE, TList *wrks=0) override;  Copy the specified macro in the cache directory. ;  ; void Print (Option_t *option="""") const override;  Print status of PROOF-Lite cluster. ;  ; Long64_t Process (const char *dsname, const char *sel, Option_t *o="""", Long64_t nent=-1, Long64_t fst=0, TObject *enl=0) override;  Process a dataset which is stored on the master with name 'dsetname'. ;  ; Long64_t Process (const char *dsname, TSelector *sel, Option_t *o="""", Long64_t nent=-1, Long64_t fst=0, TObject *enl=0) override;  Process with name of dataset and TSelector object. ;  ; Long64_t Process (const char *sel, Long64_t nent, Option_t *o="""") override;  Generic (non-data based) selector processing: the Process() method of the specified selector (.C) or TSelector object is called 'n' times. ;  ; Long64_t Process (TDSet *dset, const char *sel, Option_t *o="""", Long64_t nent=-1, Long64_t fst=0) override;  Process a data set (TDSet) using the specified selector (.C) file. ;  ; Long64_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:2333,Load,Load,2333,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,2,"['Load', 'cache']","['Load', 'cache']"
Performance,"t *p);  Return the next markup type [TGHtmlElement::NextMarkupType]. ;  ; SHtmlStyle_t PopStyleStack (int tag);  Pop a rendering style off of the stack. ;  ; void PushStyleStack (int tag, SHtmlStyle_t style);  Push a new rendering style onto the stack. ;  ; void Redraw ();  This routine is invoked in order to redraw all or part of the HTML widget. ;  ; void RedrawArea (int left, int top, int right, int bottom);  If any part of the screen needs to be redrawn, then call this routine with the values of a box (in window coordinates) that needs to be redrawn. ;  ; void RedrawBlock (TGHtmlBlock *p);  Redraw the TGHtmlBlock given. ;  ; void RedrawEverything ();  Call this routine to force the entire widget to be redrawn. ;  ; void RedrawText (int y);  Call this routine to cause all of the rendered HTML at the virtual canvas coordinate of Y and beyond to be redrawn. ;  ; void ResetLayoutContext ();  Reset the main layout context in the main widget. ;  ; void ScheduleRedraw ();  Make sure that a call to the Redraw() routine has been queued. ;  ; int SelectionSet (const char *startIx, const char *endIx);  Set selection. ;  ; int SetInsert (const char *insIx);  Set the position of the insertion cursor. ;  ; void SizeAndLink (TGFrame *frame, TGHtmlInput *pElem);  'frame' is the child widget that is used to implement an input element. ;  ; void Sizer ();  Compute the size of all elements in the widget. ;  ; void StringHW (const char *str, int *h, int *w);  Return the height and width of string. ;  ; void TableBgndImage (TGHtmlElement *p);  Set background picture of a html table. ;  ; int TextInsertCmd (int argc, char **argv);  Insert text into text token, or break token into two text tokens. ;  ; TGHtmlElement * TokenByIndex (int N, int flag);  Return a pointer to the Nth TGHtmlElement in the list. ;  ; int Tokenize ();  Process as much of the input HTML as possible. ;  ; void TokenizerAppend (const char *text);  Append text to the tokenizer engine. ;  ; int TokenNumber (TGHtmlEl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:36047,queue,queued,36047,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['queue'],['queued']
Performance,"t *s, Option_t *option, Int_t netopt);  Create a NetFile object using an existing connection (socket s). ;  ; void Init (Bool_t create) override;  Initialize a TNetFile object. ;  ; TNetFile & operator= (const TNetFile &);  ; void Print (Option_t *option) const override;  Print some info about the net file. ;  ; void PrintError (const char *where, Int_t err);  Print error string depending on error code. ;  ; Int_t Recv (Int_t &status, EMessageTypes &kind);  Return status from rootd server and message kind. ;  ; Int_t SysClose (Int_t fd) override;  Close currently open file. ;  ; Int_t SysOpen (const char *pathname, Int_t flags, UInt_t mode) override;  Open a remote file. Requires fOption to be set correctly. ;  ; Int_t SysStat (Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime) override;  Return file stat information. ;  ;  Protected Member Functions inherited from TFile; virtual Long64_t DirCreateEntry (TDirectory *);  ; virtual Int_t DirReadKeys (TDirectory *);  ; virtual void DirWriteHeader (TDirectory *);  ; virtual void DirWriteKeys (TDirectory *);  ; Bool_t FlushWriteCache ();  Flush the write cache if active. ;  ; virtual EAsyncOpenStatus GetAsyncOpenStatus ();  ; virtual InfoListRet GetStreamerInfoListImpl (bool lookupSICache);  See documentation of GetStreamerInfoList for more details. ;  ; Int_t MakeProjectParMake (const char *packname, const char *filename);  Create makefile at 'filemake' for PAR package 'pack'. ;  ; Int_t MakeProjectParProofInf (const char *packname, const char *proofinfdir);  Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'. ;  ; Int_t ReadBufferViaCache (char *buf, Int_t len);  Read buffer via cache. ;  ; virtual Int_t SysRead (Int_t fd, void *buf, Int_t len);  Interface to system read. All arguments like in POSIX read(). ;  ; virtual Long64_t SysSeek (Int_t fd, Long64_t offset, Int_t whence);  Interface to system lseek. ;  ; virtual Int_t SysSync (Int_t fd);  Interface to system fsync. All argumen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:31944,cache,cache,31944,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,1,['cache'],['cache']
Performance,"t *slave, TList *out) override;  Store feedback results from the specified slave. ;  ; void StoreOutput (TList *out) override;  Store received output list. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayer;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override;  Get output list. ;  ; TProofProgressStatus * GetProgressStatus () const override;  ; TQueryResult * GetQueryResult (const char *ref) override;  Get query result instances referenced 'ref' from the list of results. ;  ; void HandleGetTreeHeader (TMessage *mess) override;  Hand",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerSuperMaster.html:4830,cache,cache,4830,doc/master/classTProofPlayerSuperMaster.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerSuperMaster.html,1,['cache'],['cache']
Performance,"t *tinfo) const finalDefinition TCling.cxx:9506; TCling::CallFunc_ExecWithArgsAndReturnvoid CallFunc_ExecWithArgsAndReturn(CallFunc_t *func, void *address, const void *args[]=nullptr, int nargs=0, void *ret=nullptr) const finalDefinition TCling.cxx:7874; TCling::GetInterpreterTypeNamevoid GetInterpreterTypeName(const char *name, std::string &output, Bool_t full=kFALSE) finalThe 'name' is known to the interpreter, this function returns the internal version of this name (usua...Definition TCling.cxx:5200; TCling::fGlobalsListSerialInt_t fGlobalsListSerialDefinition TCling.h:114; TCling::IsAutoParsingSuspendedBool_t IsAutoParsingSuspended() const finalDefinition TCling.h:353; TCling::fSharedLibsTString fSharedLibsDefinition TCling.h:113; TCling::fPendingRdictsstd::map< std::string, llvm::StringRef > fPendingRdictsDefinition TCling.h:634; TCling::UpdateClassInfoWorkstatic void UpdateClassInfoWork(const char *name)Definition TCling.cxx:6745; TCling::LoadInt_t Load(const char *filenam, Bool_t system=kFALSE) finalLoad a library file in cling's memory.Definition TCling.cxx:3515; TCling::TypedefInfo_Nextint TypedefInfo_Next(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9490; TCling::GetInterfaceMethodvoid * GetInterfaceMethod(TClass *cl, const char *method, const char *params, Bool_t objectIsConst=kFALSE) finalReturn pointer to cling interface function for a method of a class with parameters params (params is ...Definition TCling.cxx:5007; TCling::TypeInfo_Initvoid TypeInfo_Init(TypeInfo_t *tinfo, const char *funcname) const finalDefinition TCling.cxx:9371; TCling::SetSuspendAutoParsingBool_t SetSuspendAutoParsing(Bool_t value) finalSuspend the Autoparsing of headers.Definition TCling.cxx:7596; TCling::DataMemberInfo_TypeSizeint DataMemberInfo_TypeSize(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8674; TCling::fgSetOfSpecialsstatic void * fgSetOfSpecialsDefinition TCling.h:105; TCling::ClassInfo_Titleconst char * ClassInfo_Title(ClassInfo_t *info) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:63121,Load,Load,63121,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['Load'],['Load']
Performance,"t * ; event). overridevirtual . Keyboard event handler. ; Reimplemented from TGMainFrame.; Definition at line 672 of file TGTextEditor.cxx. ◆ HandleTimer(). Bool_t TGTextEditor::HandleTimer ; (; TTimer * ; t). overridevirtual . Handle timer event. ; Reimplemented from TObject.; Definition at line 863 of file TGTextEditor.cxx. ◆ InterruptMacro(). void TGTextEditor::InterruptMacro ; (; ). Interrupt execution of a macro. ; Definition at line 834 of file TGTextEditor.cxx. ◆ IsA(). TClass * TGTextEditor::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGMainFrame.; Definition at line 93 of file TGTextEditor.h. ◆ IsSaved(). Int_t TGTextEditor::IsSaved ; (; ). Check if file has to be saved in case of modifications. ; Definition at line 596 of file TGTextEditor.cxx. ◆ LoadBuffer(). Bool_t TGTextEditor::LoadBuffer ; (; const char * ; buf). inline . Definition at line 67 of file TGTextEditor.h. ◆ LoadFile(). void TGTextEditor::LoadFile ; (; const char * ; fname = nullptr). Load a file into the editor. If fname is 0, a TGFileDialog will popup. ; Definition at line 497 of file TGTextEditor.cxx. ◆ PrintText(). void TGTextEditor::PrintText ; (; ). Open the print dialog and send current buffer to printer. ; Definition at line 618 of file TGTextEditor.cxx. ◆ ProcessMessage(). Bool_t TGTextEditor::ProcessMessage ; (; Longptr_t ; msg, . Longptr_t ; parm1, . Longptr_t ; parm2 . ). overridevirtual . Handle menu and other command generated by the user. ; Reimplemented from TGCompositeFrame.; Definition at line 910 of file TGTextEditor.cxx. ◆ SaveFile(). void TGTextEditor::SaveFile ; (; const char * ; fname). Save the edited text in the file ""fname"". ; Definition at line 545 of file TGTextEditor.cxx. ◆ SaveFileAs(). Bool_t TGTextEditor::SaveFileAs ; (; ). Save the edited text in a file selected with TGFileDialog. ; Shouldn't we create a backup file? ; Definition at line 573 of file TGTextEditor.cxx. ◆ Search(). void TGTextEditor::Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEditor.html:46891,Load,LoadFile,46891,doc/master/classTGTextEditor.html,https://root.cern,https://root.cern/doc/master/classTGTextEditor.html,1,['Load'],['LoadFile']
Performance,"t * ; wrks = 0 . ). protected . Start up PROOF workers. ; Definition at line 489 of file TProofLite.cxx. ◆ ShowCache(). void TProofLite::ShowCache ; (; Bool_t ; all = kFALSE). overridevirtual . List contents of file cache. ; If all is true show all caches also on slaves. If everything is ok all caches are to be the same. ; Reimplemented from TProof.; Definition at line 1508 of file TProofLite.cxx. ◆ ShowData(). void TProofLite::ShowData ; (; ). overridevirtual . List contents of the data directory in the sandbox. ; This is the place where files produced by the client queries are kept ; Reimplemented from TProof.; Definition at line 2479 of file TProofLite.cxx. ◆ ShowDataDir(). void TProofLite::ShowDataDir ; (; const char * ; dirname). private . List contents of the data directory 'dirname'. ; Definition at line 2495 of file TProofLite.cxx. ◆ ShowDataSetCache(). void TProofLite::ShowDataSetCache ; (; const char * ; dataset = 0). overridevirtual . Display the content of the dataset cache, if any (matching 'dataset', if defined). ; Reimplemented from TProof.; Definition at line 2292 of file TProofLite.cxx. ◆ ShowDataSets(). void TProofLite::ShowDataSets ; (; const char * ; uri = """", . const char * ; opt = 0 . ). overridevirtual . Shows datasets in locations that match the uri By default shows the user's datasets and global ones. ; Reimplemented from TProof.; Definition at line 2070 of file TProofLite.cxx. ◆ Streamer(). void TProofLite::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TProof. ◆ StreamerNVirtual(). void TProofLite::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 170 of file TProofLite.h. ◆ VerifyDataSet(). Int_t TProofLite::VerifyDataSet ; (; const char * ; uri, . const char * ; optStr = 0 . ). overridevirtual . Verify if all files in the specified dataset are available. ; Print a list and return the number of missing files. ; Reimplemented from TProof.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:67121,cache,cache,67121,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['cache'],['cache']
Performance,"t * GetTestingEvent (Long64_t ievt) const;  ; Double_t GetTestTime () const;  ; const TString & GetTestvarName () const;  ; virtual Double_t GetTrainingEfficiency (const TString &);  ; const Event * GetTrainingEvent (Long64_t ievt) const;  ; virtual const std::vector< Float_t > & GetTrainingHistory (const char *);  ; UInt_t GetTrainingROOTVersionCode () const;  ; TString GetTrainingROOTVersionString () const;  calculates the ROOT version string from the training version code on the fly ;  ; UInt_t GetTrainingTMVAVersionCode () const;  ; TString GetTrainingTMVAVersionString () const;  calculates the TMVA version string from the training version code on the fly ;  ; Double_t GetTrainTime () const;  ; TransformationHandler & GetTransformationHandler (Bool_t takeReroutedIfAvailable=true);  ; const TransformationHandler & GetTransformationHandler (Bool_t takeReroutedIfAvailable=true) const;  ; TString GetWeightFileName () const;  retrieve weight file name ;  ; Double_t GetXmax (Int_t ivar) const;  ; Double_t GetXmin (Int_t ivar) const;  ; Bool_t HasMVAPdfs () const;  ; void InitIPythonInteractive ();  ; Bool_t IsModelPersistence () const;  ; virtual Bool_t IsSignalLike ();  uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation) for a quick determination if an event would be selected as signal or background ;  ; virtual Bool_t IsSignalLike (Double_t mvaVal);  uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation) for a quick determination if an event with this mva output value would be selected as signal or background ;  ; Bool_t IsSilentFile () const;  ; TDirectory * MethodBaseDir () const;  returns the ROOT directory where all instances of the corresponding MVA method are stored ;  ; virtual std::map< TString, Double_t > OptimizeTuningParameters (TString fomType=""ROCIntegral"", TString fitType=""FitGA"");  call the Optimizer with the set of parameters and ranges that are meant to be tuned.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodC50.html:8794,Optimiz,OptimizeTuningParameters,8794,doc/master/classTMVA_1_1MethodC50.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodC50.html,12,"['Optimiz', 'tune']","['OptimizeTuningParameters', 'Optimizer', 'tuned']"
Performance,"t * moment (RooRealVar &obs, Int_t order, bool central, bool takeRoot);  Return function representing moment of function of given order. ;  ; virtual double offset () const;  ; bool operator== (const RooAbsArg &other) const override;  Equality operator when comparing to another RooAbsArg. ;  ; bool operator== (double value) const;  Equality operator comparing to a double. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the special",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddPdf.html:30236,cache,cache,30236,doc/master/classRooAddPdf.html,https://root.cern,https://root.cern/doc/master/classRooAddPdf.html,7,['cache'],['cache']
Performance,"t 90047b0cba6fd295f5c5722749a0d043fbc11ea5.; Do not insert macro definition of ROOTCLING into the pch. TTree. Properly handle the last element of arrays in the TTreeFormula functions MinIf and MaxIf ROOT-7258; Fix detection of errors that appears in nested TTreeFormula ROOT-8218; Avoid autoparse looking for default constructor in TTreeCloner::CopyStreamerInfos(). Bugs fixed in this release. [ROOT-6753] - PROOF-Lite doesn’t find TSelector type from an already loaded library; [ROOT-7258] - MinIf and MaxIf TTreeFormula functions ignore last element; [ROOT-8038] - [patch] “for e in getSTLLikeCollection()” crashes pyroot; [ROOT-8166] - Update INSTALL to reflect CMake; [ROOT-8184] - Error building XrdSysPthread with GCC 6.1; [ROOT-8197] - rootcp not preserving kSingleKey; [ROOT-8205] - TSystem::ExpandPathName is not thread safe; [ROOT-8207] - tmva/tmva/CMakeLists.txt unnecessarily includes TreeViewer; [ROOT-8217] - TMinuit::TMinuit data race; [ROOT-8218] - Detection of TTreeFormula without breaking formula; [ROOT-8221] - Enum value kKey_Shift not accessible from python with ROOT 6; [ROOT-8226] - CMake 3.5.2: circular dependency libMathMore; [ROOT-8231] - _GLIBCXX_USE_CXX11_ABI=0 should be propagated into root-config –cflags. Release 6.06/08; Released on September 1, 2016; Core. Prevent race condition in the creation of the list of base classes (but avoiding to publish the list too early). Hist. Resolved issues with inconsistent handling of the ‘gaus’ function in TFormula [[ROT-8105]]. Bugs fixed in this release. [ROOT-8105] - TFormula does not always handle ‘gaus’ correctly.; [ROOT-8239] - “python: free(): invalid next size (fast)” in PyROOT 6.06.02 and patches; [ROOT-8270] - C++14; [ROOT-8293] - CMake does not find Castor libraries; [ROOT-8328] - patches used by art; [ROOT-8307] - Crash when leaving ROOT from GUI menu item.; [ROOT-8332] - support linked libraries paths with spaces in aclic. HEAD of the v6-06-00-patches branch; Changes will be part of the future 6.06/10. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:32719,race condition,race condition,32719,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['race condition'],['race condition']
Performance,"t ; (; Option_t * ; option = """"); const. inlinefinalvirtual . Print all objects in the file. ; Reimplemented from TFile.; Definition at line 82 of file TXMLFile.h. ◆ ProduceFileNames(). void TXMLFile::ProduceFileNames ; (; const char * ; filename, . TString & ; fname, . TString & ; dtdname . ). staticprotected . function produces pair of xml and dtd file names ; Definition at line 424 of file TXMLFile.cxx. ◆ ReadBuffer() [1/2]. Bool_t TXMLFile::ReadBuffer ; (; char * ; buf, . Int_t ; len . ). inlinefinalvirtual . Read a buffer from the file. ; This is the basic low level read operation. Returns kTRUE in case of failure. ; Reimplemented from TFile.; Definition at line 83 of file TXMLFile.h. ◆ ReadBuffer() [2/2]. Bool_t TXMLFile::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). inlinefinalvirtual . Read a buffer from the file at the offset 'pos' in the file. ; Returns kTRUE in case of failure. Compared to ReadBuffer(char*, Int_t), this routine does not change the cursor on the physical file representation (fD) if the data is in this TFile's cache. ; Reimplemented from TFile.; Definition at line 84 of file TXMLFile.h. ◆ ReadFree(). void TXMLFile::ReadFree ; (; ). inlinefinalvirtual . Read the FREE linked list. ; Every file has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented from TFile.; Definition at line 85 of file TXMLFile.h. ◆ ReadFromFile(). Bool_t TXMLFile::ReadFromFile ; (; ). protected . read document from file Now full content of document reads into the memory Then document decomposed to separate keys and streamer info structures All irrelevant data will be cleaned ; Definition at line 559 of file TXMLFile.cxx. ◆ ReadKeysList(). Int_t TXMLFile::ReadKeysList ; (; TDirectory * ; dir, . XMLNodePointer_t ; topnode . ). protected . Read list of keys for directory. ; Definition at line 630 of file TXMLFile.cxx. ◆ ReadStreamerElement(). void TXMLFile::ReadStre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:65314,cache,cache,65314,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['cache'],['cache']
Performance,"t = (dynamic_cast<MethodCategory *>(im)); // DSMTEST; 433 if (!methCat) { // DSMTEST; 434 Log() << kFATAL << ""Method with type kCategory cannot be casted to MethodCategory. /Factory""; 435 << Endl; // DSMTEST; 436 return nullptr;; 437 }; 438 if (fModelPersistence); 439 methCat->SetWeightFileDir(fileDir);; 440 methCat->SetModelPersistence(fModelPersistence);; 441 methCat->fDataSetManager = loader->GetDataSetInfo().GetDataSetManager(); // DSMTEST; 442 methCat->SetFile(fgTargetFile);; 443 methCat->SetSilentFile(IsSilentFile());; 444 } // DSMTEST; 445 ; 446 if (!method->HasAnalysisType(fAnalysisType, loader->GetDataSetInfo().GetNClasses(),; 447 loader->GetDataSetInfo().GetNTargets())) {; 448 Log() << kWARNING << ""Method "" << method->GetMethodTypeName() << "" is not capable of handling "";; 449 if (fAnalysisType == Types::kRegression) {; 450 Log() << ""regression with "" << loader->GetDataSetInfo().GetNTargets() << "" targets."" << Endl;; 451 } else if (fAnalysisType == Types::kMulticlass) {; 452 Log() << ""multiclass classification with "" << loader->GetDataSetInfo().GetNClasses() << "" classes."" << Endl;; 453 } else {; 454 Log() << ""classification with "" << loader->GetDataSetInfo().GetNClasses() << "" classes."" << Endl;; 455 }; 456 return 0;; 457 }; 458 ; 459 if (fModelPersistence); 460 method->SetWeightFileDir(fileDir);; 461 method->SetModelPersistence(fModelPersistence);; 462 method->SetAnalysisType(fAnalysisType);; 463 method->SetupMethod();; 464 method->ParseOptions();; 465 method->ProcessSetup();; 466 method->SetFile(fgTargetFile);; 467 method->SetSilentFile(IsSilentFile());; 468 ; 469 // check-for-unused-options is performed; may be overridden by derived classes; 470 method->CheckSetup();; 471 ; 472 if (fMethodsMap.find(datasetname) == fMethodsMap.end()) {; 473 MVector *mvector = new MVector;; 474 fMethodsMap[datasetname] = mvector;; 475 }; 476 fMethodsMap[datasetname]->push_back(method);; 477 return method;; 478}; 479 ; 480//////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:18736,load,loader,18736,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"t = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); Int_tCopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd, Int_t nwk = 1); Int_tCreateSymLinks(TList* files); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); TProofQueryResult*MakeQueryResult(Long64_t nent, const char* opt, Long64_t fst, TDSet* dset, const char* selec); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQuery",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofLite.html:21088,cache,cachedir,21088,root/html602/TProofLite.html,https://root.cern,https://root.cern/root/html602/TProofLite.html,1,['cache'],['cachedir']
Performance,"t = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; static voidRooAbsReal::printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; virtual voidRooAbsReal::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsArg::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooDerivative(); RooDerivative(const RooDerivative& other, const char* name = 0); RooDerivative(const char* name, const char* title, RooAbsReal& func, RooRealVar& x, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDerivative.html:22863,cache,cache,22863,root/html602/RooDerivative.html,https://root.cern,https://root.cern/root/html602/RooDerivative.html,2,['cache'],['cache']
Performance,"t = std::shared_ptr< std::atomic< TDirectory * > >;  Pointer to a list of TContext object pointing to this TDirectory. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TDirectory; static Bool_t Cd1 (const char *path);  Change current directory to ""path"". ;  ; static SharedGDirectory_t & GetSharedLocalCurrentDirectory ();  Return the (address of) a shared pointer to the struct holding the actual thread local gDirectory pointer and the atomic_flag for its lock. ;  ;  Static Protected Attributes inherited from TFile; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:41994,cache,cache,41994,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,2,['cache'],"['cache', 'cached']"
Performance,"t == 0 && gLibraryVersion[gLibraryVersionIdx]) {; 1949 int v = TROOT::ConvertVersionCode2Int(gLibraryVersion[gLibraryVersionIdx]);; 1950 Error(""Load"", ""version mismatch, %s = %d, ROOT = %d"",; 1951 path, v, gROOT->GetVersionInt());; 1952 ret = -2;; 1953 gLibraryVersion[gLibraryVersionIdx] = 0;; 1954 }; 1955 gLibraryVersionIdx--;; 1956 delete [] path;; 1957 }; 1958 ; 1959 if (!entry || !entry[0] || ret < 0) return ret;; 1960 ; 1961 Func_t f = DynFindSymbol(module, entry);; 1962 if (f) return 0;; 1963 return -1;; 1964}; 1965 ; 1966///////////////////////////////////////////////////////////////////////////////; 1967/// Load all libraries known to ROOT via the rootmap system.; 1968/// Returns the number of top level libraries successfully loaded.; 1969 ; 1970UInt_t TSystem::LoadAllLibraries(); 1971{; 1972 UInt_t nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just load the first library - TSystem will do the rest.; 2002 auto res = gSystem->Load(lib);; 2003 if (res >=0) {; 2004 if (res == 0) ++nlibs;; 2005 loadedlibs.insert(lib.Data());; 2006 } else {; 2007 failedlibs.insert(lib.Data());; 2008 }; 2009 }; 2010 }; 2011 }; 2012 return nlibs;; 2013",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:63717,Load,LoadAllLibraries,63717,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,2,"['Load', 'load']","['LoadAllLibraries', 'loadedlibs']"
Performance,"t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; std::vector< std::vector< Matrix_t > > fBiasUpdates;  The accumulation of the past Biases for performing updates. ;  ; Scalar_t fEpsilon;  The Smoothing term used to avoid division by zero. ;  ; Scalar_t fMomentum;  The momentum used for training. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasGradients;  The sum of the square of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredWeightGradients;  The sum of the square of the past weight gradients associated with the deep net. ;  ; Scalar_t fRho;  The Rho constant used by the optimizer. ;  ; std::vector< std::vector< Matrix_t > > fWeightUpdates;  The accumulation of the past Weights for performing updates. ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor1;  working tensor used to keep a temporary copy of bias or bias gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor2;  working tensor used to keep a temporary copy of bias or bias gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkWeightTensor1;  working tensor used to keep a temporary copy of weights or weight gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkWeightTensor2;  working tensor used to keep a temporary copy of weights or weight gradients ;  ;  Protected Attributes inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; DeepNet_t & fDeepNet;  The reference to the deep net. ;  ; size_t fGlobalStep;  The current global step count during training. ;  ; Scalar_t fLearningRate;  The learning rate used for training. ;  . #include <TMVA/DNN/RMSProp.h>. Inheritance diagram for TMVA::DNN::TRMSProp< Architectu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html:3645,perform,performing,3645,doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,1,['perform'],['performing']
Performance,"t > & operator= (const TMatrixTLazy< Element > &source);  Assignment operator. ;  ; TMatrixT< Element > & operator= (const TMatrixTSparse< Element > &source);  Assignment operator. ;  ; TMatrixT< Element > & operator= (const TMatrixTSym< Element > &source);  Assignment operator. ;  ; TMatrixT< Element > & operator= (Element val);  Assign val to every element of the matrix. ;  ; TMatrixTRow< Element > operator[] (Int_t rown);  ; const TMatrixTRow_const< Element > operator[] (Int_t rown) const;  ; void Plus (const TMatrixT< Element > &a, const TMatrixT< Element > &b);  General matrix summation. Replace this matrix with C such that C = A + B. ;  ; void Plus (const TMatrixT< Element > &a, const TMatrixTSym< Element > &b);  General matrix summation. Replace this matrix with C such that C = A + B. ;  ; void Plus (const TMatrixTSym< Element > &a, const TMatrixT< Element > &b);  ; TMatrixT< Element > & Rank1Update (const TVectorT< Element > &v, Element alpha=1.0);  Perform a rank 1 operation on matrix A: A += alpha * v * v^T. ;  ; TMatrixT< Element > & Rank1Update (const TVectorT< Element > &v1, const TVectorT< Element > &v2, Element alpha=1.0);  Perform a rank 1 operation on matrix A: A += alpha * v1 * v2^T. ;  ; TMatrixTBase< Element > & ResizeTo (const TMatrixT< Element > &m);  ; TMatrixTBase< Element > & ResizeTo (Int_t nrows, Int_t ncols, Int_t=-1) override;  Set size of the matrix to nrows x ncols New dynamic elements are created, the overlapping part of the old ones are copied to the new structures, then the old elements are deleted. ;  ; TMatrixTBase< Element > & ResizeTo (Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t=-1) override;  Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] New dynamic elements are created, the overlapping part of the old ones are copied to the new structures, then the old elements are deleted. ;  ; TMatrixTBase< Element > & SetColIndexArray (Int_t *) override;  ; void SetElement (Int_t rown, Int_t coln, Ele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixT.html:10227,Perform,Perform,10227,doc/master/classTMatrixT.html,https://root.cern,https://root.cern/doc/master/classTMatrixT.html,1,['Perform'],['Perform']
Performance,"t >::SetBatchSize ; (; Scalar_t ; rate). inline . Definition at line 168 of file Minimizers.h. ◆ SetConvergenceSteps(). template<typename Architecture_t > . void TMVA::DNN::TGradientDescent< Architecture_t >::SetConvergenceSteps ; (; size_t ; steps). inline . Definition at line 165 of file Minimizers.h. ◆ SetLearningRate(). template<typename Architecture_t > . void TMVA::DNN::TGradientDescent< Architecture_t >::SetLearningRate ; (; Scalar_t ; rate). inline . Definition at line 167 of file Minimizers.h. ◆ SetTestInterval(). template<typename Architecture_t > . void TMVA::DNN::TGradientDescent< Architecture_t >::SetTestInterval ; (; size_t ; interval). inline . Definition at line 166 of file Minimizers.h. ◆ Step() [1/2]. template<typename Architecture_t > . template<typename Net_t > . void TMVA::DNN::TGradientDescent< Architecture_t >::Step ; (; Net_t & ; master, . std::vector< Net_t > & ; nets, . std::vector< TBatch< Architecture_t > > & ; batches . ). inline . Perform multiple optimization steps simultaneously. ; Performs the backprop algorithm on the input batches given in batches on the neural networks given in nets. The forward and backward propagation steps are executed in an interleaving manner in order to exploit potential batch-level parallelism for asynchronous device calls. ; Definition at line 374 of file Minimizers.h. ◆ Step() [2/2]. template<typename Architecture_t > . template<typename Net_t > . void TMVA::DNN::TGradientDescent< Architecture_t >::Step ; (; Net_t & ; net, . Matrix_t & ; input, . const Matrix_t & ; output, . const Matrix_t & ; weights . ). inline . Perform a single optimization step on a given batch. ; Propagates the input matrix forward through the net, evaluates the loss and propagates the gradients backward through the net. The computed gradients are scaled by the learning rate \(\alpha\) and subtracted from the weights and bias values of each layer. ; Definition at line 331 of file Minimizers.h. ◆ StepLoss() [1/2]. template<typename A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html:9087,Perform,Perform,9087,doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html,2,"['Perform', 'optimiz']","['Perform', 'optimization']"
Performance,"t >::max()) override;  Load values from dataset 't' into this data collection, optionally selecting events using 'select' RooFormulaVar. ;  ; void loadValues (const TTree *t, const RooFormulaVar *select=nullptr, const char *rangeName=nullptr, Int_t nStart=0, Int_t nStop=2000000000);  Load values from tree 't' into this data collection, optionally selecting events using the RooFormulaVar 'select'. ;  ; RooAbsDataStore * merge (const RooArgSet &allvars, std::list< RooAbsDataStore * > dstoreList) override;  Merge columns of supplied data set(s) with this data set. ;  ; Int_t numEntries () const override;  ; std::unique_ptr< RooAbsDataStore > reduce (RooStringView name, RooStringView title, const RooArgSet &vars, const RooFormulaVar *cutVar, const char *cutRange, std::size_t nStart, std::size_t nStop) override;  ; void reset () override;  ; void Reset (Option_t *option=nullptr);  Interface function to TTree::Reset. ;  ; void resetBuffers () override;  ; void resetCache () override;  Remove tree with values of cached observables and clear list of cached observables. ;  ; void restoreAlternateBuffers ();  ; const RooArgSet & row ();  ; void setArgStatus (const RooArgSet &set, bool active) override;  Activate or deactivate the branch status of the TTree branch associated with the given set of dataset observables. ;  ; void setExternalWeightArray (const double *arrayWgt, const double *arrayWgtErrLo, const double *arrayWgtErrHi, const double *arraySumW2) override;  ; void Streamer (TBuffer &) override;  Stream an object of class RooTreeDataStore. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; double sumEntries () const override;  ; TTree & tree ();  ; const TTree * tree () const override;  ; double weight () const override;  Return the weight of the n-th data point (n='index') in memory. ;  ; virtual double weight () const=0;  ; double weight (Int_t index) const;  ; void weightError (double &lo, double &hi, RooAbsData::ErrorType etype=RooAbsData::Poisso",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:5988,cache,cached,5988,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,2,['cache'],['cached']
Performance,"t Double_t * ; a, . const Double_t * ; b, . Int_t ; maxpts, . Double_t ; epsrel, . Double_t ; epsabs, . Double_t & ; relerr, . Int_t & ; nfnevl, . Int_t & ; ifail . ). virtual . This function computes, to an attempted specified accuracy, the value of the integral. ; Parameters. [in]nNumber of dimensions [2,15] ; [in]a,bOne-dimensional arrays of length >= N . On entry A[i], and B[i], contain the lower and upper limits of integration, respectively. ; [in]maxptsMaximum number of function evaluations to be allowed. maxpts >= 2^n +2*n*(n+1) +1 if maxpts<minpts, maxpts is set to 10*minpts ; [in]epsrelSpecified relative accuracy. ; [in]epsabsSpecified absolute accuracy. The integration algorithm will attempt to reach either the relative or the absolute accuracy. In case the maximum function called is reached the algorithm will stop earlier without having reached the desired accuracy; [out]relerrContains, on exit, an estimation of the relative accuracy of the result. ; [out]nfnevlnumber of function evaluations performed. ; [out]ifail0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the specified value of maxpts.; 3 n<2 or n>15 . Method:; The default method used is the Genz-Mallik adaptive multidimensional algorithm using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator() to different integrators. Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class Possible methods are : Vegas, Miser or Plain IN case of MC integration the accuracy is determined by the number of function calls, one should be careful not to use a too large value of maxpts ; Definition at line 2851 of file TF1.cxx. ◆ IntegralMultiple() [3/3]. virtual Double_t TF1::IntegralMultiple ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:100053,perform,performed,100053,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['perform'],['performed']
Performance,"t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:23934,cache,cache,23934,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,1,['cache'],['cache']
Performance,"t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const; -- List the chain. Long64_t Merge(const char* name, Option_t* option = """"); Merge all the entries in the chain into a new tree in a new file. See important note in the following function Merge(). If the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TChain.html:39991,Load,LoadTree,39991,root/html532/TChain.html,https://root.cern,https://root.cern/root/html532/TChain.html,1,['Load'],['LoadTree']
Performance,"t GetReadEvent() constDefinition TTree.h:550; TTree::~TTree~TTree() overrideDestructor.Definition TTree.cxx:920; TTree::IsFolderbool IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TTree.h:587; TTree::ImportClusterRangesvoid ImportClusterRanges(TTree *fromtree)Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAuto...Definition TTree.cxx:6372; TTree::fEstimateLong64_t fEstimateNumber of entries to estimate histogram limits.Definition TTree.h:102; TTree::GetHistogramTH1 * GetHistogram()Definition TTree.h:519; TTree::GetAllocationCountUInt_t GetAllocationCount() constDefinition TTree.h:443; TTree::FlushBasketsImplInt_t FlushBasketsImpl() constInternal implementation of the FlushBaskets algorithm.Definition TTree.cxx:5146; TTree::GetDebugMinLong64_t GetDebugMin() constDefinition TTree.h:461; TTree::LoadTreeFriendvirtual Long64_t LoadTreeFriend(Long64_t entry, TTree *T)Load entry on behalf of our master tree, we may use an index.Definition TTree.cxx:6557; TTree::WriteInt_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0) overrideWrite this object to the current directory.Definition TTree.cxx:9753; TTree::fTreeIndexTVirtualIndex * fTreeIndexPointer to the tree Index (if any)Definition TTree.h:129; TTree::UseCurrentStylevoid UseCurrentStyle() overrideReplace current attributes by current style.Definition TTree.cxx:9714; TTree::GetTreeNumbervirtual Int_t GetTreeNumber() constDefinition TTree.h:559; TTree::GetEventInt_t GetEvent(Long64_t entry, Int_t getall=0)Definition TTree.h:509; TTree::fNotifyTObject * fNotifyObject to be notified when loading a Tree.Definition TTree.h:120; TTree::BranchImpvirtual TBranch * BranchImp(const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel)Same as TTree::Branch() with added check that addobj matches className.Definition TTree.cxx:1554; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:80500,Load,LoadTreeFriendvirtual,80500,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,3,['Load'],"['Load', 'LoadTreeFriend', 'LoadTreeFriendvirtual']"
Performance,"t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:50163,cache,cache,50163,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,6,['cache'],['cache']
Performance,"t IsLocked(); Check lock state. Int_t GetVerboseLevel(); Set verbosity level (static function).; 0 - suppress messages related to geom-painter visibility level; 1 - default value. void SetVerboseLevel(Int_t vl); Return current verbosity level (static function). TGeoManager * Import(const char* filename, const char* name = """", Option_t* option = """"); static function; Import a geometry from a gdml or ROOT file. -Case 1: gdml; if filename ends with "".gdml"" the foreign geometry described with gdml; is imported executing some python scripts in $ROOTSYS/gdml.; NOTE that to use this option, the PYTHONPATH must be defined like; export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/gdml. -Case 2: root file (.root) or root/xml file (.xml); Import in memory from filename the geometry with key=name.; if name="""" (default), the first TGeoManager object in the file is returned. Note that this function deletes the current gGeoManager (if one); before importing the new object. void UpdateElements(); Update element flags when geometry is loaded from a file. Bool_t InitArrayPNE() const; Initialize PNE array for fast access via index and unique-id. Bool_t GetTminTmax(Double_t& tmin, Double_t& tmax) const; Get time cut for drawing tracks. void SetTminTmax(Double_t tmin = 0, Double_t tmax = 999); Set time cut interval for drawing tracks. If called with no arguments, time; cut will be disabled. void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. TGeoParallelWorld * CreateParallelWorld(const char* name); Create a parallel world for prioritized navigation. This can be populated; with physical nodes and can be navigated independently using its API.; In case the flag SetUseParallelWorldNav is set, any navigation query in the; main geometry is checked against the parallel geometry, which gets priority; in case of overlaps with the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoManager.html:71477,load,loaded,71477,root/html534/TGeoManager.html,https://root.cern,https://root.cern/root/html534/TGeoManager.html,3,['load'],['loaded']
Performance,"t IsLocked(); Check lock state. Int_t GetVerboseLevel(); Set verbosity level (static function).; 0 - suppress messages related to geom-painter visibility level; 1 - default value. void SetVerboseLevel(Int_t vl); Return current verbosity level (static function). TGeoManager * Import(const char* filename, const char* name = """", Option_t* option = """"); static function; Import a geometry from a gdml or ROOT file. -Case 1: gdml; if filename ends with "".gdml"" the foreign geometry described with gdml; is imported executing some python scripts in $ROOTSYS/gdml.; NOTE that to use this option, the PYTHONPATH must be defined like; export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/gdml. -Case 2: root file (.root) or root/xml file (.xml); Import in memory from filename the geometry with key=name.; if name="""" (default), the first TGeoManager object in the file is returned. Note that this function deletes the current gGeoManager (if one); before importing the new object. void UpdateElements(); Update element flags when geometry is loaded from a file. Bool_t InitArrayPNE() const; Initialize PNE array for fast access via index and unique-id. Int_t * GetIntBuffer(Int_t length); Get a temporary buffer of Int_t*. Double_t * GetDblBuffer(Int_t length); Get a temporary buffer of Double_t*. Bool_t GetTminTmax(Double_t& tmin, Double_t& tmax) const; Get time cut for drawing tracks. void SetTminTmax(Double_t tmin = 0, Double_t tmax = 999); Set time cut interval for drawing tracks. If called with no arguments, time; cut will be disabled. void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. Bool_t IsLoopingVolumes() const; --- private methods. {return fLoopVolumes;}. void SetLoopVolumes(Bool_t flag = kTRUE); {fLoopVolumes=flag;}. Int_t GetNmany() const; {return fCurrentNavigator->GetNmany();}. Bool_t IsFolder() const; --- visual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:68238,load,loaded,68238,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,2,['load'],['loaded']
Performance,"t IsLocked(); Check lock state. Int_t GetVerboseLevel(); Set verbosity level (static function).; 0 - suppress messages related to geom-painter visibility level; 1 - default value. void SetVerboseLevel(Int_t vl); Return current verbosity level (static function). TGeoManager * Import(const char* filename, const char* name = """", Option_t* option = """"); static function; Import a geometry from a gdml or ROOT file. -Case 1: gdml; if filename ends with "".gdml"" the foreign geometry described with gdml; is imported executing some python scripts in $ROOTSYS/gdml.; NOTE that to use this option, the PYTHONPATH must be defined like; export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/gdml. -Case 2: root file (.root) or root/xml file (.xml); Import in memory from filename the geometry with key=name.; if name="""" (default), the first TGeoManager object in the file is returned. Note that this function deletes the current gGeoManager (if one); before importing the new object. void UpdateElements(); Update element flags when geometry is loaded from a file. Bool_t InitArrayPNE() const; Initialize PNE array for fast access via index and unique-id. Int_t * GetIntBuffer(Int_t length); Get a temporary buffer of Int_t*. Double_t * GetDblBuffer(Int_t length); Get a temporary buffer of Double_t*. Bool_t GetTminTmax(Double_t& tmin, Double_t& tmax) const; Get time cut for drawing tracks. void SetTminTmax(Double_t tmin = 0, Double_t tmax = 999); Set time cut interval for drawing tracks. If called with no arguments, time; cut will be disabled. void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. Bool_t IsLoopingVolumes() const; --- private methods. {return fLoopVolumes;}. void SetLoopVolumes(Bool_t flag = kTRUE); {fLoopVolumes=flag;}. ThreadData_t& GetThreadData() const. Int_t GetNmany() const; {return GetCurrentNavigator()->GetNmany",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoManager.html:69949,load,loaded,69949,root/html532/TGeoManager.html,https://root.cern,https://root.cern/root/html532/TGeoManager.html,1,['load'],['loaded']
Performance,"t Name = TrainingHistory_PyKeras_'accuracy', Entries= 0, Total sum= 6.25938; TH1.Print Name = TrainingHistory_PyKeras_'loss', Entries= 0, Total sum= 7.32887; TH1.Print Name = TrainingHistory_PyKeras_'val_accuracy', Entries= 0, Total sum= 5.40937; TH1.Print Name = TrainingHistory_PyKeras_'val_loss', Entries= 0, Total sum= 7.21788; Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_BDT.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_TMVA_DNN_CPU.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_TMVA_CNN_CPU.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_PyKeras.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_PyTorch.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: BDT for Classification performance; : ; BDT : [dataset] : Evaluation of BDT on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.00573 sec ; Factory : Test method: TMVA_DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 400; : ; TMVA_DNN_CPU : [dataset] : Evaluation of TMVA_DNN_CPU on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.023 sec ; Factory : Test method: TMVA_CNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 400; : ; TMVA_CNN_CPU : [dataset] : Evaluation of TMVA_CNN_CPU on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.149 sec ; Factory : Test method: PyKeras for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; :",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:37881,perform,performance,37881,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['perform'],['performance']
Performance,t PictureAttributes_t attr const char char ret_data h unsigned char height h length. Definition at line 245 of file TGWin32VirtualXProxy.cxx. ◆ ListFonts. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char ListFonts. Definition at line 228 of file TGWin32VirtualXProxy.cxx. ◆ LoadQueryFont. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window LoadQueryFont. Definition at line 208 of file TGWin32VirtualXProxy.cxx. ◆ Long_t. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Long_t. Defin,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html:192282,Load,LoadQueryFont,192282,doc/master/TGWin32VirtualXProxy_8cxx.html,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html,2,['Load'],['LoadQueryFont']
Performance,"t RGB value for the pixel in the ""color"" structure. ;  ; void QueryPointer (Int_t &ix, Int_t &iy) override;  Returns the pointer position. ;  ; void QueryPointer (Window_t id, Window_t &rootw, Window_t &childw, Int_t &root_x, Int_t &root_y, Int_t &win_x, Int_t &win_y, UInt_t &mask) override;  Returns the root window the pointer is logically on and the pointer coordinates relative to the root window's origin. ;  ; void RaiseWindow (Window_t id) override;  Raises the specified window to the top of the stack so that no sibling window obscures it. ;  ; void ReadGIF (Int_t x0, Int_t y0, const char *file);  ; Bool_t ReadPictureDataFromFile (const char *filename, char ***ret_data) override;  Reads picture data from file ""filename"" and store it in ""ret_data"". ;  ; void RemoveWindow (ULongptr_t qwid) override;  Removes the created by Qt window ""qwid"". ;  ; void ReparentWindow (Window_t id, Window_t pid, Int_t x, Int_t y) override;  If the specified window is mapped, ReparentWindow automatically performs an UnmapWindow request on it, removes it from its current position in the hierarchy, and inserts it as the child of the specified parent. ;  ; Int_t RequestLocator (Int_t mode, Int_t ctyp, Int_t &x, Int_t &y) override;  Requests Locator position. ;  ; Int_t RequestString (Int_t x, Int_t y, char *text) override;  Requests string: text is displayed and can be edited with Emacs-like keybinding. ;  ; void RescaleWindow (Int_t wid, UInt_t w, UInt_t h) override;  Rescales the window ""wid"". ;  ; void ResetAttFill (Option_t *option="""") override;  Reset this fill attributes to default values. ;  ; void ResetAttLine (Option_t *option="""") override;  Reset this line attributes to default values. ;  ; void ResetAttMarker (Option_t *toption="""") override;  Reset this marker attributes to the default values. ;  ; void ResetAttText (Option_t *toption="""") override;  Reset this text attributes to default values. ;  ; Int_t ResizePixmap (Int_t wid, UInt_t w, UInt_t h) override;  Resizes the speci",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:20002,perform,performs,20002,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,1,['perform'],['performs']
Performance,"t ROOT::RWebWindow::GetOperationTmout ; (; ); const. inline . Returns timeout for synchronous WebWindow operations. ; Definition at line 351 of file RWebWindow.hxx. ◆ GetRelativeAddr() [1/2]. std::string RWebWindow::GetRelativeAddr ; (; const RWebWindow & ; win); const. Returns relative URL address for the specified window Address can be required if one needs to access data from one window into another window Used for instance when inserting panel into canvas. ; Definition at line 1270 of file RWebWindow.cxx. ◆ GetRelativeAddr() [2/2]. std::string RWebWindow::GetRelativeAddr ; (; const std::shared_ptr< RWebWindow > & ; win); const. Returns relative URL address for the specified window Address can be required if one needs to access data from one window into another window Used for instance when inserting panel into canvas. ; Definition at line 1260 of file RWebWindow.cxx. ◆ GetSendQueueLength(). int RWebWindow::GetSendQueueLength ; (; unsigned ; connid); const. Returns send queue length for specified connection. ; Parameters. connidconnection id, 0 - maximal value for all connections is returned If wrong connection id specified, -1 is return . Definition at line 1509 of file RWebWindow.cxx. ◆ GetServer(). THttpServer * RWebWindow::GetServer ; (; ). Return THttpServer instance serving requests to the window. ; Definition at line 181 of file RWebWindow.cxx. ◆ GetUrl(). std::string RWebWindow::GetUrl ; (; bool ; remote = true). Return URL string to connect web window URL typically includes extra parameters required for connection with the window like http://localhost:9635/win1/?key=<connection_key>#<session_key> When. ; Parameters. remoteis true, real HTTP server will be started automatically and widget can be connected from the web browser. If; remoteis false, HTTP server will not be started and window can be connected only from ROOT application itself. !!! WARNING - do not invoke this method without real need, each URL consumes resources in widget and in http server .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:33295,queue,queue,33295,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['queue'],['queue']
Performance,"t ROOT::RWebWindowWSHandler::CanServeFiles ; (; ); const. inlineoverridevirtual . returns true when window allowed to serve files relative to default page ; Reimplemented from THttpWSHandler.; Definition at line 138 of file RWebWindowWSHandler.hxx. ◆ CompleteWSSend(). void ROOT::RWebWindowWSHandler::CompleteWSSend ; (; UInt_t ; wsid). inlineoverridevirtual . React on completion of multi-threaded send operation. ; Reimplemented from THttpWSHandler.; Definition at line 155 of file RWebWindowWSHandler.hxx. ◆ GetBoolEnv(). int RWebWindowWSHandler::GetBoolEnv ; (; const std::string & ; name, . int ; dflt = -1 . ). static . Parse boolean gEnv variable which should be ""yes"" or ""no"". ; Returns1 for true or 0 for false Returns; Parameters. dfltif result is not defined ; namename of the env variable . Definition at line 47 of file RWebWindowsManager.cxx. ◆ GetCodeVersion(). std::string ROOT::RWebWindowWSHandler::GetCodeVersion ; (; ). inlineoverrideprotectedvirtual . Method generate extra suffix for all kinds of loaded code. ; Reimplemented from THttpWSHandler.; Definition at line 38 of file RWebWindowWSHandler.hxx. ◆ GetDefaultPageContent(). TString ROOT::RWebWindowWSHandler::GetDefaultPageContent ; (; ). inlineoverridevirtual . returns content of default web-page THttpWSHandler interface ; Reimplemented from THttpWSHandler.; Definition at line 135 of file RWebWindowWSHandler.hxx. ◆ ProcessBatchHolder(). Bool_t ROOT::RWebWindowWSHandler::ProcessBatchHolder ; (; std::shared_ptr< THttpCallArg > & ; ). inlineoverrideprotectedvirtual . Method used to accept or reject root_batch_holder.js request. ; Reimplemented from THttpWSHandler.; Definition at line 33 of file RWebWindowWSHandler.hxx. ◆ ProcessWS(). Bool_t ROOT::RWebWindowWSHandler::ProcessWS ; (; THttpCallArg * ; arg). inlineoverridevirtual . Process websocket request - called from THttpServer thread THttpWSHandler interface. ; Implements THttpWSHandler.; Definition at line 142 of file RWebWindowWSHandler.hxx. ◆ VerifyDefault",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowWSHandler.html:16462,load,loaded,16462,doc/v632/classROOT_1_1RWebWindowWSHandler.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowWSHandler.html,1,['load'],['loaded']
Performance,"t ROOT::RWebWindowWSHandler::CanServeFiles ; (; ); const. inlineoverridevirtual . returns true when window allowed to serve files relative to default page ; Reimplemented from THttpWSHandler.; Definition at line 138 of file RWebWindowWSHandler.hxx. ◆ CompleteWSSend(). void ROOT::RWebWindowWSHandler::CompleteWSSend ; (; UInt_t ; wsid). inlineoverridevirtual . React on completion of multi-threaded send operation. ; Reimplemented from THttpWSHandler.; Definition at line 155 of file RWebWindowWSHandler.hxx. ◆ GetBoolEnv(). int RWebWindowWSHandler::GetBoolEnv ; (; const std::string & ; name, . int ; dflt = -1 . ). static . Parse boolean gEnv variable which should be ""yes"" or ""no"". ; Returns1 for true or 0 for false Returns; Parameters. dfltif result is not defined ; namename of the env variable . Definition at line 48 of file RWebWindowsManager.cxx. ◆ GetCodeVersion(). std::string ROOT::RWebWindowWSHandler::GetCodeVersion ; (; ). inlineoverrideprotectedvirtual . Method generate extra suffix for all kinds of loaded code. ; Reimplemented from THttpWSHandler.; Definition at line 38 of file RWebWindowWSHandler.hxx. ◆ GetDefaultPageContent(). TString ROOT::RWebWindowWSHandler::GetDefaultPageContent ; (; ). inlineoverridevirtual . returns content of default web-page THttpWSHandler interface ; Reimplemented from THttpWSHandler.; Definition at line 135 of file RWebWindowWSHandler.hxx. ◆ ProcessBatchHolder(). Bool_t ROOT::RWebWindowWSHandler::ProcessBatchHolder ; (; std::shared_ptr< THttpCallArg > & ; ). inlineoverrideprotectedvirtual . Method used to accept or reject root_batch_holder.js request. ; Reimplemented from THttpWSHandler.; Definition at line 33 of file RWebWindowWSHandler.hxx. ◆ ProcessWS(). Bool_t ROOT::RWebWindowWSHandler::ProcessWS ; (; THttpCallArg * ; arg). inlineoverridevirtual . Process websocket request - called from THttpServer thread THttpWSHandler interface. ; Implements THttpWSHandler.; Definition at line 142 of file RWebWindowWSHandler.hxx. ◆ VerifyDefault",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowWSHandler.html:16455,load,loaded,16455,doc/master/classROOT_1_1RWebWindowWSHandler.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowWSHandler.html,1,['load'],['loaded']
Performance,"t ReadBuffer(char* buf, Int_t len); Override TNetFile::ReadBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Pass through to TNetFile implementation which will call back eventually; to our ReadBuffer with 2 arguments to deal with xrootd errors. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Implementation dealing with the xrootd server.; Returns kTRUE in case of errors.; This is the same as TXNetFile::ReadBuffer but using the async; call from xrootd. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReadBuffer; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure.; Note: This is the overloading made in TXNetFile. If ReadBuffers; is supported by xrootd it will try to get the whole list from one single; call avoiding the latency of multiple calls. Bool_t WriteBuffer(const char* buffer, Int_t BufferLength); Override TNetFile::WriteBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. void Init(Bool_t create); Initialize the file. Makes sure that the file is really open before; calling TFile::Init. It may block. Bool_t IsOpen() const; Return kTRUE if the file is open, kFALSE otherwise. TFile::EAsyncOpenStatus GetAsyncOpenStatus(); Return status of asynchronous request. Int_t ReOpen(const Option_t* mode); Re-open the file (see TNetFile::ReOpen() or TFile::ReOpen(); for more details). void Close(const Option_t* opt = """"); Close the file (see TNetFile::Close() or TFile::Close(); for more details). void Flush(); Flushes un-written data. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Override TNetFile::SysStat (see parent's method for more details). Int_t SysClose(Int_t fd); Override TNetFile::SysClose (see paren",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetFile.html:29525,latency,latency,29525,root/html602/TXNetFile.html,https://root.cern,https://root.cern/root/html602/TXNetFile.html,2,['latency'],['latency']
Performance,"t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the branches in the cache. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). const TObjArray * GetCachedBranches() const; { return fBranches; }. Bool_t IsLearning() const; {return fIsLearning;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TTreeCache.h 41101 2011-10-03 16:23:48Z pcanal $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:23901,cache,cache,23901,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['cache'],['cache']
Performance,"t RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; RooArgSetRooAbsDataStore::_cachedVars; Int_t_curIndex! Index associated with current event; RooAbsDataStore*_curStore! Datastore associated with current event; map<Int_t,RooAbsDataStore*>_dataMap; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; RooCategory*_indexCat; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; Bool_t_ownComps! ; RooArgSetRooAbsDataStore::_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCompositeDataStore(). RooCompositeDataStore(const char* name, const char* title, const RooArgSet& vars, RooCategory& indexCat, map<std::string,RooAbsDataStore*> inputData); Convert map by label to map by index for more efficient internal use. RooCompositeDataStore(const RooCompositeDataStore& other, const char* newname = 0); Convert map by label to map by index for more efficient internal use. RooCompositeDataStore(const RooCompositeDataStore& other, const RooArgSet& vars, const char* newname = 0); Update index category pointer, if it is contained in input argument vars. ~RooComp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCompositeDataStore.html:9143,cache,cached,9143,root/html532/RooCompositeDataStore.html,https://root.cern,https://root.cern/root/html532/RooCompositeDataStore.html,4,"['cache', 'load']","['cached', 'loading']"
Performance,"t RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); virtual Bool_tsyncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Double_tRooAbsReal::traceEval(const RooArgSet* set) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum ExtendMode { CanNotBeExtended; CanBeExtended; MustBeExtended; };; enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:40949,Cache,CacheMode,40949,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,1,['Cache'],['CacheMode']
Performance,"t RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsPdf::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsPdf::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsPdf::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; static voidRooAbsPdf::raiseEvalError(); Int_t*RooAbsPdf::randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; virtual Bool_tRooResolutionModel::redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidselectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidselectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); virtual Bool_tRooAbsPdf::syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooResolutionModel::traceEvalHook(Double_t value) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidupdateCoefficients(RooAddModel::CacheElem& cache, const RooArgSet* nset) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:36281,Cache,CacheElem,36281,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,8,"['Cache', 'cache']","['CacheElem', 'cache']"
Performance,"t RooAbsOptTestStatistic& other, const char* name = 0); Copy constructor. void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsOptTestStatistic.html:45999,optimiz,optimization,45999,root/html602/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html,2,['optimiz'],['optimization']
Performance,"t RooArgSet& vars, const char* wgtVarName = 0); RooVectorDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t, const char* wgtVarName = 0); virtual~RooVectorDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); const RooVectorDataStore*cache() const; virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kTRUE); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidRooAbsDataStore::checkInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooVectorDataStore.html:1840,cache,cacheOwner,1840,root/html534/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html534/RooVectorDataStore.html,1,['cache'],['cacheOwner']
Performance,"t RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooThresholdCategory&operator=(const RooThresholdCategory&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooThresholdCategory.html:11283,optimiz,optimizeCacheMode,11283,root/html602/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html602/RooThresholdCategory.html,2,['optimiz'],['optimizeCacheMode']
Performance,"t RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); virtual TStringRooAbsCachedPdf::histNameSuffix() const; Bool_tRooAbsArg::inhibitDirty() const; virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsSelfCachedPdf.html:37324,optimiz,optimizeDirtyHook,37324,root/html602/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsSelfCachedPdf.html,6,['optimiz'],['optimizeDirtyHook']
Performance,"t RooCatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeRooAbsCategory::evaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); virtual voidsetIndexFast(Int_t index); Bool_tsetOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategoryLValue.html:19677,optimiz,optimizeDirtyHook,19677,root/html602/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"t RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsPdf.html:38679,optimiz,optimizeDirtyHook,38679,root/html602/RooAbsPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"t RooLinkedList& norms, const RooLinkedList& imps, const RooLinkedList& ints, const RooLinkedList& cross) const; Bool_tRooAbsArg::inhibitDirty() const; voidinitializeFromCmdArgList(const RooArgSet& fullPdfSet, const RooLinkedList& l); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; RooAbsReal*makeCondPdfRatioCorr(RooAbsReal& term, const RooArgSet& termNset, const RooArgSet& termImpSet, const char* normRange, const char* refRange) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; const char*makeRGPPName(const char* pfx, const RooArgSet& term, const RooArgSet& iset, const RooArgSet& nset, const char* isetRangeName) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:38547,optimiz,optimizeDirtyHook,38547,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,3,['optimiz'],['optimizeDirtyHook']
Performance,"t TFileCacheWrite::Flush ; (; ). virtual . Flush the current write buffer to the file. ; Returns kTRUE in case of error. ; Definition at line 79 of file TFileCacheWrite.cxx. ◆ GetBytesInCache(). virtual Int_t TFileCacheWrite::GetBytesInCache ; (; ); const. inlinevirtual . Definition at line 38 of file TFileCacheWrite.h. ◆ IsA(). TClass * TFileCacheWrite::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 44 of file TFileCacheWrite.h. ◆ operator=(). TFileCacheWrite & TFileCacheWrite::operator= ; (; const TFileCacheWrite & ; ). privatedelete . ◆ Print(). void TFileCacheWrite::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print class internal structure. ; Reimplemented from TObject.; Definition at line 94 of file TFileCacheWrite.cxx. ◆ ReadBuffer(). Int_t TFileCacheWrite::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Called by the read cache to check if the requested data is not in the write cache buffer. ; Returns -1 if data not in write cache, 0 otherwise. ; Definition at line 108 of file TFileCacheWrite.cxx. ◆ SetFile(). void TFileCacheWrite::SetFile ; (; TFile * ; file). virtual . Set the file using this cache. ; Any write not yet flushed will be lost. ; Definition at line 153 of file TFileCacheWrite.cxx. ◆ Streamer(). void TFileCacheWrite::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TFileCacheWrite::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 44 of file TFileCacheWrite.h. ◆ WriteBuffer(). Int_t TFileCacheWrite::WriteBuffer ; (; const char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Write buffer at position pos in the write buffer. ; The function returns 1 if the buffer has been successfully entered into the write buffer. The function returns 0 in case WriteBuffer() was recusively ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheWrite.html:14038,cache,cache,14038,doc/master/classTFileCacheWrite.html,https://root.cern,https://root.cern/doc/master/classTFileCacheWrite.html,2,['cache'],['cache']
Performance,"t TGLVertex3 & viewportVertex) const; for 3D viewport -> 3D world vertex conversions.; See also OpenGL gluUnProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(Double_t viewportX, Double_t viewportY, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport point (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of Bool_t and TGLVertex3. If line intersects std::pair.first (Bool_t) is; kTRUE, and std::pair.second (TGLVertex) contains the intersection vertex.; If line does not intersect (line and plane parallel) std::pair.first; (Bool_t) if kFALSE, and std::pair.second (TGLVertex) is invalid. NOTE: The projection lines is extended for the plane intersection test; hence the intersection vertex can lie outside the near/far clip regions; (not visible). Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(const TPoint& viewport, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport TPoint (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of bool and vertex. If line intersects. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLCamera.html:12690,cache,cache,12690,root/html528/TGLCamera.html,https://root.cern,https://root.cern/root/html528/TGLCamera.html,6,['cache'],['cache']
Performance,"t TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp); voidRooCacheManager<RooAbsCacheElement>::sterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Bool_t_clearOnRedirect; Int_tRooCacheManager<RooAbsCacheElement>::_lastIndexLast slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSizeMaximum size; RooNormSetCache*RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; RooAbsCacheElement**RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen; list<RooArgSet*>_optCacheObsList! list of all optCacheObservables owned; RooArgSet*_optCacheObservables! current optCacheObservables ; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooObjCacheManager.html:3676,cache,cache,3676,root/html528/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html528/RooObjCacheManager.html,1,['cache'],['cache']
Performance,"t TObjArray* axes, Bool_t keepTargetAxis) const; Create an empty histogram with name and title with a given; set of axes. Create a TH1D/TH2D/TH3D, depending on the number; of elements in axes. THnSparse* CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); Create a THnSparse object from a histogram deriving from TH1. void FillExMap(); We have been streamed; set up fBins. TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); Fit a THnSparse with function f. since the data is sparse by default a likelihood fit is performed; merging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THnSparse.html:16148,Perform,Perform,16148,root/html528/THnSparse.html,https://root.cern,https://root.cern/root/html528/THnSparse.html,3,['Perform'],['Perform']
Performance,"t TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::PyMethodBase::PyInitializestatic void PyInitialize()Initialize Python interpreter.Definition PyMethodBase.cxx:153; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; AuthorHarshal Shende ; Definition in file TMVA_CNN_Classification.py. tutorialstmvaTMVA_CNN_Classification.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:18438,multi-thread,multi-threading,18438,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['multi-thread'],['multi-threading']
Performance,"t TVectorD& rho, TString options = ""a"", Double_t nSigma = 3, Bool_t rotate = kTRUE); Constructor. RooNDKeysPdf(const char* name, const char* title, RooAbsReal& x, RooDataSet& data, RooNDKeysPdf::Mirror mirror = NoMirror, Double_t rho = 1, Double_t nSigma = 3, Bool_t rotate = kTRUE); Backward compatibility constructor for (1-dim) RooKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const char* name, const char* title, RooAbsReal& x, RooAbsReal& y, RooDataSet& data, TString options = ""a"", Double_t rho = 1.0, Double_t nSigma = 3, Bool_t rotate = kTRUE); Backward compatibility constructor for Roo2DKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const RooNDKeysPdf& other, const char* name = 0); Constructor. ~RooNDKeysPdf(). createPdf(Bool_t firstCall = kTRUE) const; evaluation order of constructor. setOptions() const; set the configuration. initialize() const; initialization. loadDataSet(Bool_t firstCall) const; copy the dataset and calculate some useful variables. mirrorDataSet() const; determine mirror dataset.; mirror points are added around the physical boundaries of the dataset; Two steps:; 1. For each entry, determine if it should be mirrored (the mirror configuration).; 2. For each mirror configuration, make the mirror points. loadWeightSet() const. calculateShell(RooNDKeysPdf::BoxInfo* bi) const; determine points in +/- nSigma shell around the box determined by the variable; ranges. These points are needed in the normalization, to determine probability; leakage in and out of the box. calculatePreNorm(RooNDKeysPdf::BoxInfo* bi) const; bi->nEventsBMSW=0.;; bi->nEventsBW=0.;. sortDataIndices(RooNDKeysPdf::BoxInfo* bi = 0) const; sort entries, as needed for loopRange(). calculateBandWidth() const. gauss(vector<Double_t>& x, vector<std::vector<Double_t> >& weights) const; loop over all closest point to x, as determined by loopRange(). loopRange(vector<Double_t>& x, map<Int_t,Bool_t>& ibMap) const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNDKeysPdf.html:48944,load,loadDataSet,48944,root/html534/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html534/RooNDKeysPdf.html,1,['load'],['loadDataSet']
Performance,"t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 1899 of file TTreeCache.cxx. ◆ ProcessMiss(). bool TTreeCache::ProcessMiss ; (; Long64_t ; pos, . int ; len . ). private . ! Given a file read not in the miss cache, handle (possibly) loading the data. ; Process a cache miss; (pos, len) isn't in the buffer.; The first time we have a miss, we buffer as many baskets we can (up to the maximum size of the TTreeCache) in memory from all branches that are not in the prefetch list.; Subsequent times, we fetch all the buffers corresponding to branches that had previously seen misses. If it turns out the (pos, len) isn't in the list of branches, we treat this as if it was the first miss.; Returns true if we were able to pull the data into the miss cache. ; Definition at line 863 of file TTreeCache.cxx. ◆ ReadBuffer(). Int_t TTreeCache::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). overridevirtual . Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ; Otherwise try to fill the cache from the list of selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache. This function overloads TFileCacheRead::ReadBuffer. . Reimplemented from TFileCacheRead.; Definition at line 2027 of file TTreeCache.cxx. ◆ ReadBufferNormal(). Int_t TTreeCache::ReadBufferNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Old method ReadBuffer before the addition of the prefetch mechanism. ; Definition at line 1927 of file TTreeCache.cxx. ◆ ReadBufferPrefetch(). Int_t TTreeCache::ReadBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:46361,cache,cache,46361,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,['cache'],['cache']
Performance,"t UploadPackageOnClient(const char* package, TProof::EUploadPackageOpt opt, TMD5* md5); Upload a package on the client in ~/.proof/packages.; The 'opt' allows to specify whether the .PAR should be just unpacked; in the existing dir (opt = kUntar, default) or a remove of the existing; directory should be executed (opt = kRemoveOld), thereby triggering a full; re-build. This option if effective only for PROOF protocol > 8.; Returns 0 in case of success and -1 in case of error. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Load the specified macro on master, workers and, if notOnClient is; kFALSE, on the client. The macro file is uploaded if new or updated.; Additional files to be uploaded (or updated, if needed) can be specified; after a comma, e.g. ""mymacro.C+,thisheader.h,thatheader.h"".; If existing in the same directory, a header basename(macro).h or .hh, is also; uploaded.; The default is to load the macro also on the client; notOnClient can be used; to avoid loading on the client.; On masters, if uniqueWorkers is kTRUE, the macro is loaded on unique workers; only, and collection is not done; if uniqueWorkers is kFALSE, collection; from the previous request is done, and broadcasting + collection from the; other workers is done.; The wrks arg can be used on the master to limit the set of workers.; Returns 0 in case of success and -1 in case of error. Int_t AddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0); Add 'libpath' to the lib path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); Add 'incpath' to the inc path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t RemoveDynamicPath(const char* libpath, Bool_t onClient = kFALSE); Remove 'lib",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProof.html:68683,load,load,68683,root/html530/TProof.html,https://root.cern,https://root.cern/root/html530/TProof.html,4,['load'],"['load', 'loading']"
Performance,"t UploadPackageOnClient(const char* package, TProof::EUploadPackageOpt opt, TMD5* md5); Upload a package on the client in ~/.proof/packages.; The 'opt' allows to specify whether the .PAR should be just unpacked; in the existing dir (opt = kUntar, default) or a remove of the existing; directory should be executed (opt = kRemoveOld), thereby triggering a full; re-build. This option if effective only for PROOF protocol > 8.; Returns 0 in case of success and -1 in case of error. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Load the specified macro on master, workers and, if notOnClient is; kFALSE, on the client. The macro file is uploaded if new or updated.; Additional files to be uploaded (or updated, if needed) can be specified; after a comma, e.g. ""mymacro.C+,thisheader.h,thatheader.h"".; If existing in the same directory, a header basename(macro).h or .hh, is also; uploaded.; The default is to load the macro also on the client; notOnClient can be used; to avoid loading on the client.; On masters, if uniqueWorkers is kTRUE, the macro is loaded on unique workers; only, and collection is not done; if uniqueWorkers is kFALSE, collection; from the previous request is done, and broadcasting + collection from the; other workers is done.; The wrks arg can be used on the master to limit the set of workers.; Returns 0 in case of success and -1 in case of error. Int_t AddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0, Bool_t doCollect = kTRUE); Add 'libpath' to the lib path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0, Bool_t doCollect = kTRUE); Add 'incpath' to the inc path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t RemoveDynamicPath(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:78548,load,load,78548,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,6,['load'],"['load', 'loading']"
Performance,"t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Copies class version to buffer, but not writes it to sql immidiately; Version will be used to produce complete table; name, which will include class version. void* ReadObjectAny(const TClass* clCast); Read object from buffer. Only used from TBuffer. void SkipObjectAny(); ?????? Skip any kind of object from buffer; !!!!!! fix me, not yet implemented; Should be just skip of current column later. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); Read Float16 value. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); Read Double32 value. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); Write Float16 value. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBufferSQL2.html:29733,optimiz,optimize,29733,root/html530/TBufferSQL2.html,https://root.cern,https://root.cern/root/html530/TBufferSQL2.html,5,['optimiz'],['optimize']
Performance,"t a typical user session should be at most: root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::SetIncludePathvirtual void SetIncludePath(const char *includePath)IncludePath should contain the list of compiler flags to indicate where to find user defined header f...Definition TSystem.cxx:4194; The user may sometimes try to compile a script before it has loaded all the needed shared libraries. In this case we want to be helpful and output a list of the unresolved symbols. So if the loading of the created shared library fails, we will try to build a executable that contains the script. The linker should then output a list of missing symbols.; To support this we provide a TSystem::SetMakeExe() function, that sets the directive telling how to create an executable. The loader will need to be informed of all the libraries available. The information about the libraries that has been loaded by .L and TSystem::Load() is accessible to the script compiler. However, the information about the libraries that have been selected at link time by the application builder (like the root libraries for root.exe) are not available and need to be explicitly listed in fLinkedLibs (either by default or by a call to TSystem::SetLinkedLibs()).; To simplify customization we could also add to the .rootrc support for the variables Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; ; Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; I#define I(x, y, z); And also support for MakeSharedLibs() and MakeExe().; (the ... have to be replaced by the actual values and are here only to shorten this comment).; Note that the default behavior is to remove libraries when closing ROOT, ie TSystem::CleanCompiledMacros() is called in the TROOT destructor. The default behavior of .L ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:45396,load,loaded,45396,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['load'],['loaded']
Performance,"t accessed; Int_t_maxSizeMaximum size; RooNormSetCache*_nsetCache! Normalization/Integration set manager; vector<double,allocator<double> >**_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0). Int_t setObj(const RooArgSet* nset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); Setter function without integration set. return setObj(const RooArgSet* nset, const RooArgSet* iset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0). void reset(). void sterilize(). Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. T* getObjByIndex(Int_t index) const. const RooNameSet* nameSet1ByIndex(Int_t index) const. const RooNameSet* nameSet2ByIndex(Int_t index) const. void insertObjectHook(vector<double,allocator<double> >& ); Interface function to perform post-insert operations on cached object. template <> void RooCacheManager<RooAbsCacheElement> ShowMembers(TMemberInspector& insp, char* parent); needed to avoid 'specialization after instantiation' problem in gcc. » Last changed: Mon Dec 7 13:47:00 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCacheManager_vector_double___.html:4268,cache,cacheSize,4268,root/html526/RooCacheManager_vector_double___.html,https://root.cern,https://root.cern/root/html526/RooCacheManager_vector_double___.html,2,['cache'],"['cache', 'cacheSize']"
Performance,"t after the 'isInited.load()`; 1606 // and restart after this thread has finished the initialization (i.e. a rare case),; 1607 // the only penalty we pay is a spurious 2nd lookup for an unknown function.; 1608 [[maybe_unused]] static const auto _res = []() {; 1609 gROOT->ProcessLine(""TF1::InitStandardFunctions();"");; 1610 isInited = true;; 1611 return true;; 1612 }();; 1613 return fFunctions->FindObject(name);; 1614}; 1615 ; 1616////////////////////////////////////////////////////////////////////////////////; 1617 ; 1618TFunctionTemplate *TROOT::GetFunctionTemplate(const char *name); 1619{; 1620 if (!gInterpreter) return nullptr;; 1621 ; 1622 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1623 ; 1624 return (TFunctionTemplate*)fFuncTemplate->FindObject(name);; 1625}; 1626 ; 1627////////////////////////////////////////////////////////////////////////////////; 1628/// Return pointer to global variable by name. If load is true force; 1629/// reading of all currently defined globals from CINT (more expensive).; 1630 ; 1631TGlobal *TROOT::GetGlobal(const char *name, Bool_t load) const; 1632{; 1633 return (TGlobal *)gROOT->GetListOfGlobals(load)->FindObject(name);; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// Return pointer to global variable with address addr.; 1638 ; 1639TGlobal *TROOT::GetGlobal(const TObject *addr, Bool_t /* load */) const; 1640{; 1641 if (addr == nullptr || ((Longptr_t)addr) == -1) return nullptr;; 1642 ; 1643 TInterpreter::DeclId_t decl = gInterpreter->GetDataMemberAtAddr(addr);; 1644 if (decl) {; 1645 TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));; 1646 return (TGlobal*)globals->Get(decl);; 1647 }; 1648 // If we are actually looking for a global that is held by a global; 1649 // pointer (for example gRandom), we need to find a pointer with the; 1650 // correct value.; 1651 decl = gInterpreter->GetDataMemberWithValue(a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:62646,load,load,62646,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['load']
Performance,"t alpha = 1.); Set color of the line axis and tick marks. void SetLabelColor(Color_t color = 1, Float_t alpha = 1.); Set color of labels. void SetLabelFont(Style_t font = 62); Set labels' font. void SetLabelOffset(Float_t offset = 0.005); Set distance between the axis and the labels; The distance is expressed in per cent of the pad width. void SetLabelSize(Float_t size = 0.04); Set size of axis labels; The size is expressed in per cent of the pad width. void SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE); Set the number of divisions for this axis. if optim = kTRUE (default), the number of divisions will be; optimized around the specified value.; if optim = kFALSE, or n < 0, the axis will be forced to use; exactly n divisions. n = n1 + 100*n2 + 10000*n3. Where n1 is the number of primary divisions,; n2 is the number of second order divisions and; n3 is the number of third order divisions. e.g. 512 means 12 primary and 5 secondary divisions. If the number of divisions is ""optimized"" (see above) n1, n2, n3 are; maximum values. void SetNdivisions(Int_t n1, Int_t n2, Int_t n3, Bool_t optim = kTRUE); see function above. void SetTickLength(Float_t length = 0.03); Set tick mark length; The length is expressed in per cent of the pad width. void SetTitleOffset(Float_t offset = 1); Set distance between the axis and the axis title; Offset is a correction factor with respect to the ""standard"" value.; offset = 1 uses the default position that is computed in function; of the label offset and size.; offset = 1.2 will add 20 per cent more to the default offset. void SetTitleSize(Float_t size = 0.04); Set size of axis title; The size is expressed in per cent of the pad width. void SetTitleColor(Color_t color = 1); Set color of axis title. void SetTitleFont(Style_t font = 62); Set the title font. void Streamer(TBuffer& ); Stream an object of class TAttAxis. TAttAxis(). Int_t GetNdivisions() const; {return fNdivisions;}. Color_t GetAxisColor() const; {return fAxisColor;}. Color_t G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TAttAxis.html:3850,optimiz,optimized,3850,root/html534/TAttAxis.html,https://root.cern,https://root.cern/root/html534/TAttAxis.html,1,['optimiz'],['optimized']
Performance,"t also on boundary condition. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t * GetLastPoint() const; {return fLastPoint;}. Double_t GetSafeDistance() const; {return fSafety;}. Double_t GetLastSafety() const; {return fLastSafety;}. Double_t GetStep() const; {return fStep;}. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE). Bool_t IsStartSafe() const; {return fStartSafe;}. void Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNavigator.html:18776,cache,cache,18776,root/html528/TGeoNavigator.html,https://root.cern,https://root.cern/root/html528/TGeoNavigator.html,2,['cache'],['cache']
Performance,"t also on boundary condition. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t * GetLastPoint() const; {return fLastPoint;}. Double_t GetSafeDistance() const; {return fSafety;}. Double_t GetLastSafety() const; {return fLastSafety;}. Double_t GetStep() const; {return fStep;}. Int_t GetThreadId() const; {return fThreadId;}. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE). Bool_t IsS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoNavigator.html:19127,cache,cache,19127,root/html532/TGeoNavigator.html,https://root.cern,https://root.cern/root/html532/TGeoNavigator.html,4,['cache'],['cache']
Performance,"t also stores the option). ;  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, TObjLink *prev);  ;  Protected Member Functions inherited from TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions;  TListOfEnums (const TListOfEnums &)=delete;  Represent interpreter state when we last did a full load. ;  ; void Load ();  Load all the DataMembers known to the interpreter for the scope 'fClass' into this collection. ;  ; void MapObject (TObject *obj);  Add pair<id, object> to the map of functions and their ids. ;  ; TListOfEnums & operator= (const TListOfEnums &)=delete;  ; void SetClass (TClass *cl);  ; void Unload ();  Mark 'all func' as being unloaded. ;  ; void Unload (TEnum *e);  Mark enum 'e' as being unloaded. ;  ; void UnmapObject (TObject *obj);  Remove a pair<id, object> from the map of functions and their ids. ;  . Private Attributes; TClass * fClass;  ; TExMap * fIds;  Context of this list. Not owned. ;  ; Bool_t fIsLoaded;  Holder of TEnum for unloaded Enums. ;  ; ULong64_t fLastLoadMarker;  Mark whether Load was executed. ;  ; THashList * fUnloaded;  Map from DeclId_t to TEnum*. ;  . Friends; class TClass;  ; class TCling;  ; class TProtoClass;  ; class TROOT;  . Additional Inherited Members;  Protected Ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnums.html:20882,load,load,20882,doc/master/classTListOfEnums.html,https://root.cern,https://root.cern/doc/master/classTListOfEnums.html,1,['load'],['load']
Performance,"t an error message will be printed if there are problems such as syntax errors.; Eval(const char* expr)- the argument is a string of Python code that is evaluated as an expression. The result of the expression is returned, if it is either a builtin type (int, long, float, double, and const char* are supported), a Python type that can cross, or a ROOT type. If a ROOT type is returned, an explicit cast to void* is needed to assign the return value to a local pointer (which may have a different type), whereas builtin types will be cast implicitly, if possible, to the type of the local variable to which they are assigned.; Bind(TObject* obj,const char* label) - transfer a ROOT object from the Cling to the Python interpreter, where it will be referenced with a variable called “label”.; Prompt() - Transfer the interactive prompt to Python.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first with gSystem->Load() before use. Refer back to the other example of the use of TPython that was given in “Access to Python from ROOT”.; To show in detail how Python access can be used, an example Python module is needed, as follows:; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; This module can now be loaded into a Cling session, the class used to instantiate objects, and their member functions called for showing how different types can cross:; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; Note that the LoadMacro() call makes the class automatically available, such that it can be used directly. Otherwise, a gROOT->GetClass() call is required first.; 19.1.5.5 Callbacks; The simplest way of setting a callback to Python from Cling, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1058031,load,loaded,1058031,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['Load', 'load']","['Load', 'loaded']"
Performance,"t and from top to bottom. Note that data must be 32-bit aligned ; Reimplemented from TVirtualX.; Definition at line 3631 of file TGX11.cxx. ◆ CreateRegion(). Region_t TGX11::CreateRegion ; (; ). overridevirtual . Create a new empty region. ; Reimplemented from TVirtualX.; Definition at line 2491 of file GX11Gui.cxx. ◆ CreateWindow(). Window_t TGX11::CreateWindow ; (; Window_t ; parent, . Int_t ; x, . Int_t ; y, . UInt_t ; w, . UInt_t ; h, . UInt_t ; border, . Int_t ; depth, . UInt_t ; clss, . void * ; visual, . SetWindowAttributes_t * ; attr, . UInt_t ; wtype . ). overridevirtual . Return handle to newly created X window. ; Reimplemented from TVirtualX.; Definition at line 370 of file GX11Gui.cxx. ◆ DeclFileName(). static const char * TGX11::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 401 of file TGX11.h. ◆ DeleteFont(). void TGX11::DeleteFont ; (; FontStruct_t ; fs). overridevirtual . Explicitly delete font structure obtained with LoadQueryFont(). ; Reimplemented from TVirtualX.; Definition at line 962 of file GX11Gui.cxx. ◆ DeleteGC(). void TGX11::DeleteGC ; (; GContext_t ; gc). overridevirtual . Explicitly delete a graphics context. ; Reimplemented from TVirtualX.; Definition at line 1032 of file GX11Gui.cxx. ◆ DeleteImage(). void TGX11::DeleteImage ; (; Drawable_t ; img). overridevirtual . Destroy XImage img. ; Reimplemented from TVirtualX.; Definition at line 2665 of file GX11Gui.cxx. ◆ DeletePictureData(). void TGX11::DeletePictureData ; (; void * ; data). overridevirtual . Delete picture data created by the function ReadPictureDataFromFile. ; Reimplemented from TVirtualX.; Definition at line 1292 of file GX11Gui.cxx. ◆ DeletePixmap(). void TGX11::DeletePixmap ; (; Pixmap_t ; pmap). overridevirtual . Explicitly delete pixmap resource. ; Reimplemented from TVirtualX.; Definition at line 1092 of file GX11Gui.cxx. ◆ DeleteProperty(). void TGX11::DeleteProperty ; (; Window_t ; win, . Atom_t & ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11.html:65926,Load,LoadQueryFont,65926,doc/master/classTGX11.html,https://root.cern,https://root.cern/doc/master/classTGX11.html,1,['Load'],['LoadQueryFont']
Performance,"t at cHq3 = 0.01, cHl3 = 1.0, cHDD = 0.2; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; morphfunc.setParameter(""cHq3"", 0.01); morphfunc.setParameter(""cHl3"", 1.0); morphfunc.setParameter(""cHDD"", 0.2); ; pseudo_hist = morphfunc.createTH1(""pseudo_hist""); pseudo_dh = ROOT.RooDataHist(""pseudo_dh"", ""pseudo_dh"", [obsvar], pseudo_hist); ; # reset parameters to zeros before fit; morphfunc.setParameter(""cHq3"", 0.0); morphfunc.setParameter(""cHl3"", 0.0); morphfunc.setParameter(""cHDD"", 0.0); ; # set error to set initial step size in fit; cHq3.setError(0.1); cHl3.setError(0.1); cHDD.setError(0.1); ; # Wrap pdf on morphfunc and fit to data histogram; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; # wrapper pdf to normalise morphing function to a morphing pdf; model = ROOT.RooWrapperPdf(""wrap_pdf"", ""wrap_pdf"", morphfunc); fitres = model.fitTo(pseudo_dh, SumW2Error=True, Optimize=False, Save=True, PrintLevel=-1); # run the fit; # Get the correlation matrix; hcorr = fitres.correlationHist(); ; # Extract postfit distribution and plot with initial histogram; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; postfit_hist = morphfunc.createTH1(""morphing_postfit_hist""); postfit_dh = ROOT.RooDataHist(""morphing_postfit_dh"", ""morphing_postfit_dh"", [obsvar], postfit_hist); ; frame0 = obsvar.frame(Title=""Input templates for p_{T}^{V}""); postfit_dh.plotOn(; frame0,; Name=""postfit_dist"",; DrawOption=""C"",; LineColor=""b"",; DataError=None,; XErrorSize=0,; ); pseudo_dh.plotOn(frame0, Name=""input""); ; # Draw plots on canvas; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; c1 = ROOT.TCanvas(""fig3"", ""fig3"", 800, 400); c1.Divide(2, 1); ; c1.cd(1); ROOT.gPad.SetLeftMargin(0.15); ROOT.gPad.SetRightMargin(0.05); ; model.paramOn(frame0, ROOT.RooFit.Layout(0.50, 0.75, 0.9)); frame0.GetXaxis().SetTitle(""p_{T}^{V}""); fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8py.html:3060,Optimiz,Optimize,3060,doc/master/rf712__lagrangianmorphfit_8py.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8py.html,1,['Optimiz'],['Optimize']
Performance,"t backgroundWeight = 1.0;; ; // You can add an arbitrary number of signal or background trees; loader->AddSignalTree ( signalTree, signalWeight );; loader->AddBackgroundTree( backgroundTree, backgroundWeight );; ; ; // Set individual event weights (the variables must exist in the original TTree); // for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; // for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; //loader->SetBackgroundWeightExpression( ""weight"" );; ; // Apply additional cuts on the signal and background samples (can be different); TCut mycuts = """"; // for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; TCut mycutb = """"; // for example: TCut mycutb = ""abs(var1)<0.5"";; ; // Tell the factory how to use the training and testing events; //; // If no numbers of events are given, half of the events in the tree are used; // for training, and the other half for testing:; // loader->PrepareTrainingAndTestTree( mycut, ""SplitMode=random:!V"" );; // To also specify the number of testing events, use:; ; loader->PrepareTrainingAndTestTree( mycuts, mycutb,; ""nTrain_Signal=7000:nTrain_Background=7000:SplitMode=Random:NormMode=NumEvents:!V"" );; ; /***; ## Booking Methods; ; Here we book the TMVA methods. We book first a Likelihood based on KDE (Kernel Density Estimation), a Fischer discriminant, a BDT; and a shallow neural network; ; */; ; ; // Likelihood (""naive Bayes estimator""); if (useLikelihood) {; factory.BookMethod(loader, TMVA::Types::kLikelihood, ""Likelihood"",; ""H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50"" );; }; // Use a kernel density estimator to approximate the PDFs; if (useLikelihoodKDE) {; factory.BookMethod(loader, TMVA::Types::kLikelihood, ""LikelihoodKDE"",; ""!H:!V:!TransformOutput:PDFInterpol=KDE:KDEtype=Gauss:KDEiter=Adaptive:KDEFineFactor=0.3:KDEborder=None:NAvEvtPerBin=50"" );; ; }; ; // Fisher discriminant (same as LD); if (useFisc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:61272,load,loader,61272,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,2,['load'],['loader']
Performance,"t base class for p.d.f.s that need or want to cache their evaluate() output in a RooHistPdf defined in terms of the used observables. More...;  ; class  RooAbsCachedReal;  Abstract base class for functions that need or want to cache their evaluate() output in a RooHistFunc defined in terms of the used observables. More...;  ; class  RooAbsCacheElement;  Abstract base class for objects to be stored in RooAbsCache cache manager objects. More...;  ; class  RooAbsCategory;  A space to attach TBranches. More...;  ; class  RooAbsCategoryLValue;  Abstract base class for objects that represent a discrete value that can be set from the outside, i.e. More...;  ; class  RooAbsCollection;  Abstract container object that can hold multiple RooAbsArg objects. More...;  ; class  RooAbsData;  Abstract base class for binned and unbinned datasets. More...;  ; class  RooAbsDataStore;  Abstract base class for a data collection. More...;  ; class  RooAbsFunc;  Abstract interface for evaluating a real-valued function of one real variable and performing numerical algorithms on it. More...;  ; class  RooAbsGenContext;  Abstract base class for generator contexts of RooAbsPdf objects. More...;  ; class  RooAbsHiddenReal;  Base class for objects that want to hide their return value from interactive use, e.g. More...;  ; class  RooAbsIntegrator;  Abstract interface for integrators of real-valued functions that implement the RooAbsFunc interface. More...;  ; class  RooAbsLValue;  Abstract base class for objects that are lvalues, i.e. More...;  ; class  RooAbsMCStudyModule;  Base class for add-on modules to RooMCStudy that can perform additional calculations on each generate+fit cycle managed by RooMCStudy. More...;  ; class  RooAbsMoment;  ; class  RooAbsNumGenerator;  Abstract base class for MC event generator implementations like RooAcceptReject and RooFoam. More...;  ; class  RooAbsOptTestStatistic;  Abstract base class for test statistics objects that evaluate a function or PDF at each point ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Roofitcore.html:1961,perform,performing,1961,doc/master/group__Roofitcore.html,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html,1,['perform'],['performing']
Performance,"t be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject. ◆ Process(). Bool_t h1analysisTreeReader::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used.; WARNING when a selector is used with a TChain, you must use the pointer to the current TTree to call GetEntry(entry). The entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use: fChain->GetTree()->GetEntry(entry). ; Reimplemented from TSelector. ◆ Reset(). void h1analysisTreeReader::Reset ; (; ). Definition at line 81 of file h1analysisTreeReader.h. ◆ SetInputList(). void h1analysisTreeReader::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 72 of file h1analysisTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classh1analysisTreeReader.html:16407,load,loaded,16407,doc/master/classh1analysisTreeReader.html,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html,1,['load'],['loaded']
Performance,"t be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToVStore(RooVectorDataStore& vstore). void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that branch is set to a correctly typed conversion buffer in this; RooRealVar. A flag is set that will cause copyCache to copy the; object value from the appropriate conversion buffer instead of; the _value buffer. void fillTreeBranch(TTree& t); Fill the tree branch that associated with this object with its current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsReal.html:57227,cache,cached,57227,root/html532/RooAbsReal.html,https://root.cern,https://root.cern/root/html532/RooAbsReal.html,8,['cache'],"['cache', 'cached']"
Performance,"t branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:133371,cache,cachesize,133371,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,1,['cache'],['cachesize']
Performance,t cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; RooRealProxy_mu; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigN,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBCPGenDecay.html:39523,cache,cache,39523,root/html526/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html526/RooBCPGenDecay.html,1,['cache'],['cache']
Performance,t cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; RooRealProxy_mu; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC genera,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBCPGenDecay.html:40097,cache,cache,40097,root/html528/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html528/RooBCPGenDecay.html,1,['cache'],['cache']
Performance,t cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; RooRealProxy_mu; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculatin,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBCPGenDecay.html:40374,cache,cache,40374,root/html530/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html530/RooBCPGenDecay.html,1,['cache'],['cache']
Performance,t cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; RooRealProxy_mu; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalcul,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBCPGenDecay.html:40777,cache,cache,40777,root/html532/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html532/RooBCPGenDecay.html,1,['cache'],['cache']
Performance,"t can be drawn, evaluated, etc. --For multidimensional fitting, TFormulas of the form:; x[0]++...++x[n] can be used; 2.2.2 There is no need to create the function if you don't want to,; the formula can be set by expression:; --Example:; // 2 is the number of dimensions; TLinearFitter *lf = new TLinearFitter(2);; lf->SetFormula(""x ++ y ++ x*x*y*y"");. 2.2.3 The fastest functions to compute are polynomials and hyperplanes.; --Polynomials are set the usual way: ""pol1"", ""pol2"",...; --Hyperplanes are set by expression ""hyp3"", ""hyp4"", ...; ---The ""hypN"" expressions only work when the linear fitter; is used directly, not through TH1::Fit or TGraph::Fit.; To fit a graph or a histogram with a hyperplane, define; the function as ""1++x++y"".; ---A constant term is assumed for a hyperplane, when using; the ""hypN"" expression, so ""hyp3"" is in fact fitting with; ""1++x++y++z"" function.; --Fitting hyperplanes is much faster than fitting other; expressions so if performance is vital, calculate the; function values beforehand and give them to the fitter; as variables; --Example:; You want to fit ""sin(x)|cos(2*x)"" very fast. Calculate; sin(x) and cos(2*x) beforehand and store them in array *data.; Then:; TLinearFitter *lf=new TLinearFitter(2, ""hyp2"");; lf->AssignData(npoint, 2, data, y);. 2.3 Resetting the formula; 2.3.1 If the input data is stored (or added via AssignData() function),; the fitting formula can be reset without re-adding all the points.; --Example:; TLinearFitter *lf=new TLinearFitter(""1++x++x*x"");; lf->AssignData(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCova",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLinearFitter.html:4189,perform,performance,4189,root/html528/TLinearFitter.html,https://root.cern,https://root.cern/root/html528/TLinearFitter.html,6,['perform'],['performance']
Performance,"t can be integrated by all remaining components. If such a set exists, it reconfirms that; each component is capable of analytically integrating the common set, and combines the components; individual integration codes into a single integration code valid for RooProdPdf. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given scenario code. Bool_t checkObservables(const RooArgSet* nset) const; Obsolete. RooAbsPdf::ExtendMode extendMode() const; If this product contains exactly one extendable p.d.f return the extension abilities of; that p.d.f, otherwise return CanNotBeExtended. Double_t expectedEvents(const RooArgSet* nset) const; Return the expected number of events associated with the extentable input p.d.f; in the product. If there is no extendable term, return zero and issue and error. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return generator context optimized for generating events from product p.d.f.s. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Query internal generation capabilities of component p.d.f.s and aggregate capabilities; into master configuration passed to the generator context. void initGenerator(Int_t code); Forward one-time initialization call to component generation initialization; methods. void generateEvent(Int_t code); Generate a single event with configuration specified by 'code'; Defer internal generation to components as encoded in the _genCode; registry for given generator code. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Forward determination of safety of internal generator code to; component p.d.f that would generate the given observable. RooArgSet* findPdfNSet(RooAbsPdf& pdf) const; Look up user specified normalization set for given input PDF component. RooArgSet* getConst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProdPdf.html:53385,optimiz,optimized,53385,root/html528/RooProdPdf.html,https://root.cern,https://root.cern/root/html528/RooProdPdf.html,6,['optimiz'],['optimized']
Performance,"t can suffer from much larger numerical accuracy; 492 when the condition of the matrix is large; 493 */; 494 bool InvertFast();; 495 ; 496 /**; 497 Invert a square Matrix and returns a new matrix. In case the inversion fails; 498 the current matrix is returned.; 499 \param ifail . ifail will be set to 0 when inversion is successful.; 500 See ROOT::Math::SMatrix::InvertFast for the inversion algorithm; 501 */; 502 SMatrix<T,D1,D2,R> InverseFast(int & ifail ) const;; 503 ; 504 /**; 505 Inversion of a symmetric positive defined Matrix using Choleski decomposition.; 506 ( this method changes the current matrix).; 507 Return true if inversion is successful.; 508 The method used is based on Choleski decomposition; 509 A compile error is given if the matrix is not of type symmetric and a run-time failure if the; 510 matrix is not positive defined.; 511 For solving a linear system, it is possible to use also the function; 512 ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion; 513 */; 514 bool InvertChol();; 515 ; 516 /**; 517 Invert of a symmetric positive defined Matrix using Choleski decomposition.; 518 A compile error is given if the matrix is not of type symmetric and a run-time failure if the; 519 matrix is not positive defined.; 520 In case the inversion fails the current matrix is returned.; 521 \param ifail . ifail will be set to 0 when inversion is successful.; 522 See ROOT::Math::SMatrix::InvertChol for the inversion algorithm; 523 */; 524 SMatrix<T,D1,D2,R> InverseChol(int & ifail ) const;; 525 ; 526 /**; 527 determinant of square Matrix via Dfact.; 528 Return true when the calculation is successful.; 529 \param det will contain the calculated determinant value; 530 \b Note: this will destroy the contents of the Matrix!; 531 */; 532 bool Det(T& det);; 533 ; 534 /**; 535 determinant of square Matrix via Dfact.; 536 Return true when the calculation is successful.; 537 \param det will contain the calculated determinant value; 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SMatrix_8h_source.html:17495,perform,performing,17495,doc/master/SMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html,1,['perform'],['performing']
Performance,"t char * RooObjCacheManager::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooObjCacheManager::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 62 of file RooObjCacheManager.h. ◆ clearObsList(). static bool RooObjCacheManager::clearObsList ; (; ). inlinestatic . Definition at line 48 of file RooObjCacheManager.h. ◆ DeclFileName(). static const char * RooObjCacheManager::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 62 of file RooObjCacheManager.h. ◆ doClearObsList(). static void RooObjCacheManager::doClearObsList ; (; bool ; flag). inlinestatic . Definition at line 47 of file RooObjCacheManager.h. ◆ findConstantNodes(). void RooObjCacheManager::findConstantNodes ; (; const RooArgSet & ; obs, . RooArgSet & ; cacheList, . RooLinkedList & ; processedNodes . ). overridevirtual . If clearOnRedirect is false, forward constant term optimization calls to cache elements. ; Reimplemented from RooAbsCache.; Definition at line 209 of file RooObjCacheManager.cxx. ◆ insertObjectHook(). void RooObjCacheManager::insertObjectHook ; (; RooAbsCacheElement & ; obj). overridevirtual . Set owner link on all object inserted into cache. ; Also if cache mode optimization was requested, apply it now to cache element being inserted ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 175 of file RooObjCacheManager.cxx. ◆ IsA(). TClass * RooObjCacheManager::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 62 of file RooObjCacheManager.h. ◆ operModeHook(). void RooObjCacheManager::operModeHook ; (; ). overridevirtual . Intercept changes to cache operation mode and forward to cache elements. ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 108 of file RooObjCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:9123,optimiz,optimization,9123,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"t char *branchname, const char *leafname) override;  Return a pointer to the leaf name in the current tree. ;  ; TLeaf * GetLeaf (const char *name) override;  Return a pointer to the leaf name in the current tree. ;  ; TObjArray * GetListOfFiles () const;  ; Double_t GetMaximum (const char *columname) override;  Return maximum of column with name columname. ;  ; Double_t GetMinimum (const char *columname) override;  Return minimum of column with name columname. ;  ; Int_t GetNbranches () override;  Return the number of branches of the current tree. ;  ; Int_t GetNtrees () const;  ; TList * GetStatus () const;  ; TTree * GetTree () const override;  ; Int_t GetTreeNumber () const override;  ; Long64_t * GetTreeOffset () const;  ; Int_t GetTreeOffsetLen () const;  ; Double_t GetWeight () const override;  Return the chain weight. ;  ; bool InPlaceClone (TDirectory *newdirectory, const char *options="""") override;  Move content to a new file. (NOT IMPLEMENTED for TChain) ;  ; Int_t LoadBaskets (Long64_t maxmemory) override;  Dummy function. ;  ; Long64_t LoadTree (Long64_t entry) override;  Find the tree which contains entry, and set it as the current tree. ;  ; void Lookup (bool force=false);  Check / locate the files in the chain. ;  ; virtual void Loop (Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED) ;  ; void ls (Option_t *option="""") const override;  List the chain. ;  ; virtual Long64_t Merge (const char *name, Option_t *option="""");  Merge all the entries in the chain into a new tree in a new file. ;  ; Long64_t Merge (TCollection *list, Option_t *option="""") override;  Merge all chains in the collection. (NOT IMPLEMENTED) ;  ; Long64_t Merge (TCollection *list, TFileMergeInfo *info) override;  Merge all chains in the collection. (NOT IMPLEMENTED) ;  ; virtual Long64_t Merge (TFile *file, Int_t basketsize, Option_t *option="""");  Merge all the entries in the chain into",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofChain.html:8997,Load,LoadBaskets,8997,doc/master/classTProofChain.html,https://root.cern,https://root.cern/doc/master/classTProofChain.html,1,['Load'],['LoadBaskets']
Performance,"t char *datamember) constTClass; GetDataMemberOffset(const char *membername) constTClass; GetDeclFileLine() constTClassinline; GetDeclFileName() constTClass; GetDeclIdMap()TClassprivatestatic; GetDelete() constTClass; GetDeleteArray() constTClass; GetDestructor() constTClass; GetDict(const char *cname)TClassstatic; GetDict(const std::type_info &info)TClassstatic; GetDictionary(const char *name)TDictionarystatic; GetDictionary(const std::type_info &typeinfo)TDictionarystatic; GetDirectoryAutoAdd() constTClass; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetFunctionTemplate(const char *name)TClass; GetHeapInstanceCount() constTClassinline; GetIconName() constTObjectvirtual; GetIdMap()TClassprivatestatic; GetImplFileLine() constTClassinline; GetImplFileName() constTClassinline; GetInstanceCount() constTClassinline; GetIsAProxy() constTClass; GetLastReadInfo() constTClassinline; GetListOfAllPublicDataMembers(Bool_t load=kTRUE)TClass; GetListOfAllPublicMethods(Bool_t load=kTRUE)TClass; GetListOfBases()TClass; GetListOfDataMembers(Bool_t load=kTRUE)TClass; GetListOfEnums(Bool_t load=kTRUE)TClass; GetListOfFunctionTemplates(Bool_t load=kTRUE)TClass; GetListOfMethodOverloads(const char *name) constTClass; GetListOfMethods(Bool_t load=kTRUE)TClass; GetListOfRealData() constTClassinline; GetListOfUsingDataMembers(Bool_t load=kTRUE)TClass; GetMenuItems(TList *listitems)TClass; GetMenuList() constTClass; GetMerge() constTClass; GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)TClass; GetMethodAllAny(const char *method)TClass; GetMethodAny(const char *method)TClass; GetMethodList()TClassprivate; GetMethodWithPrototype(const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)TClass; GetMissingDictionaries(THashTable &result, bool recurse=false)TClass; GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)TClassprotected; GetMissin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass-members.html:9358,load,load,9358,doc/master/classTClass-members.html,https://root.cern,https://root.cern/doc/master/classTClass-members.html,1,['load'],['load']
Performance,"t char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::UpdateBranchesvirtual void UpdateBranches(TTree *tree)Update pointer to current Tree and recompute pointers to the branches in the cache.Definition TTreeCache.cxx:2211; TTreeCache::ResetCachevirtual void ResetCache()This will simply clear the cache.Definition TTreeCache.cxx:2040; TTree::TClusterIteratorHelper class to iterate over cluster of baskets.Definition TTree.h:270; TTree::TFriendLockHelper class to prevent infinite recursion in the usage of TTree Friends.Definition TTree.h:188; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::AddFriendvirtual TFriendElement * AddFriend(const char *treename, const char *filename="""")Add a TFriendElement to the list of friends.Definition TTree.cxx:1332; TTree::FindBranchvirtual TBranch * FindBranch(const char *name)Return the branch that correspond to the path 'branchname', which can include the name of the tree or...Definition TTree.cxx:4841; TTree::SetBranchStatusvirtual void SetBranchStatus(const char *bname, bool status=true, UInt_t *found=nullptr)Set branch status to Process or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:143547,cache,cache,143547,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['cache'],['cache']
Performance,"t char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListSymbolsvirtual void ListSymbols(const char *module, const char *re="""")List symbols in a shared library.Definition TSystem.cxx:2064; TSystem::DoBeepvirtual void DoBeep(Int_t=-1, Int_t=-1) constDefinition TSystem.h:332; TSystem::fObjExtTString fObjExtDefinition TSystem.h:314; TSystem::fLinkdefSuffixTString fLinkdefSuffixDefinition TSystem.h:318; TSystem::fBeepFreqInt_t fBeepFreqDefinition TSystem.h:287; TSystem::GetCpuInfovirtual int GetCpuInfo(CpuInfo_t *info, Int_t sampleTime=1000) constReturns cpu load average and load info into the CpuInfo_t structure.Definition TSystem.cxx:2469; TSystem::EAclicPropertiesEAclicPropertiesDefinition TSystem.h:270; TSystem::kFlatBuildDir@ kFlatBuildDirDefinition TSystem.h:271; TSystem::GetListOfFileHandlersvirtual TSeqCollection * GetListOfFileHandlers() constDefinition TSystem.h:382; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::SetMakeSharedLibvirtual void SetMakeSharedLib(const char *directives)Directives should contain the description on how to compile and link a shared lib.Definition TSystem.cxx:4145; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::InnerLoopvirtual void InnerLoop()Inner event loop.Definition TSystem.cxx:400; TSystem::GetVolumesvirtual TList * GetVolumes(Option_t *) constDefinition TSystem.h:455; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:49650,load,loaded,49650,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['load'],['loaded']
Performance,"t char *name, Short_t line)Definition TClass.h:555; TClass::GetListOfAllPublicDataMembersTList * GetListOfAllPublicDataMembers(Bool_t load=kTRUE)Returns a list of all public data members of this class and its base classes.Definition TClass.cxx:3862; TClass::TClassTClass(const TClass &tc)=delete; TClass::AddClassToDeclIdMapstatic void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass *cl)static: Add a TClass* to the map of classes.Definition TClass.cxx:511; TClass::~TClassvirtual ~TClass()TClass dtor. Deletes all list that might have been created.Definition TClass.cxx:1660; TClass::fIsSyntheticPairBool_t fIsSyntheticPairIndicates whether this class can be split or not. Values are -1, 0, 1, 2.Definition TClass.h:250; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5400; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::fCurrentInfostd::atomic< TVirtualStreamerInfo * > fCurrentInfoCurrent 'state' of the class (Emulated,Interpreted,Loaded)Definition TClass.h:278; TClass::GetListOfFunctionTemplatesTList * GetListOfFunctionTemplates(Bool_t load=kTRUE)Return TListOfFunctionTemplates for a class.Definition TClass.cxx:3798; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4915; TClass::fImplFileNameconst char * fImplFileNameDefinition TClass.h:214; TClass::RegisterStreamerInfovoid RegisterStreamerInfo(TVirtualStreamerInfo *info)Register the StreamerInfo in the given slot, change the State of the TClass as appropriate.Definition TClass.cxx:7296; TClass::operator=TClass & operator=(const TClass &)=delete; TClass::fCheckSumstd::atomic< UInt_t > fCheckSumDefinition TClass.h:219; TClass::UnregisterAddressInRepositoryvoid UnregisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:318; TClass::fMethodstd::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:49416,Load,Loaded,49416,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['Load'],['Loaded']
Performance,"t char *name, Short_t line)Definition TClass.h:555; TClass::GetListOfAllPublicDataMembersTList * GetListOfAllPublicDataMembers(Bool_t load=kTRUE)Returns a list of all public data members of this class and its base classes.Definition TClass.cxx:3929; TClass::TClassTClass(const TClass &tc)=delete; TClass::AddClassToDeclIdMapstatic void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass *cl)static: Add a TClass* to the map of classes.Definition TClass.cxx:576; TClass::~TClassvirtual ~TClass()TClass dtor. Deletes all list that might have been created.Definition TClass.cxx:1727; TClass::fIsSyntheticPairBool_t fIsSyntheticPairIndicates whether this class can be split or not. Values are -1, 0, 1, 2.Definition TClass.h:250; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::fCurrentInfostd::atomic< TVirtualStreamerInfo * > fCurrentInfoCurrent 'state' of the class (Emulated,Interpreted,Loaded)Definition TClass.h:278; TClass::GetListOfFunctionTemplatesTList * GetListOfFunctionTemplates(Bool_t load=kTRUE)Return TListOfFunctionTemplates for a class.Definition TClass.cxx:3865; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::fImplFileNameconst char * fImplFileNameDefinition TClass.h:214; TClass::RegisterStreamerInfovoid RegisterStreamerInfo(TVirtualStreamerInfo *info)Register the StreamerInfo in the given slot, change the State of the TClass as appropriate.Definition TClass.cxx:7363; TClass::operator=TClass & operator=(const TClass &)=delete; TClass::fCheckSumstd::atomic< UInt_t > fCheckSumDefinition TClass.h:219; TClass::UnregisterAddressInRepositoryvoid UnregisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:318; TClass::fMethodstd::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:49244,Load,Loaded,49244,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['Load'],['Loaded']
Performance,"t char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, const Double_t *ybins, Option_t *option="""");  Create a 2-D Profile with fix bins in X and variable bins in Y. ;  ;  TProfile2D (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Double_t zlow, Double_t zup, Option_t *option="""");  Constructor for Profile2D histograms with range in z. ;  ;  TProfile2D (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Option_t *option="""");  Normal Constructor for Profile histograms. ;  ;  TProfile2D (const TProfile2D &profile);  Copy constructor. ;  ;  ~TProfile2D () override;  Default destructor for Profile2D histograms. ;  ; Bool_t Add (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1) override;  Replace contents of this profile2D by the addition of h1 and h2. ;  ; Bool_t Add (const TH1 *h1, Double_t c1=1) override;  Performs the operation: this = this + c1*h1 . ;  ; Bool_t Add (TF1 *h1, Double_t c1=1, Option_t *option="""") override;  Performs the operation: this = this + c1*f1 . ;  ; Int_t BufferEmpty (Int_t action=0) override;  Fill histogram with all entries in the buffer. ;  ; void BuildOptions (Double_t zmin, Double_t zmax, Option_t *option);  Set Profile2D histogram structure and options. ;  ; void Copy (TObject &hnew) const override;  Copy a Profile2D histogram to a new profile2D histogram. ;  ; Bool_t Divide (const TH1 *h1) override;  Divide this profile2D by h1. ;  ; Bool_t Divide (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1, Option_t *option="""") override;  Replace contents of this profile2D by the division of h1 by h2. ;  ; Bool_t Divide (TF1 *h1, Double_t c1=1) override;  Performs the operation: this = this/(c1*f1) . ;  ; void ExtendAxis (Double_t x, TAxis *axis) override;  Profile histogram is resized along axis such that x is in the axis range. ;  ; Int_t Fill (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2D.html:4906,Perform,Performs,4906,doc/master/classTProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProfile2D.html,1,['Perform'],['Performs']
Performance,"t char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Private Member Functions; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void initialize ();  . Private Attributes; std::unique_ptr< RooProdPdf::CacheElem > _cache;  ; RooArgSet _normSet;  ; std::unique_ptr< RooProdPdf > _prodPdf;  ; RooSetProxy _servers;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFixedProdPdf.html:55578,Cache,CacheElem,55578,doc/master/classRooFixedProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooFixedProdPdf.html,1,['Cache'],['CacheElem']
Performance,"t char *optStr);  Internal function for parallel dataset verification used TProof::VerifyDataSet and TProofLite::VerifyDataSet. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Static Protected Member Functions; static Int_t AssertDataSet (TDSet *dset, TList *input, TDataSetManager *mgr, TString &emsg);  Make sure that dataset is in the form to be processed. ;  ; static void AssertMacroPath (const char *macro);  Make sure that the directory path contained by macro is in the macro path. ;  ; static Bool_t GetFileInCmd (const char *cmd, TString &fn);  Static method to extract the filename (if any) form a CINT command. ;  ; static Int_t GetInputData (TList *input, const char *cachedir, TString &emsg);  Get the input data from the file defined in the input list. ;  ; static Int_t SaveInputData (TQueryResult *qr, const char *cachedir, TString &emsg);  Save input data file from 'cachedir' into the sandbox or create a the file with input data objects. ;  ; static Int_t SendInputData (TQueryResult *qr, TProof *p, TString &emsg);  Send the input data file to the workers. ;  ; static void * SlaveStartupThread (void *arg);  ; static void SystemCmd (const char *cmd, Int_t fdout);  Exec system command 'cmd'. If fdout > -1, append the output to fdout. ;  ;  Static Protected Member Functions inherited from TQObject; static Int_t CheckConnectArgs (TQObject *sender, TClass *sender_class, const char *signal, TClass *receiver_class, const char *slot);  Checking of consistency of sender/receiver methods/arguments. ;  ; static TString CompressName (const char *method_name);  Removes ""const"" words and blanks from full (with prototype) method name and resolve any typedefs in the method sign",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:40951,cache,cachedir,40951,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['cache'],['cachedir']
Performance,"t char *path) : TNamed(path, """"); 93{; 94 if (!path[0]) {; 95 Error(""ctor"", ""path not valid"");; 96 return;; 97 }; 98 fLevel = 0;; 99 fMatrices = new TObjArray(30);; 100 fNodes = new TObjArray(30);; 101 fMatrixOrig = nullptr;; 102 SetPath(path);; 103 SetVisibility(kTRUE);; 104 SetVisibleFull(kFALSE);; 105 SetIsVolAtt(kTRUE);; 106 SetAligned(kFALSE);; 107}; 108 ; 109////////////////////////////////////////////////////////////////////////////////; 110/// Destructor; 111 ; 112TGeoPhysicalNode::~TGeoPhysicalNode(); 113{; 114 if (fMatrices) {; 115 fMatrices->Delete();; 116 delete fMatrices;; 117 }; 118 if (fNodes); 119 delete fNodes;; 120 if (fMatrixOrig); 121 delete fMatrixOrig;; 122}; 123 ; 124////////////////////////////////////////////////////////////////////////////////; 125/// Align a physical node with a new relative matrix/shape.; 126/// Example: /TOP_1/A_1/B_1/C_1; 127/// node->Align(transl_1, box) will perform:; 128/// - change RELATIVE translation of C_1 node (with respect to its; 129/// container volume B) to transl_1; 130/// - change the shape of the C volume; 131/// *NOTE* The operations will affect ONLY the LAST node in the branch. All; 132/// volumes/nodes in the branch represented by this physical node are; 133/// CLONED so the operation does not affect other possible replicas.; 134 ; 135Bool_t TGeoPhysicalNode::Align(TGeoMatrix *newmat, TGeoShape *newshape, Bool_t check, Double_t ovlp); 136{; 137 if (!newmat && !newshape); 138 return kFALSE;; 139 if (TGeoManager::IsLocked()) {; 140 Error(""Align"", ""Not performed. Geometry in LOCKED mode !"");; 141 return kFALSE;; 142 }; 143 if (newmat == gGeoIdentity) {; 144 Error(""Align"", ""Cannot align using gGeoIdentity. Use some default matrix constructor to represent identities."");; 145 return kFALSE;; 146 }; 147 TGeoNode *node = GetNode();; 148 if (node->IsOffset()) {; 149 Error(""Align"", ""Cannot align division nodes: %s\n"", node->GetName());; 150 return kFALSE;; 151 }; 152 // Refresh the node since other Align calls ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:4260,perform,perform,4260,doc/master/TGeoPhysicalNode_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html,1,['perform'],['perform']
Performance,"t char *title, Int_t nbinsx, const Float_t *xbins, Int_t nbinsy, const Float_t *ybins);  Constructor for variable bin size (along X and Y axis) 2-D histograms using input arrays of type float. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, const Double_t *ybins);  Constructor for Double_t variable bin size (along Y axis) 2-D histograms. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup);  Constructor for fix bin size 2-D histograms. ;  ; virtual Int_t BufferFill (Double_t x, Double_t y, Double_t w);  accumulate arguments in buffer. ;  ; Int_t BufferFill (Double_t, Double_t) override;  accumulate arguments in buffer. ;  ; virtual void DoFitSlices (bool onX, TF1 *f1, Int_t firstbin, Int_t lastbin, Int_t cut, Option_t *option, TObjArray *arr);  ; virtual TProfile * DoProfile (bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) const;  ; virtual TH1D * DoProjection (bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) const;  Internal (protected) method for performing projection on the X or Y axis called by ProjectionX or ProjectionY. ;  ; virtual TH1D * DoQuantiles (bool onX, const char *name, Double_t prob) const;  Implementation of quantiles for x or y. ;  ; Int_t Fill (const char *, Double_t) override;  Increment bin with namex with a weight w. ;  ; Int_t Fill (Double_t) override;  Invalid Fill method. ;  ; Double_t Interpolate (Double_t x) const override;  illegal for a TH2 ;  ;  Protected Member Functions inherited from TH1;  TH1 ();  Histogram default constructor. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins);  Constructor for variable bin size histograms using an input array of type double. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins);  Constructor for variable bin size histograms using an input arr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:47407,perform,performing,47407,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,7,['perform'],['performing']
Performance,"t char *title, Int_t nbinsx, const Float_t *xbins, Int_t nbinsy, const Float_t *ybins);  Constructor for variable bin size (along X and Y axis) 2-D histograms using input arrays of type float. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, const Double_t *ybins);  Constructor for Double_t variable bin size (along Y axis) 2-D histograms. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup);  Constructor for fix bin size 2-D histograms. ;  ; virtual Int_t BufferFill (Double_t x, Double_t y, Double_t w);  accumulate arguments in buffer. ;  ; Int_t BufferFill (Double_t, Double_t) override;  accumulate arguments in buffer. ;  ; virtual void DoFitSlices (bool onX, TF1 *f1, Int_t firstbin, Int_t lastbin, Int_t cut, Option_t *option, TObjArray *arr);  ; virtual TProfile * DoProfile (bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) const;  ; virtual TH1D * DoProjection (bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) const;  Internal (protected) method for performing projection on the X or Y axis called by ProjectionX or ProjectionY. ;  ; virtual TH1D * DoQuantiles (bool onX, const char *name, Double_t prob) const;  Implementation of quantiles for x or y. ;  ;  Protected Member Functions inherited from TH1;  TH1 ();  Histogram default constructor. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins);  Constructor for variable bin size histograms using an input array of type double. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins);  Constructor for variable bin size histograms using an input array of type float. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup);  Constructor for fix bin size histograms. ;  ; virtual Int_t AutoP2FindLimits (Double_t min, Double_t max);  Buffer-b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2Poly.html:56128,perform,performing,56128,doc/master/classTH2Poly.html,https://root.cern,https://root.cern/doc/master/classTH2Poly.html,2,['perform'],['performing']
Performance,"t char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; bool checkSyntax (const char *arg);  Perform basic syntax on given factory expression. ;  ; void clearError ();  Associated workspace. ;  ; Int_t errorCount ();  ; std::string processAliasExpression (const char *arg);  Parse token. ;  ; std::string processCompositeExpression (const char *arg);  Process a single composite expression. ;  ; std::string processCreateArg (std::string &func, std::vector< std::string > &args);  Glue function between high-level syntax and low-level factory call to createArg: Process a parsed call to create a pdf named func ;  ; std::string processCreateVar (std::string &func, std::vector< std::string > &args);  Glue function between high-level syntax and low-level factory call to createVariable: Process a parsed call to create a variable named func ;  ; std::string processListExpression (const char *arg);  Process a list of high-level expression. ;  ; std::string processMetaArg (std::string &func, std::vector< std::string > &args);  Concatenate list of args into comma separated string. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFactoryWSTool.html:17757,Perform,Perform,17757,doc/master/classRooFactoryWSTool.html,https://root.cern,https://root.cern/doc/master/classRooFactoryWSTool.html,1,['Perform'],['Perform']
Performance,"t char * GetTypeName () const override;  Returns name of leaf type. ;  ; Double_t GetValue (Int_t i=0) const override;  Returns current value of leaf. ;  ; Long64_t GetValueLong64 (Int_t i=0) const override;  ; LongDouble_t GetValueLongDouble (Int_t i=0) const override;  Returns current value of leaf. ;  ; void * GetValuePointer () const override;  ; void Import (TClonesArray *list, Int_t n) override;  Import element from ClonesArray into local leaf buffer. ;  ; bool IncludeRange (TLeaf *) override;  Copy/set fMinimum and fMaximum to include/be wide than those of the parameter. ;  ; TClass * IsA () const override;  ; void PrintValue (Int_t i=0) const override;  Prints leaf value. ;  ; void ReadBasket (TBuffer &b) override;  Read leaf elements from Basket input buffer. ;  ; void ReadBasketExport (TBuffer &b, TClonesArray *list, Int_t n) override;  Read leaf elements from Basket input buffer and export buffer to TClonesArray objects. ;  ; bool ReadBasketFast (TBuffer &, Long64_t) override;  Deserialize input by performing byteswap as needed. ;  ; void ReadValue (std::istream &s, Char_t delim=' ') override;  Read a long integer from std::istream s and store it into the branch buffer. ;  ; void SetAddress (void *add=nullptr) override;  Set leaf buffer data address. ;  ; virtual void SetMaximum (Long64_t max);  ; virtual void SetMinimum (Long64_t min);  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TLeaf;  TLeaf ();  ;  TLeaf (TBranch *parent, const char *name, const char *type);  Create a Leaf. ;  ;  ~TLeaf () override;  Destructor. ;  ; void Browse (TBrowser *b) override;  Browse the content of this leaf. ;  ; virtual bool CanGenerateOffsetArray ();  ; virtual Int_t * GenerateOffsetArray (Int_t base, Int_t events);  ; TBranch * GetBranch () const;  ; virtual TString GetFullName () const;  Return the full name (including the parent's branch names",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafL.html:1947,perform,performing,1947,doc/master/classTLeafL.html,https://root.cern,https://root.cern/doc/master/classTLeafL.html,1,['perform'],['performing']
Performance,"t char * GetTypeName () const override;  Returns name of leaf type. ;  ; Double_t GetValue (Int_t i=0) const override;  Returns current value of leaf. ;  ; Long64_t GetValueLong64 (Int_t i=0) const override;  ; LongDouble_t GetValueLongDouble (Int_t i=0) const override;  Returns current value of leaf. ;  ; void * GetValuePointer () const override;  ; void Import (TClonesArray *list, Int_t n) override;  Import element from ClonesArray into local leaf buffer. ;  ; bool IncludeRange (TLeaf *) override;  Copy/set fMinimum and fMaximum to include/be wide than those of the parameter. ;  ; TClass * IsA () const override;  ; void PrintValue (Int_t i=0) const override;  Prints leaf value. ;  ; void ReadBasket (TBuffer &b) override;  Read leaf elements from Basket input buffer. ;  ; void ReadBasketExport (TBuffer &b, TClonesArray *list, Int_t n) override;  Read leaf elements from Basket input buffer and export buffer to TClonesArray objects. ;  ; bool ReadBasketFast (TBuffer &, Long64_t) override;  Deserialize input by performing byteswap as needed. ;  ; void ReadValue (std::istream &s, Char_t delim=' ') override;  Read a long integer from std::istream s and store it into the branch buffer. ;  ; void SetAddress (void *add=nullptr) override;  Set leaf buffer data address. ;  ; virtual void SetMaximum (Long_t max);  ; virtual void SetMinimum (Long_t min);  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TLeaf;  TLeaf ();  ;  TLeaf (TBranch *parent, const char *name, const char *type);  Create a Leaf. ;  ;  ~TLeaf () override;  Destructor. ;  ; void Browse (TBrowser *b) override;  Browse the content of this leaf. ;  ; virtual bool CanGenerateOffsetArray ();  ; virtual Int_t * GenerateOffsetArray (Int_t base, Int_t events);  ; TBranch * GetBranch () const;  ; virtual TString GetFullName () const;  Return the full name (including the parent's branch names) of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafG.html:1947,perform,performing,1947,doc/master/classTLeafG.html,https://root.cern,https://root.cern/doc/master/classTLeafG.html,1,['perform'],['performing']
Performance,"t char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeRooAbsCategory::evaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); virtual voidsetIndexFast(Int_t index); Bool_tsetOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCategoryLValue.html:18617,optimiz,optimizeDirtyHook,18617,root/html532/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html532/RooAbsCategoryLValue.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"t char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const RooFormulaVar& select, const char* wgtVarName = 0); RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0); RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t, const char* wgtVarName = 0); virtual~RooTreeDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeDataStore.html:2155,cache,cachedVars,2155,root/html526/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html526/RooTreeDataStore.html,3,['cache'],['cachedVars']
Performance,"t char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); Int_tEnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tEnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tEnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tExec(const char* cmd, Bool_t plusMaster = kFALSE); Int_tExec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tFinalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tFinalize(const char* queryref, Bool_t force = kFALSE); TList*FindDataSets(const char* searchString, const char* optStr = """"",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:5625,load,loadopts,5625,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,2,['load'],['loadopts']
Performance,"t char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add a new column to the data set which holds the pre-calculated values; of 'newVar'. This operation is only meaningful if 'newVar' is a derived; value. The return value points to the added element holding 'newVar's value; in the data collection. The element is always the corresponding fundamental; type of 'newVar' (e.g. a RooRealVar if 'newVar' is a RooForm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooTreeDataStore.html:14301,Load,Load,14301,root/html528/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html528/RooTreeDataStore.html,6,['Load'],['Load']
Performance,"t char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); Int_tCreateSymLinks(TList* files); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); TProofQueryResult*MakeQueryResult(Long64_t nent, const char* opt, Long64_t fst, TDSet* dset, const char* selec); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); voidTProof::SetDSet(TDSet* dset); voidTProof::SetPlayer(TVirtualProofPlayer* player); voidSetQueryRunning(TProofQueryResult* pq); Int_tSetupWorkers(Int_t opt = 0, TList* wrks = 0); static void*TProof::SlaveStartupThread(void* arg); virtual Bool_tTProof::StartSlaves(Bool_t attach = kFALSE); static voidTProof::SystemCmd(const char* cmd, Int_t fdout); voidTProof::UpdateDialog(); virtual voidTProof::ValidateDSet(TDSet* dset).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:20223,cache,cachedir,20223,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,1,['cache'],['cachedir']
Performance,"t class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxiliary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integration ;  CIntegratorMultiDimOptionsNumerical multi dimensional integration options ;  CIntegratorOneDimUser Class for performing numerical integration of a function in one dimension ;  CIntegratorOneDimOptionsNumerical one dimensional integration options ;  CInterpolatorClass for performing function interpolation of points ;  CInverterMatrix Inverter class Class to specialize calls to Dinv ;  CInverter< 0 >Inverter<0> ;  CInverter< 1 >1x1 matrix inversion \(a_{11} \to 1/a_{11}\) ;  CInverter< 2 >2x2 matrix inversion using Cramers rule ;  CIOptionsGeneric interface for defining configuration options of a numerical algorithm ;  CIParametricFunctionMultiDimIParamFunction interface (abstract class) describing multi-dimensional parameteric functions It is a derived class from ROOT::Math::IBaseFunctionMultiDim and ROOT::Math::IBaseParam ;  CIParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is a derived class from ROOT::Math::IBaseFunctionOneDim and ROOT::Math::IBaseParam ;  CIParametricGradFunctionMultiDimInterface (abstract class) for parametric gradient multi-dimensional functions providing in addition to function evaluation with respect to the coordinates also the gradient with respect to the param",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:37976,perform,performing,37976,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['perform'],['performing']
Performance,"t class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxiliary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integration ;  CIntegratorMultiDimOptionsNumerical multi dimensional integration options ;  CIntegratorOneDimUser Class for performing numerical integration of a function in one dimension ;  CIntegratorOneDimOptionsNumerical one dimensional integration options ;  CInterpolatorClass for performing function interpolation of points ;  CInverterMatrix Inverter class Class to specialize calls to Dinv ;  CInverter< 0 >Inverter<0> ;  CInverter< 1 >1x1 matrix inversion \(a_{11} \to 1/a_{11}\) ;  CInverter< 2 >2x2 matrix inversion using Cramers rule ;  CIOptionsGeneric interface for defining configuration options of a numerical algorithm ;  CIParametricFunctionMultiDimTemplIParamFunction interface (abstract class) describing multi-dimensional parameteric functions It is a derived class from ROOT::Math::IBaseFunctionMultiDim and ROOT::Math::IBaseParam ;  CIParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is a derived class from ROOT::Math::IBaseFunctionOneDim and ROOT::Math::IBaseParam ;  CIParametricGradFunctionMultiDimTemplInterface (abstract class) for parametric gradient multi-dimensional functions providing in addition to function evaluation with respect to the coordinates also the gradient with respect to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:39318,perform,performing,39318,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['perform'],['performing']
Performance,"t class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxillary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integration ;  CIntegratorMultiDimOptionsNumerical multi dimensional integration options ;  CIntegratorOneDimUser Class for performing numerical integration of a function in one dimension ;  CIntegratorOneDimOptionsNumerical one dimensional integration options ;  CInterpolatorClass for performing function interpolation of points ;  CInverterMatrix Inverter class Class to specialize calls to Dinv ;  CInverter< 0 >Inverter<0> ;  CInverter< 1 >1x1 matrix inversion \(a_{11} \to 1/a_{11}\) ;  CInverter< 2 >2x2 matrix inversion using Cramers rule ;  CIOptionsGeneric interface for defining configuration options of a numerical algorithm ;  CIParametricFunctionMultiDimIParamFunction interface (abstract class) describing multi-dimensional parameteric functions It is a derived class from ROOT::Math::IBaseFunctionMultiDim and ROOT::Math::IBaseParam ;  CIParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is a derived class from ROOT::Math::IBaseFunctionOneDim and ROOT::Math::IBaseParam ;  CIParametricGradFunctionMultiDimInterface (abstract class) for parametric gradient multi-dimensional functions providing in addition to function evaluation with respect to the coordinates also the gradient with respect to the param",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:33908,perform,performing,33908,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['perform'],['performing']
Performance,"t cling::Transaction&);; 93 TObject* TCling__GetObjectAddress(const char *Name, void *&LookupCtx);; 94 const clang::Decl* TCling__GetObjectDecl(TObject *obj);; 95 void TCling__LibraryLoaded(const void* dyLibHandle,; 96 const char* canonicalName);; 97 void TCling__LibraryUnloaded(const void* dyLibHandle,; 98 const char* canonicalName);; 99 void TCling__RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent);; 100}; 101 ; 102class TCling final : public TInterpreter {; 103private: // Static Data Members; 104 ; 105 static void* fgSetOfSpecials; // set of TObjects used in CINT variables; 106 ; 107private: // Data Members; 108 ; 109 Int_t fExitCode; // Value passed to exit() in interpreter.; 110 char fPrompt[64]; // Command line prompt string.; 111 //cling::DictPosition fDictPos; // dictionary context after initialization is complete.; 112 //cling::DictPosition fDictPosGlobals; // dictionary context after ResetGlobals().; 113 TString fSharedLibs; // Shared libraries loaded by G__loadfile().; 114 Int_t fGlobalsListSerial;// Last time we refreshed the ROOT list of globals.; 115 TString fIncludePath; // Interpreter include path.; 116 TString fRootmapLoadPath; // Dynamic load path for rootmap files.; 117 TEnv* fMapfile; // Association of classes to libraries.; 118 std::vector<std::string> fAutoLoadLibStorage; // A storage to return a const char* from GetClassSharedLibsForModule.; 119 std::map<size_t,std::vector<const char*>> fClassesHeadersMap; // Map of classes hashes and headers associated; 120 std::map<const cling::Transaction*,size_t> fTransactionHeadersMap; // Map which transaction contains which autoparse.; 121 std::set<size_t> fLookedUpClasses; // Set of classes for which headers were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unord",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:3482,load,loaded,3482,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['load'],['loaded']
Performance,"t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; static voidblockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiVarGaussian.html:2071,cache,cacheUniqueSuffix,2071,root/html602/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html602/RooMultiVarGaussian.html,2,['cache'],['cacheUniqueSuffix']
Performance,"t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; const RooFormulaVar&RooResolutionModel::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGExpModel.html:2898,cache,cacheUniqueSuffix,2898,root/html532/RooGExpModel.html,https://root.cern,https://root.cern/root/html532/RooGExpModel.html,2,['cache'],['cacheUniqueSuffix']
Performance,"t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; const RooFormulaVar&RooResolutionModel::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGExpModel.html:2898,cache,cacheUniqueSuffix,2898,root/html528/RooGExpModel.html,https://root.cern,https://root.cern/root/html528/RooGExpModel.html,4,['cache'],['cacheUniqueSuffix']
Performance,"t containing the TDataMembers of a class. ; Definition at line 3770 of file TClass.cxx. ◆ GetListOfEnums(). TList * TClass::GetListOfEnums ; (; Bool_t ; requestListLoading = kTRUE). Return a list containing the TEnums of a class. ; The list returned is safe to use from multiple thread without explicitly taking the ROOT global lock.; In the case the TClass represents a namespace, the returned list will implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); In the case the TClass represents a class or struct and requestListLoading is true, the list is immutable (and thus safe to access from multiple thread without taking the global lock at all).; In the case the TClass represents a class or struct and requestListLoading is false, the list is mutable and thus we return a TListOfEnumsWithLock which will implicit take the ROOT global lock upon any access. ; Definition at line 3686 of file TClass.cxx. ◆ GetListOfFunctionTemplates(). TList * TClass::GetListOfFunctionTemplates ; (; Bool_t ; load = kTRUE). Return TListOfFunctionTemplates for a class. ; Definition at line 3798 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 3827 of file TClass.cxx. ◆ GetListOfMethods(). TList * TClass::GetListOfMethods ; (; Bool_t ; load = kTRUE). Return list containing the TMethods of a class. ; If load is true, the list is populated with all the defined function and currently instantiated function template. ; Definition at line 3812 of file TClass.cxx. ◆ GetListOfRealData(). TList * TClass::GetListOfRealData ; (; ); const. inline . Definition at line 453 of file TClass.h. ◆ GetListOfUsingDataMembers(). TList * TClass::GetListOfUsingDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of using declarations of a class. ; Definition at line 3786 of file TClass.cxx. ◆ GetMenuItems(). void TCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:83211,load,load,83211,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['load']
Performance,"t containing the TDataMembers of a class. ; Definition at line 3837 of file TClass.cxx. ◆ GetListOfEnums(). TList * TClass::GetListOfEnums ; (; Bool_t ; requestListLoading = kTRUE). Return a list containing the TEnums of a class. ; The list returned is safe to use from multiple thread without explicitly taking the ROOT global lock.; In the case the TClass represents a namespace, the returned list will implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); In the case the TClass represents a class or struct and requestListLoading is true, the list is immutable (and thus safe to access from multiple thread without taking the global lock at all).; In the case the TClass represents a class or struct and requestListLoading is false, the list is mutable and thus we return a TListOfEnumsWithLock which will implicit take the ROOT global lock upon any access. ; Definition at line 3753 of file TClass.cxx. ◆ GetListOfFunctionTemplates(). TList * TClass::GetListOfFunctionTemplates ; (; Bool_t ; load = kTRUE). Return TListOfFunctionTemplates for a class. ; Definition at line 3865 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 3894 of file TClass.cxx. ◆ GetListOfMethods(). TList * TClass::GetListOfMethods ; (; Bool_t ; load = kTRUE). Return list containing the TMethods of a class. ; If load is true, the list is populated with all the defined function and currently instantiated function template. ; Definition at line 3879 of file TClass.cxx. ◆ GetListOfRealData(). TList * TClass::GetListOfRealData ; (; ); const. inline . Definition at line 453 of file TClass.h. ◆ GetListOfUsingDataMembers(). TList * TClass::GetListOfUsingDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of using declarations of a class. ; Definition at line 3853 of file TClass.cxx. ◆ GetMenuItems(). void TCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:83212,load,load,83212,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['load']
Performance,"t copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsData*_dataPointer to original input dataset; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry! carry of Kahan sum in evaluatePartition; Int_t_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*_funcPointer to original input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpMode_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsTestStatistic.html:37079,cache,cache,37079,root/html602/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsTestStatistic.html,2,['cache'],['cache']
Performance,"t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TKey*TDirectory::FindKey(const char*) const; virtual TKey*TDirectory::FindKeyAny(const char*) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*TDirectory::FindObjectAnyFile(const char*) const; const char*FindObjectClassName(const char* name) const; const char*FindObjectPathName(const TObject* obj) const; TObject*FindSpecialObject(const char* name, void*& where); TClass*FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; voidForceStyle(Bool_t force = kTRUE); Bool_tFromPopUp() const; virtual TObject*TDirectory::Get(const char* namecycle); TApplication*GetApplication() const; virtual Int_tTDirectory::GetBufferSize() const; Int_tGetBuiltDate() const; Int_tGetBuiltTime() const; TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:4565,load,load,4565,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['load'],['load']
Performance,"t data file and signal and background trees; ; inputFileName = ""Higgs_data.root""; inputFileLink = ""http://root.cern.ch/files/"" + inputFileName; ; ; if ROOT.gSystem.AccessPathName(inputFileName):; ROOT.Info(""TMVA_Higgs_Classification"", ""Download Higgs_data.root file""); TFile.SetCacheFileDir("".""); inputFile = TFile.Open(inputFileLink, ""CACHEREAD""); if inputFile is None:; raise FileNotFoundError(""Input file cannot be downloaded - exit""); else:; # file exists; inputFile = TFile.Open(inputFileName); ; ; # --- Register the training and test trees; signalTree = inputFile.Get(""sig_tree""); backgroundTree = inputFile.Get(""bkg_tree""); signalTree.Print(); ; ## Declare DataLoader(s); ; # The next step is to declare the DataLoader class that deals with input variables; # Define the input variables that shall be used for the MVA training; # note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; loader = TMVA.DataLoader(""dataset""); ; loader.AddVariable(""m_jj""); loader.AddVariable(""m_jjj""); loader.AddVariable(""m_lv""); loader.AddVariable(""m_jlv""); loader.AddVariable(""m_bb""); loader.AddVariable(""m_wbb""); loader.AddVariable(""m_wwbb""); ; # We set now the input data trees in the TMVA DataLoader class; # global event weights per tree (see below for setting event-wise weights); signalWeight = 1.0; backgroundWeight = 1.0; # You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight); loader.AddBackgroundTree(backgroundTree, backgroundWeight); ; # Set individual event weights (the variables must exist in the original TTree); # for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; # for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; # loader->SetBackgroundWeightExpression( ""weight"" );; ; ; # Apply additional cuts on the signal and background samples (can be different); mycuts = ROOT.TCut("""") # for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:59368,load,loader,59368,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['load'],['loader']
Performance,t destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; void fillCacheObject (FuncCacheElem &cacheFunc) const override;  Fill cache using running integral cache elements calculate() method with specification of cdf-specific boundary conditions. ;  ;  Protected Member Functions inherited from RooNumRunningInt; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  Return observable in nset to be cached by RooAbsCachedPdf this is always the x observable that is integrated. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  Return the parameters of the cache created by RooAbsCachedPdf. ;  ; const char * binningName () const override;  ; FuncCacheElem * createCache (const RooArgSet *nset) const override;  Create custom cache element for running integral calculations. ;  ; double evaluate () const override;  Dummy function that is never called. ;  ; void fillCacheObject (FuncCacheElem &cacheFunc) const override;  Fill the cache object by calling its calculate() method. ;  ; const char * inputBaseName () const override;  Return unique name for RooAbsCachedPdf cache components constructed from input function name. ;  ; const char * payloadUniqueSuffix () const override;  ;  Protected Member Functions inherited from RooAbsCachedReal; TString cacheNameSuffix (const RooArgSet &nset) const,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumCdf.html:50064,cache,cached,50064,doc/master/classRooNumCdf.html,https://root.cern,https://root.cern/doc/master/classRooNumCdf.html,1,['cache'],['cached']
Performance,"t editor destructor. ;  ; void CloseWindow () override;  Close fit panel window. ;  ; virtual void ConnectSlots ();  Connect GUI signals to fit panel slots. ;  ; virtual void DisconnectSlots ();  Disconnect GUI signals from fit panel slots. ;  ; virtual void DoAddition (Bool_t on);  Slot connected to addition of predefined functions. ;  ; virtual void DoAdvancedOptions ();  Slot connected to advanced option button (opens a dialog). ;  ; virtual void DoAllWeights1 ();  Slot connected to 'set all weights to 1' setting. ;  ; virtual void DoClose ();  Close the fit panel. ;  ; virtual void DoConvolution (Bool_t on);  Slot connected to addition of predefined functions. ;  ; virtual void DoDataSet (Int_t sel);  Selects the data set to be fitted. ;  ; virtual void DoEmptyBinsAllWeights1 ();  Slot connected to 'include emtry bins and forse all weights to 1' setting. ;  ; virtual void DoEnteredFunction ();  Slot connected to entered function in text entry. ;  ; virtual void DoFit ();  Perform a fit with current parameters' settings. ;  ; virtual void DoFunction (Int_t sel);  Slot connected to predefined fit function settings. ;  ; virtual void DoLibrary (Bool_t on);  Set selected minimization library in use. ;  ; virtual void DoLinearFit ();  Slot connected to linear fit settings. ;  ; virtual void DoMaxIterations ();  Set the maximum number of iterations. ;  ; virtual void DoMinMethod (Int_t);  Set selected minimization method in use. ;  ; virtual void DoNoChi2 ();  Slot connected to 'no chi2' option settings. ;  ; virtual void DoNormAddition (Bool_t on);  Slot connected to addition of predefined functions. ;  ; virtual void DoNoSelection ();  Slot called when users close a TCanvas or when the user select no object. ;  ; virtual void DoNoStoreDrawing ();  Slot connected to 'no storing, no drawing' settings. ;  ; virtual void DoNumericSliderXChanged ();  Sincronize the numeric sliders with the graphical one. ;  ; virtual void DoNumericSliderYChanged ();  syncronize the numer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFitEditor.html:6916,Perform,Perform,6916,doc/master/classTFitEditor.html,https://root.cern,https://root.cern/doc/master/classTFitEditor.html,1,['Perform'],['Perform']
Performance,"t empty cell or AddLast if there is no empty cell ; Reimplemented from TObjArray.; Definition at line 60 of file TClonesArray.h. ◆ AddBefore(). void TClonesArray::AddBefore ; (; const TObject * ; , . TObject * ;  . ). inlineoverridevirtual . Implements TSeqCollection.; Definition at line 62 of file TClonesArray.h. ◆ AddFirst(). void TClonesArray::AddFirst ; (; TObject * ; ). inlineoverridevirtual . Implements TSeqCollection.; Definition at line 56 of file TClonesArray.h. ◆ AddLast(). void TClonesArray::AddLast ; (; TObject * ; ). inlineoverridevirtual . Implements TSeqCollection.; Definition at line 57 of file TClonesArray.h. ◆ AddrAt(). TObject * TClonesArray::AddrAt ; (; Int_t ; idx). inline . Definition at line 86 of file TClonesArray.h. ◆ BypassStreamer(). void TClonesArray::BypassStreamer ; (; Bool_t ; bypass = kTRUE). When the kBypassStreamer bit is set, the automatically generated Streamer can call directly TClass::WriteBuffer. ; Bypassing the Streamer improves the performance when writing/reading the objects in the TClonesArray. However there is a drawback: When a TClonesArray is written with split=0 bypassing the Streamer, the StreamerInfo of the class in the array being optimized, one cannot use later the TClonesArray with split>0. For example, there is a problem with the following scenario:; A class Foo has a TClonesArray of Bar objects; The Foo object is written with split=0 to Tree T1. In this case the StreamerInfo for the class Bar is created in optimized mode in such a way that data members of the same type are written as an array improving the I/O performance.; In a new program, T1 is read and a new Tree T2 is created with the object Foo in split>1; When the T2 branch is created, the StreamerInfo for the class Bar is created with no optimization (mandatory for the split mode). The optimized Bar StreamerInfo is going to be used to read the TClonesArray in T1. The result will be Bar objects with data member values not in the right sequence. The solutio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:31207,perform,performance,31207,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['perform'],['performance']
Performance,"t exist . kEntryNotFound the tree entry number does not exist . kEntryChainSetupError problem in accessing a chain element, e.g. file without the tree . kEntryChainFileError problem in opening a chain's file . kEntryDictionaryError problem reading dictionary info from tree . kEntryBeyondEnd last entry loop has reached its end . kEntryBadReader One of the readers was not successfully initialized. . kIndexedFriendNoMatch A friend with TTreeIndex doesn't have an entry for this index. . kMissingBranchWhenSwitchingTree A branch was not found when switching to the next TTree in the chain. . kEntryUnknownError LoadTree return less than -6, likely a 'newer' error code. . Definition at line 152 of file TTreeReader.h. ◆ ELoadTreeStatus. enum TTreeReader::ELoadTreeStatus. EnumeratorkNoTree default state, no TTree is connected (formerly 'Zombie' state) . kLoadTreeNone Notify has not been called yet. . kInternalLoadTree Notify/LoadTree was last called from SetEntryBase. . kExternalLoadTree User code called LoadTree directly. . kMissingBranchFromTree Missing expected branch when loading new tree. . Definition at line 167 of file TTreeReader.h. ◆ EStatusBits. enum TTreeReader::EStatusBits. private . EnumeratorkBitIsChain our tree is a chain . kBitHaveWarnedAboutEntryListAttachedToTTree the tree had a TEntryList and we have warned about that . kBitSetEntryBaseCallingLoadTree SetEntryBase is in the process of calling TChain/TTree::LoadTree. . kBitIsExternalTree we do not own the tree . Definition at line 311 of file TTreeReader.h. Constructor & Destructor Documentation. ◆ TTreeReader() [1/4]. TTreeReader::TTreeReader ; (; ). Default constructor. Call SetTree to connect to a TTree. ; Definition at line 191 of file TTreeReader.cxx. ◆ TTreeReader() [2/4]. TTreeReader::TTreeReader ; (; TTree * ; tree, . TEntryList * ; entryList = nullptr, . bool ; warnAboutLongerFriends = true, . const std::vector< std::string > & ; suppressErrorsForMissingBranches = {} . ). Access data from tree. ; Par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:23316,Load,LoadTree,23316,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,1,['Load'],['LoadTree']
Performance,"t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAddPdf::CacheElem*getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddPdf.html:35751,optimiz,optimizeDirtyHook,35751,root/html532/RooAddPdf.html,https://root.cern,https://root.cern/root/html532/RooAddPdf.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; const RooAbsReal*getProjection(const RooArgSet* iset, const RooArgSet* nset, const char* rangeName, int& code) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProjectedPdf.html:34934,optimiz,optimizeDirtyHook,34934,root/html532/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html532/RooProjectedPdf.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"t fExecutingMacroTrue while executing a TMacro.Definition TROOT.h:136; TROOT::GetListOfBrowsablesTList * GetListOfBrowsables() constDefinition TROOT.h:258; TROOT::fBuiltDateInt_t fBuiltDateDate of ROOT built.Definition TROOT.h:118; TROOT::fIsWebDisplayBatchBool_t fIsWebDisplayBatchTrue if web widgets are not displayed.Definition TROOT.h:129; TROOT::GetSharedLibDirstatic const TString & GetSharedLibDir()Get the shared libraries directory in the installation. Static utility function.Definition TROOT.cxx:3031; TROOT::SetEscapevoid SetEscape(Bool_t flag=kTRUE)Definition TROOT.h:327; TROOT::GetVersionCodeInt_t GetVersionCode() constDefinition TROOT.h:229; TROOT::fMappedFilesTSeqCollection * fMappedFilesList of memory mapped files.Definition TROOT.h:147; TROOT::GetNtypesInt_t GetNtypes() constGet number of types.Definition TROOT.cxx:1884; TROOT::GetListOfSpecialsTSeqCollection * GetListOfSpecials() constDefinition TROOT.h:246; TROOT::LoadMacroInt_t LoadMacro(const char *filename, Int_t *error=nullptr, Bool_t check=kFALSE)Load a macro in the interpreter's memory.Definition TROOT.cxx:2268; TROOT::GetFileTFile * GetFile() const overrideDefinition TROOT.h:260; TROOT::GetLibDirstatic const TString & GetLibDir()Get the library directory in the installation. Static utility function.Definition TROOT.cxx:3010; TROOT::SetDefCanvasNamevoid SetDefCanvasName(const char *name=""c1"")Definition TROOT.h:321; TROOT::fBrowsersTSeqCollection * fBrowsersList of browsers.Definition TROOT.h:155; TROOT::fDefCanvasNameTString fDefCanvasNameName of default canvas.Definition TROOT.h:171; TROOT::fGlobalFunctionsTListOfFunctions * fGlobalFunctionsList of global functions.Definition TROOT.h:144; TROOT::fBrowsablesTList * fBrowsablesList of browsables.Definition TROOT.h:168; TROOT::FindObjectAnyTObject * FindObjectAny(const char *name) const overrideReturn a pointer to the first object with name starting at //root.Definition TROOT.cxx:1426; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:48207,Load,LoadMacro,48207,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,2,['Load'],"['Load', 'LoadMacro']"
Performance,"t fExecutingMacroTrue while executing a TMacro.Definition TROOT.h:136; TROOT::GetListOfBrowsablesTList * GetListOfBrowsables() constDefinition TROOT.h:258; TROOT::fBuiltDateInt_t fBuiltDateDate of ROOT built.Definition TROOT.h:118; TROOT::fIsWebDisplayBatchBool_t fIsWebDisplayBatchTrue if web widgets are not displayed.Definition TROOT.h:129; TROOT::GetSharedLibDirstatic const TString & GetSharedLibDir()Get the shared libraries directory in the installation. Static utility function.Definition TROOT.cxx:3035; TROOT::SetEscapevoid SetEscape(Bool_t flag=kTRUE)Definition TROOT.h:327; TROOT::GetVersionCodeInt_t GetVersionCode() constDefinition TROOT.h:229; TROOT::fMappedFilesTSeqCollection * fMappedFilesList of memory mapped files.Definition TROOT.h:147; TROOT::GetNtypesInt_t GetNtypes() constGet number of types.Definition TROOT.cxx:1884; TROOT::GetListOfSpecialsTSeqCollection * GetListOfSpecials() constDefinition TROOT.h:246; TROOT::LoadMacroInt_t LoadMacro(const char *filename, Int_t *error=nullptr, Bool_t check=kFALSE)Load a macro in the interpreter's memory.Definition TROOT.cxx:2268; TROOT::GetFileTFile * GetFile() const overrideDefinition TROOT.h:260; TROOT::GetLibDirstatic const TString & GetLibDir()Get the library directory in the installation. Static utility function.Definition TROOT.cxx:3014; TROOT::SetDefCanvasNamevoid SetDefCanvasName(const char *name=""c1"")Definition TROOT.h:321; TROOT::fBrowsersTSeqCollection * fBrowsersList of browsers.Definition TROOT.h:155; TROOT::fDefCanvasNameTString fDefCanvasNameName of default canvas.Definition TROOT.h:171; TROOT::fGlobalFunctionsTListOfFunctions * fGlobalFunctionsList of global functions.Definition TROOT.h:144; TROOT::fBrowsablesTList * fBrowsablesList of browsables.Definition TROOT.h:168; TROOT::FindObjectAnyTObject * FindObjectAny(const char *name) const overrideReturn a pointer to the first object with name starting at //root.Definition TROOT.cxx:1426; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:48206,Load,LoadMacro,48206,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,2,['Load'],"['Load', 'LoadMacro']"
Performance,"t firstEvent, Int_t lastEvent, Int_t stepSize, Bool_t skipZeroWeights). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. void resetCache(). void setArgStatus(const RooArgSet& set, Bool_t active); Disabling of branches is (intentionally) not implemented in vector; data stores (as the doesn't result in a net saving of time). void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void dump(). void Streamer(TBuffer& ); Stream an object of class RooVectorDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooVectorDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooVectorDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. Double_t sumEntries() const; { return _sumWeight ; }. const RooAbsArg* cacheOwner(); Constant term optimizer interface. { return _cacheOwner ; }. const RooVectorDataStore* cache() const; { return _cache ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). void setDirtyProp(Bool_t flag). const RooArgSet& row(); virtual void checkInit() const;. { return _varsww ; }. RealVector& operator=(const RooVectorDataStore& ). std::vector<RealVector*>& realStoreList(); { return _realStoreList ; }. std::vector<RealFullVector*>& realfStoreList(); { return _realfStoreList ; }. std::vector<CatVector*>& catStoreList(); { return _catStoreList ; }. CatVector* addCategory(RooAbsCategory* cat). RealVector* addReal(RooAbsReal* real). Bool_t isFullReal(RooAbsReal* real). Bool_t hasError(RooAbsReal* real). Bool_t hasAsymError(RooAbsReal* real). RealFullVector* addRealFull(RooAbsReal* real). Bool_t hasFilledCache() const; { return _cache ? kTRUE : kFALSE ; }. » Last changed: Sat Jun 20 16:42:58 2015 » Last generated: 2015-0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooVectorDataStore.html:17047,cache,cacheOwner,17047,root/html534/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html534/RooVectorDataStore.html,2,"['cache', 'optimiz']","['cacheOwner', 'optimizer']"
Performance,"t firstEvent, Int_t lastEvent, Int_t stepSize, Bool_t skipZeroWeights). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. void resetCache(). void setArgStatus(const RooArgSet& set, Bool_t active); Disabling of branches is (intentionally) not implemented in vector; data stores (as the doesn't result in a net saving of time). void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void dump(). void Streamer(TBuffer& ); Stream an object of class RooVectorDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooVectorDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooVectorDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. Double_t sumEntries() const; { return _sumWeight ; }. const RooAbsArg* cacheOwner(); Constant term optimizer interface. { return _cacheOwner ; }. const RooVectorDataStore* cache() const; { return _cache ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). void setDirtyProp(Bool_t flag). const RooArgSet& row(); virtual void checkInit() const;. { return _varsww ; }. RealVector& operator=(const RooVectorDataStore& ). std::vector<RealVector*>& realStoreList(); { return _realStoreList ; }. std::vector<RealFullVector*>& realfStoreList(); { return _realfStoreList ; }. std::vector<CatVector*>& catStoreList(); { return _catStoreList ; }. CatVector* addCategory(RooAbsCategory* cat). RealVector* addReal(RooAbsReal* real). Bool_t isFullReal(RooAbsReal* real). Bool_t hasError(RooAbsReal* real). Bool_t hasAsymError(RooAbsReal* real). RealFullVector* addRealFull(RooAbsReal* real). Bool_t hasFilledCache() const; { return _cache ? kTRUE : kFALSE ; }. » Last changed: Sat Jun 20 17:31:08 2015 » Last generated: 2015-0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooVectorDataStore.html:18172,cache,cacheOwner,18172,root/html604/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html604/RooVectorDataStore.html,2,"['cache', 'optimiz']","['cacheOwner', 'optimizer']"
Performance,"t firstEvent, Int_t lastEvent, Int_t stepSize, Bool_t skipZeroWeights). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. void resetCache(). void setArgStatus(const RooArgSet& set, Bool_t active); Disabling of branches is (intentionally) not implemented in vector; data stores (as the doesn't result in a net saving of time). void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void dump(). void Streamer(TBuffer& ); Stream an object of class RooVectorDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooVectorDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooVectorDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. Double_t sumEntries() const; { return _sumWeight ; }. const RooAbsArg* cacheOwner(); Constant term optimizer interface. { return _cacheOwner ; }. const RooVectorDataStore* cache() const; { return _cache ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). void setDirtyProp(Bool_t flag). const RooArgSet& row(); virtual void checkInit() const;. { return _varsww ; }. RealVector& operator=(const RooVectorDataStore& ). std::vector<RealVector*>& realStoreList(); { return _realStoreList ; }. std::vector<RealFullVector*>& realfStoreList(); { return _realfStoreList ; }. std::vector<CatVector*>& catStoreList(); { return _catStoreList ; }. CatVector* addCategory(RooAbsCategory* cat). RealVector* addReal(RooAbsReal* real). Bool_t isFullReal(RooAbsReal* real). Bool_t hasError(RooAbsReal* real). Bool_t hasAsymError(RooAbsReal* real). RealFullVector* addRealFull(RooAbsReal* real). Bool_t hasFilledCache() const; { return _cache ? kTRUE : kFALSE ; }. » Last changed: Tue Jun 30 14:38:02 2015 » Last generated: 2015-0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooVectorDataStore.html:18172,cache,cacheOwner,18172,root/html602/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html602/RooVectorDataStore.html,2,"['cache', 'optimiz']","['cacheOwner', 'optimizer']"
Performance,"t flag); voidsetAsymError(Double_t lo, Double_t hi); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const char* rangeName = 0); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const RooAbsBinning& binning); virtual voidRooAbsRealLValue::setBinFast(Int_t ibin, const RooAbsBinning& binning); voidsetBinning(const RooAbsBinning& binning, const char* name = 0); voidsetBins(Int_t nBins, const char* name = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidRooAbsRealLValue::setConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidsetError(Double_t value); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetMax(Double_t value); voidsetMax(const char* name, Double_t value); voidsetMin(Double_t value); voidsetMin(const char* name, Double_t value); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetRange(Double_t min, Double_t max); voidsetRange(RooAbsReal& min, RooAbsReal& max); voidsetRange(const char* name, Double_t min, Double_t max); voidsetRange(const char* name, RooAbsReal& min, RooAbsReal& max); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealVar.html:27599,cache,cache,27599,root/html528/RooRealVar.html,https://root.cern,https://root.cern/root/html528/RooRealVar.html,1,['cache'],['cache']
Performance,"t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Create a GraphViz .dot file visualizing the expression tree headed by; this RooAbsArg object. Use the GraphViz tool suite to make e.g. a gif; or ps file from the .dot file. Based on concept developed by Kyle Cranmer. void graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:35234,cache,cache,35234,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,3,['cache'],['cache']
Performance,"t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Create a GraphViz .dot file visualizing the expression tree headed by; this RooAbsArg object. Use the GraphViz tool suite to make e.g. a gif; or ps file from the .dot file. Based on concept developed by Kyle Cranmer. void graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); Write the GraphViz representation of the expression tree headed by; this RooAbsArg object to the given ostream. Based on concept developed by Kyle Cranmer. void graphVizAddConn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:35429,cache,cache,35429,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,3,['cache'],['cache']
Performance,"t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of conditional product terms. void fixRefRange(const char* rangeName). std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooProdPdf with cache-and-track, _and_ label all RooProdPdf; descendants with extra informationa about (conditional) normalization, needed to be able; to Cache-And-Track them outside the RooprodPdf context. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProdPdf to more intuitively reflect the contents of the; product operator construction. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Implement support for node removal. TObject* clone(const char* newname) const; { return new RooProdPdf(*this,newname) ; }. Bool_t selfNormalized() const; { return _selfNorm ; }. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; { return _pdfList ; }. void setSelfNormalized(Bool_t flag); { _selfNorm = flag ; }. void setDefNormSet(const RooArgSet& nset); { _defNormSet.removeAll() ; _defNormSet.addClone(nset) ; }. CacheMode canNodeBeCached() const; { return RooAbsArg::NotAdvised ; }. void useDefaultGen(Bool_t flag = kTRUE); { _useDefaultGen = flag ; }. » Last changed: Tue Jun 30 14:35:01 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProdPdf.html:61667,Cache,CacheMode,61667,root/html602/RooProdPdf.html,https://root.cern,https://root.cern/root/html602/RooProdPdf.html,1,['Cache'],['CacheMode']
Performance,"t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of conditional product terms. void fixRefRange(const char* rangeName). std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooProdPdf with cache-and-track, _and_ label all RooProdPdf; descendants with extra informationa about (conditional) normalization, needed to be able; to Cache-And-Track them outside the RooprodPdf context. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProdPdf to more intuitively reflect the contents of the; product operator construction. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Implement support for node removal. TObject* clone(const char* newname) const; { return new RooProdPdf(*this,newname) ; }. Bool_t selfNormalized() const; { return _selfNorm ; }. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; { return _pdfList ; }. void setSelfNormalized(Bool_t flag); { _selfNorm = flag ; }. void setDefNormSet(const RooArgSet& nset); { _defNormSet.removeAll() ; _defNormSet.addClone(nset) ; }. CacheMode canNodeBeCached() const; { return RooAbsArg::NotAdvised ; }. void useDefaultGen(Bool_t flag = kTRUE); { _useDefaultGen = flag ; }. » Last changed: Tue Mar 10 17:18:32 2015 » Last generated: 2015-03-10 17:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:60012,Cache,CacheMode,60012,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,1,['Cache'],['CacheMode']
Performance,"t function is called. This function will execute the specified command. The following example uses the services of the class Aclock created in $ROOTSYS/test/Aclock.cxx. This examples uses a TTimer to redraw a pad at regular intervals (clock). When the clock is updated, a string with the current date&time is drawn. {; gSystem->Load(""$ROOTSYS/test/Aclock"");; Aclock ck(400);; gPad->SetFillColor(5);; TDatime dt;; TText t(.5,.3,""t"");; t.SetTextAlign(22);; t.SetTextSize(.07);; t.SetTextColor(4);; t.Draw();; TExec ex(""ex"",""dt.Set();t.SetTitle(dt.AsString())"");; ex.Draw();; }; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; gPad#define gPadDefinition TVirtualPad.h:308; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TExecTExec is a utility class that can be used to execute a C++ command when some event happens in a pad.Definition TExec.h:26; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TTextBase class for several text objects.Definition TText.h:22; exDouble_t ex[n]Definition legend1.C:17. Case 2:; The TExec object may be added to the list of functions of a TH1 or TGraph object via hist->GetListOfFunctions()->Add(exec). When the histogram (or graph) is drawn, the TExec will be executed. If the histogram is made persistent on a file, the TExec object is also saved with the histogram. When redrawing the histogram in a new session, the TExec will be executed.; Example:; Assume an histogram TH1F *h already filled. TExec *ex1 = new TExec(""ex1"",""DoSomething()"");; TExec *ex2 = new TExec(""ex2"","".x macro.C"");; h->GetListOfFunctions()->Add(ex1);; h->GetListOfFunctions()->Add(ex2);; h->Draw();; h#define h(i)Definition RSha256.hxx:106; TExec::TExecTExec()Exec default constructor.Definition TExec.cxx:105; When the Paint function for the histogram will be called, the ""DoSomething"" function will",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTExec.html:1584,Load,Loadvirtual,1584,doc/master/classTExec.html,https://root.cern,https://root.cern/doc/master/classTExec.html,3,['Load'],"['Load', 'Loadvirtual']"
Performance,"t good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masses in Python, use TLorentzVector instead. Moreover, before you start optimizing, make sure that you have run a profiler to find out where the bottlenecks are. Some performance, without cost in terms of programmer effort, may be gained by using psyco, see the next link: http://psyco.sourceforge.net, a Python just in time compiler (JIT). Note, however, that psyco is limited to Intel i386 CPUs. Since psyco optimizes Python, not PyROOT calls; it generally does not improve performance that much if most of your code consists of ROOT API calls. Mathematical computations in Python, on the other hand, benefit a lot.; Every call to a Python member function results in a lookup of that member function and an association of this method with 'self'. Furthermore, a temporary object is created during this process that is discarded after the method call. In inner loops, it may be worth your while (up to 30%), to short-cut this process by looking up and binding the method before the loop, and discarding it afterwards. Here is an example:; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bound method; for i in xrange(25000):; px = gRandom.Gaus(); hpxFill(px) # use bound method: no lookup needed; del hpxFill # done with cached method; Note that if you do not discard the bound method, a reference to the histogram will remain outstanding, and it will not be deleted when it should be. It is therefore important to delete the method when you’re done with it.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1064204,optimiz,optimizes,1064204,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['optimiz', 'perform']","['optimizes', 'performance']"
Performance,"t histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfBalanceDepthnumber of binary tree levels used for balancing tree; vector<TMVA::kNN::Event,allocator<TMVA::kNN::Event> >fEvent! (untouched) events used for learning; TStringfKernel=""Gaus"",""Poln"" - kernel type for smoothing; TMVA::LDAfLDA! Experimental feature for local knn analysis; TMVA::kNN::ModulekNN*fModule! module where all work is done; Float_tfScaleFracfraction of events used to compute variable width; Float_tfSigmaFactscale factor for Gaussian sigma in Gaus. kernel; Double_tfSumOfWeightsBsum-of-weights for background training events ; Double_tfSumOfWeightsSsum-of-weights for signal training events; Int_tfTreeOptDepthnumber of binary tree levels used for optimization; Bool_tfTrimset equal number of signal and background events; Bool_tfUseKerneluse polynomial kernel weight function; Bool_tfUseLDAuse local linear discriminat analysis to compute MVA; Bool_tfUseWeightuse weights to count kNN; Int_tfnkNNnumber of k-nearest neighbors . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodKNN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""KNN"", TDirectory* theTargetDir = NULL); standard constructor. MethodKNN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. ~MethodKNN(); destructor. void DeclareOptions(); MethodKNN options. void DeclareCompatibilityOptions(). void ProcessOptions(); process the options specified by the user. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-targe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodKNN.html:17433,optimiz,optimization,17433,root/html530/TMVA__MethodKNN.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodKNN.html,2,['optimiz'],['optimization']
Performance,"t histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfBalanceDepthnumber of binary tree levels used for balancing tree; vector<TMVA::kNN::Event,allocator<TMVA::kNN::Event> >fEvent! (untouched) events used for learning; TStringfKernel=""Gaus"",""Poln"" - kernel type for smoothing; TMVA::LDAfLDA! Experimental feature for local knn analysis; TMVA::kNN::ModulekNN*fModule! module where all work is done; Float_tfScaleFracfraction of events used to compute variable width; Float_tfSigmaFactscale factor for Gaussian sigma in Gaus. kernel; Double_tfSumOfWeightsBsum-of-weights for background training events ; Double_tfSumOfWeightsSsum-of-weights for signal training events; Int_tfTreeOptDepthnumber of binary tree levels used for optimization; Bool_tfTrimset equal number of signal and background events; Bool_tfUseKerneluse polynomial kernel weight function; Bool_tfUseLDAuse local linear discriminat analysis to compute MVA; Bool_tfUseWeightuse weights to count kNN; Int_tfnkNNnumber of k-nearest neighbors . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodKNN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""KNN"", TDirectory* theTargetDir = NULL); standard constructor. MethodKNN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. ~MethodKNN(); destructor. void DeclareOptions(); MethodKNN options. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); process the options specified by the user. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodKNN.html:17406,optimiz,optimization,17406,root/html534/TMVA__MethodKNN.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodKNN.html,1,['optimiz'],['optimization']
Performance,"t implementation does nothing. ; Reimplemented from RooAbsPdf.; Definition at line 223 of file RooBDecay.cxx. ◆ getCoefAnalyticalIntegral(). Int_t RooBDecay::getCoefAnalyticalIntegral ; (; Int_t ; coef, . RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Default implementation of function advertising integration capabilities. ; The interface is similar to that of getAnalyticalIntegral except that an integer code is added that designates the coefficient number for which the integration capabilities are requested; This default implementation advertises that no internal integrals are supported. ; Reimplemented from RooAbsAnaConvPdf.; Definition at line 167 of file RooBDecay.cxx. ◆ getGenerator(). Int_t RooBDecay::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ; A code of zero indicates that we cannot generate any of the directVars (in this case, nothing should be added to generatedVars). Any non-zero codes will be passed to our generateEvent() implementation, but otherwise its value is arbitrary. The default implementation of this method returns zero. Subclasses will usually implement this method using the matchArgs() methods to advertise the algorithms they provide. ; Reimplemented from RooAbsPdf.; Definition at line 215 of file RooBDecay.cxx. ◆ IsA(). TClass * RooBDecay::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsAnaConvPdf.; Definition at line 72 of file RooBDecay.h. ◆ Streamer(). void RooBDecay::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsAnaConvPdf. ◆ StreamerNVirtual(). void RooBDecay::StreamerNVirtual ; (; TBuffer & ; ClassD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBDecay.html:81593,Load,Load,81593,doc/master/classRooBDecay.html,https://root.cern,https://root.cern/doc/master/classRooBDecay.html,1,['Load'],['Load']
Performance,t implemented for CrossValidation; <WARNING> <WARNING> : MakeClassSpecific not implemented for CrossValidation; : Elapsed time for training with 1998 events: 3.81e-06 sec ; <HEADER> Fisher : [datasetcv] : Evaluation of Fisher on training sample (1998 events); : Elapsed time for evaluation of 1998 events: 0.000313 sec ; : Creating xml weight file: datasetcv/weights/TMVACrossValidation_Fisher.weights.xml; : Creating standalone class: datasetcv/weights/TMVACrossValidation_Fisher.class.C; <WARNING> <WARNING> : MakeClassSpecificHeader not implemented for CrossValidation; <WARNING> <WARNING> : MakeClassSpecific not implemented for CrossValidation; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: BDTG for Classification performance; : ; <HEADER> BDTG : [datasetcv] : Evaluation of BDTG on testing sample (1998 events); : Elapsed time for evaluation of 1998 events: 0.00612 sec ; <HEADER> Factory : Test method: Fisher for Classification performance; : ; <HEADER> Fisher : [datasetcv] : Evaluation of Fisher on testing sample (1998 events); : Elapsed time for evaluation of 1998 events: 0.000313 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: BDTG; : ; <HEADER> BDTG : [datasetcv] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_BDTG : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : x: -0.014284 1.4061 [ -4.1075 4.0969 ]; : y: -0.0066370 1.4204 [ -4.8520 4.0761 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: Fisher; : ; <HEADER> Fisher : [datasetcv] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Fisher : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : x: -0.014284 1.4061 [ -4.1075 4.0969 ]; : y: -0.0066370 1.4204 [ -4.8520 4.0761 ]; : ---------------------------------------------,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:15868,perform,performance,15868,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['perform'],['performance']
Performance,"t in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ). krot rotation matrix number assigned; theta1 polar angle for axis i; phi1 azimuthal angle for axis i; theta2 polar angle for axis ii; phi2 azimuthal angle for axis ii; theta3 polar angle for axis iii; phi3 azimuthal angle for axis iii. it defines the rotation matrix number irot. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np). NAME Volume name; SHAPE Volume type; NUMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. It creates a new volume in the JVOLUM data structure. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np). NAME Volume name; SHAPE Volume type; NUMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector conta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoMCGeometry.html:13334,perform,performed,13334,root/html528/TGeoMCGeometry.html,https://root.cern,https://root.cern/root/html528/TGeoMCGeometry.html,18,['perform'],['performed']
Performance,"t index); Bool_tsetOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategoryLValue.html:20537,Cache,CacheMode,20537,root/html534/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html,1,['Cache'],['CacheMode']
Performance,"t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:18750,optimiz,optimizeCacheMode,18750,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,12,['optimiz'],['optimizeCacheMode']
Performance,"t is a vector of TFormula pointers) needs to be copied one by one; 705 // looping at all the elements; 706 // delete first previous elements; 707 int nLinParts = fnew.fLinearParts.size();; 708 if (nLinParts > 0) {; 709 for (int i = 0; i < nLinParts; ++i) delete fnew.fLinearParts[i];; 710 fnew.fLinearParts.clear();; 711 }; 712 // old size that needs to be copied; 713 nLinParts = fLinearParts.size();; 714 if (nLinParts > 0) {; 715 fnew.fLinearParts.reserve(nLinParts);; 716 for (int i = 0; i < nLinParts; ++i) {; 717 TFormula * linearNew = new TFormula();; 718 TFormula * linearOld = (TFormula*) fLinearParts[i];; 719 if (linearOld) {; 720 linearOld->Copy(*linearNew);; 721 fnew.fLinearParts.push_back(linearNew);; 722 }; 723 else; 724 Warning(""Copy"",""Function %s - expr %s has a dummy linear part %d"",GetName(),GetExpFormula().Data(),i);; 725 }; 726 }; 727 ; 728 fnew.fClingInput = fClingInput;; 729 fnew.fReadyToExecute = fReadyToExecute;; 730 fnew.fClingInitialized = fClingInitialized.load();; 731 fnew.fAllParametersSetted = fAllParametersSetted;; 732 fnew.fClingName = fClingName;; 733 fnew.fSavedInputFormula = fSavedInputFormula;; 734 fnew.fLazyInitialization = fLazyInitialization;; 735 ; 736 // case of function based on a C++ expression (lambda's) which is ready to be compiled; 737 if (fLambdaPtr && TestBit(TFormula::kLambda)) {; 738 ; 739 bool ret = fnew.InitLambdaExpression(fnew.fFormula);; 740 if (ret) {; 741 fnew.SetBit(TFormula::kLambda);; 742 fnew.fReadyToExecute = true;; 743 }; 744 else {; 745 Error(""TFormula"",""Syntax error in building the lambda expression %s"", fFormula.Data() );; 746 fnew.fReadyToExecute = false;; 747 }; 748 }; 749 ; 750 // use copy-constructor of TMethodCall; 751 // if c++-14 could use std::make_unique; 752 TMethodCall *m = (fMethod) ? new TMethodCall(*fMethod) : nullptr;; 753 fnew.fMethod.reset(m);; 754 ; 755 fnew.fFuncPtr = fFuncPtr;; 756 fnew.fGradGenerationInput = fGradGenerationInput;; 757 fnew.fHessGenerationInput = fHessGenerationInput;; 7",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:26870,load,load,26870,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['load'],['load']
Performance,"t is enough to read; the data from the server.; Int_t version Set LDAP protocol version: LDAP_VERSION1,; LDAP_VERSION2, LDAP_VERSION3. TLDAPServer(const TLDAPServer& ); Copy constructor. TLDAPServer& operator=(const TLDAPServer& ); Equal operator. ~TLDAPServer(); If the object is connected to the server, it disconnects. Int_t Bind(); Binds to the server with specified binddn and password.; Return value: LDAP error code, 0 if successfully bound. void Unbind(); Unbinds from the server with specified binddn and password. const char * GetNamingContexts(); Performs an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschemaSubentry"" to; be returned with the result. The value of this attribute is; extracted and returned as const char. TLDAPResult * GetObjectClasses(); Calls GetSubschemaSubentry() and performs and LDAPSearch with; the attribute ""objectClasses"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * GetAttributeTypes(); Calls GetSubschemaSubentry() and performs and LDAPSearch with the; attribute ""attributeTypes"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * Search(const char* base = """", Int_t scope = LDAP_SCOPE_BASE, const char* filter = 0, TList* attrs = 0, Bool_t attrsonly = 0); Performs searching at the LDAP directory.; Return value: a TLDAPResult object or 0 in case of error.; Result needs to be deleted by user.; const char *base: Specifies the base object for the search operation; Int_t scope: Specifies the portion of the LDAP tree, relative to; the base object, to search.; Must be one of LDAP_SCOPE_BASE (==0),; LDAP_SCOPE_ONELEVEL (==1) or LDAP_SCOPE_SUBTREE (==2).; char *filter: The criteria during the search to determine which; entries to return, 0 means that the filte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLDAPServer.html:7655,perform,performs,7655,root/html528/TLDAPServer.html,https://root.cern,https://root.cern/root/html528/TLDAPServer.html,3,['perform'],['performs']
Performance,"t known,; the offset table is computed. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Get entry from the file to memory. getall = 0 : get only active branches; getall = 1 : get all branches. Return the total number of bytes read,; 0 bytes read indicates a failure. Long64_t GetEntryNumber(Long64_t entry) const; -- Return entry number corresponding to entry. if no TEntryList set returns entry; else returns entry #entry from this entry list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* branchname, const char* leafname); -- Return a pointer to the leaf name in the current tree. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the current tree. TObjArray* GetListOfBranches(); -- Return a pointer to the list of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TChain.html:38352,load,loaded,38352,root/html532/TChain.html,https://root.cern,https://root.cern/root/html532/TChain.html,4,['load'],['loaded']
Performance,"t known,; the offset table is computed. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Get entry from the file to memory. getall = 0 : get only active branches; getall = 1 : get all branches. Return the total number of bytes read,; 0 bytes read indicates a failure. Long64_t GetEntryNumber(Long64_t entry) const; -- Return entry number corresponding to entry. if no TEntryList set returns entry; else returns entry #entry from this entry list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the current tree. TObjArray* GetListOfBranches(); -- Return a pointer to the list of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TChain.html:36266,load,loaded,36266,root/html528/TChain.html,https://root.cern,https://root.cern/root/html528/TChain.html,2,['load'],['loaded']
Performance,"t known,; the offset table is computed. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Get entry from the file to memory. getall = 0 : get only active branches; getall = 1 : get all branches. Return the total number of bytes read,; 0 bytes read indicates a failure. Long64_t GetEntryNumber(Long64_t entry) const; -- Return entry number corresponding to entry. if no TEntryList set returns entry; else returns entry #entry from this entry list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the current tree. TObjArray* GetListOfBranches(); -- Return a pointer to the list of branches of the current tree. Warning: May set current tree!. Returns 1 on success and 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TChain.html:35712,load,loaded,35712,root/html526/TChain.html,https://root.cern,https://root.cern/root/html526/TChain.html,1,['load'],['loaded']
Performance,"t label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_t_valueConstant value of self; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooConstVar(const char* name, const char* title, Double_t value); Constructor with value; _fast = kTRUE ;. RooConstVar(const RooCons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooConstVar.html:34382,cache,cache,34382,root/html534/RooConstVar.html,https://root.cern,https://root.cern/root/html534/RooConstVar.html,2,['cache'],['cache']
Performance,"t len) const;  ; bool NeedsExistingFile (EMode mode) const;  ; bool NeedsToWrite (EMode mode) const;  ; TMemFile & operator= (const TMemFile &)=delete;  ; EMode ParseOption (Option_t *option);  Parse option strings and set fOption. ;  ; void ResetObjects (TDirectoryFile *, TFileMergeInfo *) const;  Wipe all the data from the permanent buffer but keep, the in-memory object alive. ;  ; Int_t SysClose (Int_t fd) override;  Close the mem file. ;  ; Int_t SysOpen (const char *pathname, Int_t flags, UInt_t mode) override;  Open a file in 'MemFile'. ;  ; Int_t SysRead (Int_t fd, void *buf, Int_t len) override;  Read specified number of bytes from current offset into the buffer. ;  ; Int_t SysReadImpl (Int_t fd, void *buf, Long64_t len);  Read specified number of bytes from current offset into the buffer. ;  ; Long64_t SysSeek (Int_t fd, Long64_t offset, Int_t whence) override;  Seek to a specified position in the file. ;  ; Int_t SysStat (Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime) override;  Perform a stat on the file; see TFile::SysStat(). ;  ; Int_t SysSync (Int_t fd) override;  Sync remaining data to disk. ;  ; Int_t SysWrite (Int_t fd, const void *buf, Int_t len) override;  Write a buffer into the file. ;  ; Int_t SysWriteImpl (Int_t fd, const void *buf, Long64_t len);  Write a buffer into the file. ;  ;  Protected Member Functions inherited from TFile; virtual Long64_t DirCreateEntry (TDirectory *);  ; virtual Int_t DirReadKeys (TDirectory *);  ; virtual void DirWriteHeader (TDirectory *);  ; virtual void DirWriteKeys (TDirectory *);  ; Bool_t FlushWriteCache ();  Flush the write cache if active. ;  ; virtual EAsyncOpenStatus GetAsyncOpenStatus ();  ; virtual InfoListRet GetStreamerInfoListImpl (bool lookupSICache);  See documentation of GetStreamerInfoList for more details. ;  ; virtual void Init (Bool_t create);  Initialize a TFile object. ;  ; Int_t MakeProjectParMake (const char *packname, const char *filename);  Create makefile at 'filem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMemFile.html:33763,Perform,Perform,33763,doc/master/classTMemFile.html,https://root.cern,https://root.cern/doc/master/classTMemFile.html,5,['Perform'],['Perform']
Performance,"t len);  Add block of length len at position pos in the list of blocks to be prefetched. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; virtual Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len);  Read buffer at position pos. ;  ; virtual Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc);  ; virtual Int_t ReadBufferExtNormal (char *buf, Long64_t pos, Int_t len, Int_t &loc);  Base function for ReadBuffer. ;  ; virtual Int_t ReadBufferExtPrefetch (char *buf, Long64_t pos, Int_t len, Int_t &loc);  prefetch the first block ;  ; virtual void SecondPrefetch (Long64_t, Int_t);  ; virtual void SecondSort ();  Sort buffers to be prefetched in increasing order of positions. ;  ; virtual Int_t SetBufferSize (Long64_t buffersize);  Sets the buffer size. ;  ; virtual void SetEnablePrefetching (Bool_t setPrefetching=kFALSE);  Set the prefetching mode of this file. ;  ; virtual void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect);  Set the file using this cache and reset the current blocks (if any). ;  ; virtual void SetSkipZip (Bool_t=kTRUE);  ; virtual void Sort ();  Sort buffers to be prefetched in increasing order of positions. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void WaitFinishPrefetch ();  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheRead.html:3347,cache,cache,3347,doc/master/classTFileCacheRead.html,https://root.cern,https://root.cern/doc/master/classTFileCacheRead.html,1,['cache'],['cache']
Performance,"t lenDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; TString.h; TVirtualPerfStats.h; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TGaxisThe axis painter class.Definition TGaxis.h:24; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TTextBase class for several text objects.Definition TText.h:22; TTreePerfStatsTTree I/O performance measurement.Definition TTreePerfStats.h:38; TTreePerfStats::fGraphIOTGraphErrors * fGraphIOPointer to the graph with IO data.Definition TTreePerfStats.h:69; TTreePerfStats::GetNumEventsLong64_t GetNumEvents() const overrideDefinition TTreePerfStats.h:104; TTreePerfStats::fUnzipInputSizeLong64_t fUnzipInputSizeCompressed bytes seen by the decompressor.Definition TTreePerfStats.h:62; TTreePerfStats::SetUsedvoid SetUsed(size_t bi, size_t basketNumber) overrideDefinition TTreePerfStats.h:152; TTreePerfStats::SetGraphIOvirtual void SetGraphIO(TGraphErrors *gr)Definition TTreePerfStats.h:132; TTreePerfStats::GetPaveTPaveText * GetPave()Definition TTreePerfStats.h:105; TTreePerfStats::SetUsedvoid SetUsed(TBranch *b, size_t basketNumber) overrideDefinition TTreePerfStats.h:151; TTreePerfStats::SetRealNormvirtual void SetRealNorm(Double_t rnorm)Definition TTreePerfStats.h:139; TTreePerfStats::fNameTString fNameName of this TTreePerfStats.Definition TTreePerfStats.h:65; TTreePerfS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8h_source.html:11135,perform,performance,11135,doc/master/TTreePerfStats_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html,1,['perform'],['performance']
Performance,"t level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  . Protected Attributes; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions; void addParameters (RooAbsCollection &params, const RooArgSet *nset=null",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:37691,Cache,Cached,37691,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['Cache'],['Cached']
Performance,"t line 161 of file TRInterface.cxx. ◆ IsA(). virtual TClass * ROOT::R::TRInterface::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 320 of file TRInterface.h. ◆ IsInstalled(). Bool_t TRInterface::IsInstalled ; (; TString ; pkg). Method to verify if a package is installed. ; Parameters. pkgR's pkg name . Returnstrue or false if the package is installed or not ; Definition at line 193 of file TRInterface.cxx. ◆ operator[](). TRInterface::Binding TRInterface::operator[] ; (; const TString & ; name). Definition at line 142 of file TRInterface.cxx. ◆ ProcessEventsLoop(). void TRInterface::ProcessEventsLoop ; (; ). Init event loop in a thread to support actions in windows from R graphics system. ; Definition at line 219 of file TRInterface.cxx. ◆ Require(). Bool_t TRInterface::Require ; (; TString ; pkg). Method to load an R's package. ; Parameters. pkgR's pkg name . Returnstrue or false if the package was loaded or not ; Definition at line 200 of file TRInterface.cxx. ◆ SetVerbose(). void TRInterface::SetVerbose ; (; Bool_t ; status). Method to set verbose mode, that produce extra output. ; Notesome time can produce so much noise in the output ; Parameters. statusboolean to enable of disable . Definition at line 134 of file TRInterface.cxx. ◆ Streamer(). virtual void ROOT::R::TRInterface::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void ROOT::R::TRInterface::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 320 of file TRInterface.h. Member Data Documentation. ◆ fR. RInside* ROOT::R::TRInterface::fR. protected . Definition at line 138 of file TRInterface.h. ◆ th. TThread* ROOT::R::TRInterface::th. protected . Definition at line 139 of file TRInterface.h. Libraries for ROOT::R::TRInterface:. [legend]; The documentation for this class was generated from the following file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1R_1_1TRInterface.html:23948,load,loaded,23948,doc/master/classROOT_1_1R_1_1TRInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1R_1_1TRInterface.html,1,['load'],['loaded']
Performance,t line 274 of file RooNumRunningInt.cxx. ◆ binningName(). const char * RooNumRunningInt::binningName ; (; ); const. inlineoverrideprotectedvirtual . Reimplemented from RooAbsCachedReal.; Definition at line 47 of file RooNumRunningInt.h. ◆ Class(). static TClass * RooNumRunningInt::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooNumRunningInt::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooNumRunningInt::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 63 of file RooNumRunningInt.h. ◆ clone(). TObject * RooNumRunningInt::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 26 of file RooNumRunningInt.h. ◆ createCache(). RooAbsCachedReal::FuncCacheElem * RooNumRunningInt::createCache ; (; const RooArgSet * ; nset); const. overrideprotectedvirtual . Create custom cache element for running integral calculations. ; Reimplemented from RooAbsCachedReal.; Definition at line 285 of file RooNumRunningInt.cxx. ◆ DeclFileName(). static const char * RooNumRunningInt::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 63 of file RooNumRunningInt.h. ◆ evaluate(). double RooNumRunningInt::evaluate ; (; ); const. overrideprotectedvirtual . Dummy function that is never called. ; Implements RooAbsReal.; Definition at line 294 of file RooNumRunningInt.cxx. ◆ fillCacheObject(). void RooNumRunningInt::fillCacheObject ; (; RooAbsCachedReal::FuncCacheElem & ; cache); const. overrideprotectedvirtual . Fill the cache object by calling its calculate() method. ; Implements RooAbsCachedReal.; Definition at line 248 of file RooNumRunningInt.cxx. ◆ inputBaseName(). const char * RooNumRunningInt::inputBaseName ; (; ); const. overrideprotectedvirtual . Return unique name for RooAbsCachedPdf cache components constructed from inpu,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumRunningInt.html:65783,cache,cache,65783,doc/master/classRooNumRunningInt.html,https://root.cern,https://root.cern/doc/master/classRooNumRunningInt.html,1,['cache'],['cache']
Performance,"t line 391 of file TFumili.cxx. ◆ ExecuteSetCommand(). Int_t TFumili::ExecuteSetCommand ; (; Int_t ; nargs). Called from TFumili::ExecuteCommand in case of ""SET xxx"" and ""SHOW xxx"". ; Definition at line 558 of file TFumili.cxx. ◆ FitChisquare(). void TFumili::FitChisquare ; (; Int_t & ; npar, . Double_t * ; gin, . Double_t & ; f, . Double_t * ; u, . Int_t ; flag . ). virtual . Minimization function for H1s using a Chisquare method. ; Default method (function evaluated at center of bin) for each point the cache contains the following info; 1D : bc,e,xc (bin content, error, x of center of bin); 2D : bc,e,xc,yc; 3D : bc,e,xc,yc,zc . Definition at line 1738 of file TFumili.cxx. ◆ FitChisquareI(). void TFumili::FitChisquareI ; (; Int_t & ; npar, . Double_t * ; gin, . Double_t & ; f, . Double_t * ; u, . Int_t ; flag . ). virtual . Minimization function for H1s using a Chisquare method. ; The ""I""ntegral method is used for each point the cache contains the following info; 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 2D : bc,e,xc,xw,yc,yw; 3D : bc,e,xc,xw,yc,yw,zc,zw . Definition at line 1809 of file TFumili.cxx. ◆ FitLikelihood(). void TFumili::FitLikelihood ; (; Int_t & ; npar, . Double_t * ; gin, . Double_t & ; f, . Double_t * ; u, . Int_t ; flag . ). virtual . Minimization function for H1s using a Likelihood method. ; Basically, it forms the likelihood by determining the Poisson probability that given a number of entries in a particular bin, the fit would predict it's value. This is then done for each bin, and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin) for each point the cache contains the following info; 1D : bc,e,xc (bin content, error, x of center of bin); 2D : bc,e,xc,yc; 3D : bc,e,xc,yc,zc . Definition at line 1884 of file TFumili.cxx. ◆ FitLikelihoodI(). void TFumili::FitLikelihoodI ; (; Int_t & ; npar, . Double_t * ; gin, . Double_t & ; f, . Double_t * ; u, . Int_t ; flag . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFumili.html:30364,cache,cache,30364,doc/master/classTFumili.html,https://root.cern,https://root.cern/doc/master/classTFumili.html,1,['cache'],['cache']
Performance,"t line 48 of file GeneticPopulation.h. Public Member Functions;  GeneticPopulation (const std::vector< TMVA::Interval * > &ranges, Int_t size, UInt_t seed=0);  Constructor. ;  ; virtual ~GeneticPopulation ();  destructor ;  ; void AddPopulation (GeneticPopulation &strangers);  add another population (strangers) to the one of this GeneticPopulation ;  ; void AddPopulation (GeneticPopulation *strangers);  add another population (strangers) to the one of this GeneticPopulation ;  ; Double_t GetFitness () const;  ; std::vector< TMVA::GeneticGenes > & GetGenePool ();  ; const std::vector< TMVA::GeneticGenes > & GetGenePool () const;  ; GeneticGenes * GetGenes (Int_t index);  gives back the ""Genes"" of the population with the given index. ;  ; Int_t GetPopulationSize () const;  ; std::vector< TMVA::GeneticRange * > & GetRanges ();  ; const std::vector< TMVA::GeneticRange * > & GetRanges () const;  ; void GiveHint (std::vector< Double_t > &hint, Double_t fitness=0);  add an individual (a set of variables) to the population if there is a set of variables which is known to perform good, they can be given as a hint to the population ;  ; virtual TClass * IsA () const;  ; void MakeChildren ();  Creates children out of members of the current generation. ;  ; void MakeCopies (int number);  Produces offspring which is are copies of their parents. ;  ; void Mutate (Double_t probability=20, Int_t startIndex=0, Bool_t near=kFALSE, Double_t spread=0.1, Bool_t mirror=kFALSE);  Mutates the individuals in the genePool. ;  ; void NextGeneration ();  ; void Print (Int_t untilIndex=-1);  make a little printout of the individuals up to index ""untilIndex"" this means, . ;  ; void Print (std::ostream &out, Int_t utilIndex=-1);  make a little printout to the stream ""out"" of the individuals up to index ""untilIndex"" this means, . ;  ; void SetRandomSeed (UInt_t seed=0);  the random seed of the random generator ;  ; void Sort ();  sort the genepool according to the fitness of the individuals ;  ; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1GeneticPopulation.html:1472,perform,perform,1472,doc/master/classTMVA_1_1GeneticPopulation.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1GeneticPopulation.html,1,['perform'],['perform']
Performance,"t line 48 of file RooObjCacheManager.h. ◆ DeclFileName(). static const char * RooObjCacheManager::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 62 of file RooObjCacheManager.h. ◆ doClearObsList(). static void RooObjCacheManager::doClearObsList ; (; bool ; flag). inlinestatic . Definition at line 47 of file RooObjCacheManager.h. ◆ findConstantNodes(). void RooObjCacheManager::findConstantNodes ; (; const RooArgSet & ; obs, . RooArgSet & ; cacheList, . RooLinkedList & ; processedNodes . ). overridevirtual . If clearOnRedirect is false, forward constant term optimization calls to cache elements. ; Reimplemented from RooAbsCache.; Definition at line 209 of file RooObjCacheManager.cxx. ◆ insertObjectHook(). void RooObjCacheManager::insertObjectHook ; (; RooAbsCacheElement & ; obj). overridevirtual . Set owner link on all object inserted into cache. ; Also if cache mode optimization was requested, apply it now to cache element being inserted ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 175 of file RooObjCacheManager.cxx. ◆ IsA(). TClass * RooObjCacheManager::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 62 of file RooObjCacheManager.h. ◆ operModeHook(). void RooObjCacheManager::operModeHook ; (; ). overridevirtual . Intercept changes to cache operation mode and forward to cache elements. ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 108 of file RooObjCacheManager.cxx. ◆ optimizeCacheMode(). void RooObjCacheManager::optimizeCacheMode ; (; const RooArgSet & ; obs, . RooArgSet & ; optNodes, . RooLinkedList & ; processedNodes . ). overridevirtual . Intercept calls to perform automatic optimization of cache mode operation. ; Forward calls to existing cache elements and save configuration of cache mode optimization so that it ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:9427,cache,cache,9427,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,3,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"t line 58 of file TSpectrum.h. ◆ GetPositionY(). Double_t * TSpectrum::GetPositionY ; (; ); const. inline . Definition at line 59 of file TSpectrum.h. ◆ IsA(). TClass * TSpectrum::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 78 of file TSpectrum.h. ◆ operator=(). TSpectrum & TSpectrum::operator= ; (; const TSpectrum & ; ). private . ◆ Print(). void TSpectrum::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print the array of positions. ; Reimplemented from TNamed.; Definition at line 212 of file TSpectrum.cxx. ◆ Search(). Int_t TSpectrum::Search ; (; const TH1 * ; hin, . Double_t ; sigma = 2, . Option_t * ; option = """", . Double_t ; threshold = 0.05 . ). virtual . One-dimensional peak search function. ; This function searches for peaks in source spectrum in hin The number of found peaks and their positions are written into the members fNpeaks and fPositionX. The search is performed in the current histogram range.; Parameters:. hin: pointer to the histogram of source spectrum; sigma: sigma of searched peaks, for details we refer to manual; threshold: (default=0.05) peaks with amplitude less than threshold*highest_peak are discarded. 0<threshold<1. By default, the background is removed before deconvolution. Specify the option ""nobackground"" to not remove the background.; By default the ""Markov"" chain algorithm is used. Specify the option ""noMarkov"" to disable this algorithm Note that by default the source spectrum is replaced by a new spectrum; By default a polymarker object is created and added to the list of functions of the histogram. The histogram is drawn with the specified option and the polymarker object drawn on top of the histogram. The polymarker coordinates correspond to the npeaks peaks found in the histogram.; A pointer to the polymarker object can be retrieved later via: TList *functions = hin->GetListOfFunctions();; TPolyMarker *pm = (TPolyMarker*)funct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum.html:53621,perform,performed,53621,doc/master/classTSpectrum.html,https://root.cern,https://root.cern/doc/master/classTSpectrum.html,1,['perform'],['performed']
Performance,"t line 6107 of file TProof.cxx. ◆ SetRealTimeLog(). void TProof::SetRealTimeLog ; (; Bool_t ; on = kTRUE). Switch ON/OFF the real-time logging facility. ; When this option is ON, log messages from processing are sent back as they come, instead of being sent back at the end in one go. This may help debugging or monitoring in some cases, but, depending on the amount of log, it may have significant consequencies on the load over the network, so it must be used with care. ; Definition at line 7096 of file TProof.cxx. ◆ SetRunStatus(). void TProof::SetRunStatus ; (; ERunStatus ; rst). inlineprivate . Definition at line 672 of file TProof.h. ◆ SetupWorkersEnv(). void TProof::SetupWorkersEnv ; (; TList * ; wrks, . Bool_t ; increasingpool = kFALSE . ). protected . Set up packages, loaded macros, include and lib paths ... ; Definition at line 1528 of file TProof.cxx. ◆ ShowCache(). void TProof::ShowCache ; (; Bool_t ; all = kFALSE). virtual . List contents of file cache. ; If all is true show all caches also on slaves. If everything is ok all caches are to be the same. ; Reimplemented in TProofLite.; Definition at line 7691 of file TProof.cxx. ◆ ShowData(). void TProof::ShowData ; (; ). virtual . List contents of the data directory in the sandbox. ; This is the place where files produced by the client queries are kept ; Reimplemented in TProofLite.; Definition at line 7396 of file TProof.cxx. ◆ ShowDataSet(). void TProof::ShowDataSet ; (; const char * ; dataset = """", . const char * ; opt = ""filter:SsCc"" . ). display meta-info for given dataset usi ; Definition at line 10977 of file TProof.cxx. ◆ ShowDataSetCache(). void TProof::ShowDataSetCache ; (; const char * ; dataset = 0). virtual . Display the content of the dataset cache, if any (matching 'dataset', if defined). ; Reimplemented in TProofLite.; Definition at line 10914 of file TProof.cxx. ◆ ShowDataSetQuota(). void TProof::ShowDataSetQuota ; (; Option_t * ; opt = 0). shows the quota and usage of all groups if opt contai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:147958,cache,caches,147958,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['cache'],['caches']
Performance,"t line 868 of file TList.cxx. ◆ RemoveLast(). void TList::RemoveLast ; (; ). overridevirtual . Remove the last object of the list. ; Reimplemented from TSeqCollection.; Definition at line 907 of file TList.cxx. ◆ Sort(). void TList::Sort ; (; Bool_t ; order = kSortAscending). virtual . Sort linked list. ; Real sorting is done in private function DoSort(). The list can only be sorted when is contains objects of a sortable class. ; Reimplemented in TSortedList.; Definition at line 935 of file TList.cxx. ◆ Streamer(). void TList::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from TCollection.; Reimplemented in TQCommand, TQUndoManager, TQConnection, TSortedList, TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, and TParallelCoordSelect.; Definition at line 1189 of file TList.cxx. ◆ StreamerNVirtual(). void TList::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 112 of file TList.h. Friends And Related Symbol Documentation. ◆ TListIter. friend class TListIter. friend . Definition at line 40 of file TList.h. Member Data Documentation. ◆ fAscending. Bool_t TList::fAscending. protected . cache to speedup sequential calling of Before() and After() functions ; Definition at line 49 of file TList.h. ◆ fCache. TObjLinkWeakPtr_t TList::fCache. protected . pointer to last entry in linked list ; Definition at line 48 of file TList.h. ◆ fFirst. TObjLinkPtr_t TList::fFirst. protected . Definition at line 46 of file TList.h. ◆ fLast. TObjLinkPtr_t TList::fLast. protected . pointer to first entry in linked list ; Definition at line 47 of file TList.h. Libraries for TList:. [legend]; The documentation for this class was generated from the following files:; core/cont/inc/TList.h; core/cont/src/TList.cxx. TList. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:56 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTList.html:38857,cache,cache,38857,doc/master/classTList.html,https://root.cern,https://root.cern/doc/master/classTList.html,1,['cache'],['cache']
Performance,"t line 9563 of file TCling.cxx. ◆ IsVoidPointerType(). bool TCling::IsVoidPointerType ; (; const void * ; QualTypePtr); const. virtual . Reimplemented from TInterpreter.; Definition at line 9587 of file TCling.cxx. ◆ LazyFunctionCreatorAutoload(). void * TCling::LazyFunctionCreatorAutoload ; (; const std::string & ; mangled_name). Autoload a library based on a missing symbol. ; Definition at line 6591 of file TCling.cxx. ◆ LibraryLoaded(). void TCling::LibraryLoaded ; (; const void * ; dyLibHandle, . const char * ; canonicalName . ). Definition at line 6974 of file TCling.cxx. ◆ LibraryLoadingFailed(). bool TCling::LibraryLoadingFailed ; (; const std::string & ; errmessage, . const std::string & ; libStem, . bool ; permanent, . bool ; resolved . ). Definition at line 6568 of file TCling.cxx. ◆ LibraryUnloaded(). void TCling::LibraryUnloaded ; (; const void * ; dyLibHandle, . const char * ; canonicalName . ). Definition at line 6981 of file TCling.cxx. ◆ Load(). Int_t TCling::Load ; (; const char * ; filename, . Bool_t ; system = kFALSE . ). finalvirtual . Load a library file in cling's memory. ; if 'system' is true, the library is never unloaded. Return 0 on success, -1 on failure. ; Implements TInterpreter.; Definition at line 3515 of file TCling.cxx. ◆ LoadEnums(). void TCling::LoadEnums ; (; TListOfEnums & ; cl); const. finalvirtual . Create list of pointers to enums for TClass cl. ; Implements TInterpreter.; Definition at line 4395 of file TCling.cxx. ◆ LoadFile(). int TCling::LoadFile ; (; const char * ; path); const. finalvirtual . Load a source file or library called path into the interpreter. ; Reimplemented from TInterpreter.; Definition at line 7500 of file TCling.cxx. ◆ LoadFunctionTemplates(). void TCling::LoadFunctionTemplates ; (; TClass * ; cl); const. finalvirtual . Create list of pointers to function templates for TClass cl. ; Implements TInterpreter.; Definition at line 4442 of file TCling.cxx. ◆ LoadLibraryMap(). Int_t TCling::LoadLibraryMap ; (; c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:112623,Load,Load,112623,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['Load'],['Load']
Performance,"t list into output list; 1491 if (!resampleProto) {; 1492 // In this mode, randomization is a strict reshuffle of the order; 1493 std::iota(lut, lut + nProto, 0); // fill the vector with 0 to nProto - 1; 1494 // Shuffle code taken from https://en.cppreference.com/w/cpp/algorithm/random_shuffle.; 1495 // The std::random_shuffle function was deprecated in C++17. We could have; 1496 // used std::shuffle instead, but this is not straight-forward to use with; 1497 // RooRandom::integer() and we didn't want to change the random number; 1498 // generator. It might cause unwanted effects like reproducibility problems.; 1499 for (int i = nProto-1; i > 0; --i) {; 1500 std::swap(lut[i], lut[RooRandom::integer(i+1)]);; 1501 }; 1502 } else {; 1503 // In this mode, we resample, i.e. events can be used more than once; 1504 std::generate(lut, lut + nProto, [&]{ return RooRandom::integer(nProto); });; 1505 }; 1506 ; 1507 ; 1508 return lut ;; 1509}; 1510 ; 1511 ; 1512 ; 1513////////////////////////////////////////////////////////////////////////////////; 1514/// Load generatedVars with the subset of directVars that we can generate events for,; 1515/// and return a code that specifies the generator algorithm we will use. A code of; 1516/// zero indicates that we cannot generate any of the directVars (in this case, nothing; 1517/// should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); 1518/// implementation, but otherwise its value is arbitrary. The default implementation of; 1519/// this method returns zero. Subclasses will usually implement this method using the; 1520/// matchArgs() methods to advertise the algorithms they provide.; 1521 ; 1522Int_t RooAbsPdf::getGenerator(const RooArgSet &/*directVars*/, RooArgSet &/*generatedVars*/, bool /*staticInitOK*/) const; 1523{; 1524 return 0 ;; 1525}; 1526 ; 1527 ; 1528 ; 1529////////////////////////////////////////////////////////////////////////////////; 1530/// Interface for one-time initialization ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:74347,Load,Load,74347,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['Load'],['Load']
Performance,"t matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; const RooArgSet*_nset! Normalization set to be used in evaluation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooRealProxy_pdfProbability Density function; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooEffProd.html:40683,cache,cache,40683,root/html532/RooEffProd.html,https://root.cern,https://root.cern/root/html532/RooEffProd.html,1,['cache'],['cache']
Performance,t method: Fisher for Classification performance; : ; <HEADER> Fisher : [dataset] : Evaluation of Fisher on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00318 sec ; <HEADER> Factory : Test method: Likelihood for Classification performance; : ; <HEADER> Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00959 sec ; <HEADER> Factory : Test method: FisherCat for Classification performance; : ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00192 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00196 sec ; <HEADER> Factory : Test method: LikelihoodCat for Classification performance; : ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00948 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00932 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: Fisher; : ; <HEADER> Fisher : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Fisher : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: Likelihood; : ; <HEADER> Likelihood : [dataset] : Loop ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:23563,perform,performance,23563,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,1,['perform'],['performance']
Performance,"t need to be notified; when the shape is destroyed.; Could also deliver 'change' notifications. Function Members (Methods); public:. TGLPShapeRef(); TGLPShapeRef(TGLPhysicalShape* shape); virtual~TGLPShapeRef(); static TClass*Class(); TGLPhysicalShape*GetPShape() const; virtual TClass*IsA() const; virtual voidPShapeModified(); virtual voidSetPShape(TGLPhysicalShape* shape); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TGLPShapeRef(const TGLPShapeRef&); TGLPShapeRef&operator=(const TGLPShapeRef&). Data Members; protected:. TGLPhysicalShape*fPShapePointer to referenced physical shape. private:. TGLPShapeRef*fNextPSRefInternal pointer to the next reference (used by TGLPhysicalShape directly). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPShapeRef(); Default contructor. TGLPShapeRef(TGLPhysicalShape* shape); Constructor with known shape - reference it. ~TGLPShapeRef(); Destructor - unreference the shape if set. void SetPShape(TGLPhysicalShape* shape); Set the shape. Unreference the old and reference the new.; This is virtual so that sub-classes can perform other tasks; on change. This function should be called first from there. This is also called from destructor of the refereced physical; shape with 0 argument. void PShapeModified(); This is called from physical shape when it is modified.; Sub-classes can override and take appropriate action. TGLPShapeRef(const TGLPShapeRef& ). TGLPShapeRef& operator=(const TGLPShapeRef& ). TGLPhysicalShape * GetPShape() const; { return fPShape; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPShapeRef.h 26394 2008-11-23 14:35:25Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLPShapeRef.html:1521,perform,perform,1521,root/html528/TGLPShapeRef.html,https://root.cern,https://root.cern/root/html528/TGLPShapeRef.html,1,['perform'],['perform']
Performance,"t need to be notified; when the shape is destroyed.; Could also deliver 'change' notifications. Function Members (Methods); public:. TGLPShapeRef(); TGLPShapeRef(TGLPhysicalShape* shape); virtual~TGLPShapeRef(); static TClass*Class(); TGLPhysicalShape*GetPShape() const; virtual TClass*IsA() const; virtual voidPShapeModified(); virtual voidSetPShape(TGLPhysicalShape* shape); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TGLPShapeRef(const TGLPShapeRef&); TGLPShapeRef&operator=(const TGLPShapeRef&). Data Members; protected:. TGLPhysicalShape*fPShapePointer to referenced physical shape. private:. TGLPShapeRef*fNextPSRefInternal pointer to the next reference (used by TGLPhysicalShape directly). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPShapeRef(); Default contructor. TGLPShapeRef(TGLPhysicalShape* shape); Constructor with known shape - reference it. ~TGLPShapeRef(); Destructor - unreference the shape if set. void SetPShape(TGLPhysicalShape* shape); Set the shape. Unreference the old and reference the new.; This is virtual so that sub-classes can perform other tasks; on change. This function should be called first from there. This is also called from destructor of the refereced physical; shape with 0 argument. void PShapeModified(); This is called from physical shape when it is modified.; Sub-classes can override and take appropriate action. TGLPShapeRef(const TGLPShapeRef& ). TGLPShapeRef& operator=(const TGLPShapeRef& ). TGLPhysicalShape * GetPShape() const; { return fPShape; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPShapeRef.h 26394 2008-11-23 14:35:25Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLPShapeRef.html:1521,perform,perform,1521,root/html530/TGLPShapeRef.html,https://root.cern,https://root.cern/root/html530/TGLPShapeRef.html,1,['perform'],['perform']
Performance,"t need to be notified; when the shape is destroyed.; Could also deliver 'change' notifications. Function Members (Methods); public:. TGLPShapeRef(); TGLPShapeRef(TGLPhysicalShape* shape); virtual~TGLPShapeRef(); static TClass*Class(); TGLPhysicalShape*GetPShape() const; virtual TClass*IsA() const; virtual voidPShapeModified(); virtual voidSetPShape(TGLPhysicalShape* shape); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TGLPShapeRef(const TGLPShapeRef&); TGLPShapeRef&operator=(const TGLPShapeRef&). Data Members; protected:. TGLPhysicalShape*fPShapePointer to referenced physical shape. private:. TGLPShapeRef*fNextPSRefInternal pointer to the next reference (used by TGLPhysicalShape directly). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPShapeRef(); Default contructor. TGLPShapeRef(TGLPhysicalShape* shape); Constructor with known shape - reference it. ~TGLPShapeRef(); Destructor - unreference the shape if set. void SetPShape(TGLPhysicalShape* shape); Set the shape. Unreference the old and reference the new.; This is virtual so that sub-classes can perform other tasks; on change. This function should be called first from there. This is also called from destructor of the refereced physical; shape with 0 argument. void PShapeModified(); This is called from physical shape when it is modified.; Sub-classes can override and take appropriate action. TGLPShapeRef(const TGLPShapeRef& ). TGLPShapeRef& operator=(const TGLPShapeRef& ). TGLPhysicalShape * GetPShape() const; { return fPShape; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPShapeRef.h 26394 2008-11-23 14:35:25Z matevz $ » Last generated: 2011-11-03 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLPShapeRef.html:1521,perform,perform,1521,root/html532/TGLPShapeRef.html,https://root.cern,https://root.cern/root/html532/TGLPShapeRef.html,1,['perform'],['perform']
Performance,"t object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TEnum * Find(TListOfEnums::DeclId_t id) const; Return the TEnum corresponding to the Decl 'id' or NULL if it does not; exist. TEnum * Get(TListOfEnums::DeclId_t id, const char* name); Return (after creating it if necessary) the TEnum; describing the enum corresponding to the Decl 'id'. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the dec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfEnums.html:13757,load,loaded,13757,root/html604/TListOfEnums.html,https://root.cern,https://root.cern/root/html604/TListOfEnums.html,1,['load'],['loaded']
Performance,"t of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """"",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TChain.html:39628,load,load,39628,root/html532/TChain.html,https://root.cern,https://root.cern/root/html532/TChain.html,1,['load'],['load']
Performance,"t of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); -- Loop on nentries of this chain starting at firstentry. (NOT IMPLEMENTED). void ls(Option_t* option = """") const; -- List the chain. Long64_t Merge(const char* name, Option_t* option = """"); Merge all the entries in the chain into a new tree in a new file. See important note in the following function ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TChain.html:37422,load,load,37422,root/html528/TChain.html,https://root.cern,https://root.cern/root/html528/TChain.html,2,['load'],['load']
Performance,"t of memory; closing connection"");; 12527 break;; 12528 }; 12529 }; 12530 ; 12531 /* Copy the mask before we shift the queue and destroy it */; 12532 if (mask_len > 0) {; 12533 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12534 } else {; 12535 memset(mask, 0, sizeof(mask));; 12536 }; 12537 ; 12538 /* Read frame payload from the first message in the queue into; 12539 * data and advance the queue by moving the memory in place. */; 12540 DEBUG_ASSERT(body_len >= header_len);; 12541 if (data_len + (uint64_t)header_len > (uint64_t)body_len) {; 12542 mop = buf[0]; /* current mask and opcode */; 12543 /* Overflow case */; 12544 len = body_len - header_len;; 12545 memcpy(data, buf + header_len, len);; 12546 error = 0;; 12547 while ((uint64_t)len < data_len) {; 12548 n = pull_inner(NULL,; 12549 conn,; 12550 (char *)(data + len),; 12551 (int)(data_len - len),; 12552 timeout);; 12553 if (n <= -2) {; 12554 error = 1;; 12555 break;; 12556 } else if (n > 0) {; 12557 len += (size_t)n;; 12558 } else {; 12559 /* Timeout: should retry */; 12560 /* TODO: retry condition */; 12561 }; 12562 }; 12563 if (error) {; 12564 mg_cry_internal(; 12565 conn,; 12566 ""%s"",; 12567 ""Websocket pull failed; closing connection"");; 12568 if (data != mem) {; 12569 mg_free(data);; 12570 }; 12571 break;; 12572 }; 12573 ; 12574 conn->data_len = conn->request_len;; 12575 ; 12576 } else {; 12577 ; 12578 mop = buf[0]; /* current mask and opcode, overwritten by; 12579 * memmove() */; 12580 ; 12581 /* Length of the message being read at the front of the; 12582 * queue. Cast to 31 bit is OK, since we limited; 12583 * data_len before. */; 12584 len = (size_t)data_len + header_len;; 12585 ; 12586 /* Copy the data payload into the data pointer for the; 12587 * callback. Cast to 31 bit is OK, since we; 12588 * limited data_len */; 12589 memcpy(data, buf + header_len, (size_t)data_len);; 12590 ; 12591 /* Move the queue forward len bytes */; 12592 memmove(buf, buf + len, body_len - len);; 12593 ; 12594 /* Ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:365303,queue,queue,365303,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['queue'],['queue']
Performance,"t of memory; closing connection"");; 12528 break;; 12529 }; 12530 }; 12531 ; 12532 /* Copy the mask before we shift the queue and destroy it */; 12533 if (mask_len > 0) {; 12534 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12535 } else {; 12536 memset(mask, 0, sizeof(mask));; 12537 }; 12538 ; 12539 /* Read frame payload from the first message in the queue into; 12540 * data and advance the queue by moving the memory in place. */; 12541 DEBUG_ASSERT(body_len >= header_len);; 12542 if (data_len + (uint64_t)header_len > (uint64_t)body_len) {; 12543 mop = buf[0]; /* current mask and opcode */; 12544 /* Overflow case */; 12545 len = body_len - header_len;; 12546 memcpy(data, buf + header_len, len);; 12547 error = 0;; 12548 while ((uint64_t)len < data_len) {; 12549 n = pull_inner(NULL,; 12550 conn,; 12551 (char *)(data + len),; 12552 (int)(data_len - len),; 12553 timeout);; 12554 if (n <= -2) {; 12555 error = 1;; 12556 break;; 12557 } else if (n > 0) {; 12558 len += (size_t)n;; 12559 } else {; 12560 /* Timeout: should retry */; 12561 /* TODO: retry condition */; 12562 }; 12563 }; 12564 if (error) {; 12565 mg_cry_internal(; 12566 conn,; 12567 ""%s"",; 12568 ""Websocket pull failed; closing connection"");; 12569 if (data != mem) {; 12570 mg_free(data);; 12571 }; 12572 break;; 12573 }; 12574 ; 12575 conn->data_len = conn->request_len;; 12576 ; 12577 } else {; 12578 ; 12579 mop = buf[0]; /* current mask and opcode, overwritten by; 12580 * memmove() */; 12581 ; 12582 /* Length of the message being read at the front of the; 12583 * queue. Cast to 31 bit is OK, since we limited; 12584 * data_len before. */; 12585 len = (size_t)data_len + header_len;; 12586 ; 12587 /* Copy the data payload into the data pointer for the; 12588 * callback. Cast to 31 bit is OK, since we; 12589 * limited data_len */; 12590 memcpy(data, buf + header_len, (size_t)data_len);; 12591 ; 12592 /* Move the queue forward len bytes */; 12593 memmove(buf, buf + len, body_len - len);; 12594 ; 12595 /* Ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:365336,queue,queue,365336,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['queue'],['queue']
Performance,"t of non-default rootmap files loaded; TStringfRootmapLoadPathdynamic load path used for loading rootmap files; TStringfSharedLibslist of shared libraries loaded by G__loadfile; static void*fgSetOfSpecialsset of TObject*s used in CINT variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCint(const char* name, const char* title); Initialize the CINT interpreter interface. ~TCint(); Destroy the CINT interpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableWrappers(bool value = true); Enable call wrappers (also known as stubs) if value is true;; disable if value is false. void EnableAutoLoading(); Enable the automatic loading of shared libraries when a class; is used that is stored in a not yet loaded library. Uses the; information stored in the class/library map (typically; $ROOTSYS/etc/system.rootmap). void EndOfLineAction(); It calls a ""fantom"" method to synchronize user keyboard input; and ROOT prompt line. Bool_t IsLoaded(const char* filename) const; Return true if the file has already been loaded by cint. Int_t Load(const char* filenam, Bool_t system = kFALSE); Load a library file in CINT's memory.; if 'system' is true, the library is never unloaded. void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Load a macro file in CINT's memory. Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line.; If the command is executed and the result of G__process_cmd is 0,; the return value is the int value corresponding to the result of the command; (float and double return values will be truncated). Long_t ProcessLineAsynch(const char* line, TInterpreter::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCint.html:20022,load,loading,20022,root/html526/TCint.html,https://root.cern,https://root.cern/root/html526/TCint.html,2,['load'],"['loaded', 'loading']"
Performance,"t of normalization observables.; 473///; 474/// If not, the cached normalization integral (if any) is deleted; 475/// and a new integral is constructed for use with 'nset'.; 476/// Elements in 'nset' can be discrete and real, but must be lvalues.; 477///; 478/// For functions that declare to be self-normalized by overloading the; 479/// selfNormalized() function, a unit normalization is always constructed.; 480 ; 481bool RooAbsPdf::syncNormalization(const RooArgSet* nset, bool adjustProxies) const; 482{; 483 setActiveNormSet(nset);; 484 ; 485 // Check if data sets are identical; 486 CacheElem* cache = static_cast<CacheElem*>(_normMgr.getObj(nset)) ;; 487 if (cache) {; 488 ; 489 bool nintChanged = (_norm!=cache->_norm.get()) ;; 490 _norm = cache->_norm.get();; 491 ; 492 // In the past, this condition read `if (nintChanged && adjustProxies)`.; 493 // However, the cache checks if the nset was already cached **by content**,; 494 // and not by RooArgSet instance! So it can happen that the normalization; 495 // set object is different, but the integral object is the same, in which; 496 // case it would be wrong to not adjust the proxies. They always have to be; 497 // adjusted when the nset changed, which is always the case when; 498 // `syncNormalization()` is called.; 499 if (adjustProxies) {; 500 // Update dataset pointers of proxies; 501 const_cast<RooAbsPdf*>(this)->setProxyNormSet(nset) ;; 502 }; 503 ; 504 return nintChanged ;; 505 }; 506 ; 507 // Update dataset pointers of proxies; 508 if (adjustProxies) {; 509 const_cast<RooAbsPdf*>(this)->setProxyNormSet(nset) ;; 510 }; 511 ; 512 RooArgSet depList;; 513 getObservables(nset, depList);; 514 ; 515 if (_verboseEval>0) {; 516 if (!selfNormalized()) {; 517 cxcoutD(Tracing) << ClassName() << ""::syncNormalization("" << GetName(); 518 << "") recreating normalization integral "" << endl ;; 519 depList.printStream(ccoutD(Tracing),kName|kValue|kArgs,kSingleLine) ;; 520 } else {; 521 cxcoutD(Tracing) << ClassName() << ""::syncNorm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:18653,cache,cache,18653,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,2,['cache'],"['cache', 'cached']"
Performance,"t of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooChi2Var(const char *name, const char* title, RooAbsReal& func, RooDataHist& hdata,		 const RooCmdArg& arg1,const RooCmdArg& arg2,const RooCmdArg& arg3,		 const RooCmdArg& arg4,const RooCmdArg& arg5,const RooCmdArg& arg6,		 const RooCmdArg& arg7,const RooCmdArg& arg8,const RooCmdArg& arg9); RooChi2Var constructor. Optional arguments taken. DataError() -- Choose between Poisson errors and Sum-of-weights errors; NumCPU() -- Activate parallel processing feature",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChi2Var.html:36467,cache,cache,36467,root/html526/RooChi2Var.html,https://root.cern,https://root.cern/root/html526/RooChi2Var.html,1,['cache'],['cache']
Performance,"t of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataHist& data, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none()); RooChi2Var ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooChi2Var.html:36733,cache,cache,36733,root/html528/RooChi2Var.html,https://root.cern,https://root.cern/root/html528/RooChi2Var.html,1,['cache'],['cache']
Performance,"t of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:34761,cache,cache,34761,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,1,['cache'],['cache']
Performance,"t of workers; TGTextButton*fLogNewdisplay logs button; TProofLog*fProofLogthe log; TGCheckButton*fRawLinesdisplay raw lines button; TGTextButton*fSavesave button; TGNumberEntry*fSessNumrelative index of the session to get; Int_tfSessionIdx; TStringfSessionUrl; TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display logs. 'grep' is set to kTRUE if it is invoked by pressing the; 'Filter' button. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void SetGrepView(); Sets the view of grep filters according to the value of checkboxes. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild the log info for a new entered session. void SetUrl(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofProgressLog.html:23961,Load,LoadBuffer,23961,root/html534/TProofProgressLog.html,https://root.cern,https://root.cern/root/html534/TProofProgressLog.html,2,['Load'],"['Load', 'LoadBuffer']"
Performance,"t of workers; TGTextButton*fLogNewdisplay logs button; TProofLog*fProofLogthe log; TGCheckButton*fRawLinesdisplay raw lines button; TGTextButton*fSavesave button; TGNumberEntry*fSessNumrelative index of the session to get; Int_tfSessionIdx; TStringfSessionUrl; TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display the logs. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild the log info for a new entered session. void SetUrl(const char* url); slots. { fSessionUrl = url; }. » Author: G Ganis, Aug 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofProgressLog.html:23601,Load,LoadBuffer,23601,root/html528/TProofProgressLog.html,https://root.cern,https://root.cern/root/html528/TProofProgressLog.html,6,['Load'],"['Load', 'LoadBuffer']"
Performance,"t only first 8 columns.; 2439/// - If varexp = ""*"" print all columns.; 2440/// - Otherwise a columns selection can be made using ""var1:var2:var3"".; 2441/// See TTreePlayer::Scan for more information.; 2442 ; 2443Long64_t TChain::Scan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); 2444{; 2445 if (LoadTree(firstentry) < 0) {; 2446 return 0;; 2447 }; 2448 return TTree::Scan(varexp, selection, option, nentries, firstentry);; 2449}; 2450 ; 2451////////////////////////////////////////////////////////////////////////////////; 2452/// Set the global branch kAutoDelete bit.; 2453///; 2454/// When LoadTree loads a new Tree, the branches for which; 2455/// the address is set will have the option AutoDelete set; 2456/// For more details on AutoDelete, see TBranch::SetAutoDelete.; 2457 ; 2458void TChain::SetAutoDelete(bool autodelete); 2459{; 2460 if (autodelete) {; 2461 SetBit(kAutoDelete, true);; 2462 } else {; 2463 SetBit(kAutoDelete, false);; 2464 }; 2465}; 2466 ; 2467Int_t TChain::SetCacheSize(Long64_t cacheSize); 2468{; 2469 // Set the cache size of the underlying TTree,; 2470 // See TTree::SetCacheSize.; 2471 // Returns 0 cache state ok (exists or not, as appropriate); 2472 // -1 on error; 2473 ; 2474 Int_t res = 0;; 2475 ; 2476 // remember user has requested this cache setting; 2477 fCacheUserSet = true;; 2478 ; 2479 if (fTree) {; 2480 res = fTree->SetCacheSize(cacheSize);; 2481 } else {; 2482 // If we don't have a TTree yet only record the cache size wanted; 2483 res = 0;; 2484 }; 2485 fCacheSize = cacheSize; // Record requested size.; 2486 return res;; 2487}; 2488 ; 2489////////////////////////////////////////////////////////////////////////////////; 2490/// Reset the addresses of the branch.; 2491 ; 2492void TChain::ResetBranchAddress(TBranch *branch); 2493{; 2494 TChainElement* element = (TChainElement*) fStatus->FindObject(branch->GetName());; 2495 if (element) {; 2496 element->SetBaddress(nullptr);; 2497 }; 2498",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:89007,cache,cacheSize,89007,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,2,['cache'],"['cache', 'cacheSize']"
Performance,"t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooParametricStepFunction&operator=(const RooParametricStepFunction&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooParametricStepFunction.html:23987,optimiz,optimizeCacheMode,23987,root/html602/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html602/RooParametricStepFunction.html,4,['optimiz'],['optimizeCacheMode']
Performance,"t pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that branch is set to a correctly typed conversion buffer in this; RooRealVar. A flag is set that will cause copyCache to copy the; object value from the appropriate conversion buffer instead of; the _value buffer. void fillTreeBranch(TTree& t); Fill the tree branch that associated with this object with its current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooRealVar fundamental object with our properties. The new; object will be created without any fit limits. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& analDeps, 			 const RooArgProxy& a); Utility function for use in getAnalyticalIntegral(). If ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:55918,cache,cache,55918,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,1,['cache'],['cache']
Performance,"t pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that branch is set to a correctly typed conversion buffer in this; RooRealVar. A flag is set that will cause copyCache to copy the; object value from the appropriate conversion buffer instead of; the _value buffer. void fillTreeBranch(TTree& t); Fill the tree branch that associated with this object with its current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooRealVar fundamental object with our properties. The new; object will be created without any fit limits. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Utility function for use in getAnalyticalIntegral(). If",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:56637,cache,cache,56637,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,2,['cache'],['cache']
Performance,"t py); virtual Double_tRooSimultaneous::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooSimultaneous::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooSimultaneous::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual RooDataHist*RooSimultaneous::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__HistFactorySimultaneous.html:11766,cache,cacheList,11766,root/html534/RooStats__HistFactory__HistFactorySimultaneous.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__HistFactorySimultaneous.html,3,['cache'],['cacheList']
Performance,"t query mode; TList*TProof::fRunningDSetsTemporary datasets used for async running; TProofMgr::EServTypeTProof::fServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*TProof::fSlaveslist of all slave servers as in config file; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads. private:. TStringfCacheDirDirectory containing cache of user files; TProofLockPath*fCacheLockCache dir locker; TStringfDataSetDirDirectory containing info about known data sets; TDataSetManager*fDataSetManagerDataset manager; Bool_tfForkStartupStartup N-1 workers forking the first worker; Int_tfNWorkersNumber of workers; TQueryResultManager*fQMgrQuery-result manager; TStringfQueryDirDirectory containing query results and status; TProofLockPath*fQueryLockQuery dir locker; TStringfSandboxPROOF sandbox root dir; TStringfSelectionInternal variable to pass drawing options; TServerSocket*fServSockServer socket to accept call backs; TStringfSockPathUNIX socket path for communication with workers; TStringfVarExpInternal variable to pass drawing options; static Int_tfgWrksMaxMax number of workers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofLite(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Create a PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). Masterurl is of; the form: [proof[s]://]host[:port]. Conffile is the name of the config; file describing the remote PROOF cluster (this argu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofLite.html:24407,cache,cache,24407,root/html530/TProofLite.html,https://root.cern,https://root.cern/root/html530/TProofLite.html,2,['cache'],['cache']
Performance,"t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); virtual Bool_timportWorkspaceHook(RooWorkspace& ws); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistPdf.html:35930,optimiz,optimizeDirtyHook,35930,root/html602/RooHistPdf.html,https://root.cern,https://root.cern/root/html602/RooHistPdf.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"t reported number of bytes read; TList*TEventIter::fPacketslist of packets processed packets; TStringTEventIter::fPathPath to current TDirectory; TSelector*TEventIter::fSelselector to be used; Bool_tTEventIter::fStoptermination of run requested. private:. Long64_tfCacheSizeCache size; Bool_tfDontCacheFilesControl OS caching of read files (Mac Os X only); TList*fFileTreesFiles && Trees currently open; TTree*fTreetree we are iterating over; TTreeCache*fTreeCacheinstance of the tree cache for the tree; Bool_tfTreeCacheIsLearningWhether cache is in learning phase; TStringfTreeNamename of the tree object to iterate over; Bool_tfUseParallelUnzipControl usage of parallel unzip; Bool_tfUseTreeCacheControl usage of the tree cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIterTree(); Default ctor. TEventIterTree(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIterTree(); Destructor. Long64_t GetCacheSize(); Return the size in bytes of the cache, if any; Return -1 if not used. Int_t GetLearnEntries(); Return the number of entries in the learning phase. TTree* GetTrees(TDSetElement* elem); Create a Tree for the main TDSetElement and for all the friends.; Returns the main tree or 0 in case of an error. TTree* Load(TDSetElement* elem, Bool_t& localfile); Load a tree from s TDSetElement. Int_t GetNextPacket(Long64_t& first, Long64_t& num, TEntryList** enl = 0, TEventList** evl = 0); Get loop range. void PreProcessEvent(Long64_t ent); Actions to be done just before processing entry 'entry'.; Called by TProofPlayer. Long64_t GetNextEvent(); Get next event. TEventIterTree(). » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-04 16:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEventIterTree.html:7888,cache,cache,7888,root/html534/TEventIterTree.html,https://root.cern,https://root.cern/root/html534/TEventIterTree.html,3,"['Load', 'cache']","['Load', 'cache']"
Performance,t requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of analytical integration codes; RooObjCacheManager_coefNormMgrCoefficient normalization manager; RooArgSet*_convNormSet! Subset of last normalization that applies to convolutions; RooListProxy_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*_convSetIter! Iterator over _convNormSet; RooRealVar*_convVar! Convolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_t_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above in,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:39281,cache,cache,39281,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,1,['cache'],['cache']
Performance,t requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of analytical integration codes; RooObjCacheManager_coefNormMgrCoefficient normalization manager; RooArgSet*_convNormSet! Subset of last normalization that applies to convolutions; RooListProxy_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*_convSetIter! Iterator over _convNormSet; RooRealVar*_convVar! Convolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_t_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRoo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsAnaConvPdf.html:39663,cache,cache,39663,root/html528/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsAnaConvPdf.html,2,['cache'],['cache']
Performance,t requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooArgSet*_curNormSet!; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProjectedPdf.html:37657,cache,cache,37657,root/html526/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html526/RooProjectedPdf.html,1,['cache'],['cache']
Performance,t requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooArgSet*_curNormSet!; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Pr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProjectedPdf.html:38039,cache,cache,38039,root/html528/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html528/RooProjectedPdf.html,2,['cache'],['cache']
Performance,"t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixT<Element> Determinant() const; Return the matrix determinant. void TMatrixT<Element> Determinant(Double_t& d1, Double_t& d2) const; Return the matrix determinant as d1,d2 where det = d1*TMath::Power(2.0,d2). TMatrixT<Element> &TMatrixT<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixT<Element> &TMatrixT<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant, however upto (6x6); a fast Cramer inversion is used . TMatrixT<Element> &TMatrixT<Element> Transpose(const TMatrixT<double>& source); Transpose matrix source. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v * v^T. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<double>& v1, const TVectorT<double>& v2, double alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v1 * v2^T. Element TMatrixT<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixT<Element> &TMatrixT<Element> NormByColumn(const TVectorT<double>& v, Option_t* option = ""D""); Multiply/divide matrix columns by a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(i) i = 0,fNrows-1 (default); else : b(i,j) = a(i,j)*v(i). TMatrixT<Element> &TMatrixT<Element> NormByRow(const TVectorT<double>& v, Option_t* option = ""D""); Multiply/divide matrix rows with a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(j) i = 0,fNcols-1 (default); else : b(i,j) = a(i,j)*v(j). TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixT<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTSym<Element> &source); Assignment",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixT_double_.html:20281,Perform,Perform,20281,root/html528/TMatrixT_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixT_double_.html,3,['Perform'],['Perform']
Performance,"t scale, RooAbsReal& blindValue); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindUniform.html:24156,cache,cache,24156,root/html602/RooUnblindUniform.html,https://root.cern,https://root.cern/root/html602/RooUnblindUniform.html,2,['cache'],['cache']
Performance,"t sequence. ; Reimplemented from RooAbsArg.; Definition at line 350 of file RooNumConvolution.cxx. ◆ profileData(). const TH2 * RooNumConvolution::profileData ; (; ); const. inline . Definition at line 52 of file RooNumConvolution.h. ◆ redirectServersHook(). bool RooNumConvolution::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursive . ). overrideprotectedvirtual . Intercept server redirects. Throw away cache, as figuring out redirections on the cache is an unsolvable problem. ; Reimplemented from RooAbsReal.; Definition at line 262 of file RooNumConvolution.cxx. ◆ setCallProfiling(). void RooNumConvolution::setCallProfiling ; (; bool ; flag, . Int_t ; nbinX = 40, . Int_t ; nbinCall = 40, . Int_t ; nCallHigh = 1000 . ). Activate call profile if flag is set to true. ; A 2-D histogram is kept that stores the required number of function calls versus the value of x, the convolution variable; All clones of RooNumConvolution objects will keep logging to the histogram of the original class so that performance of temporary object clones, such as used in e.g. fitting, plotting and generating are all logged in a single place.; Function caller should take ownership of profiling histogram as it is not deleted at the RooNumConvolution dtor; Calling this function with flag set to false will deactivate call profiling and delete the profiling histogram ; Definition at line 324 of file RooNumConvolution.cxx. ◆ setCallWarning(). void RooNumConvolution::setCallWarning ; (; Int_t ; threshold = 2000). Activate warning messages if number of function calls needed for evaluation of convolution integral exceeds given threshold. ; Definition at line 302 of file RooNumConvolution.cxx. ◆ setConvolutionWindow(). void RooNumConvolution::setConvolutionWindow ; (; RooAbsReal & ; centerParam, . RooAbsReal & ; widthParam, . double ; widthScaleFactor = 1 . ). Restrict convolution integral to finite range [ x - C - S*W, x ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvolution.html:69551,perform,performance,69551,doc/master/classRooNumConvolution.html,https://root.cern,https://root.cern/doc/master/classRooNumConvolution.html,1,['perform'],['performance']
Performance,"t silent=kFALSE) constTROOT; GetClipboard() constTROOTinline; GetColor(Int_t color) constTROOT; GetConfigFeatures() constTROOTinline; GetConfigOptions() constTROOTinline; GetCutClassName() constTROOTinline; GetDataDir()TROOTstatic; GetDefCanvasName() constTROOTinline; GetDirectory(const char *namecycle, Bool_t printError=false, const char *funcname=""GetDirectory"")TDirectoryvirtual; GetDirLevel()TROOTstatic; GetDocDir()TROOTstatic; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetEditHistograms() constTROOTinline; GetEditorMode() constTROOTinline; GetEtcDir()TROOTstatic; GetExtraInterpreterArgs()TROOTstatic; GetFile() const overrideTROOTinlinevirtual; GetFile(const char *name) constTROOT; GetForceStyle() constTROOTinline; GetFunction(const char *name) constTROOT; GetFunctionTemplate(const char *name)TROOT; GetGeometry(const char *name) constTROOT; GetGitBranch() constTROOTinline; GetGitCommit() constTROOTinline; GetGitDate()TROOT; GetGlobal(const char *name, Bool_t load=kFALSE) constTROOT; GetGlobal(const TObject *obj, Bool_t load=kFALSE) constTROOT; GetGlobalFunction(const char *name, const char *params=nullptr, Bool_t load=kFALSE)TROOT; GetGlobalFunctions()TROOTprotected; GetGlobalFunctionWithPrototype(const char *name, const char *proto=nullptr, Bool_t load=kFALSE)TROOT; GetIconName() constTObjectvirtual; GetIconPath()TROOTstatic; GetIncludeDir()TROOTstatic; GetInterpreter() constTROOTinline; GetKey(const char *, Short_t=9999) constTDirectoryinlinevirtual; GetLibDir()TROOTstatic; GetList() constTDirectoryinlinevirtual; GetListOfBrowsables() constTROOTinline; GetListOfBrowsers() constTROOTinline; GetListOfCanvases() constTROOTinline; GetListOfClasses() constTROOTinline; GetListOfClassGenerators() constTROOTinline; GetListOfCleanups() constTROOTinline; GetListOfClosedObjects() constTROOTinline; GetListOfColors() constTROOTinline; GetListOfDataSets() constTROOTinline; GetListOfEnums(Bool_t load=kFALSE)TROOT; GetListOfFiles() constTROOTinline; GetLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT-members.html:7354,load,load,7354,doc/master/classTROOT-members.html,https://root.cern,https://root.cern/doc/master/classTROOT-members.html,1,['load'],['load']
Performance,"t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; voidRooSimultaneous::initialize(RooAbsCategoryLValue& inIndexCat, map<string,RooAbsPdf*> pdfMap); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__HistFactorySimultaneous.html:37440,optimiz,optimizeDirtyHook,37440,root/html602/RooStats__HistFactory__HistFactorySimultaneous.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__HistFactorySimultaneous.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"t stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions;  TListOfDataMembers (const TListOfDataMembers &)=delete;  Whether the list should contain regular data members or only using decls or both. ;  ; void MapObject (TObject *obj);  Add a pair<id, object> to the map of data members and their ids. ;  ; TListOfDataMembers & operator= (const TListOfDataMembers &)=delete;  ; void UnmapObject (TObject *obj);  Remove a pair<id, object> from the map of data members and their ids. ;  . Private Attributes; TClass * fClass = nullptr;  ; TExMap * fIds = nullptr;  Context of this list. Not owned. ;  ; std::atomic< bool > fIsLoaded {kFALSE};  Represent interpreter state when we last did a full load. ;  ; ULong64_t fLastLoadMarker = 0;  Holder of TDataMember for unloaded DataMembers. ;  ; TDictionary::EMemberSelection fSelection = TDictionary::EMemberSelection::kNoUsingDecls;  Mark whether Load was executed. ;  ; THashList * fUnloaded = nullptr;  Map from DeclId_t to TDataMember*. ;  . Additional Inherited Members;  Protected Types inherited from TList; using TObjLinkPtr_t = std::shared_ptr< TObjLink >;  ; using TObjLinkWeakPtr_t = std::weak_ptr< TObjLink >;  ;  Protected Types inherited from TCollection; enum  EStatusBits { kIsOwner = (1ULL << ( 14 )); , kUseRWLock = (1ULL << ( 16 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TList; TObjLinkPtr_t * DoSort (TObjLinkPtr_t *head, Int_t n);  Sort linked list. ;  ; TObjLink * FindLink (const TObject *obj, Int_t &idx) const;  Returns the TObjLink object that contains object obj. ;  ; void InsertAfter (const TObjLinkPtr_t &newlink, const TObjLinkPtr_t &prev);  Insert a new link in the chain. ;  ; TObjLink * LinkAt (Int_t idx) const;  sorting order (when calling Sort() or for TSortedList) ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfDataMembers.html:20388,Load,Load,20388,doc/master/classTListOfDataMembers.html,https://root.cern,https://root.cern/doc/master/classTListOfDataMembers.html,1,['Load'],['Load']
Performance,"t statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Bool_t_showProgressShow progress indication during evaluation if true; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Double_t_sumWeightGlobal sum of weights needed for normalization; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooDataWeightedAverage(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t showProgress = kFALSE, Bool_t verbose = kTRUE); Constructor of data weighted average of given p.d.f over given data. If nCPU>1 the calculation is parallelized; over multuple processes. If showProgress is true a progress indicator pri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataWeightedAverage.html:41539,cache,cache,41539,root/html534/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html534/RooDataWeightedAverage.html,1,['cache'],['cache']
Performance,"t statistics to use; boolfTmpDoExtended; boolfUsePriorPdfuse a prior for nuisance parameters. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HybridCalculatorOriginal(const char* name = 0); constructor with name and title; set default parameters. HybridCalculatorOriginal(RooAbsPdf& sb_model, RooAbsPdf& b_model, RooArgList& observables, const RooArgSet* nuisance_parameters = 0, RooAbsPdf* prior_pdf = 0, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); HybridCalculatorOriginal constructor without specifying a data set; the user need to specify the models in the S+B case and B-only case,; the list of observables of the model(s) (for MC-generation), the list of parameters; that are marginalised and the prior distribution of those parameters. HybridCalculatorOriginal(RooAbsData& data, RooAbsPdf& sb_model, RooAbsPdf& b_model, const RooArgSet* nuisance_parameters = 0, RooAbsPdf* prior_pdf = 0, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); HybridCalculatorOriginal constructor for performing hypotesis test; the user need to specify the data set, the models in the S+B case and B-only case.; In case of treatment of nuisance parameter, the user need to specify the; the list of parameters that are marginalised and the prior distribution of those parameters. HybridCalculatorOriginal(RooAbsData& data, const RooStats::ModelConfig& sb_model, const RooStats::ModelConfig& b_model, bool GenerateBinned = false, int testStatistics = 1, int ntoys = 1000); Constructor with a ModelConfig object representing the signal + background model and; another model config representig the background only model; a Prior pdf for the nuiscane parameter of the signal and background can be specified in; the s+b model or the b model. If it is specified in the s+b model, the one of the s+b model will be used. ~HybridCalculatorOriginal(); HybridCalculatorOriginal destructor. void SetNullModel(const RooStats::ModelConfig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HybridCalculatorOriginal.html:12077,perform,performing,12077,root/html602/RooStats__HybridCalculatorOriginal.html,https://root.cern,https://root.cern/root/html602/RooStats__HybridCalculatorOriginal.html,2,['perform'],['performing']
Performance,"t textsizeDefinition TGWin32VirtualXProxy.cxx:58; gPad#define gPadDefinition TVirtualPad.h:308; If the text precision is equal to 3, the text size doesn't depend on the pad's dimensions. A given textsize value always generates the same absolute size. The text size (charheight) is given in pixels:; charheight = textsize;; Note that to scale fonts to the same size as the old True Type package a scale factor of 0.93376068 is apply to the text size before drawing.; The text size of any class inheriting from TAttText can be changed using the method SetTextSize and retrieved using the method GetTextSize. Text Font and Precision; The text font code is combination of the font number and the precision. Text font code = 10*fontnumber + precision; fontnumberOption_t Option_t fontnumberDefinition TGWin32VirtualXProxy.cxx:60; Font numbers must be between 1 and 14.; The precision can be:. precision = 0 fast hardware fonts (steps in the size); precision = 1 scalable and rotatable hardware fonts (see below); precision = 2 scalable and rotatable hardware fonts; precision = 3 scalable and rotatable hardware fonts. Text size is given in pixels. The text font and precision of any class inheriting from TAttText can be changed using the method SetTextFont and retrieved using the method GetTextFont. Font quality and speed; When precision 0 is used, only the original non-scaled X11 system fonts are used. The fonts have a minimum (4) and maximum (37) size in pixels. These fonts are fast and are of good quality. Their size varies with large steps and they cannot be rotated. Precision 1 and 2 fonts have a different behaviour depending if the True Type Fonts (TTF) are used or not. If TTF are used, you always get very good quality scalable and rotatable fonts. These days TTF fonts are rendered fast enough and can be used in all cases. How to use True Type Fonts; TTF fonts are used by default. They can be deactivated via the following line in the .rootrc file:; Unix.*.Root.UseTTFonts: false. Lis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAttText.html:8078,scalab,scalable,8078,doc/master/classTAttText.html,https://root.cern,https://root.cern/doc/master/classTAttText.html,3,['scalab'],['scalable']
Performance,"t the parameter values (return values from TF1) ; Implements ROOT::Math::IBaseParam.; Definition at line 100 of file WrappedMultiTF1.h. ◆ SetAndCopyFunction(). template<class T > . void ROOT::Math::WrappedMultiTF1Templ< T >::SetAndCopyFunction ; (; const TF1 * ; f = nullptr). method to set a new function pointer and copy it inside. ; By calling this method the class manages now the passed TF1 pointer ; Definition at line 399 of file WrappedMultiTF1.h. ◆ SetDerivPrecision(). template<class T > . void ROOT::Math::WrappedMultiTF1Templ< T >::SetDerivPrecision ; (; double ; eps). static . precision value used for calculating the derivative step-size h = eps * |x|. ; The default is 0.001, give a smaller in case function changes rapidly ; Definition at line 387 of file WrappedMultiTF1.h. ◆ SetParameters(). template<class T > . void ROOT::Math::WrappedMultiTF1Templ< T >::SetParameters ; (; const double * ; p). inlineoverridevirtual . set parameter values (only the cached one in this class,leave unchanges those of TF1) ; Implements ROOT::Math::IBaseParam.; Definition at line 107 of file WrappedMultiTF1.h. Member Data Documentation. ◆ fDim. template<class T > . unsigned int ROOT::Math::WrappedMultiTF1Templ< T >::fDim. private . Definition at line 188 of file WrappedMultiTF1.h. ◆ fFunc. template<class T > . TF1* ROOT::Math::WrappedMultiTF1Templ< T >::fFunc. private . Definition at line 187 of file WrappedMultiTF1.h. ◆ fLinear. template<class T > . bool ROOT::Math::WrappedMultiTF1Templ< T >::fLinear. private . Definition at line 184 of file WrappedMultiTF1.h. ◆ fOwnFunc. template<class T > . bool ROOT::Math::WrappedMultiTF1Templ< T >::fOwnFunc. private . Definition at line 186 of file WrappedMultiTF1.h. ◆ fPolynomial. template<class T > . bool ROOT::Math::WrappedMultiTF1Templ< T >::fPolynomial. private . Definition at line 185 of file WrappedMultiTF1.h. hist/hist/inc/Math/WrappedMultiTF1.h. ROOTMathWrappedMultiTF1Templ. ROOT master - Reference Guide Generated on Tue Nov 5 2024 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedMultiTF1Templ.html:13557,cache,cached,13557,doc/master/classROOT_1_1Math_1_1WrappedMultiTF1Templ.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedMultiTF1Templ.html,1,['cache'],['cached']
Performance,"t the shared library is rebuilt you can use the ++ syntax:; root[] .L MyScript.C++; To build, load, and execute the function with the same name as the file you can use the .x command. This is the same as executing a named script; you can also provide parameters. The only difference is you need to append a + or a ++.; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; You can select whether the script in compiled with debug symbol or with optimization by appending the letter ‘g’ or ‘O’ after the ‘+’ or ‘++’. Without the specification, the script is compiled with the same level of debugging symbol and optimization as the currently running ROOT executable. For example:; root[] .L MyScript.C++g; will compile MyScript.C with debug symbols; usually this means giving the -g option to compiler.; root[] .L MyScript.C++O; will compile MyScript.C with optimizations; usually this means giving the -O option to compiler. The syntax:; root[] .L MyScript.C++; is using the default optimization level. The initial default is to compile with the same level of optimization as the root executable itself. The default can be changed by:; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; Note that the commands:; root[] .L MyScript.C+g; root[] .L MyScript.C+O; respectively compile MyScript.C with debug and optimization if the library does not exist yet; they will not change the debug and the optimization level if the library already exist and it is up to date. To use ACLiC from compiled code or from inside another macro, we recommend using gROOT->ProcessLine(). For example, in one script you can use ACLiC to compile and load another script.; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); 7.4.2 Setting the Include Path; You can get the include path by typing:; root[] .include; You can append to the include path by typing:; root[] .include $HOME/mypackage/include; In a script you can append to the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:270780,optimiz,optimization,270780,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimization']
Performance,"t this class (as v5 was doing),; 4193 // instead this function must only be called if the definition is (about); 4194 // to be unloaded.; 4195 ; 4196 ResetCaches();; 4197 ; 4198 // We got here because the definition Decl is about to be unloaded.; 4199 if (fState != TClass::kHasTClassInit) {; 4200 if (fStreamerInfo->GetEntries() != 0) {; 4201 fState = TClass::kEmulated;; 4202 } else {; 4203 fState = TClass::kForwardDeclared;; 4204 }; 4205 } else {; 4206 // if the ClassInfo was loaded for a class with a TClass Init and it; 4207 // gets unloaded, should we guess it can be reloaded?; 4208 fCanLoadClassInfo = kTRUE;; 4209 }; 4210}; 4211 ; 4212////////////////////////////////////////////////////////////////////////////////; 4213/// To clean out all caches.; 4214 ; 4215void TClass::ResetCaches(); 4216{; 4217 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4218 ; 4219 // Not owning lists, don't call Delete(), but unload; 4220 if (fData.load()); 4221 (*fData).Unload();; 4222 if (fUsingData.load()); 4223 (*fUsingData).Unload();; 4224 if (fEnums.load()); 4225 (*fEnums).Unload();; 4226 if (fMethod.load()); 4227 (*fMethod).Unload();; 4228 ; 4229 delete fAllPubData; fAllPubData = nullptr;; 4230 ; 4231 if (fBase.load()); 4232 (*fBase).Delete();; 4233 delete fBase.load(); fBase = nullptr;; 4234 ; 4235 if (fRealData); 4236 fRealData->Delete();; 4237 delete fRealData; fRealData=nullptr;; 4238}; 4239 ; 4240////////////////////////////////////////////////////////////////////////////////; 4241/// Resets the menu list to it's standard value.; 4242 ; 4243void TClass::ResetMenuList(); 4244{; 4245 if (fClassMenuList); 4246 fClassMenuList->Delete();; 4247 else; 4248 fClassMenuList = new TList();; 4249 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4250}; 4251 ; 4252////////////////////////////////////////////////////////////////////////////////; 4253/// The ls function lists the contents of a class on stdout. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:159689,load,load,159689,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"t this class (as v5 was doing),; 4260 // instead this function must only be called if the definition is (about); 4261 // to be unloaded.; 4262 ; 4263 ResetCaches();; 4264 ; 4265 // We got here because the definition Decl is about to be unloaded.; 4266 if (fState != TClass::kHasTClassInit) {; 4267 if (fStreamerInfo->GetEntries() != 0) {; 4268 fState = TClass::kEmulated;; 4269 } else {; 4270 fState = TClass::kForwardDeclared;; 4271 }; 4272 } else {; 4273 // if the ClassInfo was loaded for a class with a TClass Init and it; 4274 // gets unloaded, should we guess it can be reloaded?; 4275 fCanLoadClassInfo = kTRUE;; 4276 }; 4277}; 4278 ; 4279////////////////////////////////////////////////////////////////////////////////; 4280/// To clean out all caches.; 4281 ; 4282void TClass::ResetCaches(); 4283{; 4284 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4285 ; 4286 // Not owning lists, don't call Delete(), but unload; 4287 if (fData.load()); 4288 (*fData).Unload();; 4289 if (fUsingData.load()); 4290 (*fUsingData).Unload();; 4291 if (fEnums.load()); 4292 (*fEnums).Unload();; 4293 if (fMethod.load()); 4294 (*fMethod).Unload();; 4295 ; 4296 delete fAllPubData; fAllPubData = nullptr;; 4297 ; 4298 if (fBase.load()); 4299 (*fBase).Delete();; 4300 delete fBase.load(); fBase = nullptr;; 4301 ; 4302 if (fRealData); 4303 fRealData->Delete();; 4304 delete fRealData; fRealData=nullptr;; 4305}; 4306 ; 4307////////////////////////////////////////////////////////////////////////////////; 4308/// Resets the menu list to it's standard value.; 4309 ; 4310void TClass::ResetMenuList(); 4311{; 4312 if (fClassMenuList); 4313 fClassMenuList->Delete();; 4314 else; 4315 fClassMenuList = new TList();; 4316 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4317}; 4318 ; 4319////////////////////////////////////////////////////////////////////////////////; 4320/// The ls function lists the contents of a class on stdout. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:162440,load,load,162440,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"t to the current directory. ;  . Static Public Member Functions; static Bool_t CanDelete ();  static function returning true if ReadBuffer can delete object ;  ; static Bool_t CanOptimize ();  static function returning true if optimization can be on ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TVirtualStreamerInfo * Factory ();  Static function returning a pointer to a new TVirtualStreamerInfo object. ;  ; static TStreamerBasicType * GetElementCounter (const char *countName, TClass *cl);  Get pointer to a TStreamerBasicType in TClass *cl static function. ;  ; static const char * GetElementCounterStart (const char *dmTitle);  Given a comment/title declaring an array counter, for example: ;  ; static Bool_t GetStreamMemberWise ();  Return whether the TStreamerInfos will save the collections in ""member-wise"" order whenever possible. ;  ; static void Optimize (Bool_t opt=kTRUE);  This is a static function. ;  ; static void SetCanDelete (Bool_t opt=kTRUE);  This is a static function. ;  ; static void SetFactory (TVirtualStreamerInfo *factory);  static function: Set the StreamerInfo factory ;  ; static Bool_t SetStreamMemberWise (Bool_t enable=kTRUE);  Set whether the TStreamerInfos will save the collections in ""member-wise"" order whenever possible. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destruct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualStreamerInfo.html:15308,Optimiz,Optimize,15308,doc/master/classTVirtualStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTVirtualStreamerInfo.html,1,['Optimiz'],['Optimize']
Performance,"t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCacheElement(); RooAbsCacheElement(const RooAbsCacheElement&); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. static RooAbsCacheElement::ActionFindConstantNodes; static RooAbsCacheElement::ActionOperModeChange; static RooAbsCacheElement::ActionOptimizeCaching. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). RooAbsCacheElement(); Default constructor. virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Tue Jun 30 14:29:54 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCacheElement.html:2306,optimiz,optimizeCacheMode,2306,root/html602/RooAbsCacheElement.html,https://root.cern,https://root.cern/root/html602/RooAbsCacheElement.html,5,"['cache', 'optimiz']","['cache', 'cacheList', 'optimization', 'optimizeCacheMode']"
Performance,"t tox=kTRUE);  Map Event_t structure to gdk_event structure. ;  ; void MapEventMask (UInt_t &emask, UInt_t &xemask, Bool_t tox=kTRUE);  Map event mask to or from gdk. ;  ; void MapGCValues (GCValues_t &gval, ULong_t &xmask, GdkGCValues &xgval, Bool_t tox=kTRUE);  Map a GCValues_t to a XCGValues structure if tox is true. ;  ; void MapKeySym (UInt_t &keysym, UInt_t &xkeysym, Bool_t tox=kTRUE);  Map to and from X key symbols. ;  ; void MapModifierState (UInt_t &state, UInt_t &xstate, Bool_t tox=kTRUE);  Map modifier key state to or from X. ;  ; void MapSetWindowAttributes (SetWindowAttributes_t *attr, ULong_t &xmask, GdkWindowAttr &xattr);  Map a SetWindowAttributes_t to a GdkWindowAttr structure. ;  ; void PutImage (Int_t offset, Int_t itran, Int_t x0, Int_t y0, Int_t nx, Int_t ny, Int_t xmin, Int_t ymin, Int_t xmax, Int_t ymax, UChar_t *image, Drawable_t id);  Draw image. ;  ; void RemovePixmap (GdkDrawable *pix);  Remove the pixmap pix. ;  ; void RenderString (Int_t x, Int_t y, ETextMode mode);  Perform the string rendering in the pad. ;  ; void SetColor (GdkGC *gc, Int_t ci);  Set the foreground color in GdkGC. ;  ; void SetInput (Int_t inp);  Set input on or off. ;  ; void SetMarkerType (Int_t type, Int_t n, GdkPoint *xy);  Set marker type. ;  . Private Attributes; FT_Vector fAlign;  alignment vector ;  ; TExMap * fColors;  Hash list of colors. ;  ; GdkCursor * fCursors [kNumCursors];  List of cursors. ;  ; Int_t fMaxNumberOfWindows;  Maximum number of windows. ;  ; XWindow_t * fWindows;  List of windows. ;  . Additional Inherited Members;  Public Types inherited from TVirtualX; enum  EBoxMode { kHollow; , kFilled; };  ; enum  EDrawMode { kCopy = 1; , kXor; , kInvert; };  ; enum  ETextMode { kClear; , kOpaque; };  ; enum  ETextSetMode { kCheck; , kLoad; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:50646,Perform,Perform,50646,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['Perform'],['Perform']
Performance,"t tree. The tree name may contain; subdir specification in the form ""subdir/name"".; Returns 0 on success, -1 otherwise. Bool_t ExistsDataSet(const char* uri); Returns kTRUE if 'dataset' described by 'uri' exists, kFALSE otherwise. TMap * GetDataSets(const char* uri = """", const char* = 0); lists all datasets that match given uri. void ShowDataSets(const char* uri = """", const char* = 0); Shows datasets in locations that match the uri; By default shows the user's datasets and global ones. TFileCollection * GetDataSet(const char* uri, const char* = 0); Get a list of TFileInfo objects describing the files of the specified; dataset. Int_t RemoveDataSet(const char* uri, const char* = 0); Remove the specified dataset from the PROOF cluster.; Files are not deleted. Int_t VerifyDataSet(const char* uri, const char* = 0); Verify if all files in the specified dataset are available.; Print a list and return the number of missing files. void ClearDataSetCache(const char* dataset = 0); Clear the content of the dataset cache, if any (matching 'dataset', if defined). void ShowDataSetCache(const char* dataset = 0); Display the content of the dataset cache, if any (matching 'dataset', if defined). void SendInputDataFile(); Make sure that the input data objects are available to the workers in a; dedicated file in the cache; the objects are taken from the dedicated list; and / or the specified file.; If the fInputData is empty the specified file is sent over.; If there is no specified file, a file named ""inputdata.root"" is created locally; with the content of fInputData and sent over to the master.; If both fInputData and the specified file are not empty, a copy of the file; is made locally and augmented with the content of fInputData. Int_t Remove(const char* ref, Bool_t all); Handle remove request. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. TProofLite(const TProofLite& ). void operator=(const TProofLite& ). TProof",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:31229,cache,cache,31229,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,1,['cache'],['cache']
Performance,"t tree. The tree name may contain; subdir specification in the form ""subdir/name"".; Returns 0 on success, -1 otherwise. Bool_t ExistsDataSet(const char* uri); Returns kTRUE if 'dataset' described by 'uri' exists, kFALSE otherwise. TMap * GetDataSets(const char* uri = """", const char* = 0); lists all datasets that match given uri. void ShowDataSets(const char* uri = """", const char* = 0); Shows datasets in locations that match the uri; By default shows the user's datasets and global ones. TFileCollection * GetDataSet(const char* uri, const char* = 0); Get a list of TFileInfo objects describing the files of the specified; dataset. Int_t RemoveDataSet(const char* uri, const char* = 0); Remove the specified dataset from the PROOF cluster.; Files are not deleted. Int_t VerifyDataSet(const char* uri, const char* = 0); Verify if all files in the specified dataset are available.; Print a list and return the number of missing files. void ClearDataSetCache(const char* dataset = 0); Clear the content of the dataset cache, if any (matching 'dataset', if defined). void ShowDataSetCache(const char* dataset = 0); Display the content of the dataset cache, if any (matching 'dataset', if defined). void SendInputDataFile(); Make sure that the input data objects are available to the workers in a; dedicated file in the cache; the objects are taken from the dedicated list; and / or the specified file.; If the fInputData is empty the specified file is sent over.; If there is no specified file, a file named ""inputdata.root"" is created locally; with the content of fInputData and sent over to the master.; If both fInputData and the specified file are not empty, a copy of the file; is made locally and augmented with the content of fInputData. Int_t Remove(const char* ref, Bool_t all); Handle remove request. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. void FindUniqueSlaves(); Add to the fUniqueSlave list the active slaves th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofLite.html:31692,cache,cache,31692,root/html530/TProofLite.html,https://root.cern,https://root.cern/root/html530/TProofLite.html,2,['cache'],['cache']
Performance,"t trees; -> same cuts for signal and background. void PrepareTrainingAndTestTree(TCut sigcut, TCut bkgcut, const TString& splitOpt); prepare the training and test trees. TMVA::MethodBase* BookMethod(TString theMethodName, TString methodTitle, TString theOption = """"); Book a classifier or regression method. TMVA::MethodBase* BookMethod(TMVA::Types::EMVA theMethod, TString methodTitle, TString theOption = """"); books MVA method; the option configuration string is custom for each MVA; the TString field ""theNameAppendix"" serves to define (and distinguish); several instances of a given MVA, eg, when one wants to compare the; performance of various configurations. TMVA::IMethod* GetMethod(const TString& title) const; returns pointer to MVA that corresponds to given method title. void WriteDataInformation(); put correlations of input data and a few (default + user; selected) transformations into the root file. void OptimizeAllMethods(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); iterates through all booked methods and sees if they use parameter tuning and if so..; does just that i.e. calls ""Method::Train()"" for different parameter setttings and; keeps in mind the ""optimal one""... and that's the one that will later on be used; in the main training loop. void TrainAllMethods(); iterates through all booked methods and calls training. void TestAllMethods(). void MakeClass(const TString& methodTitle = """") const; Print predefined help message of classifier; iterate over methods and test. void PrintHelpMessage(const TString& methodTitle = """") const; Print predefined help message of classifier; iterate over methods and test. void EvaluateAllVariables(TString options = """"); iterates over all MVA input varables and evaluates them. void EvaluateAllMethods( void ); iterates over all MVAs that have been booked, and calls their evaluation methods. const char* GetName() const; { return ""Factory""; }. void AddRegressionTree(TTree* tree, Double_t weight = 1.0, TMVA::Types::ETr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__Factory.html:19119,Optimiz,OptimizeAllMethods,19119,root/html530/TMVA__Factory.html,https://root.cern,https://root.cern/root/html530/TMVA__Factory.html,3,['Optimiz'],['OptimizeAllMethods']
Performance,"t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGFrameElementPack(const TGFrameElementPack&); TGFrameElementPack&operator=(const TGFrameElementPack&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TGFrame*TGFrameElement::fFrameframe used in layout; TGLayoutHints*TGFrameElement::fLayoutlayout hints used in layout; TGFrameElementPack*fSplitFE! cached varaible for optimisation; Int_tTGFrameElement::fStateEFrameState defined in TGFrame.h; Float_tfWeightrelative weight. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGFrameElementPack(const TGFrameElementPack& ). TGFrameElementPack& operator=(const TGFrameElementPack& ). TGFrameElementPack(TGFrame* frame, TGLayoutHints* lh = 0, Float_t weight = 1); { }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGFrameElementPack.html:5355,cache,cached,5355,root/html534/TGFrameElementPack.html,https://root.cern,https://root.cern/root/html534/TGFrameElementPack.html,1,['cache'],['cached']
Performance,"t use of gROOT *after* the end of the; 367 // TROOT constructor.; 368 ; 369 // So to delay until after the start of main, we also made sure that none; 370 // of the ROOT code (mostly the dictionary code) used during library loading; 371 // is using gROOT (directly or indirectly).; 372 ; 373 // In practice, the initialization of the interpreter is now delayed until; 374 // the first use gROOT (or gInterpreter) after the start of main (but user; 375 // could easily break this by using gROOT in their library initialization; 376 // code).; 377 ; 378 extern TROOT *gROOTLocal;; 379 ; 380 TROOT *GetROOT1() {; 381 if (gROOTLocal); 382 return gROOTLocal;; 383 static TROOTAllocator alloc;; 384 return gROOTLocal;; 385 }; 386 ; 387 TROOT *GetROOT2() {; 388 static Bool_t initInterpreter = kFALSE;; 389 if (!initInterpreter) {; 390 initInterpreter = kTRUE;; 391 gROOTLocal->InitInterpreter();; 392 // Load and init threads library; 393 gROOTLocal->InitThreads();; 394 }; 395 return gROOTLocal;; 396 }; 397 typedef TROOT *(*GetROOTFun_t)();; 398 ; 399 static GetROOTFun_t gGetROOT = &GetROOT1;; 400 ; 401 static Func_t GetSymInLibImt(const char *funcname); 402 {; 403 const static bool loadSuccess = dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"")? false : 0 <= gSystem->Load(""libImt"");; 404 if (loadSuccess) {; 405 if (auto sym = gSystem->DynFindSymbol(nullptr, funcname)) {; 406 return sym;; 407 } else {; 408 Error(""GetSymInLibImt"", ""Cannot get symbol %s."", funcname);; 409 }; 410 }; 411 return nullptr;; 412 }; 413 ; 414 //////////////////////////////////////////////////////////////////////////////; 415 /// Globally enables the parallel branch processing, which is a case of; 416 /// implicit multi-threading (IMT) in ROOT, activating the required locks.; 417 /// This IMT use case, implemented in TTree::GetEntry, spawns a task for; 418 /// each branch of the tree. Therefore, a task takes care of the reading,; 419 /// decompression and deserialisation of a given branch.; 420 void EnablePa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:13647,Load,Load,13647,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,8,"['Load', 'load']","['Load', 'loadSuccess']"
Performance,"t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistFunc.html:23337,cache,cache,23337,root/html532/RooHistFunc.html,https://root.cern,https://root.cern/root/html532/RooHistFunc.html,1,['cache'],['cache']
Performance,"t values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TVectorD*_frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; TVectorD*_mref; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Roo1DMomentMorphFunction::Setting_setting; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; TIterator*_varItr! do not persist; RooSetProxy_varList; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo1DMomentMorphFunction.html:32760,cache,cache,32760,root/html532/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html532/Roo1DMomentMorphFunction.html,1,['cache'],['cache']
Performance,"t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7260; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetRealDataTRealData * GetRealData(const char *name) constReturn pointer to TRealData element with name ""name"".Definition TClass.cxx:3570; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::ExpandCreateFastvirtual void ExpandCreateFast(Int_t n)Expand or shrink the array to n elements and create the clone objects by calling their default ctor.Definition TClonesArray.cxx:558; TClonesArray::GetClassTClass * GetClass() constDefinition TClonesArray.h:53; TClonesArray::Classstatic TClass * Class(); TCollection::Classstatic TClass * Class(); TCollection::GetNameconst char * GetName() const overrideReturn name of this collection.Definition TCollection.cxx:351; TCollection::GetEntriesvirtual Int_t GetEntries() constDefinition TCollection.h:179; TCollection::Browsevoid Browse(TBrowser *b) overrideBrowse this collection (called by TBrowser).Definition TCollection.cxx:248; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:285526,load,load,285526,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['load'],['load']
Performance,"t will be completely distinct : WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let's guess what it has to do. The most simple algorithm will just loop over all daughters, convert the point from mother to local reference and check if the current chamber contains the point or not. This might be efficient for pads with few chambers, but definitely not for 1000. Fortunately the modeler is smarter than that and create for each volume some optimization structures called voxels (see Voxelization) to minimize the penalty having too many daughters, but if you have 100 pads like this in your geometry you will anyway loose a lot in your tracking performance.; The way out when volumes can be arranged according to simple patterns is the usage of divisions. We will describe them in detail later on. Let's think now at a different situation : instead of 1000 chambers of the same type, we may have several types of chambers. Let's say all chambers are cylindrical and have a wire inside, but their dimensions are different. However, we would like all to be represented by a single volume family, since they have the same properties. ; Definition at line 43 of file TGeoVolume.h. Public Types; enum  EGeoVolumeTypes { ;   kVolumeReplicated = (1ULL << ( 14 )); , kVolumeSelected = (1ULL << ( 15 )); , kVolumeDiv = (1ULL << ( 16 )); , kVolumeOverlap = (1ULL << ( 17 )); , ;   kVolumeImportNodes = (1ULL << ( 18 )); , kVolumeMulti = (1ULL << ( 19 )); , kVoxelsXYZ = (1ULL << ( 20 )); , kVoxelsCyl = (1ULL << ( 21 ));",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:10691,optimiz,optimization,10691,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"t with for above integral; TIterator*_obsIter! Iterator over lowSet; RooListProxy_obsSetLow-side variation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; TIterator*_paramIter! Iterator over paramSet; RooListProxy_paramSetinterpolation parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooJeffreysPrior.html:39610,cache,cache,39610,root/html528/RooJeffreysPrior.html,https://root.cern,https://root.cern/root/html528/RooJeffreysPrior.html,2,['cache'],['cache']
Performance,"t y, Float_t angle, Float_t mgn, const char* text, TVirtualX::ETextMode mode); Draw text using TrueType fonts. If TrueType fonts are not available the; text is drawn with TGX11::DrawText. void DrawText(Int_t x, Int_t y, Float_t angle, Float_t mgn, const wchar_t* text, TVirtualX::ETextMode mode); Draw text using TrueType fonts. If TrueType fonts are not available the; text is drawn with TGX11::DrawText. XImage * GetBackground(Int_t x, Int_t y, UInt_t w, UInt_t h); Get the background of the current window in an XImage. Bool_t IsVisible(Int_t x, Int_t y, UInt_t w, UInt_t h); Test if there is really something to render. void RenderString(Int_t x, Int_t y, TVirtualX::ETextMode mode); Perform the string rendering in the pad.; LayoutGlyphs should have been called before. void SetTextFont(Font_t fontnumber); Set specified font. Int_t SetTextFont(char* fontname, TVirtualX::ETextSetMode mode); Set text font to specified name.; mode : loading flag; mode=0 : search if the font exist (kCheck); mode=1 : search the font and load it if it exists (kLoad); font : font name. Set text font to specified name. This function returns 0 if; the specified font is found, 1 if not. void SetTextSize(Float_t textsize); Set current text size. FontStruct_t LoadQueryFont(const char* font_name); Parses an XLFD name and opens a font. void DeleteFont(FontStruct_t fs); Explicitely delete font structure obtained with LoadQueryFont(). void DeleteGC(GContext_t gc); Explicitely delete a graphics context. FontH_t GetFontHandle(FontStruct_t fs); Return handle to font described by font structure. FontStruct_t GetGCFont(GContext_t gc); Return the font associated with the graphics context gc. void MapGCFont(GContext_t gc, FontStruct_t font); Map the XftFont with the Graphics Context using it. Int_t TextWidth(FontStruct_t font, const char* s, Int_t len); Return length of string in pixels. Size depends on font. void GetFontProperties(FontStruct_t font, Int_t& max_ascent, Int_t& max_descent); Return some font prope",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGX11TTF.html:27840,load,loading,27840,root/html534/TGX11TTF.html,https://root.cern,https://root.cern/root/html534/TGX11TTF.html,2,['load'],"['load', 'loading']"
Performance,"t! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_effEfficiency function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; RooArgSet*_fixedNset! Fixed normalization set overriding default normalization set (if provided); Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooEffProd.html:40089,cache,cache,40089,root/html534/RooEffProd.html,https://root.cern,https://root.cern/root/html534/RooEffProd.html,1,['cache'],['cache']
Performance,"t! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooCategoryProxy_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSimultaneous.html:41086,cache,cache,41086,root/html534/RooSimultaneous.html,https://root.cern,https://root.cern/root/html534/RooSimultaneous.html,3,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"t! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_nNumber of expected events; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooExtendedTerm.html:40087,cache,cache,40087,root/html534/RooExtendedTerm.html,https://root.cern,https://root.cern/root/html534/RooExtendedTerm.html,6,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"t"") {; 439 eng = new TCivetweb(kFALSE);; 440 sarg = ""x""; // civetweb require x before socket name; 441 sarg.Append(arg);; 442 arg = sarg.Data();; 443#endif; 444 } else if (clname == ""https"") {; 445 eng = new TCivetweb(kTRUE);; 446 } else if (clname == ""fastcgi"") {; 447 eng = new TFastCgi();; 448 }; 449 ; 450 if (!eng) {; 451 // ensure that required engine class exists before we try to create it; 452 TClass *engine_class = gROOT->LoadClass(clname.Data());; 453 if (!engine_class); 454 return kFALSE;; 455 ; 456 eng = (THttpEngine *)engine_class->New();; 457 if (!eng); 458 return kFALSE;; 459 }; 460 ; 461 eng->SetServer(this);; 462 ; 463 if (!eng->Create(arg)) {; 464 delete eng;; 465 return kFALSE;; 466 }; 467 ; 468 fEngines.Add(eng);; 469 ; 470 return kTRUE;; 471}; 472 ; 473////////////////////////////////////////////////////////////////////////////////; 474/// Create timer which will invoke ProcessRequests() function periodically; 475///; 476/// Timer is required to perform all actions in main ROOT thread; 477/// Method arguments are the same as for TTimer constructor; 478/// By default, sync timer with 100 ms period is created; 479///; 480/// It is recommended to always use sync timer mode and only change period to; 481/// adjust server reaction time. Use of async timer requires, that application regularly; 482/// calls gSystem->ProcessEvents(). It happens automatically in ROOT interactive shell.; 483/// If milliSec == 0, no timer will be created.; 484/// In this case application should regularly call ProcessRequests() method.; 485///; 486/// Async timer allows to use THttpServer in applications, which does not have explicit; 487/// gSystem->ProcessEvents() calls. But be aware, that such timer can interrupt any system call; 488/// (like malloc) and can lead to dead locks, especially in multi-threaded applications.; 489 ; 490void THttpServer::SetTimer(Long_t milliSec, Bool_t mode); 491{; 492 if (fTimer) {; 493 fTimer->Stop();; 494 fTimer.reset();; 495 }; 496 if (milliS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:15348,perform,perform,15348,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['perform'],['perform']
Performance,"t"");; ; /***; ; ## Setup Dataset(s); ; Define input data file and signal and background trees; ; **/; ; std::unique_ptr<TFile> inputFile{TFile::Open(inputFileName)};; if (!inputFile) {; Error(""TMVA_CNN_Classification"", ""Error opening input file %s - exit"", inputFileName.Data());; return;; }; ; // --- Register the training and test trees; ; auto signalTree = inputFile->Get<TTree>(""sig_tree"");; auto backgroundTree = inputFile->Get<TTree>(""bkg_tree"");; ; if (!signalTree) {; Error(""TMVA_CNN_Classification"", ""Could not find signal tree in file '%s'"", inputFileName.Data());; return;; }; if (!backgroundTree) {; Error(""TMVA_CNN_Classification"", ""Could not find background tree in file '%s'"", inputFileName.Data());; return;; }; ; int nEventsSig = signalTree->GetEntries();; int nEventsBkg = backgroundTree->GetEntries();; ; // global event weights per tree (see below for setting event-wise weights); Double_t signalWeight = 1.0;; Double_t backgroundWeight = 1.0;; ; // You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight);; loader.AddBackgroundTree(backgroundTree, backgroundWeight);; ; /// add event variables (image); /// use new method (from ROOT 6.20 to add a variable array for all image data); loader.AddVariablesArray(""vars"", imgSize);; ; // Set individual event weights (the variables must exist in the original TTree); // for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; // for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; // loader.SetBackgroundWeightExpression( ""weight"" );; ; // Apply additional cuts on the signal and background samples (can be different); TCut mycuts = """"; // for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; TCut mycutb = """"; // for example: TCut mycutb = ""abs(var1)<0.5"";; ; // Tell the factory how to use the training and testing events; //; // If no numbers of events are given, half of the events in the tree are used; // for training, and the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:51731,load,loader,51731,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['load'],['loader']
Performance,"t"",""Track.h;vector"");; gInterpreter->GenerateDictionary(""myclass"",""myheader.h"");. To generate the dictionary from a Makefile, you can use the following rule to generate a dictionary for the headers $(HEADERS) and a library containing the dictionary and the compiled $(SOURCES):. MyDict.cxx: $(HEADERS) Linkdef.h; [TAB] rootcint -f $@ -c $(CXXFLAGS) -p $^. libMyLib.so: MyDict.cxx $(SOURCES); [TAB] g++ -shared -o$@ `root-config --ldflags` $(CXXFLAGS) -I$(ROOTSYS)/include $^. See Interacting with Shared Libraries: rootcint for more details. ; . How can I fix the problem leading to :Error: Can't call vector<...>::push_back . This usually indicates that some classes dictionary refer and/or use this particular instance of std::vector. To solve the problem, you will need to generate a dictionary for this particular instance. With ROOT v5.27/06 and above this can be done by executing:gInterpreter->GenerateDictionary(""vector<Track&gt"",""Track.h;vector"");. With older version of ROOT ; this can simply be done using ACLiC and a simple loader.C script:// File loader.C; #include ; #include ; #ifdef __MAKECINT__; #pragma link C++ class vector<Track>+;; #endifI am defining a vector for my custom type (for example Track) in a root macro but when I push_back a Track object in the vector, CINT complains. e.g.; vector testVector;; Track obj;; ...; testVector.push_back(obj);; gives:Error: Can't call vector::push_back(timeStamp) in current scope MyAnalysisMasterTreeMaker.C:358:; Possible candidates are...; (in vector); *** Interpreter error recovered ***. Although, if I use a vector or vector or vector push_back works fine.; ; . What is the difference between a TFolder and a TDirectory? . TFolder manages a hierrachy of objects in memory.; TDirectory is doing it for a file.; One can save the TFolder structure to a directory in a file.; ; . Ubuntu: No backtrace (stacktrace) when ROOT crashes . Enable /proc/sys/kernel/yama/ptrace_scope or edit /etc/sysctl.d/10-ptrace.conf. See this blog entry ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/faq-page.html:3693,load,loader,3693,d/faq-page.html,https://root.cern,https://root.cern/d/faq-page.html,1,['load'],['loader']
Performance,"t& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual RooAbsGenContext*autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; virtual RooAbsGenContext*binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsPdf.html:6342,Cache,CacheModeRooAbsArg,6342,root/html604/RooAbsPdf.html,https://root.cern,https://root.cern/root/html604/RooAbsPdf.html,1,['Cache'],['CacheModeRooAbsArg']
Performance,"t& nset) const; virtual voidRooAbsReal::attachToTree(TTree& t, Int_t bufSize = 32000); virtual const char*RooAbsCachedReal::binningName() const; TStringRooAbsCachedReal::cacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidRooAbsCachedReal::clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); virtual RooAbsCachedReal::FuncCacheElem*RooAbsCachedReal::createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voidRooAbsCachedReal::disableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tevaluate() const; virtual voidfillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; static Bool_tRooAbsArg::flipAClean(); RooAbsCachedReal::FuncCacheElem*RooAbsCachedReal::getCache(const RooArgSet* nset) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedReal.html:25870,cache,cacheFunc,25870,root/html526/RooCachedReal.html,https://root.cern,https://root.cern/root/html526/RooCachedReal.html,3,['cache'],['cacheFunc']
Performance,"t& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); Print tree structure of expression tree on stdout, or to file if filename is specified.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); Print tree struct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:30944,perform,perform,30944,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,4,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"t& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent, const char* filename, const char* namePat, RooAbsArg* client); Print tree structure of expression tree on stdout, or to file if filename is specified.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printCompactTree(ostream& os, const char* indent, const char* namePat, RooAbsArg* client); Print tree structure of expression tree on give",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:30741,perform,perform,30741,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"t& slicePosition) const; Fill a slice of cachePdf with the output of the FFT convolution calculation. Double_t* scanPdf(RooRealVar& obs, RooAbsPdf& pdf, const RooDataHist& hist, const RooArgSet& slicePos, Int_t& N, Int_t& N2, Int_t& zeroBin, Double_t shift) const; Scan the values of 'pdf' in observable 'obs' using the bin values stored in 'hist' at slice position 'slicePos'; N is filled with the number of bins defined in hist, N2 is filled with N plus the number of buffer bins; The return value is an array of doubles of length N2 with the sampled values. The caller takes ownership; of the array. RooArgSet* actualObservables(const RooArgSet& nset) const; Return the observables to be cached given the normalization set nset. If the cache observables is in nset then this is; - the convolution observable plus; - any member of nset that is either a RooCategory,; - or was previously specified through setCacheObservables(). In case the cache observable is _not_ in nset, then it is; - the convolution observable plus; - all member of nset are observables of this p.d.f. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters on which the cache depends given normalization; set nset. For this p.d.f these are the parameters of the input p.d.f.; but never the convolution variable, it case it is not part of nset. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; Return p.d.f. observable (which can be a function) to substitute given; p.d.f. observable. Substitute x by xprime if xprime is set. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Create appropriate generator context for this convolution. If both input p.d.f.s support; internal generation, if it is safe to use them and if no observables other than the convolution; observable are requested for generation, use the specialized convolution generator context; which implements a smearing strategy in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:48825,cache,cache,48825,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,7,['cache'],['cache']
Performance,"t& theEvent); voidTObject::MakeZombie(); voidresampleData(Double_t& ratio). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. UInt_t_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendMode_extendModeExtended mode capabilities of p.d.f.; RooDataSet*_genData! Data being generated; Bool_t_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_t_nextProtoIndexNext prototype event to load according to LUT; TString_normRangeNormalization range of pdf; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet * generate(Int_t nEvents = 0); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of events, if non-zero. The returned; dataset belongs to the caller. Return zero in case of an error.; Generation of individual events is delegated to a virtual generateEvent(); method. A virtual initGenerator() meth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsGenContext.html:7579,load,load,7579,root/html528/RooAbsGenContext.html,https://root.cern,https://root.cern/root/html528/RooAbsGenContext.html,1,['load'],['load']
Performance,"t& theEvent); voidTObject::MakeZombie(); voidresampleData(Double_t& ratio). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. UInt_t_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendMode_extendModeExtended mode capabilities of p.d.f.; RooDataSet*_genData! Data being generated; Bool_t_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_t_nextProtoIndexNext prototype event to load according to LUT; TString_normRangeNormalization range of pdf; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Int_t nEvents = 0); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of events, if non-zero. The returned; dataset belongs to the ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsGenContext.html:7741,load,load,7741,root/html530/RooAbsGenContext.html,https://root.cern,https://root.cern/root/html530/RooAbsGenContext.html,1,['load'],['load']
Performance,"t& theEvent); voidTObject::MakeZombie(); voidresampleData(Double_t& ratio). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. UInt_t_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendMode_extendModeExtended mode capabilities of p.d.f.; RooDataSet*_genData! Data being generated; Bool_t_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_t_nextProtoIndexNext prototype event to load according to LUT; TString_normRangeNormalization range of pdf; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Int_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of even",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsGenContext.html:7842,load,load,7842,root/html532/RooAbsGenContext.html,https://root.cern,https://root.cern/root/html532/RooAbsGenContext.html,1,['load'],['load']
Performance,"t&operator=(const TGText&); Bool_tSetCurrentRow(Long_t row); TGText(const TGText&). Data Members; protected:. Long_tfColCountnumber of columns in current line; TGTextLine*fCurrentcurrent line; Long_tfCurrentRowcurrent row number; TStringfFilenamename of opened file ("""" if open buffer); TGTextLine*fFirstfirst line of text; Bool_tfIsSavedfalse if text needs to be saved; Long_tfLongestLinelength of longest line; Long_tfRowCountnumber of rows. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGText(const TGText& ); copy constructor. TGText& operator=(const TGText& ); assignment operator. void Init(); Common initialization method. TGText(); Create default (empty) text buffer. TGText(TGText* text); Create text buffer and initialize with other text buffer. TGText(const char* string); Create text buffer and initialize with single line string. ~TGText(); Destroy text buffer. void Clear(); Clear text buffer. Bool_t Load(const char* fn, Long_t startpos = 0, Long_t length = -1); Load text from file fn. Startpos is the begin from where to; load the file and length is the number of characters to read; from the file. Bool_t LoadBuffer(const char* txtbuf); Load a 0 terminated buffer. Lines will be split at '\n'. Bool_t Save(const char* fn); Save text buffer to file fn. Bool_t Append(const char* fn); Append buffer to file fn. Bool_t DelChar(TGLongPosition pos); Delete character at specified position pos. Bool_t InsChar(TGLongPosition pos, char c); Insert character c at the specified position pos. char GetChar(TGLongPosition pos); Get character a position pos. If charcater not valid return -1. Bool_t DelText(TGLongPosition start, TGLongPosition end); Delete text between start and end positions. Returns false in; case of failure (start and end not being within bounds). Bool_t InsText(TGLongPosition ins_pos, TGText* src, TGLongPosition start_src, TGLongPosition end_src); Insert src text from start_src to end_src into text at position ins_pos.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGText.html:2992,Load,Load,2992,root/html602/TGText.html,https://root.cern,https://root.cern/root/html602/TGText.html,4,['Load'],['Load']
Performance,"t' - initial width/height. TGLViewer(TVirtualPad* pad); gl-embedded viewer's ctor; Construct the viewer object, with following arguments:; 'pad' - external pad viewer is bound to; 'x', 'y' - initial top left position; 'width', 'height' - initial width/height. void InitSecondaryObjects(); Common initialization. ~TGLViewer(); Destroy viewer object. void PadPaint(TVirtualPad* pad); Entry point for updating viewer contents via VirtualViewer3D; interface.; We search and forward the request to appropriate TGLScenePad.; If it is not found we create a new TGLScenePad so this can; potentially also be used for registration of new pads. void UpdateScene(Bool_t redraw = kTRUE); Force update of pad-scenes. Eventually this could be generalized; to all scene-types via a virtual function in TGLSceneBase. void ResetCurrentCamera(); Resets position/rotation of current camera to default values. void SetupCameras(Bool_t reset); Setup cameras for current bounding box. void PostSceneBuildSetup(Bool_t resetCameras); Perform post scene-build setup. void InitGL(); Initialise GL state. void RequestDraw(Short_t LOD = TGLRnrCtx::kLODMed); Post request for redraw of viewer at level of detail 'LOD'; Request is directed via cross thread gVirtualGL object. void SetupClipObject(); Setup clip-object. Protected virtual method. void PreRender(); Initialize objects that influence rendering.; Called before every render. void PostRender(); Restore state set in PreRender().; Called after every render. void DoDraw(Bool_t swap_buffers = kTRUE); Draw out the viewer. void DoDrawMono(Bool_t swap_buffers); Draw out in monoscopic mode. void DoDrawStereo(Bool_t swap_buffers); Draw out in stereoscopic mode. Bool_t SavePicture(); Save current image using the defualt file name which can be set; via SetPictureFileName() and defaults to ""viewer.jpg"".; Really useful for the files ending with 'gif+'. Bool_t SavePicture(const TString& fileName); Save current image in various formats (gif, gif+, jpg, png, eps, pdf).; 'gif+",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLViewer.html:23913,Perform,Perform,23913,root/html528/TGLViewer.html,https://root.cern,https://root.cern/root/html528/TGLViewer.html,3,['Perform'],['Perform']
Performance,"t' - initial width/height. TGLViewer(TVirtualPad* pad); gl-embedded viewer's ctor; Construct the viewer object, with following arguments:; 'pad' - external pad viewer is bound to; 'x', 'y' - initial top left position; 'width', 'height' - initial width/height. void InitSecondaryObjects(); Common initialization. ~TGLViewer(); Destroy viewer object. void PadPaint(TVirtualPad* pad); Entry point for updating viewer contents via VirtualViewer3D; interface.; We search and forward the request to appropriate TGLScenePad.; If it is not found we create a new TGLScenePad so this can; potentially also be used for registration of new pads. void UpdateScene(Bool_t redraw = kTRUE); Force update of pad-scenes. Eventually this could be generalized; to all scene-types via a virtual function in TGLSceneBase. void ResetCurrentCamera(); Resets position/rotation of current camera to default values. void SetupCameras(Bool_t reset); Setup cameras for current bounding box. void PostSceneBuildSetup(Bool_t resetCameras); Perform post scene-build setup. void InitGL(); Initialise GL state. void RequestDraw(Short_t LOD = TGLRnrCtx::kLODMed); Post request for redraw of viewer at level of detail 'LOD'; Request is directed via cross thread gVirtualGL object. void SetupClipObject(); Setup clip-object. Protected virtual method. void PreRender(); Initialize objects that influence rendering.; Called before every render. void Render(); Normal rendering, used by mono and stereo rendering. void PostRender(); Restore state set in PreRender().; Called after every render. void DoDraw(Bool_t swap_buffers = kTRUE); Draw out the viewer. void DoDrawMono(Bool_t swap_buffers); Draw out in monoscopic mode. void DoDrawStereo(Bool_t swap_buffers); Draw out in stereoscopic mode. Bool_t SavePicture(); Save current image using the default file name which can be set; via SetPictureFileName() and defaults to ""viewer.jpg"".; Really useful for the files ending with 'gif+'. Bool_t SavePicture(const TString& fileName); Save curr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLViewer.html:24463,Perform,Perform,24463,root/html534/TGLViewer.html,https://root.cern,https://root.cern/root/html534/TGLViewer.html,3,['Perform'],['Perform']
Performance,"t','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t HasCounter () const;  ; virtual void Init (TVirtualStreamerInfo *obj=nullptr);  Initliaze the element. ;  ; virtual Bool_t IsaPointer () const;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ;  ; void ls (Option_t *option="""") const override;  Print the content of the element. ;  ; virtual void SetArrayDim (Int_t dim);  Set number of array dimensions. ;  ; virtual void SetMaxIndex (Int_t dim, Int_t max);  set maximum index for array with dimension dim ;  ; virtual void SetNewClass (TClass *cl);  ; virtual void SetNewType (Int_t dtype);  ; virtual void SetOffset (Int_t offset);  ; virtual void SetSize (Int_t dsize);  ; virtual void SetStreamer (TMemberStreamer *streamer);  set pointer to Streamer function for this element ;  ; virtual void SetTObjectOffset (Int_t tobjoffset);  ; virtual void SetType (Int_t dtype);  ; virtual void SetTypeName (const char *name);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Update (const TClass *oldClass, TClass *newClass);  function called by the TClass constructor when replacing an emulated class by the real class ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerString.html:3215,cache,cache,3215,doc/master/classTStreamerString.html,https://root.cern,https://root.cern/doc/master/classTStreamerString.html,1,['cache'],['cache']
Performance,"t()) { ... } ; Definition at line 216 of file TTreeReader.h. ◆ Notify(). bool TTreeReader::Notify ; (; ). overridevirtual . Notify director and values of a change in tree. ; Called from TChain and TTree's LoadTree. TTreeReader registers its fNotify data member with the TChain/TTree which in turn leads to this method being called upon the execution of LoadTree. ; Reimplemented from TObject.; Definition at line 323 of file TTreeReader.cxx. ◆ RegisterValueReader(). bool TTreeReader::RegisterValueReader ; (; ROOT::Internal::TTreeReaderValueBase * ; reader). protected . Add a value reader for this tree. ; Definition at line 858 of file TTreeReader.cxx. ◆ Restart(). void TTreeReader::Restart ; (; ). Restart a Next() loop from entry 0 (of TEntryList index 0 of fEntryList is set). ; Definition at line 571 of file TTreeReader.cxx. ◆ SetEntriesRange(). TTreeReader::EEntryStatus TTreeReader::SetEntriesRange ; (; Long64_t ; beginEntry, . Long64_t ; endEntry . ). Set the range of entries to be loaded by Next(); end will not be loaded. ; If end <= begin, end is ignored (set to -1, i.e. will run on all entries from begin onwards).; Example:; reader.SetEntriesRange(3, 5);; while (reader.Next()) {; // Will load entries 3 and 4.; }; Note that if a TEntryList is present, beginEntry and endEntry refer to the beginEntry-th/endEntry-th entries of the TEntryList (or the main TEntryList in case it has sub-entrylists). In other words, SetEntriesRange can be used to only loop over part of the TEntryList, but not to further restrict the actual TTree/TChain entry numbers considered.; Parameters. beginEntryThe first entry to be loaded by Next(). ; endEntryThe entry where Next() will return false, not loading it. . Definition at line 533 of file TTreeReader.cxx. ◆ SetEntry(). EEntryStatus TTreeReader::SetEntry ; (; Long64_t ; entry). inline . Set the next entry (or index of the TEntryList if that is set). ; Parameters. entryIf not TEntryList is set, the entry is a global entry (i.e. not the entry",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:31408,load,loaded,31408,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,2,['load'],['loaded']
Performance,"t(). void TFileCacheRead::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; The format is: ******TreeCache statistics for file: cms2.root ****** Reading............................: 72761843 bytes in 7 transactions Readahead..........................: 256000 bytes with overhead = 0 bytes Average transaction................: 10394.549000 Kbytes Number of blocks in current cache..: 210, total size: 6280352; If option = ""a"" the list of blocks in the cache is printed NB: this function is automatically called by TTreeCache::Print ; Reimplemented from TObject.; Reimplemented in TTreeCache, and TTreeCacheUnzip.; Definition at line 326 of file TFileCacheRead.cxx. ◆ ReadBuffer(). Int_t TFileCacheRead::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Read buffer at position pos. ; If pos is in the list of prefetched blocks read from fBuffer, otherwise need to make a normal read from file. Returns -1 in case of read error, 0 in case not in cache, 1 in case read from cache. ; Reimplemented in TTreeCache.; Definition at line 364 of file TFileCacheRead.cxx. ◆ ReadBufferExt(). Int_t TFileCacheRead::ReadBufferExt ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). virtual . Reimplemented in TTreeCacheUnzip.; Definition at line 382 of file TFileCacheRead.cxx. ◆ ReadBufferExtNormal(). Int_t TFileCacheRead::ReadBufferExtNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). virtual . Base function for ReadBuffer. ; Also gives out the position of the block in the internal buffer. This helps TTreeCacheUnzip to avoid doing twice the binary search. ; Definition at line 454 of file TFileCacheRead.cxx. ◆ ReadBufferExtPrefetch(). Int_t TFileCacheRead::ReadBufferExtPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). virtual . prefetch the first block ; Definition at line 394 of file TFileCacheRead.cxx. ◆ SecondPrefetch(). void TFileCacheRead::SecondPref",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheRead.html:21931,cache,cache,21931,doc/master/classTFileCacheRead.html,https://root.cern,https://root.cern/doc/master/classTFileCacheRead.html,2,['cache'],['cache']
Performance,"t(); ; frame3 = x.frame(); data.plotOn(frame3); modelsum.plotOn(frame3); modelsum.plotOn(frame3, VisualizeError=r3); modelsum.paramOn(frame3, Label=""S+B fit with RooAddPdf"", Layout=(0.3, 0.95)); frame3.Draw(); ; c.Draw(); ; c.SaveAs(""rf204b_extendedLikelihood_rangedFit.png""); [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'LEFT' created with bounds [10,20]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'RIGHT' created with bounds [60,100]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'FULL' created with bounds [10,100]; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_extmodel_modelData' created with bounds [10,20]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(extmodel) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_extmodel_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; RooRealVar::N = 3395.66 +/- 58.2751 L(0 - 20000) ; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_LEFT' created with bounds [10,20]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_RIGHT' created with bounds [60,100]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_over_model_Int[x|LEFT,RIGHT]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_over_model_Int[x|LEFT,RIGHT]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimizati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8py.html:8087,optimiz,optimization,8087,doc/master/rf204b__extendedLikelihood__rangedFit_8py.html,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8py.html,2,['optimiz'],['optimization']
Performance,"t(); RooExpensiveObjectCache::ExpensiveObjectExpensiveObject(const RooExpensiveObjectCache::ExpensiveObject&); RooExpensiveObjectCache::ExpensiveObjectExpensiveObject(Int_t uid, const RooExpensiveObjectCache::ExpensiveObject& other); RooExpensiveObjectCache::ExpensiveObjectExpensiveObject(Int_t uid, const char* ownerName, TObject& payload, TIterator* paramIter); virtual TClass*IsA() const; Bool_tmatches(TClass* tc, const RooArgSet& params); RooExpensiveObjectCache::ExpensiveObject&operator=(const RooExpensiveObjectCache::ExpensiveObject&); const char*ownerName() const; const TObject*payload() const; TObject*payload(); voidprint(); voidsetPayload(TObject* obj); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Int_tuid() const. Data Members; protected:. map<TString,Int_t>_catRefParamsNames and values of discrete-valued reference parameters ; TString_ownerNameName of RooAbsArg object that is associated to cache contents; TObject*_payloadPayload; map<TString,Double_t>_realRefParamsNames and values of real-valued reference parameters; Int_t_uidUnique element ID ;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ExpensiveObject(Int_t uid, const char* ownerName, TObject& payload, TIterator* paramIter); Construct ExpensiveObject oject for inPayLoad and store reference values; for all RooAbsReal and RooAbsCategory parameters in params. ExpensiveObject(Int_t uid, const RooExpensiveObjectCache::ExpensiveObject& other). ~ExpensiveObject(). Bool_t matches(TClass* tc, const RooArgSet& params); Check object type ;. void print(). ExpensiveObject(); { _payload = 0 ; }. ExpensiveObject(Int_t uid, const char* ownerName, TObject& payload, TIterator* paramIter). Int_t uid() const; { return _uid ; }. const TObject* payload(); { return _payload ; }. TObject* payload(); { return _payload ; }. void setPayload(TObject* obj); { _payload = obj ; }. const char* ownerName(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooExpensiveObjectCache__ExpensiveObject.html:1831,cache,cache,1831,root/html526/RooExpensiveObjectCache__ExpensiveObject.html,https://root.cern,https://root.cern/root/html526/RooExpensiveObjectCache__ExpensiveObject.html,1,['cache'],['cache']
Performance,"t();; 449 }; 450 ; 451 // If not create it now; 452 RooArgSet depList;; 453 getObservables(iset, depList);; 454 ; 455 // Normalization is always over all pdf components. Overriding the global; 456 // component selection temporarily makes all RooRealIntegrals created during; 457 // that time always include all components.; 458 GlobalSelectComponentRAII globalSelComp(true);; 459 RooAbsReal* norm = std::unique_ptr<RooAbsReal>{createIntegral(depList,*nset, *getIntegratorConfig(), RooNameReg::str(rangeName))}.release();; 460 ; 461 // Store it in the cache; 462 _normMgr.setObj(nset,iset,new CacheElem(*norm),rangeName) ;; 463 ; 464 // And return the newly created integral; 465 return norm ;; 466}; 467 ; 468 ; 469 ; 470////////////////////////////////////////////////////////////////////////////////; 471/// Verify that the normalization integral cached with this PDF; 472/// is valid for given set of normalization observables.; 473///; 474/// If not, the cached normalization integral (if any) is deleted; 475/// and a new integral is constructed for use with 'nset'.; 476/// Elements in 'nset' can be discrete and real, but must be lvalues.; 477///; 478/// For functions that declare to be self-normalized by overloading the; 479/// selfNormalized() function, a unit normalization is always constructed.; 480 ; 481bool RooAbsPdf::syncNormalization(const RooArgSet* nset, bool adjustProxies) const; 482{; 483 setActiveNormSet(nset);; 484 ; 485 // Check if data sets are identical; 486 CacheElem* cache = static_cast<CacheElem*>(_normMgr.getObj(nset)) ;; 487 if (cache) {; 488 ; 489 bool nintChanged = (_norm!=cache->_norm.get()) ;; 490 _norm = cache->_norm.get();; 491 ; 492 // In the past, this condition read `if (nintChanged && adjustProxies)`.; 493 // However, the cache checks if the nset was already cached **by content**,; 494 // and not by RooArgSet instance! So it can happen that the normalization; 495 // set object is different, but the integral object is the same, in which; 496 // ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:17839,cache,cached,17839,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['cache'],['cached']
Performance,"t();; root [] ? }; root [] ? }; TLine X1=0.000000 Y1=1.000000 X2=0.000000 Y2=0.000000; TLine X1=1.000000 Y1=2.000000 X2=0.000000 Y2=0.000000; TLine X1=2.000000 Y1=3.000000 X2=0.000000 Y2=0.000000; TLine X1=3.000000 Y1=4.000000 X2=0.000000 Y2=0.000000; TLine X1=4.000000 Y1=5.000000 X2=0.000000 Y2=0.000000; root [] .q; Here we note:. A multi-line command starts with a { and ends with a }.; Inside continuation, every line has to be correctly terminated with a ; (like in ""real’’ C++).; All objects are created in global scope.; There is no way to back up; you are better off writing a script.; Use .q to exit root. 7.2 Feeding Sources Files To ROOT: C++ Scripts; ROOT script files (often called “Macros”) contain pure C++ code. They can contain a simple sequence of statements like in the multi command line example given above, but also arbitrarily complex class and function definitions.; The most frequent interaction with the ROOT prompt uses .x to “run” a file:; root [] .x myScript.C; This loads myScript.C into the interpreter and calls the function myScript(). You can pass arguments using .x myScript.C(12, ""A String"").; Alternatively you can load the script and then run a function explicitly:; root [] .L myScript.C; root [] myScript(); The above is equivalent to .x myScript.C.; In a named script, the objects created on the stack are deleted when the function exits. In a common scenario you create a histogram in a named script on the stack. You draw the histogram, but when the function exits the canvas is empty and the histogram has disappeared. To avoid the histogram from disappearing you can create it on the heap (by using new). This will leave the histogram object intact, but the pointer in the named script scope will be “gone”. Since histograms (and trees) are added to the list of objects in the current directory, you can always retrieve them to delete them if needed.; root[] TH1F *h = (TH1F*)gDirectory->Get(""myHist""); // or; root[] TH1F *h = (TH1F*)gDirectory->GetList()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:263443,load,loads,263443,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loads']
Performance,"t(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf104_classfactory.png""); (MyPdfV3) An instance of MyPdfV3.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[y]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[y]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(GenPdf_over_GenPdf_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_GenPdf_over_GenPdf_Int[x]_GenPdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(GenPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf104_classfactory.py. tutorialsroofitrf104_classfactory.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf104__classfactory_8py.html:4005,optimiz,optimization,4005,doc/master/rf104__classfactory_8py.html,https://root.cern,https://root.cern/doc/master/rf104__classfactory_8py.html,4,['optimiz'],['optimization']
Performance,"t(TH1::kNoStats);; 1150 for (Int_t i=0;i<5000;i++) {; 1151 double x,y;; 1152 gRandom->Rannor(x,y);; 1153 if(x>0 && y>0) h1->Fill(x,y,4);; 1154 if(x<0 && y<0) h2->Fill(x,y,3);; 1155 if(x>0 && y<0) h3->Fill(x,y,2);; 1156 if(x<0 && y>0) h4->Fill(x,y,1);; 1157 }; 1158 h1->Draw(""colz"");; 1159 h2->Draw(""col same"");; 1160 h3->Draw(""col same"");; 1161 h4->Draw(""col same"");; 1162}; 1163End_Macro; 1164 ; 1165The option `COL` can be combined with the option `POL`:; 1166 ; 1167Begin_Macro(source); 1168{; 1169 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 1170 auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; 1171 float px, py;; 1172 for (Int_t i = 0; i < 25000; i++) {; 1173 gRandom->Rannor(px,py);; 1174 hcol1->Fill(px,py);; 1175 }; 1176 hcol1->Draw(""COLZPOL"");; 1177}; 1178End_Macro; 1179 ; 1180\since **ROOT version 6.07/03:**; 1181 ; 1182A second rendering technique is also available with the COL2 and COLZ2 options.; 1183 ; 1184These options provide potential performance improvements compared to the standard; 1185COL option. The performance comparison of the COL2 to the COL option depends on; 1186the histogram and the size of the rendering region in the current pad. In general,; 1187a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; 1188faster with the COL option.; 1189 ; 1190However, for larger histograms (approx. more than 100 bins per axis); 1191that are not sparse, the COL2 option will provide up to 20 times performance improvements.; 1192For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; 1193faster with the COL2 option.; 1194 ; 1195The COL2 option will also scale its performance based on the size of the; 1196pixmap the histogram image is being rendered into. It also is much better optimized for; 1197sessions where the user is forwarding X11 windows through an `ssh` connection.; 1198 ; 1199For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; 1200and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:47642,perform,performance,47642,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['perform'],['performance']
Performance,"t(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMaxDepth(Int_t d); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidSetNodeMinEvents(Int_t d); voidSetNodePurityLimit(Double_t l); voidSetNTrees(Int_t d); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidSetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); Double_tTestTreeQuality(TMVA::DecisionTree* dt); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBDT.html:15191,tune,tuneParameters,15191,root/html528/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBDT.html,1,['tune'],['tuneParameters']
Performance,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* uri); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTProof::GetBytesRead() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:5727,load,loadopts,5727,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,3,['load'],['loadopts']
Performance,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tTProof::ExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTProof::GetBytesR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofCondor.html:5948,load,loadopts,5948,root/html528/TProofCondor.html,https://root.cern,https://root.cern/root/html528/TProofCondor.html,6,['load'],['loadopts']
Performance,"t(i);; 8637 branch = (TBranch*)leaf->GetBranch();; 8638 if (!branch->TestBit(kDoNotProcess)) {; 8639 leafcount = leaf->GetLeafCount();; 8640 if (leafcount) {; 8641 bcount = leafcount->GetBranch();; 8642 bcount->ResetBit(kDoNotProcess);; 8643 }; 8644 } else {; 8645 //Int_t nbranches = branch->GetListOfBranches()->GetEntriesFast();; 8646 Int_t nbranches = branch->GetListOfBranches()->GetEntries();; 8647 for (j=0;j<nbranches;j++) {; 8648 bson = (TBranch*)branch->GetListOfBranches()->UncheckedAt(j);; 8649 if (!bson) continue;; 8650 if (!bson->TestBit(kDoNotProcess)) {; 8651 if (bson->GetNleaves() <= 0) continue;; 8652 branch->ResetBit(kDoNotProcess);; 8653 break;; 8654 }; 8655 }; 8656 }; 8657 }; 8658}; 8659 ; 8660////////////////////////////////////////////////////////////////////////////////; 8661/// Set the current branch style. (static function); 8662///; 8663/// - style = 0 old Branch; 8664/// - style = 1 new Bronch; 8665 ; 8666void TTree::SetBranchStyle(Int_t style); 8667{; 8668 fgBranchStyle = style;; 8669}; 8670 ; 8671////////////////////////////////////////////////////////////////////////////////; 8672/// Set maximum size of the file cache .; 8673//; 8674/// - if cachesize = 0 the existing cache (if any) is deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:337799,cache,cache,337799,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"t) const. protected:. virtual voidattachToTree(TTree& t, Int_t bufSize = 32000); TStringRooAbsArg::cleanBranchName() const; voidclearTypes(); virtual voidcopyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); const RooCatType*defineType(const char* label); const RooCatType*defineType(const char* label, Int_t index); const RooCatType*defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidfillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tisValid() const; virtual Bool_tisValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidsetTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidsyncCache(const RooArgSet* set = 0); RooCatTypetraceEval() const; virtual Bool_ttraceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategory.html:16875,optimiz,optimizeDirtyHook,16875,root/html528/RooAbsCategory.html,https://root.cern,https://root.cern/root/html528/RooAbsCategory.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"t) const. protected:. voidRooAbsArg::attachToStore(RooAbsDataStore& store); virtual voidRooAbsString::attachToTree(TTree& t, Int_t bufSize = 32000); virtual voidRooAbsString::attachToVStore(RooVectorDataStore&); TStringRooAbsArg::cleanBranchName() const; virtual voidRooAbsString::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = kTRUE); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual TStringRooAbsString::evaluate() const; virtual voidRooAbsString::fillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual Bool_tRooAbsString::isValid() const; virtual Bool_tRooAbsString::isValidString(const char*, Bool_t printError = kFALSE) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsString::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsString::syncCache(const RooArgSet* nset = 0); const char*RooAbsString::traceEval() const; virtual Bool_tRooAbsString::traceEvalHook(const char* value) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStringVar.html:17129,optimiz,optimizeDirtyHook,17129,root/html602/RooStringVar.html,https://root.cern,https://root.cern/root/html602/RooStringVar.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"t)!; 1503 return (oldClass->GetCollectionType() == newClass->GetCollectionType());; 1504 }; 1505 return kFALSE;; 1506 }; 1507 ; 1508 TClass *FindAlternate(TClass *context, const std::string &i_name, std::string& newName); 1509 {; 1510 // Return a class whose has the name as oldClass and can be found; 1511 // within the scope of the class 'context'.; 1512 ; 1513 // First strip any 'const ' prefix or trailing '*'.; 1514 std::string name(i_name);; 1515 newName.clear();; 1516 if (name.compare(0,6,""const "")==0) {; 1517 newName = ""const "";; 1518 name.erase(0,6);; 1519 }; 1520 std::string suffix;; 1521 UInt_t nstars = 0;; 1522 while(name[name.length()-nstars-1]=='*') {; 1523 ++nstars;; 1524 suffix.append(""*"");; 1525 }; 1526 if (nstars) {; 1527 name.erase(name.length()-nstars,nstars);; 1528 }; 1529 ; 1530 std::string alternate(context->GetName());; 1531 alternate.append(""::"");; 1532 alternate.append(name);; 1533 ; 1534 TClass *altcl = TClass::GetClass(alternate.c_str(),/*load=*/ false,true);; 1535 if (altcl) {; 1536 newName.append(altcl->GetName());; 1537 newName.append(suffix);; 1538 return altcl;; 1539 }; 1540 ; 1541 size_t ctxt_cursor = strlen(context->GetName());; 1542 for (size_t level = 0; ctxt_cursor != 0; --ctxt_cursor) {; 1543 switch (context->GetName()[ctxt_cursor]) {; 1544 case '<': --level; break;; 1545 case '>': ++level; break;; 1546 case ':': if (level == 0) {; 1547 // we encountered a scope not within a template; 1548 // parameter.; 1549 alternate.clear();; 1550 alternate.append(context->GetName(),ctxt_cursor+1);; 1551 alternate.append(name);; 1552 altcl = TClass::GetClass(alternate.c_str(),/*load=*/ false,true);; 1553 if (altcl) {; 1554 newName.append(altcl->GetName());; 1555 newName.append(suffix);; 1556 return altcl;; 1557 }; 1558 }; 1559 }; 1560 }; 1561 newName.clear();; 1562 return 0;; 1563 }; 1564 ; 1565 TClass *FixCollectionV5(TClass *context, TClass *oldClass, TClass *newClass); 1566 {; 1567 assert(oldClass->GetCollectionProxy() && newClass->GetCollec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:58956,load,load,58956,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['load'],['load']
Performance,"t). You can find an example in $ROOTSYS/tutorials/fit/fitcont.C. Int_t DefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); Define a parameter. void DeleteArrays(); -*-*-*Delete internal Minuit arrays; *-* =============================. Int_t Eval(Int_t npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated (see example below); grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The (optional) vector of first derivatives). The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate their function value.; The starting values must be specified by the user.; Later values are determined by Minuit as it searches for the minimum; or performs whatever analysis is requested by the user. Note that this virtual function may be redefined in a class derived from TMinuit.; The default function calls the function specified in SetFCN. Example of Minimisation function:. if (flag == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log likelihood.; if (iflag == 3) {; will come here only after the fit is finished.; Perform any final calculations, output fitted data, etc.; }. See concrete examples in TH1::H1FitChisquare, H1FitLikelihood. Int_t FixParameter(Int_t parNo); fix a parameter. Int_t GetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; return parameter value and error. Int_t GetNumFixedPars() const; returns the number of currently fixed parameters. Int_t GetNumFreePars() const; returns the numb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMinuit.html:33331,perform,performs,33331,root/html602/TMinuit.html,https://root.cern,https://root.cern/root/html602/TMinuit.html,2,['perform'],['performs']
Performance,"t).; Event- or Entry-lists should be set in the data set object using; TDSet::SetEntryList.; Returns -1 in case of error or number of selected events otherwise. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Int_t CreateSymLinks(TList* files); Create in each worker sandbox symlinks to the files in the list; Used to make the caceh information available to workers. Int_t InitDataSetManager(); Initialize the dataset manager from directives or from defaults; Return 0 on success, -1 on failure. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove files from all file caches. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Copy the specified macro in the cache directory. The macro file is; uploaded if new or updated. If existing, the corresponding header; basename(macro).h or .hh, is also uploaded. For the other arguments; see TProof::Load().; Returns 0 in case of success and -1 in case of error. Int_t CopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0); Copy a macro, and its possible associated .h[h] file,; to the cache directory, from where the workers can get the file.; If headerRequired is 1, return -1 in case the header is not found.; If headerRequired is 0, try to copy header too.; If headerRequired is -1, don't look for header, only copy macro.; If the selector pionter is not 0, consider the macro to be a selector; and try to load the selector and set it to the pointer.; The mask 'opt' is an or of ESendFileO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:28370,cache,caches,28370,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,3,['cache'],['caches']
Performance,"t).; Event- or Entry-lists should be set in the data set object using; TDSet::SetEntryList.; Returns -1 in case of error or number of selected events otherwise. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Int_t CreateSymLinks(TList* files); Create in each worker sandbox symlinks to the files in the list; Used to make the cache information available to workers. Int_t InitDataSetManager(); Initialize the dataset manager from directives or from defaults; Return 0 on success, -1 on failure. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove files from all file caches. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Copy the specified macro in the cache directory. The macro file is; uploaded if new or updated. If existing, the corresponding header; basename(macro).h or .hh, is also uploaded. For the other arguments; see TProof::Load().; Returns 0 in case of success and -1 in case of error. Int_t CopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0); Copy a macro, and its possible associated .h[h] file,; to the cache directory, from where the workers can get the file.; If headerRequired is 1, return -1 in case the header is not found.; If headerRequired is 0, try to copy header too.; If headerRequired is -1, don't look for header, only copy macro.; If the selector pionter is not 0, consider the macro to be a selector; and try to load the selector and set it to the pointer.; The mask 'opt' is an or of ESendFileO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofLite.html:32367,cache,caches,32367,root/html602/TProofLite.html,https://root.cern,https://root.cern/root/html602/TProofLite.html,1,['cache'],['caches']
Performance,"t); Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset); Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset); Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset); Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedPdf.html:42567,cache,cache,42567,root/html526/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedPdf.html,1,['cache'],['cache']
Performance,"t)Definition TROOT.h:161; TROOT::fWebDisplayTString fWebDisplayIf not empty it defines where web graphics should be rendered (cef, qt5, browser.....Definition TROOT.h:127; TROOT::GetTutorialsDirstatic const char * GetTutorialsDir()Get the tutorials directory in the installation.Definition TROOT.cxx:3211; TROOT::GetListOfFunctionOverloadsTCollection * GetListOfFunctionOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TROOT.cxx:1672; TROOT::fCleanupsTSeqCollection * fCleanupsList of recursiveRemove collections.Definition TROOT.h:157; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2906; TROOT::GetApplicationTApplication * GetApplication() constDefinition TROOT.h:209; TROOT::SetBatchvoid SetBatch(Bool_t batch=kTRUE)Set batch mode for ROOT If the argument evaluates to true, the session does not use interactive graph...Definition TROOT.cxx:2803; TROOT::fLineIsProcessingInt_t fLineIsProcessingTo synchronize multi-threads.Definition TROOT.h:100; TROOT::TimerInt_t Timer() constDefinition TROOT.h:336; TROOT::GetSourceDirstatic const TString & GetSourceDir()Get the source directory in the installation. Static utility function.Definition TROOT.cxx:3147; TROOT::GetMacroDirstatic const TString & GetMacroDir()Get the macro directory in the installation. Static utility function.Definition TROOT.cxx:3094; TROOT::fGitCommitTString fGitCommitGit commit SHA1 of built.Definition TROOT.h:120; TROOT::ProcessLineLongptr_t ProcessLine(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2370; TROOT::fClosedObjectsTSeqCollection * fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.Definition TROOT.h:145; TROOT::fTasksTSeqCollection * fTasksList of tasks.Definition TROOT.h:152; TROOT::fClipboardTSeqCollection * fClipboardList of clipboard objects.Definition T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:38742,multi-thread,multi-threads,38742,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,1,['multi-thread'],['multi-threads']
Performance,"t)Definition TROOT.h:161; TROOT::fWebDisplayTString fWebDisplayIf not empty it defines where web graphics should be rendered (cef, qt5, browser.....Definition TROOT.h:127; TROOT::GetTutorialsDirstatic const char * GetTutorialsDir()Get the tutorials directory in the installation.Definition TROOT.cxx:3215; TROOT::GetListOfFunctionOverloadsTCollection * GetListOfFunctionOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TROOT.cxx:1672; TROOT::fCleanupsTSeqCollection * fCleanupsList of recursiveRemove collections.Definition TROOT.h:157; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2910; TROOT::GetApplicationTApplication * GetApplication() constDefinition TROOT.h:209; TROOT::SetBatchvoid SetBatch(Bool_t batch=kTRUE)Set batch mode for ROOT If the argument evaluates to true, the session does not use interactive graph...Definition TROOT.cxx:2803; TROOT::fLineIsProcessingInt_t fLineIsProcessingTo synchronize multi-threads.Definition TROOT.h:100; TROOT::TimerInt_t Timer() constDefinition TROOT.h:336; TROOT::GetSourceDirstatic const TString & GetSourceDir()Get the source directory in the installation. Static utility function.Definition TROOT.cxx:3151; TROOT::GetMacroDirstatic const TString & GetMacroDir()Get the macro directory in the installation. Static utility function.Definition TROOT.cxx:3098; TROOT::fGitCommitTString fGitCommitGit commit SHA1 of built.Definition TROOT.h:120; TROOT::ProcessLineLongptr_t ProcessLine(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2370; TROOT::fClosedObjectsTSeqCollection * fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.Definition TROOT.h:145; TROOT::fTasksTSeqCollection * fTasksList of tasks.Definition TROOT.h:152; TROOT::fClipboardTSeqCollection * fClipboardList of clipboard objects.Definition T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:38741,multi-thread,multi-threads,38741,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,1,['multi-thread'],['multi-threads']
Performance,"t* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:100442,load,loading,100442,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,4,['load'],['loading']
Performance,"t* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooAbsReal::traceEvalHook(Double_t) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidvalidateAbsMin() const. Data Members; public:. enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. Double_t_absMinabsolute minimum of -log(L); Bool_t_absMinValidflag if absmin is up-to-date; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProfileLL.html:31776,Cache,CacheMode,31776,root/html534/RooProfileLL.html,https://root.cern,https://root.cern/root/html534/RooProfileLL.html,1,['Cache'],['CacheMode']
Performance,"t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:34048,cache,cache,34048,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,18,['cache'],['cache']
Performance,"t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTEventIter::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tTEventIter::LoadDir(); voidTObject::MakeZombie(). private:. TTree*GetTrees(TDSetElement* elem); TTree*Load(TDSetElement* elem, Bool_t& localfile). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Long64_tTEventIter::fCurcurrent entry; TDSet*TEventIter::fDSetdata set over which to iterate; TDirectory*TEventIter::fDirdirectory containing the objects or the TTree; TDSetElement*TEventIter::fElemCurrent Element; Long64_tTEventIter::fElemCurcurrent entry for this element; Long64_tTEventIter::fElemFirstfirst entry to process for this element; Long64_tTEventIter::fElemNumnumber of entries to process for this element; TEntryList*TEventIter::fEntryList! entry list for processing; Long64_tTEventIter::fEntryListPos! current position in the entrylist; TEventList*TEventIter::fEventList! eventList for processing; Int_tTEventIter::fEventListPos! current position in th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEventIterTree.html:5261,Load,Load,5261,root/html528/TEventIterTree.html,https://root.cern,https://root.cern/root/html528/TEventIterTree.html,3,['Load'],['Load']
Performance,"t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Bool_tSetAlias(const char* aliasName, const char* aliasFormula); virtual voidSetAutoFlush(Long64_t autof = -30000000); virtual voidSetAutoSave(Long64_t autos = -300000000); virtual voidSetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); Int_tSetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidSetBranchStyle(Int_t style = 1); virtual voidSetCacheEntryRange(Long64_t first, Long64_t last); virtual voidSetCacheLearnEntries(Int_t n = 10); virtual voidSetCacheSize(Long64_t cachesize = -1); virtual voidSetChainOffset(Long64_t offset = 0); virtual voidSetCircular(Long64_t maxEntries); virtual voidSetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidSetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tSetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidSetEstimate(Long64_t nentries = 1000000); virtual voidSetEventList(TEventList* list); virtual voidSetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:26019,cache,cachesize,26019,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,1,['cache'],['cachesize']
Performance,"t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process this chain executing the code in selector.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Reset(Option_t* option = """"); -- Resets the state of this chain. Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more details on AutoDelete, see TBranch::SetAutoDelete. void ResetBranchAddress(TBranch* ); -- Reset the addresses of the branch. void ResetBranchAddresses(); Reset the addresses of the branches. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Set branch address. bname is the name of a branch.; add is the address of the branch. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. IMPORTANT REMARK:; In case TChain::SetBranchStatus is called, it must be called; BEFORE calling this function. See TTree::CheckBranchAddressType for the semantic of the return value. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TChain.html:45505,Load,LoadTree,45505,root/html530/TChain.html,https://root.cern,https://root.cern/root/html530/TChain.html,2,"['Load', 'load']","['LoadTree', 'loads']"
Performance,"t* particle); Makes a primary track but do not attach it to the list of tracks. The track; can be attached as daughter to another one with TVirtualGeoTrack::AddTrack. Int_t AddVolume(TGeoVolume* volume); Add a volume to the list. Returns index of the volume in list. Int_t AddNavigator(TGeoNavigator* navigator); Add a navigator in the list of navigators. If it is the first one make it; current navigator. Bool_t SetCurrentNavigator(Int_t index); Switch to another navigator. void Browse(TBrowser* b); Describe how to browse this object. void Edit(Option_t* option = """"); Append a pad for this geometry. void SetVisibility(TObject* obj, Bool_t vis); Set visibility for a volume. void BombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'bombed' translation vector according current exploded view mode. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'unbombed' translation vector according current exploded view mode. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. void RegisterMatrix(const TGeoMatrix* matrix); Register a matrix to the list of matrices. It will be cleaned-up at the; destruction TGeoManager. Int_t ReplaceVolume(TGeoVolume* vorig, TGeoVolume* vnew); Replaces all occurences of VORIG with VNEW in the geometry tree. The volume VORIG; is not replaced from the list of volumes, but all node referencing it will reference; VNEW instead. Returns number of occurences changed. Int_t TransformVolumeToAssembly(const char* vname); Transform all volumes named VNAME to assemblies. The volumes must be virtual. TGeoVolume * Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); Create a new volume by dividing an existing one (GEANT3 like). Divides MOTHER into NDIV divisions called NAME; along axis IAXIS starting at coordinate value START;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:37754,cache,cache,37754,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,2,['cache'],['cache']
Performance,"t* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo2DKeysPdf.html:36003,optimiz,optimizeDirtyHook,36003,root/html602/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html602/Roo2DKeysPdf.html,102,['optimiz'],['optimizeDirtyHook']
Performance,"t*); virtual Int_tTNetFile::ReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTNetFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TCastorFile.html:12855,cache,cache,12855,root/html530/TCastorFile.html,https://root.cern,https://root.cern/root/html530/TCastorFile.html,1,['cache'],['cache']
Performance,"t*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tagFlav; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBMixDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBMixDecay.html:42036,cache,cache,42036,root/html530/RooBMixDecay.html,https://root.cern,https://root.cern/root/html530/RooBMixDecay.html,2,['cache'],['cache']
Performance,"t*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; const ROOT::Math::IBaseFunctionOneDim*funcFunctor; RooRealProxyvarArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFunctor1DPdfBinding.html:40601,cache,cache,40601,root/html532/RooFunctor1DPdfBinding.html,https://root.cern,https://root.cern/root/html532/RooFunctor1DPdfBinding.html,2,['cache'],['cache']
Performance,"t*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; const ROOT::Math::IBaseFunctionMultiDim*funcFunctor; RooListProxyvarsArgument reference; Double_t*xArgument value array. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFunctorBinding(const char* name, const char* title, const ROOT::Math::IBaseFunctionMultiDim& f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFunctorBinding.html:36490,cache,cache,36490,root/html602/RooFunctorBinding.html,https://root.cern,https://root.cern/root/html602/RooFunctorBinding.html,4,['cache'],['cache']
Performance,"t*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3PdfBinding<double,double,double,double>&operator=(const RooCFunction3PdfBinding<double,double,double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3PdfBinding_double_double_double_double_.html:23584,optimiz,optimizeCacheMode,23584,root/html602/RooCFunction3PdfBinding_double_double_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3PdfBinding_double_double_double_double_.html,4,['optimiz'],['optimizeCacheMode']
Performance,"t, Architecture_t>;; 1171 ; 1172 bool debug = Log().GetMinType() == kDEBUG;; 1173 ; 1174 ; 1175 // set the random seed for weight initialization; 1176 Architecture_t::SetRandomSeed(fRandomSeed);; 1177 ; 1178 ///split training data in training and validation data; 1179 // and determine the number of training and testing examples; 1180 ; 1181 size_t nValidationSamples = GetNumValidationSamples();; 1182 size_t nTrainingSamples = GetEventCollection(Types::kTraining).size() - nValidationSamples;; 1183 ; 1184 const std::vector<TMVA::Event *> &allData = GetEventCollection(Types::kTraining);; 1185 const std::vector<TMVA::Event *> eventCollectionTraining{allData.begin(), allData.begin() + nTrainingSamples};; 1186 const std::vector<TMVA::Event *> eventCollectionValidation{allData.begin() + nTrainingSamples, allData.end()};; 1187 ; 1188 size_t trainingPhase = 1;; 1189 ; 1190 for (TTrainingSettings &settings : this->GetTrainingSettings()) {; 1191 ; 1192 size_t nThreads = 1; // FIXME threads are hard coded to 1, no use of slave threads or multi-threading; 1193 ; 1194 ; 1195 // After the processing of the options, initialize the master deep net; 1196 size_t batchSize = settings.batchSize;; 1197 this->SetBatchSize(batchSize);; 1198 // Should be replaced by actual implementation. No support for this now.; 1199 size_t inputDepth = this->GetInputDepth();; 1200 size_t inputHeight = this->GetInputHeight();; 1201 size_t inputWidth = this->GetInputWidth();; 1202 size_t batchDepth = this->GetBatchDepth();; 1203 size_t batchHeight = this->GetBatchHeight();; 1204 size_t batchWidth = this->GetBatchWidth();; 1205 ELossFunction J = this->GetLossFunction();; 1206 EInitialization I = this->GetWeightInitialization();; 1207 ERegularization R = settings.regularization;; 1208 EOptimizer O = settings.optimizer;; 1209 Scalar_t weightDecay = settings.weightDecay;; 1210 ; 1211 //Batch size should be included in batch layout as well. There are two possibilities:; 1212 // 1. Batch depth = batch size one w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:45850,multi-thread,multi-threading,45850,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"t, DeepNet_t>(settings.learningRate, deepNet, settings.momentum));; 1359 break;; 1360 ; 1361 case EOptimizer::kAdam: {; 1362 optimizer = std::unique_ptr<DNN::TAdam<Architecture_t, Layer_t, DeepNet_t>>(; 1363 new DNN::TAdam<Architecture_t, Layer_t, DeepNet_t>(; 1364 deepNet, settings.learningRate, settings.optimizerParams[""ADAM_beta1""],; 1365 settings.optimizerParams[""ADAM_beta2""], settings.optimizerParams[""ADAM_eps""]));; 1366 break;; 1367 }; 1368 ; 1369 case EOptimizer::kAdagrad:; 1370 optimizer = std::unique_ptr<DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>>(; 1371 new DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1372 settings.optimizerParams[""ADAGRAD_eps""]));; 1373 break;; 1374 ; 1375 case EOptimizer::kRMSProp:; 1376 optimizer = std::unique_ptr<DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>>(; 1377 new DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate, settings.momentum,; 1378 settings.optimizerParams[""RMSPROP_rho""],; 1379 settings.optimizerParams[""RMSPROP_eps""]));; 1380 break;; 1381 ; 1382 case EOptimizer::kAdadelta:; 1383 optimizer = std::unique_ptr<DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>>(; 1384 new DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1385 settings.optimizerParams[""ADADELTA_rho""],; 1386 settings.optimizerParams[""ADADELTA_eps""]));; 1387 break;; 1388 }; 1389 ; 1390 ; 1391 // Initialize the vector of batches, one batch for one slave network; 1392 std::vector<TTensorBatch<Architecture_t>> batches{};; 1393 ; 1394 bool converged = false;; 1395 size_t convergenceCount = 0;; 1396 size_t batchesInEpoch = nTrainingSamples / deepNet.GetBatchSize();; 1397 ; 1398 // start measuring; 1399 std::chrono::time_point<std::chrono::system_clock> tstart, tend;; 1400 tstart = std::chrono::system_clock::now();; 1401 ; 1402 // function building string with optimizer parameters values for logging; 1403 auto optimParametersString = [&]() {; 1404 TString op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:54703,optimiz,optimizerParams,54703,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['optimiz'],['optimizerParams']
Performance,"t, Int_t bufSize = 32000); virtual voidRooAbsReal::attachToVStore(RooVectorDataStore& vstore); virtual const char*binningName() const; TStringRooAbsCachedReal::cacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidRooAbsCachedReal::clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); virtual RooAbsCachedReal::FuncCacheElem*createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voidRooAbsCachedReal::disableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tevaluate() const; virtual voidfillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; static Bool_tRooAbsArg::flipAClean(); RooAbsCachedReal::FuncCacheElem*RooAbsCachedReal::getCache(const RooArgSet* nset) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumRunningInt.html:27206,cache,cacheFunc,27206,root/html532/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html532/RooNumRunningInt.html,1,['cache'],['cacheFunc']
Performance,"t, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector&); virtual voidsterilize(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. Int_t_lastIndex! Last slot accessed; Int_t_maxSize! Maximum size; vector<RooNormSetCache>_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_size! Actual use; Bool_t_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const char* isetRangeNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCacheManager_RooAbsCacheElement_.html:3825,cache,cache,3825,root/html534/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html534/RooCacheManager_RooAbsCacheElement_.html,1,['cache'],['cache']
Performance,"t, Scalar_t learningRate=0.01, Scalar_t epsilon=1e-8);  Constructor. ;  ;  ~TAdagrad ()=default;  Destructor. ;  ; Scalar_t GetEpsilon () const;  Getters. ;  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredBiasGradients ();  ; std::vector< Matrix_t > & GetPastSquaredBiasGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightGradients ();  ; std::vector< Matrix_t > & GetPastSquaredWeightGradientsAt (size_t i);  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; Scalar_t fEpsilon;  The Smoothing term used to avoid division by zero. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasGradients;  The sum of the square of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredWeightGradients;  The sum of the square of the past weight gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor;  working tensor used to keep a temporary copy of bias or bias gradients ;  ; std::vector< std::vector< Matrix_t > > fW",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdagrad.html:2091,Perform,Performs,2091,doc/master/classTMVA_1_1DNN_1_1TAdagrad.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdagrad.html,2,"['Perform', 'optimiz']","['Performs', 'optimization']"
Performance,"t, TVirtualPad, TTask, TNode, and TGeometry.; Definition at line 574 of file TObject.cxx. ◆ MakeZombie(). void TObject::MakeZombie ; (; ). inlineprotected . Definition at line 53 of file TObject.h. ◆ MayNotUse(). void TObject::MayNotUse ; (; const char * ; method); const. Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is necessary). ; Definition at line 1040 of file TObject.cxx. ◆ Notify(). Bool_t TObject::Notify ; (; ). virtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented in TSelEvent, TXSocketHandler, TProofMgrInterruptHandler, TXProofServSigPipeHandler, TXProofServTerminationHandler, TXProofServSegViolationHandler, TXProofServInputHandler, TXSlaveInterruptHandler, TXSocketPingHandler, TMessageHandler, TNotifyLink< Type >, TNotifyLink< RNoCleanupNotifierHelper >, TNotifyLink< ROOT::Detail::TBranchProxy >, TNotifyLink< TTreeReader >, TFileHandler, TSignalHandler, TStdExceptionHandler, TProcessEventTimer, TTimer, TIdleTimer, TSingleShotCleaner, TCollection, TRefTable, TBrowserTimer, TInterruptHandler, TTermInputHandler, TThreadTimer, TGLRedrawTimer, TViewTimer, TGContainerKeyboardTimer, TGContainerScrollTimer, TGInputHandler, TViewUpdateTimer, TPopupDelayTimer, TRepeatTimer, TSBRepeatTimer, TGTextEditHist, TInsCharCom, TDelCharCom, TBreakLineCom, TInsTextCom, TDelTextCom, TBlinkTimer, TTipDelayTimer, TGuiBldDragMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTObject.html:74636,load,load,74636,doc/v632/classTObject.html,https://root.cern,https://root.cern/doc/v632/classTObject.html,2,['load'],['load']
Performance,"t, TVirtualPad, TTask, TNode, and TGeometry.; Definition at line 579 of file TObject.cxx. ◆ MakeZombie(). void TObject::MakeZombie ; (; ). inlineprotected . Definition at line 53 of file TObject.h. ◆ MayNotUse(). void TObject::MayNotUse ; (; const char * ; method); const. Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is necessary). ; Definition at line 1046 of file TObject.cxx. ◆ Notify(). Bool_t TObject::Notify ; (; ). virtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented in TSelEvent, TMessageHandler, TNotifyLink< Type >, TNotifyLink< RNoCleanupNotifierHelper >, TNotifyLink< ROOT::Detail::TBranchProxy >, TNotifyLink< TTreeReader >, TFileHandler, TSignalHandler, TStdExceptionHandler, TProcessEventTimer, TTimer, TIdleTimer, TSingleShotCleaner, TCollection, TRefTable, TBrowserTimer, TInterruptHandler, TTermInputHandler, TThreadTimer, TGLRedrawTimer, TViewTimer, TGContainerKeyboardTimer, TGContainerScrollTimer, TGInputHandler, TViewUpdateTimer, TPopupDelayTimer, TRepeatTimer, TSBRepeatTimer, TGTextEditHist, TInsCharCom, TDelCharCom, TBreakLineCom, TInsTextCom, TDelTextCom, TBlinkTimer, TTipDelayTimer, TGuiBldDragManagerRepeatTimer, TARInterruptHandler, TASLogHandler, TASInterruptHandler, TASSigPipeHandler, TASInputHandler, TSocketHandler, TTimeOutTimer, TProofInterruptHandler, TProofInputHandler, TProofServLogHandle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObject.html:74124,load,load,74124,doc/master/classTObject.html,https://root.cern,https://root.cern/doc/master/classTObject.html,2,['load'],['load']
Performance,"t, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; Bool_tok() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFormulaVar.html:20470,optimiz,optimizeCacheMode,20470,root/html534/RooFormulaVar.html,https://root.cern,https://root.cern/root/html534/RooFormulaVar.html,1,['optimiz'],['optimizeCacheMode']
Performance,"t, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction1Binding<double,double>&operator=(const RooCFunction1Binding<double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction1Binding_double_double_.html:19838,optimiz,optimizeCacheMode,19838,root/html602/RooCFunction1Binding_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction1Binding_double_double_.html,2,['optimiz'],['optimizeCacheMode']
Performance,"t, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::HistFactory::LinInterpVar&operator=(const RooStats::HistFactory::LinInterpVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__LinInterpVar.html:19813,optimiz,optimizeCacheMode,19813,root/html602/RooStats__HistFactory__LinInterpVar.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__LinInterpVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"t, const RooArgSet& intSet, RooArgSet& saveSet, const char* isetRangeName, Bool_t doFactorize); voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidoperModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGenProdProj.html:29900,optimiz,optimizeDirtyHook,29900,root/html534/RooGenProdProj.html,https://root.cern,https://root.cern/root/html534/RooGenProdProj.html,3,['optimiz'],['optimizeDirtyHook']
Performance,"t, const RooArgSet& intSet, RooArgSet& saveSet, const char* isetRangeName, Bool_t doFactorize); voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidoperModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGenProdProj.html:27602,optimiz,optimizeDirtyHook,27602,root/html528/RooGenProdProj.html,https://root.cern,https://root.cern/root/html528/RooGenProdProj.html,3,['optimiz'],['optimizeDirtyHook']
Performance,"t, const RooArgSet* iset, const TNamed* rangeName) const; 444{; 445 // Check normalization is already stored; 446 CacheElem* cache = static_cast<CacheElem*>(_normMgr.getObj(nset,iset,nullptr,rangeName)) ;; 447 if (cache) {; 448 return cache->_norm.get();; 449 }; 450 ; 451 // If not create it now; 452 RooArgSet depList;; 453 getObservables(iset, depList);; 454 ; 455 // Normalization is always over all pdf components. Overriding the global; 456 // component selection temporarily makes all RooRealIntegrals created during; 457 // that time always include all components.; 458 GlobalSelectComponentRAII globalSelComp(true);; 459 RooAbsReal* norm = std::unique_ptr<RooAbsReal>{createIntegral(depList,*nset, *getIntegratorConfig(), RooNameReg::str(rangeName))}.release();; 460 ; 461 // Store it in the cache; 462 _normMgr.setObj(nset,iset,new CacheElem(*norm),rangeName) ;; 463 ; 464 // And return the newly created integral; 465 return norm ;; 466}; 467 ; 468 ; 469 ; 470////////////////////////////////////////////////////////////////////////////////; 471/// Verify that the normalization integral cached with this PDF; 472/// is valid for given set of normalization observables.; 473///; 474/// If not, the cached normalization integral (if any) is deleted; 475/// and a new integral is constructed for use with 'nset'.; 476/// Elements in 'nset' can be discrete and real, but must be lvalues.; 477///; 478/// For functions that declare to be self-normalized by overloading the; 479/// selfNormalized() function, a unit normalization is always constructed.; 480 ; 481bool RooAbsPdf::syncNormalization(const RooArgSet* nset, bool adjustProxies) const; 482{; 483 setActiveNormSet(nset);; 484 ; 485 // Check if data sets are identical; 486 CacheElem* cache = static_cast<CacheElem*>(_normMgr.getObj(nset)) ;; 487 if (cache) {; 488 ; 489 bool nintChanged = (_norm!=cache->_norm.get()) ;; 490 _norm = cache->_norm.get();; 491 ; 492 // In the past, this condition read `if (nintChanged && adjustProxies)`.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:17472,Cache,CacheElem,17472,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,2,"['Cache', 'cache']","['CacheElem', 'cached']"
Performance,"t, const char* opt, Long64_t fst, TDSet* dset, const char* selec); Create a TProofQueryResult instance for this query. void SetQueryRunning(TProofQueryResult* pq); Set query in running state. Long64_t DrawSelect(TDSet* dset, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Execute the specified drawing action on a data set (TDSet).; Event- or Entry-lists should be set in the data set object using; TDSet::SetEntryList.; Returns -1 in case of error or number of selected events otherwise. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Int_t CreateSymLinks(TList* files, TList* wrks = 0); Create in each worker sandbox symlinks to the files in the list; Used to make the cache information available to workers. Int_t InitDataSetManager(); Initialize the dataset manager from directives or from defaults; Return 0 on success, -1 on failure. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove files from all file caches. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Copy the specified macro in the cache directory. The macro file is; uploaded if new or updated. If existing, the corresponding header; basename(macro).h or .hh, is also uploaded. For the other arguments; see TProof::Load().; Returns 0 in case of success and -1 in case of error. Int_t CopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0, TList* wrks = 0); Copy a macro, and its possible ass",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:31037,cache,cache,31037,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,2,['cache'],['cache']
Performance,"t, one can conclude that the; technique is itself an optimal method to reconstruct distributions of control variables. Different steps followed by TSPlot. A maximum Likelihood fit is performed to obtain the yields of the various species.; The fit relies on discriminating variables  uncorrelated with a control variable :; the later is therefore totally absent from the fit. The weights are calculated using Eq. (2) where the covariance matrix is taken from Minuit. Histograms of  are filled by weighting the events with . Error bars per bin are given by Eq. (6). The ; reproduce the true distributions of the species in the control variable , within the above defined statistical uncertainties. Illustrations. To illustrate the technique, one considers an example derived from the analysis where . have been first used (charmless B decays). One is dealing with a data; sample in which two species are present: the first is termed signal and; the second background. A maximum Likelihood fit is performed to obtain; the two yields and . The fit relies on two discriminating variables collectively denoted  which are chosen within three possible variables denoted , and .; The variable which is not incorporated in  is used as the control variable . The six distributions of the three variables are assumed to be the ones depicted in Fig. 1. Figure 1:; Distributions of the three discriminating variables available to perform the Likelihood fit:; , , .; Among the three variables, two are used to perform the fit while one is; kept out of the fit to serve the purpose of a control variable. The; three distributions on the top (resp. bottom) of the figure correspond; to the signal (resp. background). The unit of the vertical axis is; chosen such that it indicates the number of entries per bin, if one; slices the histograms in 25 bins. A data sample being built through a Monte Carlo simulation based on the distributions shown in Fig. 1, one obtains the three distributions of Fig. 2. Whereas the d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSPlot.html:5224,perform,performed,5224,root/html602/TSPlot.html,https://root.cern,https://root.cern/root/html602/TSPlot.html,2,['perform'],['performed']
Performance,"t, std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > &nets, TString layerString, TString delim);  Pases the layer string and creates the appropriate max pool layer. ;  ; template<typename Architecture_t , typename Layer_t > ; void ParseRecurrentLayer (ERecurrentLayerType type, DNN::TDeepNet< Architecture_t, Layer_t > &deepNet, std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > &nets, TString layerString, TString delim);  Pases the layer string and creates the appropriate rnn layer. ;  ; template<typename Architecture_t , typename Layer_t > ; void ParseReshapeLayer (DNN::TDeepNet< Architecture_t, Layer_t > &deepNet, std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > &nets, TString layerString, TString delim);  Pases the layer string and creates the appropriate reshape layer. ;  ; template<typename Architecture_t > ; std::vector< Double_t > PredictDeepNet (Long64_t firstEvt, Long64_t lastEvt, size_t batchSize, Bool_t logProgress);  perform prediction of the deep neural network using batches (called by GetMvaValues) ;  ; void ProcessOptions ();  ; template<typename Architecture_t > ; void TrainDeepNet ();  train of deep neural network using the defined architecture ;  . Private Attributes; TString fArchitectureString;  The string defining the architecture: CPU or GPU. ;  ; size_t fBatchDepth;  The depth of the batch used to train the deep net. ;  ; size_t fBatchHeight;  The height of the batch used to train the deep net. ;  ; TString fBatchLayoutString;  The string defining the layout of the batch. ;  ; size_t fBatchWidth;  The width of the batch used to train the deep net. ;  ; bool fBuildNet;  Flag to control whether to build fNet, the stored network used for the evaluation. ;  ; TString fErrorStrategy;  The string defining the error strategy for training. ;  ; TString fInputLayoutString;  The string defining the layout of the input. ;  ; std::vector< size_t > fInputShape;  Contains the batch size (no. ;  ; TString fLayoutString;  The string defining t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodDL.html:31021,perform,perform,31021,doc/master/classTMVA_1_1MethodDL.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodDL.html,1,['perform'],['perform']
Performance,"t,cached_end,&cached_config);; 1622 }; 1623 // Idea: Factor out this 'if' to a UseCacheRepeat function; 1624 if (config->fNeedRepeat) {; 1625 b.SetBufferOffset(bufpos);; 1626 }; 1627 return 0;; 1628 }; 1629 ; 1630 INLINE_TEMPLATE_ARGS Int_t UseCacheVectorLoop(TBuffer &b, void *start, const void *end, const TLoopConfiguration *loopconf, const TConfiguration *conf); 1631 {; 1632 TConfigurationUseCache *config = (TConfigurationUseCache*)conf;; 1633 ; 1634 Int_t bufpos = b.Length();; 1635 TVirtualArray *cached = b.PeekDataCache();; 1636 if (cached==0) {; 1637 TStreamerElement *aElement = config->fCompInfo->fElem;; 1638 TStreamerInfo *info = (TStreamerInfo*)config->fInfo;; 1639 Warning(""ReadBuffer"",""Skipping %s::%s because the cache is missing."",info->GetName(),aElement->GetName());; 1640 char *ptr = (char*)start;; 1641 UInt_t n = (((char*)end)-((char*)start))/((TVectorLoopConfig*)loopconf)->fIncrement;; 1642 info->ReadBufferSkip(b,&ptr,config->fCompInfo,config->fCompInfo->fType+TStreamerInfo::kSkip,aElement,n,0);; 1643 } else {; 1644 TVectorLoopConfig cached_config( nullptr, cached->fClass->Size(), /* read */ kTRUE );; 1645 void *cached_start = (*cached)[0];; 1646 void *cached_end = ((char*)cached_start) + cached->fSize * cached_config.fIncrement;; 1647 config->fAction(b,cached_start,cached_end,&cached_config);; 1648 }; 1649 // Idea: Factor out this 'if' to a UseCacheRepeat function; 1650 if (config->fNeedRepeat) {; 1651 b.SetBufferOffset(bufpos);; 1652 }; 1653 return 0;; 1654 }; 1655 ; 1656 INLINE_TEMPLATE_ARGS Int_t UseCacheGenericCollection(TBuffer &b, void *, const void *, const TLoopConfiguration *loopconfig, const TConfiguration *conf); 1657 {; 1658 TConfigurationUseCache *config = (TConfigurationUseCache*)conf;; 1659 ; 1660 Int_t bufpos = b.Length();; 1661 TVirtualArray *cached = b.PeekDataCache();; 1662 if (cached==0) {; 1663 TStreamerElement *aElement = config->fCompInfo->fElem;; 1664 TStreamerInfo *info = (TStreamerInfo*)config->fInfo;; 1665 ; 1666 TVirtualColl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:68225,cache,cached,68225,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,3,['cache'],['cached']
Performance,"t->GetN();; Long64_t chainEntries = ch->GetEntries();; Int_t treenum = 0;; ch->SetEntryList(myelist);; for (entry=start;entry < end;entry++) {; entryNumber = treechain->GetEntryNumber(entry);; if (entryNumber < 0) break;; localEntry = fTree->LoadTree(entryNumber);; if (localEntry < 0) break;; // then either call branch->GetEntry(localEntry);; // or entryNumber->GetEntry(entryNumber);; // In the later case the LoadTree is then somewhat redudant.; }; }. When using the TEntryList interface directly, you can get the 'tree number' and entry in; the current tree (i.e. value similar to the return value of LoadTree) from calling; TEntryList::GetEntryAndTree:. Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);. to obtain the entry number within the chain you need to add to it the value; of; treeEntry+ch->GetTreeOffset()[treenum]; such that the loop in the previous example can also be written as:; for (Long64_t el = 0; el < listEntries; el++) {; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum]; ; printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);; ch->LoadTree(chainEntry); // this also returns treeEntry; needed_branch->GetEntry(treeEntry);; }. TSelectors; To fill an TEntryList from a TSelector correctly, one must add the TEntryList object; to the output list of the selector (TSelector::fOutput). This is the only way to ; make the sub-lists of the TEntryList switch when the current tree of the TChain is; changed. ; Using a TEntryList as input (TTree::SetEntryList() and TChain::SetEntryList()); while the TTree::SetEntryList() function is only setting the TTree::fEntryList; data member, the same function in TChain also finds correspondance between; the TTrees of this TChain and the sub-lists of this TEntryList.; TEntryList and the current directory; TEntryList objects are automatically added to the current directory (like TTrees).; However, in case of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEntryList.html:7957,Load,LoadTree,7957,root/html534/TEntryList.html,https://root.cern,https://root.cern/root/html534/TEntryList.html,1,['Load'],['LoadTree']
Performance,"t->GetN();; Long64_t chainEntries = ch->GetEntries();; Int_t treenum = 0;; ch->SetEntryList(myelist);; for (entry=start;entry < end;entry++) {; entryNumber = treechain->GetEntryNumber(entry);; if (entryNumber < 0) break;; localEntry = fTree->LoadTree(entryNumber);; if (localEntry < 0) break;; // then either call branch->GetEntry(localEntry);; // or entryNumber->GetEntry(entryNumber);; // In the later case the LoadTree is then somewhat redudant.; }; }. When using the TEntryList interface directly, you can get the 'tree number' and entry in; the current tree (i.e. value similar to the return value of LoadTree) from calling; TEntryList::GetEntryAndTree:. Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);. to obtain the entry number within the chain you need to add to it the value; of; treeEntry+ch->GetTreeOffset()[treenum]; such that the loop in the previous example can also be written as:; for (Long64_t el = 0; el < listEntries; el++) {; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);; ch->LoadTree(chainEntry); // this also returns treeEntry; needed_branch->GetEntry(treeEntry);; }. TSelectors; To fill an TEntryList from a TSelector correctly, one must add the TEntryList object; to the output list of the selector (TSelector::fOutput). This is the only way to; make the sub-lists of the TEntryList switch when the current tree of the TChain is; changed.; Using a TEntryList as input (TTree::SetEntryList() and TChain::SetEntryList()); while the TTree::SetEntryList() function is only setting the TTree::fEntryList; data member, the same function in TChain also finds correspondance between; the TTrees of this TChain and the sub-lists of this TEntryList.; TEntryList and the current directory; TEntryList objects are automatically added to the current directory (like TTrees).; However, in case of a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEntryList.html:7918,Load,LoadTree,7918,root/html602/TEntryList.html,https://root.cern,https://root.cern/root/html602/TEntryList.html,2,['Load'],['LoadTree']
Performance,"t. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; void initializeOwnedDataHist (std::unique_ptr< RooDataHist > &&dataHist);  . Friends; class RooAbsCachedReal;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:59841,Cache,CacheMode,59841,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,1,['Cache'],['CacheMode']
Performance,"t. ;  ; ROOT::DesFunc_t GetDestructor () const;  Return the wrapper around the destructor. ;  ; ROOT::DirAutoAdd_t GetDirectoryAutoAdd () const;  Return the wrapper around the directory auto add function. ;  ; TFunctionTemplate * GetFunctionTemplate (const char *name);  ; UInt_t GetHeapInstanceCount () const;  ; Short_t GetImplFileLine () const;  ; const char * GetImplFileName () const;  ; UInt_t GetInstanceCount () const;  ; TVirtualIsAProxy * GetIsAProxy () const;  Return the proxy implementing the IsA functionality. ;  ; TVirtualStreamerInfo * GetLastReadInfo () const;  ; TList * GetListOfAllPublicDataMembers (Bool_t load=kTRUE);  Returns a list of all public data members of this class and its base classes. ;  ; const TList * GetListOfAllPublicMethods (Bool_t load=kTRUE);  Returns a list of all public methods of this class and its base classes. ;  ; TList * GetListOfBases ();  Return list containing the TBaseClass(es) of a class. ;  ; TList * GetListOfDataMembers (Bool_t load=kTRUE);  Return list containing the TDataMembers of a class. ;  ; TList * GetListOfEnums (Bool_t load=kTRUE);  Return a list containing the TEnums of a class. ;  ; TList * GetListOfFunctionTemplates (Bool_t load=kTRUE);  Return TListOfFunctionTemplates for a class. ;  ; TCollection * GetListOfMethodOverloads (const char *name) const;  Return the collection of functions named ""name"". ;  ; TList * GetListOfMethods (Bool_t load=kTRUE);  Return list containing the TMethods of a class. ;  ; TList * GetListOfRealData () const;  ; TList * GetListOfUsingDataMembers (Bool_t load=kTRUE);  Return list containing the TDataMembers of using declarations of a class. ;  ; void GetMenuItems (TList *listitems);  Returns list of methods accessible by context menu. ;  ; TList * GetMenuList () const;  Return the list of menu items associated with the class. ;  ; ROOT::MergeFunc_t GetMerge () const;  Return the wrapper around Merge. ;  ; TMethod * GetMethod (const char *method, const char *params, Bool_t objectIs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQClass.html:11543,load,load,11543,doc/master/classTQClass.html,https://root.cern,https://root.cern/doc/master/classTQClass.html,3,['load'],['load']
Performance,"t. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect.; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 527 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 493 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:26727,concurren,concurrent,26727,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['concurren'],['concurrent']
Performance,"t. This is equivalent to make install for Unix systems. ; It is possible to set a different install prefix at installation time by invoking the cmake_install.cmake script generated in the build directory:; $ cmake -DCMAKE_INSTALL_PREFIX=/tmp/root -P cmake_install.cmake. Build Options; Each build option is a boolean variable that can be turned ON or OFF. The current value is recorded in the CMake cache (CMakeCache.txt file on the build directory) and therefore it is not needed to be specified on the cmake command each time. Please note that some of the options might be turned OFF automatically for some platforms or if the required external library or component can not be satisfied. The user can view and edit the full list of options using the ccmake utility or cmake-gui for Windows. Note that some of the options are not yet implemented.; The user can set any CMake variable or option that controls the build process from the cmake command line. The command using the option -D <var>:<type>=<value> creates an entry in the CMake cache. This is the list of the ROOT specific CMake options:. option name; default value; description. afdsmgrd; OFF; Dataset manager for PROOF-based analysis facilities. afs; OFF; AFS support, requires AFS libs and objects. alien; ON; AliEn support, requires libgapiUI from ALICE. all; OFF; Enable all optional components. asimage; ON; Image processing support, requires libAfterImage. astiff; ON; Include tiff support in image processing. bonjour; ON; Bonjour support, requires libdns_sd and/or Avahi. builtin_afterimage; ON; Built included libAfterImage, or use system libAfterImage. builtin_fftw3; OFF; Built the FFTW3 library internally (downloading tarfile from the Web) (ROOT 6 only). builtin_ftgl; ON; Built included libFTGL, or use system libftgl. builtin_freetype; OFF; Built included libfreetype, or use system libfreetype. builtin_glew; ON; Built included libGLEW, or use system libGLEW. builtin_pcre; OFF; Built included libpcre, or use system libpc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:6889,cache,cache,6889,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['cache'],['cache']
Performance,"t. void SetDeclAttr(TInterpreter::DeclId_t , const char* ). DeclId_t GetDataMember(ClassInfo_t* cl, const char* name) const. DeclId_t GetDataMemberAtAddr(const void* addr) const. DeclId_t GetDataMemberWithValue(const void* ptrvalue) const. DeclId_t GetEnum(TClass* cl, const char* name) const. TEnum* CreateEnum(void* VD, TClass* cl) const. void UpdateEnumConstants(TEnum* enumObj, TClass* cl) const. void LoadEnums(TListOfEnums& cl) const. DeclId_t GetFunction(ClassInfo_t* cl, const char* funcname). DeclId_t GetFunctionWithPrototype(ClassInfo_t* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch). DeclId_t GetFunctionWithValues(ClassInfo_t* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE). DeclId_t GetFunctionTemplate(ClassInfo_t* cl, const char* funcname). void GetFunctionOverloads(ClassInfo_t* cl, const char* funcname, vector<TInterpreter::DeclId_t>& res) const. void LoadFunctionTemplates(TClass* cl) const. void CallFunc_Delete(CallFunc_t* ) const; CallFunc interface. {;}. void CallFunc_Exec(CallFunc_t* , void* ) const; {;}. void CallFunc_Exec(CallFunc_t* , void* , TInterpreterValue& ) const; {;}. void CallFunc_ExecWithReturn(CallFunc_t* , void* , void* ) const; {;}. void CallFunc_ExecWithArgsAndReturn(CallFunc_t* , void* , const void*[] = 0, int = 0, void* = 0) const; {}. Long_t CallFunc_ExecInt(CallFunc_t* , void* ) const; {return 0;}. Long64_t CallFunc_ExecInt64(CallFunc_t* , void* ) const; {return 0;}. Double_t CallFunc_ExecDouble(CallFunc_t* , void* ) const; {return 0;}. CallFunc_t * CallFunc_Factory() const; {return 0;}. CallFunc_t * CallFunc_FactoryCopy(CallFunc_t* ) const; {return 0;}. MethodInfo_t * CallFunc_FactoryMethod(CallFunc_t* ) const; {return 0;}. void CallFunc_IgnoreExtraArgs(CallFunc_t* , bool ) const; {;}. void CallFunc_Init(CallFunc_t* ) const; {;}. Bool_t CallFunc_IsValid(CallFunc_t* ) const; {return 0;}. CallFuncIFacePtr_t CallFunc_IFacePtr(C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TInterpreter.html:32764,Load,LoadFunctionTemplates,32764,root/html602/TInterpreter.html,https://root.cern,https://root.cern/root/html602/TInterpreter.html,2,['Load'],['LoadFunctionTemplates']
Performance,"t.Definition RooAbsPdf.h:157; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooClassFactory::makePdfstatic bool makePdf(std::string const &name, std::string const &realArgNames="""", std::string const &catArgNames="""", std::string const &expression=""1.0"", bool hasAnaInt=false, bool hasIntGen=false, std::string const &intExpression="""")Write code for a RooAbsPdf implementation with class name 'name'.Definition RooClassFactory.cxx:335; RooClassFactory::makePdfInstancestatic RooAbsPdf * makePdfInstance(std::string const &className, std::string const &name, std::string const &expression, const RooArgList &vars, std::string const &intExpression="""")Write, compile and load code and instantiate object for a RooAbsPdf implementation with class name 'n...Definition RooClassFactory.cxx:320; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf104__classfactory_8C.html:6646,load,load,6646,doc/master/rf104__classfactory_8C.html,https://root.cern,https://root.cern/doc/master/rf104__classfactory_8C.html,1,['load'],['load']
Performance,t.cxx. ◆ inputBaseName(). const char * RooNumRunningInt::inputBaseName ; (; ); const. overrideprotectedvirtual . Return unique name for RooAbsCachedPdf cache components constructed from input function name. ; Implements RooAbsCachedReal.; Definition at line 88 of file RooNumRunningInt.cxx. ◆ IsA(). TClass * RooNumRunningInt::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsCachedReal.; Definition at line 63 of file RooNumRunningInt.h. ◆ payloadUniqueSuffix(). const char * RooNumRunningInt::payloadUniqueSuffix ; (; ); const. inlineoverrideprotectedvirtual . Reimplemented from RooAbsCachedReal.; Definition at line 55 of file RooNumRunningInt.h. ◆ Streamer(). void RooNumRunningInt::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsCachedReal. ◆ StreamerNVirtual(). void RooNumRunningInt::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 63 of file RooNumRunningInt.h. Friends And Related Symbol Documentation. ◆ RICacheElem. friend class RICacheElem. friend . Definition at line 46 of file RooNumRunningInt.h. Member Data Documentation. ◆ _binningName. std::string RooNumRunningInt::_binningName. protected . Name of binning to be used for cache histogram. ; Definition at line 59 of file RooNumRunningInt.h. ◆ func. RooRealProxy RooNumRunningInt::func. protected . Proxy to functions whose running integral is calculated. ; Definition at line 57 of file RooNumRunningInt.h. ◆ x. RooRealProxy RooNumRunningInt::x. protected . Integrated observable. ; Definition at line 58 of file RooNumRunningInt.h. Libraries for RooNumRunningInt:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooNumRunningInt.h; roofit/roofitcore/src/RooNumRunningInt.cxx. RooNumRunningInt. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:03 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumRunningInt.html:67924,cache,cache,67924,doc/master/classRooNumRunningInt.html,https://root.cern,https://root.cern/doc/master/classRooNumRunningInt.html,1,['cache'],['cache']
Performance,"t1, . TEntryList & ; elist2 . ). friend . Definition at line 1385 of file TEntryList.cxx. Member Data Documentation. ◆ fBlocks. TObjArray* TEntryList::fBlocks. protected . blocks with indices of passing events (TEntryListBlocks) ; Definition at line 35 of file TEntryList.h. ◆ fCurrent. TEntryList* TEntryList::fCurrent. protected . ! currently filled entry list ; Definition at line 32 of file TEntryList.h. ◆ fDirectory. TDirectory* TEntryList::fDirectory. protected . ! Pointer to directory holding this tree ; Definition at line 48 of file TEntryList.h. ◆ fEntriesToProcess. Long64_t TEntryList::fEntriesToProcess. protected . used on proof to set the number of entries to process in a packet ; Definition at line 37 of file TEntryList.h. ◆ fFileName. TString TEntryList::fFileName. protected . name of the file, where the tree is ; Definition at line 39 of file TEntryList.h. ◆ fLastIndexQueried. Long64_t TEntryList::fLastIndexQueried. protected . ! used to optimize GetEntry() function from a loop ; Definition at line 44 of file TEntryList.h. ◆ fLastIndexReturned. Long64_t TEntryList::fLastIndexReturned. protected . ! used to optimize GetEntry() function from a loop ; Definition at line 45 of file TEntryList.h. ◆ fLists. TList* TEntryList::fLists. protected . a list of underlying entry lists for each tree of a chain ; Definition at line 31 of file TEntryList.h. ◆ fN. Long64_t TEntryList::fN. protected . number of entries in the list ; Definition at line 36 of file TEntryList.h. ◆ fNBlocks. Int_t TEntryList::fNBlocks. protected . number of TEntryListBlocks ; Definition at line 34 of file TEntryList.h. ◆ fReapply. bool TEntryList::fReapply. protected . If true, TTree::Draw will 'reapply' the original cut. ; Definition at line 49 of file TEntryList.h. ◆ fShift. bool TEntryList::fShift. protected . ! true when some sub-lists don't correspond to trees (when the entry list is used as input in TChain) ; Definition at line 46 of file TEntryList.h. ◆ fStringHash. ULong_t TEntryList::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryList.html:42709,optimiz,optimize,42709,doc/master/classTEntryList.html,https://root.cern,https://root.cern/doc/master/classTEntryList.html,1,['optimiz'],['optimize']
Performance,"t: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); ; ; ; -------------- Starting second fit ---------------; ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -1002.2262595660759; Edm = 2.95538313214564806e-09; Nfcn = 251; a1 = -0.498159 +/- 0.0227242 (limited); a2 = 0.198316 +/- 0.00564906 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 0, estimated distance to minimum: 0; covariance matrix quality: Not calculated at all; Status : MINIMIZE=-1 HESSE=302 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 1.0000e+01 +/- 0.00e+00; a2 -1.0000e+00 +/- 0.00e+00; ; Without recovery, the fitter encountered 23 invalid function values. The parameters are unchanged.; ; RooFitResult: minimized FCN value: 29650.9, estimated distan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:10410,optimiz,optimization,10410,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,1,['optimiz'],['optimization']
Performance,"t: filename - name of the file to convert; title - title which will be placed at the top of the HTML file; dirname - optional parameter, if it's not specified, output will; be placed in htmldoc/examples directory.; relpath - optional parameter pointing to the THtml generated doc; on the server, relative to the current page.; includeOutput - if != kNoOutput, run the script passed as filename and; store all created canvases in PNG files that are; shown next to the converted source. Bitwise-ORing with; re-runs the script even if output PNGs exist that are newer; than the script. If kCompiledOutput is passed, the script is; run through ACLiC (.x filename+); context - line shown verbatim at the top of the page; e.g. for links.; If context is non-empty it is expected to also print the; title. NOTE: Output file name is the same as filename, but with extension .html. void GetModuleNameForClass(TString& module, TClass* cl) const; Return the module name for a given class.; Use the cached information from fDocEntityInfo.fClasses. void CreateListOfClasses(const char* filter); Create the list of all known classes. void CreateListOfTypes(); Create index of all data types and a page for each typedef-to-class. Bool_t CopyFileFromEtcDir(const char* filename) const; Copy a file from $ROOTSYS/etc/html into GetOutputDir(). void CreateHierarchy(); Create the inheritance hierarchy diagram for all classes. void CreateJavascript() const; Write the default ROOT style sheet. void CreateStyleSheet() const; Write the default ROOT style sheet. void GetDerivedClasses(TClass* cl, map<TClass*,Int_t>& derived) const; fill derived with all classes inheriting from cl and their inheritance; distance to cl. void GetHtmlFileName(TClass* classPtr, TString& filename) const; Return real HTML filename. Input: classPtr - pointer to a class; filename - string containing a full name; of the corresponding HTML file after the function returns. const char* GetHtmlFileName(const char* classname) const; Get the html",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THtml.html:29940,cache,cached,29940,root/html528/THtml.html,https://root.cern,https://root.cern/root/html528/THtml.html,1,['cache'],['cached']
Performance,"t::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; static voidblockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiVarGaussian.html:2157,Cache,CacheModeRooAbsArg,2157,root/html602/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html602/RooMultiVarGaussian.html,2,['Cache'],['CacheModeRooAbsArg']
Performance,"t::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TList::AddFirstvoid AddFirst(TObject *obj) overrideAdd object at the beginning of the list.Definition TList.cxx:98; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TMethod::GetCommentStringvirtual const char * GetCommentString()Returns a comment string from the class declaration.Definition TMethod.cxx:107; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjLinkWrapper around a TObject so it can be stored in a TList.Definition TList.h:123; TObjLink::GetObjectTObject * GetObject() constDefinition TList.h:145; TObjLink::NextTObjLink * Next()Definition TList.h:151; TPMERegexpWrapper for PCRE library (Perl Compatible Regular Expressions).Definition TPRegexp.h:97; TPMERegexp::SubstituteInt_t Substitute(TString &s, const TString &r, Bool_t doDollarSubst=kTRUE)Substitute matching part of s with r, dollar back-ref substitution is performed if doDollarSubst is t...Definition TPRegexp.cxx:963; TQClassDefinition TQClass.h:33; TQConnectionListTQConnectionList is the named list of connections, see also TQConnection class.Definition TQObject.cxx:309; TQConnectionList::lsvoid ls(Option_t *option="""") const overrideList signal name and list all connections in this signal list.Definition TQObject.cxx:378; TQConnectionList::TQConnectionListTQConnectionList(const char *name, Int_t nsigargs)Definition TQObject.cxx:315; TQConnectionList::DisconnectBool_t Disconnect(void *receiver=nullptr, const char *slot_name=nullptr)Remove connection from the list.Definition TQObject.cxx:344; TQConnectionList::GetNargsInt_t GetNargs() constDefinition TQObject.cxx:320; TQConnectionList::fSignalArgsInt_t fSignalArgsDefinition TQObject.cxx:312; TQConnectionList::~TQConnectionListvirtual ~TQConnectionList()Destructor.Definition TQObject.cxx:327; TQConnectionTQConnection clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8cxx_source.html:42289,perform,performed,42289,doc/master/TQObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html,1,['perform'],['performed']
Performance,"t::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TEntryListFromFile(const TEntryListFromFile&); TEntryListFromFile&operator=(const TEntryListFromFile&). Data Members; public:. enum { kBigNumber; };; enum TEntryList::[unnamed] { kBlockSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArray*TEntryList::fBlocksblocks with indices of passing events (TEntryListBlocks); TEntryList*TEntryList::fCurrent! currently filled entry list; TDirectory*TEntryList::fDirectory! Pointer to directory holding this tree; Long64_tTEntryList::fEntriesToProcessused on proof to set the number of entries to process in a packet; TFile*fFilecurrently open file; TStringTEntryList::fFileNamename of the file, where the tree is; TObjArray*fFileNames! points to the fFiles data member of the corresponding chain; Long64_tTEntryList::fLastIndexQueried! used to optimize GetEntry() function from a loop ; Long64_tTEntryList::fLastIndexReturned! used to optimize GetEntry() function from a loop; TStringfListFileNamefrom this string names of all files can be found; TStringfListNamename of the list; Long64_t*fListOffset[fNFiles] numbers of entries in ind. lists; TList*TEntryList::fListsa list of underlying entry lists for each tree of a chain; Long64_tTEntryList::fNnumber of entries in the list; Int_tTEntryList::fNBlocksnumber of TEntryListBlocks; Int_tfNFilestotal number of files; TStringTNamed::fNameobject identifier; Bool_tTEntryList::fReapplyIf true, TTree::Draw will 'reapply' the original cut; Bool_tTEntryList::fShift! true when some sub-lists don't correspond to trees; ULong_tTEntryList::fStringHash! Hash value of a string of treename and filename; TStringTNamed::fTitleobject title; TStringTEntryList::fTreeNamenam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEntryListFromFile.html:8912,optimiz,optimize,8912,root/html534/TEntryListFromFile.html,https://root.cern,https://root.cern/root/html534/TEntryListFromFile.html,2,['optimiz'],['optimize']
Performance,"t::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TProof*fProofproof. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBenchDataSet(TProof* proof = 0); Constructor. Int_t ReleaseCache(const char* dset); Release memory cache for dataset 'dset'; Return 0 on success, -1 on error. Int_t RemoveFiles(const char* dset); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. Int_t CopyFiles(const char* dset, const char* destdir); Copy the files of dataset 'dset' to another directory; Return 0 on success, -1 on error. Int_t Handle(const char* dset, TObject* type); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. TProofBenchDataSet(TProof* proof = 0). virtual ~TProofBenchDataSet(); { }. Bool_t IsProof(TProof* p); { return (p == fProof) ? kTRUE : kFALSE; }. » Author: Sangsu Ryu 22/06/2010 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-02 16:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofBenchDataSet.html:6127,cache,cache,6127,root/html604/TProofBenchDataSet.html,https://root.cern,https://root.cern/root/html604/TProofBenchDataSet.html,1,['cache'],['cache']
Performance,"t::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TProof*fProofproof. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBenchDataSet(TProof* proof = 0); Constructor. Int_t ReleaseCache(const char* dset); Release memory cache for dataset 'dset'; Return 0 on success, -1 on error. Int_t RemoveFiles(const char* dset); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. Int_t CopyFiles(const char* dset, const char* destdir); Copy the files of dataset 'dset' to another directory; Return 0 on success, -1 on error. Int_t Handle(const char* dset, TObject* type); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. TProofBenchDataSet(TProof* proof = 0). virtual ~TProofBenchDataSet(); { }. Bool_t IsProof(TProof* p); { return (p == fProof) ? kTRUE : kFALSE; }. » Author: Sangsu Ryu 22/06/2010 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-30 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofBenchDataSet.html:6127,cache,cache,6127,root/html602/TProofBenchDataSet.html,https://root.cern,https://root.cern/root/html602/TProofBenchDataSet.html,1,['cache'],['cache']
Performance,"t::MakeZombie(). private:. TFileCacheWrite(const TFileCacheWrite&); TFileCacheWrite&operator=(const TFileCacheWrite&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileCacheWrite.html:6407,cache,cache,6407,root/html528/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html528/TFileCacheWrite.html,4,['cache'],['cache']
Performance,"t::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetCacheAllNumeric(Int_t ndim); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCacheNumeric(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealIntegral.html:23032,cache,cache,23032,root/html532/RooRealIntegral.html,https://root.cern,https://root.cern/root/html532/RooRealIntegral.html,1,['cache'],['cache']
Performance,"t::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidsetAllInterpCodes(int code); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); Bool_tsetBinIntegrator(RooArgSet& allVars); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpCode(RooAbsReal& param, int code); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidsetPositiveDefinite(bool flag = true); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/PiecewiseInterpolation.html:23362,cache,cache,23362,root/html532/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html532/PiecewiseInterpolation.html,1,['cache'],['cache']
Performance,"t::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveEventManager(const char* n = ""TEveEventManager"", const char* t = """"); Constructor. void AfterNewEventLoaded(); Virtual function to be called after a new event is loaded.; It iterates over the list of registered commands; (fNewEventCommands) and executes them in given order. void AddNewEventCommand(const TString& cmd); Register a command to be executed on each new event. void RemoveNewEventCommand(const TString& cmd); Remove the first command equal to cmd. void ClearNewEventCommands(); Clear the list of commands to be executed on each new event. virtual ~TEveEventManager(); {}. std::vector<TString>& GetNewEventCommands(); { return fNewEventCommands; }. void Open(); {}. void GotoEvent(Int_t ); {}. void NextEvent(); {}. void PrevEvent(); {}. void Close(); {}. » Last changed: root/eve:$Id: TEveEventManager.h 27157 2009-01-15 14:05:12Z brun $ » Last generated: 2010-09-23 20:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveEventManager.html:19736,load,loaded,19736,root/html528/TEveEventManager.html,https://root.cern,https://root.cern/root/html528/TEveEventManager.html,1,['load'],['loaded']
Performance,"t::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveEventManager(const char* n = ""TEveEventManager"", const char* t = """"); Constructor. void AfterNewEventLoaded(); Virtual function to be called after a new event is loaded.; It iterates over the list of registered commands; (fNewEventCommands) and executes them in given order. void AddNewEventCommand(const TString& cmd); Register a command to be executed on each new event. void RemoveNewEventCommand(const TString& cmd); Remove the first command equal to cmd. void ClearNewEventCommands(); Clear the list of commands to be executed on each new event. virtual ~TEveEventManager(); {}. std::vector<TString>& GetNewEventCommands(); { return fNewEventCommands; }. void Open(); {}. void GotoEvent(Int_t ); {}. void NextEvent(); {}. void PrevEvent(); {}. void Close(); {}. » Last changed: root/eve:$Id: TEveEventManager.h 27157 2009-01-15 14:05:12Z brun $ » Last generated: 2011-07-04 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveEventManager.html:20102,load,loaded,20102,root/html530/TEveEventManager.html,https://root.cern,https://root.cern/root/html530/TEveEventManager.html,1,['load'],['loaded']
Performance,"t::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveEventManager(const char* n = ""TEveEventManager"", const char* t = """"); Constructor. void AfterNewEventLoaded(); Virtual function to be called after a new event is loaded.; It iterates over the list of registered commands; (fNewEventCommands) and executes them in given order. void AddNewEventCommand(const TString& cmd); Register a command to be executed on each new event. void RemoveNewEventCommand(const TString& cmd); Remove the first command equal to cmd. void ClearNewEventCommands(); Clear the list of commands to be executed on each new event. virtual ~TEveEventManager(); {}. std::vector<TString>& GetNewEventCommands(); { return fNewEventCommands; }. void Open(); {}. void GotoEvent(Int_t ); {}. void NextEvent(); {}. void PrevEvent(); {}. void Close(); {}. » Last changed: root/eve:$Id: TEveEventManager.h 27157 2009-01-15 14:05:12Z brun $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveEventManager.html:20102,load,loaded,20102,root/html532/TEveEventManager.html,https://root.cern,https://root.cern/root/html532/TEveEventManager.html,1,['load'],['loaded']
Performance,"t::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TStringfClassNameclass name of the receiver; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TStringTCollection::fNamename of the collection; void*fReceiverptr to object to which slot is applied; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; TQSlot*fSlotslot-method calling interface; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQConnection. Function documentation; TQConnection(); Default constructor. TQConnection(TClass* cl, void* receiver, const char* method_name); TQConnection ctor.; cl != 0 - connection to object == receiver of class == cl; and method == method_name; cl == 0 - connection to function with name == method_name. TQConnection(const char* class_name, void* receiver, const char* method_name); TQConnection ctor.; Creates conn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQConnection.html:14256,cache,cache,14256,root/html602/TQConnection.html,https://root.cern,https://root.cern/root/html602/TQConnection.html,2,['cache'],['cache']
Performance,"t::kIsReferenced; static TFormula::(anonymous)kLinear; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TFormula::(anonymous)kNormalized; static TObject::(anonymous)TObject::kNotDeleted; static TFormula::(anonymous)kNotGlobal; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TBitsfAlreadyFound! cache for information; Double_t*fConst[fNconst] Array of fNconst formula constants; TString*fExpr[fNoper] List of expressions; TString*fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfFunctionsArray of function calls to make; TObjArrayfLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_tfNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*fNames[fNpar] Array of parameter names; Int_tfNconstNumber of constants; Int_tfNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNoperNumber of operators; Int_tfNparNumber of parameters; Int_tfNstringNumber of different constants character strings; Int_tfNumberformula number identifier; Int_tfNvalNumber of different variables in expression; TOperOffset*fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); TFormula::TFuncGfOptimal!pointer to optimal function; Double_t*fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**fPredefined![fNPar] predefined function; TStringTNamed::fTitleobject title; static TFormula::(anonymous)kAdd; static TFormula::(anonymous)kAnd; static TFormula::(anonymous)kBinary; static TFormula::(anonymous)kBitAnd; static TFormula::(anonymous)kBitOr; static TFormula::(anonymous)kBoolOptimize; static TFormula::(anonymous)kBoolOptimizeAnd; static TFormula::(an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFormula.html:12307,cache,cache,12307,root/html602/TFormula.html,https://root.cern,https://root.cern/root/html602/TFormula.html,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"t::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. static RooExpensiveObjectCache*_instance!; map<TString,RooExpensiveObjectCache::ExpensiveObject*>_map; Int_t_nextUID. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooExpensiveObjectCache(); Constructor. RooExpensiveObjectCache(const RooExpensiveObjectCache& ); Copy constructor. ~RooExpensiveObjectCache(); Destructor. RooExpensiveObjectCache& instance(); Return reference to singleton instance. void cleanup(); Static function called by RooSentinel atexit() handler to cleanup at end of program. Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, const RooArgSet& params); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve object from cache that was registered under given name with given parameters, _if_; current parameter values match those that were stored in the registry for this object.; The return object is owned by the cache instance. cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExpensiveObjectCache.html:7412,cache,cache,7412,root/html602/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html602/RooExpensiveObjectCache.html,4,['cache'],"['cache', 'cacheObject']"
Performance,"t::xRooNLLVar::xRooHypoSpace;  xRooHypoSpace (const char *name="""", const char *title="""");  ;  xRooHypoSpace (const RooStats::HypoTestInverterResult *result);  ; bool AddModel (const xRooNode &pdf, const char *validity="""");  ; xRooHypoPoint & AddPoint (const char *coords="""");  ; xRooHypoPoint & AddPoint (double value);  ; int AddPoints (const char *parName, size_t nPoints, double low, double high);  ; RooArgList axes () const;  ; void Draw (Option_t *opt="""") override;  Default Draw method for all objects. ;  ; xValueWithError findlimit (const char *opt, double relUncert=std::numeric_limits< double >::infinity(), unsigned int maxTries=20);  ; std::shared_ptr< TGraphErrors > graph (const char *opt) const;  ; std::shared_ptr< TMultiGraph > graphs (const char *opt);  ; xValueWithError limit (const char *type=""cls"", double nSigma=std::numeric_limits< double >::quiet_NaN()) const;  ; std::map< std::string, xValueWithError > limits (const char *opt=""cls"", const std::vector< double > &nSigmas={0, 1, 2, -1, -2, std::numeric_limits< double >::quiet_NaN()}, double relUncert=std::numeric_limits< double >::infinity());  ; void LoadFits (const char *apath);  ; std::shared_ptr< RooArgSet > pars () const;  ; std::shared_ptr< xRooNode > pdf (const char *parValues="""") const;  ; std::shared_ptr< xRooNode > pdf (const RooAbsCollection &parValues) const;  ; RooArgList poi ();  ; xRooHypoPoint & point (size_t i);  ; void Print (Option_t *opt="""") const override;  Print TNamed name and title. ;  ; RooStats::HypoTestInverterResult * result ();  ; int scan (const char *type, double nSigma, double relUncert=0.1);  ; int scan (const char *type, size_t nPoints, double low=std::numeric_limits< double >::quiet_NaN(), double high=std::numeric_limits< double >::quiet_NaN(), const std::vector< double > &nSigmas={0, 1, 2, -1, -2, std::numeric_limits< double >::quiet_NaN()}, double relUncert=0.1);  ; int scan (const char *type=""cls"", const std::vector< double > &nSigmas={0, 1, 2, -1, -2, std::numeric_li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooHypoSpace.html:1761,Load,LoadFits,1761,doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooHypoSpace.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooHypoSpace.html,1,['Load'],['LoadFits']
Performance,"t; 3263/// - option of transform type; 3264/// - ""R2C"" - real to complex transforms - default; 3265/// - ""R2HC"" - real to halfcomplex (special format of storing output data,; 3266/// results the same as for R2C); 3267/// - ""DHT"" - discrete Hartley transform; 3268/// real to real transforms (sine and cosine):; 3269/// - ""R2R_0"", ""R2R_1"", ""R2R_2"", ""R2R_3"" - discrete cosine transforms of types I-IV; 3270/// - ""R2R_4"", ""R2R_5"", ""R2R_6"", ""R2R_7"" - discrete sine transforms of types I-IV; 3271/// To specify the type of each dimension of a 2-dimensional real to real; 3272/// transform, use options of form ""R2R_XX"", for example, ""R2R_02"" for a transform,; 3273/// which is of type ""R2R_0"" in 1st dimension and ""R2R_2"" in the 2nd.; 3274/// - option of transform flag; 3275/// - ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; 3276/// performance; 3277/// - ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; 3278/// - ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; 3279/// - ""EX"" (from ""exhaustive"") - the most optimal way is found; 3280/// This option should be chosen depending on how many transforms of the same size and; 3281/// type are going to be done. Planning is only done once, for the first transform of this; 3282/// size and type. Default is ""ES"".; 3283///; 3284/// Examples of valid options: ""Mag R2C M"" ""Re R2R_11"" ""Im R2C ES"" ""PH R2HC EX""; 3285 ; 3286TH1* TH1::FFT(TH1* h_output, Option_t *option); 3287{; 3288 ; 3289 Int_t ndim[3];; 3290 ndim[0] = this->GetNbinsX();; 3291 ndim[1] = this->GetNbinsY();; 3292 ndim[2] = this->GetNbinsZ();; 3293 ; 3294 TVirtualFFT *fft;; 3295 TString opt = option;; 3296 opt.ToUpper();; 3297 if (!opt.Contains(""2R"")){; 3298 if (!opt.Contains(""2C"") && !opt.Contains(""2HC"") && !opt.Contains(""DHT"")) {; 3299 //no type specified, ""R2C"" by default; 3300 opt.Append(""R2C"");; 3301 }; 3302 fft = TVirtualFFT::FFT(this->GetDimension(), ndim, opt.Da",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:130969,perform,performance,130969,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['perform'],['performance']
Performance,"t; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; TIterator*_varItr! do not persist; RooSetProxy_varList; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooMomentMorph(); coverity[UNINIT_CTOR]. RooMomentMorph(const char* name, const char* title, RooAbsReal& _m, const RooArgList& varList, const RooArgList& pdfList, const TVectorD& mrefpoints, RooMomentMorph::Setting setting = NonLinearPosFractions); CTOR. RooMomentMorph(const char* name, const char* title, RooAbsReal& _m, const RooArgList& varList, const RooArgList& pdfList, const RooArgList& mrefList, RooMomentMorph::Setting setting = NonLinearPosFractions); CTOR. RooMomentMorph(const RooMomentMorph& other, const char* name = 0). ~RooMomentMorph(). void initialize(). Double_t getVal(const RooArgSet* set = 0) const; Special version of getVal() overrides RooAbsReal::getVal() to save value of current normalization set. RooAbsPdf* sumPdf(const RooArgSet* nset). Double_t evaluate() const. int idxmin(const double& m) const. int idxmax(const double& m) const. TObject* clone(const char* newname) const; { return new RooMomentMorph(*this,newname); }. void setMode(const RooMomentMorph::Setting& setting); { _setting = setting; }. void useHorizontalMorphing(bool val); { _useHorizMorph = val; }. Bool_t selfNormalized() const; P.d.f is self normalized. CacheElem* getCache(const RooArgSet* nset) const. Int_t ij(const Int_t& i, const Int_t& j) const; { return (i*_varList.getSize()+j); }. » Last changed: Tue Jun 2 15:32:12 2015 » Last generated: 2015-06-02 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooMomentMorph.html:46885,Cache,CacheElem,46885,root/html604/RooMomentMorph.html,https://root.cern,https://root.cern/root/html604/RooMomentMorph.html,1,['Cache'],['CacheElem']
Performance,"t; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual RooAbsArg&operator=(const RooAbsReal& other); virtual RooAbsArg&operator=(Double_t newValue); virtual RooAbsArg&operator=(Int_t ival); RooAbsRealLValue&operator=(const RooAbsRealLValue&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsRealLValue.html:22931,optimiz,optimizeCacheMode,22931,root/html602/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsRealLValue.html,2,['optimiz'],['optimizeCacheMode']
Performance,"t; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. DictFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealDat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:35792,load,load,35792,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,4,['load'],"['load', 'loading']"
Performance,"t; Return the TMethod or TFunction describing the function corresponding; to the Decl 'id'. Return NULL if not found. TFunction * Get(TListOfFunctions::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the functions known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TFunction* func); Mark 'func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TObject* FindObject(const TObject* obj) const. TIterator* MakeIterator(Bool_t dir = kIterForward) const. TObject* At(Int_t idx) const. TObject* After(const TObject* obj) const. TObject* Before(const TObject* obj) const. TObject* First() const. TObjLink* FirstLink() const. TObject** GetObjectRef(const TObject* obj) const. TObject* Last() const. TObjLink* LastLink() const. Int_t GetLast() const. Int_t IndexOf(const TObject* obj) const. Int_t GetSize() const. TListOfFunctions(const TListOfFunctions& ). TListO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfFunctions.html:14813,Load,Load,14813,root/html604/TListOfFunctions.html,https://root.cern,https://root.cern/root/html604/TListOfFunctions.html,2,['Load'],['Load']
Performance,"t; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TObject*GetGeometry(const char* name) const; TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfClosedObjects() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory::GetListOfKeys() const; TSeqCollection*GetListOfMappedFiles() const; TSeqCollection*GetListOfMessageHandlers() const; TSeqCollection*GetListOfProofs() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TROOT.html:6084,load,load,6084,root/html530/TROOT.html,https://root.cern,https://root.cern/root/html530/TROOT.html,2,['load'],['load']
Performance,"t; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TObject*GetGeometry(const char* name) const; TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory::GetListOfKeys() const; TSeqCollection*GetListOfMappedFiles() const; TSeqCollection*GetListOfMessageHandlers() const; TSeqCollection*GetListOfProofs() const; TSeqCollection*GetListOfSecContexts() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:6073,load,load,6073,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['load'],['load']
Performance,"t; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tGetClassSize() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; ROOT::ESTLTypeGetCollectionType() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tGetConvStreamerFunc() const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClass.html:5043,load,load,5043,root/html604/TClass.html,https://root.cern,https://root.cern/root/html604/TClass.html,1,['load'],['load']
Performance,"t; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tGetClassSize() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tGetConvStreamerFunc() const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataMember*GetDataMember(const char* datamembe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:4446,load,load,4446,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,1,['load'],['load']
Performance,"t; functionality is only basic: ROOT objects and builtin types can freely cross; the boundary between the two interpreters, python objects can be instantiated; and their methods can be called. All other cross-coding is based on strings; that are run on the python interpreter. Examples:. $ cat MyPyClass.py; print 'creating class MyPyClass ... '. class MyPyClass:; def __init__( self ):; print 'in MyPyClass.__init__'. def gime( self, what ):; return what. $ root -l; // Execute a string of python code.; root [0] TPython::Exec( ""print \'Hello World!\'"" );; Hello World!. // Create a TBrowser on the python side, and transfer it back and forth.; // Note the required explicit (void*) cast!; root [1] TBrowser* b = (void*)TPython::Eval( ""ROOT.TBrowser()"" );; root [2] TPython::Bind( b, ""b"" );; root [3] b == (void*) TPython::Eval( ""b"" ); (int)1. // Builtin variables can cross-over by using implicit casts.; root [4] int i = TPython::Eval( ""1 + 1"" );; root [5] i; (int)2. // Load a python module with a class definition, and use it. Casts are; // necessary as the type information can not be otherwise derived.; root [6] TPython::LoadMacro( ""MyPyClass.py"" );; creating class MyPyClass ...; root [7] MyPyClass m;; in MyPyClass.__init__; root [8] std::string s = (char*)m.gime( ""aap"" );; root [9] s; (class TString)""aap"". It is possible to switch between interpreters by calling ""TPython::Prompt()""; on the CINT side, while returning with ^D (EOF). State is preserved between; successive switches. The API part provides (direct) C++ access to the bindings functionality of; PyROOT. It allows verifying that you deal with a PyROOT python object in the; first place (ObjectProxy_Check for ObjectProxy and any derived types, as well; as ObjectProxy_CheckExact for ObjectProxy's only); and it allows conversions; of void* to an ObjectProxy and vice versa. Function Members (Methods); public:. TPython(); TPython(const TPython&); virtual~TPython(); static Bool_tBind(TObject* object, const char* label); stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPython.html:1348,Load,Load,1348,root/html530/TPython.html,https://root.cern,https://root.cern/root/html530/TPython.html,3,['Load'],['Load']
Performance,"t; functionality is only basic: ROOT objects and builtin types can freely cross; the boundary between the two interpreters, python objects can be instantiated; and their methods can be called. All other cross-coding is based on strings; that are run on the python interpreter. Examples:. $ cat MyPyClass.py; print 'creating class MyPyClass ... '. class MyPyClass:; def __init__( self ):; print 'in MyPyClass.__init__'. def gime( self, what ):; return what. $ root -l; // Execute a string of python code.; root [0] TPython::Exec( ""print \'Hello World!\'"" );; Hello World!. // Create a TBrowser on the python side, and transfer it back and forth.; // Note the required explicit (void*) cast!; root [1] TBrowser* b = (void*)TPython::Eval( ""ROOT.TBrowser()"" );; root [2] TPython::Bind( b, ""b"" );; root [3] b == (void*) TPython::Eval( ""b"" ); (int)1. // Builtin variables can cross-over by using implicit casts.; root [4] int i = TPython::Eval( ""1 + 1"" );; root [5] i; (int)2. // Load a python module with a class definition, and use it. Casts are; // necessary as the type information can not be otherwise derived.; root [6] TPython::LoadMacro( ""MyPyClass.py"" );; creating class MyPyClass ...; root [7] MyPyClass m;; in MyPyClass.__init__; root [8] std::string s = (char*)m.gime( ""aap"" );; root [9] s; (class TString)""aap"". It is possible to switch between interpreters by calling ""TPython::Prompt()""; on the Cling side, while returning with ^D (EOF). State is preserved between; successive switches. The API part provides (direct) C++ access to the bindings functionality of; PyROOT. It allows verifying that you deal with a PyROOT python object in the; first place (ObjectProxy_Check for ObjectProxy and any derived types, as well; as ObjectProxy_CheckExact for ObjectProxy's only); and it allows conversions; of void* to an ObjectProxy and vice versa. Function Members (Methods); public:. virtual~TPython(); static Bool_tBind(TObject* object, const char* label); static TClass*Class(); static const TPyR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPython.html:1349,Load,Load,1349,root/html602/TPython.html,https://root.cern,https://root.cern/root/html602/TPython.html,2,['Load'],['Load']
Performance,"t; functionality is only basic: ROOT objects and builtin types can freely cross; the boundary between the two interpreters, python objects can be instantiated; and their methods can be called. All other cross-coding is based on strings; that are run on the python interpreter. Examples:. $ cat MyPyClass.py; print 'creating class MyPyClass ... '. class MyPyClass:; def __init__( self ):; print 'in MyPyClass.__init__'. def gime( self, what ):; return what. $ root -l; // Execute a string of python code.; root [0] TPython::Exec( ""print \'Hello World!\'"" );; Hello World!. // Create a TBrowser on the python side, and transfer it back and forth.; // Note the required explicit (void*) cast!; root [1] TBrowser* b = (void*)TPython::Eval( ""ROOT.TBrowser()"" );; root [2] TPython::Bind( b, ""b"" );; root [3] b == (void*) TPython::Eval( ""b"" ); (int)1. // Builtin variables can cross-over by using implicit casts.; root [4] int i = TPython::Eval( ""1 + 1"" );; root [5] i; (int)2. // Load a python module with a class definition, and use it.; root [6] TPython::LoadMacro( ""MyPyClass.py"" );; creating class MyPyClass ...; root [7] MyPyClass m;; in MyPyClass.__init__; root [8] char* s = m.gime( ""aap"" );; root [9] s; (char* 0x41ee7754)""aap"". It is possible to switch between interpreters by calling ""TPython::Prompt()""; on the CINT side, while returning with ^D (EOF). State is preserved between; successive switches. The API part provides (direct) C++ access to the bindings functionality of; PyROOT. It allows verifying that you deal with a PyROOT python object in the; first place (ObjectProxy_Check for ObjectProxy and any derived types, as well; as ObjectProxy_CheckExact for ObjectProxy's only); and it allows conversions; of void* to an ObjectProxy and vice versa. Function Members (Methods); public:. TPython(); TPython(const TPython&); virtual~TPython(); static Bool_tBind(TObject* object, const char* label); static TClass*Class(); static const TPyReturnEval(const char* expr); static Bool_tExec(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPython.html:1348,Load,Load,1348,root/html528/TPython.html,https://root.cern,https://root.cern/root/html528/TPython.html,1,['Load'],['Load']
Performance,"t; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fUp; }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit). { return fValidError; }. opt. SetPrintLevel(int level). opt. SetStrategy(int strategyLevel). opt. SetMaxFunctionCalls(unsigned int maxfcn). opt. SetMaxIterations(unsigned int maxiter). opt. SetTolerance(double tol). opt. SetPrecision(double prec). opt. SetErrorDef(double up). void SetValidError(bool on); flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit). { fValidError = on; }. void SetOptions(const ROOT::Math::MinimizerOptions& opt); set all options in one go. void SetDefaultOptions(); reset the defaut options (defined in MinimizerOptions). » Author: L. Moneta Fri Sep 22 15:06:47 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: Minimizer.h 36905 2010-11-24 15:44:34Z moneta $ » Last generated: 2010-11-25 07:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__Minimizer.html:10297,perform,perform,10297,root/html528/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__Minimizer.html,1,['perform'],['perform']
Performance,"t; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fUp; }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit). { return fValidError; }. opt. SetPrintLevel(int level). opt. SetStrategy(int strategyLevel). opt. SetMaxFunctionCalls(unsigned int maxfcn). opt. SetMaxIterations(unsigned int maxiter). opt. SetTolerance(double tol). opt. SetPrecision(double prec). opt. SetErrorDef(double up). void SetValidError(bool on); flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit). { fValidError = on; }. void SetOptions(const ROOT::Math::MinimizerOptions& opt); set all options in one go. void SetDefaultOptions(); reset the defaut options (defined in MinimizerOptions). » Author: L. Moneta Fri Sep 22 15:06:47 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: Minimizer.h 39382 2011-05-26 08:31:43Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__Minimizer.html:11140,perform,perform,11140,root/html530/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__Minimizer.html,1,['perform'],['perform']
Performance,"t; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fUp; }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit). { return fValidError; }. opt. SetPrintLevel(int level). opt. SetStrategy(int strategyLevel). opt. SetMaxFunctionCalls(unsigned int maxfcn). opt. SetMaxIterations(unsigned int maxiter). opt. SetTolerance(double tol). opt. SetPrecision(double prec). opt. SetErrorDef(double up). void SetValidError(bool on); flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit). { fValidError = on; }. void SetOptions(const ROOT::Math::MinimizerOptions& opt); set all options in one go. void SetDefaultOptions(); reset the defaut options (defined in MinimizerOptions). » Author: L. Moneta Fri Sep 22 15:06:47 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: Minimizer.h 39382 2011-05-26 08:31:43Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__Minimizer.html:11140,perform,perform,11140,root/html532/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__Minimizer.html,1,['perform'],['perform']
Performance,"t; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; vector<double>_high; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; vector<int>_interpCode; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; vector<double>_low; static Int_tRooPrintable::_nameLength; double_nominal; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_paramIter! do not persist; RooListProxy_paramList; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HistFactory__FlexibleInterpVar.html:33054,cache,cache,33054,root/html532/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html532/RooStats__HistFactory__FlexibleInterpVar.html,2,['cache'],['cache']
Performance,"t; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree *t, const RooFormulaVar* select, const char* /*rangeName*/, Int_t /*nStart*/, Int_t /*nStop*/); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore *ads, const RooFormulaVar* select, 				 const char* rangeName, Int_t nStart, Int_t nStop); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeDataStore.html:13755,load,loadValues,13755,root/html526/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html526/RooTreeDataStore.html,2,"['Load', 'load']","['Load', 'loadValues']"
Performance,"t; vector<double>fHessian; unsigned intfNumberOfParameters; doublefValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FumiliFCNBase(). Default Constructor. Need in this case to create when implementing EvaluateAll the Gradient and Hessian vectors with the right size. {}. FumiliFCNBase(unsigned int npar). Constructor which initializes the class with the function provided by the; user for modeling the data. @param npar the number of parameters. {}. virtual ~FumiliFCNBase(); FumiliFCNBase(const ParametricFunction& modelFCN) { fModelFunction = &modelFCN; }. {}. void EvaluateAll(const vector<double>& par). Evaluate function Value, Gradient and Hessian using Fumili approximation, for values of parameters p; The resul is cached inside and is return from the FumiliFCNBase::Value , FumiliFCNBase::Gradient and; FumiliFCNBase::Hessian methods. @param par vector of parameters. double Value() const. Return cached Value of objective function estimated previously using the FumiliFCNBase::EvaluateAll method. { return fValue; }. const std::vector<double> & Gradient() const. Return cached Value of function Gradient estimated previously using the FumiliFCNBase::EvaluateAll method. { return fGradient; }. double Hessian(unsigned int row, unsigned int col) const. Return Value of the i-th j-th element of the Hessian matrix estimated previously using the FumiliFCNBase::EvaluateAll method; @param row row Index of the matrix; @param col col Index of the matrix. unsigned int Dimension(). return number of function variable (parameters) , i.e. function dimension. { return fNumberOfParameters; }. void InitAndReset(unsigned int npar). initialize and reset values of gradien and Hessian. void SetFCNValue(double value); methods to be used by the derived classes to set the values. { fValue = value; }. std::vector<double> & Gradient(); { return fGradient; }. std::vector<double> & Hessian(); { return fHessian; }. » Last changed: root/minuit2:$Id$ » Last ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__FumiliFCNBase.html:3503,cache,cached,3503,root/html602/ROOT__Minuit2__FumiliFCNBase.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__FumiliFCNBase.html,2,['cache'],['cached']
Performance,"t; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsGlobal() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGCompositeFrame::Layout(); virtual voidTVirtualPadEditor::LineAttributes(Int_t, Int_t, Int_t); static TVirtualPadEditor*TVirtualPadEditor::LoadEditor(); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); virtual voidTVirtualPadEditor::MarkerAttributes(Int_t, Int_t, Float_t); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGedEditor.html:13645,Load,LoadEditor,13645,root/html528/TGedEditor.html,https://root.cern,https://root.cern/root/html528/TGedEditor.html,1,['Load'],['LoadEditor']
Performance,"t; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsGlobal() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGCompositeFrame::Layout(); virtual voidTVirtualPadEditor::LineAttributes(Int_t, Int_t, Int_t); static TVirtualPadEditor*TVirtualPadEditor::LoadEditor(); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); virtual voidTVirtualPadEditor::MarkerAttributes(Int_t, Int_t, Float_t); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGedEditor.html:13645,Load,LoadEditor,13645,root/html530/TGedEditor.html,https://root.cern,https://root.cern/root/html530/TGedEditor.html,3,['Load'],['LoadEditor']
Performance,"t; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsGlobal() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGCompositeFrame::Layout(); virtual voidTVirtualPadEditor::LineAttributes(Int_t, Int_t, Int_t); static TVirtualPadEditor*TVirtualPadEditor::LoadEditor(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); virtual voidTVirtualPadEditor::MarkerAttributes(Int_t, Int_t, Float_t); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGedEditor.html:13573,Load,LoadEditor,13573,root/html602/TGedEditor.html,https://root.cern,https://root.cern/root/html602/TGedEditor.html,2,['Load'],['LoadEditor']
Performance,"t; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEvePlot3DGL.html:1823,cache,cached,1823,root/html528/TEvePlot3DGL.html,https://root.cern,https://root.cern/root/html528/TEvePlot3DGL.html,3,['cache'],['cached']
Performance,"t; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TProofLimitsFinder&operator=(const TProofLimitsFinder&); static voidTHLimitsFinder::Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BWID, Option_t* option = """"); static voidTHLimitsFinder::OptimizeLimits(Int_t nbins, Int_t& newbins, Double_t& xmin, Double_t& xmax, Bool_t isInteger); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTHLimitsFinder::SetLimitsFinder(THLimitsFinder* finder); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLimitsFinder.html:4088,Optimiz,OptimizeLimits,4088,root/html528/TProofLimitsFinder.html,https://root.cern,https://root.cern/root/html528/TProofLimitsFinder.html,1,['Optimiz'],['OptimizeLimits']
Performance,"t; virtual Double_tRooRealBinding::getMaxLimit(UInt_t dimension) const; virtual Double_tRooRealBinding::getMinLimit(UInt_t dimension) const; virtual const char*RooRealBinding::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooDataProjBinding&operator=(const RooDataProjBinding&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; RooDataProjBinding(const RooDataProjBinding&); RooDataProjBinding(const RooAbsReal& real, const RooAbsData& data, const RooArgSet& vars, const RooArgSet* normSet = 0); virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidRooRealBinding::loadValues(const Double_t[] xvector) const. Data Members; protected:. Roo1DTable*_catTableSupercategory table generated from _data; Bool_tRooRealBinding::_clipInvalid; list<RooAbsReal*>RooRealBinding::_compList!; list<Double_t>RooRealBinding::_compSave!; const RooAbsData*_dataDataset used for projection; UInt_tRooAbsFunc::_dimensionNumber of observables; Bool_t_firstBit indicating if operator() has been called yet; const RooAbsReal*RooRealBinding::_func; Double_tRooRealBinding::_funcSave!; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*_nsetNormalization set for real function; const RooArgSet*RooRealBinding::_nset; const TNamed*RooRealBinding::_rangeName!; const RooAbsReal*_realReal function to be projected; RooSuperCategory*_superCatSupercategory constructed from _data's category variables; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**RooRealBinding::_vars; Double_t*RooRealBinding::_xsave; Bool_tRooRealBinding::_xvecValid. Class Charts. Inheritance; Inheri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataProjBinding.html:1945,load,loadValues,1945,root/html602/RooDataProjBinding.html,https://root.cern,https://root.cern/root/html602/RooDataProjBinding.html,2,['load'],['loadValues']
Performance,"t; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsPdf.html:25050,optimiz,optimizeCacheMode,25050,root/html530/RooAbsPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html,2,['optimiz'],['optimizeCacheMode']
Performance,"t; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeData.html:12688,cache,cachedVars,12688,root/html532/RooTreeData.html,https://root.cern,https://root.cern/root/html532/RooTreeData.html,5,"['cache', 'optimiz']","['cacheArgs', 'cacheClone', 'cacheList', 'cachedVars', 'optimizeReadingWithCaching']"
Performance,"t; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeData.html:12135,cache,cachedVars,12135,root/html526/RooTreeData.html,https://root.cern,https://root.cern/root/html526/RooTreeData.html,15,"['cache', 'optimiz']","['cacheArgs', 'cacheClone', 'cacheList', 'cachedVars', 'optimizeReadingWithCaching']"
Performance,"t; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TStringfJobIDthe job's ID; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGridJobStatusList(); { }. virtual ~TGridJobStatusList(); { }. » Author: Andreas-Joachim Peters 10/12/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-30 15:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGridJobStatusList.html:10207,cache,cache,10207,root/html602/TGridJobStatusList.html,https://root.cern,https://root.cern/root/html602/TGridJobStatusList.html,1,['cache'],['cache']
Performance,"t; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TStringfJobIDthe job's ID; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGridJobStatusList(); { }. virtual ~TGridJobStatusList(); { }. » Author: Andreas-Joachim Peters 10/12/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-09-08 17:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGridJobStatusList.html:10207,cache,cache,10207,root/html604/TGridJobStatusList.html,https://root.cern,https://root.cern/root/html604/TGridJobStatusList.html,1,['cache'],['cache']
Performance,"t; virtual voidwriteToStream(ostream& os, Bool_t compact) const. protected:. voidRooAbsArg::attachToStore(RooAbsDataStore& store); virtual voidattachToTree(TTree& t, Int_t bufSize = 32000); virtual voidattachToVStore(RooVectorDataStore&); TStringRooAbsArg::cleanBranchName() const; virtual voidcopyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = kTRUE); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual TStringevaluate() const; virtual voidfillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tisValid() const; virtual Bool_tisValidString(const char*, Bool_t printError = kFALSE) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidsetTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidsyncCache(const RooArgSet* nset = 0); const char*traceEval() const; virtual Bool_ttraceEvalHook(const char* value) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsArg::ConstOpCode { Activate; DeActivate; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsString.html:16190,optimiz,optimizeDirtyHook,16190,root/html532/RooAbsString.html,https://root.cern,https://root.cern/root/html532/RooAbsString.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"t; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TF1 * _func = nullptr;  ; RooListProxy _olist;  ; RooListProxy _plist;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTFnBinding.html:55680,Cache,Cache,55680,doc/master/classRooTFnBinding.html,https://root.cern,https://root.cern/doc/master/classRooTFnBinding.html,1,['Cache'],['Cache']
Performance,"t; voidTObject::MakeZombie(). private:. TEveVSD(const TEveVSD&); TEveVSD&operator=(const TEveVSD&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TEveClusterfC; TEveRecCascadefCC; TEveMCRecCrossReffGI; TEveHitfH; TEveMCTrackfK; TEveRecKinkfKK; TEveRecTrackfR; TTree*fTreeC! Clusters.; TTree*fTreeCC! Cascades.; TTree*fTreeGI! Sim-Rec cross references.; TTree*fTreeH! Hits.; TTree*fTreeK! Kinematics.; TTree*fTreeKK! Kinks.; TTree*fTreeR! Reconstructed tracks.; TTree*fTreeV0! VO's.; TEveRecV0fV0; TEveCluster*fpC!; TEveRecCascade*fpCC!; TEveMCRecCrossRef*fpGI!; TEveHit*fpH!; TEveMCTrack*fpK!; TEveRecKink*fpKK!; TEveRecTrack*fpR!; TEveRecV0*fpV0!. protected:. Int_tfBuffSize!; TDirectory*fDirectory!; TFile*fFile!; Int_tfVerbose!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveVSD(const char* name = ""TEveVSD"", const char* title = """"); Constructor. ~TEveVSD(); Destructor. void SetDirectory(TDirectory* dir); Set directory in which the trees are (or will be) created. void CreateTrees(); Create internal trees. void DeleteTrees(); Delete interal trees. void CreateBranches(); Create internal VSD branches. void SetBranchAddresses(); Set branche addresses of internal trees. void WriteTrees(); Does nothing here ... reimplemented in sub-classes. void LoadTrees(); Load internal trees from directory. void DisableTObjectStreamersForVSDStruct(); Disble TObject streamers for those VSD structs that inherit from; TObject directly. TEveVSD(const TEveVSD& ). TEveVSD& operator=(const TEveVSD& ). » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveVSD.html:6647,Load,LoadTrees,6647,root/html534/TEveVSD.html,https://root.cern,https://root.cern/root/html534/TEveVSD.html,2,['Load'],"['Load', 'LoadTrees']"
Performance,"t;  ; Bool_t IsStyleDefault () const;  check if the visibility and attributes are the default ones ;  ; Bool_t IsTopVolume () const;  True if this is the top volume of the geometry. ;  ; Bool_t IsValid () const;  ; Bool_t IsVisContainers () const;  ; virtual Bool_t IsVisible () const;  ; Bool_t IsVisibleDaughters () const;  ; Bool_t IsVisLeaves () const;  ; Bool_t IsVisOnly () const;  ; Bool_t IsXYZVoxels () const;  ; TH2F * LegoPlot (Int_t ntheta=20, Double_t themin=0., Double_t themax=180., Int_t nphi=60, Double_t phimin=0., Double_t phimax=360., Double_t rmin=0., Double_t rmax=9999999, Option_t *option="""");  Generate a lego plot fot the top volume, according to option. ;  ; void MakeCopyNodes (const TGeoVolume *other);  make a new list of nodes and copy all nodes of other volume inside ;  ; TGeoVolume * MakeReflectedVolume (const char *newname="""") const;  Make a copy of this volume which is reflected with respect to XY plane. ;  ; Bool_t OptimizeVoxels ();  Perform an extensive sampling to find which type of voxelization is most efficient. ;  ; void Paint (Option_t *option="""") override;  paint volume ;  ; void Print (Option_t *option="""") const override;  Print volume info. ;  ; void PrintNodes () const;  print nodes ;  ; void PrintVoxels () const;  Print the voxels for this volume. ;  ; void RandomPoints (Int_t npoints=1000000, Option_t *option="""");  Draw random points in the bounding box of this volume. ;  ; void RandomRays (Int_t nrays=10000, Double_t startx=0, Double_t starty=0, Double_t startz=0, const char *target_vol=nullptr, Bool_t check_norm=kFALSE);  Random raytracing method. ;  ; void Raytrace (Bool_t flag=kTRUE);  Draw this volume with current settings and perform raytracing in the pad. ;  ; void RegisterYourself (Option_t *option="""");  Register the volume and all materials/media/matrices/shapes to the manager. ;  ; void Release ();  ; void RemoveNode (TGeoNode *node);  Remove an existing daughter. ;  ; TGeoNode * ReplaceNode (TGeoNode *nodeorig, TGeoS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeMulti.html:16864,Optimiz,OptimizeVoxels,16864,doc/master/classTGeoVolumeMulti.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeMulti.html,2,"['Optimiz', 'Perform']","['OptimizeVoxels', 'Perform']"
Performance,"t;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TProofDraw; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSelector; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TSelector * GetSelector (const char *filename);  The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector. ;  ; static bool IsStandardDraw (const char *selec);  Find out if this is a standard selection used for Draw actions (either TSelectorDraw, TProofDraw or deriving from them). ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawEntryList.html:10720,load,loaded,10720,doc/master/classTProofDrawEntryList.html,https://root.cern,https://root.cern/doc/master/classTProofDrawEntryList.html,9,['load'],['loaded']
Performance,"t;  ; Int_t fTcpWindowSize;  ; TString fUrl;  ; TList * fUUIDs;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from TSocket; static ULong64_t fgBytesRecv = 0;  ; static ULong64_t fgBytesSent = 0;  ; static Int_t fgClientProtocol = 17;  . #include <TPServerSocket.h>. Inheritance diagram for TPServerSocket:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TPServerSocket() [1/3]. TPServerSocket::TPServerSocket ; (; const TPServerSocket & ; ). privatedelete . ◆ TPServerSocket() [2/3]. TPServerSocket::TPServerSocket ; (; Int_t ; port, . Bool_t ; reuse = kFALSE, . Int_t ; backlog = kDefaultBacklog, . Int_t ; tcpwindowsize = -1 . ). Create a parallel server socket object on a specified port. ; Set reuse to true to force reuse of the server socket (i.e. do not wait for the time out to pass). Using backlog one can set the desirable queue length for pending connections. Use tcpwindowsize to specify the size of the receive buffer, it has to be specified here to make sure the window scale option is set (for tcpwindowsize > 65KB and for platforms supporting window scaling). Use IsValid() to check the validity of the server socket. In case server socket is not valid use GetErrorCode() to obtain the specific error value. These values are: 0 = no error (socket is valid) -1 = low level socket() call failed -2 = low level bind() call failed -3 = low level listen() call failed Every valid server socket is added to the TROOT sockets list which will make sure that any open sockets are properly closed on program termination. ; Definition at line 49 of file TPServerSocket.cxx. ◆ TPServerSocket() [3/3]. TPServerSocket::TPServerSocket ; (; const char * ; service, . Bool_t ; reuse = kFALSE, . Int_t ; backlog = kDefaultBacklog, . Int_t ; tcpwindowsize = -1 . ). Create a parallel server socket object for a named service. ; Set re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPServerSocket.html:20098,queue,queue,20098,doc/master/classTPServerSocket.html,https://root.cern,https://root.cern/doc/master/classTPServerSocket.html,1,['queue'],['queue']
Performance,"t;  Return the build compiler. ;  ; virtual const char * GetBuildCompilerVersion () const;  Return the build compiler version. ;  ; virtual const char * GetBuildCompilerVersionStr () const;  Return the build compiler version identifier string. ;  ; virtual const char * GetBuildDir () const;  Return the path of the build directory. ;  ; virtual const char * GetBuildNode () const;  Return the build node name. ;  ; virtual TString GetDirName (const char *pathname);  Return the directory name in pathname. ;  ; virtual void * GetDirPtr () const;  ; const char * GetErrorStr () const;  ; virtual const char * GetFlagsDebug () const;  Return the debug flags. ;  ; virtual const char * GetFlagsOpt () const;  Return the optimization flags. ;  ; virtual TString GetFromPipe (const char *command);  Execute command and return output in TString. ;  ; virtual const char * GetIncludePath ();  Get the list of include path. ;  ; virtual const char * GetLibraries (const char *regexp="""", const char *option="""", Bool_t isRegexp=kTRUE);  Return a space separated list of loaded shared libraries. ;  ; virtual const char * GetLinkdefSuffix () const;  Return the linkdef suffix chosen by the user for ACLiC. ;  ; virtual const char * GetLinkedLibs () const;  Return the list of library linked to this executable. ;  ; virtual TSeqCollection * GetListOfFileHandlers () const;  ; virtual TSeqCollection * GetListOfSignalHandlers () const;  ; virtual TSeqCollection * GetListOfStdExceptionHandlers () const;  ; virtual TList * GetListOfTimers () const;  ; virtual const char * GetMakeExe () const;  Return the command line use to make an executable. ;  ; virtual const char * GetMakeSharedLib () const;  Return the command line use to make a shared library. ;  ; virtual const char * GetObjExt () const;  Get the object file extension. ;  ; int GetPathInfo (const char *path, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime);  Get info about a file: id, size, flags, modification time. ;  ; int GetPathInf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacOSXSystem.html:15781,load,loaded,15781,doc/master/classTMacOSXSystem.html,https://root.cern,https://root.cern/doc/master/classTMacOSXSystem.html,2,['load'],['loaded']
Performance,"t;; 2733 offset += baseclass->Size();; 2734 } else if (element->IsA() == TStreamerSTL::Class()) {; 2735 TStreamerSTL *base = (TStreamerSTL*)element;; 2736 TClass *baseclass = base->GetClassPointer();; 2737 if (!baseclass) return -1;; 2738 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);; 2739 if (subOffset == -2) return -2;; 2740 if (subOffset != -1) return offset+subOffset;; 2741 offset += baseclass->Size();; 2742 ; 2743 } else {; 2744 Error(""GetBaseClassOffsetRecurse"",""Unexpected element type for base class: %s\n"",element->IsA()->GetName());; 2745 }; 2746 }; 2747 }; 2748 return -1;; 2749 }; 2750 }; 2751 ; 2752 TClass *c;; 2753 Int_t off;; 2754 TBaseClass *inh;; 2755 TObjLink *lnk = nullptr;; 2756 if (fBase.load() == nullptr); 2757 lnk = GetListOfBases()->FirstLink();; 2758 else; 2759 lnk = fBase.load()->FirstLink();; 2760 ; 2761 // otherwise look at inheritance tree; 2762 while (lnk) {; 2763 inh = (TBaseClass *)lnk->GetObject();; 2764 //use option load=kFALSE to avoid a warning like:; 2765 //""Warning in <TClass::TClass>: no dictionary for class TRefCnt is available""; 2766 //We can not afford to not have the class if it exist, so we; 2767 //use kTRUE.; 2768 c = inh->GetClassPointer(kTRUE); // kFALSE);; 2769 if (c) {; 2770 if (cl == c) {; 2771 if ((inh->Property() & kIsVirtualBase) != 0); 2772 return -2;; 2773 return inh->GetDelta();; 2774 }; 2775 off = c->GetBaseClassOffsetRecurse(cl);; 2776 if (off == -2) return -2;; 2777 if (off != -1) {; 2778 return off + inh->GetDelta();; 2779 }; 2780 }; 2781 lnk = lnk->Next();; 2782 }; 2783 return -1;; 2784}; 2785 ; 2786////////////////////////////////////////////////////////////////////////////////; 2787/// - Return data member offset to the base class ""cl"".; 2788/// - Returns -1 in case ""cl"" is not a base class.; 2789/// Takes care of multiple inheritance.; 2790 ; 2791Int_t TClass::GetBaseClassOffset(const TClass *toBase, void *address, bool isDerivedObject); 2792{; 2793 // Warning(""GetBaseClassOffset"",""Requires th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:103350,load,load,103350,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['load'],['load']
Performance,"t;; 2800 offset += baseclass->Size();; 2801 } else if (element->IsA() == TStreamerSTL::Class()) {; 2802 TStreamerSTL *base = (TStreamerSTL*)element;; 2803 TClass *baseclass = base->GetClassPointer();; 2804 if (!baseclass) return -1;; 2805 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);; 2806 if (subOffset == -2) return -2;; 2807 if (subOffset != -1) return offset+subOffset;; 2808 offset += baseclass->Size();; 2809 ; 2810 } else {; 2811 Error(""GetBaseClassOffsetRecurse"",""Unexpected element type for base class: %s\n"",element->IsA()->GetName());; 2812 }; 2813 }; 2814 }; 2815 return -1;; 2816 }; 2817 }; 2818 ; 2819 TClass *c;; 2820 Int_t off;; 2821 TBaseClass *inh;; 2822 TObjLink *lnk = nullptr;; 2823 if (fBase.load() == nullptr); 2824 lnk = GetListOfBases()->FirstLink();; 2825 else; 2826 lnk = fBase.load()->FirstLink();; 2827 ; 2828 // otherwise look at inheritance tree; 2829 while (lnk) {; 2830 inh = (TBaseClass *)lnk->GetObject();; 2831 //use option load=kFALSE to avoid a warning like:; 2832 //""Warning in <TClass::TClass>: no dictionary for class TRefCnt is available""; 2833 //We can not afford to not have the class if it exist, so we; 2834 //use kTRUE.; 2835 c = inh->GetClassPointer(kTRUE); // kFALSE);; 2836 if (c) {; 2837 if (cl == c) {; 2838 if ((inh->Property() & kIsVirtualBase) != 0); 2839 return -2;; 2840 return inh->GetDelta();; 2841 }; 2842 off = c->GetBaseClassOffsetRecurse(cl);; 2843 if (off == -2) return -2;; 2844 if (off != -1) {; 2845 return off + inh->GetDelta();; 2846 }; 2847 }; 2848 lnk = lnk->Next();; 2849 }; 2850 return -1;; 2851}; 2852 ; 2853////////////////////////////////////////////////////////////////////////////////; 2854/// - Return data member offset to the base class ""cl"".; 2855/// - Returns -1 in case ""cl"" is not a base class.; 2856/// Takes care of multiple inheritance.; 2857 ; 2858Int_t TClass::GetBaseClassOffset(const TClass *toBase, void *address, bool isDerivedObject); 2859{; 2860 // Warning(""GetBaseClassOffset"",""Requires th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:106101,load,load,106101,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['load'],['load']
Performance,"t;; 5138}; 5139 ; 5140 ; 5141FUNCTION_MAY_BE_UNUSED; 5142static struct dirent *; 5143mg_readdir(DIR *dir); 5144{; 5145 struct dirent *result = 0;; 5146 ; 5147 if (dir) {; 5148 if (dir->handle != INVALID_HANDLE_VALUE) {; 5149 result = &dir->result;; 5150 (void)WideCharToMultiByte(CP_UTF8,; 5151 0,; 5152 dir->info.cFileName,; 5153 -1,; 5154 result->d_name,; 5155 sizeof(result->d_name),; 5156 NULL,; 5157 NULL);; 5158 ; 5159 if (!FindNextFileW(dir->handle, &dir->info)) {; 5160 (void)FindClose(dir->handle);; 5161 dir->handle = INVALID_HANDLE_VALUE;; 5162 }; 5163 ; 5164 } else {; 5165 SetLastError(ERROR_FILE_NOT_FOUND);; 5166 }; 5167 } else {; 5168 SetLastError(ERROR_BAD_ARGUMENTS);; 5169 }; 5170 ; 5171 return result;; 5172}; 5173 ; 5174 ; 5175#if !defined(HAVE_POLL); 5176#undef POLLIN; 5177#undef POLLPRI; 5178#undef POLLOUT; 5179#undef POLLERR; 5180#define POLLIN (1) /* Data ready - read will not block. */; 5181#define POLLPRI (2) /* Priority data ready. */; 5182#define POLLOUT (4) /* Send queue not full - write will not block. */; 5183#define POLLERR (8) /* Error event */; 5184 ; 5185FUNCTION_MAY_BE_UNUSED; 5186static int; 5187poll(struct mg_pollfd *pfd, unsigned int n, int milliseconds); 5188{; 5189 struct timeval tv;; 5190 fd_set rset;; 5191 fd_set wset;; 5192 fd_set eset;; 5193 unsigned int i;; 5194 int result;; 5195 SOCKET maxfd = 0;; 5196 ; 5197 memset(&tv, 0, sizeof(tv));; 5198 tv.tv_sec = milliseconds / 1000;; 5199 tv.tv_usec = (milliseconds % 1000) * 1000;; 5200 FD_ZERO(&rset);; 5201 FD_ZERO(&wset);; 5202 FD_ZERO(&eset);; 5203 ; 5204 for (i = 0; i < n; i++) {; 5205 if (pfd[i].events & (POLLIN | POLLOUT | POLLERR)) {; 5206 if (pfd[i].events & POLLIN) {; 5207 FD_SET(pfd[i].fd, &rset);; 5208 }; 5209 if (pfd[i].events & POLLOUT) {; 5210 FD_SET(pfd[i].fd, &wset);; 5211 }; 5212 /* Check for errors for any FD in the set */; 5213 FD_SET(pfd[i].fd, &eset);; 5214 }; 5215 pfd[i].revents = 0;; 5216 ; 5217 if (pfd[i].fd > maxfd) {; 5218 maxfd = pfd[i].fd;; 5219 }; 5220 }; 522",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:154289,queue,queue,154289,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['queue'],['queue']
Performance,"t;; 5139}; 5140 ; 5141 ; 5142FUNCTION_MAY_BE_UNUSED; 5143static struct dirent *; 5144mg_readdir(DIR *dir); 5145{; 5146 struct dirent *result = 0;; 5147 ; 5148 if (dir) {; 5149 if (dir->handle != INVALID_HANDLE_VALUE) {; 5150 result = &dir->result;; 5151 (void)WideCharToMultiByte(CP_UTF8,; 5152 0,; 5153 dir->info.cFileName,; 5154 -1,; 5155 result->d_name,; 5156 sizeof(result->d_name),; 5157 NULL,; 5158 NULL);; 5159 ; 5160 if (!FindNextFileW(dir->handle, &dir->info)) {; 5161 (void)FindClose(dir->handle);; 5162 dir->handle = INVALID_HANDLE_VALUE;; 5163 }; 5164 ; 5165 } else {; 5166 SetLastError(ERROR_FILE_NOT_FOUND);; 5167 }; 5168 } else {; 5169 SetLastError(ERROR_BAD_ARGUMENTS);; 5170 }; 5171 ; 5172 return result;; 5173}; 5174 ; 5175 ; 5176#if !defined(HAVE_POLL); 5177#undef POLLIN; 5178#undef POLLPRI; 5179#undef POLLOUT; 5180#undef POLLERR; 5181#define POLLIN (1) /* Data ready - read will not block. */; 5182#define POLLPRI (2) /* Priority data ready. */; 5183#define POLLOUT (4) /* Send queue not full - write will not block. */; 5184#define POLLERR (8) /* Error event */; 5185 ; 5186FUNCTION_MAY_BE_UNUSED; 5187static int; 5188poll(struct mg_pollfd *pfd, unsigned int n, int milliseconds); 5189{; 5190 struct timeval tv;; 5191 fd_set rset;; 5192 fd_set wset;; 5193 fd_set eset;; 5194 unsigned int i;; 5195 int result;; 5196 SOCKET maxfd = 0;; 5197 ; 5198 memset(&tv, 0, sizeof(tv));; 5199 tv.tv_sec = milliseconds / 1000;; 5200 tv.tv_usec = (milliseconds % 1000) * 1000;; 5201 FD_ZERO(&rset);; 5202 FD_ZERO(&wset);; 5203 FD_ZERO(&eset);; 5204 ; 5205 for (i = 0; i < n; i++) {; 5206 if (pfd[i].events & (POLLIN | POLLOUT | POLLERR)) {; 5207 if (pfd[i].events & POLLIN) {; 5208 FD_SET(pfd[i].fd, &rset);; 5209 }; 5210 if (pfd[i].events & POLLOUT) {; 5211 FD_SET(pfd[i].fd, &wset);; 5212 }; 5213 /* Check for errors for any FD in the set */; 5214 FD_SET(pfd[i].fd, &eset);; 5215 }; 5216 pfd[i].revents = 0;; 5217 ; 5218 if (pfd[i].fd > maxfd) {; 5219 maxfd = pfd[i].fd;; 5220 }; 5221 }; 522",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:154321,queue,queue,154321,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['queue'],['queue']
Performance,"t="""") const overridePrint list of registered plugin handlers.Definition TPluginManager.cxx:637; The use of the plugin library manager removes all textual references to hard-coded class and library names and the resulting dependencies in the base classes. The plugin manager is used to extend a.o. TFile, TSQLServer, TGrid, etc. functionality. ; Definition at line 258 of file TPluginManager.h. Public Member Functions;  TPluginManager ();  Constructor. ;  ;  ~TPluginManager ();  Clean up the plugin manager. ;  ; void AddHandler (const char *base, const char *regexp, const char *className, const char *pluginName, const char *ctor=nullptr, const char *origin=nullptr);  Add plugin handler to the list of handlers. ;  ; TPluginHandler * FindHandler (const char *base, const char *uri=nullptr);  Returns the handler if there exists a handler for the specified URI. ;  ; TClass * IsA () const override;  ; void LoadHandlersFromEnv (TEnv *env);  Load plugin handlers specified in config file, like: ;  ; void LoadHandlersFromPluginDirs (const char *base=nullptr);  Load plugin handlers specified via macros in a list of plugin directories. ;  ; void Print (Option_t *opt="""") const override;  Print list of registered plugin handlers. ;  ; void RemoveHandler (const char *base, const char *regexp=nullptr);  Remove handler for the specified base class and the specified regexp. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t WritePluginMacros (const char *dir, const char *plugin=nullptr) const;  Write in the specified directory the plugin macros. ;  ; Int_t WritePluginRecords (const char *envFile, const char *plugin=nullptr) const;  Write in the specified environment config file the plugin records. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPluginManager.html:4708,Load,LoadHandlersFromEnv,4708,doc/master/classTPluginManager.html,https://root.cern,https://root.cern/doc/master/classTPluginManager.html,4,['Load'],"['Load', 'LoadHandlersFromEnv', 'LoadHandlersFromPluginDirs']"
Performance,"t=0.55); ; # Add box with data statistics; # -------------------------------------------------------; ; # X size of box is from 55% to 99% of Xaxis range, of box is at 80% of; # Yaxis range); data.statOn(frame, Layout=(0.55, 0.99, 0.8)); ; # Add text and arrow; # -----------------------------------; ; # Add text to frame; txt = ROOT.TText(2, 100, ""Signal""); txt.SetTextSize(0.04); txt.SetTextColor(ROOT.kRed); frame.addObject(txt); ; # Add arrow to frame; arrow = ROOT.TArrow(2, 100, -1, 50, 0.01, ""|>""); arrow.SetLineColor(ROOT.kRed); arrow.SetFillColor(ROOT.kRed); arrow.SetLineWidth(3); frame.addObject(arrow); ; # Persist frame with all decorations in ROOT file; # ---------------------------------------------------------------------------------------------; ; f = ROOT.TFile(""rf106_plotdecoration.root"", ""RECREATE""); frame.Write(); f.Close(); ; # To read back and plot frame with all decorations in clean root session do; # root> ROOT.TFile f(""rf106_plotdecoration.root""); # root> xframe.Draw(); ; c = ROOT.TCanvas(""rf106_plotdecoration"", ""rf106_plotdecoration"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf106_plotdecoration.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_gaussData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf106_plotdecoration.py. tutorialsroofitrf106_plotdecoration.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf106__plotdecoration_8py.html:2829,optimiz,optimization,2829,doc/master/rf106__plotdecoration_8py.html,https://root.cern,https://root.cern/doc/master/rf106__plotdecoration_8py.html,2,['optimiz'],['optimization']
Performance,"t>& other, RooAbsArg* owner = 0); Int_tsetObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidsterilize(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. Int_t_lastIndex! Last slot accessed; Int_t_maxSize! Maximum size; vector<RooNormSetCache>_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_size! Actual use; Bool_t_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCacheManager_RooAbsCacheElement_.html:3586,cache,cache,3586,root/html602/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html602/RooCacheManager_RooAbsCacheElement_.html,2,['cache'],['cache']
Performance,"t>::iterator it = Use.begin(); it != Use.end(); it++) it->second = 0;; ; std::vector<TString> mlist = gTools().SplitString( myMethodList, ',' );; for (UInt_t i=0; i<mlist.size(); i++) {; std::string regMethod(mlist[i].Data());; ; if (Use.find(regMethod) == Use.end()) {; std::cout << ""Method \"""" << regMethod << ""\"" not known in TMVA under this name. Choose among the following:"" << std::endl;; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) std::cout << it->first << "" "";; std::cout << std::endl;; return;; }; Use[regMethod] = 1;; }; }; ; // --------------------------------------------------------------------------------------------------; ; // Here the preparation phase begins; ; // Create a new root output file; TString outfileName( ""TMVAReg.root"" );; TFile* outputFile = TFile::Open( outfileName, ""RECREATE"" );; ; // Create the factory object. Later you can choose the methods; // whose performance you'd like to investigate. The factory will; // then run the performance analysis for you.; //; // The first argument is the base of the name of all the; // weightfiles in the directory weight/; //; // The second argument is the output file for the training results; // All TMVA output can be suppressed by removing the ""!"" (not) in; // front of the ""Silent"" argument in the option string; TMVA::Factory *factory = new TMVA::Factory( ""TMVARegression"", outputFile,; ""!V:!Silent:Color:DrawProgressBar:AnalysisType=Regression"" );; ; ; TMVA::DataLoader *dataloader=new TMVA::DataLoader(""datasetreg"");; // If you wish to modify default settings; // (please check ""src/Config.h"" to see all available global options); //; // (TMVA::gConfig().GetVariablePlotting()).fTimesRMS = 8.0;; // (TMVA::gConfig().GetIONames()).fWeightFileDir = ""myWeightDirectory"";; ; // Define the input variables that shall be used for the MVA training; // note that you may also use variable expressions, such as: ""3*var1/var2*abs(var3)""; // [all types of expressions that can also be pars",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:137382,perform,performance,137382,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['perform'],['performance']
Performance,"tA TParallelCoordSelect is a specialised TList to hold TParallelCoordRanges used by TParallelCoord ;  CTParallelCoordVarTParallelCoord axes ;  CTParallelMergingFile;  CTParameterNamed parameter, streamable and storable ;  CTParticleDescription of the dynamic properties of a particle ;  CTParticleClassPDGUtility class used internally by TDatabasePDG ;  CTParticlePDGDescription of the static properties of a particle ;  CTPaveA TBox with a bordersize and a shadow option ;  CTPaveClassA TPaveLabel specialized to process classes inside a TClassTree ;  CTPaveLabelA Pave (see TPave) with a text centered in the Pave ;  CTPaveStatsThe histogram statistics painter class ;  CTPaveStatsEditor;  CTPavesTextA PaveText (see TPaveText) with several stacked paves ;  CTPaveTextA Pave (see TPave) with text, lines or/and boxes inside ;  CTPBHandleDSType;  CTPBHistType;  CTPBReadType;  CTPCONA polycone ;  CTPDFInterface to PDF ;  CTPerfEvent;  CTPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing ;  CTPGONA polygon ;  CTPgSQLResult;  CTPgSQLRow;  CTPgSQLServer;  CTPgSQLStatement;  CTPickerStackGuard;  CTPieDraw a Pie Chart, ;  CTPieEditor;  CTPieSliceA slice of a piechart, see the TPie class ;  CTPieSliceEditor;  CTPluginHandler;  CTPluginManagerThis class implements a plugin library manager ;  CTPMERegexpWrapper for PCRE library (Perl Compatible Regular Expressions) ;  CTPoint;  CTPoints2-D graphics point (world coordinates) ;  CTPoints3D;  CTPoints3DABCAbstract class to define Arrays of 3D points ;  CTPointsArray3D;  CTPointSet3DTPolyMarker3D using TPointSet3DGL for direct OpenGL rendering ;  CTPointSet3DGLDirect OpenGL renderer for TPointSet3D ;  CTPolyLineDefined by an array on N points in a 2-D space ;  CTPolyLine3DA 3-dimensional polyline ;  CTPolyLineShape;  CTPolyMarkerA PolyMarker is defined by an array on N points in a 2-D space ;  CTPolyMarker3DA 3D polymarker ;  CTPoolManagerA manager for the scheduler behind ROOT multithreading o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:200509,perform,performance,200509,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['perform'],['performance']
Performance,"tA TParallelCoordSelect is a specialised TList to hold TParallelCoordRanges used by TParallelCoord ;  CTParallelCoordVarTParallelCoord axes ;  CTParallelMergingFile;  CTParameterNamed parameter, streamable and storable ;  CTParticleDescription of the dynamic properties of a particle ;  CTParticleClassPDGUtility class used internally by TDatabasePDG ;  CTParticlePDGDescription of the static properties of a particle ;  CTPaveA TBox with a bordersize and a shadow option ;  CTPaveClassA TPaveLabel specialized to process classes inside a TClassTree ;  CTPaveLabelA Pave (see TPave) with a text centered in the Pave ;  CTPaveStatsThe histogram statistics painter class ;  CTPaveStatsEditor;  CTPavesTextA PaveText (see TPaveText) with several stacked paves ;  CTPaveTextA Pave (see TPave) with text, lines or/and boxes inside ;  CTPBHandleDSType;  CTPBHistType;  CTPBReadType;  CTPCONA polycone ;  CTPDFInterface to PDF ;  CTPerfEvent;  CTPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing ;  CTPGONA polygon ;  CTPgSQLResult;  CTPgSQLRow;  CTPgSQLServer;  CTPgSQLStatement;  CTPickerStackGuard;  CTPieDraw a Pie Chart, ;  CTPieEditor;  CTPieSliceA slice of a piechart, see the TPie class ;  CTPieSliceEditor;  CTPluginHandler;  CTPluginManagerThis class implements a plugin library manager ;  CTPMERegexpWrapper for PCRE library (Perl Compatible Regular Expressions) ;  CTPoint;  CTPoints2-D graphics point (world coordinates) ;  CTPoints3D;  CTPoints3DABCAbstract class to define Arrays of 3D points ;  CTPointsArray3D;  CTPointSet3DTPolyMarker3D using TPointSet3DGL for direct OpenGL rendering ;  CTPointSet3DGLDirect OpenGL renderer for TPointSet3D ;  CTPolyLineDefined by an array on N points in a 2-D space ;  CTPolyLine3DA 3-dimensional polyline ;  CTPolyLineShape;  CTPolyMarkerA PolyMarker is defined by an array on N points in a 2-D space ;  CTPolyMarker3DA 3D polymarker ;  CTPoolPlayer;  CTPoolProcessor;  CTPoolWorkerThis class works togethe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:175227,perform,performance,175227,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['perform'],['performance']
Performance,"tA TParallelCoordSelect is a specialised TList to hold TParallelCoordRanges used by TParallelCoord ;  CTParallelCoordVarTParallelCoord axes ;  CTParallelMergingFile;  CTParameterNamed parameter, streamable and storable ;  CTParticleDescription of the dynamic properties of a particle ;  CTParticleClassPDGUtility class used internally by TDatabasePDG ;  CTParticlePDGDescription of the static properties of a particle ;  CTPaveA TBox with a bordersize and a shadow option ;  CTPaveClassA TPaveLabel specialized to process classes inside a TClassTree ;  CTPaveLabelA Pave (see TPave) with a text centered in the Pave ;  CTPaveStatsThe histogram statistics painter class ;  CTPaveStatsEditor;  CTPavesTextA PaveText (see TPaveText) with several stacked paves ;  CTPaveTextA Pave (see TPave) with text, lines or/and boxes inside ;  CTPBHandleDSType;  CTPBHistType;  CTPBReadType;  CTPCONA polycone ;  CTPDFInterface to PDF ;  CTPerfEvent;  CTPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing ;  CTPGONA polygon ;  CTPgSQLResult;  CTPgSQLRow;  CTPgSQLServer;  CTPgSQLStatement;  CTPickerStackGuard;  CTPieDraw a Pie Chart, ;  CTPieEditor;  CTPieSliceA slice of a piechart, see the TPie class ;  CTPieSliceEditor;  CTPluginHandler;  CTPluginManagerThis class implements a plugin library manager ;  CTPMERegexpWrapper for PCRE library (Perl Compatible Regular Expressions) ;  CTPoint;  CTPoints2-D graphics point (world coordinates) ;  CTPoints3D;  CTPoints3DABCAbstract class to define Arrays of 3D points ;  CTPointsArray3D;  CTPointSet3DTPolyMarker3D using TPointSet3DGL for direct OpenGL rendering ;  CTPointSet3DGLDirect OpenGL renderer for TPointSet3D ;  CTPolyLineDefined by an array on N points in a 2-D space ;  CTPolyLine3DA 3-dimensional polyline ;  CTPolyLineShape;  CTPolyMarkerA PolyMarker is defined by an array on N points in a 2-D space ;  CTPolyMarker3DA 3D polymarker ;  CTPosixCondition;  CTPosixMutex;  CTPosixThread;  CTPosixThreadCleanU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:184477,perform,performance,184477,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,3,['perform'],['performance']
Performance,"tArrays(). void TSelectorDraw::InitArrays ; (; Int_t ; newsize). protectedvirtual . Initialization of the primitive type arrays if the new size is bigger than the available space. ; Definition at line 1092 of file TSelectorDraw.cxx. ◆ IsA(). TClass * TSelectorDraw::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TSelector.; Definition at line 121 of file TSelectorDraw.h. ◆ Notify(). bool TSelectorDraw::Notify ; (; ). overridevirtual . This function is called at the first entry of a new tree in a chain. ; Reimplemented from TSelector.; Definition at line 1154 of file TSelectorDraw.cxx. ◆ operator=(). TSelectorDraw & TSelectorDraw::operator= ; (; const TSelectorDraw & ; ). private . ◆ Process(). bool TSelectorDraw::Process ; (; Long64_t ; ). inlineoverridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used.; WARNING when a selector is used with a TChain, you must use the pointer to the current TTree to call GetEntry(entry). The entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use: fChain->GetTree()->GetEntry(entry). ; Reimplemented from TSelector.; Definition at line 111 of file TSelectorDraw.h. ◆ ProcessFill(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelectorDraw.html:24328,load,loaded,24328,doc/master/classTSelectorDraw.html,https://root.cern,https://root.cern/doc/master/classTSelectorDraw.html,1,['load'],['loaded']
Performance,tBigFile; static TFile::EFileTypeTFile::kWeb; static TObject::(anonymous)TObject::kWriteDelete; static TFile::EStatusBitsTFile::kWriteError; static TObject::(anonymous)TObject::kZombie. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; TStringTWebFile::fBasicUrlbasic url without authentication and options; TStringTWebFile::fBasicUrlOrgsave original url in case of temp redirection; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; Bool_tTWebFile::fHTTP11true if server support HTTP/1.1; Bool_tTWebFile::fHasModRoottrue if server has mod_root installed; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initial,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TS3WebFile.html:22511,cache,cache,22511,root/html602/TS3WebFile.html,https://root.cern,https://root.cern/root/html602/TS3WebFile.html,6,['cache'],['cache']
Performance,"tBit(kUnloading))) return cl;; 2992 ; 2993 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2994 ; 2995 // Now that we got the write lock, another thread may have constructed the; 2996 // TClass while we were waiting, so we need to do the checks again.; 2997 ; 2998 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2999 if (cl) {; 3000 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3001 ; 3002 // We could speed-up some of the search by adding (the equivalent of); 3003 //; 3004 // if (cl->GetState() == kInterpreter) return cl; 3005 //; 3006 // In this case, if a ROOT dictionary was available when the TClass; 3007 // was first requested it would have been used and if a ROOT dictionary is; 3008 // loaded later on TClassTable::Add will take care of updating the TClass.; 3009 // So as far as ROOT dictionary are concerned, if the current TClass is; 3010 // in interpreted state, we are sure there is nothing to load.; 3011 //; 3012 // However (see TROOT::LoadClass), the TClass can also be loaded/provided; 3013 // by a user provided TClassGenerator. We have no way of knowing whether; 3014 // those do (or even can) behave the same way as the ROOT dictionary and; 3015 // have the 'dictionary is now available for use' step informs the existing; 3016 // TClass that their dictionary is now available.; 3017 ; 3018 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3019 load = kTRUE;; 3020 }; 3021 ; 3022 if (TClassEdit::IsArtificial(name)) {; 3023 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3024 // from an already normalized name for the purpose of supporting schema evolution.; 3025 // There is no dictionary or interpreter information about this kind of class, the only; 3026 // (undesirable) side-effect of doing the search would be a waste of CPU time and potential; 3027 // auto-loading or auto-parsing based on the scope of the name.; 3028 return cl;; 3029 }; 3030 ; 3031 // To avoid spuri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:113243,Load,LoadClass,113243,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,"['Load', 'load']","['LoadClass', 'loaded']"
Performance,"tBit(kUnloading))) return cl;; 3059 ; 3060 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3061 ; 3062 // Now that we got the write lock, another thread may have constructed the; 3063 // TClass while we were waiting, so we need to do the checks again.; 3064 ; 3065 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 3066 if (cl) {; 3067 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3068 ; 3069 // We could speed-up some of the search by adding (the equivalent of); 3070 //; 3071 // if (cl->GetState() == kInterpreter) return cl; 3072 //; 3073 // In this case, if a ROOT dictionary was available when the TClass; 3074 // was first requested it would have been used and if a ROOT dictionary is; 3075 // loaded later on TClassTable::Add will take care of updating the TClass.; 3076 // So as far as ROOT dictionary are concerned, if the current TClass is; 3077 // in interpreted state, we are sure there is nothing to load.; 3078 //; 3079 // However (see TROOT::LoadClass), the TClass can also be loaded/provided; 3080 // by a user provided TClassGenerator. We have no way of knowing whether; 3081 // those do (or even can) behave the same way as the ROOT dictionary and; 3082 // have the 'dictionary is now available for use' step informs the existing; 3083 // TClass that their dictionary is now available.; 3084 ; 3085 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3086 load = kTRUE;; 3087 }; 3088 ; 3089 if (TClassEdit::IsArtificial(name)) {; 3090 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3091 // from an already normalized name for the purpose of supporting schema evolution.; 3092 // There is no dictionary or interpreter information about this kind of class, the only; 3093 // (undesirable) side-effect of doing the search would be a waste of CPU time and potential; 3094 // auto-loading or auto-parsing based on the scope of the name.; 3095 return cl;; 3096 }; 3097 ; 3098 // To avoid spuri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:115994,Load,LoadClass,115994,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,"['Load', 'load']","['LoadClass', 'loaded']"
Performance,"tBranchRefvirtual TBranchRef * GetBranchRef() constDefinition TTree.h:450; TTree::GetV3virtual Double_t * GetV3()Definition TTree.h:580; TTree::Processvirtual Long64_t Process(const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Process this tree executing the TSelector code in the specified filename.Definition TTree.cxx:7450; TTree::BranchImpRefvirtual TBranch * BranchImpRef(const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel)Same as TTree::Branch but automatic detection of the class name.Definition TTree.cxx:1635; TTree::SetEventListvirtual void SetEventList(TEventList *list)This function transfroms the given TEventList into a TEntryList The new TEntryList is owned by the TT...Definition TTree.cxx:9069; TTree::BranchTBranch * Branch(const char *name, int address, const char *leaflist, Int_t bufsize=32000)Definition TTree.h:389; TTree::MoveReadCachevoid MoveReadCache(TFile *src, TDirectory *dir)Move a cache from a file to the current file in dir.Definition TTree.cxx:6983; TTree::operator=TTree & operator=(const TTree &tt)=delete; TTree::fAutoFlushLong64_t fAutoFlushAuto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced.Definition TTree.h:101; TTree::fUpdateInt_t fUpdateUpdate frequency for EntryLoop.Definition TTree.h:93; TTree::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Resets the state of this TTree after a merge (keep the customization but forget the data).Definition TTree.cxx:8034; TTree::BranchTBranch * Branch(const char *name, std::array< T, N > *obj, Int_t bufsize=32000, Int_t splitlevel=99)Definition TTree.h:405; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::SetEstimatevirtual void SetEstimate(Long64_t nentries=1000000)Set number of entries to estimate variable limits.Definition TTree.cxx:9110; TTree::fTimerIntervalInt_t fTimerIntervalTimer interval in milliseconds.De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:70183,cache,cache,70183,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['cache'],['cache']
Performance,"tBuffer = new TBufferFile(TBuffer::kRead, size);; 1047 return fTransientBuffer;; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051/// Add branch with name bname to the Tree cache.; 1052/// If bname=""*"" all branches are added to the cache.; 1053/// if subbranches is true all the branches of the subbranches are; 1054/// also put to the cache.; 1055///; 1056/// Returns:; 1057/// - 0 branch added or already included; 1058/// - -1 on error; 1059 ; 1060Int_t TTree::AddBranchToCache(const char*bname, bool subbranches); 1061{; 1062 if (!GetTree()) {; 1063 if (LoadTree(0)<0) {; 1064 Error(""AddBranchToCache"",""Could not load a tree"");; 1065 return -1;; 1066 }; 1067 }; 1068 if (GetTree()) {; 1069 if (GetTree() != this) {; 1070 return GetTree()->AddBranchToCache(bname, subbranches);; 1071 }; 1072 } else {; 1073 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1085 return -1;; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch added or already included; 1097/// - -1 on error; 1098 ; 1099Int_t TTree::AddBranchToCache(TBranch *b, bool subbranches); 1100{; 1101 if (!GetTree()) {; 1102 if (LoadTree(0)<0) {; 1103 Error(""AddBranchToCache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:38492,cache,cache,38492,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"tCache & ; other). inline . Definition at line 28 of file RooExpensiveObjectCache.h. ◆ ~RooExpensiveObjectCache(). RooExpensiveObjectCache::~RooExpensiveObjectCache ; (; ). override . Destructor. ; Definition at line 45 of file RooExpensiveObjectCache.cxx. Member Function Documentation. ◆ Class(). static TClass * RooExpensiveObjectCache::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooExpensiveObjectCache::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooExpensiveObjectCache::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 81 of file RooExpensiveObjectCache.h. ◆ clearAll(). void RooExpensiveObjectCache::clearAll ; (; ). Clear all cache elements. ; Definition at line 164 of file RooExpensiveObjectCache.cxx. ◆ clearObj(). bool RooExpensiveObjectCache::clearObj ; (; Int_t ; uniqueID). Clear cache element with given unique ID Retrieve payload object of cache element with given unique ID. ; Definition at line 131 of file RooExpensiveObjectCache.cxx. ◆ DeclFileName(). static const char * RooExpensiveObjectCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 81 of file RooExpensiveObjectCache.h. ◆ empty(). bool RooExpensiveObjectCache::empty ; (; ); const. inline . Definition at line 44 of file RooExpensiveObjectCache.h. ◆ getObj(). const TObject * RooExpensiveObjectCache::getObj ; (; Int_t ; uniqueID). Retrieve payload object of cache element with given unique ID. ; Definition at line 115 of file RooExpensiveObjectCache.cxx. ◆ importCacheObjects(). void RooExpensiveObjectCache::importCacheObjects ; (; RooExpensiveObjectCache & ; other, . const char * ; ownerName, . bool ; verbose = false . ). Definition at line 296 of file RooExpensiveObjectCache.cxx. ◆ instance(). RooExpensiveObjectCache & RooExpensiveObjectCache::instance ; (; ). static . Return refe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExpensiveObjectCache.html:13024,cache,cache,13024,doc/master/classRooExpensiveObjectCache.html,https://root.cern,https://root.cern/doc/master/classRooExpensiveObjectCache.html,2,['cache'],['cache']
Performance,"tCache& instance(); Return reference to singleton instance. void cleanup(); Static function called by RooSentinel atexit() handler to cleanup at end of program. Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, const RooArgSet& params); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve object from cache that was registered under given name with given parameters, _if_; current parameter values match those that were stored in the registry for this object.; The return object is owned by the cache instance. const TObject* getObj(Int_t uniqueID); Retrieve payload object of cache element with given unique ID. Bool_t clearObj(Int_t uniqueID); Clear cache element with given unique ID; Retrieve payload object of cache element with given unique ID. Bool_t setObj(Int_t uniqueID, TObject* obj); Place new payload object in cache element with given unique ID. Cache; will take ownership of provided object!. void clearAll(); Clear all cache elements. void print() const. void importCacheObjects(RooExpensiveObjectCache&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExpensiveObjectCache.html:7342,cache,cache,7342,root/html528/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html528/RooExpensiveObjectCache.html,12,['cache'],"['cache', 'cacheObject']"
Performance,"tCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); virtual TStringhistNameSuffix() const; static Bool_tRooAbsArg::inhibitDirty(); virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedPdf.html:33813,optimiz,optimizeDirtyHook,33813,root/html526/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedPdf.html,8,['optimiz'],['optimizeDirtyHook']
Performance,"tCache.cxx. ◆ registerObject(). bool RooExpensiveObjectCache::registerObject ; (; const char * ; ownerName, . const char * ; objectName, . TObject & ; cacheObject, . const RooArgSet & ; params . ). Register object associated with given name and given associated parameters with given values in cache. ; The cache will take ownership_of_object and is indexed under the given name (which does not need to be the name of cacheObject and with given set of dependent parameters with validity for the current values of those parameters. It can be retrieved later by callin retrieveObject() ; Definition at line 71 of file RooExpensiveObjectCache.cxx. ◆ retrieveObject(). const TObject * RooExpensiveObjectCache::retrieveObject ; (; const char * ; name, . TClass * ; tc, . const RooArgSet & ; params . ). Retrieve object from cache that was registered under given name with given parameters, if current parameter values match those that were stored in the registry for this object. ; The return object is owned by the cache instance. ; Definition at line 93 of file RooExpensiveObjectCache.cxx. ◆ setObj(). bool RooExpensiveObjectCache::setObj ; (; Int_t ; uid, . TObject * ; obj . ). Place new payload object in cache element with given unique ID. ; Cache will take ownership of provided object! ; Definition at line 148 of file RooExpensiveObjectCache.cxx. ◆ size(). Int_t RooExpensiveObjectCache::size ; (; ); const. inline . Definition at line 43 of file RooExpensiveObjectCache.h. ◆ Streamer(). void RooExpensiveObjectCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void RooExpensiveObjectCache::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 81 of file RooExpensiveObjectCache.h. Member Data Documentation. ◆ _map. std::map<TString,ExpensiveObject*> RooExpensiveObjectCache::_map. protected . Definition at line 78 of file RooExpensiveObjectCache.h. ◆ _nextUI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExpensiveObjectCache.html:15494,cache,cache,15494,doc/master/classRooExpensiveObjectCache.html,https://root.cern,https://root.cern/doc/master/classRooExpensiveObjectCache.html,1,['cache'],['cache']
Performance,"tClientFilter provides QOject event filter to map Qt and ROOT events; (see: http://doc.trolltech.com/4.3/qobject.html#installEventFilter ). Function Members (Methods); public:. TQtClientFilter(); virtual~TQtClientFilter(); voidAppendButtonGrab(TQtClientWidget*); static TClass*Class(); static TQtClientWidget*GetButtonGrabber(); static TQtClientWidget*GetPointerGrabber(); static voidGrabPointer(TQtClientWidget* grabber, UInt_t evmask, Window_t confine, QCursor* cursor, Bool_t grab = kTRUE, Bool_t owner_events = kTRUE); virtual TClass*IsA() const; static TQtPointerGrabber*PointerGrabber(); voidRemoveButtonGrab(QObject*); static voidSetButtonGrabber(TQtClientWidget* grabber); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidAddKeyEvent(const int& event, TQtClientWidget* widget); booleventFilter(QObject* o, QEvent* e); static Bool_tIsGrabSelected(UInt_t selectEventMask); TQtEventQueue*Queue(); voidRestoreLostGrabbing(Event_t& event); static Bool_tSelectGrab(Event_t& event, UInt_t selectEventMask, int& me); voidSetKeyGrabber(TQtClientWidget* grabber); voidUnSetKeyGrabber(TQtClientWidget* grabber). private:. TQtClientFilter(const TQtClientFilter&); voidoperator=(const TQtClientFilter&). Data Members; protected:. UInt_tfInputEventMask; TQtClientWidget*fKeyGrabber; TQtNextEventMessage*fNotifyClient; TQtEventQueue*fRootEventQueue; static TQtClientWidget*fgActiveGrabber; static TQtClientWidget*fgButtonGrabber; static QCursor*fgGrabPointerCursor; static UInt_tfgGrabPointerEventMask; static Bool_tfgGrabPointerOwner; static TQtPointerGrabber*fgGrabber; static TQtClientWidget*fgPointerGrabber. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t IsGrabSelected(UInt_t selectEventMask); return the selection by ""grabButton"" / ""grabPointer"". ~TQtClientFilter(). void AddKeyEvent(const int& event, TQtClientWidget* widget); Map and and to the ROOT event queue Qt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQtClientFilter.html:1284,Queue,Queue,1284,root/html528/TQtClientFilter.html,https://root.cern,https://root.cern/root/html528/TQtClientFilter.html,2,['Queue'],['Queue']
Performance,"tClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton analysis class for this tree. The following files are produced: classname.h and classname.C.; If classname is 0, classname will be called ""nameoftree"". The generated code in classname.h includes the following:; - Identification of the original tree and the input file name.; - Definition of an analysis class (data members and member functions).; - The following mem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:100784,Load,LoadTree,100784,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,4,['Load'],['LoadTree']
Performance,"tConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; static const char**&GetExtraInterpreterArgs(); virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TFunctionTemplate*GetFunctionTemplate(const char* name); TObject*GetGeometry(const char* name) const; const char*GetGitBranch() const; const char*GetGitCommit() const; const char*GetGitDate(); TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfClosedObjects() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TCollection*GetListOfEnums(Bool_t load = kFALSE); TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctionOverloads(const char* name) const; TCollection*GetListOfFunctions() const; TCollection*GetListOfFunctionTemplates(); TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:6304,load,load,6304,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['load'],['load']
Performance,"tCoordinateSystemTag> . CoordSystem ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Coordinates ; (; ); const. inline . Retrieve a copy of the coordinates object. ; Definition at line 182 of file DisplacementVector3D.h. ◆ Cross() [1/3]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherCoords , class OtherTag > . DisplacementVector3D ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Cross ; (; const DisplacementVector3D< OtherCoords, OtherTag > & ; ); const. private . ◆ Cross() [2/3]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherCoords > . DisplacementVector3D ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Cross ; (; const DisplacementVector3D< OtherCoords, Tag > & ; v); const. inline . Return vector (cross) product of two displacement vectors, as a vector in the coordinate system of this class. ; It is possible to perform the product for any type of vector coordinates, but they must have the same coordinate system tag ; Definition at line 423 of file DisplacementVector3D.h. ◆ Cross() [3/3]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherVector > . DisplacementVector3D ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Cross ; (; const OtherVector & ; v); const. inline . Return vector (cross) product of two vectors, as a vector in the coordinate system of this class. ; It is possible to perform the product for any classes implementing X(), Y() and Z() member functions ; Definition at line 437 of file DisplacementVector3D.h. ◆ Dimension(). template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . unsigned int ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Dimension ; (; ); const. inline . Dimension. ; Definition at line 273 of file DisplacementVector3D.h. ◆ Dot() [1/3]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherCoords , class OtherTag > . Scalar ROOT::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1DisplacementVector3D.html:14531,perform,perform,14531,doc/master/classROOT_1_1Math_1_1DisplacementVector3D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1DisplacementVector3D.html,1,['perform'],['perform']
Performance,"tDebug (Int_t level=1, Long64_t min=0, Long64_t max=9999999);  Set the debug level and the debug range. ;  ; virtual void SetDefaultEntryOffsetLen (Int_t newdefault, bool updateExisting=false);  Update the default value for the branch's fEntryOffsetLen. ;  ; virtual Long64_t SetEntries (Long64_t n=-1);  Change number of entries in the tree. ;  ; virtual void SetEstimate (Long64_t nentries=1000000);  Set number of entries to estimate variable limits. ;  ; virtual void SetFileNumber (Int_t number=0);  Set fFileNumber to number. ;  ; virtual void SetImplicitMT (bool enabled);  ; ROOT::TIOFeatures SetIOFeatures (const ROOT::TIOFeatures &);  Provide the end-user with the ability to enable/disable various experimental IO features for this TTree. ;  ; virtual void SetMaxEntryLoop (Long64_t maxev=kMaxEntries);  ; virtual void SetMaxVirtualSize (Long64_t size=0);  ; void SetName (const char *name) override;  Change the name of this tree. ;  ; virtual void SetNotify (TObject *obj);  Sets the address of the object to be notified when the tree is loaded. ;  ; virtual void SetObject (const char *name, const char *title);  Change the name and title of this tree. ;  ; virtual void SetParallelUnzip (bool opt=true, Float_t RelSize=-1);  Enable or disable parallel unzipping of Tree buffers. ;  ; virtual void SetPerfStats (TVirtualPerfStats *perf);  Set perf stats. ;  ; virtual void SetScanField (Int_t n=50);  ; void SetTargetMemoryRatio (Float_t ratio);  ; virtual void SetTimerInterval (Int_t msec=333);  ; virtual void SetTreeIndex (TVirtualIndex *index);  The current TreeIndex is replaced by the new index. ;  ; virtual void SetUpdate (Int_t freq=0);  ; virtual void Show (Long64_t entry=-1, Int_t lenmax=20);  Print values of all active leaves for entry. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this tree. ;  ; virtual Int_t StopCacheLearningPhase ();  Stop the cache learning phase. ;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:27114,load,loaded,27114,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,1,['load'],['loaded']
Performance,"tDebug (Int_t level=1, Long64_t min=0, Long64_t max=9999999);  Set the debug level and the debug range. ;  ; virtual void SetDefaultEntryOffsetLen (Int_t newdefault, bool updateExisting=false);  Update the default value for the branch's fEntryOffsetLen. ;  ; virtual Long64_t SetEntries (Long64_t n=-1);  Change number of entries in the tree. ;  ; virtual void SetEstimate (Long64_t nentries=1000000);  Set number of entries to estimate variable limits. ;  ; virtual void SetFileNumber (Int_t number=0);  Set fFileNumber to number. ;  ; virtual void SetImplicitMT (bool enabled);  ; ROOT::TIOFeatures SetIOFeatures (const ROOT::TIOFeatures &);  Provide the end-user with the ability to enable/disable various experimental IO features for this TTree. ;  ; virtual void SetMaxEntryLoop (Long64_t maxev=kMaxEntries);  ; virtual void SetMaxVirtualSize (Long64_t size=0);  ; void SetName (const char *name) override;  Change the name of this tree. ;  ; virtual void SetNotify (TObject *obj);  Sets the address of the object to be notified when the tree is loaded. ;  ; virtual void SetObject (const char *name, const char *title);  Change the name and title of this tree. ;  ; virtual void SetParallelUnzip (bool opt=true, Float_t RelSize=-1);  Enable or disable parallel unzipping of Tree buffers. ;  ; virtual void SetPerfStats (TVirtualPerfStats *perf);  Set perf stats. ;  ; virtual void SetScanField (Int_t n=50);  Sets the default maximum number of lines to be shown before <CR> when calling Scan(). ;  ; void SetTargetMemoryRatio (Float_t ratio);  ; virtual void SetTimerInterval (Int_t msec=333);  ; virtual void SetTreeIndex (TVirtualIndex *index);  The current TreeIndex is replaced by the new index. ;  ; virtual void SetUpdate (Int_t freq=0);  ; virtual void Show (Long64_t entry=-1, Int_t lenmax=20);  Print values of all active leaves for entry. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this tree. ;  ; virtual Int_t StopCacheLearningPhase ();  Stop the cache learning pha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:27198,load,loaded,27198,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,1,['load'],['loaded']
Performance,"tDefinition TInterpreter.h:532; TInterpreter::SetErrorMessagesvirtual Bool_t SetErrorMessages(Bool_t enable=kTRUE)=0; TInterpreter::GenerateTClassvirtual TClass * GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent=kFALSE)=0; TInterpreter::CallFunc_SetArgvoid CallFunc_SetArg(CallFunc_t *func, UChar_t param) constDefinition TInterpreter.h:344; TInterpreter::MethodInfo_Propertyvirtual Long_t MethodInfo_Property(MethodInfo_t *) const =0; TInterpreter::GetSharedLibsvirtual const char * GetSharedLibs()=0; TInterpreter::MapCppNamevirtual const char * MapCppName(const char *) constDefinition TInterpreter.h:261; TInterpreter::MethodInfo_IsValidvirtual Bool_t MethodInfo_IsValid(MethodInfo_t *) constDefinition TInterpreter.h:493; TInterpreter::DataMemberInfo_Deletevirtual void DataMemberInfo_Delete(DataMemberInfo_t *) constDefinition TInterpreter.h:456; TInterpreter::LoadEnumsvirtual void LoadEnums(TListOfEnums &cl) const =0; TInterpreter::BaseClassInfo_ClassInfovirtual ClassInfo_t * BaseClassInfo_ClassInfo(BaseClassInfo_t *) const =0; TInterpreter::~TInterpretervirtual ~TInterpreter()Definition TInterpreter.h:137; TInterpreter::FindSymvirtual void * FindSym(const char *) constDefinition TInterpreter.h:253; TInterpreter::SaveContextvirtual void SaveContext()=0; TInterpreter::ProcessLineSynchvirtual Longptr_t ProcessLineSynch(const char *line, EErrorCode *error=nullptr)=0; TInterpreter::SetErrmsgcallbackvirtual void SetErrmsgcallback(void *) constDefinition TInterpreter.h:267; TInterpreter::CallFunc_SetArgImplvoid CallFunc_SetArgImpl(CallFunc_t *)Definition TInterpreter.h:362; TInterpreter::CallFunc_SetArgvoid CallFunc_SetArg(CallFunc_t *func, UShort_t param) constDefinition TInterpreter.h:345; TInterpreter::ClassInfo_IsLoadedvirtual Bool_t ClassInfo_IsLoaded(ClassInfo_t *) constDefinition TInterpreter.h:420; TInterpreter::DataMemberInfo_MaxIndexvirtual int DataMemberInfo_MaxIndex(DataMemberInfo_t *, Int_t) constDefinition TInterpreter.h:461; TInterpreter::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TInterpreter_8h_source.html:68753,Load,LoadEnumsvirtual,68753,doc/master/TInterpreter_8h_source.html,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html,2,['Load'],"['LoadEnums', 'LoadEnumsvirtual']"
Performance,"tDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _printScientific;  ; static Int_t _printSigDigits;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:70866,cache,cache,70866,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['cache'],['cache']
Performance,"tDown();; 224 }; 225 ; 226 // Now that all the canvases and files have been closed we can; 227 // delete the implementation.; 228 SafeDelete(fAppImp);; 229}; 230 ; 231////////////////////////////////////////////////////////////////////////////////; 232/// Static method. This method should be called from static library; 233/// initializers if the library needs the low level graphics system.; 234 ; 235void TApplication::NeedGraphicsLibs(); 236{; 237 fgGraphNeeded = kTRUE;; 238}; 239 ; 240////////////////////////////////////////////////////////////////////////////////; 241/// Initialize the graphics environment.; 242/// If @param only_web is specified, only web-related part of graphics is loaded; 243 ; 244void TApplication::InitializeGraphics(Bool_t only_web); 245{; 246 if (fgGraphInit || !fgGraphNeeded); 247 return;; 248 ; 249 if (!only_web) {; 250 // Load the graphics related libraries; 251 LoadGraphicsLibs();; 252 ; 253 // Try to load TrueType font renderer. Only try to load if not in batch; 254 // mode and Root.UseTTFonts is true and Root.TTFontPath exists. Abort silently; 255 // if libttf or libGX11TTF are not found in $ROOTSYS/lib or $ROOTSYS/ttf/lib.; 256 const char *ttpath = gEnv->GetValue(""Root.TTFontPath"",; 257 TROOT::GetTTFFontDir());; 258 char *ttfont = gSystem->Which(ttpath, ""arialbd.ttf"", kReadPermission);; 259 // Check for use of DFSG - fonts; 260 if (!ttfont); 261 ttfont = gSystem->Which(ttpath, ""FreeSansBold.ttf"", kReadPermission);; 262 ; 263 #if !defined(R__WIN32); 264 if (!gROOT->IsBatch() && !strcmp(gVirtualX->GetName(), ""X11"") &&; 265 ttfont && gEnv->GetValue(""Root.UseTTFonts"", 1)) {; 266 if (gClassTable->GetDict(""TGX11TTF"")) {; 267 // in principle we should not have linked anything against libGX11TTF; 268 // but with ACLiC this can happen, initialize TGX11TTF by hand; 269 // (normally this is done by the static library initializer); 270 ProcessLine(""TGX11TTF::Activate();"");; 271 } else {; 272 TPluginHandler *h;; 273 if ((h = gROOT->GetPluginManage",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:8951,load,load,8951,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['load'],['load']
Performance,"tDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidsetVal(const char* newVal); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStringVar.html:14170,cache,cache,14170,root/html526/RooStringVar.html,https://root.cern,https://root.cern/root/html526/RooStringVar.html,1,['cache'],['cache']
Performance,"tEntries()!=oldchain->GetEntries()) {; 2029/// ... not all the file have been copied ...; 2030/// }; 2031/// ~~~; 2032 ; 2033Long64_t TChain::Merge(TFile* file, Int_t basketsize, Option_t* option); 2034{; 2035 // We must have been passed a file, we will use it; 2036 // later to reset the compression level of the branches.; 2037 if (!file) {; 2038 // FIXME: We need an error message here.; 2039 return 0;; 2040 }; 2041 ; 2042 // Options; 2043 bool fastClone = false;; 2044 TString opt = option;; 2045 opt.ToLower();; 2046 if (opt.Contains(""fast"")) {; 2047 fastClone = true;; 2048 }; 2049 ; 2050 // The chain tree must have a list of branches; 2051 // because we may try to change their basket; 2052 // size later.; 2053 TObjArray* lbranches = GetListOfBranches();; 2054 if (!lbranches) {; 2055 // FIXME: We need an error message here.; 2056 return 0;; 2057 }; 2058 ; 2059 // The chain must have a current tree because; 2060 // that is the one we will clone.; 2061 if (!fTree) {; 2062 // -- LoadTree() has not yet been called, no current tree.; 2063 // FIXME: We need an error message here.; 2064 return 0;; 2065 }; 2066 ; 2067 // Copy the chain's current tree without; 2068 // copying any entries, we will do that later.; 2069 TTree* newTree = CloneTree(0);; 2070 if (!newTree) {; 2071 // FIXME: We need an error message here.; 2072 return 0;; 2073 }; 2074 ; 2075 // Strip out the (potential) directory name.; 2076 // FIXME: The merged chain may or may not have the; 2077 // same name as the original chain. This is; 2078 // bad because the chain name determines the; 2079 // names of the trees in the chain by default.; 2080 newTree->SetName(gSystem->BaseName(GetName()));; 2081 ; 2082 // FIXME: Why do we do this?; 2083 newTree->SetAutoSave(2000000000);; 2084 ; 2085 // Circularity is incompatible with merging, it may; 2086 // force us to throw away entries, which is not what; 2087 // we are supposed to do.; 2088 newTree->SetCircular(0);; 2089 ; 2090 // Reset the compression level of the branch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:74165,Load,LoadTree,74165,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Load'],['LoadTree']
Performance,"tEntriesFast(); ievent++) {; 486 /// // Do something with the event in the dataset; 487 /// }; 488 /// \endcode; 489 ///; 490 /// In the example above, independently on whether the dataset is a TTree or; 491 /// a TChain, the GetEntriesFast call will provide the correct stopping; 492 /// condition for the loop (i.e. the total number of entries). In the TChain; 493 /// case, calling GetEntries instead would open all the files in the chain; 494 /// upfront which could be costly.; 495 ///; 496 /// The functionality offered by this method can also be seen when used in; 497 /// conjunction with LoadTree. For a call like <tt> LoadTree(ievent) </tt>,; 498 /// the condition <tt> ievent < dataset.GetEntriesFast() </tt> is only; 499 /// satisfied if \p ievent is strictly smaller than the total number of; 500 /// entries in the dataset. In fact, even when the dataset is a TChain, the; 501 /// first time LoadTree is called with an entry number that belongs to the; 502 /// last file of the chain, this will update the internal data member of the; 503 /// class so that the next call to GetEntriesFast returns the total number; 504 /// of entries in the dataset.; 505 virtual Long64_t GetEntriesFast() const { return fEntries; }; 506 virtual Long64_t GetEntriesFriend() const;; 507 virtual Long64_t GetEstimate() const { return fEstimate; }; 508 virtual Int_t GetEntry(Long64_t entry, Int_t getall = 0);; 509 Int_t GetEvent(Long64_t entry, Int_t getall = 0) { return GetEntry(entry, getall); }; 510 virtual Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0);; 511 virtual Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor = 0) const;; 512 virtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor = 0) const;; 513 TEventList *GetEventList() const { return fEventList; }; 514 virtual TEntryList *GetEntryList();; 515 virtual Long64_t GetEntryNumber(Long64_t entry) const;; 516 virtual Int_t GetFileNumber() const { return fFileNumber; }; 517 virtual TTree *GetFrien",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:26864,Load,LoadTree,26864,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['Load'],['LoadTree']
Performance,"tEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:29158,cache,cache,29158,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,4,['cache'],['cache']
Performance,"tFile. private . Definition at line 209 of file RNTupleImporter.hxx. ◆ fDestFileName. std::string ROOT::Experimental::RNTupleImporter::fDestFileName. private . Definition at line 207 of file RNTupleImporter.hxx. ◆ fEntry. std::unique_ptr<REntry> ROOT::Experimental::RNTupleImporter::fEntry. private . Definition at line 225 of file RNTupleImporter.hxx. ◆ fFieldModifier. FieldModifier_t ROOT::Experimental::RNTupleImporter::fFieldModifier. private . Definition at line 222 of file RNTupleImporter.hxx. ◆ fImportBranches. std::vector<RImportBranch> ROOT::Experimental::RNTupleImporter::fImportBranches. private . Definition at line 226 of file RNTupleImporter.hxx. ◆ fImportFields. std::vector<RImportField> ROOT::Experimental::RNTupleImporter::fImportFields. private . Definition at line 227 of file RNTupleImporter.hxx. ◆ fImportTransformations. std::vector<std::unique_ptr<RImportTransformation> > ROOT::Experimental::RNTupleImporter::fImportTransformations. private . The list of transformations to be performed for every entry. ; Definition at line 231 of file RNTupleImporter.hxx. ◆ fIsQuiet. bool ROOT::Experimental::RNTupleImporter::fIsQuiet = false. private . No standard output, conversely if set to false, schema information and progress is printed. ; Definition at line 220 of file RNTupleImporter.hxx. ◆ fLeafCountCollections. std::map<std::string, RImportLeafCountCollection> ROOT::Experimental::RNTupleImporter::fLeafCountCollections. private . Maps the count leaf to the information about the corresponding untyped collection. ; Definition at line 229 of file RNTupleImporter.hxx. ◆ fMaxEntries. std::int64_t ROOT::Experimental::RNTupleImporter::fMaxEntries = -1. private . The maximum number of entries to import. When this value is -1 (default), import all entries. ; Definition at line 217 of file RNTupleImporter.hxx. ◆ fModel. std::unique_ptr<RNTupleModel> ROOT::Experimental::RNTupleImporter::fModel. private . Definition at line 224 of file RNTupleImporter.hxx. ◆ fNTupleName. st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleImporter.html:13291,perform,performed,13291,doc/master/classROOT_1_1Experimental_1_1RNTupleImporter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleImporter.html,1,['perform'],['performed']
Performance,"tFiles() list,; the file may be a remote file url; <macro>.C are considered ROOT macros and also added to the InputFiles() list; In TRint we set the working directory to the <dir>, the ROOT files are; connected, and the macros are executed. If your main TApplication is not; TRint you have to decide yourself what to do whith these options.; All specified arguments (also the ones removed) can always be retrieved; via the TApplication::Argv() method. void HandleIdleTimer(); Handle idle timeout. When this timer expires the registered idle command; will be executed by this routine and a signal will be emitted. void HandleException(Int_t sig); Handle exceptions (kSigBus, kSigSegmentationViolation,; kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; Specific TApplication implementations may want something different here. void Help(const char* line); Print help on interpreter. void LoadGraphicsLibs(); Load shared libs neccesary for graphics. These libraries are only; loaded when gROOT->IsBatch() is kFALSE. void MakeBatch(); Switch to batch mode. Int_t ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); Parse the content of a line starting with "".R"" (already stripped-off); The format is; [user@]host[:dir] [-l user] [-d dbg] [script]; The variable 'dir' is the remote directory to be used as working dir.; The username can be specified in two ways, ""-l"" having the priority; (as in ssh).; A 'dbg' value > 0 gives increasing verbosity.; The last argument 'script' allows to specify an alternative script to; be executed remotely to startup the session. Long_t ProcessRemote(const char* line, Int_t* error = 0); Process the content of a line starting with "".R"" (already stripped-off); The format is; [user@]host[:dir] [-l user] [-d dbg] [script] | [host] -close; The variable 'dir' is the remote directory to be used as working dir.; The username can be specified in two ways, ""-l"" having the priority; (as in ssh).; A 'dbg' valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TApplication.html:16011,load,loaded,16011,root/html528/TApplication.html,https://root.cern,https://root.cern/root/html528/TApplication.html,6,['load'],['loaded']
Performance,"tFromFile.; Definition at line 81 of file TEntryList.h. ◆ IsA(). TClass * TEntryList::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TEntryListArray, and TEntryListFromFile.; Definition at line 125 of file TEntryList.h. ◆ IsValid(). bool TEntryList::IsValid ; (; ); const. inline . Definition at line 84 of file TEntryList.h. ◆ Merge(). Int_t TEntryList::Merge ; (; TCollection * ; list). virtual . Merge this list with the lists from the collection. ; Reimplemented in TEntryListFromFile.; Definition at line 979 of file TEntryList.cxx. ◆ Next(). Long64_t TEntryList::Next ; (; ). virtual . Return the next non-zero entry index (next after fLastIndexQueried) this function is faster than GetEntry() ; Reimplemented in TEntryListFromFile.; Definition at line 998 of file TEntryList.cxx. ◆ operator=(). TEntryList & TEntryList::operator= ; (; const TEntryList & ; ). private . ◆ OptimizeStorage(). void TEntryList::OptimizeStorage ; (; ). virtual . Checks if the array representation is more economical and if so, switches to it. ; Reimplemented in TEntryListFromFile.; Definition at line 1085 of file TEntryList.cxx. ◆ Print(). void TEntryList::Print ; (; const Option_t * ; option = """"); const. override . Print this list. . option = """" - default - print the name of the tree and file; option = ""all"" - print all the entry numbers . Definition at line 1101 of file TEntryList.cxx. ◆ Relocate(). Int_t TEntryList::Relocate ; (; const char * ; fn, . const char * ; newroot, . const char * ; oldroot = nullptr, . const char * ; enlnm = nullptr . ). static . Relocate entry list 'enlnm' in file 'fn' replacing 'oldroot' with 'newroot' in filenames. ; If 'enlnm' is null or '*' all entry lists in the file are relocated. Relocation is mandatory to use the entry-list with the same dataset at a different location (i.e. on a different cluster, machine or disks). This function can be called as many times as need to reach ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryList.html:35736,Optimiz,OptimizeStorage,35736,doc/master/classTEntryList.html,https://root.cern,https://root.cern/doc/master/classTEntryList.html,1,['Optimiz'],['OptimizeStorage']
Performance,"tFromFile::Enter ; (; Long64_t ; , . const char * ; , . const char * ;  . ). inlineoverridevirtual . Reimplemented from TEntryList.; Definition at line 66 of file TEntryListFromFile.h. ◆ Enter() [2/2]. bool TEntryListFromFile::Enter ; (; Long64_t ; entry, . TTree * ; tree . ). inlineoverridevirtual . Add entry #entry to the list. . When tree = 0, adds to the current list; When tree != 0, finds the list, corresponding to this tree; When tree is a chain, the entry is assumed to be global index and the local entry is recomputed from the treeoffset information of the chain . Reimplemented from TEntryList.; Definition at line 65 of file TEntryListFromFile.h. ◆ GetCurrentList(). TEntryList * TEntryListFromFile::GetCurrentList ; (; ); const. inlineoverridevirtual . Reimplemented from TEntryList.; Definition at line 67 of file TEntryListFromFile.h. ◆ GetEntries(). Long64_t TEntryListFromFile::GetEntries ; (; ). virtual . Returns the total number of entries in the list. ; If some lists have not been loaded, loads them. ; Definition at line 166 of file TEntryListFromFile.cxx. ◆ GetEntriesFast(). virtual Long64_t TEntryListFromFile::GetEntriesFast ; (; ); const. inlinevirtual . Definition at line 73 of file TEntryListFromFile.h. ◆ GetEntry(). Long64_t TEntryListFromFile::GetEntry ; (; Long64_t ; index). overridevirtual . Returns entry #index See also Next() for a faster alternative. ; Reimplemented from TEntryList.; Definition at line 90 of file TEntryListFromFile.cxx. ◆ GetEntryAndTree(). Long64_t TEntryListFromFile::GetEntryAndTree ; (; Long64_t ; index, . Int_t & ; treenum . ). overridevirtual . Return the entry corresponding to the index parameter and the number of the tree, where this entry is. ; Reimplemented from TEntryList.; Definition at line 155 of file TEntryListFromFile.cxx. ◆ GetEntryList(). TEntryList * TEntryListFromFile::GetEntryList ; (; const char * ; treename, . const char * ; filename, . Option_t * ; opt . ). inlineoverridevirtual . Return the entry list, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryListFromFile.html:23879,load,loaded,23879,doc/master/classTEntryListFromFile.html,https://root.cern,https://root.cern/doc/master/classTEntryListFromFile.html,2,['load'],"['loaded', 'loads']"
Performance,"tFromOutside back from new point.; Plot d-(d1+d2). void ClearVisibleVolumes(); Clear the list of visible volumes; reset the kVisOnScreen bit for volumes previously in the list. void DefineColors() const; Define 100 colors with increasing light intensities for each basic color (1-7); Register these colors at indexes starting with 1000. Int_t GetColor(Int_t base, Float_t light) const; Get index of a base color with given light intensity (0,1). TGeoVolume * GetDrawnVolume() const; Get currently drawn volume. Int_t DistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py); compute the closest distance of approach from point px,py to a volume. void DefaultAngles(); Set default angles for the current view. void DefaultColors(); Set default volume colors according to tracking media. Int_t CountNodes(TGeoVolume* vol, Int_t level) const; Count number of visible nodes down to a given level. Int_t CountVisibleNodes(); Count total number of visible nodes. void CheckEdit(); Check if Ged library is loaded and load geometry editor classe. void EditGeometry(Option_t* option = """"); Start the geometry editor. void Draw(Option_t* option = """"); Draw method. void DrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"); Draw the time evolution of a radionuclide. void DrawPolygon(const TGeoPolygon* poly); Draw a polygon in 3D. void DrawVolume(TGeoVolume* vol, Option_t* option = """"); Draw method. void DrawShape(TGeoShape* shape, Option_t* option = """"); Draw a shape. void DrawOverlap(void* ovlp, Option_t* option = """"); Draw an overlap. void DrawOnly(Option_t* option = """"); Draw only one volume. void DrawCurrentPoint(Int_t color); Draw current point in the same view. void DrawPanel(). void DrawPath(const char* path, Option_t* option = """"); Draw all volumes for a given path. void EstimateCameraMove(Double_t tmin, Double_t tmax, Double_t* start, Double_t* end); Estimate camera movement between tmin and tmax for best track display. void ExecuteManagerEvent(TGeoManager* geom, Int_t event, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPainter.html:15780,load,loaded,15780,root/html534/TGeoPainter.html,https://root.cern,https://root.cern/root/html534/TGeoPainter.html,6,['load'],"['load', 'loaded']"
Performance,"tFromOutside back from new point.; Plot d-(d1+d2). void ClearVisibleVolumes(); Clear the list of visible volumes; reset the kVisOnScreen bit for volumes previously in the list. void DefineColors() const; Define 100 colors with increasing light intensities for each basic color (1-7); Register these colors at indexes starting with 1000. Int_t GetColor(Int_t base, Float_t light) const; Get index of a base color with given light intensity (0,1). TGeoVolume * GetDrawnVolume() const; Get currently drawn volume. Int_t DistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py); compute the closest distance of approach from point px,py to a volume. void DefaultAngles(); Set default angles for the current view. void DefaultColors(); Set default volume colors according to tracking media. Int_t CountNodes(TGeoVolume* vol, Int_t level) const; Count number of visible nodes down to a given level. Int_t CountVisibleNodes(); Count total number of visible nodes. void CheckEdit(); Check if Ged library is loaded and load geometry editor classe. void EditGeometry(Option_t* option = """"); Start the geometry editor. void Draw(Option_t* option = """"); Draw method. void DrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"); Draw the time evolution of a radionuclide. void DrawVolume(TGeoVolume* vol, Option_t* option = """"); Draw method. void DrawShape(TGeoShape* shape, Option_t* option = """"); Draw a shape. void DrawOverlap(void* ovlp, Option_t* option = """"); Draw an overlap. void DrawOnly(Option_t* option = """"); Draw only one volume. void DrawCurrentPoint(Int_t color); Draw current point in the same view. void DrawPanel(). void DrawPath(const char* path); Draw all volumes for a given path. void EstimateCameraMove(Double_t tmin, Double_t tmax, Double_t* start, Double_t* end); Estimate camera movement between tmin and tmax for best track display. void ExecuteManagerEvent(TGeoManager* geom, Int_t event, Int_t px, Int_t py); Execute mouse actions on a given volume. void ExecuteShapeEvent(TGeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoPainter.html:15610,load,loaded,15610,root/html530/TGeoPainter.html,https://root.cern,https://root.cern/root/html530/TGeoPainter.html,4,['load'],"['load', 'loaded']"
Performance,"tGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory::GetListOfKeys() const; TSeqCollection*GetListOfMappedFiles() const; TSeqCollection*GetListOfMessageHandlers() const; TSeqCollection*GetListOfProofs() const; TSeqCollection*GetListOfSecContexts() const; TSeqCollection*GetListOfSockets() const; TSeqCollection*GetListOfSpecials() const; TSeqCollection*GetListOfStreamerInfo() const; TSeqCollection*GetListOfStyles() const; TSeqCollection*GetListOfTasks() const; TCollection*GetListOfTypes(Bool_t load = kFALSE); static const char*GetMacroPath(); virtual TObject*TDirectory::GetMother() const; virtual TDirectory*TDirectory::GetMotherDir() const; virtual const char*TNamed::GetName() const; virtual Int_tTDirectory::GetNbytesKeys() const; Int_tGetNclasses() const; virtual Int_tTDirectory::GetNkeys() const; Int_tGetNtypes() const; voidTDirectory::GetObject(const char* namecycle, void*& ptr); virtual void*TDirectory::GetObjectChecked(const char* namecycle, const char* classname); virtual void*TDirectory::GetObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:6832,load,load,6832,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['load'],['load']
Performance,"tGlobalPwHash ; (; Bool_t ; pwhash). static . Set global passwd hash flag to be used for authentication to rootd or proofd. ; Definition at line 1323 of file TAuthenticate.cxx. ◆ SetGlobalSRPPwd(). void TAuthenticate::SetGlobalSRPPwd ; (; Bool_t ; srppwd). static . Set global SRP passwd flag to be used for authentication to rootd or proofd. ; Definition at line 1331 of file TAuthenticate.cxx. ◆ SetGlobalUser(). void TAuthenticate::SetGlobalUser ; (; const char * ; user). static . Set global user name to be used for authentication to rootd or proofd. ; Definition at line 1295 of file TAuthenticate.cxx. ◆ SetGlobusAuthHook(). void TAuthenticate::SetGlobusAuthHook ; (; GlobusAuth_t ; func). static . Set Globus authorization function. ; Automatically called when libGlobusAuth is loaded. ; Definition at line 1411 of file TAuthenticate.cxx. ◆ SetKrb5AuthHook(). void TAuthenticate::SetKrb5AuthHook ; (; Krb5Auth_t ; func). static . Set kerberos5 authorization function. ; Automatically called when libKrb5Auth is loaded. ; Definition at line 1402 of file TAuthenticate.cxx. ◆ SetPromptUser(). void TAuthenticate::SetPromptUser ; (; Bool_t ; promptuser). static . Set global PromptUser flag. ; Definition at line 1385 of file TAuthenticate.cxx. ◆ SetReadHomeAuthrc(). void TAuthenticate::SetReadHomeAuthrc ; (; Bool_t ; readhomeauthrc). static . Set flag controlling the reading of $HOME/.rootauthrc. ; In PROOF the administrator may want to switch off private settings. Always true, may only be set false via option to proofd. ; Definition at line 1341 of file TAuthenticate.cxx. ◆ SetRSAInit(). void TAuthenticate::SetRSAInit ; (; Int_t ; init = 1). static . Static method setting RSA initialization flag. ; Definition at line 1228 of file TAuthenticate.cxx. ◆ SetRSAKeyType(). void TAuthenticate::SetRSAKeyType ; (; Int_t ; key). inline . Definition at line 148 of file TAuthenticate.h. ◆ SetRSAPublic(). Int_t TAuthenticate::SetRSAPublic ; (; const char * ; rsaPubExport, . Int_t ; klen . ). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:39593,load,loaded,39593,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['load'],['loaded']
Performance,"tHelperArgs> &snapHelperArgs,; 259 const unsigned int nSlots, std::shared_ptr<PrevNodeType> prevNode, ActionTags::Snapshot,; 260 const RColumnRegister &colRegister); 261{; 262 const auto &filename = snapHelperArgs->fFileName;; 263 const auto &dirname = snapHelperArgs->fDirName;; 264 const auto &treename = snapHelperArgs->fTreeName;; 265 const auto &outputColNames = snapHelperArgs->fOutputColNames;; 266 const auto &options = snapHelperArgs->fOptions;; 267 ; 268 auto sz = sizeof...(ColTypes);; 269 std::vector<bool> isDefine(sz);; 270 for (auto i = 0u; i < sz; ++i); 271 isDefine[i] = colRegister.IsDefineOrAlias(colNames[i]);; 272 ; 273 std::unique_ptr<RActionBase> actionPtr;; 274 if (!ROOT::IsImplicitMTEnabled()) {; 275 // single-thread snapshot; 276 using Helper_t = SnapshotHelper<ColTypes...>;; 277 using Action_t = RAction<Helper_t, PrevNodeType>;; 278 actionPtr.reset(; 279 new Action_t(Helper_t(filename, dirname, treename, colNames, outputColNames, options, std::move(isDefine)),; 280 colNames, prevNode, colRegister));; 281 } else {; 282 // multi-thread snapshot; 283 using Helper_t = SnapshotHelperMT<ColTypes...>;; 284 using Action_t = RAction<Helper_t, PrevNodeType>;; 285 actionPtr.reset(new Action_t(; 286 Helper_t(nSlots, filename, dirname, treename, colNames, outputColNames, options, std::move(isDefine)),; 287 colNames, prevNode, colRegister));; 288 }; 289 return actionPtr;; 290}; 291 ; 292// Book with custom helper type; 293template <typename... ColTypes, typename PrevNodeType, typename Helper_t>; 294std::unique_ptr<RActionBase>; 295BuildAction(const ColumnNames_t &bl, const std::shared_ptr<Helper_t> &h, const unsigned int /*nSlots*/,; 296 std::shared_ptr<PrevNodeType> prevNode, ActionTags::Book, const RColumnRegister &colRegister); 297{; 298 using Action_t = RAction<Helper_t, PrevNodeType, TTraits::TypeList<ColTypes...>>;; 299 return std::make_unique<Action_t>(Helper_t(std::move(*h)), bl, std::move(prevNode), colRegister);; 300}; 301 ; 302/****** end BuildAndBoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/InterfaceUtils_8hxx_source.html:11886,multi-thread,multi-thread,11886,doc/master/InterfaceUtils_8hxx_source.html,https://root.cern,https://root.cern/doc/master/InterfaceUtils_8hxx_source.html,1,['multi-thread'],['multi-thread']
Performance,"tHub based build system.; Bugs and Issues fixed in this release; More than 200 items were addressed for this release. The full list is:. [#15621] - Buffer overflow in TBranch::Init; [#15610] - Memory leak in TTree getattr pythonization; [#15590] - Infinite recursion in TFile::Open; [#15460] - TEnum::GetEnum(“B”)->GetUnderlyingType() does not following typedefs; [#15413] - Fails to build with cuDNN version 9; [#15406] - TEnum::GetEnum does not seem to see ‘through’ using statements.; [#15399] - Memory leak with jitted nodes if the execution is never triggered; [#15396] - [TMVA] Pymva test (Keras) failing on 632 and main; [#15370] - Broken link in HS3 printout; [#15340] - Webgraphics: canvas displayed, but many error printed; [#15253] - C++ standard not propagated via CMake anymore; [#15197] - RBDT does not support xgboost inference; [#15156] - Segfault in TMVA::Experimental::SOFIE::RModel::Streamer; [#15139] - cmake option -Dall=YES breaks the cmake; [#15118] - jsoninterface does not build if provided with RapidYAML; [#15108] - Turn off clang-format for Linkdef files; [#15090] - TClass::GetClassInfo() is not thread safe; [#15077] - Passing different floating point types to RVec utility functions; [#15048] - [ntuple] Handling of virtual inheritance broken; [#15040] - RDataFrame Inaccurate example of progress bar from documentation; [#15028] - RDataFrame Unable to cacheread remote file; [#15027] - spurrious cmake message about AfterImage with -Dminimal=ON; [#14981] - RVecs leak memory with np.asarray in pyROOT; [#14964] - ROOT-HEAD fails with “cling interactive line includer >>>: fatal error: module file ‘[snip]/Vc.pcm’ not found: module file not found”; [#14958] - ROOT_HEAD failed with error message: Fail to detect cryptographic random generator; [#14921] - ROOT Fails to build macOS 14.4 arm64 Xcode 15.3; [#14914] - VecOps::Take with default argument doesn’t check correctly the out of boundary condition; [#14910] - hadd issue when using parallelization together with in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:26047,cache,cacheread,26047,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['cache'],['cacheread']
Performance,"tLine class so the line style or width can also be changed:; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; kRed@ kRedDefinition Rtypes.h:66; kDotted@ kDottedDefinition TAttLine.h:48; When drawing in solid mode, the color of the drawn volume corresponds to the line color.; Visibility Settings; The way geometry is build forces the definition of several volumes that does not represent real objects, but just virtual containers used for grouping and positioning volumes together. One would not want to see them in the picture. Since every volume is by default visible, one has to do this sort of tuning by its own:; myVolumeContainer->SetVisibility(kFALSE);; As described before, the drawing package supports two main global options: 1 (default) - only final volume leaves; 0 - all volumes down the drawn one appear on the screen. The global visible level put a limitation on the maximum applied depth. Combined with visibility settings per volume, these can tune quite well what should appear on the screen. However, there are situations when users want to see a volume branch displayed down to the maximum depth, keeping at the same time a limitation or even suppressing others. In order to accomplish that, one should use the volume attribute: ""Visible daughters"". By default, all daughters of all volumes are displayed if there is no limitation related with their level depth with respect to the top drawn volume. Ray Tracing; Ray tracing is a quite known drawing technique based on tracking rays from the eye position through all pixels of a view port device. The pixel color is derived from the properties of the first crossed surface, according some illumination model and material optical properties. While there are currently existing quite sophisticated ray tracing models, TGeo is currently using a very simple approach where the light source is matching the eye position (no shadows or back-tracing of the reflected ray). In future we are cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:111743,tune,tune,111743,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['tune'],['tune']
Performance,"tListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunctionTemplate * Get(TListOfFunctionTemplates::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the functions known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TFunctionTemplate* func); Mark 'func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfFunctionTemplates(const TListOfFunctionTemplates& ). TListOfFunctionTemplates& operator=(const TListOfFunctionTemplates& ). » Author: Philippe Canal Aug 2013 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfFunctionTemplates.html:14780,Load,Load,14780,root/html604/TListOfFunctionTemplates.html,https://root.cern,https://root.cern/root/html604/TListOfFunctionTemplates.html,2,['Load'],['Load']
Performance,"tListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunctionTemplate * Get(TListOfFunctionTemplates::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the functions known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TFunctionTemplate* func); Mark 'func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfFunctionTemplates(const TListOfFunctionTemplates& ). TListOfFunctionTemplates& operator=(const TListOfFunctionTemplates& ). » Author: Philippe Canal Aug 2013 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last generated: 2015-06-30 15:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfFunctionTemplates.html:14780,Load,Load,14780,root/html602/TListOfFunctionTemplates.html,https://root.cern,https://root.cern/root/html602/TListOfFunctionTemplates.html,2,['Load'],['Load']
Performance,"tListOfAllPublicDataMembers(Bool_t load=kTRUE)Returns a list of all public data members of this class and its base classes.Definition TClass.cxx:3862; TClass::AddClassToDeclIdMapstatic void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass *cl)static: Add a TClass* to the map of classes.Definition TClass.cxx:511; TClass::~TClassvirtual ~TClass()TClass dtor. Deletes all list that might have been created.Definition TClass.cxx:1660; TClass::fIsSyntheticPairBool_t fIsSyntheticPairIndicates whether this class can be split or not. Values are -1, 0, 1, 2.Definition TClass.h:250; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5400; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::fCurrentInfostd::atomic< TVirtualStreamerInfo * > fCurrentInfoCurrent 'state' of the class (Emulated,Interpreted,Loaded)Definition TClass.h:278; TClass::GetListOfFunctionTemplatesTList * GetListOfFunctionTemplates(Bool_t load=kTRUE)Return TListOfFunctionTemplates for a class.Definition TClass.cxx:3798; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4915; TClass::fImplFileNameconst char * fImplFileNameDefinition TClass.h:214; TClass::RegisterStreamerInfovoid RegisterStreamerInfo(TVirtualStreamerInfo *info)Register the StreamerInfo in the given slot, change the State of the TClass as appropriate.Definition TClass.cxx:7296; TClass::fCheckSumstd::atomic< UInt_t > fCheckSumDefinition TClass.h:219; TClass::UnregisterAddressInRepositoryvoid UnregisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:318; TClass::fMethodstd::atomic< TListOfFunctions * > fMethodDefinition TClass.h:207; TClass::RemoveClassDeclIdstatic void RemoveClassDeclId(TDictionary::DeclId_t id)Definition TClass.cxx:536; TClass::SetNewArrayvoid SetNewArray(R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:315502,load,load,315502,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"tListOfAllPublicDataMembers(Bool_t load=kTRUE)Returns a list of all public data members of this class and its base classes.Definition TClass.cxx:3929; TClass::AddClassToDeclIdMapstatic void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass *cl)static: Add a TClass* to the map of classes.Definition TClass.cxx:576; TClass::~TClassvirtual ~TClass()TClass dtor. Deletes all list that might have been created.Definition TClass.cxx:1727; TClass::fIsSyntheticPairBool_t fIsSyntheticPairIndicates whether this class can be split or not. Values are -1, 0, 1, 2.Definition TClass.h:250; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::fCurrentInfostd::atomic< TVirtualStreamerInfo * > fCurrentInfoCurrent 'state' of the class (Emulated,Interpreted,Loaded)Definition TClass.h:278; TClass::GetListOfFunctionTemplatesTList * GetListOfFunctionTemplates(Bool_t load=kTRUE)Return TListOfFunctionTemplates for a class.Definition TClass.cxx:3865; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::fImplFileNameconst char * fImplFileNameDefinition TClass.h:214; TClass::RegisterStreamerInfovoid RegisterStreamerInfo(TVirtualStreamerInfo *info)Register the StreamerInfo in the given slot, change the State of the TClass as appropriate.Definition TClass.cxx:7363; TClass::fCheckSumstd::atomic< UInt_t > fCheckSumDefinition TClass.h:219; TClass::UnregisterAddressInRepositoryvoid UnregisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:318; TClass::fMethodstd::atomic< TListOfFunctions * > fMethodDefinition TClass.h:207; TClass::RemoveClassDeclIdstatic void RemoveClassDeclId(TDictionary::DeclId_t id)Definition TClass.cxx:603; TClass::SetNewArrayvoid SetNewArray(R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:318140,load,load,318140,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"tListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;; 3086// if (altcl && normalizedName != altcl->GetName()); 3087// ::Fatal(""TClass::GetClass"",""The existing name (%s) for %s is different from the normalized name: %s\n"",; 3088// altcl->GetName(), name, normalizedName.c_str());; 3089// }; 3090 ; 3091 // We want to avoid auto-parsing due to intentionally missing dictionary for std::pair.; 3092 // However, we don't need this special treatement in rootcling (there is no auto-parsing); 3093 // and we want to make that the TClass for the pair goes through the regular creation; 3094 // mechanism (i.e. in rootcling they should be in kInterpreted state and never in; 3095 // kEmulated state) so that they have proper interpreter (ClassInfo) information which; 3096 // will be used to create the TProtoClass (if one is requested for the pair).; 3097 const bool ispair = TClassEdit::IsStdPair(normalizedName) && !IsFromRootCling();; 3098 const bool ispairbase = TClassEdit::IsStdPairBase(normalizedName) && !IsFromRootCling();; 3099 ; 3100 TClass *loadedcl = nullptr;; 3101 if (checkTable) {; 3102 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3103 } else {; 3104 if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {; 3105 // At this point more information has been loaded. This; 3106 // information might be pertinent to the normalization of the name.; 3107 // For example it might contain or be a typedef for which we don't; 3108 // have a forward declaration (eg. typedef to instance of class; 3109 // template with default parameters). So let's redo the normalization; 3110 // as the new information (eg. typedef in TROOT::GetListOfTypes) might; 3111 // lead to a different value.; 3112 {; 3113 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3114 TClassEdit::GetNormalizedName(normalizedName, name);; 3115 }; 3116 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3117 }; 3118 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:117312,load,loadedcl,117312,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,3,"['Load', 'load']","['LoadClassDefault', 'loadedcl']"
Performance,"tListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;; 3153// if (altcl && normalizedName != altcl->GetName()); 3154// ::Fatal(""TClass::GetClass"",""The existing name (%s) for %s is different from the normalized name: %s\n"",; 3155// altcl->GetName(), name, normalizedName.c_str());; 3156// }; 3157 ; 3158 // We want to avoid auto-parsing due to intentionally missing dictionary for std::pair.; 3159 // However, we don't need this special treatement in rootcling (there is no auto-parsing); 3160 // and we want to make that the TClass for the pair goes through the regular creation; 3161 // mechanism (i.e. in rootcling they should be in kInterpreted state and never in; 3162 // kEmulated state) so that they have proper interpreter (ClassInfo) information which; 3163 // will be used to create the TProtoClass (if one is requested for the pair).; 3164 const bool ispair = TClassEdit::IsStdPair(normalizedName) && !IsFromRootCling();; 3165 const bool ispairbase = TClassEdit::IsStdPairBase(normalizedName) && !IsFromRootCling();; 3166 ; 3167 TClass *loadedcl = nullptr;; 3168 if (checkTable) {; 3169 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3170 } else {; 3171 if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {; 3172 // At this point more information has been loaded. This; 3173 // information might be pertinent to the normalization of the name.; 3174 // For example it might contain or be a typedef for which we don't; 3175 // have a forward declaration (eg. typedef to instance of class; 3176 // template with default parameters). So let's redo the normalization; 3177 // as the new information (eg. typedef in TROOT::GetListOfTypes) might; 3178 // lead to a different value.; 3179 {; 3180 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3181 TClassEdit::GetNormalizedName(normalizedName, name);; 3182 }; 3183 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3184 }; 3185 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:120063,load,loadedcl,120063,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,3,"['Load', 'load']","['LoadClassDefault', 'loadedcl']"
Performance,"tListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooNumRunningInt::funcProxy to functions whose running integral is calculated; RooRealProxyRooNumRunningInt::xIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumCdf(const char* name, const char* title, RooAbsPdf& _pdf, RooRealVar& _x, const char* binningName = ""cache""); Construct a cumulative distribution function from given input p.d.f over observable x.; using a numeric sampling algorithm. Use binning named 'bname' to control sampling; granularity. RooNumCdf(const RooNumCdf& other, const char* name = 0); Copy constructor. ~RooNumCdf(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill cache using running integral cache elements calculate(); method with specification of cdf-specific boundary conditions. TObject* clone(const char* newname) const; { return new RooNumCdf(*this,newname); }. » Last changed: Mon Dec 7 13:48:29 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumCdf.html:34124,cache,cache,34124,root/html526/RooNumCdf.html,https://root.cern,https://root.cern/root/html526/RooNumCdf.html,4,['cache'],"['cache', 'cacheFunc']"
Performance,"tListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooNumRunningInt::funcProxy to functions whose running integral is calculated; RooRealProxyRooNumRunningInt::xIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumCdf(const char* name, const char* title, RooAbsPdf& _pdf, RooRealVar& _x, const char* binningName = ""cache""); Construct a cumulative distribution function from given input p.d.f over observable x.; using a numeric sampling algorithm. Use binning named 'bname' to control sampling; granularity. RooNumCdf(const RooNumCdf& other, const char* name = 0); Copy constructor. ~RooNumCdf(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill cache using running integral cache elements calculate(); method with specification of cdf-specific boundary conditions. TObject* clone(const char* newname) const; { return new RooNumCdf(*this,newname); }. » Last changed: Mon Jul 4 15:23:32 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumCdf.html:34948,cache,cache,34948,root/html530/RooNumCdf.html,https://root.cern,https://root.cern/root/html530/RooNumCdf.html,4,['cache'],"['cache', 'cacheFunc']"
Performance,"tListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooNumRunningInt::funcProxy to functions whose running integral is calculated; RooRealProxyRooNumRunningInt::xIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumCdf(const char* name, const char* title, RooAbsPdf& _pdf, RooRealVar& _x, const char* binningName = ""cache""); Construct a cumulative distribution function from given input p.d.f over observable x.; using a numeric sampling algorithm. Use binning named 'bname' to control sampling; granularity. RooNumCdf(const RooNumCdf& other, const char* name = 0); Copy constructor. ~RooNumCdf(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill cache using running integral cache elements calculate(); method with specification of cdf-specific boundary conditions. TObject* clone(const char* newname) const; { return new RooNumCdf(*this,newname); }. » Last changed: Thu Nov 3 20:08:49 2011 » Last generated: 2011-11-03 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumCdf.html:35327,cache,cache,35327,root/html532/RooNumCdf.html,https://root.cern,https://root.cern/root/html532/RooNumCdf.html,4,['cache'],"['cache', 'cacheFunc']"
