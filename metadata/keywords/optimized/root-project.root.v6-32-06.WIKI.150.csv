quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Safety,"/ after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. TNetSystem(Bool_t ftpowner = kTRUE); TNetSystem(const char* url, Bool_t ftpowner = kTRUE); virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHand",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetSystem.html:1917,safe,safe,1917,root/html528/TNetSystem.html,https://root.cern,https://root.cern/root/html528/TNetSystem.html,1,['safe'],['safe']
Safety,"/ after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectory",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetFile.html:1909,safe,safe,1909,root/html602/TNetFile.html,https://root.cern,https://root.cern/root/html602/TNetFile.html,2,['safe'],['safe']
Safety,"/ after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetSystem.html:1917,safe,safe,1917,root/html602/TNetSystem.html,https://root.cern,https://root.cern/root/html602/TNetSystem.html,2,['safe'],['safe']
Safety,"/ forget about preserving old statistics; 2746 bool resetStats = true;; 2747 Double_t stats[kNstat];; 2748 // reset statistics; 2749 if (resetStats); 2750 for (Int_t i=0;i<kNstat;i++) stats[i] = 0;; 2751 ; 2752 p2->PutStats(stats);; 2753 Double_t entries = fEntries;; 2754 // recalculate the statistics; 2755 if (resetStats) {; 2756 entries = p2->GetEffectiveEntries();; 2757 if (!useWeights) entries = TMath::Floor( entries + 0.5); // to avoid numerical rounding; 2758 p2->SetEntries( entries );; 2759 }; 2760 ; 2761 p2->SetEntries(entries);; 2762 ; 2763 return p2;; 2764}; 2765 ; 2766 ; 2767////////////////////////////////////////////////////////////////////////////////; 2768/// Project a 3-d histogram into a 2-d profile histograms depending; 2769/// on the option parameter; 2770/// option may contain a combination of the characters x,y,z; 2771/// option = ""xy"" return the x versus y projection into a TProfile2D histogram; 2772/// option = ""yx"" return the y versus x projection into a TProfile2D histogram; 2773/// option = ""xz"" return the x versus z projection into a TProfile2D histogram; 2774/// option = ""zx"" return the z versus x projection into a TProfile2D histogram; 2775/// option = ""yz"" return the y versus z projection into a TProfile2D histogram; 2776/// option = ""zy"" return the z versus y projection into a TProfile2D histogram; 2777/// NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal; 2778///; 2779/// option = ""o"" original axis range of the target axes will be; 2780/// kept, but only bins inside the selected range will be filled.; 2781///; 2782/// The projection is made for the selected bins only.; 2783/// To select a bin range along an axis, use TAxis::SetRange, eg; 2784/// h3.GetYaxis()->SetRange(23,56);; 2785///; 2786/// NOTE 1: The generated histogram is named th3name + ""_p"" + option; 2787/// eg if the TH3* h histogram is named ""myhist"", then; 2788/// h->Project3D(""xy""); produces a TProfile2D histogram named ""myhist_pxy"".; 2789/// The following s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:109119,avoid,avoid,109119,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['avoid'],['avoid']
Safety,"/ the architecture can now be set at runtime as an option; 247 ; 248 ; 249 if (fArchitectureString == ""GPU"" || fArchitectureString == ""CUDNN"") {; 250#ifdef R__HAS_TMVAGPU; 251 Log() << kINFO << ""Will now use the GPU architecture !"" << Endl;; 252#else // case TMVA does not support GPU; 253 Log() << kERROR << ""CUDA backend not enabled. Please make sure ""; 254 ""you have CUDA installed and it was successfully ""; 255 ""detected by CMAKE by using -Dtmva-gpu=On ""; 256 << Endl;; 257 fArchitectureString = ""CPU"";; 258 Log() << kINFO << ""Will now use instead the CPU architecture !"" << Endl;; 259#endif; 260 }; 261 ; 262 if (fArchitectureString == ""CPU"") {; 263#ifdef R__HAS_TMVACPU // TMVA has CPU BLAS and IMT support; 264 Log() << kINFO << ""Will now use the CPU architecture with BLAS and IMT support !"" << Endl;; 265#else // TMVA has no CPU BLAS or IMT support; 266 Log() << kINFO << ""Multi-core CPU backend not enabled. For better performances, make sure ""; 267 ""you have a BLAS implementation and it was successfully ""; 268 ""detected by CMake as well that the imt CMake flag is set.""; 269 << Endl;; 270 Log() << kINFO << ""Will use anyway the CPU architecture but with slower performance"" << Endl;; 271#endif; 272 }; 273 ; 274 // Input Layout; 275 ParseInputLayout();; 276 ParseBatchLayout();; 277 ; 278 // Loss function and output.; 279 fOutputFunction = EOutputFunction::kSigmoid;; 280 if (fAnalysisType == Types::kClassification) {; 281 if (fErrorStrategy == ""SUMOFSQUARES"") {; 282 fLossFunction = ELossFunction::kMeanSquaredError;; 283 }; 284 if (fErrorStrategy == ""CROSSENTROPY"") {; 285 fLossFunction = ELossFunction::kCrossEntropy;; 286 }; 287 fOutputFunction = EOutputFunction::kSigmoid;; 288 } else if (fAnalysisType == Types::kRegression) {; 289 if (fErrorStrategy != ""SUMOFSQUARES"") {; 290 Log() << kWARNING << ""For regression only SUMOFSQUARES is a valid ""; 291 << "" neural net error function. Setting error function to ""; 292 << "" SUMOFSQUARES now."" << Endl;; 293 }; 294 ; 295 fLossFunctio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:10029,detect,detected,10029,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['detect'],['detected']
Safety,"/ the same key for the same lib; 5632 if (gDebug > 3); 5633 Info(""ReadRootmapFile"", ""While processing %s, key %s was found to be already defined for %s"",; 5634 rootmapfile, keyname, lib_name.c_str());; 5635 }; 5636 } else {; 5637 fMapfile->SetValue(keyname, lib_name.c_str());; 5638 }; 5639 }; 5640 }; 5641 file.close();; 5642 return 0;; 5643}; 5644 ; 5645////////////////////////////////////////////////////////////////////////////////; 5646/// Create a resource table and read the (possibly) three resource files,; 5647/// i.e. `$ROOTSYS/etc/system<name>` (or `ROOTETCDIR/system<name>`), `$HOME/<name>`; 5648/// and `$PWD/<name>`. ROOT always reads "".rootrc"" (in TROOT::InitSystem()). You; 5649/// can read additional user defined resource files by creating additional TEnv; 5650/// objects. By setting the shell variable ROOTENV_NO_HOME=1 the reading of; 5651/// the `$HOME/<name>` resource file will be skipped. This might be useful in; 5652/// case the home directory resides on an automounted remote file system; 5653/// and one wants to avoid the file system from being mounted.; 5654 ; 5655void TCling::InitRootmapFile(const char *name); 5656{; 5657 assert(requiresRootMap(name) && ""We have a module!"");; 5658 ; 5659 if (!requiresRootMap(name)); 5660 return;; 5661 ; 5662 Bool_t ignore = fMapfile->IgnoreDuplicates(kFALSE);; 5663 ; 5664 fMapfile->SetRcName(name);; 5665 ; 5666 TString sname = ""system"";; 5667 sname += name;; 5668 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 5669 ; 5670 Int_t ret = ReadRootmapFile(s);; 5671 if (ret == -3) // old format; 5672 fMapfile->ReadFile(s, kEnvGlobal);; 5673 delete [] s;; 5674 if (!gSystem->Getenv(""ROOTENV_NO_HOME"")) {; 5675 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 5676 ret = ReadRootmapFile(s);; 5677 if (ret == -3) // old format; 5678 fMapfile->ReadFile(s, kEnvUser);; 5679 delete [] s;; 5680 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())) {; 5681 ret = ReadRootmapFile(name);; 5682 if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:220206,avoid,avoid,220206,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avoid'],['avoid']
Safety,"/ the tree; }; Adding a branch is often not possible because the tree is in a read-only file and you do not have permission to save the modified tree with the new branch. Even if you do have the permission, you risk loosing the original tree with an unsuccessful attempt to save the modification. Since trees are usually large, adding a branch could extend it over the 2GB limit. In this case, the attempt to write the tree fails, and the original data is may also be corrupted. In addition, adding a branch to a tree enlarges the tree and increases the amount of memory needed to read an entry, and therefore decreases the performance. For these reasons, ROOT offers the concept of friends for trees (and chains). We encourage you to use TTree::AddFriend rather than adding a branch manually.; 12.16.2 TTree::AddFriend; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way it is much like adding another branch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The TTree (tree) below has two friends (ft1 and ft2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friendâ€™s variables were in the original tree. To specify which tree to use in the Draw method, use the syntax:; <treeName>.<branchname>.<varname>; If the variablename is enough to identify uniquely th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:569929,risk,risk,569929,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['risk'],['risk']
Safety,"// Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFitResult.h; RooGlobalFunc.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TLegend.h; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:5361,recover,recovery,5361,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,1,['recover'],['recovery']
Safety,"// NOLINT: silence clang-tidy warnings; 819 Error(""Init"", ""cannot stat the file %s"", GetName());; 820 goto zombie;; 821 }; 822 ; 823 //*-* -------------Check if, in case of inconsistencies, we are requested to; 824 //*-* -------------attempt recovering the file; 825 Bool_t tryrecover = (gEnv->GetValue(""TFile.Recover"", 1) == 1) ? kTRUE : kFALSE;; 826 ; 827 //*-* -------------Check if we need to enable forward compatible with version; 828 //*-* -------------prior to v6.30; 829 if (gEnv->GetValue(""TFile.v630forwardCompatibility"", 0) == 1); 830 SetBit(k630forwardCompatibility);; 831 ; 832 //*-* -------------Read keys of the top directory; 833 if (fSeekKeys > fBEGIN && fEND <= size) {; 834 //normal case. Recover only if file has no keys; 835 TDirectoryFile::ReadKeys(kFALSE);; 836 gDirectory = this;; 837 if (!GetNkeys()) {; 838 if (tryrecover) {; 839 Recover(); // NOLINT: silence clang-tidy warnings; 840 } else {; 841 Error(""Init"", ""file %s has no keys"", GetName());; 842 goto zombie;; 843 }; 844 }; 845 } else if ((fBEGIN+nbytes == fEND) && (fEND == size)) {; 846 //the file might be open by another process and nothing written to the file yet; 847 Warning(""Init"",""file %s has no keys"", GetName());; 848 gDirectory = this;; 849 } else {; 850 //something had been written to the file. Trailer is missing, must recover; 851 if (fEND > size) {; 852 if (tryrecover) {; 853 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld, ""; 854 ""trying to recover"", GetName(), size, fEND);; 855 } else {; 856 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld"",; 857 GetName(), size, fEND);; 858 goto zombie;; 859 }; 860 } else {; 861 if (tryrecover) {; 862 Warning(""Init"",""file %s probably not closed, ""; 863 ""trying to recover"", GetName());; 864 } else {; 865 Warning(""Init"",""file %s probably not closed"", GetName());; 866 goto zombie;; 867 }; 868 }; 869 Int_t nrecov = Recover(); // NOLINT: silence clang-tidy warnings; 870 if (nrecov) {; 871 Warning(""Init"", ""successfully reco",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:30546,Recover,Recover,30546,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,['Recover'],['Recover']
Safety,"// TQObject Constructor.; 387/// Comment:; 388/// - In order to minimize memory allocation fListOfSignals and; 389/// fListOfConnections are allocated only if it is neccesary; 390/// - When fListOfSignals/fListOfConnections are empty they will; 391/// be deleted; 392 ; 393TQObject::TQObject(); 394{; 395 fListOfSignals = nullptr;; 396 fListOfConnections = nullptr;; 397 fSignalsBlocked = kFALSE;; 398}; 399 ; 400////////////////////////////////////////////////////////////////////////////////; 401/// TQObject Destructor.; 402/// - delete all connections and signal list; 403 ; 404TQObject::~TQObject(); 405{; 406 if (!gROOT) return;; 407 ; 408 Destroyed(); // emit ""Destroyed()"" signal; 409 ; 410 if (fListOfSignals) {; 411 fListOfSignals->Delete();; 412 SafeDelete(fListOfSignals); // delete list of signals; 413 }; 414 ; 415 // loop over all connections and remove references to this object; 416 if (fListOfConnections) {; 417 TIter next_connection(fListOfConnections);; 418 TQConnection *connection;; 419 ; 420 while ((connection = (TQConnection*)next_connection())) {; 421 TIter next_list(connection);; 422 TQConnectionList *list;; 423 while ((list = (TQConnectionList*)next_list())) {; 424 list->Remove(connection);; 425 if (list->IsEmpty()) SafeDelete(list);; 426 }; 427 }; 428 SafeDelete(fListOfConnections);; 429 }; 430}; 431 ; 432////////////////////////////////////////////////////////////////////////////////; 433/// Returns pointer to list of signals of this class.; 434 ; 435TList *TQObject::GetListOfClassSignals() const; 436{; 437 TQClass *qcl = nullptr;; 438 ; 439 qcl = dynamic_cast<TQClass*>(IsA());; 440 ; 441 return qcl ? qcl->fListOfSignals : nullptr; //!!; 442}; 443 ; 444////////////////////////////////////////////////////////////////////////////////; 445/// Collect class signal lists from class cls and all its; 446/// base-classes.; 447///; 448/// The recursive traversal is not performed for classes not; 449/// deriving from TQClass.; 450 ; 451void TQObject::CollectClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8cxx_source.html:13265,Safe,SafeDelete,13265,doc/master/TQObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html,3,['Safe'],['SafeDelete']
Safety,"/// - `Length$(formula )` : return the total number of element of the formula; 4215/// given as a parameter.; 4216/// - `Sum$(formula )` : return the sum of the value of the elements of the; 4217/// formula given as a parameter. For example the mean for all the elements in; 4218/// one entry can be calculated with: `Sum$(formula )/Length$(formula )`; 4219/// - `Min$(formula )` : return the minimum (within one TTree entry) of the value of the; 4220/// elements of the formula given as a parameter.; 4221/// - `Max$(formula )` : return the maximum (within one TTree entry) of the value of the; 4222/// elements of the formula given as a parameter.; 4223/// - `MinIf$(formula,condition)`; 4224/// - `MaxIf$(formula,condition)` : return the minimum (maximum) (within one TTree entry); 4225/// of the value of the elements of the formula given as a parameter; 4226/// if they match the condition. If no element matches the condition,; 4227/// the result is zero. To avoid the resulting peak at zero, use the; 4228/// pattern:; 4229/// ~~~ {.cpp}; 4230/// tree->Draw(""MinIf$(formula,condition)"",""condition"");; 4231/// ~~~; 4232/// which will avoid calculation `MinIf$` for the entries that have no match; 4233/// for the condition.; 4234/// - `Alt$(primary,alternate)` : return the value of ""primary"" if it is available; 4235/// for the current iteration otherwise return the value of ""alternate"".; 4236/// For example, with arr1[3] and arr2[2]; 4237/// ~~~ {.cpp}; 4238/// tree->Draw(""arr1+Alt$(arr2,0)"");; 4239/// ~~~; 4240/// will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; 4241/// Or with a variable size array arr3; 4242/// ~~~ {.cpp}; 4243/// tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; 4244/// ~~~; 4245/// will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); 4246/// As a comparison; 4247/// ~~~ {.cpp}; 4248/// tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; 4249/// ~~~; 4250/// will draw the sum arr3 for the index 0 to 2 only if the; 4251/// actual_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:169868,avoid,avoid,169868,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['avoid'],['avoid']
Safety,"/// This member function is called when a graph is clicked with the locator; 149///; 150/// If Left button clicked on one of the line end points, this point; 151/// follows the cursor until button is released.; 152///; 153/// if Middle button clicked, the line is moved parallel to itself; 154/// until the button is released.; 155 ; 156void TScatter::ExecuteEvent(Int_t event, Int_t px, Int_t py); 157{; 158 TVirtualGraphPainter *painter = TVirtualGraphPainter::GetPainter();; 159 if (painter) painter->ExecuteEventHelper(this->GetGraph(), event, px, py);; 160}; 161 ; 162 ; 163////////////////////////////////////////////////////////////////////////////////; 164/// Returns a pointer to the histogram used to draw the axis; 165 ; 166TH2F *TScatter::GetHistogram() const; 167{; 168 if (!fHistogram) {; 169 // do not add the histogram to gDirectory; 170 // use local TDirectory::TContect that will set temporarly gDirectory to a nullptr and; 171 // will avoid that histogram is added in the global directory; 172 TDirectory::TContext ctx(nullptr);; 173 double rwxmin, rwymin, rwxmax, rwymax;; 174 int npt = 50;; 175 fGraph->ComputeRange(rwxmin, rwymin, rwxmax, rwymax);; 176 double dx = (rwxmax-rwxmin)*fMargin;; 177 double dy = (rwymax-rwymin)*fMargin;; 178 auto h = new TH2F(TString::Format(""%s_h"",GetName()),GetTitle(),npt,rwxmin-dx,rwxmax+dx,npt,rwymin-dy,rwymax+dy);; 179 h->SetBit(TH1::kNoStats);; 180 h->SetDirectory(nullptr);; 181 h->Sumw2(kFALSE);; 182 const_cast<TScatter *>(this)->fHistogram = h;; 183 }; 184 return fHistogram;; 185}; 186 ; 187 ; 188////////////////////////////////////////////////////////////////////////////////; 189/// Get the scatter's x axis.; 190 ; 191TAxis *TScatter::GetXaxis() const; 192{; 193 auto h = GetHistogram();; 194 return h ? h->GetXaxis() : nullptr;; 195}; 196 ; 197 ; 198////////////////////////////////////////////////////////////////////////////////; 199/// Get the scatter's y axis.; 200 ; 201TAxis *TScatter::GetYaxis() const; 202{; 203 auto h = Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TScatter_8cxx_source.html:5400,avoid,avoid,5400,doc/master/TScatter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TScatter_8cxx_source.html,1,['avoid'],['avoid']
Safety,"/// by TNamed::Clone. TNamed::Clone uses the optional argument newname to set; 380/// a new name to the newly created object.; 381///; 382/// If autoadd is true and if the object class has a; 383/// DirectoryAutoAdd function, it will be called at the end of the; 384/// function with the parameter gDirectory. This usually means that; 385/// the object will be appended to the current ROOT directory.; 386 ; 387TObject *TDirectoryFile::CloneObject(const TObject *obj, Bool_t autoadd /* = kTRUE */); 388{; 389 // if no default ctor return immediately (error issued by New()); 390 char *pobj = (char*)obj->IsA()->New();; 391 if (!pobj) return nullptr;; 392 ; 393 Int_t baseOffset = obj->IsA()->GetBaseClassOffset(TObject::Class());; 394 if (baseOffset==-1) {; 395 // cl does not inherit from TObject.; 396 // Since this is not supported in this function, the only reason we could reach this code; 397 // is because something is screwed up in the ROOT code.; 398 Fatal(""CloneObject"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 399 obj->IsA()->GetName());; 400 }; 401 TObject *newobj = (TObject*)(pobj+baseOffset);; 402 ; 403 //create a buffer where the object will be streamed; 404 {; 405 // NOTE: do we still need to make this change to gFile?; 406 // NOTE: This can not be 'gDirectory=0' as at least roofit expect gDirectory to not be null; 407 // during the streaming ....; 408 TFile *filsav = gFile;; 409 gFile = nullptr;; 410 const Int_t bufsize = 10000;; 411 TBufferFile buffer(TBuffer::kWrite,bufsize);; 412 buffer.MapObject(obj); //register obj in map to handle self reference; 413 {; 414 Bool_t isRef = obj->TestBit(kIsReferenced);; 415 ((TObject*)obj)->ResetBit(kIsReferenced);; 416 ; 417 ((TObject*)obj)->Streamer(buffer);; 418 ; 419 if (isRef) ((TObject*)obj)->SetBit(kIsReferenced);; 420 }; 421 ; 422 // read new object from buffer; 423 buffer.SetReadMode();; 424 buffer.ResetMap();; 425 buffer.SetBufferOffset(0);; 426 buffer.MapObject(newobj); //register obj i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:13094,detect,detection,13094,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['detect'],['detection']
Safety,"/// gSystem->ProcessEvents() calls. But be aware, that such timer can interrupt any system call; 488/// (like malloc) and can lead to dead locks, especially in multi-threaded applications.; 489 ; 490void THttpServer::SetTimer(Long_t milliSec, Bool_t mode); 491{; 492 if (fTimer) {; 493 fTimer->Stop();; 494 fTimer.reset();; 495 }; 496 if (milliSec > 0) {; 497 if (fOwnThread) {; 498 Error(""SetTimer"", ""Server runs already in special thread, therefore no any timer can be created"");; 499 } else {; 500 fTimer = std::make_unique<THttpTimer>(milliSec, mode, *this);; 501 fTimer->TurnOn();; 502 }; 503 }; 504}; 505 ; 506////////////////////////////////////////////////////////////////////////////////; 507/// Creates special thread to process all requests, directed to http server; 508///; 509/// Should be used with care - only dedicated instance of TRootSniffer is allowed; 510/// By default THttpServer allows to access global lists pointers gROOT or gFile.; 511/// To be on the safe side, all kind of such access performed from the main thread.; 512/// Therefore usage of specialized thread means that no any global pointers will; 513/// be accessible by THttpServer; 514 ; 515void THttpServer::CreateServerThread(); 516{; 517 if (fOwnThread); 518 return;; 519 ; 520 SetTimer(0);; 521 fMainThrdId = 0;; 522 fOwnThread = true;; 523 ; 524 std::thread thrd([this] {; 525 int nempty = 0;; 526 while (fOwnThread && !fTerminated) {; 527 int nprocess = ProcessRequests();; 528 if (nprocess > 0); 529 nempty = 0;; 530 else; 531 nempty++;; 532 if (nempty > 1000) {; 533 nempty = 0;; 534 std::this_thread::sleep_for(std::chrono::milliseconds(1));; 535 }; 536 }; 537 });; 538 ; 539 fThrd = std::move(thrd);; 540}; 541 ; 542////////////////////////////////////////////////////////////////////////////////; 543/// Stop server thread; 544///; 545/// Normally called shortly before http server destructor; 546 ; 547void THttpServer::StopServerThread(); 548{; 549 if (!fOwnThread); 550 return;; 551 ; 552 fOwnThread ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:17003,safe,safe,17003,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['safe'],['safe']
Safety,"/// will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; 4064/// etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; 4065/// for regular expressions that will be checked) and as last a local file will; 4066/// be tried.; 4067/// Before opening a file via TNetFile a check is made to see if the URL; 4068/// specifies a local file. If that is the case the file will be opened; 4069/// via a normal TFile. To force the opening of a local file via a; 4070/// TNetFile use either TNetFile directly or specify as host ""localhost"".; 4071/// The netopt argument is only used by TNetFile. For the meaning of the; 4072/// options and other arguments see the constructors of the individual; 4073/// file classes. In case of error, it returns a nullptr.; 4074///; 4075/// For TFile implementations supporting asynchronous file open, see; 4076/// TFile::AsyncOpen(...), it is possible to request a timeout with the; 4077/// option <b>`TIMEOUT=<secs>`</b>: the timeout must be specified in seconds and; 4078/// it will be internally checked with granularity of one millisec.; 4079/// For remote files there is the option: <b>CACHEREAD</b> opens an existing; 4080/// file for reading through the file cache. The file will be downloaded to; 4081/// the cache and opened from there. If the download fails, it will be opened remotely.; 4082/// The file will be downloaded to the directory specified by SetCacheFileDir().; 4083///; 4084/// *The caller is responsible for deleting the pointer.*; 4085/// In READ mode, a nullptr is returned if the file does not exist or cannot be opened.; 4086/// In CREATE mode, a nullptr is returned if the file already exists or cannot be created.; 4087/// In RECREATE mode, a nullptr is returned if the file can not be created.; 4088/// In UPDATE mode, a nullptr is returned if the file cannot be created or opened.; 4089 ; 4090TFile *TFile::Open(const char *url, Option_t *options, const char *ftitle,; 4091 Int_t compress, Int_t netopt); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:148769,timeout,timeout,148769,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,3,"['TIMEOUT', 'timeout']","['TIMEOUT', 'timeout']"
Safety,"////////////////////////////////////////////////////////////////////////////////; 536/// Return absolute index to last object in array. Returns -1 in case; 537/// array is empty.; 538 ; 539Int_t TObjArray::GetAbsLast() const; 540{; 541 // For efficiency we need sometimes to update fLast so we have; 542 // to cast const away. Ugly, but making GetAbsLast() not const breaks; 543 // many other const functions.; 544 ; 545 R__COLLECTION_READ_LOCKGUARD(ROOT::gCoreMutex);; 546 ; 547 if (fLast == -2) {; 548 for (Int_t i = fSize-1; i >= 0; i--); 549 if (fCont[i]) {; 550 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 551 ((TObjArray*)this)->fLast = i;; 552 return fLast;; 553 }; 554 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 555 ((TObjArray*)this)->fLast = -1;; 556 }; 557 return fLast;; 558}; 559 ; 560////////////////////////////////////////////////////////////////////////////////; 561/// Return the number of objects in array (i.e. number of non-empty slots).; 562/// This is a thread-unsafe version of GetEntriesFast. Use it only if sure; 563/// it will not be invoked concurrently.; 564 ; 565Int_t TObjArray::GetEntriesUnsafe() const; 566{; 567 if (R__unlikely(fLast == -2)); 568 return GetEntriesFast();; 569 else; 570 return fLast + 1;; 571}; 572 ; 573////////////////////////////////////////////////////////////////////////////////; 574/// Return index of last object in array. Returns lowerBound-1 in case; 575/// array is empty.; 576 ; 577Int_t TObjArray::GetLast() const; 578{; 579 R__COLLECTION_READ_LOCKGUARD(ROOT::gCoreMutex);; 580 ; 581 return fLowerBound+GetAbsLast();; 582}; 583 ; 584////////////////////////////////////////////////////////////////////////////////; 585/// Return address of pointer obj. If obj is 0 returns address of container.; 586 ; 587TObject **TObjArray::GetObjectRef(const TObject *obj) const; 588{; 589 if (!obj); 590 return fCont;; 591 ; 592 R__COLLECTION_READ_LOCKGUARD(ROOT::gCoreMutex);; 593 ; 594 Int_t index = IndexOf(obj);; 595 return &fCont[in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObjArray_8cxx_source.html:18410,unsafe,unsafe,18410,doc/master/TObjArray_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObjArray_8cxx_source.html,1,['unsafe'],['unsafe']
Safety,"//////////////////////////////////////////////////////////////////////////; 888/// Return pointer to object identified by namecycle.; 889///; 890/// Properties:; 891/// - namecycle has the format name;cycle; 892/// - name = * is illegal, cycle = * is illegal; 893/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 894///; 895/// Examples:; 896/// | %Pattern | Explanation |; 897/// |----------|-------------|; 898/// | foo | get object named foo in memory if object is not in memory, try with highest cycle from file |; 899/// | foo;1 | get cycle 1 of foo on file |; 900///; 901/// The retrieved object should in principle derive from TObject.; 902/// If not, the function TDirectoryFile::Get<T> should be called.; 903/// However, this function will still work for a non-TObject, provided that; 904/// the calling application cast the return type to the correct type (which; 905/// is the actual type of the object).; 906///; 907/// ### The Get<T> Method; 908/// The method Get<T> offers better protection and avoids the need for any; 909/// cast:; 910/// ~~~{.cpp}; 911/// auto objPtr = directory->Get<MyClass>(""some object"");; 912/// if (objPtr) { ... the object exist and inherits from MyClass ... }; 913/// ~~~; 914///; 915/// ### Very important note about inheritance; 916/// In case the class of this object derives from TObject but not; 917/// as a first inheritance, one must use dynamic_cast<>().; 918///; 919/// #### Example 1 - Normal case:; 920///; 921/// class MyClass : public TObject, public AnotherClass; 922///; 923/// then on return, one can adopt a C style cast:; 924///; 925/// auto objPtr = (MyClass*)directory->Get(""some object of MyClass"");; 926///; 927/// #### Example 2 - Special case:; 928///; 929/// class MyClass : public AnotherClass, public TObject; 930///; 931/// then on return, one must do:; 932///; 933/// auto objPtr = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));; 934///; 935/// Of course, dynamic_cast<> can also be used in the exa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:30491,avoid,avoids,30491,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['avoid'],['avoids']
Safety,"/////////////////////////////////////////////////////////////////////////; 104 ; 105namespace ROOT {; 106 class TClassRec {; 107 public:; 108 TClassRec(TClassRec *next) :; 109 fName(nullptr), fId(0), fDict(nullptr), fInfo(nullptr), fProto(nullptr), fNext(next); 110 {}; 111 ; 112 ~TClassRec() {; 113 // TClassTable::fgIdMap->Remove(r->fInfo->name());; 114 delete [] fName;; 115 delete fProto;; 116 delete fNext;; 117 }; 118 ; 119 char *fName;; 120 Version_t fId;; 121 Int_t fBits;; 122 DictFuncPtr_t fDict;; 123 const std::type_info *fInfo;; 124 TProtoClass *fProto;; 125 TClassRec *fNext;; 126 };; 127 ; 128 class TClassAlt {; 129 public:; 130 TClassAlt(const char*alternate, const char *normName, TClassAlt *next) :; 131 fName(alternate), fNormName(normName), fNext(next); 132 {}; 133 ; 134 ~TClassAlt() {; 135 // Nothing more to delete.; 136 }; 137 ; 138 const char *fName; // Do not own; 139 const char *fNormName; // Do not own; 140 std::unique_ptr<TClassAlt> fNext;; 141 };; 142 ; 143#define R__USE_STD_MAP; 144 class TMapTypeToClassRec {; 145#if defined R__USE_STD_MAP; 146 // This wrapper class allow to avoid putting #include <map> in the; 147 // TROOT.h header file.; 148 public:; 149 typedef std::map<std::string, TClassRec*> IdMap_t;; 150 typedef IdMap_t::key_type key_type;; 151 typedef IdMap_t::const_iterator const_iterator;; 152 typedef IdMap_t::size_type size_type;; 153#ifdef R__WIN32; 154 // Window's std::map does NOT defined mapped_type; 155 typedef TClassRec* mapped_type;; 156#else; 157 typedef IdMap_t::mapped_type mapped_type;; 158#endif; 159 ; 160 private:; 161 IdMap_t fMap;; 162 ; 163 public:; 164 void Add(const key_type &key, mapped_type &obj) {; 165 fMap[key] = obj;; 166 }; 167 ; 168 mapped_type Find(const key_type &key) const {; 169 IdMap_t::const_iterator iter = fMap.find(key);; 170 mapped_type cl = nullptr;; 171 if (iter != fMap.end()) cl = iter->second;; 172 return cl;; 173 }; 174 ; 175 void Remove(const key_type &key) { fMap.erase(key); }; 176 ; 177 void Prin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:4347,avoid,avoid,4347,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,2,['avoid'],['avoid']
Safety,"//////////////////////////////////////////////////////////////////////; 752/// Loop on all branch baskets. Drop all baskets from memory except readbasket.; 753/// If the option contains ""all"", drop all baskets including; 754/// read- and write-baskets (unless they are not stored individually on disk).; 755/// The option ""all"" also lead to DropBaskets being called on the sub-branches.; 756 ; 757void TBranch::DropBaskets(Option_t* options); 758{; 759 bool all = false;; 760 if (options && options[0]) {; 761 TString opt = options;; 762 opt.ToLower();; 763 if (opt.Contains(""all"")) all = true;; 764 }; 765 ; 766 TBasket *basket;; 767 Int_t nbaskets = fBaskets.GetEntriesFast();; 768 ; 769 if ( (fNBaskets>1) || all ) {; 770 //slow case; 771 for (Int_t i=0;i<nbaskets;i++) {; 772 basket = (TBasket*)fBaskets.UncheckedAt(i);; 773 if (!basket) continue;; 774 if ((i == fReadBasket || i == fWriteBasket) && !all) continue;; 775 // if the basket is not yet on file but already has event in it; 776 // we must continue to avoid dropping the basket (and thus losing data); 777 if (fBasketBytes[i]==0 && basket->GetNevBuf() > 0) continue;; 778 basket->DropBuffers();; 779 --fNBaskets;; 780 fBaskets.RemoveAt(i);; 781 if (basket == fCurrentBasket) {; 782 fCurrentBasket = nullptr;; 783 fFirstBasketEntry = -1;; 784 fNextBasketEntry = -1;; 785 }; 786 delete basket;; 787 }; 788 ; 789 // process subbranches; 790 if (all) {; 791 TObjArray *lb = GetListOfBranches();; 792 Int_t nb = lb->GetEntriesFast();; 793 for (Int_t j = 0; j < nb; j++) {; 794 TBranch* branch = (TBranch*) lb->UncheckedAt(j);; 795 if (!branch) continue;; 796 branch->DropBaskets(""all"");; 797 }; 798 }; 799 } else {; 800 //fast case; 801 if (nbaskets > 0) {; 802 Int_t i = fBaskets.GetLast();; 803 basket = (TBasket*)fBaskets.UncheckedAt(i);; 804 if (basket && fBasketBytes[i]!=0) {; 805 basket->DropBuffers();; 806 if (basket == fCurrentBasket) {; 807 fCurrentBasket = nullptr;; 808 fFirstBasketEntry = -1;; 809 fNextBasketEntry = -1;; 810 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:27473,avoid,avoid,27473,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['avoid'],['avoid']
Safety,"///////////////////////////////////////////////////////////////////; 803/// Returns next class from sorted class table. Don't use this iterator; 804/// while modifying the class table. The class table can be modified; 805/// when making calls like TClass::GetClass(), etc.; 806 ; 807char *TClassTable::Next(); 808{; 809 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 810 ; 811 if (fgCursor < fgTally) {; 812 TClassRec *r = fgSortedTable[fgCursor++];; 813 return r->fName;; 814 }; 815 ; 816 return nullptr;; 817}; 818 ; 819////////////////////////////////////////////////////////////////////////////////; 820/// Print the class table. Before printing the table is sorted; 821/// alphabetically.; 822 ; 823void TClassTable::PrintTable(); 824{; 825 if (fgTally == 0 || !fgTable); 826 return;; 827 ; 828 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 829 ; 830 SortTable();; 831 ; 832 int n = 0, ninit = 0;; 833 ; 834 Printf(""\nDefined classes"");; 835 Printf(""class version bits initialized"");; 836 Printf(""================================================================"");; 837 UInt_t last = fgTally;; 838 for (UInt_t i = 0; i < last; i++) {; 839 TClassRec *r = fgSortedTable[i];; 840 if (!r) break;; 841 n++;; 842 // Do not use TClass::GetClass to avoid any risk of autoloading.; 843 if (gROOT->GetListOfClasses()->FindObject(r->fName)) {; 844 ninit++;; 845 Printf(""%-35s %6d %7d Yes"", r->fName, r->fId, r->fBits);; 846 } else; 847 Printf(""%-35s %6d %7d No"", r->fName, r->fId, r->fBits);; 848 }; 849 Printf(""----------------------------------------------------------------"");; 850 Printf(""Total classes: %4d initialized: %4d"", n, ninit);; 851 Printf(""================================================================\n"");; 852}; 853 ; 854////////////////////////////////////////////////////////////////////////////////; 855/// Sort the class table by ascending class ID's.; 856 ; 857void TClassTable::SortTable(); 858{; 859 // Internal routine.; 860 ; 861 if (!fgSorted) {; 862 dele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:27039,avoid,avoid,27039,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,4,"['avoid', 'risk']","['avoid', 'risk']"
Safety,"//////////////////////////////////////////////////////////////////; 2917/// Set double buffer mode ON or OFF.; 2918 ; 2919void TPad::SetDoubleBuffer(Int_t mode); 2920{; 2921 if (fCanvas) fCanvas->SetDoubleBuffer(mode);; 2922}; 2923 ; 2924////////////////////////////////////////////////////////////////////////////////; 2925/// Set selected.; 2926 ; 2927void TPad::SetSelected(TObject *obj); 2928{; 2929 if (fCanvas) fCanvas->SetSelected(obj);; 2930}; 2931 ; 2932////////////////////////////////////////////////////////////////////////////////; 2933/// Update pad.; 2934 ; 2935void TPad::Update(); 2936{; 2937 if (fCanvas) fCanvas->Update();; 2938}; 2939 ; 2940////////////////////////////////////////////////////////////////////////////////; 2941/// Asynchronous pad update.; 2942/// In case of web-based canvas triggers update of the canvas on the client side,; 2943/// but does not wait that real update is completed. Avoids blocking of caller thread.; 2944/// Have to be used if called from other web-based widget to avoid logical dead-locks.; 2945/// In case of normal canvas just canvas->Update() is performed.; 2946 ; 2947void TPad::UpdateAsync(); 2948{; 2949 if (fCanvas) fCanvas->UpdateAsync();; 2950}; 2951 ; 2952////////////////////////////////////////////////////////////////////////////////; 2953/// Get frame.; 2954 ; 2955TFrame *TPad::GetFrame(); 2956{; 2957 if (!fPrimitives) fPrimitives = new TList;; 2958 TFrame *frame = (TFrame*)GetListOfPrimitives()->FindObject(fFrame);; 2959 if (!frame) frame = (TFrame*)GetListOfPrimitives()->FindObject(""TFrame"");; 2960 fFrame = frame;; 2961 if (!fFrame) {; 2962 if (!frame) fFrame = new TFrame(0,0,1,1);; 2963 Int_t framecolor = GetFrameFillColor();; 2964 if (!framecolor) framecolor = GetFillColor();; 2965 fFrame->SetFillColor(framecolor);; 2966 fFrame->SetFillStyle(GetFrameFillStyle());; 2967 fFrame->SetLineColor(GetFrameLineColor());; 2968 fFrame->SetLineStyle(GetFrameLineStyle());; 2969 fFrame->SetLineWidth(GetFrameLineWidth());; 297",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:93002,avoid,avoid,93002,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['avoid'],['avoid']
Safety,"//////////////////////////////////////////////////////////////////; 3132/// Compute total size of all persistent elements of the class; 3133 ; 3134void TStreamerInfo::ComputeSize(); 3135{; 3136 if (this == fClass->GetCurrentStreamerInfo()) {; 3137 if (fClass->GetState() >= TClass::kInterpreted || fClass->fIsSyntheticPair) {; 3138 fSize = fClass->GetClassSize();; 3139 return;; 3140 }; 3141 }; 3142 ; 3143 TStreamerElement *element = (TStreamerElement*)fElements->Last();; 3144 //faster and more precise to use last element offset +size; 3145 //on 64 bit machines, offset may be forced to be a multiple of 8 bytes; 3146 fSize = element ? element->GetOffset() + element->GetSize() : 0;; 3147 if (fNVirtualInfoLoc > 0 && (fVirtualInfoLoc[0]+sizeof(TStreamerInfo*)) >= (ULong_t)fSize) {; 3148 fSize = fVirtualInfoLoc[0] + sizeof(TStreamerInfo*);; 3149 }; 3150 ; 3151 // On some platform and in some case of layout non-basic data types needs; 3152 // to be aligned. So let's be on the safe side and align on the size of; 3153 // the pointers. (Question: is that the right thing on x32 ABI ?); 3154 constexpr size_t kSizeOfPtr = sizeof(void*);; 3155 if ((fSize % kSizeOfPtr) != 0 && !fClass->IsSyntheticPair()) {; 3156 fSize = fSize - (fSize % kSizeOfPtr) + kSizeOfPtr;; 3157 }; 3158}; 3159 ; 3160////////////////////////////////////////////////////////////////////////////////; 3161/// Recursively mark streamer infos for writing to a file.; 3162///; 3163/// Will force this TStreamerInfo to the file and also; 3164/// all the dependencies.; 3165/// If argument force > 0 the loop on class dependencies is forced.; 3166/// This function is called when streaming a class that contains; 3167/// a null pointer. In this case, the TStreamerInfo for the class; 3168/// with the null pointer must be written to the file and also all; 3169/// the TStreamerInfo of all the classes referenced by the class.; 3170/// We must be given a file to write to.; 3171 ; 3172void TStreamerInfo::ForceWriteInfo(TFile* file, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:126912,safe,safe,126912,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['safe'],['safe']
Safety,"/////////////////////////////////////////////////////////////////; 377/// Pad destructor.; 378 ; 379TPad::~TPad(); 380{; 381 if (ROOT::Detail::HasBeenDeleted(this)) return;; 382 Close();; 383 CloseToolTip(fTip);; 384 DeleteToolTip(fTip);; 385 auto primitives = fPrimitives;; 386 // In some cases, fPrimitives has the kMustCleanup bit set which will lead; 387 // its destructor to call RecursiveRemove and since this pad is still; 388 // likely to be (indirectly) in the list of cleanups, we must set; 389 // fPrimitives to nullptr to avoid TPad::RecursiveRemove from calling; 390 // a member function of a partially destructed object.; 391 fPrimitives = nullptr;; 392 delete primitives;; 393 SafeDelete(fExecs);; 394 delete fViewer3D;; 395 ; 396 // Required since we overload TObject::Hash.; 397 ROOT::CallRecursiveRemoveIfNeeded(*this);; 398 if (this == gPad); 399 gPad = nullptr;; 400}; 401 ; 402////////////////////////////////////////////////////////////////////////////////; 403/// Add an object to list of primitives with speicified draw option; 404/// When \par modified set to kTRUE (default) pad will be marked as modified; 405/// Let avoid usage of gPad when drawing object(s) in canvas or in subpads.; 406///; 407/// ~~~{.cpp}; 408/// auto c1 = new TCanvas(""c1"",""Canvas with subpoads"", 600, 600);; 409/// c1->Divide(2,2);; 410///; 411/// for (Int_t n = 1; n <= 4; ++n) {; 412/// auto h1 = new TH1I(TString::Format(""hist_%d"",n), ""Random hist"", 100, -5, 5);; 413/// h1->FillRandom(""gaus"", 2000 + n*1000);; 414/// c1->GetPad(n)->Add(h1);; 415/// }; 416/// ~~~; 417 ; 418void TPad::Add(TObject *obj, Option_t *opt, Bool_t modified); 419{; 420 if (!obj); 421 return;; 422 ; 423 if (!fPrimitives); 424 fPrimitives = new TList;; 425 ; 426 obj->SetBit(kMustCleanup);; 427 ; 428 fPrimitives->Add(obj, opt);; 429 ; 430 if (modified); 431 Modified();; 432}; 433 ; 434////////////////////////////////////////////////////////////////////////////////; 435/// Add an object as first in list of primitives ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:12083,avoid,avoid,12083,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////; 2322/// Set the maximum of the graph.; 2323 ; 2324void TGraph::SetMaximum(Double_t maximum); 2325{; 2326 fMaximum = maximum;; 2327 GetHistogram()->SetMaximum(maximum);; 2328}; 2329 ; 2330////////////////////////////////////////////////////////////////////////////////; 2331/// Set the minimum of the graph.; 2332 ; 2333void TGraph::SetMinimum(Double_t minimum); 2334{; 2335 fMinimum = minimum;; 2336 GetHistogram()->SetMinimum(minimum);; 2337}; 2338 ; 2339////////////////////////////////////////////////////////////////////////////////; 2340/// Set x and y values for point number i.; 2341 ; 2342void TGraph::SetPoint(Int_t i, Double_t x, Double_t y); 2343{; 2344 if (i < 0) return;; 2345 if (fHistogram) SetBit(kResetHisto);; 2346 ; 2347 if (i >= fMaxSize) {; 2348 Double_t **ps = ExpandAndCopy(i + 1, fNpoints);; 2349 CopyAndRelease(ps, 0, 0, 0);; 2350 }; 2351 if (i >= fNpoints) {; 2352 // points above i can be not initialized; 2353 // set zero up to i-th point to avoid redefinition; 2354 // of this method in descendant classes; 2355 FillZero(fNpoints, i + 1);; 2356 fNpoints = i + 1;; 2357 }; 2358 fX[i] = x;; 2359 fY[i] = y;; 2360 if (gPad) gPad->Modified();; 2361}; 2362 ; 2363////////////////////////////////////////////////////////////////////////////////; 2364/// Set x value for point i.; 2365 ; 2366void TGraph::SetPointX(Int_t i, Double_t x); 2367{; 2368 SetPoint(i, x, GetPointY(i));; 2369}; 2370 ; 2371////////////////////////////////////////////////////////////////////////////////; 2372/// Set y value for point i.; 2373 ; 2374void TGraph::SetPointY(Int_t i, Double_t y); 2375{; 2376 SetPoint(i, GetPointX(i), y);; 2377}; 2378 ; 2379////////////////////////////////////////////////////////////////////////////////; 2380/// Set graph name.; 2381void TGraph::SetName(const char *name); 2382{; 2383 fName = name;; 2384 if (fHistogram) fHistogram->SetName(name);; 2385}; 2386 ; 2387/////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:84220,avoid,avoid,84220,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////; 3604 ; 3605//---- signals -----------------------------------------------------------------; 3606 ; 3607static struct Signalmap_t {; 3608 int fCode;; 3609 SigHandler_t fHandler;; 3610 struct sigaction *fOldHandler;; 3611 const char *fSigName;; 3612} gSignalMap[kMAXSIGNALS] = { // the order of the signals should be identical; 3613 { SIGBUS, nullptr, nullptr, ""bus error"" }, // to the one in TSysEvtHandler.h; 3614 { SIGSEGV, nullptr, nullptr, ""segmentation violation"" },; 3615 { SIGSYS, nullptr, nullptr, ""bad argument to system call"" },; 3616 { SIGPIPE, nullptr, nullptr, ""write on a pipe with no one to read it"" },; 3617 { SIGILL, nullptr, nullptr, ""illegal instruction"" },; 3618 { SIGABRT, nullptr, nullptr, ""abort"" },; 3619 { SIGQUIT, nullptr, nullptr, ""quit"" },; 3620 { SIGINT, nullptr, nullptr, ""interrupt"" },; 3621 { SIGWINCH, nullptr, nullptr, ""window size change"" },; 3622 { SIGALRM, nullptr, nullptr, ""alarm clock"" },; 3623 { SIGCHLD, nullptr, nullptr, ""death of a child"" },; 3624 { SIGURG, nullptr, nullptr, ""urgent data arrived on an I/O channel"" },; 3625 { SIGFPE, nullptr, nullptr, ""floating point exception"" },; 3626 { SIGTERM, nullptr, nullptr, ""termination signal"" },; 3627 { SIGUSR1, nullptr, nullptr, ""user-defined signal 1"" },; 3628 { SIGUSR2, nullptr, nullptr, ""user-defined signal 2"" }; 3629};; 3630 ; 3631 ; 3632////////////////////////////////////////////////////////////////////////////////; 3633/// Call the signal handler associated with the signal.; 3634 ; 3635static void sighandler(int sig); 3636{; 3637 for (int i= 0; i < kMAXSIGNALS; i++) {; 3638 if (gSignalMap[i].fCode == sig) {; 3639 (*gSignalMap[i].fHandler)((ESignals)i);; 3640 return;; 3641 }; 3642 }; 3643}; 3644 ; 3645////////////////////////////////////////////////////////////////////////////////; 3646/// Handle and dispatch signals.; 3647 ; 3648void TUnixSystem::DispatchSignals(ESignals sig); 3649{; 3650 switch (sig) {; 3651 case kSigAlarm:; 365",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:115411,abort,abort,115411,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['abort'],['abort']
Safety,"////////////////////////////////////////////////////////; 4061/// Perform a \f$ \chi^2 \f$ fit to given histogram. By default the fit is executed through the MINUIT; 4062/// commands MIGRAD, HESSE in succession; 4063///; 4064/// The following named arguments are supported; 4065///; 4066/// <table>; 4067/// <tr><th> <th> Options to control construction of chi2; 4068/// <tr><td> `Extended(bool flag)` <td> **Only applicable when fitting a RooAbsPdf**. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight.; 4069/// This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; 4070/// - If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events; 4071/// (in RooFit jargon, ""if the pdf can be extended"").; 4072/// - Passing `Extended(true)` when the the pdf makes no prediction on the expected number of events will result in error messages,; 4073/// and the chi2 will fall back to the total data weight to scale the normalized pdf.; 4074/// - There are cases where the fit **must** be done in extended mode. This happens for example when you have a RooAddPdf; 4075/// where the coefficients represent component yields. If the fit is not extended, these coefficients will not be; 4076/// well-defined, as the RooAddPdf always normalizes itself. If you pass `Extended(false)` in such a case, an error will be; 4077/// printed and you'll most likely get garbage results.; 4078/// <tr><td> `Range(const char* name)` <td> Fit only data inside range with given name; 4079/// <tr><td> `Range(double lo, double hi)` <td> Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; 4080/// Multiple comma separated range names can be specified.; 4081/// <tr><td> `NumCPU(int num)` <td> Parallelize NLL calculation on num CPUs; 4082/// <tr><td> `Optimize(bool flag)` <td> Activate constant ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:176434,predict,prediction,176434,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['predict'],['prediction']
Safety,"//////////////////////////////////////////////////////; 3161/// Recursively mark streamer infos for writing to a file.; 3162///; 3163/// Will force this TStreamerInfo to the file and also; 3164/// all the dependencies.; 3165/// If argument force > 0 the loop on class dependencies is forced.; 3166/// This function is called when streaming a class that contains; 3167/// a null pointer. In this case, the TStreamerInfo for the class; 3168/// with the null pointer must be written to the file and also all; 3169/// the TStreamerInfo of all the classes referenced by the class.; 3170/// We must be given a file to write to.; 3171 ; 3172void TStreamerInfo::ForceWriteInfo(TFile* file, Bool_t force); 3173{; 3174 if (!file || fNumber < 0) {; 3175 return;; 3176 }; 3177 // Get the given file's list of streamer infos marked for writing.; 3178 TArrayC* cindex = file->GetClassIndex();; 3179 //the test below testing fArray[fNumber]>1 is to avoid a recursivity; 3180 //problem in some cases like:; 3181 // class aProblemChild: public TNamed {; 3182 // aProblemChild *canBeNull;; 3183 // };; 3184 if ( // -- Done if already marked, and we are not forcing, or forcing is blocked.; 3185 (cindex->fArray[fNumber] && !force) || // Streamer info is already marked, and not forcing, or; 3186 (cindex->fArray[fNumber] > 1) // == 2 means ignore forcing to prevent infinite recursion.; 3187 ) {; 3188 return;; 3189 }; 3190 ; 3191 auto recurseIntoContent = [file, force](TClass *contentClass); 3192 {; 3193 TVirtualStreamerInfo* si = 0;; 3194 if (contentClass->Property() & kIsAbstract) {; 3195 // If the class of the element is abstract, register the; 3196 // TStreamerInfo only if it has already been built.; 3197 // Otherwise call cl->GetStreamerInfo() would generate an; 3198 // incorrect StreamerInfo.; 3199 si = contentClass->GetCurrentStreamerInfo();; 3200 } else {; 3201 si = contentClass->GetStreamerInfo();; 3202 }; 3203 if (si) {; 3204 si->ForceWriteInfo(file, force);; 3205 }; 3206 };; 3207 ; 3208 // We do ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:128183,avoid,avoid,128183,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['avoid'],['avoid']
Safety,"/////////////////////////////////////////////////////; 802/// Pointing to the first element of the container.; 803 ; 804TIter &TIter::Begin(); 805{; 806 fIterator->Reset();; 807 fIterator->Next();; 808 return *this;; 809}; 810 ; 811////////////////////////////////////////////////////////////////////////////////; 812/// Pointing to the element after the last - to a nullptr value in our case.; 813 ; 814TIter TIter::End(); 815{; 816 return TIter(static_cast<TIterator*>(nullptr));; 817}; 818 ; 819////////////////////////////////////////////////////////////////////////////////; 820/// Return an empty collection for use with nullptr TRangeCast; 821 ; 822const TCollection &ROOT::Internal::EmptyCollection(); 823{; 824 static TObjArray sEmpty;; 825 return sEmpty;; 826}; 827 ; 828////////////////////////////////////////////////////////////////////////////////; 829/// Return true if 'cl' inherits from 'base'.; 830 ; 831bool ROOT::Internal::ContaineeInheritsFrom(TClass *cl, TClass *base); 832{; 833 return cl->InheritsFrom(base);; 834}; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kMaxIntconstexpr Int_t kMaxIntDefinition RtypesCore.h:105; Version_tshort Version_tDefinition RtypesCore.h:65; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBrowser.h; TBuffer.h; TClass.h; gCollectionMutexTVirtualMutex * gCollectionMutexDefinition TCollection.cxx:52; TCollection.h; gCollectionMutexR__EXTERN TVirtualMutex * gCollectionMutexDefinition TCollection.h:45; R__FOR_EACH#define R__FOR_EACH(type, proc)Definition TCollection.h:373; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8cxx_source.html:27687,Safe,SafeDelete,27687,doc/master/TCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html,2,['Safe'],['SafeDelete']
Safety,"//////////////////////////////////////////////////; 503/// Destructor; 504 ; 505TGeoManager::~TGeoManager(); 506{; 507 if (gGeoManager != this); 508 gGeoManager = this;; 509 fIsGeomCleaning = kTRUE;; 510 ; 511 if (gROOT->GetListOfFiles()) { // in case this function is called from TROOT destructor; 512 gROOT->GetListOfGeometries()->Remove(this);; 513 gROOT->GetListOfBrowsables()->Remove(this);; 514 }; 515 // TSeqCollection *brlist = gROOT->GetListOfBrowsers();; 516 // TIter next(brlist);; 517 // TBrowser *browser = 0;; 518 // while ((browser=(TBrowser*)next())) browser->RecursiveRemove(this);; 519 ClearThreadsMap();; 520 ClearThreadData();; 521 delete TGeoBuilder::Instance(this);; 522 if (fBits); 523 delete[] fBits;; 524 SafeDelete(fNodes);; 525 SafeDelete(fTopNode);; 526 if (fOverlaps) {; 527 fOverlaps->Delete();; 528 SafeDelete(fOverlaps);; 529 }; 530 if (fRegions) {; 531 fRegions->Delete();; 532 SafeDelete(fRegions);; 533 }; 534 if (fMaterials) {; 535 fMaterials->Delete();; 536 SafeDelete(fMaterials);; 537 }; 538 SafeDelete(fElementTable);; 539 if (fMedia) {; 540 fMedia->Delete();; 541 SafeDelete(fMedia);; 542 }; 543 if (fHashVolumes) {; 544 fHashVolumes->Clear(""nodelete"");; 545 SafeDelete(fHashVolumes);; 546 }; 547 if (fHashGVolumes) {; 548 fHashGVolumes->Clear(""nodelete"");; 549 SafeDelete(fHashGVolumes);; 550 }; 551 if (fHashPNE) {; 552 fHashPNE->Delete();; 553 SafeDelete(fHashPNE);; 554 }; 555 if (fArrayPNE) {; 556 delete fArrayPNE;; 557 }; 558 if (fVolumes) {; 559 fVolumes->Delete();; 560 SafeDelete(fVolumes);; 561 }; 562 if (fShapes) {; 563 fShapes->Delete();; 564 SafeDelete(fShapes);; 565 }; 566 if (fPhysicalNodes) {; 567 fPhysicalNodes->Delete();; 568 SafeDelete(fPhysicalNodes);; 569 }; 570 if (fMatrices) {; 571 fMatrices->Delete();; 572 SafeDelete(fMatrices);; 573 }; 574 if (fTracks) {; 575 fTracks->Delete();; 576 SafeDelete(fTracks);; 577 }; 578 SafeDelete(fUniqueVolumes);; 579 if (fPdgNames) {; 580 fPdgNames->Delete();; 581 SafeDelete(fPdgNames);; 582 }; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:21703,Safe,SafeDelete,21703,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,"/////////////////////////////////////////////////; 9883/// [Control function to draw a TH2Poly as a scatter plot.](\ref HP20a); 9884 ; 9885void THistPainter::PaintTH2PolyScatterPlot(Option_t *); 9886{; 9887 ; 9888 //Do not highlight the histogram, if its part was selected.; 9889 if (gPad->PadInHighlightMode() && gPad->GetSelected() != fH); 9890 return;; 9891 ; 9892 Int_t k, loop, marker=0;; 9893 Double_t z, xk,xstep, yk, ystep, xp, yp;; 9894 Double_t scale = 1;; 9895 Double_t zmin = fH->GetMinimum();; 9896 Double_t zmax = fH->GetMaximum();; 9897 if (Hoption.Logz) {; 9898 if (zmax > 0) {; 9899 if (zmin <= 0) zmin = TMath::Min((Double_t)1, (Double_t)0.001*zmax);; 9900 zmin = TMath::Log10(zmin);; 9901 zmax = TMath::Log10(zmax);; 9902 } else {; 9903 return;; 9904 }; 9905 }; 9906 Double_t dz = zmax - zmin;; 9907 scale = (kNMAX-1)/dz;; 9908 ; 9909 ; 9910 // use an independent instance of a random generator; 9911 // instead of gRandom to avoid conflicts and; 9912 // to get same random numbers when drawing the same histogram; 9913 TRandom2 random;; 9914 ; 9915 TH2PolyBin *b;; 9916 ; 9917 TIter next(((TH2Poly*)fH)->GetBins());; 9918 TObject *obj, *poly;; 9919 ; 9920 Double_t maxarea = 0, a;; 9921 while ((obj=next())) {; 9922 b = (TH2PolyBin*)obj;; 9923 a = b->GetArea();; 9924 if (a>maxarea) maxarea = a;; 9925 }; 9926 ; 9927 next.Reset();; 9928 ; 9929 while ((obj=next())) {; 9930 b = (TH2PolyBin*)obj;; 9931 poly = b->GetPolygon();; 9932 z = b->GetContent();; 9933 if (z < zmin) z = zmin;; 9934 if (z > zmax) z = zmax;; 9935 if (Hoption.Logz) {; 9936 if (z > 0) z = TMath::Log10(z) - zmin;; 9937 } else {; 9938 z -= zmin;; 9939 }; 9940 k = Int_t((z*scale)*(b->GetArea()/maxarea));; 9941 xk = b->GetXMin();; 9942 yk = b->GetYMin();; 9943 xstep = b->GetXMax()-xk;; 9944 ystep = b->GetYMax()-yk;; 9945 ; 9946 // Paint the TGraph bins.; 9947 if (poly->IsA() == TGraph::Class()) {; 9948 TGraph *g = (TGraph*)poly;; 9949 if (k <= 0 || z <= 0) continue;; 9950 loop = 0;; 9951 while (loop<k) {; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:356849,avoid,avoid,356849,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['avoid'],['avoid']
Safety,"///////////////////////////////////////////////; 686/// Set this collection to be the globally accessible collection.; 687 ; 688void TCollection::SetCurrentCollection(); 689{; 690 fgCurrentCollection = this;; 691}; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Set up for garbage collection.; 695 ; 696void TCollection::StartGarbageCollection(); 697{; 698 R__LOCKGUARD2(gCollectionMutex);; 699 if (!fgGarbageCollection) {; 700 fgGarbageCollection = new TObjectTable;; 701 fgEmptyingGarbage = kFALSE;; 702 fgGarbageStack = 0;; 703 }; 704 fgGarbageStack++;; 705}; 706 ; 707////////////////////////////////////////////////////////////////////////////////; 708/// Do the garbage collection.; 709 ; 710void TCollection::EmptyGarbageCollection(); 711{; 712 R__LOCKGUARD2(gCollectionMutex);; 713 if (fgGarbageStack > 0) fgGarbageStack--;; 714 if (fgGarbageCollection && fgGarbageStack == 0 && fgEmptyingGarbage == kFALSE) {; 715 fgEmptyingGarbage = kTRUE;; 716 fgGarbageCollection->Delete();; 717 fgEmptyingGarbage = kFALSE;; 718 SafeDelete(fgGarbageCollection);; 719 }; 720}; 721 ; 722////////////////////////////////////////////////////////////////////////////////; 723/// Add to the list of things to be cleaned up.; 724 ; 725void TCollection::GarbageCollect(TObject *obj); 726{; 727 {; 728 R__LOCKGUARD2(gCollectionMutex);; 729 if (fgGarbageCollection) {; 730 if (!fgEmptyingGarbage) {; 731 fgGarbageCollection->Add(obj);; 732 return;; 733 }; 734 }; 735 }; 736 delete obj;; 737}; 738 ; 739////////////////////////////////////////////////////////////////////////////////; 740/// Set whether this collection is the owner (enable==true); 741/// of its content. If it is the owner of its contents,; 742/// these objects will be deleted whenever the collection itself; 743/// is deleted. The objects might also be deleted or destructed when Clear; 744/// is called (depending on the collection).; 745 ; 746void TCollection::SetOwner(Bool_t enable); 747{; 74",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8cxx_source.html:24085,Safe,SafeDelete,24085,doc/master/TCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,"///////////////////////////////////////////////; 70/// Internal function to initialize data members.; 71/// Use TF1::Copy instead of Clone.; 72 ; 73void TF1Convolution::InitializeDataMembers(TF1* function1, TF1* function2, Bool_t useFFT); 74{; 75 if (function1) {; 76 // functions must be 1d- if not flag an error; 77 if (function1->GetNdim() != 1); 78 Error(""InitializeDataMembers"",""function1 %s is not of dimension 1 "",function1->GetName());; 79 //TF1 * fnew1 = (TF1*) function1->IsA()->New();; 80 // since function1 is a TF1 (cannot be a derived class) we can instantiate it directly; 81 fFunction1 = std::make_unique<TF1> ();; 82 function1->Copy(*fFunction1);; 83 }; 84 if (function2) {; 85 if (function2->GetNdim() != 1); 86 Error(""InitializeDataMembers"",""function2 %s is not of dimension 1 "",function2->GetName());; 87 //TF1 * fnew2 = (TF1*) function2->IsA()->New();; 88 fFunction2 = std::make_unique<TF1>();; 89 function2->Copy(*fFunction2);; 90 }; 91 if (fFunction1 == nullptr|| fFunction2 == nullptr); 92 Fatal(""InitializeDataMembers"",""Invalid functions - Abort"");; 93 ; 94 // Set kNotGlobal bit; 95 fFunction1->SetBit(TF1::kNotGlobal, kTRUE);; 96 fFunction2->SetBit(TF1::kNotGlobal, kTRUE);; 97 ; 98 // use by default range of first function; 99 fFunction1->GetRange(fXmin, fXmax);; 100 // when using FFT add by default an extra 10% on each side; 101 if (useFFT) {; 102 SetExtraRange(fgExtraRangeFraction);; 103 }; 104 fNofParams1 = fFunction1->GetNpar();; 105 fNofParams2 = fFunction2->GetNpar();; 106 fParams1 = std::vector<Double_t>(fNofParams1);; 107 fParams2 = std::vector<Double_t>(fNofParams2);; 108 fCstIndex = (fFunction1->GetParNumber(""Constant"") == -1); 109 ? -1; 110 : fFunction2->GetParNumber(""Constant""); // TODO: add dropConstantParam flag?; 111 fFlagFFT = useFFT;; 112 fFlagGraph = false;; 113 fNofPoints = 10000;; 114 ; 115 fParNames.reserve( fNofParams1 + fNofParams2);; 116 for (int i=0; i<fNofParams1; i++); 117 {; 118 fParams1[i] = fFunction1 -> GetParameter(i);; 119 f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1Convolution_8cxx_source.html:3526,Abort,Abort,3526,doc/master/TF1Convolution_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html,1,['Abort'],['Abort']
Safety,"/////////////////////////////////////////////; 2169/// Close the pipe.; 2170 ; 2171int TUnixSystem::ClosePipe(FILE *pipe); 2172{; 2173 return ::pclose(pipe);; 2174}; 2175 ; 2176////////////////////////////////////////////////////////////////////////////////; 2177/// Get process id.; 2178 ; 2179int TUnixSystem::GetPid(); 2180{; 2181 return ::getpid();; 2182}; 2183 ; 2184////////////////////////////////////////////////////////////////////////////////; 2185/// Exit the application.; 2186 ; 2187void TUnixSystem::Exit(int code, Bool_t mode); 2188{; 2189 // Insures that the files and sockets are closed before any library is unloaded; 2190 // and before emptying CINT.; 2191 TROOT::ShutDown();; 2192 ; 2193 if (mode); 2194 ::exit(code);; 2195 else; 2196 ::_exit(code);; 2197}; 2198 ; 2199////////////////////////////////////////////////////////////////////////////////; 2200/// Abort the application.; 2201 ; 2202void TUnixSystem::Abort(int); 2203{; 2204 IgnoreSignal(kSigAbort);; 2205 ::abort();; 2206}; 2207 ; 2208 ; 2209#ifdef R__MACOSX; 2210/// Use CoreSymbolication to retrieve the stacktrace.; 2211#include <mach/mach.h>; 2212extern ""C"" {; 2213 // Adapted from https://github.com/mountainstorm/CoreSymbolication; 2214 // Under the hood the framework basically just calls through to a set of C++ libraries; 2215 typedef struct {; 2216 void* csCppData;; 2217 void* csCppObj;; 2218 } CSTypeRef;; 2219 typedef CSTypeRef CSSymbolicatorRef;; 2220 typedef CSTypeRef CSSourceInfoRef;; 2221 typedef CSTypeRef CSSymbolOwnerRef;; 2222 typedef CSTypeRef CSSymbolRef;; 2223 ; 2224 CSSymbolicatorRef CSSymbolicatorCreateWithPid(pid_t pid);; 2225 CSSymbolRef CSSymbolicatorGetSymbolWithAddressAtTime(CSSymbolicatorRef cs, vm_address_t addr, uint64_t time);; 2226 CSSourceInfoRef CSSymbolicatorGetSourceInfoWithAddressAtTime(CSSymbolicatorRef cs, vm_address_t addr, uint64_t time);; 2227 const char* CSSymbolGetName(CSSymbolRef sym);; 2228 CSSymbolOwnerRef CSSymbolGetSymbolOwner(CSSymbolRef sym);; 2229 const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:67959,Abort,Abort,67959,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,2,"['Abort', 'abort']","['Abort', 'abort']"
Safety,"//////////////////////////////////////////; 4047///; 4048/// Return value of x (in range xmin,xmax) at which function equals yval.; 4049/// (Calculation is performed with Brent root finding algorithm); 4050 ; 4051double RooAbsReal::findRoot(RooRealVar& x, double xmin, double xmax, double yval); 4052{; 4053 double result(0) ;; 4054 RooBrentRootFinder(RooRealBinding(*this,x)).findRoot(result,xmin,xmax,yval) ;; 4055 return result ;; 4056}; 4057 ; 4058 ; 4059 ; 4060////////////////////////////////////////////////////////////////////////////////; 4061/// Perform a \f$ \chi^2 \f$ fit to given histogram. By default the fit is executed through the MINUIT; 4062/// commands MIGRAD, HESSE in succession; 4063///; 4064/// The following named arguments are supported; 4065///; 4066/// <table>; 4067/// <tr><th> <th> Options to control construction of chi2; 4068/// <tr><td> `Extended(bool flag)` <td> **Only applicable when fitting a RooAbsPdf**. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight.; 4069/// This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; 4070/// - If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events; 4071/// (in RooFit jargon, ""if the pdf can be extended"").; 4072/// - Passing `Extended(true)` when the the pdf makes no prediction on the expected number of events will result in error messages,; 4073/// and the chi2 will fall back to the total data weight to scale the normalized pdf.; 4074/// - There are cases where the fit **must** be done in extended mode. This happens for example when you have a RooAddPdf; 4075/// where the coefficients represent component yields. If the fit is not extended, these coefficients will not be; 4076/// well-defined, as the RooAddPdf always normalizes itself. If you pass `Extended(false)` in such a case, an error will be; 4077/// printed and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:175987,predict,predicted,175987,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['predict'],['predicted']
Safety,"////////////////////////////////////////; 425/// parse option string for ANN methods; 426/// default settings (should be defined in theOption string); 427///; 428/// format and syntax of option string: ""3000:N:N+2:N-3:6""; 429///; 430/// where:; 431/// - 3000 - number of training cycles (epochs); 432/// - N - number of nodes in first hidden layer, where N is the number; 433/// of discriminating variables used (note that the first ANN; 434/// layer necessarily has N nodes, and hence is not given).; 435/// - N+2 - number of nodes in 2nd hidden layer (2 nodes more than; 436/// number of variables); 437/// - N-3 - number of nodes in 3rd hidden layer (3 nodes less than; 438/// number of variables); 439/// - 6 - 6 nodes in last (4th) hidden layer (note that the last ANN; 440/// layer in MVA has 2 nodes, each one for signal and background; 441/// classes); 442 ; 443vector<Int_t>* TMVA::Tools::ParseANNOptionString( TString theOptions, Int_t nvar,; 444 vector<Int_t>* nodes ); 445{; 446 TList* list = TMVA::Tools::ParseFormatLine( theOptions, "":"" );; 447 ; 448 ; 449 // sanity check; 450 if (list->GetSize() < 1) {; 451 Log() << kFATAL << ""<ParseANNOptionString> unrecognized option string: "" << theOptions << Endl;; 452 }; 453 ; 454 // add number of cycles; 455 nodes->push_back( atoi( ((TObjString*)list->At(0))->GetString() ) );; 456 ; 457 Int_t a;; 458 if (list->GetSize() > 1) {; 459 for (Int_t i=1; i<list->GetSize(); i++) {; 460 TString s = ((TObjString*)list->At(i))->GetString();; 461 s.ToUpper();; 462 if (s(0) == 'N') {; 463 if (s.Length() > 1) nodes->push_back( nvar + atoi(&s[1]) );; 464 else nodes->push_back( nvar );; 465 }; 466 else if ((a = atoi( s )) > 0) nodes->push_back( atoi(s ) );; 467 else {; 468 Log() << kFATAL << ""<ParseANNOptionString> unrecognized option string: "" << theOptions << Endl;; 469 }; 470 }; 471 }; 472 ; 473 return nodes;; 474}; 475 ; 476////////////////////////////////////////////////////////////////////////////////; 477/// check quality of splining by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:15594,sanity check,sanity check,15594,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['sanity check'],['sanity check']
Safety,"/////////////////////////////////; 54 ; 55void TF1NormSum::InitializeDataMembers(const std::vector<TF1 *> &functions, const std::vector<Double_t> &coeffs,; 56 Double_t scale); 57{; 58 ; 59 fScale = scale;; 60 fCoeffs = coeffs;; 61 fNOfFunctions = functions.size();; 62 fCstIndexes = std::vector < Int_t > (fNOfFunctions);; 63 fParNames = std::vector<TString> (fNOfFunctions);; 64 fParNames.reserve(3*fNOfFunctions); // enlarge capacity for function parameters; 65 ; 66 // fill fFunctions with unique_ptr's; 67 fFunctions = std::vector<std::unique_ptr<TF1>>(functions.size());; 68 for (unsigned int n = 0; n < fNOfFunctions; n++) {; 69 // use TF1::Copy and not clone to copy the TF1 pointers; 70 // and use IsA()::New() in case we have base class pointers; 71 TF1 * f = (TF1*) functions[n]->IsA()->New();; 72 functions[n]->Copy(*f);; 73 fFunctions[n] = std::unique_ptr<TF1>(f);; 74 ; 75 ; 76 if (!fFunctions[n]); 77 Fatal(""InitializeDataMembers"", ""Invalid input function -- abort"");; 78 ; 79 fFunctions[n]->SetBit(TF1::kNotGlobal, kTRUE);; 80 }; 81 ; 82 for (unsigned int n=0; n < fNOfFunctions; n++); 83 {; 84 int npar = fFunctions[n] -> GetNpar();; 85 fCstIndexes[n] = fFunctions[n] -> GetParNumber(""Constant"");//return -1 if there is no constant parameter; 86 fParNames[n] = TString::Format(""Coeff%d"",n);; 87 if (fCstIndexes[n]!= -1) //if there exists a constant parameter; 88 {; 89 fFunctions[n] -> FixParameter(fCstIndexes[n], 1.); // fixes the parameters called ""Constant"" to 1; 90 for (int i=0; i<npar; i++) // go through all the parameter to; 91 {; 92 if (i==fCstIndexes[n]) continue; // go to next step if this is the constant parameter; 93 fParNames.push_back( fFunctions[n] -> GetParName(i) );; 94 }; 95 }; 96 else {; 97 for (int i=0; i < npar; i++) //go through all the parameter to; 98 {; 99 fParNames.push_back( fFunctions[n] -> GetParName(i) );; 100 }; 101 }; 102 //normalize the functions if it is not already done (do at the end so constant parameter is not zero); 103 if (!fFunctions",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1NormSum_8cxx_source.html:2745,abort,abort,2745,doc/master/TF1NormSum_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1NormSum_8cxx_source.html,1,['abort'],['abort']
Safety,"////////////////////////////; 100/// Selector destructor.; 101 ; 102TSelector::~TSelector(); 103{; 104 delete fOutput;; 105}; 106 ; 107////////////////////////////////////////////////////////////////////////////////; 108/// Abort processing. If what = kAbortProcess, the Process() loop will be; 109/// aborted. If what = kAbortFile, the current file in a chain will be; 110/// aborted and the processing will continue with the next file, if there; 111/// is no next file then Process() will be aborted. Abort() can also be; 112/// called from Begin(), SlaveBegin(), Init() and Notify(). After abort; 113/// the SlaveTerminate() and Terminate() are always called. The abort flag; 114/// can be checked in these methods using GetAbort().; 115 ; 116void TSelector::Abort(const char *why, EAbort what); 117{; 118 fAbort = what;; 119 TString mess = ""Abort"";; 120 if (fAbort == kAbortProcess); 121 mess = ""AbortProcess"";; 122 else if (fAbort == kAbortFile); 123 mess = ""AbortFile"";; 124 ; 125 Info(mess, ""%s"", why);; 126}; 127 ; 128////////////////////////////////////////////////////////////////////////////////; 129/// The code in filename is loaded (interpreted or compiled, see below),; 130/// filename must contain a valid class implementation derived from TSelector.; 131///; 132/// If filename is of the form file.C, the file will be interpreted.; 133/// If filename is of the form file.C++, the file file.C will be compiled; 134/// and dynamically loaded. The corresponding binary file and shared; 135/// library will be deleted at the end of the function.; 136/// If filename is of the form file.C+, the file file.C will be compiled; 137/// and dynamically loaded. At next call, if file.C is older than file.o; 138/// and file.so, the file.C is not compiled, only file.so is loaded.; 139///; 140/// The static function returns a pointer to a TSelector object; 141 ; 142TSelector *TSelector::GetSelector(const char *filename); 143{; 144 // If the filename does not contain ""."" assume class is compil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:4871,Abort,Abort,4871,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,4,['Abort'],"['Abort', 'AbortFile', 'AbortProcess']"
Safety,"///////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:72634,recover,recovered,72634,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['recover'],['recovered']
Safety,"////////////////////; 3873/// Set interval timer to time-out in ms milliseconds.; 3874 ; 3875int TUnixSystem::UnixSetitimer(Long_t ms); 3876{; 3877 struct itimerval itv;; 3878 itv.it_value.tv_sec = 0;; 3879 itv.it_value.tv_usec = 0;; 3880 itv.it_interval.tv_sec = 0;; 3881 itv.it_interval.tv_usec = 0;; 3882 if (ms > 0) {; 3883 itv.it_value.tv_sec = time_t(ms / 1000);; 3884 itv.it_value.tv_usec = time_t((ms % 1000) * 1000);; 3885 }; 3886 int st = setitimer(ITIMER_REAL, &itv, nullptr);; 3887 if (st == -1); 3888 ::SysError(""TUnixSystem::UnixSetitimer"", ""setitimer"");; 3889 return st;; 3890}; 3891 ; 3892//---- file descriptors --------------------------------------------------------; 3893 ; 3894////////////////////////////////////////////////////////////////////////////////; 3895/// Wait for events on the file descriptors specified in the readready and; 3896/// writeready masks or for timeout (in milliseconds) to occur. Returns; 3897/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 3898/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 3899/// the errno has been reset and the method can be called again.; 3900 ; 3901int TUnixSystem::UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 3902 Long_t timeout); 3903{; 3904 int retcode;; 3905 ; 3906 fd_set *rd = (readready) ? (fd_set*)readready->GetBits() : nullptr;; 3907 fd_set *wr = (writeready) ? (fd_set*)writeready->GetBits() : nullptr;; 3908 ; 3909 if (timeout >= 0) {; 3910 struct timeval tv;; 3911 tv.tv_sec = Int_t(timeout / 1000);; 3912 tv.tv_usec = (timeout % 1000) * 1000;; 3913 retcode = select(nfds, rd, wr, nullptr, &tv);; 3914 } else {; 3915 retcode = select(nfds, rd, wr, nullptr, nullptr);; 3916 }; 3917 if (retcode == -1) {; 3918 if (GetErrno() == EINTR) {; 3919 ResetErrno(); // errno is not self reseting; 3920 return -2;; 3921 }; 3922 if (GetErrno() == EBADF); 3923 return -3;; 3924 return -1;; 3925 }; 3926 ; 3927 return retcode;; 3928}; 3929 ; 3930//---- direct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:124880,timeout,timeout,124880,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['timeout'],['timeout']
Safety,"/////////////////; 4019/// Get the object file extension.; 4020 ; 4021const char *TSystem::GetObjExt() const; 4022{; 4023 return fObjExt;; 4024}; 4025 ; 4026////////////////////////////////////////////////////////////////////////////////; 4027/// Set the location where ACLiC will create libraries and use as; 4028/// a scratch area. If unset, libraries will be created at the same; 4029/// location than the script.; 4030///; 4031/// \param build_dir the name of the build directory; 4032/// \param isflat If false (default), then the libraries are actually stored; 4033/// in sub-directories of 'build_dir' including the full pathname; 4034/// of the script. If the script is located at `/full/path/name/macro.C`; 4035/// the library will be located at `build_dir+/full/path/name/macro_C.so`; 4036/// If 'isflat' is true, then no subdirectory is created and the library; 4037/// is created directly in the directory 'build_dir'. Note that in this; 4038/// mode there is a risk than 2 script of the same in different source; 4039/// directory will over-write each other.; 4040/// \note This `build_dir` can also be controlled via `ACLiC.BuildDir` in; 4041/// your `.rootrc`.; 4042 ; 4043void TSystem::SetBuildDir(const char *build_dir, Bool_t isflat); 4044{; 4045 fBuildDir = build_dir;; 4046 if (isflat); 4047 fAclicProperties |= kFlatBuildDir;; 4048 else; 4049 fAclicProperties &= ~kFlatBuildDir;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// FlagsDebug should contain the options to pass to the C++ compiler; 4054/// in order to compile the library in debug mode.; 4055 ; 4056void TSystem::SetFlagsDebug(const char *flags); 4057{; 4058 fFlagsDebug = flags;; 4059}; 4060 ; 4061////////////////////////////////////////////////////////////////////////////////; 4062/// FlagsOpt should contain the options to pass to the C++ compiler; 4063/// in order to compile the library in optimized mode.; 4064 ; 4065void TSystem::SetFlagsOpt(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:137342,risk,risk,137342,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['risk'],['risk']
Safety,"///////////////; 2161/// Open a pipe.; 2162 ; 2163FILE *TUnixSystem::OpenPipe(const char *command, const char *mode); 2164{; 2165 return ::popen(command, mode);; 2166}; 2167 ; 2168////////////////////////////////////////////////////////////////////////////////; 2169/// Close the pipe.; 2170 ; 2171int TUnixSystem::ClosePipe(FILE *pipe); 2172{; 2173 return ::pclose(pipe);; 2174}; 2175 ; 2176////////////////////////////////////////////////////////////////////////////////; 2177/// Get process id.; 2178 ; 2179int TUnixSystem::GetPid(); 2180{; 2181 return ::getpid();; 2182}; 2183 ; 2184////////////////////////////////////////////////////////////////////////////////; 2185/// Exit the application.; 2186 ; 2187void TUnixSystem::Exit(int code, Bool_t mode); 2188{; 2189 // Insures that the files and sockets are closed before any library is unloaded; 2190 // and before emptying CINT.; 2191 TROOT::ShutDown();; 2192 ; 2193 if (mode); 2194 ::exit(code);; 2195 else; 2196 ::_exit(code);; 2197}; 2198 ; 2199////////////////////////////////////////////////////////////////////////////////; 2200/// Abort the application.; 2201 ; 2202void TUnixSystem::Abort(int); 2203{; 2204 IgnoreSignal(kSigAbort);; 2205 ::abort();; 2206}; 2207 ; 2208 ; 2209#ifdef R__MACOSX; 2210/// Use CoreSymbolication to retrieve the stacktrace.; 2211#include <mach/mach.h>; 2212extern ""C"" {; 2213 // Adapted from https://github.com/mountainstorm/CoreSymbolication; 2214 // Under the hood the framework basically just calls through to a set of C++ libraries; 2215 typedef struct {; 2216 void* csCppData;; 2217 void* csCppObj;; 2218 } CSTypeRef;; 2219 typedef CSTypeRef CSSymbolicatorRef;; 2220 typedef CSTypeRef CSSourceInfoRef;; 2221 typedef CSTypeRef CSSymbolOwnerRef;; 2222 typedef CSTypeRef CSSymbolRef;; 2223 ; 2224 CSSymbolicatorRef CSSymbolicatorCreateWithPid(pid_t pid);; 2225 CSSymbolRef CSSymbolicatorGetSymbolWithAddressAtTime(CSSymbolicatorRef cs, vm_address_t addr, uint64_t time);; 2226 CSSourceInfoRef CSSymbolicator",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:67906,Abort,Abort,67906,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['Abort'],['Abort']
Safety,///////////////; 3029/// Get the shared libraries directory in the installation. Static utility function.; 3030 ; 3031const TString& TROOT::GetSharedLibDir() {; 3032#if defined(R__WIN32); 3033 return TROOT::GetBinDir();; 3034#else; 3035 return TROOT::GetLibDir();; 3036#endif; 3037}; 3038 ; 3039////////////////////////////////////////////////////////////////////////////////; 3040/// Get the include directory in the installation. Static utility function.; 3041 ; 3042const TString& TROOT::GetIncludeDir() {; 3043 // Avoid returning a reference to a temporary because of the conversion; 3044 // between std::string and TString.; 3045 const static TString includedir = ROOT::FoundationUtils::GetIncludeDir();; 3046 return includedir;; 3047}; 3048 ; 3049////////////////////////////////////////////////////////////////////////////////; 3050/// Get the sysconfig directory in the installation. Static utility function.; 3051 ; 3052const TString& TROOT::GetEtcDir() {; 3053 // Avoid returning a reference to a temporary because of the conversion; 3054 // between std::string and TString.; 3055 const static TString etcdir = ROOT::FoundationUtils::GetEtcDir();; 3056 return etcdir;; 3057}; 3058 ; 3059////////////////////////////////////////////////////////////////////////////////; 3060/// Get the data directory in the installation. Static utility function.; 3061 ; 3062const TString& TROOT::GetDataDir() {; 3063#ifdef ROOTDATADIR; 3064 if (IgnorePrefix()) {; 3065#endif; 3066 return GetRootSys();; 3067#ifdef ROOTDATADIR; 3068 } else {; 3069 const static TString rootdatadir = ROOTDATADIR;; 3070 return rootdatadir;; 3071 }; 3072#endif; 3073}; 3074 ; 3075////////////////////////////////////////////////////////////////////////////////; 3076/// Get the documentation directory in the installation. Static utility function.; 3077 ; 3078const TString& TROOT::GetDocDir() {; 3079#ifdef ROOTDOCDIR; 3080 if (IgnorePrefix()) {; 3081#endif; 3082 return GetRootSys();; 3083#ifdef ROOTDOCDIR; 3084 } else {; 3,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:115909,Avoid,Avoid,115909,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['Avoid'],['Avoid']
Safety,///////////////; 3033/// Get the shared libraries directory in the installation. Static utility function.; 3034 ; 3035const TString& TROOT::GetSharedLibDir() {; 3036#if defined(R__WIN32); 3037 return TROOT::GetBinDir();; 3038#else; 3039 return TROOT::GetLibDir();; 3040#endif; 3041}; 3042 ; 3043////////////////////////////////////////////////////////////////////////////////; 3044/// Get the include directory in the installation. Static utility function.; 3045 ; 3046const TString& TROOT::GetIncludeDir() {; 3047 // Avoid returning a reference to a temporary because of the conversion; 3048 // between std::string and TString.; 3049 const static TString includedir = ROOT::FoundationUtils::GetIncludeDir();; 3050 return includedir;; 3051}; 3052 ; 3053////////////////////////////////////////////////////////////////////////////////; 3054/// Get the sysconfig directory in the installation. Static utility function.; 3055 ; 3056const TString& TROOT::GetEtcDir() {; 3057 // Avoid returning a reference to a temporary because of the conversion; 3058 // between std::string and TString.; 3059 const static TString etcdir = ROOT::FoundationUtils::GetEtcDir();; 3060 return etcdir;; 3061}; 3062 ; 3063////////////////////////////////////////////////////////////////////////////////; 3064/// Get the data directory in the installation. Static utility function.; 3065 ; 3066const TString& TROOT::GetDataDir() {; 3067#ifdef ROOTDATADIR; 3068 if (IgnorePrefix()) {; 3069#endif; 3070 return GetRootSys();; 3071#ifdef ROOTDATADIR; 3072 } else {; 3073 const static TString rootdatadir = ROOTDATADIR;; 3074 return rootdatadir;; 3075 }; 3076#endif; 3077}; 3078 ; 3079////////////////////////////////////////////////////////////////////////////////; 3080/// Get the documentation directory in the installation. Static utility function.; 3081 ; 3082const TString& TROOT::GetDocDir() {; 3083#ifdef ROOTDOCDIR; 3084 if (IgnorePrefix()) {; 3085#endif; 3086 return GetRootSys();; 3087#ifdef ROOTDOCDIR; 3088 } else {; 3,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:116156,Avoid,Avoid,116156,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['Avoid'],['Avoid']
Safety,"//////////////; 503/// Destructor; 504 ; 505TGeoManager::~TGeoManager(); 506{; 507 if (gGeoManager != this); 508 gGeoManager = this;; 509 fIsGeomCleaning = kTRUE;; 510 ; 511 if (gROOT->GetListOfFiles()) { // in case this function is called from TROOT destructor; 512 gROOT->GetListOfGeometries()->Remove(this);; 513 gROOT->GetListOfBrowsables()->Remove(this);; 514 }; 515 // TSeqCollection *brlist = gROOT->GetListOfBrowsers();; 516 // TIter next(brlist);; 517 // TBrowser *browser = 0;; 518 // while ((browser=(TBrowser*)next())) browser->RecursiveRemove(this);; 519 ClearThreadsMap();; 520 ClearThreadData();; 521 delete TGeoBuilder::Instance(this);; 522 if (fBits); 523 delete[] fBits;; 524 SafeDelete(fNodes);; 525 SafeDelete(fTopNode);; 526 if (fOverlaps) {; 527 fOverlaps->Delete();; 528 SafeDelete(fOverlaps);; 529 }; 530 if (fRegions) {; 531 fRegions->Delete();; 532 SafeDelete(fRegions);; 533 }; 534 if (fMaterials) {; 535 fMaterials->Delete();; 536 SafeDelete(fMaterials);; 537 }; 538 SafeDelete(fElementTable);; 539 if (fMedia) {; 540 fMedia->Delete();; 541 SafeDelete(fMedia);; 542 }; 543 if (fHashVolumes) {; 544 fHashVolumes->Clear(""nodelete"");; 545 SafeDelete(fHashVolumes);; 546 }; 547 if (fHashGVolumes) {; 548 fHashGVolumes->Clear(""nodelete"");; 549 SafeDelete(fHashGVolumes);; 550 }; 551 if (fHashPNE) {; 552 fHashPNE->Delete();; 553 SafeDelete(fHashPNE);; 554 }; 555 if (fArrayPNE) {; 556 delete fArrayPNE;; 557 }; 558 if (fVolumes) {; 559 fVolumes->Delete();; 560 SafeDelete(fVolumes);; 561 }; 562 if (fShapes) {; 563 fShapes->Delete();; 564 SafeDelete(fShapes);; 565 }; 566 if (fPhysicalNodes) {; 567 fPhysicalNodes->Delete();; 568 SafeDelete(fPhysicalNodes);; 569 }; 570 if (fMatrices) {; 571 fMatrices->Delete();; 572 SafeDelete(fMatrices);; 573 }; 574 if (fTracks) {; 575 fTracks->Delete();; 576 SafeDelete(fTracks);; 577 }; 578 SafeDelete(fUniqueVolumes);; 579 if (fPdgNames) {; 580 fPdgNames->Delete();; 581 SafeDelete(fPdgNames);; 582 }; 583 if (fGDMLMatrices) {; 584 fGDMLM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:21739,Safe,SafeDelete,21739,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,"//////////////; 87/// Default selector ctor.; 88 ; 89TSelector::TSelector() : TObject(); 90{; 91 fStatus = 0;; 92 fAbort = kContinue;; 93 fObject = nullptr;; 94 fInput = nullptr;; 95 fOutput = new TSelectorList;; 96 fOutput->SetOwner();; 97}; 98 ; 99////////////////////////////////////////////////////////////////////////////////; 100/// Selector destructor.; 101 ; 102TSelector::~TSelector(); 103{; 104 delete fOutput;; 105}; 106 ; 107////////////////////////////////////////////////////////////////////////////////; 108/// Abort processing. If what = kAbortProcess, the Process() loop will be; 109/// aborted. If what = kAbortFile, the current file in a chain will be; 110/// aborted and the processing will continue with the next file, if there; 111/// is no next file then Process() will be aborted. Abort() can also be; 112/// called from Begin(), SlaveBegin(), Init() and Notify(). After abort; 113/// the SlaveTerminate() and Terminate() are always called. The abort flag; 114/// can be checked in these methods using GetAbort().; 115 ; 116void TSelector::Abort(const char *why, EAbort what); 117{; 118 fAbort = what;; 119 TString mess = ""Abort"";; 120 if (fAbort == kAbortProcess); 121 mess = ""AbortProcess"";; 122 else if (fAbort == kAbortFile); 123 mess = ""AbortFile"";; 124 ; 125 Info(mess, ""%s"", why);; 126}; 127 ; 128////////////////////////////////////////////////////////////////////////////////; 129/// The code in filename is loaded (interpreted or compiled, see below),; 130/// filename must contain a valid class implementation derived from TSelector.; 131///; 132/// If filename is of the form file.C, the file will be interpreted.; 133/// If filename is of the form file.C++, the file file.C will be compiled; 134/// and dynamically loaded. The corresponding binary file and shared; 135/// library will be deleted at the end of the function.; 136/// If filename is of the form file.C+, the file file.C will be compiled; 137/// and dynamically loaded. At next call, if file.C is olde",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:4776,abort,abort,4776,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,1,['abort'],['abort']
Safety,"////////////; 1110/// Find special characters which are typically used in `printf()` calls; 1111/// and replace them by appropriate escape sequences. Result can be; 1112/// stored as string argument in ROOT macros. The content of TString will be changed!; 1113 ; 1114TString &TString::ReplaceSpecialCppChars(); 1115{; 1116 return ReplaceAll(""\\"",""\\\\"").ReplaceAll(""\"""",""\\\"""");; 1117}; 1118 ; 1119 ; 1120////////////////////////////////////////////////////////////////////////////////; 1121/// Remove char c at begin and/or end of string (like Strip()) but; 1122/// modifies directly the string.; 1123 ; 1124TString &TString::Remove(EStripType st, char c); 1125{; 1126 Ssiz_t start = 0; // Index of first character; 1127 Ssiz_t end = Length(); // One beyond last character; 1128 const char *direct = Data(); // Avoid a dereference w dumb compiler; 1129 Ssiz_t send = end;; 1130 ; 1131 if (st & kLeading); 1132 while (start < end && direct[start] == c); 1133 ++start;; 1134 if (st & kTrailing); 1135 while (start < end && direct[end-1] == c); 1136 --end;; 1137 if (end == start) {; 1138 UnLink();; 1139 Zero();; 1140 return *this;; 1141 }; 1142 if (start); 1143 Remove(0, start);; 1144 if (send != end); 1145 Remove(send - start - (send - end), send - end);; 1146 return *this;; 1147}; 1148 ; 1149////////////////////////////////////////////////////////////////////////////////; 1150/// Resize the string. Truncate or add blanks as necessary.; 1151 ; 1152void TString::Resize(Ssiz_t n); 1153{; 1154 if (n < Length()); 1155 Remove(n); // Shrank; truncate the string; 1156 else; 1157 Append(' ', n-Length()); // Grew or staid the same; 1158}; 1159 ; 1160////////////////////////////////////////////////////////////////////////////////; 1161/// Return a substring of self stripped at beginning and/or end.; 1162 ; 1163TSubString TString::Strip(EStripType st, char c) const; 1164{; 1165 Ssiz_t start = 0; // Index of first character; 1166 Ssiz_t end = Length(); // One beyond last character; 1167 const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:34291,Avoid,Avoid,34291,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['Avoid'],['Avoid']
Safety,"///////////; 262/// Create a new browser with a name, title, width and height for TObject *obj.; 263 ; 264TBrowser::TBrowser(const char *name,void *obj, TClass *cl,; 265 const char *objname, const char *title,; 266 Int_t x, Int_t y,; 267 UInt_t width, UInt_t height, Option_t *opt); 268 : TNamed(name, title); 269{; 270 if (!InitGraphics()); 271 return;; 272 if (!fImp); 273 fImp = gGuiFactory->CreateBrowserImp(this, title, x, y, width, height, opt);; 274 Create(new TBrowserObject(obj,cl,objname));; 275}; 276 ; 277////////////////////////////////////////////////////////////////////////////////; 278/// Delete the browser.; 279 ; 280TBrowser::~TBrowser(); 281{; 282 Destructor();; 283}; 284 ; 285////////////////////////////////////////////////////////////////////////////////; 286/// Actual browser destructor.; 287 ; 288void TBrowser::Destructor(); 289{; 290 if (fImp) fImp->CloseTabs();; 291 R__LOCKGUARD(gROOTMutex);; 292 gROOT->GetListOfBrowsers()->Remove(this);; 293 SafeDelete(fContextMenu);; 294 SafeDelete(fTimer);; 295 SafeDelete(fImp);; 296}; 297 ; 298////////////////////////////////////////////////////////////////////////////////; 299/// Add object with name to browser. If name not set the objects GetName(); 300/// is used. If check < 0 (default) no check box is drawn, if 0 then; 301/// unchecked checkbox is added, if 1 checked checkbox is added.; 302 ; 303void TBrowser::Add(TObject *obj, const char *name, Int_t check); 304{; 305 if (obj && fImp) {; 306 fImp->Add(obj, name, check);; 307 obj->SetBit(kMustCleanup);; 308 }; 309}; 310 ; 311////////////////////////////////////////////////////////////////////////////////; 312/// Add foreign object with name to browser.; 313/// 'cl' is the type use to store the value of obj.; 314/// So literally the following pseudo code should be correct:; 315///~~~ {.cpp}; 316/// `cl->GetName()` * ptr = (`cl->GetName()`*) obj;; 317///~~~; 318/// and the value of obj is not necessarily the start of the object.; 319/// If check < 0 (default)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBrowser_8cxx_source.html:9840,Safe,SafeDelete,9840,doc/master/TBrowser_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html,3,['Safe'],['SafeDelete']
Safety,"///////////; 5735/// Load map between class and library. If rootmapfile is specified a; 5736/// specific rootmap file can be added (typically used by ACLiC).; 5737/// In case of error -1 is returned, 0 otherwise.; 5738/// The interpreter uses this information to automatically load the shared; 5739/// library for a class (autoload mechanism), see the AutoLoad() methods below.; 5740 ; 5741Int_t TCling::LoadLibraryMap(const char* rootmapfile); 5742{; 5743 if (rootmapfile && *rootmapfile && !requiresRootMap(rootmapfile)); 5744 return 0;; 5745 ; 5746 R__LOCKGUARD(gInterpreterMutex);; 5747 ; 5748 // open the [system].rootmap files; 5749 if (!fMapfile) {; 5750 fMapfile = new TEnv();; 5751 fMapfile->IgnoreDuplicates(kTRUE);; 5752 fRootmapFiles = new TObjArray;; 5753 fRootmapFiles->SetOwner();; 5754 InitRootmapFile("".rootmap"");; 5755 }; 5756 ; 5757 // Prepare a list of all forward declarations for cling; 5758 // For some experiments it is easily as big as 500k characters. To be on the; 5759 // safe side, we go for 1M.; 5760 TUniqueString uniqueString(1048576);; 5761 ; 5762 // Load all rootmap files in the dynamic load path ((DY)LD_LIBRARY_PATH, etc.).; 5763 // A rootmap file must end with the string "".rootmap"".; 5764 TString ldpath = gSystem->GetDynamicPath();; 5765 if (ldpath != fRootmapLoadPath) {; 5766 fRootmapLoadPath = ldpath;; 5767#ifdef WIN32; 5768 TObjArray* paths = ldpath.Tokenize("";"");; 5769#else; 5770 TObjArray* paths = ldpath.Tokenize("":"");; 5771#endif; 5772 TString d;; 5773 for (Int_t i = 0; i < paths->GetEntriesFast(); i++) {; 5774 d = ((TObjString *)paths->At(i))->GetString();; 5775 // check if directory already scanned; 5776 Int_t skip = 0;; 5777 for (Int_t j = 0; j < i; j++) {; 5778 TString pd = ((TObjString *)paths->At(j))->GetString();; 5779 if (pd == d) {; 5780 skip++;; 5781 break;; 5782 }; 5783 }; 5784 if (!skip) {; 5785 void* dirp = gSystem->OpenDirectory(d);; 5786 if (dirp) {; 5787 if (gDebug > 3) {; 5788 Info(""LoadLibraryMap"", ""%s"", d.Data());; 5789 };",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:224428,safe,safe,224428,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['safe'],['safe']
Safety,"//////; 262/// TClassTable is a singleton (i.e. only one can exist per application).; 263 ; 264TClassTable::TClassTable(); 265{; 266 if (gClassTable) return;; 267 ; 268 fgSize = 1009; //this is the result of (int)TMath::NextPrime(1000);; 269 fgTable = new TClassRec* [fgSize];; 270 fgAlternate = new TClassAlt* [fgSize];; 271 fgIdMap = new IdMap_t;; 272 memset(fgTable, 0, fgSize * sizeof(TClassRec*));; 273 memset(fgAlternate, 0, fgSize * sizeof(TClassAlt*));; 274 gClassTable = this;; 275 ; 276 for (auto &&r : GetDelayedAddClass()) {; 277 AddClass(r->fName, r->fId, *r->fInfo, r->fDict, r->fBits);; 278 };; 279 GetDelayedAddClass().clear();; 280 ; 281 for (auto &&r : GetDelayedAddClassAlternate()) {; 282 AddAlternate(r.first, r.second);; 283 }; 284 GetDelayedAddClassAlternate().clear();; 285}; 286 ; 287////////////////////////////////////////////////////////////////////////////////; 288/// TClassTable singleton is deleted in Terminate().; 289 ; 290TClassTable::~TClassTable(); 291{; 292 // Try to avoid spurious warning from memory leak checkers.; 293 if (gClassTable != this) return;; 294 ; 295 for (UInt_t i = 0; i < fgSize; i++) {; 296 delete fgTable[i]; // Will delete all the elements in the chain.; 297 }; 298 delete [] fgTable; fgTable = nullptr;; 299 delete [] fgSortedTable; fgSortedTable = nullptr;; 300 delete fgIdMap; fgIdMap = nullptr;; 301}; 302 ; 303////////////////////////////////////////////////////////////////////////////////; 304/// Return true fs the table exist.; 305/// If the table does not exist but the delayed list does, then; 306/// create the table and return true.; 307 ; 308inline Bool_t TClassTable::CheckClassTableInit(); 309{; 310 // This will be set at the lastest during TROOT construction, so before; 311 // any threading could happen.; 312 if (!gClassTable || !fgTable) {; 313 if (GetDelayedAddClass().size()) {; 314 new TClassTable;; 315 return kTRUE;; 316 }; 317 return kFALSE;; 318 }; 319 return kTRUE;; 320}; 321 ; 322///////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:8627,avoid,avoid,8627,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,2,['avoid'],['avoid']
Safety,"/////; 123/// Create a new OS interface.; 124 ; 125TSystem::TSystem(const char *name, const char *title) : TNamed(name, title); 126{; 127 if (gSystem && name[0] != '-' && strcmp(name, ""Generic"")); 128 Error(""TSystem"", ""only one instance of TSystem allowed"");; 129 ; 130 if (!gLibraryVersion) {; 131 gLibraryVersion = new Int_t [gLibraryVersionMax];; 132 memset(gLibraryVersion, 0, gLibraryVersionMax*sizeof(Int_t));; 133 }; 134}; 135 ; 136////////////////////////////////////////////////////////////////////////////////; 137/// Delete the OS interface.; 138 ; 139TSystem::~TSystem(); 140{; 141 if (fOnExitList) {; 142 fOnExitList->Delete();; 143 SafeDelete(fOnExitList);; 144 }; 145 ; 146 if (fSignalHandler) {; 147 fSignalHandler->Delete();; 148 SafeDelete(fSignalHandler);; 149 }; 150 ; 151 if (fFileHandler) {; 152 fFileHandler->Delete();; 153 SafeDelete(fFileHandler);; 154 }; 155 ; 156 if (fStdExceptionHandler) {; 157 fStdExceptionHandler->Delete();; 158 SafeDelete(fStdExceptionHandler);; 159 }; 160 ; 161 if (fTimers) {; 162 fTimers->Delete();; 163 SafeDelete(fTimers);; 164 }; 165 ; 166 if (fCompiled) {; 167 fCompiled->Delete();; 168 SafeDelete(fCompiled);; 169 }; 170 ; 171 if (fHelpers) {; 172 fHelpers->Delete();; 173 SafeDelete(fHelpers);; 174 }; 175 ; 176 if (gSystem == this); 177 gSystem = nullptr;; 178}; 179 ; 180////////////////////////////////////////////////////////////////////////////////; 181/// Initialize the OS interface.; 182 ; 183Bool_t TSystem::Init(); 184{; 185 fNfd = 0;; 186 fMaxrfd = -1;; 187 fMaxwfd = -1;; 188 ; 189 fSigcnt = 0;; 190 fLevel = 0;; 191 ; 192 fSignalHandler = new TOrdCollection;; 193 fFileHandler = new TOrdCollection;; 194 fStdExceptionHandler = new TOrdCollection;; 195 fTimers = new TList;; 196 fTimers->UseRWLock();; 197 ; 198 fBuildArch = BUILD_ARCH;; 199 fBuildCompiler = COMPILER;; 200 fBuildCompilerVersion = COMPILERVERS;; 201 fBuildCompilerVersionStr = COMPILERVERSSTR;; 202 fBuildNode = BUILD_NODE;; 203 fFlagsDebug = CXXDEBUG;; 204 fFlag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:4546,Safe,SafeDelete,4546,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,7,['Safe'],['SafeDelete']
Safety,"/////; 9632/// Re-apply the lock count delta that TCling__ResetInterpreterMutex() caused.; 9633 ; 9634void TCling::ApplyToInterpreterMutex(void *delta); 9635{; 9636 if (gInterpreterMutex) {; 9637 if (delta) {; 9638 auto typedDelta = static_cast<MutexStateAndRecurseCountDelta *>(delta);; 9639 std::unique_ptr<MutexStateAndRecurseCountDelta> uniqueP{typedDelta};; 9640 gCoreMutex->Apply(std::move(typedDelta->fDelta));; 9641 // Now that we have the lock, update the global; 9642 R__ASSERT(fInitialMutex.fRecurseCount == 0 && ""Inconsistent state of fInitialMutex! Another thread within Interpreter critical section."");; 9643 std::swap(fInitialMutex, typedDelta->fInitialState);; 9644 } else {; 9645 // This case happens when EnableThreadSafety is first called from; 9646 // the interpreter function we just handled.; 9647 // Since thread safety was not enabled at the time we rewound, there was; 9648 // no lock taken and even-though we should be locking the rest of this; 9649 // interpreter handling/modifying code (since there might be threads in; 9650 // flight), we can't because there would not be any lock guard to release the; 9651 // locks; 9652 if (fInitialMutex || fInitialMutex.fRecurseCount !=0); 9653 Error(""ApplyToInterpreterMutex"",; 9654 ""After returning from user code that turned on thread safety support, we notice that fInitialMutex is already used ... ""; 9655 ""so the rest of this function/stack execution might have race condition (with the other thread that thinks it has exclusive access to the interpreter state."");; 9656 }; 9657 }; 9658}; 9659 ; 9660////////////////////////////////////////////////////////////////////////////////; 9661/// Reset the interpreter lock to the state it had before interpreter-related; 9662/// calls happened.; 9663 ; 9664void *TCling::RewindInterpreterMutex(); 9665{; 9666 if (fInitialMutex) {; 9667 // Need to start a new recurse count.; 9668 std::unique_ptr<MutexStateAndRecurseCountDelta> uniqueP(new MutexStateAndRecurseCountDelta());; 9669 st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:372923,safe,safety,372923,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['safe'],['safety']
Safety,"//; 2609/// ~~~~~~~{.cpp}; 2610/// TFile* pFile = new TFile(""passed.root"",""update"");; 2611/// TEfficiency* pEff = (TEfficiency*)gDirectory->Get(""my_eff"");; 2612/// TH1* copy = pEff->GetCopyPassedHisto();; 2613/// copy->SetDirectory(gDirectory);; 2614/// pFile->Write();; 2615/// ~~~~~~~; 2616 ; 2617TH1* TEfficiency::GetCopyPassedHisto() const; 2618{; 2619 // do not add cloned histogram to gDirectory; 2620 TDirectory::TContext ctx(nullptr);; 2621 TH1* tmp = (TH1*)(fPassedHistogram->Clone());; 2622 ; 2623 return tmp;; 2624}; 2625 ; 2626////////////////////////////////////////////////////////////////////////////////; 2627/// Returns a cloned version of fTotalHistogram; 2628///; 2629/// Notes:; 2630/// - The histogram is filled with unit weights. You might want to scale; 2631/// it with the global weight GetWeight().; 2632/// - The returned object is owned by the user who has to care about the; 2633/// deletion of the new TH1 object.; 2634/// - This histogram is by default NOT attached to the current directory; 2635/// to avoid duplication of data. If you want to store it automatically; 2636/// during the next TFile::Write() command, you have to attach it to; 2637/// the corresponding directory.; 2638///; 2639/// ~~~~~~~{.cpp}; 2640/// TFile* pFile = new TFile(""total.root"",""update"");; 2641/// TEfficiency* pEff = (TEfficiency*)gDirectory->Get(""my_eff"");; 2642/// TH1* copy = pEff->GetCopyTotalHisto();; 2643/// copy->SetDirectory(gDirectory);; 2644/// pFile->Write();; 2645/// ~~~~~~~; 2646 ; 2647TH1* TEfficiency::GetCopyTotalHisto() const; 2648{; 2649 // do not add cloned histogram to gDirectory; 2650 TDirectory::TContext ctx(nullptr);; 2651 TH1* tmp = (TH1*)(fTotalHistogram->Clone());; 2652 ; 2653 return tmp;; 2654}; 2655 ; 2656////////////////////////////////////////////////////////////////////////////////; 2657///returns the dimension of the current TEfficiency object; 2658 ; 2659Int_t TEfficiency::GetDimension() const; 2660{; 2661 return fTotalHistogram->GetDimension();;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEfficiency_8cxx_source.html:106102,avoid,avoid,106102,doc/master/TEfficiency_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html,1,['avoid'],['avoid']
Safety,"//; 2637/// Find parent tree of a clicked item.; 2638 ; 2639void TTreeViewer::SetParentTree(TGListTreeItem *item); 2640{; 2641 if (!item) return;; 2642 ULong_t *itemType = (ULong_t *)item->GetUserData();; 2643 if (!itemType) return;; 2644 TGListTreeItem *parent = nullptr;; 2645 Int_t index;; 2646 if (!(*itemType & kLTTreeType)) {; 2647 parent = item->GetParent();; 2648 SetParentTree(parent);; 2649 } else {; 2650 index = (Int_t)(*itemType >> 8);; 2651 SwitchTree(index);; 2652 }; 2653}; 2654 ; 2655////////////////////////////////////////////////////////////////////////////////; 2656/// Send a message on the status bar.; 2657 ; 2658void TTreeViewer::Message(const char* msg); 2659{; 2660 fStatusBar->SetText(msg);; 2661}; 2662 ; 2663////////////////////////////////////////////////////////////////////////////////; 2664/// Put error/warning into TMsgBox and also forward to console.; 2665 ; 2666void TTreeViewer::DoError(int level, const char *location, const char *fmt, va_list va) const; 2667{; 2668 TObject::DoError(level, location, fmt, va);; 2669 ; 2670 // in case level will abort we will not come here...; 2671 ; 2672 static const int buf_size = 2048;; 2673 char buf[buf_size], *bp;; 2674 ; 2675 int n = vsnprintf(buf, buf_size, fmt, va);; 2676 // old vsnprintf's return -1 if string is truncated new ones return; 2677 // total number of characters that would have been written; 2678 if (n == -1 || n >= buf_size) {; 2679 TObject::Warning(""DoError"", ""Error message string truncated..."");; 2680 }; 2681 if (level >= kSysError && level < kFatal); 2682 bp = Form(""%s (%s)"", buf, gSystem->GetError());; 2683 else; 2684 bp = buf;; 2685 ; 2686 const char *title = """";; 2687 if (level == kInfo); 2688 title = ""Info"";; 2689 if (level == kWarning); 2690 title = ""Warning"";; 2691 if (level == kError); 2692 title = ""Error"";; 2693 if (level == kSysError); 2694 title = ""System Error"";; 2695 ; 2696 new TGMsgBox(fClient->GetRoot(), this, title, bp, kMBIconExclamation);; 2697}; 2698 ; 2699////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:94885,abort,abort,94885,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['abort'],['abort']
Safety,"//www.chilkatsoft.com/p/p_299.asp */; 6377 return -2;; 6378 } else {; 6379 DEBUG_TRACE(""recv() failed, error %d"", err);; 6380 return -2;; 6381 }; 6382#else; 6383 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6384 * if the timeout is reached and if the socket was set to non-; 6385 * blocking in close_socket_gracefully, so we can not distinguish; 6386 * here. We have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN(err)) {; 6389 /* TODO (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6428 ; 6429 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6430 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6431 if (n == -2) {; 6432 if (nread == 0) {; 6433 nread = -1; /* Propagate the error */; 6434 }; 6435 break;; 6436 } else if (n == -1) {; 6437 /* timeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:186677,Timeout,Timeout,186677,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['Timeout'],['Timeout']
Safety,"//www.chilkatsoft.com/p/p_299.asp */; 6378 return -2;; 6379 } else {; 6380 DEBUG_TRACE(""recv() failed, error %d"", err);; 6381 return -2;; 6382 }; 6383#else; 6384 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6385 * if the timeout is reached and if the socket was set to non-; 6386 * blocking in close_socket_gracefully, so we can not distinguish; 6387 * here. We have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN(err)) {; 6390 /* TODO (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6429 ; 6430 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6431 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6432 if (n == -2) {; 6433 if (nread == 0) {; 6434 nread = -1; /* Propagate the error */; 6435 }; 6436 break;; 6437 } else if (n == -1) {; 6438 /* timeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:186709,Timeout,Timeout,186709,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['Timeout'],['Timeout']
Safety,"/webviewer/inc/ROOT/RGeomData.hxx Source File. ; ROOT Â ; . v6-32. Reference Guide ; . Â . Loading...; Searching...; No Matches. RGeomData.hxx. Go to the documentation of this file. 1// Author: Sergey Linev, 14.12.2018; 2 ; 3/*************************************************************************; 4 * Copyright (C) 1995-2023, Rene Brun and Fons Rademakers. *; 5 * All rights reserved. *; 6 * *; 7 * For the licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#ifndef ROOT7_RGeomData; 12#define ROOT7_RGeomData; 13 ; 14#include <vector>; 15#include <string>; 16#include <functional>; 17#include <memory>; 18 ; 19#include <ROOT/Browsable/RItem.hxx>; 20 ; 21#include ""TVirtualMutex.h""; 22 ; 23class TGeoNode;; 24class TGeoManager;; 25class TGeoShape;; 26class TGeoMatrix;; 27class TGeoVolume;; 28 ; 29// do not use namespace to avoid too long JSON; 30 ; 31namespace ROOT {; 32 ; 33class RGeomBrowserIter;; 34 ; 35namespace Experimental {; 36class RLogChannel;; 37} // namespace Experimental; 38 ; 39/// Log channel for Geomviewer diagnostics.; 40Experimental::RLogChannel &RGeomLog();; 41 ; 42/** Base description of geometry node, required only to build hierarchy */; 43 ; 44class RGeomNodeBase {; 45public:; 46 int id{0}; ///< node id, index in array; 47 std::string name; ///< node name; 48 std::vector<int> chlds; ///< list of childs id; 49 int vis{0}; ///< visibility flag, 0 - off, 1 - only when level==0, 99 - always; 50 bool nochlds{false}; ///< how far in hierarchy depth should be scanned; 51 ; 52 std::string color; ///< rgb code in hex format; 53 std::string material; ///< name of the material; 54 int sortid{0}; ///<! place in sorted array, to check cuts, or id of original node when used search structures; 55 ; 56 RGeomNodeBase(int _id = 0) : id(_id) {}; 57 ; 58 bool IsVisible() const { return vis > 0; }; 59 ; 60 /** Returns argument for regexp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RGeomData_8hxx_source.html:978,avoid,avoid,978,doc/v632/RGeomData_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RGeomData_8hxx_source.html,1,['avoid'],['avoid']
Safety,"0 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6428 ; 6429 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6430 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6431 if (n == -2) {; 6432 if (nread == 0) {; 6433 nread = -1; /* Propagate the error */; 6434 }; 6435 break;; 6436 } else if (n == -1) {; 6437 /* timeout */; 6438 if (timeout >= 0.0) {; 6439 now = mg_get_current_time_ns();; 6440 if ((now - start_time) <= timeout_ns) {; 6441 continue;; 6442 }; 6443 }; 6444 break;; 6445 } else if (n == 0) {; 6446 break; /* No more data to read */; 6447 } else {; 6448 nread += n;; 6449 len -= n;; 6450 }; 6451 }; 6452 ; 6453 return nread;; 6454}; 6455 ; 6456 ; 6457static void; 6458discard_unread_request_data(struct mg_connection *conn); 6459{; 6460 char buf[MG_BUF_LEN];; 6461 ; 6462 while (mg_read(conn, buf, sizeof(buf)) > 0); 6463 ;; 6464}; 6465 ; 646",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:187135,timeout,timeout,187135,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"0 = 0.5 L(0 - 1) ""a0""; 2) 0x7ffcf3632428 RooRealVar:: a1 = 0.2 L(0 - 1) ""a1""; 3) 0x7ffcf3632810 RooRealVar:: alpha = -1 C L(-INF - +INF) ""alpha""; 4) 0x7ffcf3632bf8 RooRealVar:: bkg1frac = 0.2 L(0 - 1) ""fraction of component 1 in background""; 5) 0x7ffcf3632fe0 RooRealVar:: bkgfrac = 0.5 L(0 - 1) ""fraction of background""; 6) 0x7ffcf3634428 RooRealVar:: mean = 5 C L(-INF - +INF) ""mean of gaussians""; 7) 0x7ffcf3631c58 RooRealVar:: sigma = 0.5 C L(-INF - +INF) ""width of gaussians""; RooArgSet::parameters = (a0,a1,alpha,bkg1frac,bkgfrac,mean,sigma); 1) 0x7ffcf3635228 RooAddPdf:: model[ bkgfrac * bkg + [%] * sig ] = 0.582695/1 ""g1+g2+a""; 2) 0x7ffcf3633d08 RooAddPdf:: bkg[ bkg1frac * bkg1 + [%] * bkg2 ] = 0.16539/1 ""Signal""; 3) 0x7ffcf3631230 RooChebychev:: bkg1[ x=x coefficients=(a0,a1) ] = 0.8 ""Background 1""; 4) 0x7ffcf3631760 RooExponential:: bkg2[ x=x c=alpha ] = 0.00673795 ""Background 2""; 5) 0x7ffcf36337b0 RooGaussian:: sig[ x=x mean=mean sigma=sigma ] = 1 ""Signal component 1""; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooCustomizer::build(model): tree node sig will be replaced by sigsum; [#1] INFO:ObjectHandling -- RooCustomizer::build(model) Branch node RooAddPdf::model cloned: depends on a replaced parameter; [#1] INFO:ObjectHandling -- RooCustomizer::build(model) Branch node sig is already replaced; 0x55dc4fd6a940 RooAddPdf::model_cust = 0.582695/1 [Auto,Clean] ; 0x7ffcf3633d08/V- RooAddPdf::bkg = 0.16539/1 [Auto,Clean] ; 0x7ffcf3631230/V- RooChebychev::bkg1 = 0.8 [Auto,Dirty] ; 0x7ffcf3635ea0/V- RooRealVar::x = 5; 0x7ffcf3632040/V- RooRealVar::a0 = 0.5; 0x7ffcf3632428/V- RooRealVar::a1 = 0.2; 0x7ffcf3632bf8/V- RooRealVar::bkg1frac = 0.2; 0x7ffcf3631760/V- RooExponential::bkg2 = 0.00673795 [Auto,Dirty] ; 0x7ffcf3635ea0/V- RooRealVar::x = 5; 0x7ffcf3632810/V- RooRealVar::alpha = -1; 0x7ffcf3632fe0/V- RooRealVar::bkgf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf207__comptools_8C.html:7725,safe,safe,7725,doc/master/rf207__comptools_8C.html,https://root.cern,https://root.cern/doc/master/rf207__comptools_8C.html,1,['safe'],['safe']
Safety,"0 Bool_t fIsSameLocation; //! flag that a new point is in the same node as previous; 71 Bool_t fIsNullStep; //! flag that last geometric step was null; 72 TGeoManager *fGeometry; //! current geometry; 73 TGeoNodeCache *fCache; //! cache of states; 74 TGeoVolume *fCurrentVolume; //! current volume; 75 TGeoNode *fCurrentNode; //! current node; 76 TGeoNode *fTopNode; //! top physical node; 77 TGeoNode *fLastNode; //! last searched node; 78 TGeoNode *fNextNode; //! next node that will be crossed; 79 TGeoNode *fForcedNode; //! current point is supposed to be inside this node; 80 TGeoCacheState *fBackupState; //! backup state; 81 TGeoHMatrix *fCurrentMatrix; //! current stored global matrix; 82 TGeoHMatrix *fGlobalMatrix; //! current pointer to cached global matrix; 83 TGeoHMatrix *fDivMatrix; //! current local matrix of the selected division cell; 84 TString fPath; //! path to current node; 85 ; 86 static Bool_t fgUsePWSafetyCaching; //! global mode is caching enabled for parallel world safety calls; 87 ; 88public:; 89 TGeoNavigator();; 90 TGeoNavigator(TGeoManager *geom);; 91 ~TGeoNavigator() override;; 92 ; 93 void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE);; 94 Bool_t cd(const char *path = """");; 95 Bool_t CheckPath(const char *path) const;; 96 void CdNode(Int_t nodeid);; 97 void CdDown(Int_t index);; 98 void CdDown(TGeoNode *node);; 99 void CdUp();; 100 void CdTop();; 101 void CdNext();; 102 void GetBranchNames(Int_t *names) const;; 103 void GetBranchNumbers(Int_t *copyNumbers, Int_t *volumeNumbers) const;; 104 void GetBranchOnlys(Int_t *isonly) const;; 105 Int_t GetNmany() const { return fNmany; }; 106 //--- geometry queries; 107 TGeoNode *CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode);; 108 TGeoNode *FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char *path = """", Bool_t frombdr = kFALSE);; 109 TGeoNode *FindNextDaughterBoundary(Double_t *point, Double_t *dir, Int_t &idaughter, Bool_t compmatrix = kFALSE);; 110 TGeoNode *FindN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:4457,safe,safety,4457,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safety']
Safety,"0 va_list ap;; 3471 va_start(ap, fmt);; 3472 mg_cry_internal_impl(conn, ""user"", 0, fmt, ap);; 3473 va_end(ap);; 3474}; 3475 ; 3476 ; 3477#define mg_cry DO_NOT_USE_THIS_FUNCTION__USE_mg_cry_internal; 3478 ; 3479 ; 3480const char *; 3481mg_version(void); 3482{; 3483 return CIVETWEB_VERSION;; 3484}; 3485 ; 3486 ; 3487const struct mg_request_info *; 3488mg_get_request_info(const struct mg_connection *conn); 3489{; 3490 if (!conn) {; 3491 return NULL;; 3492 }; 3493#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE); 3494 if (conn->connection_type == CONNECTION_TYPE_RESPONSE) {; 3495 char txt[16];; 3496 struct mg_workerTLS *tls =; 3497 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 3498 ; 3499 sprintf(txt, ""%03i"", conn->response_info.status_code);; 3500 if (strlen(txt) == 3) {; 3501 memcpy(tls->txtbuf, txt, 4);; 3502 } else {; 3503 strcpy(tls->txtbuf, ""ERR"");; 3504 }; 3505 ; 3506 ((struct mg_connection *)conn)->request_info.local_uri =; 3507 tls->txtbuf; /* use thread safe buffer */; 3508 ((struct mg_connection *)conn)->request_info.local_uri_raw =; 3509 tls->txtbuf; /* use the same thread safe buffer */; 3510 ((struct mg_connection *)conn)->request_info.request_uri =; 3511 tls->txtbuf; /* use the same thread safe buffer */; 3512 ; 3513 ((struct mg_connection *)conn)->request_info.num_headers =; 3514 conn->response_info.num_headers;; 3515 memcpy(((struct mg_connection *)conn)->request_info.http_headers,; 3516 conn->response_info.http_headers,; 3517 sizeof(conn->response_info.http_headers));; 3518 } else; 3519#endif; 3520 if (conn->connection_type != CONNECTION_TYPE_REQUEST) {; 3521 return NULL;; 3522 }; 3523 return &conn->request_info;; 3524}; 3525 ; 3526 ; 3527const struct mg_response_info *; 3528mg_get_response_info(const struct mg_connection *conn); 3529{; 3530 if (!conn) {; 3531 return NULL;; 3532 }; 3533 if (conn->connection_type != CONNECTION_TYPE_RESPONSE) {; 3534 return NULL;; 3535 }; 3536 return &conn->response_info;; 3537}; 3538 ; 3539 ; 3540static c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:104132,safe,safe,104132,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['safe'],['safe']
Safety,"0). explicit . Class constructor. ; nWorkers is the number of times this ROOT session will be forked, i.e. the number of workers that will be spawned. ; Definition at line 90 of file TTreeProcessorMP.cxx. â—†Â ~TTreeProcessorMP(). ROOT::TTreeProcessorMP::~TTreeProcessorMP ; (; ). default . â—†Â TTreeProcessorMP() [2/2]. ROOT::TTreeProcessorMP::TTreeProcessorMP ; (; const TTreeProcessorMP &Â ; ). delete . Member Function Documentation. â—†Â Collect(). template<class T > . void ROOT::TTreeProcessorMP::Collect ; (; std::vector< T > &Â ; reslist). private . Listen for messages sent by the workers and call the appropriate handler function. ; TTreeProcessorMP::HandlePoolCode is called on messages with a code < 1000 and TMPClient::HandleMPCode is called on messages with a code >= 1000. ; Definition at line 433 of file TTreeProcessorMP.hxx. â—†Â FixLists(). void ROOT::TTreeProcessorMP::FixLists ; (; std::vector< TObject * > &Â ; lists). private . Fix list of lists before merging (to avoid errors about duplicated objects) ; Definition at line 324 of file TTreeProcessorMP.cxx. â—†Â GetNWorkers(). unsigned ROOT::TTreeProcessorMP::GetNWorkers ; (; ); const. inline . Definition at line 166 of file TTreeProcessorMP.hxx. â—†Â HandlePoolCode(). template<class T > . void ROOT::TTreeProcessorMP::HandlePoolCode ; (; MPCodeBufPair &Â ; msg, . TSocket *Â ; sender, . std::vector< T > &Â ; reslistÂ . ). private . Handle message and reply to the worker. ; Definition at line 407 of file TTreeProcessorMP.hxx. â—†Â operator=(). TTreeProcessorMP & ROOT::TTreeProcessorMP::operator= ; (; const TTreeProcessorMP &Â ; ). delete . â—†Â Process() [1/20]. template<class F > . auto ROOT::TTreeProcessorMP::Process ; (; const std::string &Â ; fileName, . FÂ ; procFunc, . const std::string &Â ; treeName = """", . ULong64_tÂ ; nToProcess = 0, . ULong64_tÂ ; jFirst = 0Â . ); -> InvokeResult_t<F, std::reference_wrapper<TTreeReader>>. Definition at line 366 of file TTreeProcessorMP.hxx. â—†Â Process() [2/20]. template<class F > . auto ROOT::TTreeProces",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TTreeProcessorMP.html:13130,avoid,avoid,13130,doc/v632/classROOT_1_1TTreeProcessorMP.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TTreeProcessorMP.html,2,['avoid'],['avoid']
Safety,"0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Create biuned dataset; # -----------------------------------------; ; d = model.generate({x}, 10000); dh = d.binnedClone(); ; # Construct a chi^2 of the data and the model.; # When a p.d.f. is used in a chi^2 fit, probability density scaled; # by the number of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 104.639633447510988; Edm = 0.000778057047730882148; Nfcn = 70; a0 = 0.501526 +/- 0.0229096 (limited); a1 = 0.158456 +/- 0.0368354 (limited); bkgfrac = 0.506609 +/- 0.011349 (limited); sig1frac = 0.815448 +/- 0.0373695 (limited); [#1] INFO:Minimization -- RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf602__chi2fit_8py.html:2503,safe,safe,2503,doc/master/rf602__chi2fit_8py.html,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html,1,['safe'],['safe']
Safety,"0.077) 0.368 (0.368) 0.659 (0.684); : dataset TMVA_DNN : 0.027 (0.021) 0.223 (0.194) 0.487 (0.491); : -------------------------------------------------------------------------------------------------------------------; : ; Dataset:dataset : Created tree 'TestTree' with 800 events; : ; Dataset:dataset : Created tree 'TrainTree' with 3200 events; : ; Factory : â›[1mThank you for using TMVA!â›[0m; : â›[1mFor citation information, please visit: http://tmva.sf.net/citeTMVA.htmlâ›[0m; nthreads = 4; ; ; # TMVA Classification Example Using a Recurrent Neural Network; ; # This is an example of using a RNN in TMVA.; # We do the classification using a toy data set containing a time series of data sample ntimes; # and with dimension ndim that is generated when running the provided function `MakeTimeData (nevents, ntime, ndim)`; ; ; import ROOT; ; num_threads = 4 # use max 4 threads; # do enable MT running; if ""imt"" in ROOT.gROOT.GetConfigFeatures():; ROOT.EnableImplicitMT(num_threads); # switch off MT in OpenBLAS to avoid conflict with tbb; ROOT.gSystem.Setenv(""OMP_NUM_THREADS"", ""1""); print(""Running with nthreads = {}"".format(ROOT.GetThreadPoolSize())); else:; print(""Running in serial mode since ROOT does not support MT""); ; ; TMVA = ROOT.TMVA; TFile = ROOT.TFile; ; import os; import importlib; ; ; TMVA.Tools.Instance(); TMVA.Config.Instance(); ; ; ## Helper function to generate the time data set; ## make some time data but not of fixed length.; ## use a poisson with mu = 5 and truncated at 10; ; ; def MakeTimeData(n, ntime, ndim):; # ntime = 10;; # ndim = 30; // number of dim/time; ; fname = ""time_data_t"" + str(ntime) + ""_d"" + str(ndim) + "".root""; v1 = []; v2 = []; ; for i in range(ntime):; v1.append(ROOT.TH1D(""h1_"" + str(i), ""h1"", ndim, 0, 10)); v2.append(ROOT.TH1D(""h2_"" + str(i), ""h2"", ndim, 0, 10)); ; f1 = ROOT.TF1(""f1"", ""gaus""); f2 = ROOT.TF1(""f2"", ""gaus""); ; sgn = ROOT.TTree(""sgn"", ""sgn""); bkg = ROOT.TTree(""bkg"", ""bkg""); f = TFile(fname, ""RECREATE""); ; x1 = []; x2 = []; ; for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:49542,avoid,avoid,49542,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['avoid'],['avoid']
Safety,"0.5; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; frame1 = obsvar.frame(Title=""Morphed templates for selected values""); plot_args = dict(; DrawOption=""C"",; DataError=None,; XErrorSize=0,; ); morph_datahist_0p01.plotOn(frame1, Name=""morph_dh_cHq3=0.01"", LineColor=""kGreen"", **plot_args); morph_datahist_0p25.plotOn(frame1, Name=""morph_dh_cHq3=0.25"", LineColor=""kGreen+1"", **plot_args); morph_datahist_0p5.plotOn(frame1, Name=""morph_dh_cHq3=0.5"", LineColor=""kGreen+2"", **plot_args); ; # Create wrapped pdf to generate 2D dataset of cHq3 as a function of pTV; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; model = ROOT.RooWrapperPdf(""wrap_pdf"", ""wrap_pdf"", morphfunc); data = model.generate({cHq3, obsvar}, 1000000); hh_data = data.createHistogram(""x,y"", obsvar, Binning=20, YVar=dict(var=cHq3, Binning=50)); hh_data.SetTitle(""Morphing prediction""); ; # Draw plots on canvas; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; c1 = ROOT.TCanvas(""fig3"", ""fig3"", 1200, 400); c1.Divide(3, 1); ; c1.cd(1); ROOT.gPad.SetLeftMargin(0.15); ROOT.gPad.SetRightMargin(0.05); ; frame0.Draw(); leg1 = ROOT.TLegend(0.55, 0.65, 0.94, 0.87); leg1.SetTextSize(0.04); leg1.SetFillColor(ROOT.kWhite); leg1.SetLineColor(ROOT.kWhite); leg1.AddEntry(""SM_NPsq0"", ""SM"", ""LP""); leg1.AddEntry(0, """", """"); leg1.AddEntry(""cHq3_NPsq1"", ""c_{Hq^{(3)}}=1.0 at #Lambda^{-2}"", ""LP""); leg1.AddEntry(0, """", """"); leg1.AddEntry(""cHq3_NPsq2"", ""c_{Hq^{(3)}}=1.0 at #Lambda^{-4}"", ""LP""); leg1.Draw(); ; c1.cd(2); ROOT.gPad.SetLeftMargin(0.15); ROOT.gPad.SetRightMargin(0.05); ; frame1.Draw(); ; leg2 = ROOT.TLegend(0.62, 0.65, 0.94, 0.87); leg2.SetTextSize(0.04); leg2.SetFillColor(ROOT.kWhite); leg2.SetLineColor(ROOT.kWhite); ; leg2.AddEntry(""morph_dh_cHq3=0.01"", ""c_{Hq^{(3)}}=0.01"", ""L""); leg2.AddEntry(0, """", """"); leg2.AddEntry(""morph_dh_cHq3=0.25"", ""c_{Hq^{(3)}}=0.25"", ""L""); leg2.AddEntr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf711__lagrangianmorph_8py.html:4384,predict,prediction,4384,doc/master/rf711__lagrangianmorph_8py.html,https://root.cern,https://root.cern/doc/master/rf711__lagrangianmorph_8py.html,1,['predict'],['prediction']
Safety,"00 Hz for complex data structure. A factor of few improvement for complex data can be a difference between requiring just one machine or a small farm. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:51 Permalink . Re: I/O Performance . Hi ROOT User,; We have dramatically improved the I/O performance over the last two years. If you use the latest production release also for writing data you might be able to see a performance improvement of an order of magnitude compared to e.g. 5.26, both in real and CPU time! See e.g. this blog entry.; We have been comparing the performance of ROOT I/O with competitors like Google ProtoBuf; we know exactly where we spend extra time and why, e.g. for schema evolution, proper C++ type support, introspection, pointers.; On the other hand, are you sure you make use of all the performance features ROOT offers? Did you enable the tree cache (on by default for PROOF and one tree per file, off - for now, still - otherwise)? Do you only read the branches you need? I am working on a new TTree read access class that should simplify all of that considerably (and is type safe - no more void*&!); maybe I should take your comment as an invitation to speed up :-); Cheers, Axel. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:51 Permalink . Re: Interpreters . Hi ROOT user,; Thanks for your comments - they are excellent!; Your scenario would probably work - but we decided against it, and I believe that we have good reasons for that :-); GCCXML's future is limited; there is a re-write based on GCC's plugin mechanism, but both suffer from the same problems: we cannot influence what the GCC parser does. And reading headers, writing XML, parsing XML, writing (huge files of) C++, compiling, linking, loading - that's really, really inefficient and error prone.; Python is much simpler than C++. But it's still a horrible language in our environment, unless it's used as bash++. Not a single algorithm should be written in Python: it'",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:16069,safe,safe,16069,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['safe'],['safe']
Safety,"000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFile.html:52996,timeout,timeout,52996,root/html532/TFile.html,https://root.cern,https://root.cern/root/html532/TFile.html,8,['timeout'],['timeout']
Safety,"000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:50209,timeout,timeout,50209,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,4,['timeout'],['timeout']
Safety,"000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoCompositeShape.html:8057,safe,safe,8057,root/html532/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html532/TGeoCompositeShape.html,1,['safe'],['safe']
Safety,"000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TTimer; 13#define ROOT_TTimer; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TTimer //; 19// //; 20// Handles synchronous and a-synchronous timer events. You can use //; 21// this class in one of the following ways: //; 22// - Sub-class TTimer and override the Notify() method. //; 23// - Re-implement the TObject::HandleTimer() method in your class //; 24// and pass a pointer to this object to timer, see the SetObject() //; 25// method. //; 26// - Pass an interpreter command to timer, see SetCommand() method. //; 27// - Create a TTimer, connect its Timeout() signal to the //; 28// appropriate methods. Then when the time is up it will emit a //; 29// Timeout() signal and call connected slots. //; 30// //; 31// Minimum timeout interval is defined in TSystem::ESysConstants as //; 32// kItimerResolution (currently 10 ms). //; 33// //; 34// Signal/slots example: //; 35// TTimer *timer = new TTimer(); //; 36// timer->Connect(""Timeout()"", ""myObjectClassName"", //; 37// myObject, ""TimerDone()""); //; 38// timer->Start(2000, kTRUE); // 2 seconds single-shot //; 39// //; 40// // Timeout signal is emitted repeadetly with minimum timeout //; 41// // timer->Start(0, kFALSE); //; 42// //; 43//////////////////////////////////////////////////////////////////////////; 44 ; 45#include ""TSysEvtHandler.h""; 46#include ""TTime.h""; 47#include ""TString.h""; 48 ; 49 ; 50 ; 51class TTimer : public TSysEvtHandler {; 52 ; 53protected:; 54 TTime fTime; // time out time in ms; 55 TTime fAbsTime; // absolute time out time in ms; 56 Bool_t fTimeout; // true if timer has timed out; 57 Bool_t fSync; // true if synchrounous timer; 58 Bool_t fIntSyscalls; // true is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8h_source.html:1344,Timeout,Timeout,1344,doc/master/TTimer_8h_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8h_source.html,1,['Timeout'],['Timeout']
Safety,"000.0;; 10828 }; 10829 }; 10830 ; 10831 request_len = get_http_header_len(buf, *nread);; 10832 ; 10833 while (request_len == 0) {; 10834 /* Full request not yet received */; 10835 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 10836 /* Server is to be stopped. */; 10837 return -1;; 10838 }; 10839 ; 10840 if (*nread >= bufsiz) {; 10841 /* Request too long */; 10842 return -2;; 10843 }; 10844 ; 10845 n = pull_inner(; 10846 fp, conn, buf + *nread, bufsiz - *nread, request_timeout);; 10847 if (n == -2) {; 10848 /* Receive error */; 10849 return -1;; 10850 }; 10851 ; 10852 /* update clock after every read request */; 10853 clock_gettime(CLOCK_MONOTONIC, &last_action_time);; 10854 ; 10855 if (n > 0) {; 10856 *nread += n;; 10857 request_len = get_http_header_len(buf, *nread);; 10858 }; 10859 ; 10860 if ((request_len == 0) && (request_timeout >= 0)) {; 10861 if (mg_difftimespec(&last_action_time, &(conn->req_time)); 10862 > request_timeout) {; 10863 /* Timeout */; 10864 return -1;; 10865 }; 10866 }; 10867 }; 10868 ; 10869 return request_len;; 10870}; 10871 ; 10872 ; 10873#if !defined(NO_CGI) || !defined(NO_FILES); 10874static int; 10875forward_body_data(struct mg_connection *conn, FILE *fp, SOCKET sock, SSL *ssl); 10876{; 10877 const char *expect;; 10878 char buf[MG_BUF_LEN];; 10879 int success = 0;; 10880 ; 10881 if (!conn) {; 10882 return 0;; 10883 }; 10884 ; 10885 expect = mg_get_header(conn, ""Expect"");; 10886 DEBUG_ASSERT(fp != NULL);; 10887 if (!fp) {; 10888 mg_send_http_error(conn, 500, ""%s"", ""Error: NULL File"");; 10889 return 0;; 10890 }; 10891 ; 10892 if ((expect != NULL) && (mg_strcasecmp(expect, ""100-continue"") != 0)) {; 10893 /* Client sent an ""Expect: xyz"" header and xyz is not 100-continue.; 10894 */; 10895 mg_send_http_error(conn, 417, ""Error: Can not fulfill expectation"");; 10896 } else {; 10897 if (expect != NULL) {; 10898 (void)mg_printf(conn, ""%s"", ""HTTP/1.1 100 Continue\r\n\r\n"");; 10899 conn->status_code = 100;; 10900 } else {; 10901 conn->status",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:312619,Timeout,Timeout,312619,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['Timeout'],['Timeout']
Safety,"000.0;; 10829 }; 10830 }; 10831 ; 10832 request_len = get_http_header_len(buf, *nread);; 10833 ; 10834 while (request_len == 0) {; 10835 /* Full request not yet received */; 10836 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 10837 /* Server is to be stopped. */; 10838 return -1;; 10839 }; 10840 ; 10841 if (*nread >= bufsiz) {; 10842 /* Request too long */; 10843 return -2;; 10844 }; 10845 ; 10846 n = pull_inner(; 10847 fp, conn, buf + *nread, bufsiz - *nread, request_timeout);; 10848 if (n == -2) {; 10849 /* Receive error */; 10850 return -1;; 10851 }; 10852 ; 10853 /* update clock after every read request */; 10854 clock_gettime(CLOCK_MONOTONIC, &last_action_time);; 10855 ; 10856 if (n > 0) {; 10857 *nread += n;; 10858 request_len = get_http_header_len(buf, *nread);; 10859 }; 10860 ; 10861 if ((request_len == 0) && (request_timeout >= 0)) {; 10862 if (mg_difftimespec(&last_action_time, &(conn->req_time)); 10863 > request_timeout) {; 10864 /* Timeout */; 10865 return -1;; 10866 }; 10867 }; 10868 }; 10869 ; 10870 return request_len;; 10871}; 10872 ; 10873 ; 10874#if !defined(NO_CGI) || !defined(NO_FILES); 10875static int; 10876forward_body_data(struct mg_connection *conn, FILE *fp, SOCKET sock, SSL *ssl); 10877{; 10878 const char *expect;; 10879 char buf[MG_BUF_LEN];; 10880 int success = 0;; 10881 ; 10882 if (!conn) {; 10883 return 0;; 10884 }; 10885 ; 10886 expect = mg_get_header(conn, ""Expect"");; 10887 DEBUG_ASSERT(fp != NULL);; 10888 if (!fp) {; 10889 mg_send_http_error(conn, 500, ""%s"", ""Error: NULL File"");; 10890 return 0;; 10891 }; 10892 ; 10893 if ((expect != NULL) && (mg_strcasecmp(expect, ""100-continue"") != 0)) {; 10894 /* Client sent an ""Expect: xyz"" header and xyz is not 100-continue.; 10895 */; 10896 mg_send_http_error(conn, 417, ""Error: Can not fulfill expectation"");; 10897 } else {; 10898 if (expect != NULL) {; 10899 (void)mg_printf(conn, ""%s"", ""HTTP/1.1 100 Continue\r\n\r\n"");; 10900 conn->status_code = 100;; 10901 } else {; 10902 conn->status",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:312652,Timeout,Timeout,312652,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['Timeout'],['Timeout']
Safety,"00;; 5199 tv.tv_usec = (milliseconds % 1000) * 1000;; 5200 FD_ZERO(&rset);; 5201 FD_ZERO(&wset);; 5202 FD_ZERO(&eset);; 5203 ; 5204 for (i = 0; i < n; i++) {; 5205 if (pfd[i].events & (POLLIN | POLLOUT | POLLERR)) {; 5206 if (pfd[i].events & POLLIN) {; 5207 FD_SET(pfd[i].fd, &rset);; 5208 }; 5209 if (pfd[i].events & POLLOUT) {; 5210 FD_SET(pfd[i].fd, &wset);; 5211 }; 5212 /* Check for errors for any FD in the set */; 5213 FD_SET(pfd[i].fd, &eset);; 5214 }; 5215 pfd[i].revents = 0;; 5216 ; 5217 if (pfd[i].fd > maxfd) {; 5218 maxfd = pfd[i].fd;; 5219 }; 5220 }; 5221 ; 5222 if ((result = select((int)maxfd + 1, &rset, &wset, &eset, &tv)) > 0) {; 5223 for (i = 0; i < n; i++) {; 5224 if (FD_ISSET(pfd[i].fd, &rset)) {; 5225 pfd[i].revents |= POLLIN;; 5226 }; 5227 if (FD_ISSET(pfd[i].fd, &wset)) {; 5228 pfd[i].revents |= POLLOUT;; 5229 }; 5230 if (FD_ISSET(pfd[i].fd, &eset)) {; 5231 pfd[i].revents |= POLLERR;; 5232 }; 5233 }; 5234 }; 5235 ; 5236 /* We should subtract the time used in select from remaining; 5237 * ""milliseconds"", in particular if called from mg_poll with a; 5238 * timeout quantum.; 5239 * Unfortunately, the remaining time is not stored in ""tv"" in all; 5240 * implementations, so the result in ""tv"" must be considered undefined.; 5241 * See http://man7.org/linux/man-pages/man2/select.2.html */; 5242 ; 5243 return result;; 5244}; 5245#endif /* HAVE_POLL */; 5246 ; 5247 ; 5248#if defined(GCC_DIAGNOSTIC); 5249/* Enable unused function warning again */; 5250#pragma GCC diagnostic pop; 5251#endif; 5252 ; 5253 ; 5254static void; 5255set_close_on_exec(SOCKET sock,; 5256 const struct mg_connection *conn /* may be null */,; 5257 struct mg_context *ctx /* may be null */); 5258{; 5259 (void)conn; /* Unused. */; 5260 (void)ctx;; 5261 ; 5262 (void)SetHandleInformation((HANDLE)(intptr_t)sock, HANDLE_FLAG_INHERIT, 0);; 5263}; 5264 ; 5265 ; 5266int; 5267mg_start_thread(mg_thread_func_t f, void *p); 5268{; 5269#if defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1); 5270 /* Compile",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:155810,timeout,timeout,155810,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"00;; 5200 tv.tv_usec = (milliseconds % 1000) * 1000;; 5201 FD_ZERO(&rset);; 5202 FD_ZERO(&wset);; 5203 FD_ZERO(&eset);; 5204 ; 5205 for (i = 0; i < n; i++) {; 5206 if (pfd[i].events & (POLLIN | POLLOUT | POLLERR)) {; 5207 if (pfd[i].events & POLLIN) {; 5208 FD_SET(pfd[i].fd, &rset);; 5209 }; 5210 if (pfd[i].events & POLLOUT) {; 5211 FD_SET(pfd[i].fd, &wset);; 5212 }; 5213 /* Check for errors for any FD in the set */; 5214 FD_SET(pfd[i].fd, &eset);; 5215 }; 5216 pfd[i].revents = 0;; 5217 ; 5218 if (pfd[i].fd > maxfd) {; 5219 maxfd = pfd[i].fd;; 5220 }; 5221 }; 5222 ; 5223 if ((result = select((int)maxfd + 1, &rset, &wset, &eset, &tv)) > 0) {; 5224 for (i = 0; i < n; i++) {; 5225 if (FD_ISSET(pfd[i].fd, &rset)) {; 5226 pfd[i].revents |= POLLIN;; 5227 }; 5228 if (FD_ISSET(pfd[i].fd, &wset)) {; 5229 pfd[i].revents |= POLLOUT;; 5230 }; 5231 if (FD_ISSET(pfd[i].fd, &eset)) {; 5232 pfd[i].revents |= POLLERR;; 5233 }; 5234 }; 5235 }; 5236 ; 5237 /* We should subtract the time used in select from remaining; 5238 * ""milliseconds"", in particular if called from mg_poll with a; 5239 * timeout quantum.; 5240 * Unfortunately, the remaining time is not stored in ""tv"" in all; 5241 * implementations, so the result in ""tv"" must be considered undefined.; 5242 * See http://man7.org/linux/man-pages/man2/select.2.html */; 5243 ; 5244 return result;; 5245}; 5246#endif /* HAVE_POLL */; 5247 ; 5248 ; 5249#if defined(GCC_DIAGNOSTIC); 5250/* Enable unused function warning again */; 5251#pragma GCC diagnostic pop; 5252#endif; 5253 ; 5254 ; 5255static void; 5256set_close_on_exec(SOCKET sock,; 5257 const struct mg_connection *conn /* may be null */,; 5258 struct mg_context *ctx /* may be null */); 5259{; 5260 (void)conn; /* Unused. */; 5261 (void)ctx;; 5262 ; 5263 (void)SetHandleInformation((HANDLE)(intptr_t)sock, HANDLE_FLAG_INHERIT, 0);; 5264}; 5265 ; 5266 ; 5267int; 5268mg_start_thread(mg_thread_func_t f, void *p); 5269{; 5270#if defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1); 5271 /* Compile",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:155842,timeout,timeout,155842,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"02 case TVirtualStreamerInfo::kUInt: sequence->AddAction( WriteBasicTypeGenericLoop<UInt_t>, new TConfiguration(info,i,compinfo,offset) ); break;; 4103 case TVirtualStreamerInfo::kULong: sequence->AddAction( WriteBasicTypeGenericLoop<ULong_t>, new TConfiguration(info,i,compinfo,offset) ); break;; 4104 case TVirtualStreamerInfo::kULong64: sequence->AddAction( WriteBasicTypeGenericLoop<ULong64_t>, new TConfiguration(info,i,compinfo,offset) ); break;; 4105 // case TVirtualStreamerInfo::kBits: sequence->AddAction( WriteBasicTypeGenericLoop<BitsMarker>, new TConfiguration(info,i,compinfo,offset) ); break;; 4106 case TVirtualStreamerInfo::kFloat16: {; 4107 if (element->GetFactor() != 0) {; 4108 sequence->AddAction( GenericLooper<WriteBasicType_WithFactor<float> >, new TConfWithFactor(info,i,compinfo,offset,element->GetFactor(),element->GetXmin()) );; 4109 } else {; 4110 Int_t nbits = (Int_t)element->GetXmin();; 4111 if (!nbits) nbits = 12;; 4112 sequence->AddAction( GenericLooper<WriteBasicType_NoFactor<float> >, new TConfNoFactor(info,i,compinfo,offset,nbits) );; 4113 }; 4114 break;; 4115 }; 4116 case TVirtualStreamerInfo::kDouble32: {; 4117 if (element->GetFactor() != 0) {; 4118 sequence->AddAction( GenericLooper<WriteBasicType_WithFactor<double> >, new TConfWithFactor(info,i,compinfo,offset,element->GetFactor(),element->GetXmin()) );; 4119 } else {; 4120 Int_t nbits = (Int_t)element->GetXmin();; 4121 if (!nbits) {; 4122 sequence->AddAction( GenericLooper<ConvertBasicType<float,double> >, new TConfiguration(info,i,compinfo,offset) );; 4123 } else {; 4124 sequence->AddAction( GenericLooper<WriteBasicType_NoFactor<double> >, new TConfNoFactor(info,i,compinfo,offset,nbits) );; 4125 }; 4126 }; 4127 break;; 4128 }; 4129 case TVirtualStreamerInfo::kTNamed: sequence->AddAction( GenericLooper<WriteTNamed >, new TConfiguration(info,i,compinfo,offset) ); break;; 4130 // Idea: We should calculate the CanIgnoreTObjectStreamer here and avoid calling the; 4131 // Streamer alltogether.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:194466,avoid,avoid,194466,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['avoid'],['avoid']
Safety,"05 }; 3006 }; 3007 if (oldName.IsNull() ) {; 3008 Error(""SetParName"",""Parameter %d is not existing."",ipar);; 3009 return;; 3010 }; 3011 ; 3012 //replace also parameter name in formula expression in case is not a lambda; 3013 if (! TestBit(TFormula::kLambda)) ReplaceParamName(fFormula, oldName, name);; 3014 ; 3015}; 3016 ; 3017////////////////////////////////////////////////////////////////////////////////; 3018/// Replace in Formula expression the parameter name.; 3019 ; 3020void TFormula::ReplaceParamName(TString & formula, const TString & oldName, const TString & name){; 3021 if (!formula.IsNull() ) {; 3022 bool found = false;; 3023 for(list<TFormulaFunction>::iterator it = fFuncs.begin(); it != fFuncs.end(); ++it); 3024 {; 3025 if (oldName == it->GetName()) {; 3026 found = true;; 3027 it->fName = name;; 3028 break;; 3029 }; 3030 }; 3031 if (!found) {; 3032 Error(""SetParName"", ""Parameter %s is not defined."", oldName.Data());; 3033 return;; 3034 }; 3035 // change whitespace to \s to avoid problems in parsing; 3036 TString newName = name;; 3037 newName.ReplaceAll("" "", ""\\s"");; 3038 TString pattern = TString::Format(""[%s]"", oldName.Data());; 3039 TString replacement = TString::Format(""[%s]"", newName.Data());; 3040 formula.ReplaceAll(pattern, replacement);; 3041 }; 3042 ; 3043}; 3044 ; 3045////////////////////////////////////////////////////////////////////////////////; 3046void TFormula::SetVectorized(Bool_t vectorized); 3047{; 3048#ifdef R__HAS_VECCORE; 3049 if (fNdim == 0) {; 3050 Info(""SetVectorized"",""Cannot vectorized a function of zero dimension"");; 3051 return;; 3052 }; 3053 if (vectorized != fVectorized) {; 3054 if (!fFormula); 3055 Error(""SetVectorized"", ""Cannot set vectorized to %d -- Formula is missing"", vectorized);; 3056 ; 3057 fVectorized = vectorized;; 3058 // no need to JIT a new signature in case of zero dimension; 3059 //if (fNdim== 0) return;; 3060 fClingInitialized = false;; 3061 fReadyToExecute = false;; 3062 fClingName = """";; 3063 fClingInput = fF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:115943,avoid,avoid,115943,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['avoid'],['avoid']
Safety,"059 if (err == WSAEWOULDBLOCK) {; 6060 err = 0;; 6061 n = 0;; 6062 }; 6063#else; 6064 if (ERROR_TRY_AGAIN(err)) {; 6065 err = 0;; 6066 n = 0;; 6067 }; 6068#endif; 6069 if (n < 0) {; 6070 /* shutdown of the socket at client side */; 6071 return -2;; 6072 }; 6073 }; 6074 ; 6075 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6076 return -2;; 6077 }; 6078 ; 6079 if ((n > 0) || ((n == 0) && (len == 0))) {; 6080 /* some data has been read, or no data was requested */; 6081 return n;; 6082 }; 6083 if (n < 0) {; 6084 /* socket error - check errno */; 6085 DEBUG_TRACE(""send() failed, error %d"", err);; 6086 ; 6087 /* TODO (mid): error handling depending on the error code.; 6088 * These codes are different between Windows and Linux.; 6089 * Currently there is no problem with failing send calls,; 6090 * if there is a reproducible situation, it should be; 6091 * investigated in detail.; 6092 */; 6093 return -2;; 6094 }; 6095 ; 6096 /* Only in case n=0 (timeout), repeat calling the write function */; 6097 ; 6098 /* If send failed, wait before retry */; 6099 if (fp != NULL) {; 6100 /* For files, just wait a fixed time.; 6101 * Maybe it helps, maybe not. */; 6102 mg_sleep(5);; 6103 } else {; 6104 /* For sockets, wait for the socket using poll */; 6105 struct mg_pollfd pfd[1];; 6106 int pollres;; 6107 ; 6108 pfd[0].fd = sock;; 6109 pfd[0].events = POLLOUT;; 6110 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6111 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6112 return -2;; 6113 }; 6114 if (pollres > 0) {; 6115 continue;; 6116 }; 6117 }; 6118 ; 6119 if (timeout > 0) {; 6120 now = mg_get_current_time_ns();; 6121 if ((now - start) > timeout_ns) {; 6122 /* Timeout */; 6123 break;; 6124 }; 6125 }; 6126 }; 6127 ; 6128 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6129 used */; 6130 ; 6131 return -1;; 6132}; 6133 ; 6134 ; 6135static int; 6136push_all(struct mg_context *ctx,; 6137 FILE *fp,; 6138 SOCKET sock,; 6139 SSL *ssl,; 6140 const char *buf,;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:178204,timeout,timeout,178204,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"060 if (err == WSAEWOULDBLOCK) {; 6061 err = 0;; 6062 n = 0;; 6063 }; 6064#else; 6065 if (ERROR_TRY_AGAIN(err)) {; 6066 err = 0;; 6067 n = 0;; 6068 }; 6069#endif; 6070 if (n < 0) {; 6071 /* shutdown of the socket at client side */; 6072 return -2;; 6073 }; 6074 }; 6075 ; 6076 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6077 return -2;; 6078 }; 6079 ; 6080 if ((n > 0) || ((n == 0) && (len == 0))) {; 6081 /* some data has been read, or no data was requested */; 6082 return n;; 6083 }; 6084 if (n < 0) {; 6085 /* socket error - check errno */; 6086 DEBUG_TRACE(""send() failed, error %d"", err);; 6087 ; 6088 /* TODO (mid): error handling depending on the error code.; 6089 * These codes are different between Windows and Linux.; 6090 * Currently there is no problem with failing send calls,; 6091 * if there is a reproducible situation, it should be; 6092 * investigated in detail.; 6093 */; 6094 return -2;; 6095 }; 6096 ; 6097 /* Only in case n=0 (timeout), repeat calling the write function */; 6098 ; 6099 /* If send failed, wait before retry */; 6100 if (fp != NULL) {; 6101 /* For files, just wait a fixed time.; 6102 * Maybe it helps, maybe not. */; 6103 mg_sleep(5);; 6104 } else {; 6105 /* For sockets, wait for the socket using poll */; 6106 struct mg_pollfd pfd[1];; 6107 int pollres;; 6108 ; 6109 pfd[0].fd = sock;; 6110 pfd[0].events = POLLOUT;; 6111 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6112 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6113 return -2;; 6114 }; 6115 if (pollres > 0) {; 6116 continue;; 6117 }; 6118 }; 6119 ; 6120 if (timeout > 0) {; 6121 now = mg_get_current_time_ns();; 6122 if ((now - start) > timeout_ns) {; 6123 /* Timeout */; 6124 break;; 6125 }; 6126 }; 6127 }; 6128 ; 6129 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6130 used */; 6131 ; 6132 return -1;; 6133}; 6134 ; 6135 ; 6136static int; 6137push_all(struct mg_context *ctx,; 6138 FILE *fp,; 6139 SOCKET sock,; 6140 SSL *ssl,; 6141 const char *buf,;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:178236,timeout,timeout,178236,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"06{; 507 if (gGeoManager != this); 508 gGeoManager = this;; 509 fIsGeomCleaning = kTRUE;; 510 ; 511 if (gROOT->GetListOfFiles()) { // in case this function is called from TROOT destructor; 512 gROOT->GetListOfGeometries()->Remove(this);; 513 gROOT->GetListOfBrowsables()->Remove(this);; 514 }; 515 // TSeqCollection *brlist = gROOT->GetListOfBrowsers();; 516 // TIter next(brlist);; 517 // TBrowser *browser = 0;; 518 // while ((browser=(TBrowser*)next())) browser->RecursiveRemove(this);; 519 ClearThreadsMap();; 520 ClearThreadData();; 521 delete TGeoBuilder::Instance(this);; 522 if (fBits); 523 delete[] fBits;; 524 SafeDelete(fNodes);; 525 SafeDelete(fTopNode);; 526 if (fOverlaps) {; 527 fOverlaps->Delete();; 528 SafeDelete(fOverlaps);; 529 }; 530 if (fRegions) {; 531 fRegions->Delete();; 532 SafeDelete(fRegions);; 533 }; 534 if (fMaterials) {; 535 fMaterials->Delete();; 536 SafeDelete(fMaterials);; 537 }; 538 SafeDelete(fElementTable);; 539 if (fMedia) {; 540 fMedia->Delete();; 541 SafeDelete(fMedia);; 542 }; 543 if (fHashVolumes) {; 544 fHashVolumes->Clear(""nodelete"");; 545 SafeDelete(fHashVolumes);; 546 }; 547 if (fHashGVolumes) {; 548 fHashGVolumes->Clear(""nodelete"");; 549 SafeDelete(fHashGVolumes);; 550 }; 551 if (fHashPNE) {; 552 fHashPNE->Delete();; 553 SafeDelete(fHashPNE);; 554 }; 555 if (fArrayPNE) {; 556 delete fArrayPNE;; 557 }; 558 if (fVolumes) {; 559 fVolumes->Delete();; 560 SafeDelete(fVolumes);; 561 }; 562 if (fShapes) {; 563 fShapes->Delete();; 564 SafeDelete(fShapes);; 565 }; 566 if (fPhysicalNodes) {; 567 fPhysicalNodes->Delete();; 568 SafeDelete(fPhysicalNodes);; 569 }; 570 if (fMatrices) {; 571 fMatrices->Delete();; 572 SafeDelete(fMatrices);; 573 }; 574 if (fTracks) {; 575 fTracks->Delete();; 576 SafeDelete(fTracks);; 577 }; 578 SafeDelete(fUniqueVolumes);; 579 if (fPdgNames) {; 580 fPdgNames->Delete();; 581 SafeDelete(fPdgNames);; 582 }; 583 if (fGDMLMatrices) {; 584 fGDMLMatrices->Delete();; 585 SafeDelete(fGDMLMatrices);; 586 }; 587 if (fOptica",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:21813,Safe,SafeDelete,21813,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,"06{; 9807 if (this != &rhs) {; 9808 fDirection = rhs.fDirection;; 9809 }; 9810 return *this;; 9811}; 9812 ; 9813////////////////////////////////////////////////////////////////////////////////; 9814/// Go the next friend element; 9815 ; 9816TObject* TTreeFriendLeafIter::Next(); 9817{; 9818 if (!fTree) return nullptr;; 9819 ; 9820 TObject * next;; 9821 TTree * nextTree;; 9822 ; 9823 if (!fLeafIter) {; 9824 TObjArray *list = fTree->GetListOfLeaves();; 9825 if (!list) return nullptr; // Can happen with an empty chain.; 9826 fLeafIter = list->MakeIterator(fDirection);; 9827 if (!fLeafIter) return nullptr;; 9828 }; 9829 ; 9830 next = fLeafIter->Next();; 9831 if (!next) {; 9832 if (!fTreeIter) {; 9833 TCollection * list = fTree->GetListOfFriends();; 9834 if (!list) return next;; 9835 fTreeIter = list->MakeIterator(fDirection);; 9836 if (!fTreeIter) return nullptr;; 9837 }; 9838 TFriendElement * nextFriend = (TFriendElement*) fTreeIter->Next();; 9839 ///nextTree = (TTree*)fTreeIter->Next();; 9840 if (nextFriend) {; 9841 nextTree = const_cast<TTree*>(nextFriend->GetTree());; 9842 if (!nextTree) return Next();; 9843 SafeDelete(fLeafIter);; 9844 fLeafIter = nextTree->GetListOfLeaves()->MakeIterator(fDirection);; 9845 if (!fLeafIter) return nullptr;; 9846 next = fLeafIter->Next();; 9847 }; 9848 }; 9849 return next;; 9850}; 9851 ; 9852////////////////////////////////////////////////////////////////////////////////; 9853/// Returns the object option stored in the list.; 9854 ; 9855Option_t* TTreeFriendLeafIter::GetOption() const; 9856{; 9857 if (fLeafIter) return fLeafIter->GetOption();; 9858 return """";; 9859}; RConfig.hxx; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:377767,Safe,SafeDelete,377767,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,"08 if (!nbytes) {; 1609 Printf(""Address = %lld\tNbytes = %d\t=====E R R O R======="", idcur, nbytes);; 1610 date = 0; time = 0;; 1611 break;; 1612 }; 1613 if (nbytes < 0) {; 1614 Printf(""Address = %lld\tNbytes = %d\t=====G A P==========="", idcur, nbytes);; 1615 idcur -= nbytes;; 1616 Seek(idcur);; 1617 continue;; 1618 }; 1619 Version_t versionkey;; 1620 frombuf(buffer, &versionkey);; 1621 frombuf(buffer, &objlen);; 1622 frombuf(buffer, &datime);; 1623 frombuf(buffer, &keylen);; 1624 frombuf(buffer, &cycle);; 1625 if (versionkey > 1000) {; 1626 frombuf(buffer, &seekkey);; 1627 frombuf(buffer, &seekpdir);; 1628 } else {; 1629 Int_t skey,sdir;; 1630 frombuf(buffer, &skey); seekkey = (Long64_t)skey;; 1631 frombuf(buffer, &sdir); seekpdir = (Long64_t)sdir;; 1632 }; 1633 frombuf(buffer, &nwhc);; 1634 if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of the key we have read.; 1635 nwhc = nwheader - (buffer-header);; 1636 for (int i = 0;i < nwhc; i++) frombuf(buffer, &classname[i]);; 1637 classname[(int)nwhc] = '\0'; //cast to avoid warning with gcc3.4; 1638 if (idcur == fSeekFree) strlcpy(classname,""FreeSegments"",512);; 1639 if (idcur == fSeekInfo) strlcpy(classname,""StreamerInfo"",512);; 1640 if (idcur == fSeekKeys) strlcpy(classname,""KeysList"",512);; 1641 ; 1642 if (extended) {; 1643 if ( (buffer-header) >= nwheader ); 1644 nwhc = 0;; 1645 else {; 1646 frombuf(buffer, &nwhc);; 1647 if (nwhc < 0); 1648 nwhc = 0;; 1649 else if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of the key we have read.; 1650 nwhc = nwheader - (buffer-header);; 1651 }; 1652 for (int i = 0;i < nwhc; i++) frombuf(buffer, &keyname[i]);; 1653 keyname[(int)nwhc] = '\0'; //cast to avoid warning with gcc3.4; 1654 ; 1655 if ( (buffer-header) >= nwheader ); 1656 nwhc = 0;; 1657 else {; 1658 frombuf(buffer, &nwhc);; 1659 if (nwhc < 0); 1660 nwhc = 0;; 1661 else if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:59617,avoid,avoid,59617,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['avoid'],['avoid']
Safety,"0] PROGRESS:Caching -- current storage has size 10; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf_over_wrap_pdf_Int[pTV]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_wrap_pdf_over_wrap_pdf_Int[pTV]_pseudo_dh) Summation contains a RooNLLVar, using its error level; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0 cHl3=0 cHq3=-0.0202918; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.213672 cHl3=1.97898 cHq3=0.00773174; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLogVal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:8740,recover,recover,8740,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,"1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, const TClass* cl, Int_t compact = 0); converts any type of object to JSON string; following values of compact; 0 - no any compression; 1 - exclude spaces in the begin; 2 - remove newlines; 3 - exclude spaces as much as possible. TString ConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0); converts selected data member into json. TString JsonWriteMember(const void* ptr, TDataMember* member, TClass* memberClass); Convert single data member to JSON structures; Returns string with converted member. Bool_t CheckObject(const TObject* ); Check that object already stored in the buffer. Bool_t CheckObject(const void* , const TClass* ); Check that object already stored in the buffer. void WriteObject(const TObject* obj); Convert object into json structures.; !!! Should be used only by TBufferJSON itself.; Use ConvertToJSON() methods to convert object to json; Redefined here to avoid gcc 3.x warning. TJSONStackObj * PushStack(Int_t inclevel = 0); add new level to the structures stack. TJSONStackObj * PopStack(); remove one level from stack. TJSONStackObj * Stack(Int_t depth = 0); return stack object of specified depth. void AppendOutput(const char* line0, const char* line1 = 0); Info(""AppendOutput"","" '%s' '%s'"", line0, line1?line1 : ""---"");. void JsonStartElement(const TStreamerElement* elem, const TClass* base_class = 0). void JsonDisablePostprocessing(). Int_t JsonSpecialClass(const TClass* cl) const; return non-zero value when class has special handling in JSON; it is TCollection (-130), TArray (100), TString (110), std::string (120) and STL containers (1..6). void JsonWriteObject(const void* obj, const TClass* objClass, Bool_t check_map = kTRUE); Write object to buffer; If object was written before, only pointer will be stored; If check_map==kFALSE, object will be stored in any case and pointer will not be registered in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBufferJSON.html:21993,avoid,avoid,21993,root/html602/TBufferJSON.html,https://root.cern,https://root.cern/root/html602/TBufferJSON.html,2,['avoid'],['avoid']
Safety,"1 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6429 ; 6430 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6431 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6432 if (n == -2) {; 6433 if (nread == 0) {; 6434 nread = -1; /* Propagate the error */; 6435 }; 6436 break;; 6437 } else if (n == -1) {; 6438 /* timeout */; 6439 if (timeout >= 0.0) {; 6440 now = mg_get_current_time_ns();; 6441 if ((now - start_time) <= timeout_ns) {; 6442 continue;; 6443 }; 6444 }; 6445 break;; 6446 } else if (n == 0) {; 6447 break; /* No more data to read */; 6448 } else {; 6449 nread += n;; 6450 len -= n;; 6451 }; 6452 }; 6453 ; 6454 return nread;; 6455}; 6456 ; 6457 ; 6458static void; 6459discard_unread_request_data(struct mg_connection *conn); 6460{; 6461 char buf[MG_BUF_LEN];; 6462 ; 6463 while (mg_read(conn, buf, sizeof(buf)) > 0); 6464 ;; 6465}; 6466 ; 646",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:187167,timeout,timeout,187167,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"1 Data()->SetCurrentEvent(ievt);; 1912 size_t nVariables = GetEvent()->GetNVariables();; 1913 ; 1914 if (n1 == batchSize && n0 == 1) {; 1915 if (n2 != nVariables) {; 1916 Log() << kFATAL << ""Input Event variable dimensions are not compatible with the built network architecture""; 1917 << "" n-event variables "" << nVariables << "" expected input matrix "" << n1 << "" x "" << n2; 1918 << Endl;; 1919 }; 1920 } else {; 1921 if (n1*n2 != nVariables || n0 != batchSize) {; 1922 Log() << kFATAL << ""Input Event variable dimensions are not compatible with the built network architecture""; 1923 << "" n-event variables "" << nVariables << "" expected input tensor "" << n0 << "" x "" << n1 << "" x "" << n2; 1924 << Endl;; 1925 }; 1926 }; 1927 }; 1928 ; 1929 auto batch = testData.GetTensorBatch();; 1930 auto inputTensor = batch.GetInput();; 1931 ; 1932 auto xInput = batch.GetInput();; 1933 // make the prediction; 1934 deepNet.Prediction(yHat, xInput, fOutputFunction);; 1935 for (size_t i = 0; i < batchSize; ++i) {; 1936 double value = yHat(i,0);; 1937 mvaValues[ievt + i] = (TMath::IsNaN(value)) ? -999. : value;; 1938 }; 1939 }; 1940 else {; 1941 // case of remaining events: compute prediction by single event !; 1942 for (Long64_t i = ievt; i < lastEvt; ++i) {; 1943 Data()->SetCurrentEvent(i);; 1944 mvaValues[i] = GetMvaValue();; 1945 }; 1946 }; 1947 }; 1948 ; 1949 if (logProgress) {; 1950 Log() << kINFO; 1951 << ""Elapsed time for evaluation of "" << nEvents << "" events: ""; 1952 << timer.GetElapsedTime() << "" "" << Endl;; 1953 }; 1954 ; 1955 return mvaValues;; 1956}; 1957 ; 1958//////////////////////////////////////////////////////////////////////////; 1959/// Get the regression output values for a single event; 1960//////////////////////////////////////////////////////////////////////////; 1961const std::vector<Float_t> & TMVA::MethodDL::GetRegressionValues(); 1962{; 1963 ; 1964 FillInputTensor ();; 1965 ; 1966 // perform the network prediction; 1967 fNet->Prediction(*fYHat, fXInput, fOutputFuncti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:77158,Predict,Prediction,77158,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['Predict'],['Prediction']
Safety,"1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps. Graphical Checking Methods. Safety computation checking; In order to check a given point, CheckPoint(x,y,z) method of TGeoManager draws the daughters of the volume containing the point one level down, printing the path to the deepest physical node holding ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:103881,detect,detected,103881,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['detect'],['detected']
Safety,"1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps.; 18.6.2 Graphical Checking Methods. Safety computation checking. In order to check a given point, CheckPoint(x,y,z) method of TGeoManager draws the daughters of the volume containing the point one level down, printing the path to the deepest physical node ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1002706,detect,detected,1002706,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detected']
Safety,"1"", -0.5, -10., 20.);; RooRealVar a2(""a2"", ""a2"", 0.2, -10., 20.);; RooRealVar a3(""a3"", ""a3"", 0.01);; RooPolynomial pdf(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, RooArgSet(a1, a2, a3));; ; // Create toy data with all-positive coefficients:; std::unique_ptr<RooDataSet> data(pdf.generate(x, 10000));; ; // For plotting.; // We create pointers to the plotted objects. We want these objects to leak out of the function,; // so we can still see them after it returns.; TCanvas* c = new TCanvas();; RooPlot* frame = x.frame();; data->plotOn(frame, RooFit::Name(""data""));; ; // Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; // Therefore, we disable plotting messages in RooFit's message streams:; RooMsgService::instance().getStream(0).removeTopic(RooFit::Plotting);; RooMsgService::instance().getStream(1).removeTopic(RooFit::Plotting);; ; ; // RooFit before ROOT 6.24; // --------------------------------; // Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; // the starting values of the parameters without finding any improvement.; ; // Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Perform a fit:; std::unique_ptr<RooFitResult> fitWithoutRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::end",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:3286,recover,recover,3286,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,1,['recover'],['recover']
Safety,"1) >= 1) {; 2182 Warning(""Chi2TestX"",""First histogram is not unweighted and option UW has been requested"");; 2183 }; 2184 }; 2185 if ( (!scaledHistogram && comparisonUU) ) {; 2186 if ( ( TMath::Abs(sumBinContent1 - effEntries1) >= 1) || (TMath::Abs(sumBinContent2 - effEntries2) >= 1) ) {; 2187 Warning(""Chi2TestX"",""Both histograms are not unweighted and option UU has been requested"");; 2188 }; 2189 }; 2190 ; 2191 ; 2192 //get number of events in histogram; 2193 if (comparisonUU && scaledHistogram) {; 2194 for (Int_t i = i_start; i <= i_end; ++i) {; 2195 for (Int_t j = j_start; j <= j_end; ++j) {; 2196 for (Int_t k = k_start; k <= k_end; ++k) {; 2197 ; 2198 Int_t bin = GetBin(i, j, k);; 2199 ; 2200 Double_t cnt1 = RetrieveBinContent(bin);; 2201 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2202 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2203 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2204 ; 2205 if (e1sq > 0.0) cnt1 = TMath::Floor(cnt1 * cnt1 / e1sq + 0.5); // avoid rounding errors; 2206 else cnt1 = 0.0;; 2207 ; 2208 if (e2sq > 0.0) cnt2 = TMath::Floor(cnt2 * cnt2 / e2sq + 0.5); // avoid rounding errors; 2209 else cnt2 = 0.0;; 2210 ; 2211 // sum contents; 2212 sum1 += cnt1;; 2213 sum2 += cnt2;; 2214 sumw1 += e1sq;; 2215 sumw2 += e2sq;; 2216 }; 2217 }; 2218 }; 2219 if (sumw1 <= 0.0 || sumw2 <= 0.0) {; 2220 Error(""Chi2TestX"", ""Cannot use option NORM when one histogram has all zero errors"");; 2221 return 0.0;; 2222 }; 2223 ; 2224 } else {; 2225 for (Int_t i = i_start; i <= i_end; ++i) {; 2226 for (Int_t j = j_start; j <= j_end; ++j) {; 2227 for (Int_t k = k_start; k <= k_end; ++k) {; 2228 ; 2229 Int_t bin = GetBin(i, j, k);; 2230 ; 2231 sum1 += RetrieveBinContent(bin);; 2232 sum2 += h2->RetrieveBinContent(bin);; 2233 ; 2234 if ( comparisonWW ) sumw1 += GetBinErrorSqUnchecked(bin);; 2235 if ( comparisonUW || comparisonWW ) sumw2 += h2->GetBinErrorSqUnchecked(bin);; 2236 }; 2237 }; 2238 }; 2239 }; 2240 //checks that the histograms are not empty; 2241 if (sum1 == 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:89535,avoid,avoid,89535,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['avoid'],['avoid']
Safety,"1)); ROOT::Experimental::ENTupleStructureENTupleStructureThe fields in the ntuple model tree can carry different structural information about the type system.Definition RNTupleUtil.hxx:112; ROOT::Experimental::kLeaf@ kLeafDefinition RNTupleUtil.hxx:112; ROOT::Experimental::kRecord@ kRecordDefinition RNTupleUtil.hxx:112; ROOT::Experimental::kUnknown@ kUnknownDefinition RNTupleUtil.hxx:112; ROOT::Experimental::kCollection@ kCollectionDefinition RNTupleUtil.hxx:112; ROOT::Experimental::kInvalid@ kInvalidDefinition RNTupleUtil.hxx:112; ROOT::Experimental::kStreamer@ kStreamerDefinition RNTupleUtil.hxx:112; ROOT::Experimental::kVariant@ kVariantDefinition RNTupleUtil.hxx:112; ROOT::Experimental::kInvalidDescriptorIdconstexpr DescriptorId_t kInvalidDescriptorIdDefinition RNTupleUtil.hxx:167; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::Experimental::RClusterSizeWrap the integer in a struct in order to avoid template specialization clash with std::uint64_t.Definition RNTupleUtil.hxx:118; ROOT::Experimental::RClusterSize::fValueValueType fValueDefinition RNTupleUtil.hxx:141; ROOT::Experimental::RClusterSize::operator++RClusterSize operator++(int)Definition RNTupleUtil.hxx:133; ROOT::Experimental::RClusterSize::operator=RClusterSize & operator=(const ValueType value)Definition RNTupleUtil.hxx:123; ROOT::Experimental::RClusterSize::RClusterSizeconstexpr RClusterSize(ValueType value)Definition RNTupleUtil.hxx:122; ROOT::Experimental::RClusterSize::ValueTypestd::uint64_t ValueTypeDefinition RNTupleUtil.hxx:119; ROOT::Experimental::RClusterSize::RClusterSizeRClusterSize()Definition RNTupleUtil.hxx:121; ROOT::Experimental::RClusterSize::operator+=RClusterSize & operator+=(const ValueType value)Definition RNTupleUtil.hxx:128; ROOT::Experimental::RNTupleLocatorObject64RNTupleLocator payload that is common for object stores using 64bit location information.Definition RNTupleUtil.hx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleUtil_8hxx_source.html:18204,avoid,avoid,18204,doc/master/RNTupleUtil_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleUtil_8hxx_source.html,1,['avoid'],['avoid']
Safety,"10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTube::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Int_tDistToHype(Double_t* point, Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoHype.html:3062,safe,safe,3062,root/html532/TGeoHype.html,https://root.cern,https://root.cern/root/html532/TGeoHype.html,1,['safe'],['safe']
Safety,"10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTube::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoEltu.html:2082,safe,safe,2082,root/html532/TGeoEltu.html,https://root.cern,https://root.cern/root/html532/TGeoEltu.html,1,['safe'],['safe']
Safety,"12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_handling = 1;; 12475 mg_set_thread_name(""wsock"");; 12476 ; 12477 /* Loop continuously, reading messages from the socket, invoking the; 12478 * callback, and waiting repeatedly until an error occurs. */; 12479 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12480 && (!conn->must_close)) {; 12481 header_len = 0;; 12482 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12483 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12484 len = buf[1] & 127;; 12485 mask_len = (buf[1] & 128) ? 4 : 0;; 12486 if ((len < 126) && (body_len >= mask_len)) {; 12487 /* inline 7-bit length field */; 12488 data_len = len;; 12489 header_len = 2 + ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:361550,timeout,timeout,361550,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_handling = 1;; 12476 mg_set_thread_name(""wsock"");; 12477 ; 12478 /* Loop continuously, reading messages from the socket, invoking the; 12479 * callback, and waiting repeatedly until an error occurs. */; 12480 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12481 && (!conn->must_close)) {; 12482 header_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1] & 128) ? 4 : 0;; 12487 if ((len < 126) && (body_len >= mask_len)) {; 12488 /* inline 7-bit length field */; 12489 data_len = len;; 12490 header_len = 2 + ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:361583,timeout,timeout,361583,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"14 //Note the following restrictions in the code generated:; 1615 // - variable bin size not implemented; 1616 // - SetErrorOption not implemented; 1617 ; 1618 Bool_t nonEqiX = kFALSE;; 1619 Int_t i;; 1620 // Check if the profile has equidistant X bins or not. If not, we; 1621 // create an array holding the bins.; 1622 if (GetXaxis()->GetXbins()->fN && GetXaxis()->GetXbins()->fArray) {; 1623 nonEqiX = kTRUE;; 1624 out << "" Double_t xAxis["" << GetXaxis()->GetXbins()->fN; 1625 << ""] = {"";; 1626 for (i = 0; i < GetXaxis()->GetXbins()->fN; i++) {; 1627 if (i != 0) out << "", "";; 1628 out << GetXaxis()->GetXbins()->fArray[i];; 1629 }; 1630 out << ""}; "" << std::endl;; 1631 }; 1632 ; 1633 char quote = '""';; 1634 out<<"" ""<<std::endl;; 1635 out<<"" ""<<ClassName()<<"" *"";; 1636 ; 1637 //histogram pointer has by default the histogram name.; 1638 //however, in case histogram has no directory, it is safer to add a incremental suffix; 1639 static Int_t hcounter = 0;; 1640 TString histName = gInterpreter->MapCppName(GetName());; 1641 if (!fDirectory) {; 1642 hcounter++;; 1643 histName += ""__"";; 1644 histName += hcounter;; 1645 }; 1646 const char *hname = histName.Data();; 1647 ; 1648 out << hname << "" = new "" << ClassName() << ""("" << quote << hname << quote << "","" << quote << GetTitle() << quote; 1649 << "","" << GetXaxis()->GetNbins();; 1650 if (nonEqiX); 1651 out << "", xAxis"";; 1652 else; 1653 out << "","" << GetXaxis()->GetXmin(); 1654 << "","" << GetXaxis()->GetXmax(); 1655 <<"",""<<quote<<GetErrorOption()<<quote<<"");""<<std::endl;; 1656 ; 1657 // save bin entries; 1658 Int_t bin;; 1659 for (bin=0;bin<fNcells;bin++) {; 1660 Double_t bi = GetBinEntries(bin);; 1661 if (bi) {; 1662 out<<"" ""<<hname<<""->SetBinEntries(""<<bin<<"",""<<bi<<"");""<<std::endl;; 1663 }; 1664 }; 1665 //save bin contents; 1666 for (bin=0;bin<fNcells;bin++) {; 1667 Double_t bc = fArray[bin];; 1668 if (bc) {; 1669 out<<"" ""<<hname<<""->SetBinContent(""<<bin<<"",""<<bc<<"");""<<std::endl;; 1670 }; 1671 }; 1672 // save bin errors; 167",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:60120,safe,safer,60120,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,1,['safe'],['safer']
Safety,"1456 oldcl->fMethod = nullptr;; 1457 ; 1458 }; 1459 ; 1460 SetBit(kLoading);; 1461 // Advertise ourself as the loading class for this class name; 1462 TClass::AddClass(this);; 1463 ; 1464 Bool_t isStl = TClassEdit::IsSTLCont(fName);; 1465 ; 1466 if (!gInterpreter); 1467 ::Fatal(""TClass::Init"", ""gInterpreter not initialized"");; 1468 ; 1469 if (givenInfo) {; 1470 bool invalid = !gInterpreter->ClassInfo_IsValid(givenInfo);; 1471 bool notloaded = !gInterpreter->ClassInfo_IsLoaded(givenInfo);; 1472 auto property = gInterpreter->ClassInfo_Property(givenInfo);; 1473 ; 1474 if (invalid || (notloaded && (property & kIsNamespace)) ||; 1475 !(property & (kIsClass | kIsStruct | kIsNamespace))) {; 1476 if (!TClassEdit::IsSTLCont(fName.Data())) {; 1477 MakeZombie();; 1478 fState = kNoInfo;; 1479 TClass::RemoveClass(this);; 1480 return;; 1481 }; 1482 }; 1483 ; 1484 if (!invalid) {; 1485 fClassInfo = gInterpreter->ClassInfo_Factory(givenInfo);; 1486 fCanLoadClassInfo = false; // avoids calls to LoadClassInfo() if info is already loaded; 1487 if (fState <= kEmulated); 1488 fState = kInterpreted;; 1489 }; 1490 }; 1491 ; 1492 // We need to check if the class it is not fwd declared for the cases where we; 1493 // created a TClass directly in the kForwardDeclared state. Indeed in those cases; 1494 // fClassInfo will always be nullptr.; 1495 if (fState!=kForwardDeclared && !fClassInfo && !TClassEdit::IsArtificial(fName)) {; 1496 ; 1497 if (fState == kHasTClassInit) {; 1498 // If the TClass is being generated from a ROOT dictionary,; 1499 // even though we do not seem to have a CINT dictionary for; 1500 // the class, we will will try to load it anyway UNLESS; 1501 // the class is an STL container (or string).; 1502 // This is because we do not expect the CINT dictionary; 1503 // to be present for all STL classes (and we can handle; 1504 // the lack of CINT dictionary in that cases).; 1505 // However, the cling the dictionary no longer carries; 1506 // an instantiation with it, unless we re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:57172,avoid,avoids,57172,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['avoid'],['avoids']
Safety,"1523 oldcl->fMethod = nullptr;; 1524 ; 1525 }; 1526 ; 1527 SetBit(kLoading);; 1528 // Advertise ourself as the loading class for this class name; 1529 TClass::AddClass(this);; 1530 ; 1531 Bool_t isStl = TClassEdit::IsSTLCont(fName);; 1532 ; 1533 if (!gInterpreter); 1534 ::Fatal(""TClass::Init"", ""gInterpreter not initialized"");; 1535 ; 1536 if (givenInfo) {; 1537 bool invalid = !gInterpreter->ClassInfo_IsValid(givenInfo);; 1538 bool notloaded = !gInterpreter->ClassInfo_IsLoaded(givenInfo);; 1539 auto property = gInterpreter->ClassInfo_Property(givenInfo);; 1540 ; 1541 if (invalid || (notloaded && (property & kIsNamespace)) ||; 1542 !(property & (kIsClass | kIsStruct | kIsNamespace))) {; 1543 if (!TClassEdit::IsSTLCont(fName.Data())) {; 1544 MakeZombie();; 1545 fState = kNoInfo;; 1546 TClass::RemoveClass(this);; 1547 return;; 1548 }; 1549 }; 1550 ; 1551 if (!invalid) {; 1552 fClassInfo = gInterpreter->ClassInfo_Factory(givenInfo);; 1553 fCanLoadClassInfo = false; // avoids calls to LoadClassInfo() if info is already loaded; 1554 if (fState <= kEmulated); 1555 fState = kInterpreted;; 1556 }; 1557 }; 1558 ; 1559 // We need to check if the class it is not fwd declared for the cases where we; 1560 // created a TClass directly in the kForwardDeclared state. Indeed in those cases; 1561 // fClassInfo will always be nullptr.; 1562 if (fState!=kForwardDeclared && !fClassInfo && !TClassEdit::IsArtificial(fName)) {; 1563 ; 1564 if (fState == kHasTClassInit) {; 1565 // If the TClass is being generated from a ROOT dictionary,; 1566 // even though we do not seem to have a CINT dictionary for; 1567 // the class, we will will try to load it anyway UNLESS; 1568 // the class is an STL container (or string).; 1569 // This is because we do not expect the CINT dictionary; 1570 // to be present for all STL classes (and we can handle; 1571 // the lack of CINT dictionary in that cases).; 1572 // However, the cling the dictionary no longer carries; 1573 // an instantiation with it, unless we re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:59923,avoid,avoids,59923,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['avoid'],['avoids']
Safety,"1530/// Interface for one-time initialization to setup the generator for the specified code.; 1531 ; 1532void RooAbsPdf::initGenerator(Int_t /*code*/); 1533{; 1534}; 1535 ; 1536 ; 1537 ; 1538////////////////////////////////////////////////////////////////////////////////; 1539/// Interface for generation of an event using the algorithm; 1540/// corresponding to the specified code. The meaning of each code is; 1541/// defined by the getGenerator() implementation. The default; 1542/// implementation does nothing.; 1543 ; 1544void RooAbsPdf::generateEvent(Int_t /*code*/); 1545{; 1546}; 1547 ; 1548 ; 1549 ; 1550////////////////////////////////////////////////////////////////////////////////; 1551/// Check if given observable can be safely generated using the; 1552/// pdfs internal generator mechanism (if that existsP). Observables; 1553/// on which a PDF depends via more than route are not safe; 1554/// for use with internal generators because they introduce; 1555/// correlations not known to the internal generator; 1556 ; 1557bool RooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; 1558{; 1559 // Arg must be direct server of self; 1560 if (!findServer(arg.GetName())) return false ;; 1561 ; 1562 // There must be no other dependency routes; 1563 for (const auto server : _serverList) {; 1564 if(server == &arg) continue;; 1565 if(server->dependsOn(arg)) {; 1566 return false ;; 1567 }; 1568 }; 1569 ; 1570 return true ;; 1571}; 1572 ; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575/// Generate a new dataset containing the specified variables with events sampled from our distribution.; 1576/// \param[in] whatVars Choose variables in which to generate events. Variables not listed here will remain; 1577/// constant and not be used for event generation; 1578/// \param[in] arg1,arg2,arg3,arg4,arg5,arg6 Optional RooCmdArg to change behaviour of generateBinned(); 1579/// \return RooDataHist *, to be managed by caller.; 1580///; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:76139,safe,safe,76139,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['safe'],['safe']
Safety,"15RVEC_ASSIGNMENT_OPERATOR(>>=); 1716RVEC_ASSIGNMENT_OPERATOR(<<=); 1717#undef RVEC_ASSIGNMENT_OPERATOR; 1718 ; 1719///@}; 1720///@name RVec Comparison and Logical Operators; 1721///@{; 1722 ; 1723#define RVEC_LOGICAL_OPERATOR(OP) \; 1724template <typename T0, typename T1> \; 1725auto operator OP(const RVec<T0> &v, const T1 &y) \; 1726 -> RVec<int> /* avoid std::vector<bool> */ \; 1727{ \; 1728 RVec<int> ret(v.size()); \; 1729 auto op = [y](const T0 &x) -> int { return x OP y; }; \; 1730 std::transform(v.begin(), v.end(), ret.begin(), op); \; 1731 return ret; \; 1732} \; 1733 \; 1734template <typename T0, typename T1> \; 1735auto operator OP(const T0 &x, const RVec<T1> &v) \; 1736 -> RVec<int> /* avoid std::vector<bool> */ \; 1737{ \; 1738 RVec<int> ret(v.size()); \; 1739 auto op = [x](const T1 &y) -> int { return x OP y; }; \; 1740 std::transform(v.begin(), v.end(), ret.begin(), op); \; 1741 return ret; \; 1742} \; 1743 \; 1744template <typename T0, typename T1> \; 1745auto operator OP(const RVec<T0> &v0, const RVec<T1> &v1) \; 1746 -> RVec<int> /* avoid std::vector<bool> */ \; 1747{ \; 1748 if (v0.size() != v1.size()) \; 1749 throw std::runtime_error(ERROR_MESSAGE(OP)); \; 1750 \; 1751 RVec<int> ret(v0.size()); \; 1752 auto op = [](const T0 &x, const T1 &y) -> int { return x OP y; }; \; 1753 std::transform(v0.begin(), v0.end(), v1.begin(), ret.begin(), op); \; 1754 return ret; \; 1755} \; 1756 ; 1757RVEC_LOGICAL_OPERATOR(<); 1758RVEC_LOGICAL_OPERATOR(>); 1759RVEC_LOGICAL_OPERATOR(==); 1760RVEC_LOGICAL_OPERATOR(!=); 1761RVEC_LOGICAL_OPERATOR(<=); 1762RVEC_LOGICAL_OPERATOR(>=); 1763RVEC_LOGICAL_OPERATOR(&&); 1764RVEC_LOGICAL_OPERATOR(||); 1765#undef RVEC_LOGICAL_OPERATOR; 1766 ; 1767///@}; 1768///@name RVec Standard Mathematical Functions; 1769///@{; 1770 ; 1771/// \cond; 1772template <typename T> struct PromoteTypeImpl;; 1773 ; 1774template <> struct PromoteTypeImpl<float> { using Type = float; };; 1775template <> struct PromoteTypeImpl<double> { using Type = double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:61218,avoid,avoid,61218,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['avoid'],['avoid']
Safety,"16.3 operator\(<<\)(std::ostream&, const MnUserCovariance&); Prints out the MnUserCovariance.; 5.16.4 operator\(<<\)(std::ostream&, const MnGlobalCorrelationCoeff&); Prints out the MnGlobalCorrelationCoeff.; 5.16.5 operator\(<<\)(std::ostream&, const MnUserParameterState&); Prints out the whole MnUserParameterState: MnUserParameters, MnUserCovariance and MnGlobalCorrelationCoeff.; 5.16.6 operator\(<<\)(std::ostream&, const MinosError&); Prints out the MinosError of a given parameter.; 5.16.7 operator\(<<\)(std::ostream&, const ContoursErros&); Prints out the MinosError of the two parameters and plots a line printer graphic of the contours on the output terminal.; 6 How to get the right answer from M; The goal of M â€” to be able to minimize and analyze parameter errors for all possible user functions with any number of variable parameters â€” is of course impossible to realise, even in principle, in a finite amount of time. In practice, some assumptions must be made about the behaviour of the function in order to avoid evaluating it at all possible points. In this chapter we give some hints on how the user can help M to make the right assumptions.; 6.1 Which minimizer to use; One of the historically interesting advantages of M is that it was probably the first minimization program to offer the user a choice of several minimization algorithms. This could be taken as a reflection of the fact that none of the algorithms known at that time were good enough to be universal, so users were encouraged to find the one that worked best for them. Since then, algorithms have improved considerably, but M still offers several, mostly so that old users will not feel cheated, but also to help the occasional user who does manage to defeat the best algorithms. M currently offers four applications which can be used to find a smaller function value, in addition to \(\mbox{MINOS}\), which will retain a smaller function value if it stumbles on one unexpectedly. The objects which can be used t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:65042,avoid,avoid,65042,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['avoid'],['avoid']
Safety,"16967 ; 16968 /* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:; 16969 * ""Note that enabling a nonzero timeout on a nonblocking socket; 16970 * is not recommended."", so set it to blocking now */; 16971 set_blocking_mode(conn->client.sock);; 16972 ; 16973 /* Send FIN to the client */; 16974 shutdown(conn->client.sock, SHUTDOWN_WR);; 16975 ; 16976 ; 16977#if defined(_WIN32); 16978 /* Read and discard pending incoming data. If we do not do that and; 16979 * close; 16980 * the socket, the data in the send buffer may be discarded. This; 16981 * behaviour is seen on Windows, when client keeps sending data; 16982 * when server decides to close the connection; then when client; 16983 * does recv() it gets no data back. */; 16984 do {; 16985 n = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);; 16986 } while (n > 0);; 16987#endif; 16988 ; 16989 if (conn->dom_ctx->config[LINGER_TIMEOUT]) {; 16990 linger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);; 16991 }; 16992 ; 16993 /* Set linger option according to configuration */; 16994 if (linger_timeout >= 0) {; 16995 /* Set linger option to avoid socket hanging out after close. This; 16996 * prevent ephemeral port exhaust problem under high QPS. */; 16997 linger.l_onoff = 1;; 16998 ; 16999#if defined(_MSC_VER); 17000#pragma warning(push); 17001#pragma warning(disable : 4244); 17002#endif; 17003#if defined(GCC_DIAGNOSTIC); 17004#pragma GCC diagnostic push; 17005#pragma GCC diagnostic ignored ""-Wconversion""; 17006#endif; 17007 /* Data type of linger structure elements may differ,; 17008 * so we don't know what cast we need here.; 17009 * Disable type conversion warnings. */; 17010 ; 17011 linger.l_linger = (linger_timeout + 999) / 1000;; 17012 ; 17013#if defined(GCC_DIAGNOSTIC); 17014#pragma GCC diagnostic pop; 17015#endif; 17016#if defined(_MSC_VER); 17017#pragma warning(pop); 17018#endif; 17019 ; 17020 } else {; 17021 linger.l_onoff = 0;; 17022 linger.l_linger = 0;; 17023 }; 17024 ; 17025",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:504677,avoid,avoid,504677,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['avoid'],['avoid']
Safety,"16968 ; 16969 /* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:; 16970 * ""Note that enabling a nonzero timeout on a nonblocking socket; 16971 * is not recommended."", so set it to blocking now */; 16972 set_blocking_mode(conn->client.sock);; 16973 ; 16974 /* Send FIN to the client */; 16975 shutdown(conn->client.sock, SHUTDOWN_WR);; 16976 ; 16977 ; 16978#if defined(_WIN32); 16979 /* Read and discard pending incoming data. If we do not do that and; 16980 * close; 16981 * the socket, the data in the send buffer may be discarded. This; 16982 * behaviour is seen on Windows, when client keeps sending data; 16983 * when server decides to close the connection; then when client; 16984 * does recv() it gets no data back. */; 16985 do {; 16986 n = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);; 16987 } while (n > 0);; 16988#endif; 16989 ; 16990 if (conn->dom_ctx->config[LINGER_TIMEOUT]) {; 16991 linger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);; 16992 }; 16993 ; 16994 /* Set linger option according to configuration */; 16995 if (linger_timeout >= 0) {; 16996 /* Set linger option to avoid socket hanging out after close. This; 16997 * prevent ephemeral port exhaust problem under high QPS. */; 16998 linger.l_onoff = 1;; 16999 ; 17000#if defined(_MSC_VER); 17001#pragma warning(push); 17002#pragma warning(disable : 4244); 17003#endif; 17004#if defined(GCC_DIAGNOSTIC); 17005#pragma GCC diagnostic push; 17006#pragma GCC diagnostic ignored ""-Wconversion""; 17007#endif; 17008 /* Data type of linger structure elements may differ,; 17009 * so we don't know what cast we need here.; 17010 * Disable type conversion warnings. */; 17011 ; 17012 linger.l_linger = (linger_timeout + 999) / 1000;; 17013 ; 17014#if defined(GCC_DIAGNOSTIC); 17015#pragma GCC diagnostic pop; 17016#endif; 17017#if defined(_MSC_VER); 17018#pragma warning(pop); 17019#endif; 17020 ; 17021 } else {; 17022 linger.l_onoff = 0;; 17023 linger.l_linger = 0;; 17024 }; 17025 ; 17026",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:504710,avoid,avoid,504710,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['avoid'],['avoid']
Safety,"18 // while ((browser=(TBrowser*)next())) browser->RecursiveRemove(this);; 519 ClearThreadsMap();; 520 ClearThreadData();; 521 delete TGeoBuilder::Instance(this);; 522 if (fBits); 523 delete[] fBits;; 524 SafeDelete(fNodes);; 525 SafeDelete(fTopNode);; 526 if (fOverlaps) {; 527 fOverlaps->Delete();; 528 SafeDelete(fOverlaps);; 529 }; 530 if (fRegions) {; 531 fRegions->Delete();; 532 SafeDelete(fRegions);; 533 }; 534 if (fMaterials) {; 535 fMaterials->Delete();; 536 SafeDelete(fMaterials);; 537 }; 538 SafeDelete(fElementTable);; 539 if (fMedia) {; 540 fMedia->Delete();; 541 SafeDelete(fMedia);; 542 }; 543 if (fHashVolumes) {; 544 fHashVolumes->Clear(""nodelete"");; 545 SafeDelete(fHashVolumes);; 546 }; 547 if (fHashGVolumes) {; 548 fHashGVolumes->Clear(""nodelete"");; 549 SafeDelete(fHashGVolumes);; 550 }; 551 if (fHashPNE) {; 552 fHashPNE->Delete();; 553 SafeDelete(fHashPNE);; 554 }; 555 if (fArrayPNE) {; 556 delete fArrayPNE;; 557 }; 558 if (fVolumes) {; 559 fVolumes->Delete();; 560 SafeDelete(fVolumes);; 561 }; 562 if (fShapes) {; 563 fShapes->Delete();; 564 SafeDelete(fShapes);; 565 }; 566 if (fPhysicalNodes) {; 567 fPhysicalNodes->Delete();; 568 SafeDelete(fPhysicalNodes);; 569 }; 570 if (fMatrices) {; 571 fMatrices->Delete();; 572 SafeDelete(fMatrices);; 573 }; 574 if (fTracks) {; 575 fTracks->Delete();; 576 SafeDelete(fTracks);; 577 }; 578 SafeDelete(fUniqueVolumes);; 579 if (fPdgNames) {; 580 fPdgNames->Delete();; 581 SafeDelete(fPdgNames);; 582 }; 583 if (fGDMLMatrices) {; 584 fGDMLMatrices->Delete();; 585 SafeDelete(fGDMLMatrices);; 586 }; 587 if (fOpticalSurfaces) {; 588 fOpticalSurfaces->Delete();; 589 SafeDelete(fOpticalSurfaces);; 590 }; 591 if (fSkinSurfaces) {; 592 fSkinSurfaces->Delete();; 593 SafeDelete(fSkinSurfaces);; 594 }; 595 if (fBorderSurfaces) {; 596 fBorderSurfaces->Delete();; 597 SafeDelete(fBorderSurfaces);; 598 }; 599 ClearNavigators();; 600 CleanGarbage();; 601 SafeDelete(fPainter);; 602 SafeDelete(fGLMatrix);; 603 if (fSizePNEId) {; 604 del",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:22228,Safe,SafeDelete,22228,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,"18 this->set_size(RHSSize);; 1019 return *this;; 1020 }; 1021 ; 1022 // If we have to grow to have enough elements, destroy the current elements.; 1023 // This allows us to avoid copying them during the grow.; 1024 // From the original LLVM implementation:; 1025 // FIXME: don't do this if they're efficiently moveable.; 1026 if (this->capacity() < RHSSize) {; 1027 if (this->Owns()) {; 1028 // Destroy current elements.; 1029 this->destroy_range(this->begin(), this->end());; 1030 }; 1031 this->set_size(0);; 1032 CurSize = 0;; 1033 this->grow(RHSSize);; 1034 } else if (CurSize) {; 1035 // Otherwise, use assignment for the already-constructed elements.; 1036 std::copy(RHS.begin(), RHS.begin() + CurSize, this->begin());; 1037 }; 1038 ; 1039 // Copy construct the new elements in place.; 1040 this->uninitialized_copy(RHS.begin() + CurSize, RHS.end(), this->begin() + CurSize);; 1041 ; 1042 // Set end.; 1043 this->set_size(RHSSize);; 1044 return *this;; 1045}; 1046 ; 1047template <typename T>; 1048RVecImpl<T> &RVecImpl<T>::operator=(RVecImpl<T> &&RHS); 1049{; 1050 // Avoid self-assignment.; 1051 if (this == &RHS); 1052 return *this;; 1053 ; 1054 // If the RHS isn't small, clear this vector and then steal its buffer.; 1055 if (!RHS.isSmall()) {; 1056 if (this->Owns()) {; 1057 this->destroy_range(this->begin(), this->end());; 1058 if (!this->isSmall()); 1059 free(this->begin());; 1060 }; 1061 this->fBeginX = RHS.fBeginX;; 1062 this->fSize = RHS.fSize;; 1063 this->fCapacity = RHS.fCapacity;; 1064 RHS.resetToSmall();; 1065 return *this;; 1066 }; 1067 ; 1068 // If we already have sufficient space, assign the common elements, then; 1069 // destroy any excess.; 1070 size_t RHSSize = RHS.size();; 1071 size_t CurSize = this->size();; 1072 if (CurSize >= RHSSize) {; 1073 // Assign common elements.; 1074 iterator NewEnd = this->begin();; 1075 if (RHSSize); 1076 NewEnd = std::move(RHS.begin(), RHS.end(), NewEnd);; 1077 ; 1078 // Destroy excess elements and trim the bounds.; 1079 if (this-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:36632,Avoid,Avoid,36632,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['Avoid'],['Avoid']
Safety,"198 of file TGeoParallelWorld.cxx. â—†Â ResetOverlaps(). void TGeoParallelWorld::ResetOverlaps ; (; ); const. Reset overlapflag for all volumes in geometry. ; Definition at line 154 of file TGeoParallelWorld.cxx. â—†Â Safety(). Double_t TGeoParallelWorld::Safety ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). inline . Definition at line 118 of file TGeoParallelWorld.h. â—†Â SafetyBVH(). double TGeoParallelWorld::SafetyBVH ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). private . Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ; Definition at line 1027 of file TGeoParallelWorld.cxx. â—†Â SafetyLoop(). Double_t TGeoParallelWorld::SafetyLoop ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). private . Compute safety for the parallel world (trivial loop version for comparison/debugging) ; Definition at line 1207 of file TGeoParallelWorld.cxx. â—†Â SafetyOrig(). Double_t TGeoParallelWorld::SafetyOrig ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). private . Compute safety for the parallel world (original version based on TGeoVoxelFinder) ; Definition at line 1145 of file TGeoParallelWorld.cxx. â—†Â SetAccelerationMode(). void TGeoParallelWorld::SetAccelerationMode ; (; AccelerationMode const &Â ; mode). inline . Definition at line 95 of file TGeoParallelWorld.h. â—†Â SetUseOverlaps(). void TGeoParallelWorld::SetUseOverlaps ; (; Bool_tÂ ; flag). inline . Definition at line 80 of file TGeoParallelWorld.h. â—†Â Streamer(). void TGeoParallelWorld::Streamer ; (; TBuffer &Â ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. â—†Â StreamerNVirtual(). void TGeoParallelWorld::StreamerNVirtual ; (; TBuffer &Â ; ClassDef_StreamerNVirtual_b). inline . Definition at line 184 of file TGeoParallelWorld.h. â—†Â TestVoxelGrid(). void TGeoParallelWorld::TestVoxelGrid ; (; ). private . Definition at line 1425 of file TGeoParallelWorld.cxx. â—†Â VoxelSafety(). double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:26461,Safe,SafetyOrig,26461,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['Safe'],['SafetyOrig']
Safety,"1; , kClassName =2; , kValue =4; , kArgs =8; , ; Â Â kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. }; Â ; enum Â StyleOption { ; Â Â kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ; Â Â kTreeStructure =5. }; Â ; Â Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArgÂ const { return observableOverlaps(dset,testArg); Â ; const RooAbsArg &testArgÂ const { return observableOverlaps(depList, testArg); Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â ; Â Static Protected Attributes inherited from RooAbsReal; static boolÂ _globalSelectComp = false; Â ; static boolÂ _hideOffset = true; Â Offset hiding flag. ; Â ; Â Static Protected Attributes inherited from RooAbsArg; static boolÂ _inhibitDirty; Â ; static boolÂ _verboseDirty; Â cache of the list of proxies. Avoids type casting. ; Â ; Â Static Protected Attributes inherited from RooPrintable; static Int_tÂ _nameLength; Â . #include <RooStats/HistFactory/ParamHistFunc.h>. Inheritance diagram for ParamHistFunc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. â—†Â ParamHistFunc() [1/4]. ParamHistFunc::ParamHistFunc ; (; ). Definition at line 62 of file ParamHistFunc.cxx. â—†Â ParamHistFunc() [2/4]. ParamHistFunc::ParamHistFunc ; (; const char *Â ; name, . const char *Â ; title, . const RooArgList &Â ; vars, . const RooArgList &Â ; paramSetÂ . ). Create a function which returns binewise-values This class contains N RooAbsReals's, one for each bin from the given RooRealVar. ; The value of the function in the ith bin is given by:; F(i) = gamma_i * nominal(i); Where the nominal values are simply fixed numbers (default = 1.0 for all i) ; Definition at line 81 of file ParamHistFunc.cxx. â—†Â ParamHistFunc() [3/4]. ParamHistFunc::ParamHist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classParamHistFunc.html:62550,Avoid,Avoids,62550,doc/master/classParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html,1,['Avoid'],['Avoids']
Safety,"1; 87 static void SetDefaultTolerance(double tol);; 88 ; 89 /// Set the default Minimizer precision.; 90 /// (used only by MInuit and Minuit2); 91 /// It is used to specify the numerical precision used for computing the; 92 /// objective function. It should be left to the default value found by the Minimizer; 93 /// (typically double precision); 94 static void SetDefaultPrecision(double prec);; 95 ; 96 /// Set the maximum number of function calls.; 97 static void SetDefaultMaxFunctionCalls(int maxcall);; 98 ; 99 /// Set the maximum number of iterations.; 100 /// Used by the GSL minimizers and Genetic. Not used by Minuit,Minuit2.; 101 static void SetDefaultMaxIterations(int maxiter);; 102 ; 103 /// Set the default strategy.; 104 /// The strategy is a parameter used only by Minuit and Minuit2.; 105 /// Possible values are:; 106 /// - `strat = 0` : rough approximation of Hessian using the gradient. Avoid computing the full Hessian matrix; 107 /// - `strat = 1` (default and recommended one) - Use Hessian approximation but compute full Hessian at the end of minimization if needed.; 108 /// - `strat = 2` Perform several full Hessian computations during the minimization. Slower and not always working better than `strat=1`.; 109 static void SetDefaultStrategy(int strat);; 110 ; 111 /// Set the default Print Level.; 112 /// Possible levels are from 0 (minimal printing) to 3 (maximum printing); 113 static void SetDefaultPrintLevel(int level);; 114 ; 115 /// Set additional minimizer options as pair of (string,value).; 116 /// Extra option defaults can be configured for a specific algorithm and; 117 /// then if a matching with the correct option name exists it will be used; 118 /// whenever creating a new minimizer instance.; 119 /// For example for changing the default number of steps of the Genetic minimizer from 100 to 500 do; 120 ///; 121 /// auto extraOpt = ROOT::Math::MinimizerOptions::Default(""Genetic""); 122 /// extraOpts.SetValue(""Steps"",500);; 123 ///; 124 /// and when",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MinimizerOptions_8h_source.html:4619,Avoid,Avoid,4619,doc/master/MinimizerOptions_8h_source.html,https://root.cern,https://root.cern/doc/master/MinimizerOptions_8h_source.html,1,['Avoid'],['Avoid']
Safety,"1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â ; Â Protected Member Functions inherited from TObject; virtual voidÂ DoError (int level, const char *location, const char *fmt, va_list va) const; Â Interface to ErrorHandler (protected). ; Â ; voidÂ MakeZombie (); Â . #include <TFilePrefetch.h>. Inheritance diagram for TFilePrefetch:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. â—†Â TFilePrefetch(). TFilePrefetch::TFilePrefetch ; (; TFile *Â ; file). Constructor. ; Definition at line 54 of file TFilePrefetch.cxx. â—†Â ~TFilePrefetch(). TFilePrefetch::~TFilePrefetch ; (; ). override . Destructor. ; Definition at line 72 of file TFilePrefetch.cxx. Member Function Documentation. â—†Â AddPendingBlock(). void TFilePrefetch::AddPendingBlock ; (; TFPBlock *Â ; block). Safe method to add a block to the pendingList. ; Definition at line 223 of file TFilePrefetch.cxx. â—†Â AddReadBlock(). void TFilePrefetch::AddReadBlock ; (; TFPBlock *Â ; block). Safe method to add a block to the readList. ; Definition at line 259 of file TFilePrefetch.cxx. â—†Â BinarySearchReadList(). Bool_t TFilePrefetch::BinarySearchReadList ; (; TFPBlock *Â ; blockObj, . Long64_tÂ ; offset, . Int_tÂ ; len, . Int_t *Â ; indexÂ . ). Search for a requested element in a block and return the index. ; Definition at line 144 of file TFilePrefetch.cxx. â—†Â CheckBlockInCache(). Bool_t TFilePrefetch::CheckBlockInCache ; (; char *&Â ; path, . TFPBlock *Â ; blockÂ . ). Test if the block is in cache. ; Definition at line 395 of file TFilePrefetch.cxx. â—†Â Class(). static TClass * TFilePrefetch::Class ; (; ). static . ReturnsTClass describing this class . â—†Â Class_Name(). static const char * TFilePrefetch::Class_Name ; (; ). static . ReturnsName of this class . â—†Â Class_Version(). static constexpr Version_t TFilePrefetch::Class_Version ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFilePrefetch.html:13817,Safe,Safe,13817,doc/master/classTFilePrefetch.html,https://root.cern,https://root.cern/doc/master/classTFilePrefetch.html,1,['Safe'],['Safe']
Safety,"1] = zn; param[4*(nz-1)+2] = xn; param[4*(nz-1)+3] = yn; param[4*(nz-1)+4] = scalen. TGeoXtru(const TGeoXtru& ); copy constructor. TGeoXtru& operator=(const TGeoXtru& ); assignment operator. ~TGeoXtru(); destructor. Double_t Capacity() const; Compute capacity [length^3] of this shape. void ComputeBBox(); compute bounding box of the pcon. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. void DrawPolygon(Option_t* option = """"); Draw the section polygon. Double_t DistToPlane(const Double_t* point, const Double_t* dir, Int_t iz, Int_t ivert, Double_t stepmax, Bool_t in) const; Compute distance to a Xtru lateral surface. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone; locate Z segment. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; Warning(""DistFromOutside"", ""not implemented"");. Bool_t DefinePolygon(Int_t nvert, const Double_t* xv, const Double_t* yv); Creates the polygon representing the blueprint of any Xtru section.; nvert = number of vertices >2; xv[nvert] = array of X vertex positions; yv[nvert] = array of Y vertex positions; *NOTE* should be called before DefineSection or ctor with 'param'. void DefineSection(Int_t snum, Double_t z, Double_t x0 = 0., Double_t y0 = 0., Double_t scale = 1.); defines z position of a section plane, rmin and rmax at this z. Double_t GetZ(Int_t ipl) const; Return the Z coordinate for segment ipl. void GetPlaneNormal(const Double_t* vert, Double_t* norm) const; Retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoXtru.html:16694,safe,safe,16694,root/html534/TGeoXtru.html,https://root.cern,https://root.cern/root/html534/TGeoXtru.html,3,['safe'],['safe']
Safety,"1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Generate a data sample of 1000 events in x from model; data = model.generate({x}, 1000); ; # Create workspace, import data and model; # -----------------------------------------------------------------------------; ; # Create a empty workspace; w = ROOT.RooWorkspace(""w"", ""workspace""); ; # Import model and all its components into the workspace; w.Import(model); ; # Import data into the workspace; w.Import(data); ; # Print workspace contents; w.Print(); ; # Save workspace in file; # -------------------------------------------; ; # Save the workspace into a ROOT file; w.writeToFile(""rf502_workspace_py.root""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:Objec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf502__wspacewrite_8py.html:2237,safe,safe,2237,doc/master/rf502__wspacewrite_8py.html,https://root.cern,https://root.cern/doc/master/rf502__wspacewrite_8py.html,1,['safe'],['safe']
Safety,"2 // On the link line, we must list the most dependent .o file; 983 // and end with the least dependent (LLVM libraries), unfortunately,; 984 // Fedora Core 17+ or Ubuntu 12 will also execute the initialization; 985 // in the same order (hence doing libCore's before LLVM's and; 986 // vice et versa for both the destructor. We worked around the; 987 // initialization order by delay the TROOT creation until first use.; 988 // We can not do the same for destruction as we have no way of knowing; 989 // the last access ...; 990 // So for now, let's avoid delete TCling except in the special build; 991 // checking the completeness of the termination deletion.; 992 ; 993 // TODO: Should we do more cleanup here than just call delete?; 994 // Segfaults rootcling in some cases, debug and uncomment:; 995 //; 996 // delete fInterpreter;; 997 ; 998 // We cannot delete fCleanups because of the logic in atexit which needs it.; 999 SafeDelete(fCleanups);; 1000#endif; 1001 ; 1002#ifdef _MSC_VER; 1003 // usedToIdentifyRootClingByDlSym is available when TROOT is part of rootcling.; 1004 if (dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"")) {; 1005 // deleting the interpreter makes things crash at exit in some cases; 1006 delete fInterpreter;; 1007 }; 1008#else; 1009 // deleting the interpreter makes things crash at exit in some cases; 1010 delete fInterpreter;; 1011#endif; 1012 ; 1013 // Prints memory stats; 1014 TStorage::PrintStatistics();; 1015 ; 1016 gROOTLocal = nullptr;; 1017 fgRootInit = kFALSE;; 1018 }; 1019}; 1020 ; 1021////////////////////////////////////////////////////////////////////////////////; 1022/// Add a class to the list and map of classes.; 1023/// This routine is deprecated, use TClass::AddClass directly.; 1024 ; 1025void TROOT::AddClass(TClass *cl); 1026{; 1027 TClass::AddClass(cl);; 1028}; 1029 ; 1030////////////////////////////////////////////////////////////////////////////////; 1031/// Add a class generator. This generator will be called by TClass::GetCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:39707,Safe,SafeDelete,39707,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['Safe'],['SafeDelete']
Safety,"2 TString content;; 1583 content.ReadFile(instr);; 1584 Printf(""%s"", content.Data());; 1585 return 0;; 1586 }; 1587 } // namespace; 1588 ; 1589////////////////////////////////////////////////////////////////////////////////; 1590/// Process a single command line, either a C++ statement or an interpreter; 1591/// command starting with a ""."".; 1592/// Return the return value of the command cast to a long.; 1593 ; 1594Longptr_t TApplication::ProcessLine(const char *line, Bool_t sync, Int_t *err); 1595{; 1596 if (!line || !*line) return 0;; 1597 ; 1598 // If we are asked to go remote do it; 1599 if (!strncmp(line, "".R"", 2)) {; 1600 Int_t n = 2;; 1601 while (*(line+n) == ' '); 1602 n++;; 1603 return ProcessRemote(line+n, err);; 1604 }; 1605 ; 1606 // Redirect, if requested; 1607 if (fAppRemote && TestBit(kProcessRemotely)) {; 1608 ResetBit(kProcessRemotely);; 1609 return fAppRemote->ProcessLine(line, err);; 1610 }; 1611 ; 1612 if (!strncasecmp(line, "".qqqqqqq"", 7)) {; 1613 gSystem->Abort();; 1614 } else if (!strncasecmp(line, "".qqqqq"", 5)) {; 1615 Info(""ProcessLine"", ""Bye... (try '.qqqqqqq' if still running)"");; 1616 gSystem->Exit(1);; 1617 } else if (!strncasecmp(line, "".exit"", 4) || !strncasecmp(line, "".quit"", 2)) {; 1618 Terminate(0);; 1619 return 0;; 1620 }; 1621 ; 1622 if (!strncmp(line, "".gh"", 3)) {; 1623 GitHub(line);; 1624 return 1;; 1625 }; 1626 ; 1627 if (!strncmp(line, "".forum"", 6)) {; 1628 Forum(line);; 1629 return 1;; 1630 }; 1631 ; 1632 if (!strncmp(line, "".?"", 2) || !strncmp(line, "".help"", 5)) {; 1633 Help(line);; 1634 return 1;; 1635 }; 1636 ; 1637 if (!strncmp(line, "".demo"", 5)) {; 1638 if (gROOT->IsBatch()) {; 1639 Error(""ProcessLine"", ""Cannot show demos in batch mode!"");; 1640 return 1;; 1641 }; 1642 ProcessLine("".x "" + TROOT::GetTutorialDir() + ""/demos.C"");; 1643 return 0;; 1644 }; 1645 ; 1646 if (!strncmp(line, "".license"", 8)) {; 1647 return PrintFile(TROOT::GetDocDir() + ""/LICENSE"");; 1648 }; 1649 ; 1650 if (!strncmp(line, "".credits"", 8)) {; 1651 TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:63542,Abort,Abort,63542,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['Abort'],['Abort']
Safety,"2); //node is not drawn but its sons are drawn; VT1_1->SetVisibility(-4); //Node is not drawn. Its immediate sons are drawn; VT2_1->SetVisibility(-4);; MTL_1->SetVisibility(-4);; MTR_1->SetVisibility(-4);; TOFR1->SetVisibility(-4);; ; gBenchmark->Show(""na49"");; }; TBRIK.h; TBenchmark.h; gBenchmarkR__EXTERN TBenchmark * gBenchmarkDefinition TBenchmark.h:59; TGeometry.h; TMaterial.h; TMixture.h; TNode.h; TRotMatrix.h; TTRAP.h; TTUBE.h; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TBRIKA box with faces perpendicular to the axes.Definition TBRIK.h:26; TBenchmark::Startvirtual void Start(const char *name)Starts Benchmark with the specified name.Definition TBenchmark.cxx:172; TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TGeometryTGeometry description.Definition TGeometry.h:39; TMaterialManages a detector material.Definition TMaterial.h:28; TMixtureManages a detector mixture.Definition TMixture.h:27; TMixture::DefineElementvirtual void DefineElement(Int_t n, Float_t a, Float_t z, Float_t w)Define one mixture element.Definition TMixture.cxx:86; TNodeTNode description.Definition TNode.h:33; TNode::cdvirtual void cd(const char *path=nullptr)Change Current Reference node to this.Definition TNode.cxx:249; TNode::ImportShapeAttributesvirtual void ImportShapeAttributes()Copy shape attributes as node attributes.Definition TNode.cxx:409; TNode::SetVisibilityvirtual void SetVisibility(Int_t vis=1)Set visibility for this node and its sons.Definition TNode.cxx:758; TRotMatrixManages a detector rotation matrix.Definition TRotMatrix.h:28; TShape::SetVisibilityvirtual void SetVisibility(Int_t vis)Definition TShape.h:62; TTRAPA general trapezoid.Definition TTRAP.h:33; TTUBEA tube.Definition TTUBE.h:32; AuthorRene Brun ; Definition in file na49.C. tutorialsgeomna49.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:28 (GVA Time) using Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/na49_8C.html:948515,detect,detector,948515,doc/master/na49_8C.html,https://root.cern,https://root.cern/doc/master/na49_8C.html,1,['detect'],['detector']
Safety,"2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoParaboloid&operator=(const TGeoParaboloid&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetParaboloidDimensions(Double_t rlo, Double_t rhi, Double_t dz); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoParaboloid.html:8216,Safe,SafetyPhi,8216,root/html530/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html530/TGeoParaboloid.html,2,['Safe'],['SafetyPhi']
Safety,"2.21831, denominator=wrap_pdf_Int[pTV]=89722.5; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.44258 cHl3=4.96668 cHq3=0.0273884; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; ... (remaining 14 messages suppressed); ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:13241,recover,recover,13241,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,"2.setVal(-1.);; ; // Perform a fit:; std::unique_ptr<RooFitResult> fitWithoutRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:4545,Recover,RecoverFromUndefinedRegions,4545,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,1,['Recover'],['RecoverFromUndefinedRegions']
Safety,"2023{; 2024 ; 2025 Long64_t nEvents = Data()->GetNEvents();; 2026 if (firstEvt > lastEvt || lastEvt > nEvents) lastEvt = nEvents;; 2027 if (firstEvt < 0) firstEvt = 0;; 2028 nEvents = lastEvt-firstEvt;; 2029 ; 2030 // use same batch size as for training (from first strategy); 2031 size_t defaultEvalBatchSize = (fXInput.GetSize() > 1000) ? 100 : 1000;; 2032 size_t batchSize = (fTrainingSettings.empty()) ? defaultEvalBatchSize : fTrainingSettings.front().batchSize;; 2033 if ( size_t(nEvents) < batchSize ) batchSize = nEvents;; 2034 ; 2035 // using for training same scalar type defined for the prediction; 2036 if (this->GetArchitectureString() == ""GPU"") {; 2037#ifdef R__HAS_TMVAGPU; 2038 Log() << kINFO << ""Evaluate deep neural network on GPU using batches with size = "" << batchSize << Endl << Endl;; 2039#ifdef R__HAS_CUDNN; 2040 return PredictDeepNet<DNN::TCudnn<ScalarImpl_t>>(firstEvt, lastEvt, batchSize, logProgress);; 2041#else; 2042 return PredictDeepNet<DNN::TCuda<ScalarImpl_t>>(firstEvt, lastEvt, batchSize, logProgress);; 2043#endif; 2044 ; 2045#endif; 2046 }; 2047 Log() << kINFO << ""Evaluate deep neural network on CPU using batches with size = "" << batchSize << Endl << Endl;; 2048 return PredictDeepNet<DNN::TCpu<ScalarImpl_t> >(firstEvt, lastEvt, batchSize, logProgress);; 2049}; 2050////////////////////////////////////////////////////////////////////////////////; 2051void MethodDL::AddWeightsXMLTo(void * parent) const; 2052{; 2053 // Create the parent XML node with name ""Weights""; 2054 auto & xmlEngine = gTools().xmlengine();; 2055 void* nn = xmlEngine.NewChild(parent, 0, ""Weights"");; 2056 ; 2057 /*! Get all necessary information, in order to be able to reconstruct the net; 2058 * if we read the same XML file. */; 2059 ; 2060 // Deep Net specific info; 2061 Int_t depth = fNet->GetDepth();; 2062 ; 2063 Int_t inputDepth = fNet->GetInputDepth();; 2064 Int_t inputHeight = fNet->GetInputHeight();; 2065 Int_t inputWidth = fNet->GetInputWidth();; 2066 ; 2067 Int_t batc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:81072,predict,prediction,81072,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,4,"['Predict', 'predict']","['PredictDeepNet', 'prediction']"
Safety,"21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TNamed.h""; 25#include ""TClass.h""; 26#include ""TUUID.h""; 27#include <atomic>; 28 ; 29#ifdef R__LESS_INCLUDES; 30class TList;; 31#else; 32#include ""TList.h""; 33#include ""TBuffer.h""; 34// #include ""TDatime.h""; 35#endif; 36 ; 37class TBrowser;; 38class TKey;; 39class TFile;; 40namespace ROOT {; 41namespace Internal {; 42 struct TDirectoryAtomicAdapter;; 43}}; 44 ; 45class TDirectory : public TNamed {; 46public:; 47 ; 48/** \class TContext; 49\ingroup Base; 50 ; 51TDirectory::TContext keeps track and restore the current directory.; 52With this tool C++ exceptions will be guaranteed to properly restore the; 53current directory pointer.; 54 ; 55For example code like:; 56 ; 57~~~ {.cpp}; 58 TDirectory *sav = gDirectory;; 59 mydirectory->cd();; 60 if (...) {; 61 ....; 62 sav->cd();; 63 return;; 64 } else if (...) {; 65 ....; 66 sav->cd();; 67 return;; 68 }; 69 sav->cd;; 70 return;; 71~~~; 72 ; 73can be replaced with the simpler and exception safe:; 74 ; 75~~~ {.cpp}; 76 TDirectory::TContext context(gDirectory, mydirectory);; 77 if (...) {; 78 ....; 79 return;; 80 } else if (...) {; 81 ....; 82 return;; 83 }; 84 return;; 85~~~; 86 ; 87*/; 88 ; 89 class TContext {; 90 private:; 91 std::atomic<TDirectory*> fDirectory{nullptr}; //! Pointer to the previous current directory.; 92 std::atomic<bool> fActiveDestructor{false}; //! Set to true during the destructor execution; 93 std::atomic<bool> fDirectoryWait{false}; //! Set to true if a TDirectory might still access this object.; 94 TContext *fPrevious{nullptr}; //! Pointer to the next TContext in the implied list of context pointing to fPrevious.; 95 TContext *fNext{nullptr}; //! Pointer to the next TContext in the implied list of context pointing to fPrevious.; 96 ; 97 TContext(TContext&) = delete;; 98 TContext& operator=(TContext&) = delete;; 99 ; 100 void CdNull();; 101 friend class TDirectory;; 102 ; 103 void RegisterCurrentDi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8h_source.html:1898,safe,safe,1898,doc/master/TDirectory_8h_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html,1,['safe'],['safe']
Safety,"2426 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12427 int n, error, exit_by_callback;; 12428 int ret;; 12429 ; 12430 /* body_len is the length of the entire queue in bytes; 12431 * len is the length of the current message; 12432 * data_len is the length of the current message's data payload; 12433 * header_len is the length of the current message's header */; 12434 size_t i, len, mask_len = 0, header_len, body_len;; 12435 uint64_t data_len = 0;; 12436 ; 12437 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12438 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:360966,timeout,timeout,360966,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"2427 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12428 int n, error, exit_by_callback;; 12429 int ret;; 12430 ; 12431 /* body_len is the length of the entire queue in bytes; 12432 * len is the length of the current message; 12433 * data_len is the length of the current message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:360999,timeout,timeout,360999,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"256.hxx:99; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; THLimitsFinder.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TMath.h; TProfile2D.h; TProfileHelper.h; EErrorTypeEErrorTypeDefinition TProfile.h:28; kERRORSPREAD@ kERRORSPREADDefinition TProfile.h:28; kERRORSPREADG@ kERRORSPREADGDefinition TProfile.h:28; kERRORSPREADI@ kERRORSPREADIDefinition TProfile.h:28; gDebugInt_t gDebugDefinition TROOT.cxx:597; TArrayDArray of doubles (64 bits per element).Definition TArrayD.h:27; TArrayD::fArrayDouble_t * fArrayDefinition TArrayD.h:30; TArrayD::Streamervoid Streamer(TBuffer &) overrideStream a TArrayD object.Definition TArrayD.cxx:149; TArrayD::Copyvoid Copy(TArrayD &array) constDefinition TArrayD.h:42; TArrayD::Setvo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:75759,abort,abort,75759,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,1,['abort'],['abort']
Safety,"258 cHl3=4.96668 cHq3=0.0273884; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; ... (remaining 14 messages suppressed); ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=-3.35967 cHl3=-9.58704 cHq3=-6.27461; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, deno",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:13479,recover,recover,13479,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,"26// TSignalHandler *ih = GetSignalHandler();; 327// ih->Remove();; 328// SetSignalHandler(0);; 329// delete ih;; 330}; 331 ; 332////////////////////////////////////////////////////////////////////////////////; 333/// Execute logon macro's. There are three levels of logon macros that; 334/// will be executed: the system logon etc/system.rootlogon.C, the global; 335/// user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; 336/// compatibility also the logon macro as specified by the Rint.Logon; 337/// environment setting, by default ./rootlogon.C, will be executed.; 338/// No logon macros will be executed when the system is started with; 339/// the -n option.; 340 ; 341void TRint::ExecLogon(); 342{; 343 if (NoLogOpt()) return;; 344 ; 345 TString name = "".rootlogon.C"";; 346 TString sname = ""system"";; 347 sname += name;; 348 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 349 if (!gSystem->AccessPathName(s, kReadPermission)) {; 350 ProcessFile(s);; 351 }; 352 delete [] s;; 353 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 354 if (!gSystem->AccessPathName(s, kReadPermission)) {; 355 ProcessFile(s);; 356 }; 357 delete [] s;; 358 // avoid executing ~/.rootlogon.C twice; 359 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())) {; 360 if (!gSystem->AccessPathName(name, kReadPermission)); 361 ProcessFile(name);; 362 }; 363 ; 364 // execute also the logon macro specified by ""Rint.Logon""; 365 const char *logon = gEnv->GetValue(""Rint.Logon"", (char*)nullptr);; 366 if (logon) {; 367 char *mac = gSystem->Which(TROOT::GetMacroPath(), logon, kReadPermission);; 368 if (mac); 369 ProcessFile(logon);; 370 delete [] mac;; 371 }; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// Main application eventloop. First process files given on the command; 376/// line and then go into the main application event loop, unless the -q; 377/// command line option was specified in which cas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:12358,avoid,avoid,12358,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,1,['avoid'],['avoid']
Safety,"29; TMVA::MethodDL::GetRegressionValuesvirtual const std::vector< Float_t > & GetRegressionValues(); TMVA::MethodDL::fTrainingStrategyStringTString fTrainingStrategyStringThe string defining the training strategy.Definition MethodDL.h:196; TMVA::MethodDL::CreateRankingconst Ranking * CreateRanking()Definition MethodDL.cxx:2335; TMVA::MethodDL::HostBufferImpl_ttypename ArchitectureImpl_t::HostBuffer_t HostBufferImpl_tDefinition MethodDL.h:110; TMVA::MethodDL::SetBatchDepthvoid SetBatchDepth(size_t batchDepth)Definition MethodDL.h:292; TMVA::MethodDL::ParseKeyValueStringKeyValueVector_t ParseKeyValueString(TString parseString, TString blockDelim, TString tokenDelim)Function for parsing the training settings, provided as a string in a key-value form.Definition MethodDL.cxx:1052; TMVA::MethodDL::SetBatchWidthvoid SetBatchWidth(size_t batchWidth)Definition MethodDL.h:294; TMVA::MethodDL::PredictDeepNetstd::vector< Double_t > PredictDeepNet(Long64_t firstEvt, Long64_t lastEvt, size_t batchSize, Bool_t logProgress)perform prediction of the deep neural network using batches (called by GetMvaValues)Definition MethodDL.cxx:1828; TMVA::MethodDL::GetWeightInitializationDNN::EInitialization GetWeightInitialization() constDefinition MethodDL.h:268; TMVA::MethodDL::SetBatchSizevoid SetBatchSize(size_t batchSize)Definition MethodDL.h:291; TMVA::MethodDL::GetLayoutStringTString GetLayoutString() constDefinition MethodDL.h:274; TMVA::MethodDL::fBatchDepthsize_t fBatchDepthThe depth of the batch used to train the deep net.Definition MethodDL.h:182; TMVA::MethodDL::DeepNetImpl_tTMVA::DNN::TDeepNet< ArchitectureImpl_t > DeepNetImpl_tDefinition MethodDL.h:106; TMVA::MethodDL::GetBatchWidthsize_t GetBatchWidth() constDefinition MethodDL.h:264; TMVA::MethodDL::AddWeightsXMLTovoid AddWeightsXMLTo(void *parent) constDefinition MethodDL.cxx:2051; TMVA::MethodDL::MatrixImpl_ttypename ArchitectureImpl_t::Matrix_t MatrixImpl_tDefinition MethodDL.h:107; TMVA::MethodDL::~MethodDLvirtual ~MethodDL(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:111080,Predict,PredictDeepNetstd,111080,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,3,"['Predict', 'predict']","['PredictDeepNet', 'PredictDeepNetstd', 'prediction']"
Safety,"2]. Bool_t TGeoNavigator::PopPath ; (; ). inline . Definition at line 247 of file TGeoNavigator.h. â—†Â PopPath() [2/2]. Bool_t TGeoNavigator::PopPath ; (; Int_tÂ ; index). inline . Definition at line 255 of file TGeoNavigator.h. â—†Â PopPoint() [1/2]. Bool_t TGeoNavigator::PopPoint ; (; ). inline . Definition at line 264 of file TGeoNavigator.h. â—†Â PopPoint() [2/2]. Bool_t TGeoNavigator::PopPoint ; (; Int_tÂ ; index). inline . Definition at line 272 of file TGeoNavigator.h. â—†Â PushPath(). Int_t TGeoNavigator::PushPath ; (; Int_tÂ ; startlevel = 0). inline . Definition at line 246 of file TGeoNavigator.h. â—†Â PushPoint(). Int_t TGeoNavigator::PushPoint ; (; Int_tÂ ; startlevel = 0). inline . Definition at line 263 of file TGeoNavigator.h. â—†Â ResetAll(). void TGeoNavigator::ResetAll ; (; ). Reset the navigator. ; Definition at line 2708 of file TGeoNavigator.cxx. â—†Â ResetState(). void TGeoNavigator::ResetState ; (; ). Reset current state flags. ; Definition at line 1643 of file TGeoNavigator.cxx. â—†Â Safety(). Double_t TGeoNavigator::Safety ; (; Bool_tÂ ; inside = kFALSE). Compute safe distance from the current point. ; This represent the distance from POINT to the closest boundary. ; Definition at line 1689 of file TGeoNavigator.cxx. â—†Â SafetyOverlaps(). void TGeoNavigator::SafetyOverlaps ; (; ). protected . Compute safe distance from the current point within an overlapping node. ; Definition at line 1846 of file TGeoNavigator.cxx. â—†Â SearchNode(). TGeoNode * TGeoNavigator::SearchNode ; (; Bool_tÂ ; downwards = kFALSE, . const TGeoNode *Â ; skipnode = nullptrÂ . ). Returns the deepest node containing fPoint, which must be set a priori. ; Check if parallel world navigation is enabled ; Definition at line 1924 of file TGeoNavigator.cxx. â—†Â SetCheckingOverlaps(). void TGeoNavigator::SetCheckingOverlaps ; (; Bool_tÂ ; flag = kTRUE). inline . Definition at line 147 of file TGeoNavigator.h. â—†Â SetCldirChecked(). void TGeoNavigator::SetCldirChecked ; (; Double_t *Â ; dir). inline . Definition at line",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:41303,Safe,Safety,41303,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['Safe'],['Safety']
Safety,"3 &Â ; v, . Double_tÂ ; w = 1Â . ); const. Multiply vector in-place. ; Definition at line 728 of file TEveTrans.cxx. â—†Â MultLeft(). void TEveTrans::MultLeft ; (; const TEveTrans &Â ; t). Multiply from left: this = t * this. ; Definition at line 300 of file TEveTrans.cxx. â—†Â MultRight(). void TEveTrans::MultRight ; (; const TEveTrans &Â ; t). Multiply from right: this = this * t. ; Definition at line 316 of file TEveTrans.cxx. â—†Â Norm3Column(). Double_t TEveTrans::Norm3Column ; (; Int_tÂ ; col). protected . Norm 3-vector in column col. ; Definition at line 824 of file TEveTrans.cxx. â—†Â operator()() [1/2]. Double_t & TEveTrans::operator() ; (; Int_tÂ ; i, . Int_tÂ ; jÂ . ). inline . Definition at line 107 of file TEveTrans.h. â—†Â operator()() [2/2]. Double_t TEveTrans::operator() ; (; Int_tÂ ; i, . Int_tÂ ; jÂ . ); const. inline . Definition at line 106 of file TEveTrans.h. â—†Â operator*(). TEveTrans TEveTrans::operator* ; (; const TEveTrans &Â ; t). Copy, multiply from right and return product. ; Avoid unless necessary. ; Definition at line 333 of file TEveTrans.cxx. â—†Â operator*=(). void TEveTrans::operator*= ; (; const TEveTrans &Â ; t). inline . Definition at line 72 of file TEveTrans.h. â—†Â operator=(). TEveTrans & TEveTrans::operator= ; (; const TEveTrans &Â ; t). inline . Definition at line 63 of file TEveTrans.h. â—†Â operator[]() [1/2]. Double_t & TEveTrans::operator[] ; (; Int_tÂ ; i). inline . Definition at line 101 of file TEveTrans.h. â—†Â operator[]() [2/2]. Double_t TEveTrans::operator[] ; (; Int_tÂ ; i); const. inline . Definition at line 100 of file TEveTrans.h. â—†Â Orto3Column(). Double_t TEveTrans::Orto3Column ; (; Int_tÂ ; col, . Int_tÂ ; refÂ . ). protected . Orto-norm 3-vector in column col with respect to column ref. ; Definition at line 835 of file TEveTrans.cxx. â—†Â OrtoNorm3(). void TEveTrans::OrtoNorm3 ; (; ). Orto-norm columns 1 to 3. ; Definition at line 847 of file TEveTrans.cxx. â—†Â Print(). void TEveTrans::Print ; (; Option_t *Â ; option = """"); const. overridevirtual . Print in r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTrans.html:25437,Avoid,Avoid,25437,doc/master/classTEveTrans.html,https://root.cern,https://root.cern/doc/master/classTEveTrans.html,1,['Avoid'],['Avoid']
Safety,"31 else if (fSumw2.fN) {; 1032 w2 = 1.E200; // use an arbitrary huge value; 1033 if (y2 == 0) {; 1034 // use an estimated error from the global histogram scale; 1035 double sf = (s1[0] != 0) ? s1[1]/s1[0] : 1;; 1036 w2 = 1./(sf*sf);; 1037 }; 1038 }; 1039 ; 1040 double y = (w1*y1 + w2*y2)/(w1 + w2);; 1041 UpdateBinContent(bin, y);; 1042 if (fSumw2.fN) {; 1043 double err2 = 1./(w1 + w2);; 1044 if (err2 < 1.E-200) err2 = 0; // to remove arbitrary value when e1=0 AND e2=0; 1045 fSumw2.fArray[bin] = err2;; 1046 }; 1047 } else { // normal case of addition between histograms; 1048 AddBinContent(bin, c1 * factor * h1->RetrieveBinContent(bin));; 1049 if (fSumw2.fN) fSumw2.fArray[bin] += c1sq * factsq * h1->GetBinErrorSqUnchecked(bin);; 1050 }; 1051 }; 1052 ; 1053 // update statistics (do here to avoid changes by SetBinContent); 1054 if (resetStats) {; 1055 // statistics need to be reset in case coefficient are negative; 1056 ResetStats();; 1057 }; 1058 else {; 1059 for (Int_t i=0;i<kNstat;i++) {; 1060 if (i == 1) s1[i] += c1*c1*s2[i];; 1061 else s1[i] += c1*s2[i];; 1062 }; 1063 PutStats(s1);; 1064 SetEntries(entries);; 1065 }; 1066 return kTRUE;; 1067}; 1068 ; 1069////////////////////////////////////////////////////////////////////////////////; 1070/// Replace contents of this histogram by the addition of h1 and h2.; 1071///; 1072/// `this = c1*h1 + c2*h2`; 1073/// if errors are defined (see TH1::Sumw2), errors are also recalculated; 1074///; 1075/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 1076/// if not already set.; 1077///; 1078/// Note also that adding histogram with labels is not supported, histogram will be; 1079/// added merging them by bin number independently of the labels.; 1080/// For adding histogram ith labels one should use TH1::Merge; 1081///; 1082/// SPECIAL CASE (Average/Efficiency histograms); 1083/// For histograms representing averages or efficiencies, one should compute the average; 1084/// of the two histograms and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:42046,avoid,avoid,42046,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['avoid'],['avoid']
Safety,"32 TString opts(options);; 4133 Int_t ito = opts.Index(""TIMEOUT="");; 4134 if (ito != kNPOS) {; 4135 TString sto = opts(ito + strlen(""TIMEOUT=""), opts.Length());; 4136 while (!(sto.IsDigit()) && !(sto.IsNull())) { sto.Remove(sto.Length()-1,1); }; 4137 if (!(sto.IsNull())) {; 4138 // Timeout in millisecs; 4139 Int_t toms = sto.Atoi() * 1000;; 4140 if (gDebug > 0) ::Info(""TFile::Open"", ""timeout of %d millisec requested"", toms);; 4141 // Remove from the options field; 4142 sto.Insert(0, ""TIMEOUT="");; 4143 opts.ReplaceAll(sto, """");; 4144 // Asynchronous open; 4145 TFileOpenHandle *fh = TFile::AsyncOpen(expandedUrl, opts, ftitle, compress, netopt);; 4146 // Check the result in steps of 1 millisec; 4147 TFile::EAsyncOpenStatus aos = TFile::kAOSNotAsync;; 4148 aos = TFile::GetAsyncOpenStatus(fh);; 4149 Int_t xtms = toms;; 4150 while (aos == TFile::kAOSInProgress && xtms > 0) {; 4151 gSystem->Sleep(1);; 4152 xtms -= 1;; 4153 aos = TFile::GetAsyncOpenStatus(fh);; 4154 }; 4155 if (aos == TFile::kAOSNotAsync || aos == TFile::kAOSSuccess) {; 4156 // Do open the file now; 4157 f = TFile::Open(fh);; 4158 if (gDebug > 0) {; 4159 if (aos == TFile::kAOSSuccess); 4160 ::Info(""TFile::Open"", ""waited %d millisec for asynchronous open"", toms - xtms);; 4161 else; 4162 ::Info(""TFile::Open"", ""timeout option not supported (requires asynchronous""; 4163 "" open support)"");; 4164 }; 4165 } else {; 4166 if (xtms <= 0); 4167 ::Error(""TFile::Open"", ""timeout expired while opening '%s'"", expandedUrl.Data());; 4168 // Cleanup the request; 4169 SafeDelete(fh);; 4170 }; 4171 // Done; 4172 return f;; 4173 } else {; 4174 ::Warning(""TFile::Open"", ""incomplete 'TIMEOUT=' option specification - ignored"");; 4175 opts.ReplaceAll(""TIMEOUT="", """");; 4176 }; 4177 }; 4178 ; 4179 // We will use this from now on; 4180 const char *option = opts;; 4181 ; 4182 // Many URLs? Redirect output and print errors in case of global failure; 4183 TString namelist(expandedUrl);; 4184 Ssiz_t ip = namelist.Index(""|"");; 4185 Bool_t red",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:152444,timeout,timeout,152444,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,['timeout'],['timeout']
Safety,"37 case TStreamerInfo::kOffsetL + TStreamerInfo::kStreamLoop:; 3738 writeSequence->AddAction(WriteStreamerLoop<true>, new TConfiguration(this, i, compinfo, compinfo->fOffset));; 3739 break;; 3740 ; 3741 case TStreamerInfo::kBase: isBase = kTRUE; break;; 3742 ; 3743 case TStreamerInfo::kStreamer:; 3744 writeSequence->AddAction(WriteTextStreamer, new TGenericConfiguration(this, i, compinfo));; 3745 break;; 3746 ; 3747 // case TStreamerInfo::kBits: writeSequence->AddAction( WriteBasicType<BitsMarker>, new; 3748 // TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; 3749 /*case TStreamerInfo::kFloat16: {; 3750 if (element->GetFactor() != 0) {; 3751 writeSequence->AddAction( WriteBasicType_WithFactor<float>, new; 3752 TConfWithFactor(this,i,compinfo,compinfo->fOffset,element->GetFactor(),element->GetXmin()) );; 3753 } else {; 3754 Int_t nbits = (Int_t)element->GetXmin();; 3755 if (!nbits) nbits = 12;; 3756 writeSequence->AddAction( WriteBasicType_NoFactor<float>, new; 3757 TConfNoFactor(this,i,compinfo,compinfo->fOffset,nbits) );; 3758 }; 3759 break;; 3760 } */; 3761 /*case TStreamerInfo::kDouble32: {; 3762 if (element->GetFactor() != 0) {; 3763 writeSequence->AddAction( WriteBasicType_WithFactor<double>, new; 3764 TConfWithFactor(this,i,compinfo,compinfo->fOffset,element->GetFactor(),element->GetXmin()) );; 3765 } else {; 3766 Int_t nbits = (Int_t)element->GetXmin();; 3767 if (!nbits) {; 3768 writeSequence->AddAction( ConvertBasicType<float,double>, new; 3769 TConfiguration(this,i,compinfo,compinfo->fOffset) );; 3770 } else {; 3771 writeSequence->AddAction( WriteBasicType_NoFactor<double>, new; 3772 TConfNoFactor(this,i,compinfo,compinfo->fOffset,nbits) );; 3773 }; 3774 }; 3775 break;; 3776 } */; 3777 // case TStreamerInfo::kTNamed: writeSequence->AddAction( WriteTNamed, new; 3778 // TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; 3779 // Idea: We should calculate the CanIgnoreTObjectStreamer here and avoid calling the; 3780 // Streamer alltogether.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:175138,avoid,avoid,175138,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['avoid'],['avoid']
Safety,"3=TMath::QuietNaN(), double p4=TMath::QuietNaN(), double p5=TMath::QuietNaN(), double p6=TMath::QuietNaN(), double p7=TMath::QuietNaN(), double p8=TMath::QuietNaN(), double p9=TMath::QuietNaN(), double p10=TMath::QuietNaN())Set parameter values.Definition TF1.h:684; TF1::TF1TF1()TF1 default constructor.Definition TF1.cxx:489; TF1::DrawCopyvirtual TF1 * DrawCopy(Option_t *option="""") constDraw a copy of this function with its current attributes.Definition TF1.cxx:1363; TF1::fParMaxstd::vector< Double_t > fParMaxArray of upper limits of the fNpar parameters.Definition TF1.h:276; TF1::IsVectorizedbool IsVectorized()Definition TF1.h:467; TF1::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TF1.cxx:3218; TF1::IsValidvirtual Bool_t IsValid() constReturn kTRUE if the function is valid.Definition TF1.cxx:2882; TF1::DefaultAddToGlobalListstatic Bool_t DefaultAddToGlobalList(Bool_t on=kTRUE)Static method to add/avoid to add automatically functions to the global list (gROOT->GetListOfFunctio...Definition TF1.cxx:838; TF1::fSavestd::vector< Double_t > fSaveArray of fNsave function values.Definition TF1.h:277; TF1::RejectedPointstatic Bool_t RejectedPoint()See TF1::RejectPoint above.Definition TF1.cxx:3692; TF1::DefineNSUMTermvoid DefineNSUMTerm(TObjArray *newFuncs, TObjArray *coeffNames, TString &fullFormula, TString &formula, int termStart, int termEnd, Double_t xmin, Double_t xmax)Helper functions for NSUM parsing.Definition TF1.cxx:883; TF1::fGammastd::vector< Double_t > fGamma! Array gamma.Definition TF1.h:281; TF1::fParentTObject * fParent! Parent object hooking this function (if one)Definition TF1.h:282; TF1::GetMinMaxNDimvirtual Double_t GetMinMaxNDim(Double_t *x, Bool_t findmax, Double_t epsilon=0, Int_t maxiter=0) constFind the minimum of a function of whatever dimension.Definition TF1.cxx:1723; TF1::DrawF1virtual void DrawF1(Double_t xmin, Double_t xmax, Option_t *optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8h_source.html:63690,avoid,avoid,63690,doc/master/TF1_8h_source.html,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html,1,['avoid'],['avoid']
Safety,"4 ; 895std::string TSystem::GetHomeDirectory(const char *) const; 896{; 897 return std::string();; 898}; 899 ; 900////////////////////////////////////////////////////////////////////////////////; 901/// Make a file system directory. Returns 0 in case of success and; 902/// -1 if the directory could not be created (either already exists or; 903/// illegal path name).; 904/// If 'recursive' is true, makes parent directories as needed.; 905 ; 906int TSystem::mkdir(const char *name, Bool_t recursive); 907{; 908 if (recursive) {; 909 TString safeName = name; // local copy in case 'name' is output from; 910 // TSystem::DirName as it uses static buffers; 911 TString dirname = GetDirName(safeName.Data());; 912 if (dirname.IsNull()) {; 913 // well we should not have to make the root of the file system!; 914 // (and this avoid infinite recursions!); 915 return -1;; 916 }; 917 if (AccessPathName(dirname.Data(), kFileExists)) {; 918 int res = mkdir(dirname.Data(), kTRUE);; 919 if (res) return res;; 920 }; 921 if (!AccessPathName(safeName.Data(), kFileExists)) {; 922 return -1;; 923 }; 924 }; 925 ; 926 return MakeDirectory(name);; 927}; 928 ; 929//---- Paths & Files -----------------------------------------------------------; 930 ; 931////////////////////////////////////////////////////////////////////////////////; 932/// Base name of a file name. Base name of /user/root is root.; 933 ; 934const char *TSystem::BaseName(const char *name); 935{; 936 if (name) {; 937 if (name[0] == '/' && name[1] == '\0'); 938 return name;; 939 char *cp;; 940 if ((cp = (char *)strrchr(name, '/'))); 941 return ++cp;; 942 return name;; 943 }; 944 Error(""BaseName"", ""name = 0"");; 945 return nullptr;; 946}; 947 ; 948////////////////////////////////////////////////////////////////////////////////; 949/// Return true if dir is an absolute pathname.; 950 ; 951Bool_t TSystem::IsAbsoluteFileName(const char *dir); 952{; 953 if (dir); 954 return dir[0] == '/';; 955 return kFALSE;; 956}; 957 ; 958///////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:27853,safe,safeName,27853,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['safe'],['safeName']
Safety,"4 TClass::AddClassToDeclIdMap(((TClingClassInfo*)cl->fClassInfo)->GetDeclId(), cl);; 4155 }; 4156}; 4157 ; 4158////////////////////////////////////////////////////////////////////////////////; 4159/// Checks if an entity with the specified name is defined in Cling.; 4160/// Returns kUnknown if the entity is not defined.; 4161/// Returns kWithClassDefInline if the entity exists and has a ClassDefInline; 4162/// Returns kKnown if the entity is defined.; 4163///; 4164/// By default, structs, namespaces, classes, enums and unions are looked for.; 4165/// If the flag isClassOrNamespaceOnly is true, classes, structs and; 4166/// namespaces only are considered. I.e. if the name is an enum or a union,; 4167/// the returned value is false.; 4168///; 4169/// In the case where the class is not loaded and belongs to a namespace; 4170/// or is nested, looking for the full class name is outputting a lots of; 4171/// (expected) error messages. Currently the only way to avoid this is to; 4172/// specifically check that each level of nesting is already loaded.; 4173/// In case of templates the idea is that everything between the outer; 4174/// '<' and '>' has to be skipped, e.g.: `aap<pippo<noot>::klaas>::a_class`; 4175 ; 4176TInterpreter::ECheckClassInfo; 4177TCling::CheckClassInfo(const char *name, Bool_t autoload, Bool_t isClassOrNamespaceOnly /* = kFALSE*/); 4178{; 4179 R__LOCKGUARD(gInterpreterMutex);; 4180 static const char *anonEnum = ""anonymous enum "";; 4181 static const int cmplen = strlen(anonEnum);; 4182 ; 4183 if (fIsShuttingDown || 0 == strncmp(name, anonEnum, cmplen)) {; 4184 return kUnknown;; 4185 }; 4186 ; 4187 // Do not turn on the AutoLoading if it is globally off.; 4188 autoload = autoload && IsClassAutoLoadingEnabled();; 4189 ; 4190 // Avoid the double search below in case the name is a fundamental type; 4191 // or typedef to a fundamental type.; 4192 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 4193 TDataType *fundType = (TDataTy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:161560,avoid,avoid,161560,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avoid'],['avoid']
Safety,"4 of file TProof.h. â—†Â IsSync(). Bool_t TProof::IsSync ; (; ); const. inlineprivate . Definition at line 669 of file TProof.h. â—†Â IsTty(). Bool_t TProof::IsTty ; (; ); const. inline . Definition at line 938 of file TProof.h. â—†Â IsValid(). Bool_t TProof::IsValid ; (; ); const. inline . Definition at line 937 of file TProof.h. â—†Â IsWaiting(). Bool_t TProof::IsWaiting ; (; ); const. inline . Definition at line 941 of file TProof.h. â—†Â Load(). Int_t TProof::Load ; (; const char *Â ; macro, . Bool_tÂ ; notOnClient = kFALSE, . Bool_tÂ ; uniqueWorkers = kTRUE, . TList *Â ; wrks = 0Â . ). virtual . Load the specified macro on master, workers and, if notOnClient is kFALSE, on the client. ; The macro file is uploaded if new or updated. Additional files to be uploaded (or updated, if needed) can be specified after a comma, e.g. ""mymacro.C+,thisheader.h,thatheader.h"". If existing in the same directory, a header basename(macro).h or .hh, is also uploaded. The default is to load the macro also on the client; notOnClient can be used to avoid loading on the client. On masters, if uniqueWorkers is kTRUE, the macro is loaded on unique workers only, and collection is not done; if uniqueWorkers is kFALSE, collection from the previous request is done, and broadcasting + collection from the other workers is done. The wrks arg can be used on the master to limit the set of workers. Returns 0 in case of success and -1 in case of error. ; Reimplemented in TProofLite.; Definition at line 8628 of file TProof.cxx. â—†Â LoadPackage(). Int_t TProof::LoadPackage ; (; const char *Â ; package, . Bool_tÂ ; notOnClient = kFALSE, . TList *Â ; loadopts = 0, . TList *Â ; workers = 0Â . ). private . Load specified package. ; Executes the PROOF-INF/SETUP.C script on all active nodes. If notOnClient = true, don't load package on the client. The default is to load the package also on the client. The argument 'loadopts' specify a list of objects to be passed to the SETUP. The objects in the list must be streamable; the SETUP ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:114395,avoid,avoid,114395,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['avoid'],['avoid']
Safety,"42 Double_t xlim0, xlim1, xlim2, xlim3, xlim4; // --x-- on region boundaries; 943 Double_t a0=0, d0=0, d2=0, e0=0, e2=0, e4=0, h0=0, h2=0, h4=0, h6=0;// W4 temporary variables; 944 Double_t p0=0, p2=0, p4=0, p6=0, p8=0, z0=0, z2=0, z4=0, z6=0, z8=0;; 945 Double_t xp[6], xm[6], yp[6], ym[6]; // CPF12 temporary values; 946 Double_t mq[6], pq[6], mf[6], pf[6];; 947 Double_t d, yf, ypy0, ypy0q;; 948 ; 949 //***** Start of executable code *****************************************; 950 ; 951 rg1 = 1; // Set flags; 952 rg2 = 1;; 953 rg3 = 1;; 954 yq = y * y; // y^2; 955 yrrtpi = y * rrtpi; // y/SQRT(pi); 956 ; 957 // Region boundaries when both k and L are required or when R<>4; 958 ; 959 xlim0 = r0 - y;; 960 xlim1 = r1 - y;; 961 xlim3 = 3.097 * y - 0.45;; 962 xlim2 = 6.8 - y;; 963 xlim4 = 18.1 * y + 1.65;; 964 if ( y <= 1e-6 ) { // When y<10^-6 avoid W4 algorithm; 965 xlim1 = xlim0;; 966 xlim2 = xlim0;; 967 }; 968 ; 969 abx = fabs(x); // |x|; 970 xq = abx * abx; // x^2; 971 if ( abx > xlim0 ) { // Region 0 algorithm; 972 k = yrrtpi / (xq + yq);; 973 } else if ( abx > xlim1 ) { // Humlicek W4 Region 1; 974 if ( rg1 != 0 ) { // First point in Region 1; 975 rg1 = 0;; 976 a0 = yq + 0.5; // Region 1 y-dependents; 977 d0 = a0*a0;; 978 d2 = yq + yq - 1.0;; 979 }; 980 d = rrtpi / (d0 + xq*(d2 + xq));; 981 k = d * y * (a0 + xq);; 982 } else if ( abx > xlim2 ) { // Humlicek W4 Region 2; 983 if ( rg2 != 0 ) { // First point in Region 2; 984 rg2 = 0;; 985 h0 = 0.5625 + yq * (4.5 + yq * (10.5 + yq * (6.0 + yq)));; 986 // Region 2 y-dependents; 987 h2 = -4.5 + yq * (9.0 + yq * ( 6.0 + yq * 4.0));; 988 h4 = 10.5 - yq * (6.0 - yq * 6.0);; 989 h6 = -6.0 + yq * 4.0;; 990 e0 = 1.875 + yq * (8.25 + yq * (5.5 + yq));; 991 e2 = 5.25 + yq * (1.0 + yq * 3.0);; 992 e4 = 0.75 * h6;; 993 }; 994 d = rrtpi / (h0 + xq * (h2 + xq * (h4 + xq * (h6 + xq))));; 995 k = d * y * (e0 + xq * (e2 + xq * (e4 + xq)));; 996 } else if ( abx < xlim3 ) { // Humlicek W4 Region 3; 997 if ( rg3 != 0 ) { // First point i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:32072,avoid,avoid,32072,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['avoid'],['avoid']
Safety,"42.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; ... (remaining 14 messages suppressed); ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=-3.35967 cHl3=-9.58704 cHq3=-6.27461; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.154263 cHl3=2.95902 cHq3=-2.78828; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=59.1285, denominator=wrap_pdf_Int[pTV]=200921; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.338546 cHl3=0.879879 cHq3=-1.35856; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:14551,recover,recover,14551,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,"4265 ; 4266 case 431:; 4267 return ""Request Header Fields Too Large""; /* RFC 6585, Section 5 */; 4268 ; 4269 case 451:; 4270 return ""Unavailable For Legal Reasons""; /* draft-tbray-http-legally-restricted-status-05,; 4271 * Section 3 */; 4272 ; 4273 /* RFC2616 Section 10.5 - Server Error 5xx */; 4274 case 500:; 4275 return ""Internal Server Error""; /* RFC2616 Section 10.5.1 */; 4276 case 501:; 4277 return ""Not Implemented""; /* RFC2616 Section 10.5.2 */; 4278 case 502:; 4279 return ""Bad Gateway""; /* RFC2616 Section 10.5.3 */; 4280 case 503:; 4281 return ""Service Unavailable""; /* RFC2616 Section 10.5.4 */; 4282 case 504:; 4283 return ""Gateway Time-out""; /* RFC2616 Section 10.5.5 */; 4284 case 505:; 4285 return ""HTTP Version not supported""; /* RFC2616 Section 10.5.6 */; 4286 case 506:; 4287 return ""Variant Also Negotiates""; /* RFC 2295, Section 8.1 */; 4288 case 507:; 4289 return ""Insufficient Storage""; /* RFC2518 Section 10.6, RFC4918; 4290 * Section 11.5 */; 4291 case 508:; 4292 return ""Loop Detected""; /* RFC5842 Section 7.1 */; 4293 ; 4294 case 510:; 4295 return ""Not Extended""; /* RFC 2774, Section 7 */; 4296 case 511:; 4297 return ""Network Authentication Required""; /* RFC 6585, Section 6 */; 4298 ; 4299 /* Other status codes, not shown in the IANA HTTP status code; 4300 * assignment.; 4301 * E.g., ""de facto"" standards due to common use, ... */; 4302 case 418:; 4303 return ""I am a teapot""; /* RFC2324 Section 2.3.2 */; 4304 case 419:; 4305 return ""Authentication Timeout""; /* common use */; 4306 case 420:; 4307 return ""Enhance Your Calm""; /* common use */; 4308 case 440:; 4309 return ""Login Timeout""; /* common use */; 4310 case 509:; 4311 return ""Bandwidth Limit Exceeded""; /* common use */; 4312 ; 4313 default:; 4314 /* This error code is unknown. This should not happen. */; 4315 if (conn) {; 4316 mg_cry_internal(conn,; 4317 ""Unknown HTTP response code: %u"",; 4318 response_code);; 4319 }; 4320 ; 4321 /* Return at least a category according to RFC 2616 Section 10. */; 43",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:128070,Detect,Detected,128070,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['Detect'],['Detected']
Safety,"4266 ; 4267 case 431:; 4268 return ""Request Header Fields Too Large""; /* RFC 6585, Section 5 */; 4269 ; 4270 case 451:; 4271 return ""Unavailable For Legal Reasons""; /* draft-tbray-http-legally-restricted-status-05,; 4272 * Section 3 */; 4273 ; 4274 /* RFC2616 Section 10.5 - Server Error 5xx */; 4275 case 500:; 4276 return ""Internal Server Error""; /* RFC2616 Section 10.5.1 */; 4277 case 501:; 4278 return ""Not Implemented""; /* RFC2616 Section 10.5.2 */; 4279 case 502:; 4280 return ""Bad Gateway""; /* RFC2616 Section 10.5.3 */; 4281 case 503:; 4282 return ""Service Unavailable""; /* RFC2616 Section 10.5.4 */; 4283 case 504:; 4284 return ""Gateway Time-out""; /* RFC2616 Section 10.5.5 */; 4285 case 505:; 4286 return ""HTTP Version not supported""; /* RFC2616 Section 10.5.6 */; 4287 case 506:; 4288 return ""Variant Also Negotiates""; /* RFC 2295, Section 8.1 */; 4289 case 507:; 4290 return ""Insufficient Storage""; /* RFC2518 Section 10.6, RFC4918; 4291 * Section 11.5 */; 4292 case 508:; 4293 return ""Loop Detected""; /* RFC5842 Section 7.1 */; 4294 ; 4295 case 510:; 4296 return ""Not Extended""; /* RFC 2774, Section 7 */; 4297 case 511:; 4298 return ""Network Authentication Required""; /* RFC 6585, Section 6 */; 4299 ; 4300 /* Other status codes, not shown in the IANA HTTP status code; 4301 * assignment.; 4302 * E.g., ""de facto"" standards due to common use, ... */; 4303 case 418:; 4304 return ""I am a teapot""; /* RFC2324 Section 2.3.2 */; 4305 case 419:; 4306 return ""Authentication Timeout""; /* common use */; 4307 case 420:; 4308 return ""Enhance Your Calm""; /* common use */; 4309 case 440:; 4310 return ""Login Timeout""; /* common use */; 4311 case 509:; 4312 return ""Bandwidth Limit Exceeded""; /* common use */; 4313 ; 4314 default:; 4315 /* This error code is unknown. This should not happen. */; 4316 if (conn) {; 4317 mg_cry_internal(conn,; 4318 ""Unknown HTTP response code: %u"",; 4319 response_code);; 4320 }; 4321 ; 4322 /* Return at least a category according to RFC 2616 Section 10. */; 43",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:128102,Detect,Detected,128102,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['Detect'],['Detected']
Safety,"43 ; 15044 /* Set reuse option, but don't abort on errors. */; 15045 mg_cry_ctx_internal(; 15046 phys_ctx,; 15047 ""cannot set socket option SO_EXCLUSIVEADDRUSE (entry %i)"",; 15048 portsTotal);; 15049 }; 15050#else; 15051 if (setsockopt(so.sock,; 15052 SOL_SOCKET,; 15053 SO_REUSEADDR,; 15054 (SOCK_OPT_TYPE)&on,; 15055 sizeof(on)); 15056 != 0) {; 15057 ; 15058 /* Set reuse option, but don't abort on errors. */; 15059 mg_cry_ctx_internal(; 15060 phys_ctx,; 15061 ""cannot set socket option SO_REUSEADDR (entry %i)"",; 15062 portsTotal);; 15063 }; 15064#endif; 15065 ; 15066#if defined(USE_X_DOM_SOCKET); 15067 if (ip_version == 99) {; 15068 /* Unix domain socket */; 15069 } else; 15070#endif; 15071 ; 15072 if (ip_version > 4) {; 15073 /* Could be 6 for IPv6 onlyor 10 (4+6) for IPv4+IPv6 */; 15074#if defined(USE_IPV6); 15075 if (ip_version > 6) {; 15076 if (so.lsa.sa.sa_family == AF_INET6; 15077 && setsockopt(so.sock,; 15078 IPPROTO_IPV6,; 15079 IPV6_V6ONLY,; 15080 (void *)&off,; 15081 sizeof(off)); 15082 != 0) {; 15083 ; 15084 /* Set IPv6 only option, but don't abort on errors. */; 15085 mg_cry_ctx_internal(phys_ctx,; 15086 ""cannot set socket option ""; 15087 ""IPV6_V6ONLY=off (entry %i)"",; 15088 portsTotal);; 15089 }; 15090 } else {; 15091 if (so.lsa.sa.sa_family == AF_INET6; 15092 && setsockopt(so.sock,; 15093 IPPROTO_IPV6,; 15094 IPV6_V6ONLY,; 15095 (void *)&on,; 15096 sizeof(on)); 15097 != 0) {; 15098 ; 15099 /* Set IPv6 only option, but don't abort on errors. */; 15100 mg_cry_ctx_internal(phys_ctx,; 15101 ""cannot set socket option ""; 15102 ""IPV6_V6ONLY=on (entry %i)"",; 15103 portsTotal);; 15104 }; 15105 }; 15106#else; 15107 mg_cry_ctx_internal(phys_ctx, ""%s"", ""IPv6 not available"");; 15108 closesocket(so.sock);; 15109 so.sock = INVALID_SOCKET;; 15110 continue;; 15111#endif; 15112 }; 15113 ; 15114 if (so.lsa.sa.sa_family == AF_INET) {; 15115 ; 15116 len = sizeof(so.lsa.sin);; 15117 if (bind(so.sock, &so.lsa.sa, len) != 0) {; 15118 mg_cry_ctx_internal(phys_ctx,; 15119 ""cannot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:446301,abort,abort,446301,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"4340705d2c4db7f8).; 1177 ; 1178\warning Note that in multi-thread event loops the values of `rdfentry_` _do not_ correspond to what would be the entry numbers; 1179of a TChain constructed over the same set of ROOT files, as the entries are processed in an unspecified order.; 1180 ; 1181\anchor jitting; 1182### Just-in-time compilation: column type inference and explicit declaration of column types; 1183C++ is a statically typed language: all types must be known at compile-time. This includes the types of the TTree; 1184branches we want to work on. For filters, defined columns and some of the actions, **column types are deduced from the; 1185signature** of the relevant filter function/temporary column expression/action function:; 1186~~~{.cpp}; 1187// here b1 is deduced to be `int` and b2 to be `double`; 1188df.Filter([](int x, double y) { return x > 0 && y < 0.; }, {""b1"", ""b2""});; 1189~~~; 1190If we specify an incorrect type for one of the columns, an exception with an informative message will be thrown at; 1191runtime, when the column value is actually read from the dataset: RDataFrame detects type mismatches. The same would; 1192happen if we swapped the order of ""b1"" and ""b2"" in the column list passed to Filter().; 1193 ; 1194Certain actions, on the other hand, do not take a function as argument (e.g. Histo1D()), so we cannot deduce the type of; 1195the column at compile-time. In this case **RDataFrame infers the type of the column** from the TTree itself. This; 1196is why we never needed to specify the column types for all actions in the above snippets.; 1197 ; 1198When the column type is not a common one such as `int`, `double`, `char` or `float` it is nonetheless good practice to; 1199specify it as a template parameter to the action itself, like this:; 1200~~~{.cpp}; 1201df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; 1202df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; 1203~~~; 1204 ; 1205Deducing types a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:69952,detect,detects,69952,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['detect'],['detects']
Safety,"4340705d2c4db7f8).; 1217 ; 1218\warning Note that in multi-thread event loops the values of `rdfentry_` _do not_ correspond to what would be the entry numbers; 1219of a TChain constructed over the same set of ROOT files, as the entries are processed in an unspecified order.; 1220 ; 1221\anchor jitting; 1222### Just-in-time compilation: column type inference and explicit declaration of column types; 1223C++ is a statically typed language: all types must be known at compile-time. This includes the types of the TTree; 1224branches we want to work on. For filters, defined columns and some of the actions, **column types are deduced from the; 1225signature** of the relevant filter function/temporary column expression/action function:; 1226~~~{.cpp}; 1227// here b1 is deduced to be `int` and b2 to be `double`; 1228df.Filter([](int x, double y) { return x > 0 && y < 0.; }, {""b1"", ""b2""});; 1229~~~; 1230If we specify an incorrect type for one of the columns, an exception with an informative message will be thrown at; 1231runtime, when the column value is actually read from the dataset: RDataFrame detects type mismatches. The same would; 1232happen if we swapped the order of ""b1"" and ""b2"" in the column list passed to Filter().; 1233 ; 1234Certain actions, on the other hand, do not take a function as argument (e.g. Histo1D()), so we cannot deduce the type of; 1235the column at compile-time. In this case **RDataFrame infers the type of the column** from the TTree itself. This; 1236is why we never needed to specify the column types for all actions in the above snippets.; 1237 ; 1238When the column type is not a common one such as `int`, `double`, `char` or `float` it is nonetheless good practice to; 1239specify it as a template parameter to the action itself, like this:; 1240~~~{.cpp}; 1241df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; 1242df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; 1243~~~; 1244 ; 1245Deducing types a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:71632,detect,detects,71632,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['detect'],['detects']
Safety,"435 {; 436#ifdef R__USE_IMT; 437 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TImplicitMT_DisableParBranchProcessing"");; 438 if (sym); 439 sym();; 440#else; 441 ::Warning(""DisableParBranchProcessing"", ""Cannot disable parallel branch processing, please build ROOT with -Dimt=ON"");; 442#endif; 443 }; 444 ; 445 //////////////////////////////////////////////////////////////////////////////; 446 /// Returns true if parallel branch processing is enabled.; 447 Bool_t IsParBranchProcessingEnabled(); 448 {; 449#ifdef R__USE_IMT; 450 static Bool_t (*sym)() = (Bool_t(*)())Internal::GetSymInLibImt(""ROOT_TImplicitMT_IsParBranchProcessingEnabled"");; 451 if (sym); 452 return sym();; 453 else; 454 return kFALSE;; 455#else; 456 return kFALSE;; 457#endif; 458 }; 459 ; 460 ////////////////////////////////////////////////////////////////////////////////; 461 /// Keeps track of the status of ImplicitMT w/o resorting to the load of; 462 /// libImt; 463 static Bool_t &IsImplicitMTEnabledImpl(); 464 {; 465 static Bool_t isImplicitMTEnabled = kFALSE;; 466 return isImplicitMTEnabled;; 467 }; 468 ; 469} // end of Internal sub namespace; 470// back to ROOT namespace; 471 ; 472 TROOT *GetROOT() {; 473 return (*Internal::gGetROOT)();; 474 }; 475 ; 476 TString &GetMacroPath() {; 477 static TString macroPath;; 478 return macroPath;; 479 }; 480 ; 481 // clang-format off; 482 ////////////////////////////////////////////////////////////////////////////////; 483 /// Enables the global mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:16856,safe,safe,16856,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['safe'],['safe']
Safety,"44 ; 15045 /* Set reuse option, but don't abort on errors. */; 15046 mg_cry_ctx_internal(; 15047 phys_ctx,; 15048 ""cannot set socket option SO_EXCLUSIVEADDRUSE (entry %i)"",; 15049 portsTotal);; 15050 }; 15051#else; 15052 if (setsockopt(so.sock,; 15053 SOL_SOCKET,; 15054 SO_REUSEADDR,; 15055 (SOCK_OPT_TYPE)&on,; 15056 sizeof(on)); 15057 != 0) {; 15058 ; 15059 /* Set reuse option, but don't abort on errors. */; 15060 mg_cry_ctx_internal(; 15061 phys_ctx,; 15062 ""cannot set socket option SO_REUSEADDR (entry %i)"",; 15063 portsTotal);; 15064 }; 15065#endif; 15066 ; 15067#if defined(USE_X_DOM_SOCKET); 15068 if (ip_version == 99) {; 15069 /* Unix domain socket */; 15070 } else; 15071#endif; 15072 ; 15073 if (ip_version > 4) {; 15074 /* Could be 6 for IPv6 onlyor 10 (4+6) for IPv4+IPv6 */; 15075#if defined(USE_IPV6); 15076 if (ip_version > 6) {; 15077 if (so.lsa.sa.sa_family == AF_INET6; 15078 && setsockopt(so.sock,; 15079 IPPROTO_IPV6,; 15080 IPV6_V6ONLY,; 15081 (void *)&off,; 15082 sizeof(off)); 15083 != 0) {; 15084 ; 15085 /* Set IPv6 only option, but don't abort on errors. */; 15086 mg_cry_ctx_internal(phys_ctx,; 15087 ""cannot set socket option ""; 15088 ""IPV6_V6ONLY=off (entry %i)"",; 15089 portsTotal);; 15090 }; 15091 } else {; 15092 if (so.lsa.sa.sa_family == AF_INET6; 15093 && setsockopt(so.sock,; 15094 IPPROTO_IPV6,; 15095 IPV6_V6ONLY,; 15096 (void *)&on,; 15097 sizeof(on)); 15098 != 0) {; 15099 ; 15100 /* Set IPv6 only option, but don't abort on errors. */; 15101 mg_cry_ctx_internal(phys_ctx,; 15102 ""cannot set socket option ""; 15103 ""IPV6_V6ONLY=on (entry %i)"",; 15104 portsTotal);; 15105 }; 15106 }; 15107#else; 15108 mg_cry_ctx_internal(phys_ctx, ""%s"", ""IPv6 not available"");; 15109 closesocket(so.sock);; 15110 so.sock = INVALID_SOCKET;; 15111 continue;; 15112#endif; 15113 }; 15114 ; 15115 if (so.lsa.sa.sa_family == AF_INET) {; 15116 ; 15117 len = sizeof(so.lsa.sin);; 15118 if (bind(so.sock, &so.lsa.sa, len) != 0) {; 15119 mg_cry_ctx_internal(phys_ctx,; 15120 ""cannot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:446334,abort,abort,446334,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"49 && (fComp[fNdata].fType == kObjectp || fComp[fNdata].fType == kAnyp; 3150 || fComp[fNdata].fType == kObject || fComp[fNdata].fType == kAny; 3151 || fComp[fNdata].fType == kTObject || fComp[fNdata].fType == kTNamed || fComp[fNdata].fType == kTString ); 3152 ) {; 3153 fComp[fNdata].fType = fComp[fNdata].fNewType;; 3154 } else if (fComp[fNdata].fType != kCounter) {; 3155 fComp[fNdata].fType += kConv;; 3156 }; 3157 } else {; 3158 if (fComp[fNdata].fType == kCounter) {; 3159 Warning(""Compile"", ""Counter %s should not be skipped from class %s"", element->GetName(), GetName());; 3160 }; 3161 fComp[fNdata].fType += kSkip;; 3162 }; 3163 }; 3164 fCompOpt[fNdata] = &(fComp[fNdata]);; 3165 fCompFull[fNfulldata] = &(fComp[fNdata]);; 3166 ; 3167 R__ASSERT( fNdata < (fNslots - optiOut) );; 3168 ; 3169 keep = fNdata;; 3170 if (fComp[keep].fLength == 0) {; 3171 fComp[keep].fLength = 1;; 3172 }; 3173 fNdata++;; 3174 previousOptimized = kFALSE;; 3175 }; 3176 // The test 'fMethod[keep] == 0' fails to detect a variable size array; 3177 // if the counter happens to have an offset of zero, so let's explicitly; 3178 // prevent for here.; 3179 if (element->HasCounter()) keep = -1;; 3180 ++fNfulldata;; 3181 previous = element;; 3182 }; 3183 ; 3184 for (i = 0; i < fNdata; ++i) {; 3185 if (!fCompOpt[i]->fElem || fCompOpt[i]->fElem->GetType()< 0) {; 3186 continue;; 3187 }; 3188 AddReadAction(fReadObjectWise, i, fCompOpt[i]);; 3189 AddWriteAction(fWriteObjectWise, i, fCompOpt[i]);; 3190 }; 3191 for (i = 0; i < fNfulldata; ++i) {; 3192 if (!fCompFull[i]->fElem || fCompFull[i]->fElem->GetType()< 0) {; 3193 continue;; 3194 }; 3195 AddReadAction(fReadMemberWise, i, fCompFull[i]);; 3196 AddWriteAction(fWriteMemberWise, i, fCompFull[i]);; 3197 AddReadMemberWiseVecPtrAction(fReadMemberWiseVecPtr, i, fCompFull[i]);; 3198 AddWriteMemberWiseVecPtrAction(fWriteMemberWiseVecPtr, i, fCompFull[i]);; 3199 ; 3200 AddReadTextAction(fReadText, i, fCompFull[i]);; 3201 AddWriteTextAction(fWriteText, i, fCompFull[i]",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:138973,detect,detect,138973,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['detect'],['detect']
Safety,"4]. Int_t TProof::Collect ; (; ESlavesÂ ; list = kActive, . Long_tÂ ; timeout = -1, . Int_tÂ ; endtype = -1, . Bool_tÂ ; deactonfail = kFALSEÂ . ). protected . Collect responses from the slave servers. ; Returns the number of slaves that responded. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2727 of file TProof.cxx. â—†Â Collect() [3/4]. Int_t TProof::Collect ; (; TList *Â ; slaves, . Long_tÂ ; timeout = -1, . Int_tÂ ; endtype = -1, . Bool_tÂ ; deactonfail = kFALSEÂ . ). protected . Collect responses from the slave servers. ; Returns the number of slaves that responded. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2696 of file TProof.cxx. â—†Â Collect() [4/4]. Int_t TProof::Collect ; (; TMonitor *Â ; mon, . Long_tÂ ; timeout = -1, . Int_tÂ ; endtype = -1, . Bool_tÂ ; deactonfail = kFALSEÂ . ). private . Collect responses from the slave servers. ; Returns the number of messages received. Can be 0 if there are no active slaves. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. Collect also stops its execution from time to time to check for new workers in Dynamic Startup mode. ; Definition at line 2756 of file TProof.cxx. â—†Â CollectInputFrom(). Int_t TProof::CollectInputFrom ; (; TSocket *Â ; s, . Int_tÂ ; endtype = -1, . Bool_tÂ ; deactonfail = kFALSEÂ . ). private . Collect and analyze available input from socket s. ; Returns 0 on success, -1 if any failure occurs. ; Definition at line 3060 of file TProof.cxx. â—†Â CreateDrawFeedback(). TDrawFeedback * TProof::CreateDrawFeedback ; (; ). Draw feedback creation proxy. ; When accessed via TProof avoids link dependency on libProofPlayer. ; Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:78386,timeout,timeout,78386,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['timeout'],['timeout']
Safety,"4_t GetChainEntryNumber(Long64_t entry) const { return entry; }; 456 virtual Long64_t GetChainOffset() const { return fChainOffset; }; 457 virtual bool GetClusterPrefetch() const { return fCacheDoClusterPrefetch; }; 458 TFile *GetCurrentFile() const;; 459 Int_t GetDefaultEntryOffsetLen() const {return fDefaultEntryOffsetLen;}; 460 Long64_t GetDebugMax() const { return fDebugMax; }; 461 Long64_t GetDebugMin() const { return fDebugMin; }; 462 TDirectory *GetDirectory() const { return fDirectory; }; 463 virtual Long64_t GetEntries() const { return fEntries; }; 464 virtual Long64_t GetEntries(const char *selection);; 465 /// Return a number greater or equal to the total number of entries in the; 466 /// dataset.; 467 ///; 468 /// \note If you are interested in the total number of entries in a TChain,; 469 /// this function will give that number once the last file of the chain; 470 /// is opened. In general, using this instead of GetEntries will avoid; 471 /// opening all files in the chain which could be very costly for very; 472 /// large number of files stored at a remote location.; 473 ///; 474 /// The logic depends on whether the dataset is a TTree or a TChain. In the; 475 /// first case, it simply returns the total number of entries in the tree. In; 476 /// the latter case, it depends on which point of the processing of the chain; 477 /// this function is called. During most of the chain processing, this; 478 /// function will return TTree::kMaxEntries. When the chain arrives at the; 479 /// last file, then the function will return the accumulated total number of; 480 /// entries in the whole chain. A notable use case where this function; 481 /// becomes quite useful is when writing the following for loop to traverse; 482 /// the entries in the dataset:; 483 ///; 484 /// \code{.cpp}; 485 /// for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; 486 /// // Do something with the event in the dataset; 487 /// }; 488 /// \endcode; 489 ///; 490 /// In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:25045,avoid,avoid,25045,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['avoid'],['avoid']
Safety,"5 )); , kEditDisableWidth = (1ULL << ( 6 )); , ; Â Â kEditDisableBtnEnable = (1ULL << ( 7 )); , kEditDisableKeyEnable = (1ULL << ( 8 )). }; Â ; enum Â EStatusBits { kIsHtmlView = (1ULL << ( 14 )); }; Â ; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; Â Â kBitMask = 0x00ffffff. }; Â ; enum Â { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; Â ; enum Â EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); }; Â ; enum Â EStatusBits { ; Â Â kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ; Â Â kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; Â ; Â Protected Types inherited from TGFrame; enum Â { kDeleteWindowCalled = (1ULL << ( 15 )); }; Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â ; Â Static Protected Member Functions inherited from TGDoubleSlider; static voidÂ FixBounds (Double_t &min, Double_t &max); Â Avoid boundaries to be equal. ; Â ; Â Static Protected Member Functions inherited from TGFrame; static Time_tÂ GetLastClick (); Â Get time of last mouse click. ; Â ; Â Static Protected Member Functions inherited from TQObject; static Int_tÂ CheckConnectArgs (TQObject *sender, TClass *sender_class, const char *signal, TClass *receiver_class, const char *slot); Â Checking of consistency of sender/receiver methods/arguments. ; Â ; static TStringÂ CompressName (const char *method_name); Â Removes ""const"" words and blanks from full (with prototype) method name and resolve any typedefs in the method signature. ; Â ; static Bool_tÂ ConnectToClass (const char *sender_class, const char *signal, TClass *receiver_class, void *receiver, const char *slot); Â This method allows to make connection from any object of the same class to the receiver object. ; Â ; static Bool_tÂ Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDoubleHSlider.html:30530,Avoid,Avoid,30530,doc/master/classTGDoubleHSlider.html,https://root.cern,https://root.cern/doc/master/classTGDoubleHSlider.html,4,['Avoid'],['Avoid']
Safety,"5 if (l > 0) {; 766 TString nm = buf(0, l);; 767 TString val = buf(l+1, buf.Length());; 768 SetValue(nm, val, level);; 769 } else; 770 SetValue(name, ""1"", level);; 771}; 772 ; 773////////////////////////////////////////////////////////////////////////////////; 774/// Set or create an integer resource value.; 775 ; 776void TEnv::SetValue(const char *name, Int_t value); 777{; 778 SetValue(name, TString::Format(""%d"", value).Data());; 779}; 780 ; 781////////////////////////////////////////////////////////////////////////////////; 782/// Set or create a double resource value.; 783 ; 784void TEnv::SetValue(const char *name, Double_t value); 785{; 786 SetValue(name, TString::Format(""%g"", value).Data());; 787}; 788 ; 789////////////////////////////////////////////////////////////////////////////////; 790/// If set to true, no warnings in case of duplicates are issued.; 791/// Returns previous value.; 792 ; 793Bool_t TEnv::IgnoreDuplicates(Bool_t ignore); 794{; 795 Bool_t ret = fIgnoreDup;; 796 fIgnoreDup = ignore;; 797 return ret;; 798}; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; s1#define s1(x)Definition RSha256.hxx:91; e#define e(i)Definition RSha256.hxx:103; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; gEnvTEnv * gEnvDefinition TEnv.cxx:83; gBoolNamesstatic struct BoolNameTable_t gBoolNames[]; TEnv.h; EEnvLevelEEnvLevelDefinition TEnv.h:69; kEnvUser@ kEnvUserDefinition TEnv.h:71; kEnvChange@ kEnvChangeDefinition TEnv.h:73; kEnvAll@ kEnvAllDefinition TEnv.h:74; kEnvGlobal@ kEnvGlobalDefinition TEnv.h:70; kEnvLocal@ kEnvLocalDefinition TEnv.h:72; TError.h; vvwinID h TVirtualViewer3D vvDefinition TGWin32VirtualGLProxy.cxx:49; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEnv_8cxx_source.html:22736,Safe,SafeDelete,22736,doc/master/TEnv_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html,2,['Safe'],['SafeDelete']
Safety,"5 of file RuleFitParams.cxx. â—†Â MakeTstGradientVector(). void TMVA::RuleFitParams::MakeTstGradientVector ; (; ). protected . make test gradient vector for all tau same algorithm as MakeGradientVector() ; Definition at line 1259 of file RuleFitParams.cxx. â—†Â Optimism(). Double_t TMVA::RuleFitParams::Optimism ; (; ). protected . implementation of eq. ; 7.17 in Hastie,Tibshirani & Friedman book this is the covariance between the estimated response yhat and the true value y. NOT REALLY SURE IF THIS IS CORRECT! â€” THIS IS NOT USED â€” ; Definition at line 925 of file RuleFitParams.cxx. â—†Â Penalty(). Double_t TMVA::RuleFitParams::Penalty ; (; ); const. This is the ""lasso"" penalty To be used for regression. ; â€” NOT USED â€” ; Definition at line 356 of file RuleFitParams.cxx. â—†Â Risk() [1/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_tÂ ; ind1, . UInt_tÂ ; ind2, . Double_tÂ ; neffÂ . ); const. risk assessment ; Definition at line 314 of file RuleFitParams.cxx. â—†Â Risk() [2/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_tÂ ; ind1, . UInt_tÂ ; ind2, . Double_tÂ ; neff, . UInt_tÂ ; itauÂ . ); const. risk assessment for tau model <itau> ; Definition at line 334 of file RuleFitParams.cxx. â—†Â RiskPath(). Double_t TMVA::RuleFitParams::RiskPath ; (; ); const. inline . Definition at line 108 of file RuleFitParams.h. â—†Â RiskPerf() [1/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; ); const. inline . Definition at line 109 of file RuleFitParams.h. â—†Â RiskPerf() [2/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; UInt_tÂ ; itau); const. inline . Definition at line 110 of file RuleFitParams.h. â—†Â RiskPerfTst(). UInt_t TMVA::RuleFitParams::RiskPerfTst ; (; ). Estimates the error rate with the current set of parameters. ; using the <Perf> subsample. Return the tau index giving the lowest error ; Definition at line 1201 of file RuleFitParams.cxx. â—†Â SetGDErrScale(). void TMVA::RuleFitParams::SetGDErrScale ; (; Double_tÂ ; s). inline . Definition at line 85 of file RuleFitParams.h. â—†Â SetGDNPathSteps(). void TMVA:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:16681,Risk,Risk,16681,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['Risk'],['Risk']
Safety,"5 of file TGeoSphere.h. â—†Â InspectShape(). void TGeoSphere::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â IsA(). TClass * TGeoSphere::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 96 of file TGeoSphere.h. â—†Â IsCylType(). Bool_t TGeoSphere::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 79 of file TGeoSphere.h. â—†Â IsOnBoundary(). Int_t TGeoSphere::IsOnBoundary ; (; const Double_t *Â ; point); const. â—†Â IsPointInside(). Bool_t TGeoSphere::IsPointInside ; (; const Double_t *Â ; point, . Bool_tÂ ; checkR = kTRUE, . Bool_tÂ ; checkTh = kTRUE, . Bool_tÂ ; checkPh = kTRUEÂ . ); const. â—†Â MakeBuffer3D(). TBuffer3D * TGeoSphere::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â operator=(). TGeoSphere & TGeoSphere::operator= ; (; const TGeoSphere &Â ; ). protecteddelete . â—†Â Safety(). Double_t TGeoSphere::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Safety_v(). void TGeoSphere::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â SavePrimitive(). void TGeoSphere::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. â—†Â SetDimensions() [1/2]. void TGeoSphere::SetDimensions ; (; Double_t *Â ; param). overridevirtual . Reimplemented from TGeoBBox. â—†Â SetDimensions() [2/2]. void TGeoSphere::SetDimensions ; (; Double_t *Â ; param, . Int_tÂ ; nparamÂ . ). â—†Â SetNumberOfDivisions(). virtual void TGeoSphere::SetNumberOfDivisions ; (; Int_tÂ ; p). virtual . â—†Â SetPoints() [1/2]. void TGeoSphere::SetPoints ; (; Double_t *Â ; points); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â SetPoints(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSphere.html:30327,Safe,Safety,30327,doc/master/classTGeoSphere.html,https://root.cern,https://root.cern/doc/master/classTGeoSphere.html,1,['Safe'],['Safety']
Safety,"50 out.close();; 151}; 152 ; 153// clang-format off; 154/// Cast a RDataFrame node to the common type ROOT::RDF::RNode; 155/// \param[in] node Any node of a RDataFrame graph; 156// clang-format on; 157template <typename NodeType>; 158RNode AsRNode(NodeType node); 159{; 160 return node;; 161}; 162 ; 163// clang-format off; 164/// Trigger the event loop of multiple RDataFrames concurrently; 165/// \param[in] handles A vector of RResultHandles; 166/// \return The number of distinct computation graphs that have been processed; 167///; 168/// This function triggers the event loop of all computation graphs which relate to the; 169/// given RResultHandles. The advantage compared to running the event loop implicitly by accessing the; 170/// RResultPtr is that the event loops will run concurrently. Therefore, the overall; 171/// computation of all results is generally more efficient.; 172/// It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; 173///; 174/// ~~~{.cpp}; 175/// ROOT::RDataFrame df1(""tree1"", ""file1.root"");; 176/// auto r1 = df1.Histo1D(""var1"");; 177///; 178/// ROOT::RDataFrame df2(""tree2"", ""file2.root"");; 179/// auto r2 = df2.Sum(""var2"");; 180///; 181/// // RResultPtr -> RResultHandle conversion is automatic; 182/// ROOT::RDF::RunGraphs({r1, r2});; 183/// ~~~; 184// clang-format on; 185unsigned int RunGraphs(std::vector<RResultHandle> handles);; 186 ; 187namespace Experimental {; 188 ; 189/// \brief Produce all required systematic variations for the given result.; 190/// \param[in] resPtr The result for which variations should be produced.; 191/// \return A \ref ROOT::RDF::Experimental::RResultMap ""RResultMap"" object with full variation names as strings; 192/// (e.g. ""pt:down"") and the corresponding varied results as values.; 193///; 194/// A given input RResultPtr<T> produces a corresponding RResultMap<T> with a ""nominal""; 195/// key that will return a value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:7792,safe,safe,7792,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['safe'],['safe']
Safety,"51 assert(fXInput.GetShape().size() >= 4);; 1752 size_t nc = fXInput.GetCSize();; 1753 size_t nh = fXInput.GetHSize();; 1754 size_t nw = fXInput.GetWSize();; 1755 size_t n = nc * nh * nw;; 1756 if (nVariables != n) {; 1757 Log() << kFATAL << ""Input Event variable dimensions are not compatible with the built network architecture""; 1758 << "" n-event variables "" << nVariables << "" expected input tensor "" << nc << "" x "" << nh << "" x "" << nw; 1759 << Endl;; 1760 }; 1761 for (size_t j = 0; j < n; j++) {; 1762 // in this case TMVA event has same order as input tensor; 1763 fXInputBuffer[j] = inputValues[j]; // for column layout !!!; 1764 }; 1765 }; 1766 // copy buffer in input; 1767 fXInput.GetDeviceBuffer().CopyFrom(fXInputBuffer);; 1768 return;; 1769}; 1770 ; 1771////////////////////////////////////////////////////////////////////////////////; 1772Double_t MethodDL::GetMvaValue(Double_t * /*errLower*/, Double_t * /*errUpper*/); 1773{; 1774 ; 1775 FillInputTensor();; 1776 ; 1777 // perform the prediction; 1778 fNet->Prediction(*fYHat, fXInput, fOutputFunction);; 1779 ; 1780 // return value; 1781 double mvaValue = (*fYHat)(0, 0);; 1782 ; 1783 // for debugging; 1784#ifdef DEBUG_MVAVALUE; 1785 using Tensor_t = std::vector<MatrixImpl_t>;; 1786 TMatrixF xInput(n1,n2, inputValues.data() );; 1787 std::cout << ""Input data - class "" << GetEvent()->GetClass() << std::endl;; 1788 xInput.Print();; 1789 std::cout << ""Output of DeepNet "" << mvaValue << std::endl;; 1790 auto & deepnet = *fNet;; 1791 std::cout << ""Loop on layers "" << std::endl;; 1792 for (int l = 0; l < deepnet.GetDepth(); ++l) {; 1793 std::cout << ""Layer "" << l;; 1794 const auto * layer = deepnet.GetLayerAt(l);; 1795 const Tensor_t & layer_output = layer->GetOutput();; 1796 layer->Print();; 1797 std::cout << ""DNN output "" << layer_output.size() << std::endl;; 1798 for (size_t i = 0; i < layer_output.size(); ++i) {; 1799#ifdef R__HAS_TMVAGPU; 1800 //TMatrixD m(layer_output[i].GetNrows(), layer_output[i].GetNcols() , laye",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:70523,predict,prediction,70523,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,2,"['Predict', 'predict']","['Prediction', 'prediction']"
Safety,"51/// dummy constructor; 452 ; 453TGeoVolume::TGeoVolume(); 454{; 455 fNodes = nullptr;; 456 fShape = nullptr;; 457 fMedium = nullptr;; 458 fFinder = nullptr;; 459 fVoxels = nullptr;; 460 fGeoManager = gGeoManager;; 461 fField = nullptr;; 462 fOption = """";; 463 fNumber = 0;; 464 fNtotal = 0;; 465 fRefCount = 0;; 466 fUserExtension = nullptr;; 467 fFWExtension = nullptr;; 468 fTransparency = -1;; 469 TObject::ResetBit(kVolumeImportNodes);; 470}; 471 ; 472////////////////////////////////////////////////////////////////////////////////; 473/// default constructor; 474 ; 475TGeoVolume::TGeoVolume(const char *name, const TGeoShape *shape, const TGeoMedium *med) : TNamed(name, """"); 476{; 477 fName = fName.Strip();; 478 fNodes = nullptr;; 479 fShape = (TGeoShape *)shape;; 480 if (fShape) {; 481 if (fShape->TestShapeBit(TGeoShape::kGeoBad)) {; 482 Warning(""Ctor"", ""volume %s has invalid shape"", name);; 483 }; 484 if (!fShape->IsValid()) {; 485 Fatal(""ctor"", ""Shape of volume %s invalid. Aborting!"", fName.Data());; 486 }; 487 }; 488 fMedium = (TGeoMedium *)med;; 489 if (fMedium && fMedium->GetMaterial()); 490 fMedium->GetMaterial()->SetUsed();; 491 fFinder = nullptr;; 492 fVoxels = nullptr;; 493 fGeoManager = gGeoManager;; 494 fField = nullptr;; 495 fOption = """";; 496 fNumber = 0;; 497 fNtotal = 0;; 498 fRefCount = 0;; 499 fUserExtension = nullptr;; 500 fFWExtension = nullptr;; 501 fTransparency = -1;; 502 if (fGeoManager); 503 fNumber = fGeoManager->AddVolume(this);; 504 TObject::ResetBit(kVolumeImportNodes);; 505}; 506 ; 507////////////////////////////////////////////////////////////////////////////////; 508/// Destructor; 509 ; 510TGeoVolume::~TGeoVolume(); 511{; 512 if (fNodes) {; 513 if (!TObject::TestBit(kVolumeImportNodes)) {; 514 fNodes->Delete();; 515 }; 516 delete fNodes;; 517 }; 518 if (fFinder && !TObject::TestBit(kVolumeImportNodes | kVolumeClone)); 519 delete fFinder;; 520 if (fVoxels); 521 delete fVoxels;; 522 if (fUserExtension) {; 523 fUserExtension->Release();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:22504,Abort,Aborting,22504,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['Abort'],['Aborting']
Safety,"52 hxmax = xmax + fMargin * (xmax - xmin);; 1053 hymax = ymax + fMargin * (ymax - ymin);; 1054 Double_t epsilon = 1e-9;; 1055 if (TMath::AreEqualRel(hxmax,hxmin,epsilon)) {; 1056 if (TMath::Abs(hxmin) < epsilon) {; 1057 hxmin = -0.001;; 1058 hxmax = 0.001;; 1059 } else {; 1060 hxmin = hxmin-TMath::Abs(hxmin)*(epsilon/2.);; 1061 hxmax = hxmax+TMath::Abs(hxmax)*(epsilon/2.);; 1062 }; 1063 }; 1064 if (TMath::AreEqualRel(hymax, hymin, epsilon)) {; 1065 if (TMath::Abs(hymin) < epsilon) {; 1066 hymin = -0.001;; 1067 hymax = 0.001;; 1068 } else {; 1069 hymin = hymin-TMath::Abs(hymin)*(epsilon/2.);; 1070 hymax = hymax+TMath::Abs(hymax)*(epsilon/2.);; 1071 }; 1072 }; 1073 if (fHistogram) {; 1074 fHistogram->GetXaxis()->SetLimits(hxmin, hxmax);; 1075 fHistogram->GetYaxis()->SetLimits(hymin, hymax);; 1076 } else {; 1077 TDirectory::TContext ctx(nullptr); // to avoid adding fHistogram to gDirectory; 1078 fHistogram = new TH2D(GetName(), GetTitle(),; 1079 fNpx , hxmin, hxmax,; 1080 fNpy, hymin, hymax);; 1081 CreateInterpolator(oldInterp);; 1082 }; 1083 fHistogram->SetBit(TH1::kNoStats);; 1084 } else {; 1085 hxmin = fHistogram->GetXaxis()->GetXmin();; 1086 hymin = fHistogram->GetYaxis()->GetXmin();; 1087 hxmax = fHistogram->GetXaxis()->GetXmax();; 1088 hymax = fHistogram->GetYaxis()->GetXmax();; 1089 }; 1090 ; 1091 // Option ""empty"" is selected. An empty histogram is returned.; 1092 Double_t hzmax, hzmin;; 1093 if (empty) {; 1094 if (fMinimum != -1111) {; 1095 hzmin = fMinimum;; 1096 } else {; 1097 hzmin = GetZminE();; 1098 }; 1099 if (fMaximum != -1111) {; 1100 hzmax = fMaximum;; 1101 } else {; 1102 hzmax = GetZmaxE();; 1103 }; 1104 if (hzmin == hzmax) {; 1105 Double_t hz = hzmin;; 1106 if (hz==0) {; 1107 hzmin = -0.01;; 1108 hzmax = 0.01;; 1109 } else {; 1110 hzmin = hz - 0.01 * TMath::Abs(hz);; 1111 hzmax = hz + 0.01 * TMath::Abs(hz);; 1112 }; 1113 }; 1114 fHistogram->SetMinimum(hzmin);; 1115 fHistogram->SetMaximum(hzmax);; 1116 return fHistogram;; 1117 }; 1118 ; 1119 Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2D_8cxx_source.html:35199,avoid,avoid,35199,doc/master/TGraph2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html,1,['avoid'],['avoid']
Safety,"57 of file Rtypes.h. â—†Â ClassDefInlineOverride. #define ClassDefInlineOverride; (; Â ; name, . Â ; idÂ . ). Value: _ClassDefInline_(name,id,,override) \; /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */. Definition at line 353 of file Rtypes.h. â—†Â ClassDefNV. #define ClassDefNV; (; Â ; name, . Â ; idÂ . ). Value: _ClassDefOutline_(name,id,,) \; /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */. Definition at line 345 of file Rtypes.h. â—†Â ClassDefOverride. #define ClassDefOverride; (; Â ; name, . Â ; idÂ . ). Value: _ClassDefOutline_(name,id,,override) \; /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */. Definition at line 341 of file Rtypes.h. â—†Â ClassDefT. #define ClassDefT; (; Â ; name, . Â ; idÂ . ). Value: _ClassDefOutline_(name,id,virtual,) \; /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */. This ClassDefT is strictly redundant and is kept only for backward compatibility. ; Deprecated:; Definition at line 404 of file Rtypes.h. â—†Â ClassDefT2. #define ClassDefT2; (; Â ; name, . Â ; TmplÂ . ). Definition at line 413 of file Rtypes.h. â—†Â ClassDefTNV. #define ClassDefTNV; (; Â ; name, . Â ; idÂ . ). Value: _ClassDefOutline_(name,id,virtual,) \; /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */. Definition at line 408 of file Rtypes.h. â—†Â ClassImp. #define ClassImp; (; Â ; name); Â Â Â ClassImpUnique(name,default). Deprecated:; Definition at line 377 of file Rtypes.h. â—†Â ClassImp2T. #define ClassImp2T; (; Â ; name, . Â ; Tmpl1, . Â ; Tmpl2Â . ); Â Â Â templateClassImp(name). Definition at line 432 of file Rtypes.h. â—†Â ClassImp3T. #define ClassImp3T; (; Â ; name, . Â ; Tmpl1, . Â ; Tmpl2, . Â ; Tmpl3Â . ); Â Â Â templateClassImp(name). Definition at line 441 of file Rtypes.h. â—†Â ClassImpT. #define ClassImpT; (; Â ; name, . Â ; TmplÂ . ); Â Â Â templateClassImp(name). Definition at line 424 of file Rtypes.h. â—†Â Class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/Rtypes_8h.html:14268,redund,redundant,14268,doc/v632/Rtypes_8h.html,https://root.cern,https://root.cern/doc/v632/Rtypes_8h.html,1,['redund'],['redundant']
Safety,"586] - CMS missing symbol / function body of template; [ROOT-7598] - Size shown in dmg installer is wrong; [ROOT-7602] - CMake: Touching core/meta/inc/Linkdef.h, core/base/G__Base.cxx does not get regenerated; [ROOT-7605] - cmake -Dminimal=ON not working; [ROOT-7606] - cmake -Dfail-on-missing=ON -Dmathmore=ON not consistent; [ROOT-7663] - failure to compile master branch on ubuntu 15.04; [ROOT-7683] - Memory leak in ROOT::TSchemaRuleSet reported in ATLAS job; [ROOT-7706] - thisroot.sh not working properly for zsh. Improvements. [ROOT-7480] - improvement of the occincdir search in configure. Tasks. [ROOT-7583] - Let thisroot add ROOT to CMAKE_PREFIX_PATH. Release 6.04/06; Build. Building ROOT with cmake command not in my PATH now fixed ROOT-7715; Fix builtin_xrootd option that was not working for XROOTD version 4.2.2.; Option gnuinstall also sets RPATH in librries and executables in installation directory; Various fixes for MacOS X 10.11 ROOT-7680. Core. Fix thread safety of the creation of TMethodCall from a TFunction.; Fix dictionary generation of STL collection involving one of ROOTâ€™s core classes when the user header contains only a forward declaration of the class [ROOT-7695]. Bugs. [ROOT-7680] - Canâ€™t build v6-02-12 on MacOS X 10.11; [ROOT-7695] - Segmentation violation in rootcint; [ROOT-7709] - PyROOT not functional with system-default Python version on MacOS X 10.11; [ROOT-7715] - Building ROOT with CMake not in my PATH fails. Release 6.04/08; Build. Add â€“disable-search-usrlocal to configure/make to be able to avoid conflict with incompatible installation (e.g.Â homebrew).; Add /opt/X11 to configure/make search for include files and libraries.; Updates PCRE to 8.37 (current upstream version) which can detect PPC64LE machine.; Fail cmake configuration if the specified CMAKE_BUILD_TYPE is unknown; Fix RPATH for MacOSX (El Capitan) to avoid building with -Drpath=ON. The default uses rpath=@loader_path/../lib. Core. Add missing protection when creating new Streame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:32077,safe,safety,32077,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['safe'],['safety']
Safety,"5E-2,; 289 4.76367800457137231464E-2,; 290 2.07448227648435975150E-1,; 291 4.94214826801497100753E-1,; 292 9.99999999999999996796E-1; 293};; 294static double Q[] = {; 295 -2.31581873324120129819E-5,; 296 5.39605580493303397842E-4,; 297 -4.45641913851797240494E-3,; 298 1.18139785222060435552E-2,; 299 3.58236398605498653373E-2,; 300 -2.34591795718243348568E-1,; 301 7.14304917030273074085E-2,; 302 1.00000000000000000320E0; 303};; 304 ; 305/* Stirling's formula for the gamma function */; 306static double STIR[5] = {; 307 7.87311395793093628397E-4,; 308 -2.29549961613378126380E-4,; 309 -2.68132617805781232825E-3,; 310 3.47222221605458667310E-3,; 311 8.33333333333482257126E-2,; 312};; 313 ; 314#define SQTPI std::sqrt(2*ROOT::Math::Pi()) /* sqrt(2*pi) */; 315/* Stirling formula for the gamma function */; 316static double stirf( double x); 317{; 318 double y, w, v;; 319 ; 320 w = 1.0/x;; 321 w = 1.0 + w * Polynomialeval( w, STIR, 4 );; 322 y = exp(x);; 323 ; 324/* #define kMAXSTIR kMAXLOG/log(kMAXLOG) */; 325 ; 326 if( x > kMAXSTIR ); 327 { /* Avoid overflow in pow() */; 328 v = pow( x, 0.5 * x - 0.25 );; 329 y = v * (v / y);; 330 }; 331 else; 332 {; 333 y = pow( x, x - 0.5 ) / y;; 334 }; 335 y = SQTPI * y * w;; 336 return( y );; 337}; 338 ; 339double gamma( double x ); 340{; 341 double p, q, z;; 342 int i;; 343 ; 344 int sgngam = 1;; 345 ; 346 if (x >=std::numeric_limits<double>::infinity()); 347 return(x);; 348 ; 349 q = std::abs(x);; 350 ; 351 if( q > 33.0 ); 352 {; 353 if( x < 0.0 ); 354 {; 355 p = std::floor(q);; 356 if( p == q ); 357 {; 358 return( sgngam * std::numeric_limits<double>::infinity());; 359 }; 360 i = (int) p;; 361 if( (i & 1) == 0 ); 362 sgngam = -1;; 363 z = q - p;; 364 if( z > 0.5 ); 365 {; 366 p += 1.0;; 367 z = q - p;; 368 }; 369 z = q * std::sin( ROOT::Math::Pi() * z );; 370 if( z == 0 ); 371 {; 372 return( sgngam * std::numeric_limits<double>::infinity());; 373 }; 374 z = std::abs(z);; 375 z = ROOT::Math::Pi()/(z * stirf(q) );; 376 }; 377 else; 378 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:7323,Avoid,Avoid,7323,doc/master/SpecFuncCephes_8cxx_source.html,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html,1,['Avoid'],['Avoid']
Safety,"6 925.361 0; : 10 Minimum Test error found - save the configuration ; : 10 | 0.561268 0.630455 1.40233 0.116045 932.919 0; : ; : Elapsed time for training with 1600 events: 14.2 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; TMVA_CNN_CPU : [dataset] : Evaluation of TMVA_CNN_CPU on training sample (1600 events); : Elapsed time for evaluation of 1600 events: 0.629 sec ; : Creating xml weight file: â›[0;36mdataset/weights/TMVA_CNN_Classification_TMVA_CNN_CPU.weights.xmlâ›[0m; : Creating standalone class: â›[0;36mdataset/weights/TMVA_CNN_Classification_TMVA_CNN_CPU.class.Câ›[0m; Factory : Training finished; : ; Factory : Train method: PyKeras for Classification; : ; : ; : â›[1m================================================================â›[0m; : â›[1mH e l p f o r M V A m e t h o d [ PyKeras ] :â›[0m; : ; : Keras is a high-level API for the Theano and Tensorflow packages.; : This method wraps the training and predictions steps of the Keras; : Python package for TMVA, so that dataloading, preprocessing and; : evaluation can be done within the TMVA system. To use this Keras; : interface, you have to generate a model with Keras first. Then,; : this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : â›[1m================================================================â›[0m; : ; : Split TMVA training data in 1280 training events and 320 validation events; : Training Model Summary; custom objects for loading model : {'optimizer': <class 'torch.optim.adam.Adam'>, 'criterion': BCELoss(), 'train_func': <function fit at 0x7fe43c5d1b80>, 'predict_func': <function predict at 0x7fe43c5d1ca0>}; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 16, 16, 1) 0 ; ; conv2d (Conv2D) (None, 16, 16, 10) 100 ; ; batch_normalization (Batch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:16174,predict,predictions,16174,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['predict'],['predictions']
Safety,"6 of file TSystem.h. Public Types; enum Â EAclicMode { kDefault; , kDebug; , kOpt; }; Â ; enum Â EAclicProperties { kFlatBuildDir = (1ULL << ( 0 )); }; Â ; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; Â Â kBitMask = 0x00ffffff. }; Â ; enum Â { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; Â ; enum Â EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); }; Â ; enum Â EStatusBits { ; Â Â kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ; Â Â kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; Â . Public Member Functions; Â TSystem (const char *name=""Generic"", const char *title=""Generic System""); Â Create a new OS interface. ; Â ; virtualÂ ~TSystem (); Â Delete the OS interface. ; Â ; virtual voidÂ Abort (int code=0); Â Abort the application. ; Â ; virtual intÂ AcceptConnection (int sock); Â Accept a connection. ; Â ; virtual Bool_tÂ AccessPathName (const char *path, EAccessMode mode=kFileExists); Â Returns FALSE if one can access a file using the specified access mode. ; Â ; virtual voidÂ AddDynamicPath (const char *pathname); Â Add a new directory to the dynamic path. ; Â ; virtual voidÂ AddFileHandler (TFileHandler *fh); Â Add a file handler to the list of system file handlers. ; Â ; virtual voidÂ AddIncludePath (const char *includePath); Â Add a directory to the already set include path. ; Â ; virtual voidÂ AddLinkedLibs (const char *linkedLib); Â Add linkedLib to already set linked libs. ; Â ; virtual voidÂ AddSignalHandler (TSignalHandler *sh); Â Add a signal handler to list of system signal handlers. ; Â ; virtual voidÂ AddStdExceptionHandler (TStdExceptionHandler *eh); Â Add an exception handler to list of system exception handlers. ; Â ; virtual voidÂ AddTimer (TTimer *t); Â Add timer to list of system timers.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:1824,Abort,Abort,1824,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,2,['Abort'],['Abort']
Safety,"6 of file TUnixSystem.cxx. â—†Â ResetTimer(). void TUnixSystem::ResetTimer ; (; TTimer *Â ; ti). overridevirtual . Reset a-sync timer. ; Reimplemented from TSystem.; Definition at line 3033 of file TUnixSystem.cxx. â—†Â Select() [1/2]. Int_t TUnixSystem::Select ; (; TFileHandler *Â ; h, . Long_tÂ ; toÂ . ). overridevirtual . Select on the file descriptor related to file handler h. ; The timeout to is in millisec. Returns the number of ready descriptors, or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR the errno has been reset and the method can be called again. Returns -4 in case the file handler is 0 or does not have a file descriptor >= 0. ; Reimplemented from TSystem.; Definition at line 1250 of file TUnixSystem.cxx. â—†Â Select() [2/2]. Int_t TUnixSystem::Select ; (; TList *Â ; act, . Long_tÂ ; toÂ . ). overridevirtual . Select on file descriptors. ; The timeout to is in millisec. Returns the number of ready descriptors, or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR the errno has been reset and the method can be called again. Returns -4 in case the list did not contain any file handlers or file handlers with file descriptor >= 0. ; Reimplemented from TSystem.; Definition at line 1202 of file TUnixSystem.cxx. â—†Â SendBuf(). int TUnixSystem::SendBuf ; (; intÂ ; sock, . const void *Â ; buf, . intÂ ; lengthÂ . ). overridevirtual . Send a buffer headed by a length indicator. ; Returns length of sent buffer or -1 in case of error. ; Reimplemented from TSystem.; Definition at line 3341 of file TUnixSystem.cxx. â—†Â SendRaw(). int TUnixSystem::SendRaw ; (; intÂ ; sock, . const void *Â ; buf, . intÂ ; length, . intÂ ; optÂ . ). overridevirtual . Send exactly length bytes from buffer. ; Use opt to send out-of-band data (see TSocket). Returns the number of bytes sent or -1 in case of error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:65739,timeout,timeout,65739,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['timeout'],['timeout']
Safety,"6074/// The value of `fStreamerType` are; 6075/// ~~~ {.cpp}; 6076/// kTObject : the class inherits from TObject; 6077/// kForeign : the class does not have a Streamer method; 6078/// kInstrumented: the class does have a Streamer method; 6079/// kExternal: the class has a free standing way of streaming itself; 6080/// kEmulatedStreamer: the class is missing its shared library.; 6081/// ~~~; 6082///; 6083/// Implementation note: the data member fProperty has the value -1; 6084/// until it is initialized.; 6085 ; 6086Long_t TClass::Property() const; 6087{; 6088 // Check if we can return without taking the lock,; 6089 // this is valid since fProperty is atomic and set as; 6090 // the last operation before return.; 6091 if (fProperty!=(-1)) return fProperty;; 6092 ; 6093 R__LOCKGUARD(gInterpreterMutex);; 6094 ; 6095 // Check if another thread set fProperty while we; 6096 // were waiting.; 6097 if (fProperty!=(-1)) return fProperty;; 6098 ; 6099 // Avoid asking about the class when it is still building; 6100 if (TestBit(kLoading)) return fProperty;; 6101 ; 6102 // When called via TMapFile (e.g. Update()) make sure that the dictionary; 6103 // gets allocated on the heap and not in the mapped file.; 6104 TMmallocDescTemp setreset;; 6105 ; 6106 TClass *kl = const_cast<TClass*>(this);; 6107 ; 6108 kl->fStreamerType = TClass::kDefault;; 6109 kl->fStreamerImpl = &TClass::StreamerDefault;; 6110 ; 6111 if (InheritsFrom(TObject::Class())) {; 6112 kl->SetBit(kIsTObject);; 6113 ; 6114 // Is it DIRECT inheritance from TObject?; 6115 Int_t delta = kl->GetBaseClassOffsetRecurse(TObject::Class());; 6116 if (delta==0) kl->SetBit(kStartWithTObject);; 6117 ; 6118 kl->fStreamerType = kTObject;; 6119 kl->fStreamerImpl = &TClass::StreamerTObject;; 6120 }; 6121 ; 6122 if (HasInterpreterInfo()) {; 6123 ; 6124 // This code used to use ClassInfo_Has|IsValidMethod but since v6; 6125 // they return true if the routine is defined in the class or any of; 6126 // its parent. We explicitly want to kno",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:234535,Avoid,Avoid,234535,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['Avoid'],['Avoid']
Safety,"61 if (fReadmask->IsSet(fd)) {; 1162 rc = UnixSelect(fd+1, &t, nullptr, 0);; 1163 if (rc < 0 && rc != -2) {; 1164 SysError(""DispatchOneEvent"", ""select: read error on %d"", fd);; 1165 fReadmask->Clr(fd);; 1166 }; 1167 }; 1168 if (fWritemask->IsSet(fd)) {; 1169 rc = UnixSelect(fd+1, nullptr, &t, 0);; 1170 if (rc < 0 && rc != -2) {; 1171 SysError(""DispatchOneEvent"", ""select: write error on %d"", fd);; 1172 fWritemask->Clr(fd);; 1173 }; 1174 }; 1175 t.Clr(fd);; 1176 }; 1177 }; 1178 }; 1179}; 1180 ; 1181////////////////////////////////////////////////////////////////////////////////; 1182/// Sleep milliSec milliseconds.; 1183 ; 1184void TUnixSystem::Sleep(UInt_t milliSec); 1185{; 1186 struct timeval tv;; 1187 ; 1188 tv.tv_sec = milliSec / 1000;; 1189 tv.tv_usec = (milliSec % 1000) * 1000;; 1190 ; 1191 select(0, nullptr, nullptr, nullptr, &tv);; 1192}; 1193 ; 1194////////////////////////////////////////////////////////////////////////////////; 1195/// Select on file descriptors. The timeout to is in millisec. Returns; 1196/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 1197/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 1198/// the errno has been reset and the method can be called again. Returns; 1199/// -4 in case the list did not contain any file handlers or file handlers; 1200/// with file descriptor >= 0.; 1201 ; 1202Int_t TUnixSystem::Select(TList *act, Long_t to); 1203{; 1204 Int_t rc = -4;; 1205 ; 1206 TFdSet rd, wr;; 1207 Int_t mxfd = -1;; 1208 TIter next(act);; 1209 TFileHandler *h = nullptr;; 1210 while ((h = (TFileHandler *) next())) {; 1211 Int_t fd = h->GetFd();; 1212 if (fd > -1) {; 1213 if (h->HasReadInterest()) {; 1214 rd.Set(fd);; 1215 mxfd = TMath::Max(mxfd, fd);; 1216 }; 1217 if (h->HasWriteInterest()) {; 1218 wr.Set(fd);; 1219 mxfd = TMath::Max(mxfd, fd);; 1220 }; 1221 h->ResetReadyMask();; 1222 }; 1223 }; 1224 if (mxfd > -1); 1225 rc = UnixSelect(mxfd+1, &rd, &wr, to);; 1226 ; 1227 // Set readiness bits;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:36592,timeout,timeout,36592,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['timeout'],['timeout']
Safety,"6141/// The value of `fStreamerType` are; 6142/// ~~~ {.cpp}; 6143/// kTObject : the class inherits from TObject; 6144/// kForeign : the class does not have a Streamer method; 6145/// kInstrumented: the class does have a Streamer method; 6146/// kExternal: the class has a free standing way of streaming itself; 6147/// kEmulatedStreamer: the class is missing its shared library.; 6148/// ~~~; 6149///; 6150/// Implementation note: the data member fProperty has the value -1; 6151/// until it is initialized.; 6152 ; 6153Long_t TClass::Property() const; 6154{; 6155 // Check if we can return without taking the lock,; 6156 // this is valid since fProperty is atomic and set as; 6157 // the last operation before return.; 6158 if (fProperty!=(-1)) return fProperty;; 6159 ; 6160 R__LOCKGUARD(gInterpreterMutex);; 6161 ; 6162 // Check if another thread set fProperty while we; 6163 // were waiting.; 6164 if (fProperty!=(-1)) return fProperty;; 6165 ; 6166 // Avoid asking about the class when it is still building; 6167 if (TestBit(kLoading)) return fProperty;; 6168 ; 6169 // When called via TMapFile (e.g. Update()) make sure that the dictionary; 6170 // gets allocated on the heap and not in the mapped file.; 6171 TMmallocDescTemp setreset;; 6172 ; 6173 TClass *kl = const_cast<TClass*>(this);; 6174 ; 6175 kl->fStreamerType = TClass::kDefault;; 6176 kl->fStreamerImpl = &TClass::StreamerDefault;; 6177 ; 6178 if (InheritsFrom(TObject::Class())) {; 6179 kl->SetBit(kIsTObject);; 6180 ; 6181 // Is it DIRECT inheritance from TObject?; 6182 Int_t delta = kl->GetBaseClassOffsetRecurse(TObject::Class());; 6183 if (delta==0) kl->SetBit(kStartWithTObject);; 6184 ; 6185 kl->fStreamerType = kTObject;; 6186 kl->fStreamerImpl = &TClass::StreamerTObject;; 6187 }; 6188 ; 6189 if (HasInterpreterInfo()) {; 6190 ; 6191 // This code used to use ClassInfo_Has|IsValidMethod but since v6; 6192 // they return true if the routine is defined in the class or any of; 6193 // its parent. We explicitly want to kno",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:237286,Avoid,Avoid,237286,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['Avoid'],['Avoid']
Safety,"62 of file Rtypes.h. â—†Â ClassDefInlineOverride. #define ClassDefInlineOverride; (; Â ; name, . Â ; idÂ . ). Value: _ClassDefInline_(name,id,,override) \; /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */. Definition at line 358 of file Rtypes.h. â—†Â ClassDefNV. #define ClassDefNV; (; Â ; name, . Â ; idÂ . ). Value: _ClassDefOutline_(name,id,,) \; /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */. Definition at line 350 of file Rtypes.h. â—†Â ClassDefOverride. #define ClassDefOverride; (; Â ; name, . Â ; idÂ . ). Value: _ClassDefOutline_(name,id,,override) \; /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */. Definition at line 346 of file Rtypes.h. â—†Â ClassDefT. #define ClassDefT; (; Â ; name, . Â ; idÂ . ). Value: _ClassDefOutline_(name,id,virtual,) \; /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */. This ClassDefT is strictly redundant and is kept only for backward compatibility. ; Deprecated:; Definition at line 409 of file Rtypes.h. â—†Â ClassDefT2. #define ClassDefT2; (; Â ; name, . Â ; TmplÂ . ). Definition at line 418 of file Rtypes.h. â—†Â ClassDefTNV. #define ClassDefTNV; (; Â ; name, . Â ; idÂ . ). Value: _ClassDefOutline_(name,id,virtual,) \; /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */. Definition at line 413 of file Rtypes.h. â—†Â ClassImp. #define ClassImp; (; Â ; name); Â Â Â ClassImpUnique(name,default). Deprecated:; Definition at line 382 of file Rtypes.h. â—†Â ClassImp2T. #define ClassImp2T; (; Â ; name, . Â ; Tmpl1, . Â ; Tmpl2Â . ); Â Â Â templateClassImp(name). Definition at line 437 of file Rtypes.h. â—†Â ClassImp3T. #define ClassImp3T; (; Â ; name, . Â ; Tmpl1, . Â ; Tmpl2, . Â ; Tmpl3Â . ); Â Â Â templateClassImp(name). Definition at line 446 of file Rtypes.h. â—†Â ClassImpT. #define ClassImpT; (; Â ; name, . Â ; TmplÂ . ); Â Â Â templateClassImp(name). Definition at line 429 of file Rtypes.h. â—†Â Class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Rtypes_8h.html:14747,redund,redundant,14747,doc/master/Rtypes_8h.html,https://root.cern,https://root.cern/doc/master/Rtypes_8h.html,1,['redund'],['redundant']
Safety,"62; TSystem::AddTimervirtual void AddTimer(TTimer *t)Add timer to list of system timers.Definition TSystem.cxx:471; TSystem::GetBuildCompilerVersionStrvirtual const char * GetBuildCompilerVersionStr() constReturn the build compiler version identifier string.Definition TSystem.cxx:3899; TSystem::Exitvirtual void Exit(int code, Bool_t mode=kTRUE)Exit the application.Definition TSystem.cxx:716; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::SetPrognamevirtual void SetProgname(const char *name)Set the application name (from command line, argv[0]) and copy it in gProgName.Definition TSystem.cxx:226; TSystem::GetBuildArchvirtual const char * GetBuildArch() constReturn the build architecture.Definition TSystem.cxx:3875; TSystem::Abortvirtual void Abort(int code=0)Abort the application.Definition TSystem.cxx:725; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; TUrlThis class represents a WWW compatible URL.Definition TUrl.h:33; TUrl::GetUrlconst char * GetUrl(Bool_t withDeflt=kFALSE) constReturn full URL.Definition TUrl.cxx:390; TUrl::GetFileAndOptionsconst char * GetFileAndOptions() constReturn the file and its options (the string specified behind the ?).Definition TUrl.cxx:504; TUrl::GetFileconst char * GetFile() constDefinition TUrl.h:69; TUrl::GetProtocolconst char * GetProtocol() constDefinition TUrl.h:64; TVirtualXSemi-Abstract base class defining a generic interface to the underlying, low level,...Definition TVirtualX.h:46; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:107035,Abort,Abortvirtual,107035,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,3,['Abort'],"['Abort', 'Abortvirtual']"
Safety,"63 of file DeepNet.h. â—†Â Loss() [2/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Loss ; (; Tensor_t &Â ; input, . const Matrix_t &Â ; groundTruth, . const Matrix_t &Â ; weights, . boolÂ ; inTraining = false, . boolÂ ; includeRegularization = trueÂ . ). Function for evaluating the loss, based on the propagation of the given input. ; Definition at line 1279 of file DeepNet.h. â—†Â Prediction() [1/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t &Â ; predictions, . EOutputFunctionÂ ; fÂ . ); const. Prediction based on activations stored in the last layer. ; Definition at line 1303 of file DeepNet.h. â—†Â Prediction() [2/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t &Â ; predictions, . Tensor_t &Â ; input, . EOutputFunctionÂ ; fÂ . ). Prediction for the given inputs, based on what network learned. ; Definition at line 1311 of file DeepNet.h. â—†Â Print(). template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Print. Print the Deep Net Info. ; Definition at line 1321 of file DeepNet.h. â—†Â RegularizationTerm(). template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::RegularizationTerm. Function for computing the regularizaton term to be added to the loss function . Definition at line 1289 of file DeepNet.h. â—†Â ResetTraining(). template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::ResetTraining. Function that reset some training flags after looping all the events but not the weights. ; Definition at line 886 of file DeepNet.h. â—†Â SetBatchDepth(). template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>> . void TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::SetBatchDept",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDeepNet.html:24950,Predict,Prediction,24950,doc/master/classTMVA_1_1DNN_1_1TDeepNet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDeepNet.html,1,['Predict'],['Prediction']
Safety,"6451 ; 6452Int_t TTree::LoadBaskets(Long64_t maxmemory); 6453{; 6454 if (maxmemory > 0) SetMaxVirtualSize(maxmemory);; 6455 ; 6456 TIter next(GetListOfLeaves());; 6457 TLeaf *leaf;; 6458 Int_t nimported = 0;; 6459 while ((leaf=(TLeaf*)next())) {; 6460 nimported += leaf->GetBranch()->LoadBaskets();//break;; 6461 }; 6462 return nimported;; 6463}; 6464 ; 6465////////////////////////////////////////////////////////////////////////////////; 6466/// Set current entry.; 6467///; 6468/// Returns -2 if entry does not exist (just as TChain::LoadTree()).; 6469/// Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; 6470///; 6471/// Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; 6472///; 6473/// \note This function is overloaded in TChain.; 6474Long64_t TTree::LoadTree(Long64_t entry); 6475{; 6476 // We have already been visited while recursively looking; 6477 // through the friend trees, let's return; 6478 if (kLoadTree & fFriendLockStatus) {; 6479 // We need to return a negative value to avoid a circular list of friends; 6480 // to think that there is always an entry somewhere in the list.; 6481 return -1;; 6482 }; 6483 ; 6484 // create cache if wanted; 6485 if (fCacheDoAutoInit && entry >=0); 6486 SetCacheSizeAux();; 6487 ; 6488 if (fNotify) {; 6489 if (fReadEntry < 0) {; 6490 fNotify->Notify();; 6491 }; 6492 }; 6493 fReadEntry = entry;; 6494 ; 6495 bool friendHasEntry = false;; 6496 if (fFriends) {; 6497 // Set current entry in friends as well.; 6498 //; 6499 // An alternative would move this code to each of the; 6500 // functions calling LoadTree (and to overload a few more).; 6501 bool needUpdate = false;; 6502 {; 6503 // This scope is need to insure the lock is released at the right time; 6504 TIter nextf(fFriends);; 6505 TFriendLock lock(this, kLoadTree);; 6506 TFriendElement* fe = nullptr;; 6507 while ((fe = (TFriendElement*) nextf())) {; 6508 if (fe->TestBit(TFriendElement::kFromChain))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:253363,avoid,avoid,253363,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['avoid'],['avoid']
Safety,"65,30,-3,6);. //process cases with event list; fillList = kFALSE;; useList = kFALSE;; fChain->SetEventList(0);; delete gDirectory->GetList()->FindObject(""elist"");. // case when one creates/fills the event list; if (option.Contains(""fillList"")) {; fillList = kTRUE;; elist = new TEventList(""elist"",""selection from Cut"",5000);; }; // case when one uses the event list generated in a previous call; if (option.Contains(""useList"")) {; useList = kTRUE;; TFile f(""elist.root"");; elist = (TEventList*)f.Get(""elist"");; if (elist) elist->SetDirectory(0);; //otherwise the file destructor will delete elist; fChain->SetEventList(elist);; }; }; //_________________________________________________________; Bool_t h1analysis::ProcessCut(Int_t entry); { // Selection function to select D* and D0. //in case one event list is given in input,; //the selection has already been done.; if (useList) return kTRUE;; // Read only the necessary branches to select entries.; // return as soon as a bad entry is detected; b_md0_d->GetEntry(entry);; if (TMath::Abs(md0_d-1.8646) >= 0.04) return kFALSE;; b_ptds_d->GetEntry(entry);; if (ptds_d <= 2.5) return kFALSE;; b_etads_d->GetEntry(entry);; if (TMath::Abs(etads_d) >= 1.5) return kFALSE;; b_ik->GetEntry(entry); ik--;; //original ik used f77 convention starting at 1; b_ipi->GetEntry(entry);; ipi--;; b_ntracks->GetEntry(entry);; b_nhitrp->GetEntry(entry);; if (nhitrp[ik]*nhitrp[ipi] <= 1) return kFALSE;; b_rend->GetEntry(entry);; b_rstart->GetEntry(entry);; if (rend[ik]-rstart[ik] <= 22) return kFALSE;; if (rend[ipi]-rstart[ipi] <= 22) return kFALSE;; b_nlhk->GetEntry(entry);; if (nlhk[ik] <= 0.1) return kFALSE;; b_nlhpi->GetEntry(entry);; if (nlhpi[ipi] <= 0.1) return kFALSE;; b_ipis->GetEntry(entry);; ipis--;; if (nlhpi[ipis] <= 0.1) return kFALSE;; b_njets->GetEntry(entry);; if (njets < 1) return kFALSE;. // if option fillList, fill the event list; if (fillList) elist->Enter(fChain->GetChainEntryNumber(entry));. return kTRUE;; }. //_____________________",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1094323,detect,detected,1094323,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detected']
Safety,"679/// of this PDF for the given number of observed events.; 680///; 681/// For successful operation, the PDF implementation must indicate that; 682/// it is extendable by overloading `canBeExtended()`, and must; 683/// implement the `expectedEvents()` function.; 684///; 685/// \param[in] sumEntries The number of observed events.; 686/// \param[in] nset The normalization set when asking the pdf for the expected; 687/// number of events.; 688/// \param[in] observedSumW2 The number of observed events when weighting with; 689/// squared weights. If non-zero, the weight-squared error; 690/// correction is applied to the extended term.; 691/// \param[in] doOffset Offset the extended term by a counterterm where the; 692/// expected number of events equals the observed number of events.; 693/// This constant shift results in a term closer to zero that is; 694/// approximately chi-square distributed. It is useful to do this; 695/// also when summing multiple NLL terms to avoid numeric precision; 696/// loss that happens if you sum multiple terms of different orders; 697/// of magnitude.; 698///; 699/// The weight-squared error correction works as follows:; 700/// adjust poisson such that; 701/// estimate of \f$N_\mathrm{expect}\f$ stays at the same value, but has a different variance, rescale; 702/// both the observed and expected count of the Poisson with a factor \f$ \sum w_{i} / \sum w_{i}^2 \f$; 703/// (the effective weight of the Poisson term),; 704/// i.e., change \f$\mathrm{Poisson}(N_\mathrm{observed} = \sum w_{i} | N_\mathrm{expect} )\f$; 705/// to \f$ \mathrm{Poisson}(\sum w_{i} \cdot \sum w_{i} / \sum w_{i}^2 | N_\mathrm{expect} \cdot \sum w_{i} / \sum w_{i}^2 ) \f$,; 706/// weighted by the effective weight \f$ \sum w_{i}^2 / \sum w_{i} \f$ in the likelihood.; 707/// Since here we compute the likelihood with the weight square, we need to multiply by the; 708/// square of the effective weight:; 709/// - \f$ W_\mathrm{expect} = N_\mathrm{expect} \cdot \sum w_{i} / ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:26829,avoid,avoid,26829,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['avoid'],['avoid']
Safety,"681 0.047397 20090.8 9; : 26 | 0.531742 0.582802 0.613513 0.0496834 19750.6 10; : 27 | 0.532714 0.581886 0.617515 0.0480417 19554.9 11; : ; : Elapsed time for training with 14000 events: 16.1 sec ; : Evaluate deep neural network on CPU using batches with size = 128; : ; DNN_CPU : [dataset] : Evaluation of DNN_CPU on training sample (14000 events); : Elapsed time for evaluation of 14000 events: 0.253 sec ; : Creating xml weight file: â›[0;36mdataset/weights/TMVA_Higgs_Classification_DNN_CPU.weights.xmlâ›[0m; : Creating standalone class: â›[0;36mdataset/weights/TMVA_Higgs_Classification_DNN_CPU.class.Câ›[0m; Factory : Training finished; : ; Factory : Train method: PyKeras for Classification; : ; : ; : â›[1m================================================================â›[0m; : â›[1mH e l p f o r M V A m e t h o d [ PyKeras ] :â›[0m; : ; : Keras is a high-level API for the Theano and Tensorflow packages.; : This method wraps the training and predictions steps of the Keras; : Python package for TMVA, so that dataloading, preprocessing and; : evaluation can be done within the TMVA system. To use this Keras; : interface, you have to generate a model with Keras first. Then,; : this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : â›[1m================================================================â›[0m; : ; : Split TMVA training data in 11200 training events and 2800 validation events; : Training Model Summary; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; dense (Dense) (None, 64) 512 ; ; dense_1 (Dense) (None, 64) 4160 ; ; dense_2 (Dense) (None, 64) 4160 ; ; dense_3 (Dense) (None, 64) 4160 ; ; dense_4 (Dense) (None, 2) 130 ; ; =================================================================; Total params: 13122 (51.26 KB); Trainable params: 13122 (51.26 KB); Non-trai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:26966,predict,predictions,26966,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['predict'],['predictions']
Safety,"69 *s1 = '$';; 370 s1 += 2;; 371 s2 = (char*)strchr(s1, ')');; 372 *s2 = 0;; 373 vv = gSystem->Getenv(s1);; 374 if (vv) strlcat(nv, vv,nch);; 375 *s2 = ')';; 376 v = s2 + 1;; 377 }; 378 ; 379 if (*v) strlcat(nv, v,nch);; 380 ; 381 TString val = nv;; 382 delete [] nv;; 383 delete [] vorg;; 384 ; 385 return val;; 386}; 387 ; 388ClassImp(TEnv);; 389 ; 390////////////////////////////////////////////////////////////////////////////////; 391/// Create a resource table and read the (possibly) three resource files,; 392/// i.e.\ `$ROOTSYS/etc/system<name>` (or `ROOTETCDIR/system<name>`),; 393/// `$HOME/<name>` and `$PWD/<name>`.; 394/// ROOT always reads "".rootrc"" (in TROOT::InitSystem()). You can; 395/// read additional user defined resource files by creating additional TEnv; 396/// objects. By setting the shell variable ROOTENV_NO_HOME=1 the reading of; 397/// the `$HOME/<name>` resource file will be skipped. This might be useful in; 398/// case the home directory resides on an auto-mounted remote file system; 399/// and one wants to avoid the file system from being mounted.; 400 ; 401TEnv::TEnv(const char *name); 402{; 403 fIgnoreDup = kFALSE;; 404 ; 405 if (!name || !name[0] || !gSystem); 406 fTable = nullptr;; 407 else {; 408 fTable = new THashList(1000);; 409 fRcName = name;; 410 ; 411 TString sname = ""system"";; 412 sname += name;; 413 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 414 ReadFile(s, kEnvGlobal);; 415 delete [] s;; 416 if (!gSystem->Getenv(""ROOTENV_NO_HOME"")) {; 417 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 418 ReadFile(s, kEnvUser);; 419 delete [] s;; 420 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())); 421 ReadFile(name, kEnvLocal);; 422 } else; 423 ReadFile(name, kEnvLocal);; 424 }; 425}; 426 ; 427////////////////////////////////////////////////////////////////////////////////; 428/// Delete the resource table.; 429 ; 430TEnv::~TEnv(); 431{; 432 if (fTable) {; 433 fTable->Delete();; 434 SafeDelete(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEnv_8cxx_source.html:10822,avoid,avoid,10822,doc/master/TEnv_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html,1,['avoid'],['avoid']
Safety,"6_file_1.root"", ""recreate""); file_2 = TFile(""pyroot006_file_2.root"", ""recreate""); print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); # Changing directory into another file can be safely done through a TContext; # context manager.; with TDirectory.TContext(file_1):; # Inside the statement, the current directory is file_1; print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); histo_1 = ROOT.TH1F(""histo_1"", ""histo_1"", 10, 0, 10); file_1.WriteObject(histo_1, ""my_histogram""); ; # After the context, the current directory is restored back to file_2. Also, the; # two files are kept open. This means that objects read, written or modified; # inside the context are still available afterwards.; print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); if file_1.IsOpen() and file_2.IsOpen():; print(""'{}' and '{}' are open.\n"".format(file_1.GetName(), file_2.GetName())); ; # TContext and TFile context managers can also be used in conjunction, allowing; # for safely:; # - Opening a file, creating, modifying, writing and reading objects in it.; # - Closing the file, storing it on disk.; # - Restoring the previous value of gDirectory to the latest file opened before; # this context, rather than to the global ROOT.gROOT; # Remember that the TContext must be initialized before the TFile, otherwise the; # current directory would already be set to the file opened for this context.; with TDirectory.TContext(), TFile(""pyroot006_file_3.root"", ""recreate"") as f:; print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); histo_2 = ROOT.TH1F(""histo_2"", ""histo_2"", 10, 0, 10); f.WriteObject(histo_2, ""another_histogram""); ; print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); ; # Cleanup the files created for this tutorial; file_1.Close();; file_2.Close();; for i in range(1, 4):; os.remove(""pyroot006_file_{}.root"".format(i)); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot006__tcontext__context__manager_8py.html:1730,safe,safely,1730,doc/master/pyroot006__tcontext__context__manager_8py.html,https://root.cern,https://root.cern/doc/master/pyroot006__tcontext__context__manager_8py.html,1,['safe'],['safely']
Safety,"7 ; 4368 if ((conn == NULL) || (fmt == NULL)) {; 4369 return -2;; 4370 }; 4371 ; 4372 /* Set status (for log) */; 4373 conn->status_code = status;; 4374 ; 4375 /* Errors 1xx, 204 and 304 MUST NOT send a body */; 4376 has_body = ((status > 199) && (status != 204) && (status != 304));; 4377 ; 4378 /* Prepare message in buf, if required */; 4379 if (has_body; 4380 || (!conn->in_error_handler; 4381 && (conn->phys_ctx->callbacks.http_error != NULL))) {; 4382 /* Store error message in errmsg_buf */; 4383 va_copy(ap, args);; 4384 mg_vsnprintf(conn, NULL, errmsg_buf, sizeof(errmsg_buf), fmt, ap);; 4385 va_end(ap);; 4386 /* In a debug build, print all html errors */; 4387 DEBUG_TRACE(""Error %i - [%s]"", status, errmsg_buf);; 4388 }; 4389 ; 4390 /* If there is a http_error callback, call it.; 4391 * But don't do it recursively, if callback calls mg_send_http_error again.; 4392 */; 4393 if (!conn->in_error_handler; 4394 && (conn->phys_ctx->callbacks.http_error != NULL)) {; 4395 /* Mark in_error_handler to avoid recursion and call user callback. */; 4396 conn->in_error_handler = 1;; 4397 handled_by_callback =; 4398 (conn->phys_ctx->callbacks.http_error(conn, status, errmsg_buf); 4399 == 0);; 4400 conn->in_error_handler = 0;; 4401 }; 4402 ; 4403 if (!handled_by_callback) {; 4404 /* Check for recursion */; 4405 if (conn->in_error_handler) {; 4406 DEBUG_TRACE(; 4407 ""Recursion when handling error %u - fall back to default"",; 4408 status);; 4409#if !defined(NO_FILESYSTEMS); 4410 } else {; 4411 /* Send user defined error pages, if defined */; 4412 error_handler = conn->dom_ctx->config[ERROR_PAGES];; 4413 error_page_file_ext = conn->dom_ctx->config[INDEX_FILES];; 4414 page_handler_found = 0;; 4415 ; 4416 if (error_handler != NULL) {; 4417 for (scope = 1; (scope <= 3) && !page_handler_found; scope++) {; 4418 switch (scope) {; 4419 case 1: /* Handler for specific error, e.g. 404 error */; 4420 mg_snprintf(conn,; 4421 &truncated,; 4422 path_buf,; 4423 sizeof(path_buf) - 32,; 4424 ""%serro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:131409,avoid,avoid,131409,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['avoid'],['avoid']
Safety,"7// //; 18// TTimer //; 19// //; 20// Handles synchronous and a-synchronous timer events. You can use //; 21// this class in one of the following ways: //; 22// - Sub-class TTimer and override the Notify() method. //; 23// - Re-implement the TObject::HandleTimer() method in your class //; 24// and pass a pointer to this object to timer, see the SetObject() //; 25// method. //; 26// - Pass an interpreter command to timer, see SetCommand() method. //; 27// - Create a TTimer, connect its Timeout() signal to the //; 28// appropriate methods. Then when the time is up it will emit a //; 29// Timeout() signal and call connected slots. //; 30// //; 31// Minimum timeout interval is defined in TSystem::ESysConstants as //; 32// kItimerResolution (currently 10 ms). //; 33// //; 34// Signal/slots example: //; 35// TTimer *timer = new TTimer(); //; 36// timer->Connect(""Timeout()"", ""myObjectClassName"", //; 37// myObject, ""TimerDone()""); //; 38// timer->Start(2000, kTRUE); // 2 seconds single-shot //; 39// //; 40// // Timeout signal is emitted repeadetly with minimum timeout //; 41// // timer->Start(0, kFALSE); //; 42// //; 43//////////////////////////////////////////////////////////////////////////; 44 ; 45#include ""TSysEvtHandler.h""; 46#include ""TTime.h""; 47#include ""TString.h""; 48 ; 49 ; 50 ; 51class TTimer : public TSysEvtHandler {; 52 ; 53protected:; 54 TTime fTime; // time out time in ms; 55 TTime fAbsTime; // absolute time out time in ms; 56 Bool_t fTimeout; // true if timer has timed out; 57 Bool_t fSync; // true if synchrounous timer; 58 Bool_t fIntSyscalls; // true is a-synchronous timer is to interrupt system calls; 59 UInt_t fTimeID; // the system ID of this timer (for WIN32); 60 TObject *fObject; // object to be notified (if any); 61 TString fCommand; // interpreter command to be executed; 62 ; 63private:; 64 TTimer(const TTimer&) = delete;; 65 TTimer& operator=(const TTimer&) = delete;; 66 ; 67public:; 68 TTimer(Long_t milliSec = 0, Bool_t mode = kTRUE);; 69 TTimer(TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8h_source.html:1620,Timeout,Timeout,1620,doc/master/TTimer_8h_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8h_source.html,3,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,"71 }; 772 ; 773 iterator insert(iterator I, const T &Elt); 774 {; 775 if (I == this->end()) { // Important special case for empty vector.; 776 this->push_back(Elt);; 777 return this->end() - 1;; 778 }; 779 ; 780 if (I < this->begin() || I > this->end()) {; 781 throw std::runtime_error(""The iterator passed to `insert` is out of bounds."");; 782 }; 783 ; 784 if (this->size() >= this->capacity()) {; 785 size_t EltNo = I - this->begin();; 786 this->grow();; 787 I = this->begin() + EltNo;; 788 }; 789 ::new ((void *)this->end()) T(std::move(this->back()));; 790 // Push everything else over.; 791 std::move_backward(I, this->end() - 1, this->end());; 792 this->set_size(this->size() + 1);; 793 ; 794 // If we just moved the element we're inserting, be sure to update; 795 // the reference.; 796 const T *EltPtr = &Elt;; 797 if (I <= EltPtr && EltPtr < this->end()); 798 ++EltPtr;; 799 ; 800 *I = *EltPtr;; 801 return I;; 802 }; 803 ; 804 iterator insert(iterator I, size_type NumToInsert, const T &Elt); 805 {; 806 // Convert iterator to elt# to avoid invalidating iterator when we reserve(); 807 size_t InsertElt = I - this->begin();; 808 ; 809 if (I == this->end()) { // Important special case for empty vector.; 810 append(NumToInsert, Elt);; 811 return this->begin() + InsertElt;; 812 }; 813 ; 814 if (I < this->begin() || I > this->end()) {; 815 throw std::runtime_error(""The iterator passed to `insert` is out of bounds."");; 816 }; 817 ; 818 // Ensure there is enough space.; 819 reserve(this->size() + NumToInsert);; 820 ; 821 // Uninvalidate the iterator.; 822 I = this->begin() + InsertElt;; 823 ; 824 // If there are more elements between the insertion point and the end of the; 825 // range than there are being inserted, we can use a simple approach to; 826 // insertion. Since we already reserved space, we know that this won't; 827 // reallocate the vector.; 828 if (size_t(this->end() - I) >= NumToInsert) {; 829 T *OldEnd = this->end();; 830 append(std::move_iterator<iterator>(this->e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:28216,avoid,avoid,28216,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['avoid'],['avoid']
Safety,"7141 }; 17142 }; 17143 ; 17144 mg_unlock_connection(conn);; 17145 ; 17146#if defined(USE_SERVER_STATS); 17147 conn->conn_state = 8; /* closed */; 17148#endif; 17149}; 17150 ; 17151 ; 17152void; 17153mg_close_connection(struct mg_connection *conn); 17154{; 17155 if ((conn == NULL) || (conn->phys_ctx == NULL)) {; 17156 return;; 17157 }; 17158 ; 17159#if defined(USE_WEBSOCKET); 17160 if (conn->phys_ctx->context_type == CONTEXT_SERVER) {; 17161 if (conn->in_websocket_handling) {; 17162 /* Set close flag, so the server thread can exit. */; 17163 conn->must_close = 1;; 17164 return;; 17165 }; 17166 }; 17167 if (conn->phys_ctx->context_type == CONTEXT_WS_CLIENT) {; 17168 ; 17169 unsigned int i;; 17170 ; 17171 /* client context: loops must end */; 17172 STOP_FLAG_ASSIGN(&conn->phys_ctx->stop_flag, 1);; 17173 conn->must_close = 1;; 17174 ; 17175 /* We need to get the client thread out of the select/recv call; 17176 * here. */; 17177 /* Since we use a sleep quantum of some seconds to check for recv; 17178 * timeouts, we will just wait a few seconds in mg_join_thread. */; 17179 ; 17180 /* join worker thread */; 17181 for (i = 0; i < conn->phys_ctx->cfg_worker_threads; i++) {; 17182 mg_join_thread(conn->phys_ctx->worker_threadids[i]);; 17183 }; 17184 }; 17185#endif /* defined(USE_WEBSOCKET) */; 17186 ; 17187 close_connection(conn);; 17188 ; 17189#if !defined(NO_SSL) && !defined(USE_MBEDTLS) // TODO: mbedTLS client; 17190 if (((conn->phys_ctx->context_type == CONTEXT_HTTP_CLIENT); 17191 || (conn->phys_ctx->context_type == CONTEXT_WS_CLIENT)); 17192 && (conn->phys_ctx->dd.ssl_ctx != NULL)) {; 17193 SSL_CTX_free(conn->phys_ctx->dd.ssl_ctx);; 17194 }; 17195#endif; 17196 ; 17197#if defined(USE_WEBSOCKET); 17198 if (conn->phys_ctx->context_type == CONTEXT_WS_CLIENT) {; 17199 mg_free(conn->phys_ctx->worker_threadids);; 17200 (void)pthread_mutex_destroy(&conn->mutex);; 17201 mg_free(conn);; 17202 } else if (conn->phys_ctx->context_type == CONTEXT_HTTP_CLIENT) {; 17203 (void)pthread_mut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:510068,timeout,timeouts,510068,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeouts']
Safety,"7142 }; 17143 }; 17144 ; 17145 mg_unlock_connection(conn);; 17146 ; 17147#if defined(USE_SERVER_STATS); 17148 conn->conn_state = 8; /* closed */; 17149#endif; 17150}; 17151 ; 17152 ; 17153void; 17154mg_close_connection(struct mg_connection *conn); 17155{; 17156 if ((conn == NULL) || (conn->phys_ctx == NULL)) {; 17157 return;; 17158 }; 17159 ; 17160#if defined(USE_WEBSOCKET); 17161 if (conn->phys_ctx->context_type == CONTEXT_SERVER) {; 17162 if (conn->in_websocket_handling) {; 17163 /* Set close flag, so the server thread can exit. */; 17164 conn->must_close = 1;; 17165 return;; 17166 }; 17167 }; 17168 if (conn->phys_ctx->context_type == CONTEXT_WS_CLIENT) {; 17169 ; 17170 unsigned int i;; 17171 ; 17172 /* client context: loops must end */; 17173 STOP_FLAG_ASSIGN(&conn->phys_ctx->stop_flag, 1);; 17174 conn->must_close = 1;; 17175 ; 17176 /* We need to get the client thread out of the select/recv call; 17177 * here. */; 17178 /* Since we use a sleep quantum of some seconds to check for recv; 17179 * timeouts, we will just wait a few seconds in mg_join_thread. */; 17180 ; 17181 /* join worker thread */; 17182 for (i = 0; i < conn->phys_ctx->cfg_worker_threads; i++) {; 17183 mg_join_thread(conn->phys_ctx->worker_threadids[i]);; 17184 }; 17185 }; 17186#endif /* defined(USE_WEBSOCKET) */; 17187 ; 17188 close_connection(conn);; 17189 ; 17190#if !defined(NO_SSL) && !defined(USE_MBEDTLS) // TODO: mbedTLS client; 17191 if (((conn->phys_ctx->context_type == CONTEXT_HTTP_CLIENT); 17192 || (conn->phys_ctx->context_type == CONTEXT_WS_CLIENT)); 17193 && (conn->phys_ctx->dd.ssl_ctx != NULL)) {; 17194 SSL_CTX_free(conn->phys_ctx->dd.ssl_ctx);; 17195 }; 17196#endif; 17197 ; 17198#if defined(USE_WEBSOCKET); 17199 if (conn->phys_ctx->context_type == CONTEXT_WS_CLIENT) {; 17200 mg_free(conn->phys_ctx->worker_threadids);; 17201 (void)pthread_mutex_destroy(&conn->mutex);; 17202 mg_free(conn);; 17203 } else if (conn->phys_ctx->context_type == CONTEXT_HTTP_CLIENT) {; 17204 (void)pthread_mut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:510101,timeout,timeouts,510101,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeouts']
Safety,"72 kCannotPick = TObject::kCannotPick,; 373 kNoContextMenu = TObject::kNoContextMenu,; 374 kInvalidObject = TObject::kInvalidObject; 375};; 376 ; 377namespace cling {; 378 std::string printValue(TObject *val);; 379}; 380 ; 381namespace ROOT {; 382 ; 383namespace Internal {; 384 bool DeleteChangesMemory();; 385} // Internal; 386 ; 387namespace Detail {; 388 ; 389 ; 390/// @brief Check if the TObject's memory has been deleted.; 391/// @warning This should be only used for error mitigation as the answer is only; 392/// sometimes correct. It actually just checks whether the object has been; 393/// deleted, so this will falsely return true for an object that has; 394/// been destructed but its memory has not been deleted. This will return an; 395/// undefined value if the memory is re-used between the deletion and the check.; 396/// i.e. This is useful to prevent a segmentation fault in case where the problem; 397/// can be detected when the deletion and the usage are 'close-by'; 398/// @warning In enviroment where delete taints (changes) the memory, this function; 399/// always returns false as the marker left by ~TObject will be overwritten.; 400/// @param obj The memory to check; 401/// @return true if the object has been destructed and it can be inferred that it has been deleted; 402R__ALWAYS_INLINE bool HasBeenDeleted(const TObject *obj) {; 403 return !ROOT::Internal::DeleteChangesMemory() && obj->IsDestructed();; 404}; 405 ; 406}} // ROOT::Details; 407 ; 408#endif; R__ALWAYS_INLINE#define R__ALWAYS_INLINEDefinition RConfig.hxx:552; R__likely#define R__likely(expr)Definition RConfig.hxx:587; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Longptr_tlong Longptr_tDefinition RtypesCore.h:75; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; UInt_tunsigned int UInt_tDefinition Rtype",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8h_source.html:16856,detect,detected,16856,doc/master/TObject_8h_source.html,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html,1,['detect'],['detected']
Safety,"73 delete gSystem;; 974 ; 975 // ROOT-6022:; 976 // if (gInterpreterLib) dlclose(gInterpreterLib);; 977#ifdef R__COMPLETE_MEM_TERMINATION; 978 // On some 'newer' platform (Fedora Core 17+, Ubuntu 12), the; 979 // initialization order is (by default?) is 'wrong' and so we can't; 980 // delete the interpreter now .. because any of the static in the; 981 // interpreter's library have already been deleted.; 982 // On the link line, we must list the most dependent .o file; 983 // and end with the least dependent (LLVM libraries), unfortunately,; 984 // Fedora Core 17+ or Ubuntu 12 will also execute the initialization; 985 // in the same order (hence doing libCore's before LLVM's and; 986 // vice et versa for both the destructor. We worked around the; 987 // initialization order by delay the TROOT creation until first use.; 988 // We can not do the same for destruction as we have no way of knowing; 989 // the last access ...; 990 // So for now, let's avoid delete TCling except in the special build; 991 // checking the completeness of the termination deletion.; 992 ; 993 // TODO: Should we do more cleanup here than just call delete?; 994 // Segfaults rootcling in some cases, debug and uncomment:; 995 //; 996 // delete fInterpreter;; 997 ; 998 // We cannot delete fCleanups because of the logic in atexit which needs it.; 999 SafeDelete(fCleanups);; 1000#endif; 1001 ; 1002#ifdef _MSC_VER; 1003 // usedToIdentifyRootClingByDlSym is available when TROOT is part of rootcling.; 1004 if (dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"")) {; 1005 // deleting the interpreter makes things crash at exit in some cases; 1006 delete fInterpreter;; 1007 }; 1008#else; 1009 // deleting the interpreter makes things crash at exit in some cases; 1010 delete fInterpreter;; 1011#endif; 1012 ; 1013 // Prints memory stats; 1014 TStorage::PrintStatistics();; 1015 ; 1016 gROOTLocal = nullptr;; 1017 fgRootInit = kFALSE;; 1018 }; 1019}; 1020 ; 1021////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:39328,avoid,avoid,39328,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['avoid'],['avoid']
Safety,"76 ; 377 // Check if the bins are the same.; 378 TList *h1pBins = h1p->GetBins();; 379 TH2PolyBin *thisBin, *h1pBin;; 380 for (bin = 1; bin <= GetNumberOfBins(); bin++) {; 381 thisBin = (TH2PolyBin *)fBins->At(bin - 1);; 382 h1pBin = (TH2PolyBin *)h1pBins->At(bin - 1);; 383 if (thisBin->GetXMin() != h1pBin->GetXMin() ||; 384 thisBin->GetXMax() != h1pBin->GetXMax() ||; 385 thisBin->GetYMin() != h1pBin->GetYMin() ||; 386 thisBin->GetYMax() != h1pBin->GetYMax()) {; 387 Error(""Add"", ""Attempt to add histograms with different bin limits"");; 388 return kFALSE;; 389 }; 390 }; 391 ; 392 ; 393 // Create Sumw2 if h1p has Sumw2 set; 394 if (fSumw2.fN == 0 && h1p->GetSumw2N() != 0) Sumw2();; 395 ; 396 // statistics can be preserved only in case of positive coefficients; 397 // otherwise with negative c1 (histogram subtraction) one risks to get negative variances; 398 Bool_t resetStats = (c1 < 0);; 399 Double_t s1[kNstat] = {0};; 400 Double_t s2[kNstat] = {0};; 401 if (!resetStats) {; 402 // need to initialize to zero s1 and s2 since; 403 // GetStats fills only used elements depending on dimension and type; 404 GetStats(s1);; 405 h1->GetStats(s2);; 406 }; 407 // get number of entries now because afterwards UpdateBinContent will change it; 408 Double_t entries = TMath::Abs( GetEntries() + c1 * h1->GetEntries() );; 409 ; 410 ; 411 // Perform the Add.; 412 Double_t factor = 1;; 413 if (h1p->GetNormFactor() != 0); 414 factor = h1p->GetNormFactor() / h1p->GetSumOfWeights();; 415 for (bin = 0; bin < fNcells; bin++) {; 416 Double_t y = this->RetrieveBinContent(bin) + c1 * h1p->RetrieveBinContent(bin);; 417 UpdateBinContent(bin, y);; 418 if (fSumw2.fN) {; 419 Double_t esq = factor * factor * h1p->GetBinErrorSqUnchecked(bin);; 420 fSumw2.fArray[bin] += c1 * c1 * factor * factor * esq;; 421 }; 422 }; 423 ; 424 // update statistics (do here to avoid changes by SetBinContent); 425 if (resetStats) {; 426 // statistics need to be reset in case coefficient are negative; 427 ResetStats();; 428 }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8cxx_source.html:15296,risk,risks,15296,doc/master/TH2Poly_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html,1,['risk'],['risks']
Safety,"76 continue; // this node is not used at all; 1477 ; 1478 auto &desc = fDesc[sid];; 1479 if ((viscnt[sid] <= 0) && (desc.vol <= 0)); 1480 continue;; 1481 ; 1482 auto shape = GetVolume(sid)->GetShape();; 1483 if (!shape); 1484 continue;; 1485 ; 1486 // create shape raw data; 1487 auto &shape_descr = MakeShapeDescr(shape);; 1488 ; 1489 // should not happen, but just in case; 1490 if (shape_descr.nfaces <= 0) {; 1491 R__LOG_ERROR(RGeomLog()) << ""No faces for the shape "" << shape->GetName() << "" class "" << shape->ClassName();; 1492 continue;; 1493 }; 1494 ; 1495 // check how many faces are created; 1496 totalnumfaces += shape_descr.nfaces * viscnt[sid];; 1497 if ((GetMaxVisFaces() > 0) && (totalnumfaces > GetMaxVisFaces())) {; 1498 send_rawdata = false;; 1499 break;; 1500 }; 1501 ; 1502 // also avoid too many nodes; 1503 totalnumnodes += viscnt[sid];; 1504 if ((GetMaxVisNodes() > 0) && (totalnumnodes > GetMaxVisNodes())) {; 1505 send_rawdata = false;; 1506 break;; 1507 }; 1508 }; 1509 ; 1510 // only for debug purposes - remove later; 1511 // send_rawdata = false;; 1512 ; 1513 // finally we should create data for streaming to the client; 1514 // it includes list of visible nodes and rawdata (if there is enough space); 1515 ; 1516 std::vector<RGeomNodeBase> found_desc; ///<! hierarchy of nodes, used for search; 1517 std::vector<int> found_map(fDesc.size(), -1); ///<! mapping between nodeid - > foundid; 1518 ; 1519 // these are only selected nodes to produce hierarchy; 1520 ; 1521 found_desc.emplace_back(0);; 1522 found_desc[0].vis = fDesc[0].vis;; 1523 found_desc[0].name = fDesc[0].name;; 1524 found_desc[0].color = fDesc[0].color;; 1525 found_map[0] = 0;; 1526 ; 1527 ResetRndrInfos();; 1528 ; 1529 RGeomDrawing drawing;; 1530 bool has_shape = true;; 1531 ; 1532 ScanNodes(false, 0, [&, this](RGeomNode &node, std::vector<int> &stack, bool is_vis, int seqid) {; 1533 // select only nodes which should match; 1534 if (!match_func(node)); 1535 return true;; 1536 ; 1537 // add entr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:45583,avoid,avoid,45583,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['avoid'],['avoid']
Safety,"79 npt = 1;; 5380 qlx[0] = sxmin + xt/xratio;; 5381 qly[0] = symin + yt/yratio;; 5382L320:; 5383 if (finished > 0) goto L390;; 5384 if (finished < 0) { finished = 0; goto L110;}; 5385 if (s > 0) goto L180;; 5386 goto L110;; 5387 ; 5388 // Convert coordinates back to original system; 5389 ; 5390L390:; 5391 for (i=0;i<npoints;i++) {; 5392 x[i] = sxmin + x[i]/xratio;; 5393 y[i] = symin + y[i]/yratio;; 5394 }; 5395 ; 5396}; 5397 ; 5398////////////////////////////////////////////////////////////////////////////////; 5399/// Static function to set `fgMaxPointsPerLine` for graph painting. When graphs; 5400/// are painted with lines, they are split into chunks of length `fgMaxPointsPerLine`.; 5401/// This allows to paint line with an ""infinite"" number of points. In some case; 5402/// this ""chunks painting"" technic may create artefacts at the chunk's boundaries.; 5403/// For instance when zooming deeply in a PDF file. To avoid this effect it might; 5404/// be necessary to increase the chunks' size using this function:; 5405/// `TGraphPainter::SetMaxPointsPerLine(20000)`.; 5406 ; 5407void TGraphPainter::SetMaxPointsPerLine(Int_t maxp); 5408{; 5409 fgMaxPointsPerLine = maxp;; 5410 if (maxp < 50) fgMaxPointsPerLine = 50;; 5411}; kMouseMotion@ kMouseMotionDefinition Buttons.h:23; kButton1Motion@ kButton1MotionDefinition Buttons.h:20; kButton1Up@ kButton1UpDefinition Buttons.h:19; kButton1Down@ kButton1DownDefinition Buttons.h:17; kMove@ kMoveDefinition GuiTypes.h:374; kHand@ kHandDefinition GuiTypes.h:374; kMaxPixelconst Int_t kMaxPixelMax value for an int.Definition GuiTypes.h:369; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; Int_tint Int_tDefinition RtypesCore.h:45; Char_tchar Char_tDefinition RtypesCore.h:37; Float_tfloat Float_tDefinition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:186508,avoid,avoid,186508,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['avoid'],['avoid']
Safety,"8 &) = delete;; 32 ; 33 void CopyTwist(Double_t *twist = nullptr);; 34 ; 35public:; 36 // constructors; 37 TGeoArb8();; 38 TGeoArb8(Double_t dz, Double_t *vertices = nullptr);; 39 TGeoArb8(const char *name, Double_t dz, Double_t *vertices = nullptr);; 40 // destructor; 41 ~TGeoArb8() override;; 42 // methods; 43 Double_t Capacity() const override;; 44 void ComputeBBox() override;; 45 void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override;; 46 void ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;; 47 void ComputeTwist();; 48 Bool_t Contains(const Double_t *point) const override;; 49 void Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override;; 50 Double_t DistToPlane(const Double_t *point, const Double_t *dir, Int_t ipl, Bool_t in) const;; 51 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 52 Double_t *safe = nullptr) const override;; 53 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 54 Double_t *step) const override;; 55 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 56 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 57 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 58 Double_t *step) const override;; 59 TGeoVolume *; 60 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 61 Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;; 62 void GetBoundingCylinder(Double_t *param) const override;; 63 Int_t GetByteCount() const override { return 100; }; 64 Double_t GetClosestEdge(const Double_t *point, Double_t *vert, Int_t &isegment) const;; 65 Bool_t GetPointsOnFacet(Int_t /*index*/, Int_t /*npoints*/, Double_t * /*array*/) const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:2222,safe,safe,2222,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,1,['safe'],['safe']
Safety,"8 /* Print first entry - link to a parent directory */; 9699 mg_printf(conn,; 9700 ""<tr><td><a href=\""%s\"">%s</a></td>""; 9701 ""<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\n"",; 9702 "".."",; 9703 ""Parent directory"",; 9704 ""-"",; 9705 ""-"");; 9706 ; 9707 /* Sort and print directory entries */; 9708 if (data.entries != NULL) {; 9709 qsort(data.entries,; 9710 data.num_entries,; 9711 sizeof(data.entries[0]),; 9712 compare_dir_entries);; 9713 for (i = 0; i < data.num_entries; i++) {; 9714 print_dir_entry(&data.entries[i]);; 9715 mg_free(data.entries[i].file_name);; 9716 }; 9717 mg_free(data.entries);; 9718 }; 9719 ; 9720 mg_printf(conn, ""%s"", ""</table></pre></body></html>"");; 9721 conn->status_code = 200;; 9722}; 9723#endif /* NO_FILESYSTEMS */; 9724 ; 9725 ; 9726/* Send len bytes from the opened file to the client. */; 9727static void; 9728send_file_data(struct mg_connection *conn,; 9729 struct mg_file *filep,; 9730 int64_t offset,; 9731 int64_t len); 9732{; 9733 char buf[MG_BUF_LEN];; 9734 int to_read, num_read, num_written;; 9735 int64_t size;; 9736 ; 9737 if (!filep || !conn) {; 9738 return;; 9739 }; 9740 ; 9741 /* Sanity check the offset */; 9742 size = (filep->stat.size > INT64_MAX) ? INT64_MAX; 9743 : (int64_t)(filep->stat.size);; 9744 offset = (offset < 0) ? 0 : ((offset > size) ? size : offset);; 9745 ; 9746 if (len > 0 && filep->access.fp != NULL) {; 9747 /* file stored on disk */; 9748#if defined(__linux__); 9749 /* sendfile is only available for Linux */; 9750 if ((conn->ssl == 0) && (conn->throttle == 0); 9751 && (!mg_strcasecmp(conn->dom_ctx->config[ALLOW_SENDFILE_CALL],; 9752 ""yes""))) {; 9753 off_t sf_offs = (off_t)offset;; 9754 ssize_t sf_sent;; 9755 int sf_file = fileno(filep->access.fp);; 9756 int loop_cnt = 0;; 9757 ; 9758 do {; 9759 /* 2147479552 (0x7FFFF000) is a limit found by experiment on; 9760 * 64 bit Linux (2^31 minus one memory page of 4k?). */; 9761 size_t sf_tosend =; 9762 (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);; 9763 sf_sent =; 9764 se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:278822,Sanity check,Sanity check,278822,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['Sanity check'],['Sanity check']
Safety,"8 ; 189 // try again to see if the interpreter is initialized; 190 if (!Py_IsInitialized()) {; 191 // give up ...; 192 std::cerr << ""Error: python has not been intialized; returning."" << std::endl;; 193 return kFALSE;; 194 }; 195 ; 196#if PY_VERSION_HEX < 0x030b0000; 197 PySys_SetArgv(argc, argv);; 198#endif; 199 ; 200 mainThreadState = PyEval_SaveThread();; 201 }; 202 ; 203 {; 204 // For the Python API calls; 205 PyGILRAII gilRaii;; 206 ; 207 // force loading of the ROOT module; 208 const int ret = PyRun_SimpleString(const_cast<char *>(""import ROOT""));; 209 if (ret != 0) {; 210 std::cerr << ""Error: import ROOT failed, check your PYTHONPATH environmental variable."" << std::endl;; 211 return kFALSE;; 212 }; 213 ; 214 if (!gMainDict) {; 215 ; 216 // retrieve the main dictionary; 217 gMainDict = PyModule_GetDict(PyImport_AddModule(const_cast<char *>(""__main__"")));; 218 // The gMainDict is borrowed, i.e. we are not calling Py_INCREF(gMainDict).; 219 // Like this, we avoid unexpectedly affecting how long __main__ is kept; 220 // alive. The gMainDict is only used in Exec(), ExecScript(), and Eval(),; 221 // which should not be called after __main__ is garbage collected anyway.; 222 }; 223 }; 224 ; 225 // python side class construction, managed by ROOT; 226 gROOT->AddClassGenerator(new TPyClassGenerator);; 227 ; 228 // declare success ...; 229 isInitialized = kTRUE;; 230 return kTRUE;; 231}; 232 ; 233////////////////////////////////////////////////////////////////////////////////; 234/// Import the named python module and create Cling equivalents for its classes; 235/// and methods.; 236 ; 237Bool_t TPython::Import(const char *mod_name); 238{; 239 // setup; 240 if (!Initialize()); 241 return false;; 242 ; 243 PyGILRAII gilRaii;; 244 ; 245 if (!CPyCppyy::Import(mod_name)) {; 246 return false;; 247 }; 248 ; 249 // force creation of the module as a namespace; 250 TClass::GetClass(mod_name, kTRUE);; 251 ; 252 PyObject *modNameObj = PyUnicode_FromString(mod_name);; 253 PyObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPython_8cxx_source.html:7519,avoid,avoid,7519,doc/master/TPython_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html,1,['avoid'],['avoid']
Safety,"8 ; 4369 if ((conn == NULL) || (fmt == NULL)) {; 4370 return -2;; 4371 }; 4372 ; 4373 /* Set status (for log) */; 4374 conn->status_code = status;; 4375 ; 4376 /* Errors 1xx, 204 and 304 MUST NOT send a body */; 4377 has_body = ((status > 199) && (status != 204) && (status != 304));; 4378 ; 4379 /* Prepare message in buf, if required */; 4380 if (has_body; 4381 || (!conn->in_error_handler; 4382 && (conn->phys_ctx->callbacks.http_error != NULL))) {; 4383 /* Store error message in errmsg_buf */; 4384 va_copy(ap, args);; 4385 mg_vsnprintf(conn, NULL, errmsg_buf, sizeof(errmsg_buf), fmt, ap);; 4386 va_end(ap);; 4387 /* In a debug build, print all html errors */; 4388 DEBUG_TRACE(""Error %i - [%s]"", status, errmsg_buf);; 4389 }; 4390 ; 4391 /* If there is a http_error callback, call it.; 4392 * But don't do it recursively, if callback calls mg_send_http_error again.; 4393 */; 4394 if (!conn->in_error_handler; 4395 && (conn->phys_ctx->callbacks.http_error != NULL)) {; 4396 /* Mark in_error_handler to avoid recursion and call user callback. */; 4397 conn->in_error_handler = 1;; 4398 handled_by_callback =; 4399 (conn->phys_ctx->callbacks.http_error(conn, status, errmsg_buf); 4400 == 0);; 4401 conn->in_error_handler = 0;; 4402 }; 4403 ; 4404 if (!handled_by_callback) {; 4405 /* Check for recursion */; 4406 if (conn->in_error_handler) {; 4407 DEBUG_TRACE(; 4408 ""Recursion when handling error %u - fall back to default"",; 4409 status);; 4410#if !defined(NO_FILESYSTEMS); 4411 } else {; 4412 /* Send user defined error pages, if defined */; 4413 error_handler = conn->dom_ctx->config[ERROR_PAGES];; 4414 error_page_file_ext = conn->dom_ctx->config[INDEX_FILES];; 4415 page_handler_found = 0;; 4416 ; 4417 if (error_handler != NULL) {; 4418 for (scope = 1; (scope <= 3) && !page_handler_found; scope++) {; 4419 switch (scope) {; 4420 case 1: /* Handler for specific error, e.g. 404 error */; 4421 mg_snprintf(conn,; 4422 &truncated,; 4423 path_buf,; 4424 sizeof(path_buf) - 32,; 4425 ""%serro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:131441,avoid,avoid,131441,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['avoid'],['avoid']
Safety,"8.h. â—†Â GetH1(). Double_t TGeoTrap::GetH1 ; (; ); const. inline . Definition at line 132 of file TGeoArb8.h. â—†Â GetH2(). Double_t TGeoTrap::GetH2 ; (; ); const. inline . Definition at line 136 of file TGeoArb8.h. â—†Â GetMakeRuntimeShape(). TGeoShape * TGeoTrap::GetMakeRuntimeShape ; (; TGeoShape *Â ; mother, . TGeoMatrix *Â ; matÂ . ); const. overridevirtual . Reimplemented from TGeoArb8. â—†Â GetPhi(). Double_t TGeoTrap::GetPhi ; (; ); const. inline . Definition at line 131 of file TGeoArb8.h. â—†Â GetTheta(). Double_t TGeoTrap::GetTheta ; (; ); const. inline . Definition at line 130 of file TGeoArb8.h. â—†Â GetTl1(). Double_t TGeoTrap::GetTl1 ; (; ); const. inline . Definition at line 134 of file TGeoArb8.h. â—†Â GetTl2(). Double_t TGeoTrap::GetTl2 ; (; ); const. inline . Definition at line 138 of file TGeoArb8.h. â—†Â IsA(). TClass * TGeoTrap::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoArb8.; Definition at line 146 of file TGeoArb8.h. â—†Â Safety(). Double_t TGeoTrap::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Reimplemented from TGeoArb8. â—†Â Safety_v(). void TGeoTrap::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoArb8. â—†Â SavePrimitive(). void TGeoTrap::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoArb8. â—†Â SetDimensions(). void TGeoTrap::SetDimensions ; (; Double_t *Â ; param). overridevirtual . Reimplemented from TGeoArb8. â—†Â Streamer(). void TGeoTrap::Streamer ; (; TBuffer &Â ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGeoArb8. â—†Â StreamerNVirtual(). void TGeoTrap::StreamerNVirtual ; (; TBuffer &Â ; ClassDef_StreamerNVirtual_b). inline . Definition at line 146 of file TGeoArb8.h. Member Data Documenta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrap.html:29118,Safe,Safety,29118,doc/master/classTGeoTrap.html,https://root.cern,https://root.cern/doc/master/classTGeoTrap.html,1,['Safe'],['Safety']
Safety,"80 ""Trying to read an emulated class (%s) to store in a compiled pointer (%s)"",; 1081 cl->GetName(),expectedClass->GetName());; 1082 }; 1083 }; 1084 // Create an instance of this class; 1085 ; 1086 void *pobj = cl->New();; 1087 if (!pobj) {; 1088 Error(""ReadObjectAny"", ""Cannot create new object of class %s"", fClassName.Data());; 1089 return 0;; 1090 }; 1091 ; 1092 if (kvers > 1); 1093 bufferRef.MapObject(pobj,cl); //register obj in map to handle self reference; 1094 ; 1095 if (fObjlen > fNbytes-fKeylen) {; 1096 char *objbuf = bufferRef.Buffer() + fKeylen;; 1097 UChar_t *bufcur = (UChar_t *)&compressedBuffer[fKeylen];; 1098 Int_t nin, nout = 0, nbuf;; 1099 Int_t noutot = 0;; 1100 while (1) {; 1101 Int_t hc = R__unzip_header(&nin, bufcur, &nbuf);; 1102 if (hc!=0) break;; 1103 R__unzip(&nin, bufcur, &nbuf, (unsigned char*) objbuf, &nout);; 1104 if (!nout) break;; 1105 noutot += nout;; 1106 if (noutot >= fObjlen) break;; 1107 bufcur += nin;; 1108 objbuf += nout;; 1109 }; 1110 if (nout) {; 1111 cl->Streamer((void*)pobj, bufferRef, clOnfile); //read object; 1112 } else {; 1113 cl->Destructor(pobj);; 1114 return nullptr;; 1115 }; 1116 } else {; 1117 cl->Streamer((void*)pobj, bufferRef, clOnfile); //read object; 1118 }; 1119 ; 1120 if (cl->IsTObject()) {; 1121 auto tobjBaseOffset = cl->GetBaseClassOffset(TObject::Class());; 1122 if (tobjBaseOffset == -1) {; 1123 Fatal(""ReadObj"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 1124 fClassName.Data());; 1125 }; 1126 TObject *tobj = (TObject*)( ((char*)pobj) + tobjBaseOffset);; 1127 ; 1128 // See similar adjustments in ReadObj; 1129 if (gROOT->GetForceStyle()) tobj->UseCurrentStyle();; 1130 ; 1131 if (cl->InheritsFrom(TDirectoryFile::Class())) {; 1132 TDirectory *dir = static_cast<TDirectoryFile*>(tobj);; 1133 dir->SetName(GetName());; 1134 dir->SetTitle(GetTitle());; 1135 dir->SetMother(fMotherDir);; 1136 fMotherDir->Append(dir);; 1137 }; 1138 }; 1139 ; 1140 {; 1141 // Append the object to the directory ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:40323,detect,detection,40323,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,1,['detect'],['detection']
Safety,"8048 - ShortTypes doesnâ€™t always strip default stdlib template args; ROOT-8055 - File corruption after TTree deletion; ROOT-8066 - problems creating dictionaries in pyROOT; ROOT-8067 - Source code tree left â€œpollutedâ€ with â€œinterpreter/llvm/src/utils/llvm-build/llvmbuild/*.pyc; ROOT-8068 - Fix file flags for bin/setxrd.* bin/thisroot.*; ROOT-8097 - null pointer dereference in TProtoClass::FillTClass with gcc6 build; ROOT-8117 - Particle in TPDGCode.h but not in TDatabasePDG; ROOT-8145 - TMethodCall::InitWithPrototype keeps accumulating memory on successive calls; ROOT-8149 - Memory leak in TList I/O. Release 6.06/06; Released on July 6, 2016; Cling. Properly handle try-catch functions. ROOT-8034; Fix handling of template parameter pack in the forward declaration printer. ROOT-8096. Core. Fix the validity of TRef after the first ProcessID is full.; Fix thread safety of TSystem::ExpandPathName ROOT-8205. Dictionaries. Do not autoparse headers for classes in the pch.; Avoid autoparse on IsForeign() if possible.; Check for new-style empty pcm with key named â€œEMPTYâ€ created since commit 90047b0cba6fd295f5c5722749a0d043fbc11ea5.; Do not insert macro definition of ROOTCLING into the pch. TTree. Properly handle the last element of arrays in the TTreeFormula functions MinIf and MaxIf ROOT-7258; Fix detection of errors that appears in nested TTreeFormula ROOT-8218; Avoid autoparse looking for default constructor in TTreeCloner::CopyStreamerInfos(). Bugs fixed in this release. [ROOT-6753] - PROOF-Lite doesnâ€™t find TSelector type from an already loaded library; [ROOT-7258] - MinIf and MaxIf TTreeFormula functions ignore last element; [ROOT-8038] - [patch] â€œfor e in getSTLLikeCollection()â€ crashes pyroot; [ROOT-8166] - Update INSTALL to reflect CMake; [ROOT-8184] - Error building XrdSysPthread with GCC 6.1; [ROOT-8197] - rootcp not preserving kSingleKey; [ROOT-8205] - TSystem::ExpandPathName is not thread safe; [ROOT-8207] - tmva/tmva/CMakeLists.txt unnecessarily includes TreeVie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:31301,Avoid,Avoid,31301,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['Avoid'],['Avoid']
Safety,"81 if (!gSystem->GetPathInfo(cachetagfile, &id, &size, &flags, &modtime)) {; 4682 // check the time passed since last cache cleanup; 4683 Long_t lastcleanuptime = ((Long_t)time(0) - modtime);; 4684 if (lastcleanuptime < cleanupinterval) {; 4685 ::Info(""TFile::ShrinkCacheFileDir"", ""clean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:171936,safe,safety,171936,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['safe'],['safety']
Safety,"81#include ""TClass.h""; 82#include ""TInterpreter.h""; 83 ; 84ClassImp(TSelector);; 85 ; 86////////////////////////////////////////////////////////////////////////////////; 87/// Default selector ctor.; 88 ; 89TSelector::TSelector() : TObject(); 90{; 91 fStatus = 0;; 92 fAbort = kContinue;; 93 fObject = nullptr;; 94 fInput = nullptr;; 95 fOutput = new TSelectorList;; 96 fOutput->SetOwner();; 97}; 98 ; 99////////////////////////////////////////////////////////////////////////////////; 100/// Selector destructor.; 101 ; 102TSelector::~TSelector(); 103{; 104 delete fOutput;; 105}; 106 ; 107////////////////////////////////////////////////////////////////////////////////; 108/// Abort processing. If what = kAbortProcess, the Process() loop will be; 109/// aborted. If what = kAbortFile, the current file in a chain will be; 110/// aborted and the processing will continue with the next file, if there; 111/// is no next file then Process() will be aborted. Abort() can also be; 112/// called from Begin(), SlaveBegin(), Init() and Notify(). After abort; 113/// the SlaveTerminate() and Terminate() are always called. The abort flag; 114/// can be checked in these methods using GetAbort().; 115 ; 116void TSelector::Abort(const char *why, EAbort what); 117{; 118 fAbort = what;; 119 TString mess = ""Abort"";; 120 if (fAbort == kAbortProcess); 121 mess = ""AbortProcess"";; 122 else if (fAbort == kAbortFile); 123 mess = ""AbortFile"";; 124 ; 125 Info(mess, ""%s"", why);; 126}; 127 ; 128////////////////////////////////////////////////////////////////////////////////; 129/// The code in filename is loaded (interpreted or compiled, see below),; 130/// filename must contain a valid class implementation derived from TSelector.; 131///; 132/// If filename is of the form file.C, the file will be interpreted.; 133/// If filename is of the form file.C++, the file file.C will be compiled; 134/// and dynamically loaded. The corresponding binary file and shared; 135/// library will be deleted at the end of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:4612,Abort,Abort,4612,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,1,['Abort'],['Abort']
Safety,"823 // If the option ""->"" is given in the data member comment field; 4824 // it is assumed that the object exists before reading data in,; 4825 // so we create an object.; 4826 if (cle != TClonesArray::Class()) {; 4827 void** r = (void**) eaddr;; 4828 *r = cle->New();; 4829 } else {; 4830 // In the case of a TClonesArray, the class name of; 4831 // the contained objects must be specified in the; 4832 // data member comment in this format:; 4833 // TClonesArray* myVar; //->(className); 4834 const char* title = element->GetTitle();; 4835 const char* bracket1 = strrchr(title, '(');; 4836 const char* bracket2 = strrchr(title, ')');; 4837 if (bracket1 && bracket2 && (bracket2 != (bracket1 + 1))) {; 4838 Int_t len = bracket2 - (bracket1 + 1);; 4839 char* clonesClass = new char[len+1];; 4840 clonesClass[0] = '\0';; 4841 strncat(clonesClass, bracket1 + 1, len);; 4842 void** r = (void**) eaddr;; 4843 *r = (void*) new TClonesArray(clonesClass);; 4844 delete[] clonesClass;; 4845 } else {; 4846 //Warning(""New"", ""No class name found for TClonesArray initializer in data member comment (expected \""//->(className)\"""");; 4847 void** r = (void**) eaddr;; 4848 *r = (void*) new TClonesArray();; 4849 }; 4850 }; 4851 }; 4852 break;; 4853 ; 4854 case kBase:; 4855 {; 4856 if (cle->Property() & kIsAbstract) {; 4857 TVirtualStreamerInfo *einfo = cle->GetStreamerInfoAbstractEmulated();; 4858 if (einfo) einfo->New(eaddr);; 4859 } else {; 4860 cle->New(eaddr);; 4861 }; 4862 break;; 4863 }; 4864 case kObject:; 4865 case kAny:; 4866 case kTObject:; 4867 case kTString:; 4868 case kTNamed:; 4869 {; 4870 cle->New(eaddr);; 4871 }; 4872 break;; 4873 ; 4874 case kSTL:; 4875 {; 4876 if (strcmp(element->GetName(),""This"")==0 &&; 4877 !cle->GetCollectionProxy()) {; 4878 // missing information, avoid infinite loop; 4879 // by doing nothing ....; 4880 } else {; 4881 if (cle->GetCollectionProxy()); 4882 cle->GetCollectionProxy()->New(eaddr);; 4883 else; 4884 cle->New(eaddr);; 4885 }; 4886 }; 4887 break;; 4888 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:195490,avoid,avoid,195490,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['avoid'],['avoid']
Safety,"84 ; 5885 if (lfsr == 0) {; 5886 /* lfsr will be only 0 if has not been initialized,; 5887 * so this code is called only once. */; 5888 lfsr = mg_get_current_time_ns();; 5889 lcg = mg_get_current_time_ns();; 5890 } else {; 5891 /* Get the next step of both random number generators. */; 5892 lfsr = (lfsr >> 1); 5893 | ((((lfsr >> 0) ^ (lfsr >> 1) ^ (lfsr >> 3) ^ (lfsr >> 4)) & 1); 5894 << 63);; 5895 lcg = lcg * 6364136223846793005LL + 1442695040888963407LL;; 5896 }; 5897 ; 5898 /* Combining two pseudo-random number generators and a high resolution; 5899 * part; 5900 * of the current server time will make it hard (impossible?) to guess; 5901 * the; 5902 * next number. */; 5903 return (lfsr ^ lcg ^ now);; 5904}; 5905 ; 5906 ; 5907static int; 5908mg_poll(struct mg_pollfd *pfd,; 5909 unsigned int n,; 5910 int milliseconds,; 5911 const stop_flag_t *stop_flag); 5912{; 5913 /* Call poll, but only for a maximum time of a few seconds.; 5914 * This will allow to stop the server after some seconds, instead; 5915 * of having to wait for a long socket timeout. */; 5916 int ms_now = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5917 ; 5918 int check_pollerr = 0;; 5919 if ((n == 1) && ((pfd[0].events & POLLERR) == 0)) {; 5920 /* If we wait for only one file descriptor, wait on error as well */; 5921 pfd[0].events |= POLLERR;; 5922 check_pollerr = 1;; 5923 }; 5924 ; 5925 do {; 5926 int result;; 5927 ; 5928 if (!STOP_FLAG_IS_ZERO(&*stop_flag)) {; 5929 /* Shut down signal */; 5930 return -2;; 5931 }; 5932 ; 5933 if ((milliseconds >= 0) && (milliseconds < ms_now)) {; 5934 ms_now = milliseconds;; 5935 }; 5936 ; 5937 result = poll(pfd, n, ms_now);; 5938 if (result != 0) {; 5939 /* Poll returned either success (1) or error (-1).; 5940 * Forward both to the caller. */; 5941 if ((check_pollerr); 5942 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5943 == POLLERR)) {; 5944 /* One and only file descriptor returned error */; 5945 return -1;; 5946 }; 5947 return result;; 5948 }; 5949",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:173700,timeout,timeout,173700,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"85 ; 5886 if (lfsr == 0) {; 5887 /* lfsr will be only 0 if has not been initialized,; 5888 * so this code is called only once. */; 5889 lfsr = mg_get_current_time_ns();; 5890 lcg = mg_get_current_time_ns();; 5891 } else {; 5892 /* Get the next step of both random number generators. */; 5893 lfsr = (lfsr >> 1); 5894 | ((((lfsr >> 0) ^ (lfsr >> 1) ^ (lfsr >> 3) ^ (lfsr >> 4)) & 1); 5895 << 63);; 5896 lcg = lcg * 6364136223846793005LL + 1442695040888963407LL;; 5897 }; 5898 ; 5899 /* Combining two pseudo-random number generators and a high resolution; 5900 * part; 5901 * of the current server time will make it hard (impossible?) to guess; 5902 * the; 5903 * next number. */; 5904 return (lfsr ^ lcg ^ now);; 5905}; 5906 ; 5907 ; 5908static int; 5909mg_poll(struct mg_pollfd *pfd,; 5910 unsigned int n,; 5911 int milliseconds,; 5912 const stop_flag_t *stop_flag); 5913{; 5914 /* Call poll, but only for a maximum time of a few seconds.; 5915 * This will allow to stop the server after some seconds, instead; 5916 * of having to wait for a long socket timeout. */; 5917 int ms_now = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5918 ; 5919 int check_pollerr = 0;; 5920 if ((n == 1) && ((pfd[0].events & POLLERR) == 0)) {; 5921 /* If we wait for only one file descriptor, wait on error as well */; 5922 pfd[0].events |= POLLERR;; 5923 check_pollerr = 1;; 5924 }; 5925 ; 5926 do {; 5927 int result;; 5928 ; 5929 if (!STOP_FLAG_IS_ZERO(&*stop_flag)) {; 5930 /* Shut down signal */; 5931 return -2;; 5932 }; 5933 ; 5934 if ((milliseconds >= 0) && (milliseconds < ms_now)) {; 5935 ms_now = milliseconds;; 5936 }; 5937 ; 5938 result = poll(pfd, n, ms_now);; 5939 if (result != 0) {; 5940 /* Poll returned either success (1) or error (-1).; 5941 * Forward both to the caller. */; 5942 if ((check_pollerr); 5943 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5944 == POLLERR)) {; 5945 /* One and only file descriptor returned error */; 5946 return -1;; 5947 }; 5948 return result;; 5949 }; 5950",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:173732,timeout,timeout,173732,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"86 ; 1687#define RVEC_ASSIGNMENT_OPERATOR(OP) \; 1688template <typename T0, typename T1> \; 1689RVec<T0>& operator OP(RVec<T0> &v, const T1 &y) \; 1690{ \; 1691 auto op = [&y](T0 &x) { return x OP y; }; \; 1692 std::transform(v.begin(), v.end(), v.begin(), op); \; 1693 return v; \; 1694} \; 1695 \; 1696template <typename T0, typename T1> \; 1697RVec<T0>& operator OP(RVec<T0> &v0, const RVec<T1> &v1) \; 1698{ \; 1699 if (v0.size() != v1.size()) \; 1700 throw std::runtime_error(ERROR_MESSAGE(OP)); \; 1701 \; 1702 auto op = [](T0 &x, const T1 &y) { return x OP y; }; \; 1703 std::transform(v0.begin(), v0.end(), v1.begin(), v0.begin(), op); \; 1704 return v0; \; 1705} \; 1706 ; 1707RVEC_ASSIGNMENT_OPERATOR(+=); 1708RVEC_ASSIGNMENT_OPERATOR(-=); 1709RVEC_ASSIGNMENT_OPERATOR(*=); 1710RVEC_ASSIGNMENT_OPERATOR(/=); 1711RVEC_ASSIGNMENT_OPERATOR(%=); 1712RVEC_ASSIGNMENT_OPERATOR(^=); 1713RVEC_ASSIGNMENT_OPERATOR(|=); 1714RVEC_ASSIGNMENT_OPERATOR(&=); 1715RVEC_ASSIGNMENT_OPERATOR(>>=); 1716RVEC_ASSIGNMENT_OPERATOR(<<=); 1717#undef RVEC_ASSIGNMENT_OPERATOR; 1718 ; 1719///@}; 1720///@name RVec Comparison and Logical Operators; 1721///@{; 1722 ; 1723#define RVEC_LOGICAL_OPERATOR(OP) \; 1724template <typename T0, typename T1> \; 1725auto operator OP(const RVec<T0> &v, const T1 &y) \; 1726 -> RVec<int> /* avoid std::vector<bool> */ \; 1727{ \; 1728 RVec<int> ret(v.size()); \; 1729 auto op = [y](const T0 &x) -> int { return x OP y; }; \; 1730 std::transform(v.begin(), v.end(), ret.begin(), op); \; 1731 return ret; \; 1732} \; 1733 \; 1734template <typename T0, typename T1> \; 1735auto operator OP(const T0 &x, const RVec<T1> &v) \; 1736 -> RVec<int> /* avoid std::vector<bool> */ \; 1737{ \; 1738 RVec<int> ret(v.size()); \; 1739 auto op = [x](const T1 &y) -> int { return x OP y; }; \; 1740 std::transform(v.begin(), v.end(), ret.begin(), op); \; 1741 return ret; \; 1742} \; 1743 \; 1744template <typename T0, typename T1> \; 1745auto operator OP(const RVec<T0> &v0, const RVec<T1> &v1) \;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:60506,avoid,avoid,60506,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['avoid'],['avoid']
Safety,"87 fBuffer = 0;; 788 return 0;; 789 }; 790 memcpy(bufferRef.Buffer(),fBuffer,fKeylen);; 791 } else {; 792 fBuffer = bufferRef.Buffer();; 793 if( !ReadFile() ) { //Read object structure from file; 794 ; 795 fBuffer = 0;; 796 return 0;; 797 }; 798 }; 799 fBuffer = storeBuffer;; 800 ; 801 // get version of key; 802 bufferRef.SetBufferOffset(sizeof(fNbytes));; 803 Version_t kvers = bufferRef.ReadVersion();; 804 ; 805 bufferRef.SetBufferOffset(fKeylen);; 806 TObject *tobj = 0;; 807 // Create an instance of this class; 808 ; 809 char *pobj = (char*)cl->New();; 810 if (!pobj) {; 811 Error(""ReadObj"", ""Cannot create new object of class %s"", fClassName.Data());; 812 return 0;; 813 }; 814 Int_t baseOffset = cl->GetBaseClassOffset(TObject::Class());; 815 if (baseOffset==-1) {; 816 // cl does not inherit from TObject.; 817 // Since this is not possible yet, the only reason we could reach this code; 818 // is because something is screw up in the ROOT code.; 819 Fatal(""ReadObj"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 820 fClassName.Data());; 821 }; 822 tobj = (TObject*)(pobj+baseOffset);; 823 if (kvers > 1); 824 bufferRef.MapObject(pobj,cl); //register obj in map to handle self reference; 825 ; 826 if (fObjlen > fNbytes-fKeylen) {; 827 char *objbuf = bufferRef.Buffer() + fKeylen;; 828 UChar_t *bufcur = (UChar_t *)&compressedBuffer[fKeylen];; 829 Int_t nin, nout = 0, nbuf;; 830 Int_t noutot = 0;; 831 while (1) {; 832 Int_t hc = R__unzip_header(&nin, bufcur, &nbuf);; 833 if (hc!=0) break;; 834 R__unzip(&nin, bufcur, &nbuf, (unsigned char*) objbuf, &nout);; 835 if (!nout) break;; 836 noutot += nout;; 837 if (noutot >= fObjlen) break;; 838 bufcur += nin;; 839 objbuf += nout;; 840 }; 841 compressedBuffer.reset(nullptr);; 842 if (nout) {; 843 tobj->Streamer(bufferRef); //does not work with example 2 above; 844 } else {; 845 // Even-though we have a TObject, if the class is emulated the virtual; 846 // table may not be 'right', so let's go via the TClass.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:29218,detect,detection,29218,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,1,['detect'],['detection']
Safety,"87void TBuffer::SetBuffer(void *buf, UInt_t newsiz, Bool_t adopt, ReAllocCharFun_t reallocfunc); 188{; 189 if (fBuffer && TestBit(kIsOwner)); 190 delete [] fBuffer;; 191 ; 192 if (adopt); 193 SetBit(kIsOwner);; 194 else; 195 ResetBit(kIsOwner);; 196 ; 197 fBuffer = (char *)buf;; 198 fBufCur = fBuffer;; 199 if (newsiz > 0) {; 200 if ( (fMode&kWrite)!=0 ) {; 201 fBufSize = newsiz - kExtraSpace;; 202 } else {; 203 fBufSize = newsiz;; 204 }; 205 }; 206 fBufMax = fBuffer + fBufSize;; 207 ; 208 SetReAllocFunc( reallocfunc );; 209 ; 210 if (buf && ( (fMode&kWrite)!=0 ) && fBufSize < 0) {; 211 Expand( kMinimalSize );; 212 }; 213}; 214 ; 215////////////////////////////////////////////////////////////////////////////////; 216/// Expand (or shrink) the I/O buffer to newsize bytes.; 217/// If copy is true (the default), the existing content of the; 218/// buffer is preserved, otherwise the buffer is returned zero-ed out.; 219///; 220/// In order to avoid losing data, if the current length is greater than; 221/// the requested size, we only shrink down to the current length.; 222 ; 223void TBuffer::Expand(Int_t newsize, Bool_t copy); 224{; 225 Int_t l = Length();; 226 if ( (l > newsize) && copy ) {; 227 newsize = l;; 228 }; 229 const Int_t extraspace = (fMode&kWrite)!=0 ? kExtraSpace : 0;; 230 ; 231 if ( ((Long64_t)newsize+extraspace) > kMaxBufferSize) {; 232 if (l < kMaxBufferSize) {; 233 newsize = kMaxBufferSize - extraspace;; 234 } else {; 235 Fatal(""Expand"",""Requested size (%d) is too large (max is %d)."", newsize, kMaxBufferSize);; 236 }; 237 }; 238 if ( (fMode&kWrite)!=0 ) {; 239 fBuffer = fReAllocFunc(fBuffer, newsize+kExtraSpace,; 240 copy ? fBufSize+kExtraSpace : 0);; 241 } else {; 242 fBuffer = fReAllocFunc(fBuffer, newsize,; 243 copy ? fBufSize : 0);; 244 }; 245 if (fBuffer == nullptr) {; 246 if (fReAllocFunc == TStorage::ReAllocChar) {; 247 Fatal(""Expand"",""Failed to expand the data buffer using TStorage::ReAllocChar."");; 248 } else if (fReAllocFunc == R__NoReAllocChar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8cxx_source.html:7468,avoid,avoid,7468,doc/master/TBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html,1,['avoid'],['avoid']
Safety,"89 * <tr><td> `Hesse(bool flag)` <td> Flag controls if HESSE is run after MIGRAD, on by default; 990 * <tr><td> `Minos(bool flag)` <td> Flag controls if MINOS is run after HESSE, off by default; 991 * <tr><td> `Minos(const RooArgSet& set)` <td> Only run MINOS on given subset of arguments; 992 * <tr><td> `Save(bool flag)` <td> Flag controls if RooFitResult object is produced and returned, off by default; 993 * <tr><td> `Strategy(Int_t flag)` <td> Set Minuit strategy (0 to 2, default is 1); 994 * <tr><td> `MaxCalls(int n)` <td> Change maximum number of likelihood function calls from MINUIT (if `n <= 0`, the default of 500 * #%parameters is used); 995 * <tr><td> `EvalErrorWall(bool flag=true)` <td> When parameters are in disallowed regions (e.g. PDF is negative), return very high value to fitter; 996 * to force it out of that region. This can, however, mean that the fitter gets lost in this region. If; 997 * this happens, try switching it off.; 998 * <tr><td> `RecoverFromUndefinedRegions(double strength)` <td> When PDF is invalid (e.g. parameter in undefined region), try to direct minimiser away from that region.; 999 * `strength` controls the magnitude of the penalty term. Leaving out this argument defaults to 10. Switch off with `strength = 0.`.; 1000 *; 1001 * <tr><td> `SumW2Error(bool flag)` <td> Apply correction to errors and covariance matrix.; 1002 * This uses two covariance matrices, one with the weights, the other with squared weights,; 1003 * to obtain the correct errors for weighted likelihood fits. If this option is activated, the; 1004 * corrected covariance matrix is calculated as \f$ V_\mathrm{corr} = V C^{-1} V \f$, where \f$ V \f$ is the original; 1005 * covariance matrix and \f$ C \f$ is the inverse of the covariance matrix calculated using the; 1006 * squared weights. This allows to switch between two interpretations of errors:; 1007 * <table>; 1008 * <tr><th> SumW2Error <th> Interpretation; 1009 * <tr><td> true <td> The errors reflect the uncertaint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:46928,Recover,RecoverFromUndefinedRegions,46928,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['Recover'],['RecoverFromUndefinedRegions']
Safety,"9 /* Print first entry - link to a parent directory */; 9700 mg_printf(conn,; 9701 ""<tr><td><a href=\""%s\"">%s</a></td>""; 9702 ""<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\n"",; 9703 "".."",; 9704 ""Parent directory"",; 9705 ""-"",; 9706 ""-"");; 9707 ; 9708 /* Sort and print directory entries */; 9709 if (data.entries != NULL) {; 9710 qsort(data.entries,; 9711 data.num_entries,; 9712 sizeof(data.entries[0]),; 9713 compare_dir_entries);; 9714 for (i = 0; i < data.num_entries; i++) {; 9715 print_dir_entry(&data.entries[i]);; 9716 mg_free(data.entries[i].file_name);; 9717 }; 9718 mg_free(data.entries);; 9719 }; 9720 ; 9721 mg_printf(conn, ""%s"", ""</table></pre></body></html>"");; 9722 conn->status_code = 200;; 9723}; 9724#endif /* NO_FILESYSTEMS */; 9725 ; 9726 ; 9727/* Send len bytes from the opened file to the client. */; 9728static void; 9729send_file_data(struct mg_connection *conn,; 9730 struct mg_file *filep,; 9731 int64_t offset,; 9732 int64_t len); 9733{; 9734 char buf[MG_BUF_LEN];; 9735 int to_read, num_read, num_written;; 9736 int64_t size;; 9737 ; 9738 if (!filep || !conn) {; 9739 return;; 9740 }; 9741 ; 9742 /* Sanity check the offset */; 9743 size = (filep->stat.size > INT64_MAX) ? INT64_MAX; 9744 : (int64_t)(filep->stat.size);; 9745 offset = (offset < 0) ? 0 : ((offset > size) ? size : offset);; 9746 ; 9747 if (len > 0 && filep->access.fp != NULL) {; 9748 /* file stored on disk */; 9749#if defined(__linux__); 9750 /* sendfile is only available for Linux */; 9751 if ((conn->ssl == 0) && (conn->throttle == 0); 9752 && (!mg_strcasecmp(conn->dom_ctx->config[ALLOW_SENDFILE_CALL],; 9753 ""yes""))) {; 9754 off_t sf_offs = (off_t)offset;; 9755 ssize_t sf_sent;; 9756 int sf_file = fileno(filep->access.fp);; 9757 int loop_cnt = 0;; 9758 ; 9759 do {; 9760 /* 2147479552 (0x7FFFF000) is a limit found by experiment on; 9761 * 64 bit Linux (2^31 minus one memory page of 4k?). */; 9762 size_t sf_tosend =; 9763 (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);; 9764 sf_sent =; 9765 se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:278854,Sanity check,Sanity check,278854,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['Sanity check'],['Sanity check']
Safety,"9 ; 1760 first = 1;; 1761 last = npoints;; 1762 nbins = last - first + 1;; 1763 ; 1764 // Draw the Axis with a fixed number of division: 510; 1765 ; 1766 Double_t baroffset = gStyle->GetBarOffset();; 1767 Double_t barwidth = gStyle->GetBarWidth();; 1768 Double_t rwxmin = gPad->GetUxmin();; 1769 Double_t rwxmax = gPad->GetUxmax();; 1770 Double_t rwymin = gPad->GetUymin();; 1771 Double_t rwymax = gPad->GetUymax();; 1772 Double_t uxmin = gPad->PadtoX(rwxmin);; 1773 Double_t uxmax = gPad->PadtoX(rwxmax);; 1774 Double_t rounding = (uxmax-uxmin)*1.e-5;; 1775 drawborder = gStyle->GetDrawBorder();; 1776 if (optionAxis) {; 1777 Int_t nx1, nx2, ndivx, ndivy, ndiv;; 1778 choptaxis[0] = 0;; 1779 Double_t rwmin = rwxmin;; 1780 Double_t rwmax = rwxmax;; 1781 ndivx = gStyle->GetNdivisions(""X"");; 1782 ndivy = gStyle->GetNdivisions(""Y"");; 1783 if (ndivx > 1000) {; 1784 nx2 = ndivx/100;; 1785 nx1 = TMath::Max(1, ndivx%100);; 1786 ndivx = 100*nx2 + Int_t(Double_t(nx1)*gPad->GetAbsWNDC());; 1787 }; 1788 ndiv =TMath::Abs(ndivx);; 1789 // coverity [Calling risky function]; 1790 if (ndivx < 0) strlcat(choptaxis, ""N"",10);; 1791 if (gPad->GetGridx()) {; 1792 // coverity [Calling risky function]; 1793 strlcat(choptaxis, ""W"",10);; 1794 }; 1795 if (gPad->GetLogx()) {; 1796 rwmin = TMath::Power(10,rwxmin);; 1797 rwmax = TMath::Power(10,rwxmax);; 1798 // coverity [Calling risky function]; 1799 strlcat(choptaxis, ""G"",10);; 1800 }; 1801 TGaxis axis;; 1802 axis.SetLineColor(gStyle->GetAxisColor(""X""));; 1803 axis.SetTextColor(gStyle->GetLabelColor(""X""));; 1804 axis.SetTextFont(gStyle->GetLabelFont(""X""));; 1805 axis.SetLabelSize(gStyle->GetLabelSize(""X""));; 1806 axis.SetLabelOffset(gStyle->GetLabelOffset(""X""));; 1807 axis.SetTickSize(gStyle->GetTickLength(""X""));; 1808 ; 1809 axis.PaintAxis(rwxmin,rwymin,rwxmax,rwymin,rwmin,rwmax,ndiv,choptaxis);; 1810 ; 1811 choptaxis[0] = 0;; 1812 rwmin = rwymin;; 1813 rwmax = rwymax;; 1814 if (ndivy < 0) {; 1815 nx2 = ndivy/100;; 1816 nx1 = TMath::Max(1, ndivy%100);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:66132,risk,risky,66132,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,3,['risk'],['risky']
Safety,"9 TString wd = AsString();; 90 int day;; 91 for (day = 0; day < 7; day++) {; 92 if (wd(0, 3) == weekDays[day]); 93 break;; 94 }; 95 return (day < 7) ? day+1: -1;; 96}; 97 ; 98////////////////////////////////////////////////////////////////////////////////; 99/// Return the date & time as a string (ctime() format).; 100/// Copy result because it points to a statically allocated string.; 101 ; 102const char *TDatime::AsString() const; 103{; 104 time_t t = Convert();; 105 char *retStr = ctime(&t);; 106 if (retStr) {; 107 *(retStr + 24) = 0;; 108 return retStr;; 109 } else {; 110 static const char *defaulttime = ""15/06/96"";; 111 Error(""TDatime::AsString"", ""could not get time string"");; 112 return defaulttime;; 113 }; 114}; 115 ; 116////////////////////////////////////////////////////////////////////////////////; 117/// Return the date & time as a string (ctime() format).; 118/// Result is copied into out (and out is returned). Make sure; 119/// out can at least contain 26 characters. Thread safe.; 120 ; 121const char *TDatime::AsString(char *out) const; 122{; 123 time_t t = Convert();; 124#ifndef WIN32; 125#if defined(R__SOLARIS) && (_POSIX_C_SOURCE - 0 < 199506L); 126 char *retStr = ctime_r(&t, out, 26);; 127#else; 128 char *retStr = ctime_r(&t, out);; 129#endif; 130#else; 131 char *retStr = ctime(&t);; 132#endif; 133 if (retStr) {; 134 *(retStr + 24) = 0;; 135#ifdef WIN32; 136 strcpy(out, retStr);; 137#endif; 138 return retStr;; 139 } else {; 140 static const char *defaulttime = ""15/06/96"";; 141 strcpy(out, defaulttime);; 142 Error(""TDatime::AsString"", ""could not get time string"");; 143 return defaulttime;; 144 }; 145}; 146 ; 147////////////////////////////////////////////////////////////////////////////////; 148/// Return the date & time in SQL compatible string format, like:; 149/// 1997-01-15 20:16:28. The returned string buffer is static and; 150/// will be reused.; 151 ; 152const char *TDatime::AsSQLString() const; 153{; 154 static char sqldate[20];; 155 ; 156 UIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDatime_8cxx_source.html:4004,safe,safe,4004,doc/master/TDatime_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDatime_8cxx_source.html,1,['safe'],['safe']
Safety,"9 of file RooAbsCollection.cxx. â—†Â IsA(). TClass * RooAbsCollection::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in RooArgList, RooArgSet, RooCollectionProxy< RooArgList >, and RooCollectionProxy< RooArgSet >.; Definition at line 432 of file RooAbsCollection.h. â—†Â isOwning(). bool RooAbsCollection::isOwning ; (; ); const. inline . Definition at line 346 of file RooAbsCollection.h. â—†Â makeStructureTag(). void RooAbsCollection::makeStructureTag ; (; ). inlineprotected . Definition at line 394 of file RooAbsCollection.h. â—†Â makeTypedStructureTag(). void RooAbsCollection::makeTypedStructureTag ; (; ). inlineprotected . Definition at line 395 of file RooAbsCollection.h. â—†Â operator=(). RooAbsCollection & RooAbsCollection::operator= ; (; const RooAbsCollection &Â ; other). Assign values from the elements in other to our elements. ; WarningThis is not a conventional assignment operator. To avoid confusion, prefer using RooAbsCollection::assign(). ; Definition at line 270 of file RooAbsCollection.cxx. â—†Â operator[](). RooAbsArg * RooAbsCollection::operator[] ; (; Storage_t::size_typeÂ ; i); const. inline . Definition at line 297 of file RooAbsCollection.h. â—†Â overlaps() [1/2]. bool RooAbsCollection::overlaps ; (; const RooAbsCollection &Â ; otherColl); const. inline . Check if this and other collection have common entries. ; Definition at line 249 of file RooAbsCollection.h. â—†Â overlaps() [2/2]. template<typename Iterator_t , typename value_type = typename std::remove_pointer<typename std::iterator_traits<Iterator_t>::value_type>, typename = std::enable_if<std::is_convertible<const value_type*, const RooAbsArg*>::value>> . bool RooAbsCollection::overlaps ; (; Iterator_tÂ ; otherCollBegin, . Iterator_tÂ ; otherCollEndÂ . ); const. inline . Definition at line 238 of file RooAbsCollection.h. â—†Â Print(). void RooAbsCollection::Print ; (; Option_t *Â ; option = nullptr); const. inlineoverridevirtual . This method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCollection.html:45083,avoid,avoid,45083,doc/master/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/master/classRooAbsCollection.html,1,['avoid'],['avoid']
Safety,"9 va_list ap;; 3470 va_start(ap, fmt);; 3471 mg_cry_internal_impl(conn, ""user"", 0, fmt, ap);; 3472 va_end(ap);; 3473}; 3474 ; 3475 ; 3476#define mg_cry DO_NOT_USE_THIS_FUNCTION__USE_mg_cry_internal; 3477 ; 3478 ; 3479const char *; 3480mg_version(void); 3481{; 3482 return CIVETWEB_VERSION;; 3483}; 3484 ; 3485 ; 3486const struct mg_request_info *; 3487mg_get_request_info(const struct mg_connection *conn); 3488{; 3489 if (!conn) {; 3490 return NULL;; 3491 }; 3492#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE); 3493 if (conn->connection_type == CONNECTION_TYPE_RESPONSE) {; 3494 char txt[16];; 3495 struct mg_workerTLS *tls =; 3496 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 3497 ; 3498 sprintf(txt, ""%03i"", conn->response_info.status_code);; 3499 if (strlen(txt) == 3) {; 3500 memcpy(tls->txtbuf, txt, 4);; 3501 } else {; 3502 strcpy(tls->txtbuf, ""ERR"");; 3503 }; 3504 ; 3505 ((struct mg_connection *)conn)->request_info.local_uri =; 3506 tls->txtbuf; /* use thread safe buffer */; 3507 ((struct mg_connection *)conn)->request_info.local_uri_raw =; 3508 tls->txtbuf; /* use the same thread safe buffer */; 3509 ((struct mg_connection *)conn)->request_info.request_uri =; 3510 tls->txtbuf; /* use the same thread safe buffer */; 3511 ; 3512 ((struct mg_connection *)conn)->request_info.num_headers =; 3513 conn->response_info.num_headers;; 3514 memcpy(((struct mg_connection *)conn)->request_info.http_headers,; 3515 conn->response_info.http_headers,; 3516 sizeof(conn->response_info.http_headers));; 3517 } else; 3518#endif; 3519 if (conn->connection_type != CONNECTION_TYPE_REQUEST) {; 3520 return NULL;; 3521 }; 3522 return &conn->request_info;; 3523}; 3524 ; 3525 ; 3526const struct mg_response_info *; 3527mg_get_response_info(const struct mg_connection *conn); 3528{; 3529 if (!conn) {; 3530 return NULL;; 3531 }; 3532 if (conn->connection_type != CONNECTION_TYPE_RESPONSE) {; 3533 return NULL;; 3534 }; 3535 return &conn->response_info;; 3536}; 3537 ; 3538 ; 3539static c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:104100,safe,safe,104100,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['safe'],['safe']
Safety,"92 of file TDavixSystem.cxx. â—†Â GetDirEntry(). const char * TDavixSystem::GetDirEntry ; (; void *Â ; dirp). virtual . Get a directory entry. Returns 0 if no more entries. ; Reimplemented from TSystem.; Definition at line 100 of file TDavixSystem.cxx. â—†Â GetPathInfo(). Int_t TDavixSystem::GetPathInfo ; (; const char *Â ; path, . FileStat_t &Â ; bufÂ . ). virtual . Get info about a file. ; Info is returned in the form of a FileStat_t structure (see TSystem.h). The function returns 0 in case of success and 1 if the file could not be stat'ed. ; Reimplemented from TSystem.; Definition at line 138 of file TDavixSystem.cxx. â—†Â IsA(). virtual TClass * TDavixSystem::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 57 of file TDavixSystem.h. â—†Â IsPathLocal(). Bool_t TDavixSystem::IsPathLocal ; (; const char *Â ; path). virtual . Returns TRUE if the url in 'path' points to the local file system. ; This is used to avoid going through the NIC card for local operations. ; Reimplemented from TSystem.; Definition at line 159 of file TDavixSystem.cxx. â—†Â Locate(). Int_t TDavixSystem::Locate ; (; const char *Â ; path, . TString &Â ; endurlÂ . ). virtual . Definition at line 167 of file TDavixSystem.cxx. â—†Â MakeDirectory(). Int_t TDavixSystem::MakeDirectory ; (; const char *Â ; name). virtual . Make a directory. ; Returns 0 in case of success and -1 if the directory could not be created (either already exists or illegal path name). ; Reimplemented from TSystem.; Definition at line 194 of file TDavixSystem.cxx. â—†Â OpenDirectory(). void * TDavixSystem::OpenDirectory ; (; const char *Â ; name). virtual . Open a directory. Returns 0 if directory does not exist. ; Reimplemented from TSystem.; Definition at line 115 of file TDavixSystem.cxx. â—†Â Streamer(). virtual void TDavixSystem::Streamer ; (; TBuffer &Â ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TObject. â—†Â StreamerNVirtual(). void TDavixSystem::Strea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixSystem.html:35935,avoid,avoid,35935,doc/master/classTDavixSystem.html,https://root.cern,https://root.cern/doc/master/classTDavixSystem.html,1,['avoid'],['avoid']
Safety,"928 ; 16929 ; 16930static int; 16931set_tcp_nodelay(const struct socket *so, int nodelay_on); 16932{; 16933 if ((so->lsa.sa.sa_family == AF_INET); 16934 || (so->lsa.sa.sa_family == AF_INET6)) {; 16935 /* Only for TCP sockets */; 16936 if (setsockopt(so->sock,; 16937 IPPROTO_TCP,; 16938 TCP_NODELAY,; 16939 (SOCK_OPT_TYPE)&nodelay_on,; 16940 sizeof(nodelay_on)); 16941 != 0) {; 16942 /* Error */; 16943 return 1;; 16944 }; 16945 }; 16946 /* OK */; 16947 return 0;; 16948}; 16949 ; 16950 ; 16951#if !defined(__ZEPHYR__); 16952static void; 16953close_socket_gracefully(struct mg_connection *conn); 16954{; 16955#if defined(_WIN32); 16956 char buf[MG_BUF_LEN];; 16957 int n;; 16958#endif; 16959 struct linger linger;; 16960 int error_code = 0;; 16961 int linger_timeout = -2;; 16962 socklen_t opt_len = sizeof(error_code);; 16963 ; 16964 if (!conn) {; 16965 return;; 16966 }; 16967 ; 16968 /* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:; 16969 * ""Note that enabling a nonzero timeout on a nonblocking socket; 16970 * is not recommended."", so set it to blocking now */; 16971 set_blocking_mode(conn->client.sock);; 16972 ; 16973 /* Send FIN to the client */; 16974 shutdown(conn->client.sock, SHUTDOWN_WR);; 16975 ; 16976 ; 16977#if defined(_WIN32); 16978 /* Read and discard pending incoming data. If we do not do that and; 16979 * close; 16980 * the socket, the data in the send buffer may be discarded. This; 16981 * behaviour is seen on Windows, when client keeps sending data; 16982 * when server decides to close the connection; then when client; 16983 * does recv() it gets no data back. */; 16984 do {; 16985 n = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);; 16986 } while (n > 0);; 16987#endif; 16988 ; 16989 if (conn->dom_ctx->config[LINGER_TIMEOUT]) {; 16990 linger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);; 16991 }; 16992 ; 16993 /* Set linger option according to configuration */; 16994 if (linger_timeout >= 0) {; 16995 /* Set linger o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:503660,timeout,timeout,503660,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"929 ; 16930 ; 16931static int; 16932set_tcp_nodelay(const struct socket *so, int nodelay_on); 16933{; 16934 if ((so->lsa.sa.sa_family == AF_INET); 16935 || (so->lsa.sa.sa_family == AF_INET6)) {; 16936 /* Only for TCP sockets */; 16937 if (setsockopt(so->sock,; 16938 IPPROTO_TCP,; 16939 TCP_NODELAY,; 16940 (SOCK_OPT_TYPE)&nodelay_on,; 16941 sizeof(nodelay_on)); 16942 != 0) {; 16943 /* Error */; 16944 return 1;; 16945 }; 16946 }; 16947 /* OK */; 16948 return 0;; 16949}; 16950 ; 16951 ; 16952#if !defined(__ZEPHYR__); 16953static void; 16954close_socket_gracefully(struct mg_connection *conn); 16955{; 16956#if defined(_WIN32); 16957 char buf[MG_BUF_LEN];; 16958 int n;; 16959#endif; 16960 struct linger linger;; 16961 int error_code = 0;; 16962 int linger_timeout = -2;; 16963 socklen_t opt_len = sizeof(error_code);; 16964 ; 16965 if (!conn) {; 16966 return;; 16967 }; 16968 ; 16969 /* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:; 16970 * ""Note that enabling a nonzero timeout on a nonblocking socket; 16971 * is not recommended."", so set it to blocking now */; 16972 set_blocking_mode(conn->client.sock);; 16973 ; 16974 /* Send FIN to the client */; 16975 shutdown(conn->client.sock, SHUTDOWN_WR);; 16976 ; 16977 ; 16978#if defined(_WIN32); 16979 /* Read and discard pending incoming data. If we do not do that and; 16980 * close; 16981 * the socket, the data in the send buffer may be discarded. This; 16982 * behaviour is seen on Windows, when client keeps sending data; 16983 * when server decides to close the connection; then when client; 16984 * does recv() it gets no data back. */; 16985 do {; 16986 n = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);; 16987 } while (n > 0);; 16988#endif; 16989 ; 16990 if (conn->dom_ctx->config[LINGER_TIMEOUT]) {; 16991 linger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);; 16992 }; 16993 ; 16994 /* Set linger option according to configuration */; 16995 if (linger_timeout >= 0) {; 16996 /* Set linger o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:503693,timeout,timeout,503693,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"95class WrappedMemFunction : public IGenFunction {; 96 ; 97 ; 98 public:; 99 ; 100 /**; 101 construct from the pointer to the object and the member function; 102 */; 103 WrappedMemFunction( FuncObj & obj, MemFuncPtr memFn ) :; 104 fObj(&obj),; 105 fMemFunc( memFn ); 106 { /* no op */ }; 107 ; 108 // use default copy constructor and assignment operator; 109 ; 110 /// clone (required by the interface); 111 WrappedMemFunction * Clone() const override {; 112 return new WrappedMemFunction(*fObj,fMemFunc);; 113 }; 114 ; 115 ; 116private:; 117 ; 118 double DoEval (double x) const override {; 119 return ((*fObj).*fMemFunc)( x );; 120 }; 121 ; 122 ; 123 FuncObj * fObj;; 124 MemFuncPtr fMemFunc;; 125 ; 126 ; 127}; // WrappedMemFunction; 128 ; 129 ; 130/**; 131 Template class to wrap any C++ callable object; 132 implementing operator() (const double * x) in a multi-dimensional function interface.; 133 It provides a ROOT::Math::IGenMultiFunction-like signature; 134 ; 135 Note: If you want to wrap just the reference (to avoid copying) you need to use; 136 Func& or const Func & as template parameter. The former should be used when the; 137 operator() is not a const method of Func; 138 ; 139 @ingroup GenFunc; 140 ; 141 */; 142template< typename Func = FreeMultiFunctionPtr >; 143class WrappedMultiFunction : public IMultiGenFunction {; 144 ; 145 ; 146 public:; 147 ; 148 /**; 149 construct from the pointer to the object and the member function; 150 */; 151 WrappedMultiFunction( Func f , unsigned int dim = 1) :; 152 fFunc( f ),; 153 fDim( dim); 154 { /* no op */ }; 155 ; 156 // use default copy constructor and assignment operator; 157 ; 158 /// clone (required by the interface); 159 WrappedMultiFunction * Clone() const override {; 160 return new WrappedMultiFunction(fFunc,fDim);; 161 }; 162 ; 163 unsigned int NDim() const override { return fDim; }; 164 ; 165 // virtual ~WrappedFunction() { /**/ }; 166 ; 167private:; 168 ; 169 double DoEval (const double * x) const override {; 170 retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/WrappedFunction_8h_source.html:3576,avoid,avoid,3576,doc/master/WrappedFunction_8h_source.html,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html,1,['avoid'],['avoid']
Safety,"96 ; 1497////////////////////////////////////////////////////////////////////////////////; 1498/// Nothing to do; 1499 ; 1500void TGenCollectionProxy__SlowDeleteTwoIterators(void *, void *); 1501{; 1502}; 1503 ; 1504 ; 1505////////////////////////////////////////////////////////////////////////////////; 1506/// We can safely assume that the std::vector layout does not really depend on; 1507/// the content!; 1508 ; 1509void TGenCollectionProxy__VectorCreateIterators(void *obj, void **begin_arena, void **end_arena, TVirtualCollectionProxy*); 1510{; 1511 std::vector<char> *vec = (std::vector<char>*)obj;; 1512 if (vec->empty()) {; 1513 *begin_arena = 0;; 1514 *end_arena = 0;; 1515 return;; 1516 }; 1517 *begin_arena = &(*vec->begin());; 1518#ifdef R__VISUAL_CPLUSPLUS; 1519 *end_arena = &(*(vec->end()-1)) + 1; // On windows we can not dererence the end iterator at all.; 1520#else; 1521 // coverity[past_the_end] Safe on other platforms; 1522 *end_arena = &(*vec->end());; 1523#endif; 1524 ; 1525}; 1526 ; 1527////////////////////////////////////////////////////////////////////////////////; 1528/// Should not be used.; 1529 ; 1530void *TGenCollectionProxy__VectorNext(void *, const void *); 1531{; 1532 R__ASSERT(0);; 1533 return 0;; 1534}; 1535 ; 1536////////////////////////////////////////////////////////////////////////////////; 1537 ; 1538void *TGenCollectionProxy__VectorCopyIterator(void *dest, const void *source); 1539{; 1540 *(void**)dest = *(void**)source;; 1541 return dest;; 1542}; 1543 ; 1544////////////////////////////////////////////////////////////////////////////////; 1545/// Nothing to do; 1546 ; 1547void TGenCollectionProxy__VectorDeleteSingleIterators(void *); 1548{; 1549}; 1550 ; 1551////////////////////////////////////////////////////////////////////////////////; 1552/// Nothing to do; 1553 ; 1554void TGenCollectionProxy__VectorDeleteTwoIterators(void *, void *); 1555{; 1556}; 1557 ; 1558 ; 1559 ; 1560//////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:49006,Safe,Safe,49006,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['Safe'],['Safe']
Safety,"96 ; 297 Init();; 298 SetBit(kMenuBar,true);; 299 if (form < 0) {; 300 form = -form;; 301 SetBit(kMenuBar,false);; 302 }; 303 ; 304 fCanvas = this;; 305 ; 306 fCanvasID = -1;; 307 TCanvas *old = (TCanvas*)gROOT->GetListOfCanvases()->FindObject(name);; 308 if (old && old->IsOnHeap()) {; 309 Warning(""Constructor"",""Deleting canvas with same name: %s"",name);; 310 delete old;; 311 }; 312 if (gROOT->IsBatch()) { //We are in Batch mode; 313 fWindowTopX = fWindowTopY = 0;; 314 if (form == 1) {; 315 fWindowWidth = gStyle->GetCanvasDefW();; 316 fWindowHeight = gStyle->GetCanvasDefH();; 317 } else {; 318 fWindowWidth = 500;; 319 fWindowHeight = 500;; 320 }; 321 fCw = fWindowWidth;; 322 fCh = fWindowHeight;; 323 fCanvasImp = gBatchGuiFactory->CreateCanvasImp(this, name, fCw, fCh);; 324 if (!fCanvasImp) return;; 325 fBatch = kTRUE;; 326 } else { //normal mode with a screen window; 327 Float_t cx = gStyle->GetScreenFactor();; 328 if (form < 1 || form > 20) form = 1;; 329 auto factory = gROOT->IsWebDisplay() ? gBatchGuiFactory : gGuiFactory;; 330 Int_t ux, uy, cw, ch;; 331 if (form == 1) {; 332 cw = gStyle->GetCanvasDefW();; 333 ch = gStyle->GetCanvasDefH();; 334 ux = gStyle->GetCanvasDefX();; 335 uy = gStyle->GetCanvasDefY();; 336 } else {; 337 cw = ch = 500;; 338 ux = uy = form * 10;; 339 }; 340 ; 341 fCanvasImp = factory->CreateCanvasImp(this, name, Int_t(cx*ux), Int_t(cx*uy), UInt_t(cx*cw), UInt_t(cx*ch));; 342 if (!fCanvasImp) return;; 343 ; 344 if (!gROOT->IsBatch() && fCanvasID == -1); 345 fCanvasID = fCanvasImp->InitWindow();; 346 ; 347 fCanvasImp->ShowMenuBar(TestBit(kMenuBar));; 348 fBatch = kFALSE;; 349 }; 350 ; 351 CreatePainter();; 352 ; 353 fName = GetNewCanvasName(name); // avoid Modified() signal from SetName; 354 SetTitle(title); // requires fCanvasImp set; 355 Build();; 356 ; 357 // Popup canvas; 358 fCanvasImp->Show();; 359}; 360 ; 361////////////////////////////////////////////////////////////////////////////////; 362/// Create a new canvas at a random position.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:10865,avoid,avoid,10865,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['avoid'],['avoid']
Safety,"9647 0.0472837 20277.3 3; : 19 | 0.540337 0.582774 0.592992 0.0472829 20406.5 4; : 20 | 0.538876 0.589547 0.592937 0.0473047 20409.4 5; : ; : Elapsed time for training with 14000 events: 11.9 sec ; : Evaluate deep neural network on CPU using batches with size = 128; : ; DNN_CPU : [dataset] : Evaluation of DNN_CPU on training sample (14000 events); : Elapsed time for evaluation of 14000 events: 0.247 sec ; : Creating xml weight file: â›[0;36mdataset/weights/TMVA_Higgs_Classification_DNN_CPU.weights.xmlâ›[0m; : Creating standalone class: â›[0;36mdataset/weights/TMVA_Higgs_Classification_DNN_CPU.class.Câ›[0m; Factory : Training finished; : ; Factory : Train method: PyKeras for Classification; : ; : ; : â›[1m================================================================â›[0m; : â›[1mH e l p f o r M V A m e t h o d [ PyKeras ] :â›[0m; : ; : Keras is a high-level API for the Theano and Tensorflow packages.; : This method wraps the training and predictions steps of the Keras; : Python package for TMVA, so that dataloading, preprocessing and; : evaluation can be done within the TMVA system. To use this Keras; : interface, you have to generate a model with Keras first. Then,; : this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : â›[1m================================================================â›[0m; : ; : Split TMVA training data in 11200 training events and 2800 validation events; : Training Model Summary; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; dense (Dense) (None, 64) 512 ; ; dense_1 (Dense) (None, 64) 4160 ; ; dense_2 (Dense) (None, 64) 4160 ; ; dense_3 (Dense) (None, 64) 4160 ; ; dense_4 (Dense) (None, 2) 130 ; ; =================================================================; Total params: 13122 (51.26 KB); Trainable params: 13122 (51.26 KB); Non-trai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:26526,predict,predictions,26526,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['predict'],['predictions']
Safety,"965 constructorTypes,; 4966 gOptSplit,; 4967 isGenreflex,; 4968 isSelXML,; 4969 gOptWriteEmptyRootPCM);; 4970 }; 4971 ; 4972 if (rootclingRetCode != 0) {; 4973 return rootclingRetCode;; 4974 }; 4975 ; 4976 // Now we have done all our looping and thus all the possible; 4977 // annotation, let's write the pcms.; 4978 HeadersDeclsMap_t headersClassesMap;; 4979 HeadersDeclsMap_t headersDeclsMap;; 4980 if (!gOptIgnoreExistingDict) {; 4981 const std::string fwdDeclnArgsToKeepString(GetFwdDeclnArgsToKeepString(normCtxt, interp));; 4982 ; 4983 ExtractHeadersForDecls(scan.fSelectedClasses,; 4984 scan.fSelectedTypedefs,; 4985 scan.fSelectedFunctions,; 4986 scan.fSelectedVariables,; 4987 scan.fSelectedEnums,; 4988 headersClassesMap,; 4989 headersDeclsMap,; 4990 interp);; 4991 ; 4992 std::string detectedUmbrella;; 4993 for (auto & arg : pcmArgs) {; 4994 if (gOptInlineInput && !ROOT::TMetaUtils::IsLinkdefFile(arg.c_str()) && ROOT::TMetaUtils::IsHeaderName(arg)) {; 4995 detectedUmbrella = arg;; 4996 break;; 4997 }; 4998 }; 4999 ; 5000 if (gOptWriteEmptyRootPCM){; 5001 headersDeclsMap.clear();; 5002 }; 5003 ; 5004 ; 5005 std::string headersClassesMapString = ""\""\"""";; 5006 std::string fwdDeclsString = ""\""\"""";; 5007 if (!gOptCxxModule) {; 5008 headersClassesMapString = GenerateStringFromHeadersForClasses(headersDeclsMap,; 5009 detectedUmbrella,; 5010 true);; 5011 if (!gDriverConfig->fBuildingROOTStage1) {; 5012 if (!gOptWriteEmptyRootPCM); 5013 fwdDeclsString = GenerateFwdDeclString(scan, interp);; 5014 }; 5015 }; 5016 modGen.WriteRegistrationSource(dictStream, fwdDeclnArgsToKeepString, headersClassesMapString, fwdDeclsString,; 5017 extraIncludes, gOptCxxModule);; 5018 // If we just want to inline the input header, we don't need; 5019 // to generate any files.; 5020 if (!gOptInlineInput) {; 5021 // Write the module/PCH depending on what mode we are on; 5022 if (modGen.IsPCH()) {; 5023 if (!GenerateAllDict(modGen, CI, currentDirectory)) return 1;; 5024 } else if (gOptCxxModule) {; 502",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:203599,detect,detectedUmbrella,203599,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['detect'],['detectedUmbrella']
Safety,"9659 }; 19660 return NULL;; 19661 }; 19662 ; 19663 /* Random number generator will initialize at the first call */; 19664 ctx->dd.auth_nonce_mask =; 19665 (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);; 19666 ; 19667 /* Save started thread index to reuse in other external API calls; 19668 * For the sake of thread synchronization all non-civetweb threads; 19669 * can be considered as single external thread */; 19670 ctx->starter_thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);; 19671 tls.is_master = -1; /* Thread calling mg_start */; 19672 tls.thread_idx = ctx->starter_thread_idx;; 19673#if defined(_WIN32); 19674 tls.pthread_cond_helper_mutex = NULL;; 19675#endif; 19676 pthread_setspecific(sTlsKey, &tls);; 19677 ; 19678 ok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));; 19679#if !defined(ALTERNATIVE_QUEUE); 19680 ok &= (0 == pthread_cond_init(&ctx->sq_empty, NULL));; 19681 ok &= (0 == pthread_cond_init(&ctx->sq_full, NULL));; 19682 ctx->sq_blocked = 0;; 19683#endif; 19684 ok &= (0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr));; 19685#if defined(USE_LUA); 19686 ok &= (0 == pthread_mutex_init(&ctx->lua_bg_mutex, &pthread_mutex_attr));; 19687#endif; 19688 if (!ok) {; 19689 const char *err_msg =; 19690 ""Cannot initialize thread synchronization objects"";; 19691 /* Fatal error - abort start. However, this situation should never; 19692 * occur in practice. */; 19693 ; 19694 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19695 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19696 mg_snprintf(NULL,; 19697 NULL, /* No truncation check for error buffers */; 19698 error->text,; 19699 error->text_buffer_size,; 19700 ""%s"",; 19701 err_msg);; 19702 }; 19703 ; 19704 mg_free(ctx);; 19705 pthread_setspecific(sTlsKey, NULL);; 19706 return NULL;; 19707 }; 19708 ; 19709 if ((init != NULL) && (init->callbacks != NULL)) {; 19710 /* Set all callbacks except exit_context. */; 19711 ctx->callbacks = *init->callbacks;; 19712 exit_callba",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:587323,abort,abort,587323,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"9660 }; 19661 return NULL;; 19662 }; 19663 ; 19664 /* Random number generator will initialize at the first call */; 19665 ctx->dd.auth_nonce_mask =; 19666 (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);; 19667 ; 19668 /* Save started thread index to reuse in other external API calls; 19669 * For the sake of thread synchronization all non-civetweb threads; 19670 * can be considered as single external thread */; 19671 ctx->starter_thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);; 19672 tls.is_master = -1; /* Thread calling mg_start */; 19673 tls.thread_idx = ctx->starter_thread_idx;; 19674#if defined(_WIN32); 19675 tls.pthread_cond_helper_mutex = NULL;; 19676#endif; 19677 pthread_setspecific(sTlsKey, &tls);; 19678 ; 19679 ok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));; 19680#if !defined(ALTERNATIVE_QUEUE); 19681 ok &= (0 == pthread_cond_init(&ctx->sq_empty, NULL));; 19682 ok &= (0 == pthread_cond_init(&ctx->sq_full, NULL));; 19683 ctx->sq_blocked = 0;; 19684#endif; 19685 ok &= (0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr));; 19686#if defined(USE_LUA); 19687 ok &= (0 == pthread_mutex_init(&ctx->lua_bg_mutex, &pthread_mutex_attr));; 19688#endif; 19689 if (!ok) {; 19690 const char *err_msg =; 19691 ""Cannot initialize thread synchronization objects"";; 19692 /* Fatal error - abort start. However, this situation should never; 19693 * occur in practice. */; 19694 ; 19695 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19696 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19697 mg_snprintf(NULL,; 19698 NULL, /* No truncation check for error buffers */; 19699 error->text,; 19700 error->text_buffer_size,; 19701 ""%s"",; 19702 err_msg);; 19703 }; 19704 ; 19705 mg_free(ctx);; 19706 pthread_setspecific(sTlsKey, NULL);; 19707 return NULL;; 19708 }; 19709 ; 19710 if ((init != NULL) && (init->callbacks != NULL)) {; 19711 /* Set all callbacks except exit_context. */; 19712 ctx->callbacks = *init->callbacks;; 19713 exit_callba",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:587356,abort,abort,587356,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"994// Find which root is the right one; 1995 rt = TMath::Sqrt(determ);; 1996 x1 = (-coeff[1] + rt) / (coeff[2]*2);; 1997 x2 = (-coeff[1] - rt) / (coeff[2]*2);; 1998 s1 = coeff[1] + x1*2*coeff[2];; 1999 s2 = coeff[1] + x2*2*coeff[2];; 2000 if (s1*s2 > 0) {; 2001 Printf("" MNCONTour problem 1"");; 2002 }; 2003 aopt = x1;; 2004 slope = s1;; 2005 if (s2 > 0) {; 2006 aopt = x2;; 2007 slope = s2;; 2008 }; 2009// ask if converged; 2010 tla = .01;; 2011 if (TMath::Abs(aopt) > 1) tla = TMath::Abs(aopt)*.01;; 2012 if (TMath::Abs(aopt - alsb[ibest-1]) < tla && TMath::Abs(flsb[ibest-1] - aim) < tlf) {; 2013 goto L800;; 2014 }; 2015 if (ipt >= 15) goto L950;; 2016 ; 2017// see if proposed point is in acceptable zone between L and R; 2018// first find ILEFT, IRIGHT, IOUT and IBEST; 2019 ileft = 0;; 2020 iright = 0;; 2021 ibest = 1;; 2022 ecarmx = 0;; 2023 ecarmn = TMath::Abs(aim - flsb[0]);; 2024 for (i = 1; i <= 3; ++i) {; 2025 ecart = TMath::Abs(flsb[i-1] - aim);; 2026 if (ecart < ecarmn) { ecarmn = ecart; ibest = i; }; 2027 if (ecart > ecarmx) { ecarmx = ecart; }; 2028 if (flsb[i-1] > aim) {; 2029 if (iright == 0) iright = i;; 2030 else if (flsb[i-1] > flsb[iright-1]) iout = i;; 2031 else { iout = iright; iright = i; }; 2032 }; 2033 else if (ileft == 0) ileft = i;; 2034 else if (flsb[i-1] < flsb[ileft-1]) iout = i;; 2035 else { iout = ileft; ileft = i; }; 2036 }; 2037// avoid keeping a very bad point next time around; 2038 if (ecarmx > TMath::Abs(flsb[iout-1] - aim)*10) {; 2039 aopt = aopt*.5 + (alsb[iright-1] + alsb[ileft-1])*.25;; 2040 }; 2041// knowing ILEFT and IRIGHT, get acceptable window; 2042 smalla = tla*.1;; 2043 if (slope*smalla > tlf) smalla = tlf / slope;; 2044 aleft = alsb[ileft-1] + smalla;; 2045 aright = alsb[iright-1] - smalla;; 2046// move proposed point AOPT into window if necessary; 2047 if (aopt < aleft) aopt = aleft;; 2048 if (aopt > aright) aopt = aright;; 2049 if (aleft > aright) aopt = (aleft + aright)*.5;; 2050 ; 2051// see if proposed point outside limi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:68401,avoid,avoid,68401,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['avoid'],['avoid']
Safety,"995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TTimer; 13\ingroup Base; 14 ; 15Handles synchronous and a-synchronous timer events.; 161. synchronous timer is registered into TSystem and is processed; 17 within the standard ROOT event-loop.; 182. asynchronous timer is passed to the operating system which sends; 19 an external signal to ROOT and thus interrupts its event-loop.; 20 ; 21You can use this class in one of the following ways:; 22 - Sub-class TTimer and override the Notify() method.; 23 - Re-implement the TObject::HandleTimer() method in your class; 24 and pass a pointer to this object to timer, see the SetObject(); 25 method.; 26 - Pass an interpreter command to timer, see SetCommand() method.; 27 - Create a TTimer, connect its Timeout() signal to the; 28 appropriate methods. Then when the time is up it will emit a; 29 Timeout() signal and call connected slots.; 30 ; 31Minimum timeout interval is defined in TSystem::ESysConstants as; 32`kItimerResolution` (currently 10 ms).; 33 ; 34Signal/slots example:; 35~~~{.cpp}; 36 TTimer *timer = new TTimer();; 37 timer->Connect(""Timeout()"", ""myObjectClassName"",; 38 myObject, ""TimerDone()"");; 39 timer->Start(2000, kTRUE); // 2 seconds single-shot; 40~~~; 41To emit the Timeout signal repeatedly with minimum timeout:; 42~~~ {.cpp}; 43 timer->Start(0, kFALSE);; 44~~~; 45*/; 46 ; 47#include ""TTimer.h""; 48#include ""TSystem.h""; 49#include ""TROOT.h""; 50 ; 51ClassImp(TTimer);; 52 ; 53 ; 54class TSingleShotCleaner : public TTimer {; 55private:; 56 TList *fGarbage;; 57public:; 58 TSingleShotCleaner() : TTimer(10, kTRUE) { fGarbage = new TList(); }; 59 virtual ~TSingleShotCleaner() { fGarbage->Delete(); delete fGarbage; }; 60 void TurnOn() override; 61 {; 62 TObject *obj = (TObject *)gT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8cxx_source.html:1333,Timeout,Timeout,1333,doc/master/TTimer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html,1,['Timeout'],['Timeout']
Safety,": "" << realVar->GetName() << std::endl;; 979 }; 980 plotClones.addClone(*realVar,true); // do not complain about duplicates; 981 }; 982 ; 983 // Reconnect all plotClones to each other, imported when plotting N-dim integrals with entangled parameterized ranges; 984 for(RooAbsArg * pc : plotClones) {; 985 pc->recursiveRedirectServers(plotClones,false,false,true) ;; 986 }; 987 ; 988 // Call checkObservables; 989 RooArgSet allDeps(plotClones) ;; 990 if (projectedVars) {; 991 allDeps.add(*projectedVars) ;; 992 }; 993 if (checkObservables(&allDeps)) {; 994 coutE(InputArguments) << ""RooAbsReal::fillHistogram("" << GetName() << "") error in checkObservables, abort"" << std::endl ;; 995 return hist ;; 996 }; 997 ; 998 // Create a standalone projection object to use for calculating bin contents; 999 RooArgSet *cloneSet = nullptr;; 1000 const RooAbsReal *projected= createPlotProjection(plotClones,projectedVars,cloneSet,nullptr,condObs);; 1001 ; 1002 cxcoutD(Plotting) << ""RooAbsReal::fillHistogram("" << GetName() << "") plot projection object is "" << projected->GetName() << std::endl ;; 1003 ; 1004 // Prepare to loop over the histogram bins; 1005 Int_t xbins(0);; 1006 Int_t ybins(1);; 1007 Int_t zbins(1);; 1008 RooRealVar *xvar = nullptr;; 1009 RooRealVar *yvar = nullptr;; 1010 RooRealVar *zvar = nullptr;; 1011 TAxis *xaxis = nullptr;; 1012 TAxis *yaxis = nullptr;; 1013 TAxis *zaxis = nullptr;; 1014 switch(hdim) {; 1015 case 3:; 1016 zbins= hist->GetNbinsZ();; 1017 zvar= dynamic_cast<RooRealVar*>(plotClones.find(plotVars.at(2)->GetName()));; 1018 zaxis= hist->GetZaxis();; 1019 assert(nullptr != zvar && nullptr != zaxis);; 1020 if (scaleForDensity) {; 1021 scaleFactor*= (zaxis->GetXmax() - zaxis->GetXmin())/zbins;; 1022 }; 1023 // fall through to next case...; 1024 case 2:; 1025 ybins= hist->GetNbinsY();; 1026 yvar= dynamic_cast<RooRealVar*>(plotClones.find(plotVars.at(1)->GetName()));; 1027 yaxis= hist->GetYaxis();; 1028 assert(nullptr != yvar && nullptr != yaxis);; 1029 if (scaleFo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:40694,abort,abort,40694,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['abort'],['abort']
Safety,": -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); ; ; ; -------------- Starting second fit ---------------; ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -1002.2262595660759; Edm = 2.95538313214564806e-09; Nfcn = 251; a1 = -0.498159 +/- 0.0227242 (limited); a2 = 0.198316 +/- 0.00564906 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 0, estimated distance to minimum: 0; covariance matrix quality: Not calculated at all; Status : MINIMIZE=-1 HESSE=302 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 1.0000e+01 +/- 0.00e+00; a2 -1.0000e+00 +/- 0.00e+00; ; Without recovery, the fitter encountered 23 invalid function values. The parameters are unchanged.; ; RooFitResult: minimized FCN value: 29650.9, estimated distance to minimum: 2.95925e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 -4.9816e-01 +/- 2.27e-02; a2 1.9832e-01 +/- 5.65e-03; ; With recovery, the fitter encountered 76 invalid function values, but the parameters are fitted.; Date10/2020 ; AuthorStephan Hageboeck ; Definition in file rf612_recoverFromInvalidParameters.C. tutorialsroofitrf612_recoverFromInvalidParameters.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8 Â Â ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:11119,recover,recovery,11119,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,2,['recover'],['recovery']
Safety,": core/foundation/inc/TError.h File Reference. ; ROOT Â ; . master. Reference Guide ; . Â . Loading...; Searching...; No Matches. Namespaces |; Macros |; Typedefs |; Functions |; Variables ; TError.h File Reference. #include <DllImport.h>; #include ""RtypesCore.h""; #include <ROOT/RConfig.hxx>; #include <cstdarg>; #include <functional>. Include dependency graph for TError.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace Â ROOT; Â tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ; Â ; namespace Â ROOT::Internal; Â . Macros; #defineÂ R__ASSERT(e); Â Checks condition e and reports a fatal error if it's false. ; Â ; #defineÂ R__CHECK(e); Â Checks condition e and reports a warning message if it's false. ; Â . Typedefs; typedef void(*Â ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg); Â ; usingÂ ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>; Â Retrieves the error string associated with the last system error. ; Â . Functions; voidÂ AbstractMethod (const char *method); Â This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ; Â ; voidÂ Break (const char *location, const char *msgfmt,...); Â Use this function in case an error occurred. ; Â ; voidÂ DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg); Â The default error handler function. ; Â ; voidÂ Error (const char *location, const char *msgfmt,...); Â Use this function in case an error occurred. ; Â ; voidÂ ErrorHandler (int level, const char *location, const char *fmt, std::va_list va); Â General error handler function. It calls the user set error handler. ; Â ; voidÂ Fatal (const char *location, const char *msgfmt,...); Â Use this function in case of a fatal error. It will abort the program. ; Â ; ErrorHandlerFunc_tÂ GetErrorH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8h.html:939,abort,abort,939,doc/master/TError_8h.html,https://root.cern,https://root.cern/doc/master/TError_8h.html,1,['abort'],['abort']
Safety,":. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; TDirectory*RooDirItem::_dir! Associated directory; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool; RooArgSetRooAbsData::_varsDimensions of this data set; RooArgSet_varsNoWgtVars without weight variable; RooRealVar*_wgtVarPointer to weight variable (if set); static RooAbsData::StorageTypeRooAbsData::defaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooDataSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooDataSet(); Default constructor for persistence. RooDataSet(const char* name, const char* title, const RooArgSet& vars, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Construct an unbinned dataset from a RooArgSet defining the dimensions of the dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataSet.html:19343,avoid,avoid,19343,root/html602/RooDataSet.html,https://root.cern,https://root.cern/root/html602/RooDataSet.html,2,['avoid'],['avoid']
Safety,":. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. stringfFileNamePrefix; intfHighBin; intfLowBin; doublefLumiError; doublefNomLumi; TFile*fOut_f; stringstreamfResultsPrefixStr; stringfRowTitle; vector<std::string>fSystToFix; FILE*pFile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HistoToWorkspaceFactory(). ~HistoToWorkspaceFactory(). HistoToWorkspaceFactory(string , string , vector<std::string> , double = 200, double = 20, int = 0, int = 6, TFile* = 0). string FilePrefixStr(string ). void ProcessExpectedHisto(TH1* hist, RooWorkspace* proto, string prefix, string productPrefix, string systTerm, double low, double high, int lowBin, int highBin). void AddMultiVarGaussConstraint(RooWorkspace* proto, string prefix, int lowBin, int highBin, vector<std::string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins. void LinInterpWithConstraint(RooWorkspace* proto, TH1* nominal, vector<TH1*> lowHist, vector<TH1*> highHist, vector<std::string> sourceName, string prefix, string productPrefix, string systTerm, int lowBin, int highBin, vector<std::string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins; make list of abstract parameters that interpolate in space of variations; range is set using defined macro (see top of the page). string AddNormFactor(RooWorkspace* , string& , string& , RooStats::HistFactory::EstimateSummary& , bool ). void AddEfficiencyTerms(RooWorkspace* proto, string prefix, string interpName, map<std::string,std::pair<double,double> > systMap, vector<std::string>& likelihoodTermNames, vector<std::string>& totSyst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__HistoToWorkspaceFactory.html:8473,predict,predictions,8473,root/html534/RooStats__HistFactory__HistoToWorkspaceFactory.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__HistoToWorkspaceFactory.html,1,['predict'],['predictions']
Safety,":. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra(). Â» Author: L. Moneta Fri Aug 15 2008 Â» Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *; Â» Last changed: root/ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__BaseIntegratorOptions.html:1682,avoid,avoid,1682,root/html528/ROOT__Math__BaseIntegratorOptions.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__BaseIntegratorOptions.html,4,['avoid'],['avoid']
Safety,":1821; TFile::GetFileCounterstatic Long64_t GetFileCounter()Definition TFile.cxx:4617; TFile::fCacheReadMapTMap * fCacheReadMap!Pointer to the read cache (if any)Definition TFile.h:99; TFile::fBEGINLong64_t fBEGINFirst used byte in file.Definition TFile.h:78; TFile::MakeProjectParProofInfInt_t MakeProjectParProofInf(const char *packname, const char *proofinfdir)Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.Definition TFile.cxx:3486; TFile::WriteProcessIDvirtual UShort_t WriteProcessID(TProcessID *pid)Check if the ProcessID pidd is already in the file, if not, add it and return the index number in the...Definition TFile.cxx:3763; TFile::MakeProjectvirtual void MakeProject(const char *dirname, const char *classes=""*"", Option_t *option=""new"")Generate source code necessary to access the objects stored in the file.Definition TFile.cxx:2726; TFile::fArchiveOffsetLong64_t fArchiveOffset!Offset at which file starts in archiveDefinition TFile.h:101; TFile::EOpenTimeOutEOpenTimeOutOpen timeout constants.Definition TFile.h:67; TFile::kInstantTimeout@ kInstantTimeoutDefinition TFile.h:67; TFile::kEternalTimeout@ kEternalTimeoutDefinition TFile.h:67; TFile::fNbytesInfoInt_t fNbytesInfoNumber of bytes for StreamerInfo record.Definition TFile.h:86; TFile::GetSizevirtual Long64_t GetSize() constReturns the current file size.Definition TFile.cxx:1347; TFile::GetFdInt_t GetFd() constDefinition TFile.h:234; TFile::IsOpenvirtual Bool_t IsOpen() constReturns kTRUE in case file is open and kFALSE if file is not open.Definition TFile.cxx:1469; TFile::fAsyncHandleTFileOpenHandle * fAsyncHandle!For proper automatic cleanupDefinition TFile.h:108; TFile::SetOnlyStagedstatic Bool_t SetOnlyStaged(Bool_t onlystaged)Sets only staged flag.Definition TFile.cxx:4744; TFile::GetReadCallsvirtual Int_t GetReadCalls() constDefinition TFile.h:244; TFile::GetNewUrlvirtual TString GetNewUrl()Definition TFile.h:250; TFile::GetBytesReadvirtual Long64_t GetBytesRead() constDefinition TFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:35448,timeout,timeout,35448,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['timeout'],['timeout']
Safety,":298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; RooFit::YVarRooCmdArg YVar(const RooAbsRealLValue &var, const RooCmdArg &arg={})Definition RooGlobalFunc.cxx:846; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf301_compositionDefinition rf301_composition.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[y]_Norm[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on y integrates over variables (x); [#1] INFO:NumericIntegration -- RooRealIntegral::ini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf301__composition_8C.html:4900,safe,safe,4900,doc/master/rf301__composition_8C.html,https://root.cern,https://root.cern/doc/master/rf301__composition_8C.html,1,['safe'],['safe']
Safety,":8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; The second to last entry is a list of free segments. In our case, this starts 8976 and is not very long, only 53 bytes, since we have not deleted any objects. The last entry is the address of the last byte in the file.; 11.1.6 File Recovery; A file may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints informa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:440744,recover,recovery,440744,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['recover'],['recovery']
Safety,":9000"" - creates fastcgi server with port 9000; ""dabc:1237"" - create DABC server with port 1237 (only available with DABC installed); ""dabc:master_host:port"" - attach to DABC master, running on master_host:port (only available with DABC installed). void SetTimer(Long_t milliSec = 100, Bool_t mode = kTRUE); create timer which will invoke ProcessRequests() function periodically; Timer is required to perform all actions in main ROOT thread; Method arguments are the same as for TTimer constructor; By default, sync timer with 100 ms period is created. If milliSec == 0, no timer will be created.; In this case application should regularly call ProcessRequests() method. Bool_t VerifyFilePath(const char* fname); Checked that filename does not contains relative path below current directory; Used to prevent access to files below current directory. Bool_t IsFileRequested(const char* uri, TString& res) const; Verifies that request is just file name; File names typically contains prefix like ""jsrootsys/""; If true, method returns real name of the file,; which should be delivered to the client; Method is thread safe and can be called from any thread. Bool_t ExecuteHttp(THttpCallArg* arg); Executes http request, specified in THttpCallArg structure; Method can be called from any thread; Actual execution will be done in main ROOT thread, where analysis code is running. void ProcessRequests(); Process requests, submitted for execution; Regularly invoked by THttpTimer, when somewhere in the code; gSystem->ProcessEvents() is called.; User can call serv->ProcessRequests() directly, but only from main analysis thread. void ProcessRequest(THttpCallArg* arg); Process single http request; Depending from requested path and filename different actions will be performed.; In most cases information is provided by TRootSniffer class. Bool_t Register(const char* subfolder, TObject* obj); Register object in folders hierarchy. See TRootSniffer::RegisterObject() for more details. Bool_t Unregister(TObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THttpServer.html:12123,safe,safe,12123,root/html534/THttpServer.html,https://root.cern,https://root.cern/root/html534/THttpServer.html,3,['safe'],['safe']
Safety,"::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TEventIterObj&operator=(const TEventIterObj&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPreProcessEvent(Long64_t); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidTEventIter::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEventIterObj.html:4786,abort,abort,4786,root/html534/TEventIterObj.html,https://root.cern,https://root.cern/root/html534/TEventIterObj.html,1,['abort'],['abort']
Safety,"::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTVirtualPacketizer::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPacketizer.html:5881,abort,abort,5881,root/html528/TPacketizer.html,https://root.cern,https://root.cern/root/html528/TPacketizer.html,4,['abort'],['abort']
Safety,"::RVec< T > Class Template ReferenceVecOps. ; template<typename T>; class ROOT::VecOps::RVec< T >A ""std::vector""-like collection of values implementing handy operation to analyse them. ; Template Parameters. TThe type of the contained objects. A RVec is a container designed to make analysis of values' collections fast and easy. Its storage is contiguous in memory and its interface is designed such to resemble to the one of the stl vector. In addition the interface features methods and external functions to ease the manipulation and analysis of the data in the RVec.; NoteROOT::VecOps::RVec can also be spelled simply ROOT::RVec. Shorthand aliases such as ROOT::RVecI or ROOT::RVecD are also available as template instantiations of RVec of fundamental types. The full list of available aliases:; RVecB (bool); RVecC (char); RVecD (double); RVecF (float); RVecI (int); RVecL (long); RVecLL (long long); RVecU (unsigned); RVecUL (unsigned long); RVecULL (unsigned long long). RVec does not attempt to be exception safe. Exceptions thrown by element constructors during insertions, swaps or other operations will be propagated potentially leaving the RVec object in an invalid state. RVec methods (e.g. at or size) follow the STL naming convention instead of the ROOT naming convention in order to make RVec a drop-in replacement for std::vector. Table of Contents. Example; Arithmetic operations, logical operations and mathematical functions; Owning and adopting memory; Sorting and manipulation of indices; Usage in combination with RDataFrame; Reference for the RVec class; Reference for RVec helper functions. Example; Suppose to have an event featuring a collection of muons with a certain pseudorapidity, momentum and charge, e.g.: std::vector<short> mu_charge {1, 1, -1, -1, -1, 1, 1, -1};; std::vector<float> mu_pt {56, 45, 32, 24, 12, 8, 7, 6.2};; std::vector<float> mu_eta {3.1, -.2, -1.1, 1, 4.1, 1.6, 2.4, -.5};; Suppose you want to extract the transverse momenta of the muons satisfyi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html:1283,safe,safe,1283,doc/v632/classROOT_1_1VecOps_1_1RVec.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html,2,['safe'],['safe']
Safety,"::RecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tTSystem::RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*TSystem::RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*TSystem::RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*TSystem::RemoveTimer(TTimer* t); virtual intTSystem::Rename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidTSystem::ResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidTSystem::ResetTimer(TTimer*); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDCacheSystem.html:11302,timeout,timeout,11302,root/html528/TDCacheSystem.html,https://root.cern,https://root.cern/root/html528/TDCacheSystem.html,4,['timeout'],['timeout']
Safety,"::RecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tTSystem::RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*TSystem::RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*TSystem::RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*TSystem::RemoveTimer(TTimer* t); virtual intTSystem::Rename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidTSystem::ResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidTSystem::ResetTimer(TTimer*); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char*); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TDCacheSystem.html:11252,timeout,timeout,11252,root/html526/TDCacheSystem.html,https://root.cern,https://root.cern/root/html526/TDCacheSystem.html,1,['timeout'],['timeout']
Safety,"::RuleFitAPI::EModel. protected . EnumeratorkRfLinearÂ ; kRfRulesÂ ; kRfBothÂ . Definition at line 85 of file RuleFitAPI.h. â—†Â ERFMode. enum TMVA::RuleFitAPI::ERFMode. protected . EnumeratorkRfRegressÂ ; kRfClassÂ . Definition at line 84 of file RuleFitAPI.h. â—†Â ERFProgram. enum TMVA::RuleFitAPI::ERFProgram. protected . EnumeratorkRfTrainÂ ; kRfPredictÂ ; kRfVarimpÂ . Definition at line 86 of file RuleFitAPI.h. Constructor & Destructor Documentation. â—†Â RuleFitAPI() [1/2]. TMVA::RuleFitAPI::RuleFitAPI ; (; const TMVA::MethodRuleFit *Â ; rfbase, . TMVA::RuleFit *Â ; rulefit, . EMsgTypeÂ ; minType = kINFOÂ . ). Definition at line 48 of file RuleFitAPI.cxx. â—†Â ~RuleFitAPI(). TMVA::RuleFitAPI::~RuleFitAPI ; (; ). virtual . destructor ; Definition at line 69 of file RuleFitAPI.cxx. â—†Â RuleFitAPI() [2/2]. TMVA::RuleFitAPI::RuleFitAPI ; (; ). private . Member Function Documentation. â—†Â CheckRFWorkDir(). void TMVA::RuleFitAPI::CheckRFWorkDir ; (; ). check if the rulefit work dir is properly setup. ; it aborts (kFATAL) if not.; Check existence of directory ; Definition at line 166 of file RuleFitAPI.cxx. â—†Â Class(). static TClass * TMVA::RuleFitAPI::Class ; (; ). static . ReturnsTClass describing this class . â—†Â Class_Name(). static const char * TMVA::RuleFitAPI::Class_Name ; (; ). static . ReturnsName of this class . â—†Â Class_Version(). static constexpr Version_t TMVA::RuleFitAPI::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 195 of file RuleFitAPI.h. â—†Â DeclFileName(). static const char * TMVA::RuleFitAPI::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 195 of file RuleFitAPI.h. â—†Â FillIntParmsDef(). void TMVA::RuleFitAPI::FillIntParmsDef ; (; ). protected . set default int params ; Definition at line 228 of file RuleFitAPI.cxx. â—†Â FillRealParmsDef(). void TMVA::RuleFitAPI::FillRealParmsDef ; (; ). protected . set default real params ; Definition at line 213 of file RuleFitAPI.cxx. â—†",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitAPI.html:5643,abort,aborts,5643,doc/master/classTMVA_1_1RuleFitAPI.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitAPI.html,1,['abort'],['aborts']
Safety,"::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_tfDetIdCustom detector id.; Int_tfEvaLabelLabel of primary particle, ancestor of label.; Int_tfLabelLabel of particle that produced the hit.; UShort_tfSubdetIdCustom sub-detector id.; TEveVectorfVHit position. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveMCTrack& operator=(const TEveHit& ); { *((TParticle*)this) = p; return *this; }. TEveHit(); Float_t charge; probably specific. {}. virtual ~TEveHit(); {}. Â» Last changed: root/eve:$Id: TEveVSDStructs.h 31517 2009-12-03 11:56:23Z matevz $ Â» Last generated: 2010-09-23 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveHit.html:5004,detect,detector,5004,root/html528/TEveHit.html,https://root.cern,https://root.cern/root/html528/TEveHit.html,2,['detect'],['detector']
Safety,"::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_tfDetIdCustom detector id.; Int_tfEvaLabelLabel of primary particle, ancestor of label.; Int_tfLabelLabel of particle that produced the hit.; UShort_tfSubdetIdCustom sub-detector id.; TEveVectorfVHit position. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveMCTrack& operator=(const TEveHit& ); { *((TParticle*)this) = p; return *this; }. TEveHit(); Float_t charge; probably specific. {}. virtual ~TEveHit(); {}. Â» Last changed: root/eve:$Id: TEveVSDStructs.h 38721 2011-04-04 13:37:12Z matevz $ Â» Last generated: 2011-07-04 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveHit.html:5073,detect,detector,5073,root/html530/TEveHit.html,https://root.cern,https://root.cern/root/html530/TEveHit.html,2,['detect'],['detector']
Safety,"::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_tfDetIdCustom detector id.; Int_tfEvaLabelLabel of primary particle, ancestor of label.; Int_tfLabelLabel of particle that produced the hit.; UShort_tfSubdetIdCustom sub-detector id.; TEveVectorfVHit position. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveMCTrack& operator=(const TEveHit& ); { *((TParticle*)this) = p; return *this; }. TEveHit(); Float_t charge; probably specific. {}. virtual ~TEveHit(); {}. Â» Last changed: root/eve:$Id: TEveVSDStructs.h 38721 2011-04-04 13:37:12Z matevz $ Â» Last generated: 2011-11-03 20:12; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveHit.html:5073,detect,detector,5073,root/html532/TEveHit.html,https://root.cern,https://root.cern/root/html532/TEveHit.html,2,['detect'],['detector']
Safety,"::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_tfDetIdCustom detector id.; Int_tfLabel[3]Labels of particles that contributed hits.; UShort_tfSubdetIdCustom sub-detector id.; TEveVectorfVVertex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveMCTrack& operator=(const TEveCluster& ); { *((TParticle*)this) = p; return *this; }. TEveCluster(); TEveVector fW; // Cluster widths.; Coord system? Errors and/or widths Wz, Wy?. { fLabel[0] = fLabel[1] = fLabel[2] = 0; }. virtual ~TEveCluster(); {}. Â» Last changed: root/eve:$Id$ Â» Last generated: 2015-03-13 19:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveCluster.html:5128,detect,detector,5128,root/html534/TEveCluster.html,https://root.cern,https://root.cern/root/html534/TEveCluster.html,2,['detect'],['detector']
Safety,"::StorageTypeRooAbsData::defaultStorageType. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; TDirectory*RooDirItem::_dir! Associated directory; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool ; RooArgSetRooAbsData::_varsDimensions of this data set; RooArgSet_varsNoWgtVars without weight variable ; RooRealVar*_wgtVarPointer to weight variable (if set) ; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooDataSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooDataSet(); Default constructor for persistence. RooDataSet(const char* name, const char* title, const RooArgSet& vars, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Construct an unbinned dataset from a RooArgSet defining the dimensions of the dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDataSet.html:17819,avoid,avoid,17819,root/html532/RooDataSet.html,https://root.cern,https://root.cern/root/html532/RooDataSet.html,1,['avoid'],['avoid']
Safety,"::atomic< bool > fIsRunningWindow system specific application implementation.Definition TApplication.h:61; TApplication::NeedGraphicsLibsstatic void NeedGraphicsLibs()Static method.Definition TApplication.cxx:235; TApplication::ParseRemoteLinestatic Int_t ParseRemoteLine(const char *ln, TString &hostdir, TString &user, Int_t &dbg, TString &script)Parse the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1419; TApplication::fIdleTimerTTimer * fIdleTimerDefinition TApplication.h:69; TApplication::lsvoid ls(Option_t *option="""") const overrideShow available sessions.Definition TApplication.cxx:2087; TApplication::fArgcInt_t fArgcDefinition TApplication.h:58; TApplication::fNoLogBool_t fNoLogDefinition TApplication.h:63; TApplication::fNoLogoBool_t fNoLogoDefinition TApplication.h:64; TApplication::GetSetupTString GetSetup()It gets the ROOT installation setup as TString.Definition TApplication.cxx:967; TApplication::HandleIdleTimervirtual void HandleIdleTimer()Handle idle timeout.Definition TApplication.cxx:577; TApplication::ProcessRemotevirtual Longptr_t ProcessRemote(const char *line, Int_t *error=nullptr)Process the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1485; TApplication::fAppRemoteTApplication * fAppRemoteDefinition TApplication.h:80; TApplication::fArgvchar ** fArgvDefinition TApplication.h:59; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBrowser::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove obj from browser.Definition TBrowser.cxx:408; TBrowser::Addvoid Add(TObject *obj, const char *name=nullptr, Int_t check=-1)Add object with name to browser.Definition TBrowser.cxx:303; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTClass instances re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:94183,timeout,timeout,94183,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['timeout'],['timeout']
Safety,"::fOutput!List of objects created during processing; Long64_tTSelector::fStatusSelector status. private:. PyObject*fPySelf! actual python object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupPySelf(); Install the python side identity of the TPySelector. PyObject* CallSelf(const char* method, PyObject* pyobject = 0); Forward <method> to python. TPySelector(TTree* = 0, PyObject* self = 0); Construct a TSelector derived with <self> as the underlying, which is; generally 0 to start out with in the current PROOF framework. ~TPySelector(); Destructor. Only deref if still holding on to Py_None (circular otherwise). Int_t Version() const; Return version number of this selector. First forward; if not overridden, then; yield an obvious ""undefined"" number,. Int_t GetEntry(Long64_t entry, Int_t getall = 0); Boilerplate get entry; same as for generated code; not forwarded. void Init(TTree* tree); Initialize with the current tree to be used; not forwarded (may be called; multiple times, and is called from Begin() and SlaveBegin() ). Bool_t Notify(); Forward call to derived Notify() if available. void Begin(TTree* tree = 0); First function called, and used to setup the python self; forward call. void SlaveBegin(TTree* tree); First function called on worker node, needs to make sure python self is setup,; then store the tree to be used, initialize client, and forward call. Bool_t Process(Long64_t entry); Actual processing; call is forwarded to python self. void SlaveTerminate(); End of client; call is forwarded to python self. void Terminate(); End of job; call is forwarded to python self. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); If no 'why' given, read from python error. Â» Last changed: Sat Mar 14 16:47:59 2015 Â» Last generated: 2015-03-14 16:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPySelector.html:9784,Abort,Abort,9784,root/html534/TPySelector.html,https://root.cern,https://root.cern/root/html534/TPySelector.html,1,['Abort'],['Abort']
Safety,"::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title; TGeoVolumeAssembly*fVolumeassembly volume. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoShapeAssembly(); Default constructor. TGeoShapeAssembly(TGeoVolumeAssembly* vol); Constructor specifying hyperboloid parameters. ~TGeoShapeAssembly(); destructor. void ComputeBBox(); Compute bounding box of the assembly. void RecomputeBoxLast(); Recompute bounding box of the assembly after adding a node. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Should not be called. Bool_t Contains(const Double_t* point) const; Test if point is inside the assembly. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid.; fVolume->SetNextNodeIndex(-1);. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShapeAssembly.html:13019,safe,safe,13019,root/html534/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html534/TGeoShapeAssembly.html,3,['safe'],['safe']
Safety,"::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2(); dummy ctor. TGeoTrd2(Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy1; param[3] = dy2; param[4] = dz. ~TGeoTrd2(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd2. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd2; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd2; Boundary safe algorithm. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetVisibleCorner(const Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(const Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd2 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the gi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrd2.html:13739,safe,safe,13739,root/html534/TGeoTrd2.html,https://root.cern,https://root.cern/root/html534/TGeoTrd2.html,6,['safe'],['safe']
Safety,"::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDoubleSlider(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t type = 1, Int_t id = -1, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground(), Bool_t reversed = kFALSE, Bool_t mark_ends = kFALSE); Slider constructor. void FixBounds(Float_t& min, Float_t& max); Avoid boundaries to be equal. TString GetSString() const; Returns the slider type as a string - used in SavePrimitive(). void ChangeCursor(Event_t* event); Change the cursor shape depending on the slider area. TGDoubleSlider(const TGDoubleSlider& ). TGDoubleSlider& operator=(const TGDoubleSlider& ). virtual ~TGDoubleSlider(); { }. Bool_t HandleButton(Event_t* event). Bool_t HandleMotion(Event_t* event). void SetScale(Int_t scale); { fScale = scale; }. void SetRange(Float_t min, Float_t max). void SetPosition(Float_t min, Float_t max). Float_t GetMinPosition() const. Float_t GetMaxPosition() const. void GetPosition(Float_t& min, Float_t& max) const. void GetPosition(Float_t* min, Float_t* max) const. void MapSubwindows(); { TGWindow::MapSubwindows(); }. void PositionChanged(); { Emit(""PositionChanged()""); }. void Pressed(); { Emit(""Pressed()""); }. void Released(); { Emit(""Released()""); }. Â» Author: Reiner Rohlfs 30/09/98 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGDoubleSlider.html:21326,Avoid,Avoid,21326,root/html602/TGDoubleSlider.html,https://root.cern,https://root.cern/root/html602/TGDoubleSlider.html,2,['Avoid'],['Avoid']
Safety,"::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool; TNamed*RooAbsCollection::_structureTag! Structure tag; TNamed*RooAbsCollection::_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooArgSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void* operator new(size_t bytes, void* ptr); Overloaded new operator with placement does not guarante that all; RooArgSets allocated with new have a unique address, but uses the global; operator. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooArgSet(); Default constructor. RooArgSet(const RooArgList& list); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const RooArgList& list, const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooArgSet.html:15574,avoid,avoid,15574,root/html602/RooArgSet.html,https://root.cern,https://root.cern/root/html602/RooArgSet.html,2,['avoid'],['avoid']
Safety,"::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidReady(TSocket* sock)SIGNAL ; virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(TSocket* sock); virtual voidRemoveAll(); voidTObject::ResetBit(UInt_t f); voidResetInterrupt(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TSocket*Select(); TSocket*Select(Long_t timeout); Int_tSelect(TList* rdready, TList* wrready, Long_t timeout); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInterest(TSocket* sock, Int_t interest = kRead); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonitor.html:7460,timeout,timeout,7460,root/html530/TMonitor.html,https://root.cern,https://root.cern/root/html530/TMonitor.html,4,['timeout'],['timeout']
Safety,"::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TSSLSocket&operator=(const TSSLSocket&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tTSocket::Reconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); virtual Int_tTSocket::SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTSocket::SetCompressionAlgorithm(Int_t algorithm = 0); voidTSocket::SetCompressionLevel(Int_t level = 1); voidTSocket::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tTSocket::SetOption(ESockOptions opt, Int_t val); voidTSocket::SetRemoteProtocol(Int_t rproto); voidTSocke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSSLSocket.html:5554,timeout,timeout,5554,root/html602/TSSLSocket.html,https://root.cern,https://root.cern/root/html602/TSSLSocket.html,2,['timeout'],['timeout']
Safety,"::shared_ptr< RWebWindow >Â fMaster; Â ! master window where this window is embedded ; Â ; std::vector< MasterConn >Â fMasterConns; Â ! master connections ; Â ; unsignedÂ fMaxQueueLength {10}; Â ! maximal number of queue entries ; Â ; std::shared_ptr< RWebWindowsManager >Â fMgr; Â ! display manager ; Â ; boolÂ fNativeOnlyConn {false}; Â ! only native connection are allowed, created by Show() method ; Â ; floatÂ fOperationTmout {50.}; Â ! timeout in seconds to perform synchronous operation, default 50s ; Â ; std::stringÂ fPanelName; Â ! panel name which should be shown in the window ; Â ; ConnectionsList_tÂ fPendingConn; Â ! list of pending connection with pre-assigned keys ; Â ; boolÂ fProcessMT {false}; Â ! if window event processing performed in dedicated thread ; Â ; std::stringÂ fProtocol; Â ! protocol ; Â ; intÂ fProtocolCnt {-1}; Â ! counter for protocol recording ; Â ; unsignedÂ fProtocolConnId {0}; Â ! connection id, which is used for writing protocol ; Â ; std::stringÂ fProtocolFileName; Â ! local file where communication protocol will be written ; Â ; std::stringÂ fProtocolPrefix; Â ! prefix for created files names ; Â ; boolÂ fRequireAuthKey {true}; Â ! defines if authentication key always required when connect to the widget ; Â ; boolÂ fSendMT {false}; Â ! true is special threads should be used for sending data ; Â ; boolÂ fUseCurrentDir {false}; Â ! if window can access local files via currentdir/ path of http server ; Â ; boolÂ fUseProcessEvents {false}; Â ! all window functionality will run through process events ; Â ; std::stringÂ fUserArgs; Â ! arbitrary JSON code, which is accessible via conn.getUserArgs() method ; Â ; boolÂ fUseServerThreads {false}; Â ! indicates that server thread is using, no special window thread ; Â ; unsignedÂ fWidth {0}; Â ; std::threadÂ fWindowThrd; Â ! special thread for that window ; Â ; std::shared_ptr< RWebWindowWSHandler >Â fWSHandler; Â ! specialize websocket handler for all incoming connections ; Â ; intÂ fX {-1}; Â ; intÂ fY {-1}; Â ! initial window position, -1 ignored ; Â . Static Priv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:19828,timeout,timeout,19828,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,2,['timeout'],['timeout']
Safety,"::size_t len)Send binary data to specified connection.Definition RWebWindow.cxx:1630; ROOT::RWebWindow::fYint fY! initial window position, -1 ignoredDefinition RWebWindow.hxx:167; ROOT::RWebWindow::GetXint GetX() constreturns configured window X position (-1 - default)Definition RWebWindow.hxx:286; ROOT::RWebWindow::Createstatic std::shared_ptr< RWebWindow > Create()Create new RWebWindow Using default RWebWindowsManager.Definition RWebWindow.cxx:1883; ROOT::RWebWindow::fWidthunsigned fWidthDefinition RWebWindow.hxx:166; ROOT::RWebWindow::fClientVersionstd::string fClientVersion! configured client version, used as prefix in scripts URLDefinition RWebWindow.hxx:169; ROOT::RWebWindow::ProcessBatchHolderbool ProcessBatchHolder(std::shared_ptr< THttpCallArg > &arg)Process special http request, used to hold headless browser running Such requests should not be repli...Definition RWebWindow.cxx:374; ROOT::RWebWindow::SetOperationTmoutvoid SetOperationTmout(float tm=50.)Set timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:354; ROOT::RWebWindow::AddEmbedWindowunsigned AddEmbedWindow(std::shared_ptr< RWebWindow > window, unsigned connid, int channel)Add embed window.Definition RWebWindow.cxx:1846; ROOT::RWebWindow::SetDisconnectCallBackvoid SetDisconnectCallBack(WebWindowConnectCallback_t func)Set call-back function for disconnecting.Definition RWebWindow.cxx:1753; ROOT::RWebWindow::GetConnectionsstd::vector< unsigned > GetConnections(unsigned excludeid=0) constreturns vector with all existing connections ids One also can exclude specified connection from retur...Definition RWebWindow.cxx:1387; ROOT::RWebWindow::SetDataCallBackvoid SetDataCallBack(WebWindowDataCallback_t func)Set call-back function for data, received from the clients via websocket.Definition RWebWindow.cxx:1733; ROOT::RWebWindow::fOperationTmoutfloat fOperationTmout! timeout in seconds to perform synchronous operation, default 50sDefinition RWebWindow.hxx:168; ROOT::RWebWindow::fRequireAu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:30493,timeout,timeout,30493,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['timeout'],['timeout']
Safety,"::size_t len)Send binary data to specified connection.Definition RWebWindow.cxx:1672; ROOT::RWebWindow::fYint fY! initial window position, -1 ignoredDefinition RWebWindow.hxx:170; ROOT::RWebWindow::GetXint GetX() constreturns configured window X position (-1 - default)Definition RWebWindow.hxx:289; ROOT::RWebWindow::Createstatic std::shared_ptr< RWebWindow > Create()Create new RWebWindow Using default RWebWindowsManager.Definition RWebWindow.cxx:1925; ROOT::RWebWindow::fWidthunsigned fWidthDefinition RWebWindow.hxx:169; ROOT::RWebWindow::fClientVersionstd::string fClientVersion! configured client version, used as prefix in scripts URLDefinition RWebWindow.hxx:172; ROOT::RWebWindow::ProcessBatchHolderbool ProcessBatchHolder(std::shared_ptr< THttpCallArg > &arg)Process special http request, used to hold headless browser running Such requests should not be repli...Definition RWebWindow.cxx:375; ROOT::RWebWindow::SetOperationTmoutvoid SetOperationTmout(float tm=50.)Set timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:357; ROOT::RWebWindow::AddEmbedWindowunsigned AddEmbedWindow(std::shared_ptr< RWebWindow > window, unsigned connid, int channel)Add embed window.Definition RWebWindow.cxx:1888; ROOT::RWebWindow::SetDisconnectCallBackvoid SetDisconnectCallBack(WebWindowConnectCallback_t func)Set call-back function for disconnecting.Definition RWebWindow.cxx:1795; ROOT::RWebWindow::GetConnectionsstd::vector< unsigned > GetConnections(unsigned excludeid=0) constreturns vector with all existing connections ids One also can exclude specified connection from retur...Definition RWebWindow.cxx:1429; ROOT::RWebWindow::SetDataCallBackvoid SetDataCallBack(WebWindowDataCallback_t func)Set call-back function for data, received from the clients via websocket.Definition RWebWindow.cxx:1775; ROOT::RWebWindow::fOperationTmoutfloat fOperationTmout! timeout in seconds to perform synchronous operation, default 50sDefinition RWebWindow.hxx:171; ROOT::RWebWindow::fRequireAu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:30882,timeout,timeout,30882,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['timeout'],['timeout']
Safety,":; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; Â» GRAF3D; Â» GL; Â» TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes do not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLLogicalShape.html:1050,detect,detector,1050,root/html532/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html532/TGLLogicalShape.html,4,['detect'],['detector']
Safety,":; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; Â» GRAF3D; Â» GL; Â» TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLLogicalShape.html:1050,detect,detector,1050,root/html528/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html,2,['detect'],['detector']
Safety,":Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPara.html:2220,safe,safe,2220,root/html528/TGeoPara.html,https://root.cern,https://root.cern/root/html528/TGeoPara.html,3,['safe'],['safe']
Safety,":Browse(TBrowser* b); virtual Double_tTGeoBBox::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShapeAssembly.html:1857,safe,safe,1857,root/html528/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html528/TGeoShapeAssembly.html,1,['safe'],['safe']
Safety,":ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static voidTGeoCone::DistToCone(const Double_t* point, const Double_t* dir, Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoConeSeg.html:2833,safe,safe,2833,root/html534/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html,3,['safe'],['safe']
Safety,":ComputeNormalvirtual void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm)=0; TGeoShape::TestShapeBitsInt_t TestShapeBits(UInt_t f) constDefinition TGeoShape.h:168; TGeoShape::GetBuffer3Dvirtual const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) constStub implementation to avoid forcing implementation at this stage.Definition TGeoShape.cxx:735; TGeoShape::SetIdvoid SetId(Int_t id)Definition TGeoShape.h:155; TGeoShape::fShapeBitsUInt_t fShapeBitsDefinition TGeoShape.h:72; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoShape::GetAxisRangevirtual Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const =0; TGeoShape::GetBasicColorInt_t GetBasicColor() constGet the basic color (0-7).Definition TGeoShape.cxx:718; TGeoShape::DistFromInsidevirtual Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; TGeoShape::IsSegCrossingstatic Bool_t IsSegCrossing(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4)Check if segments (A,B) and (C,D) are crossing, where: A(x1,y1), B(x2,y2), C(x3,y3),...Definition TGeoShape.cxx:349; TGeoShape::CreateThreadDatavirtual void CreateThreadData(Int_t)Definition TGeoShape.h:67; TGeoShape::TransformPointsvoid TransformPoints(Double_t *points, UInt_t NbPoints) constTranform a set of points (LocalToMaster)Definition TGeoShape.cxx:590; TGeoShape::SetShapeBitvoid SetShapeBit(UInt_t f, Bool_t set)Equivalent of TObject::SetBit.Definition TGeoShape.cxx:562; TGeoShape::IsValidBool_t IsValid() constDefinition TGeoShape.h:143; TGeoShape::ResetShapeBitvoid ResetShapeBit(UInt_t f)Definition TGeoShape.h:166; TGeoShape::GetNmeshVerticesvirtual Int_t GetNmeshVertices() constDefinition TGeoShape.h:127; TGeoShape::GetMeshNumbersvirtual void GetMeshNumbers(Int_t &, Int_t &, Int_t &) constDefinition TGeoShape.h:125; TGeoShape::DistToPhiMinstatic Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoShape_8h_source.html:11599,safe,safe,11599,doc/master/TGeoShape_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html,1,['safe'],['safe']
Safety,":CopyTwist ; (; Double_t *Â ; twist = nullptr). protected . â—†Â DeclFileName(). static const char * TGeoArb8::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 93 of file TGeoArb8.h. â—†Â DistFromInside(). Double_t TGeoArb8::DistFromInside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoTrap, and TGeoGtra. â—†Â DistFromInside_v(). void TGeoArb8::DistFromInside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoShape.; Reimplemented in TGeoTrap, and TGeoGtra. â—†Â DistFromOutside(). Double_t TGeoArb8::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoTrap, and TGeoGtra. â—†Â DistFromOutside_v(). void TGeoArb8::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoShape.; Reimplemented in TGeoTrap, and TGeoGtra. â—†Â DistToPlane(). Double_t TGeoArb8::DistToPlane ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; ipl, . Bool_tÂ ; inÂ . ); const. â—†Â Divide(). TGeoVolume * TGeoArb8::Divide ; (; TGeoVolume *Â ; voldiv, . const char *Â ; divname, . Int_tÂ ; iaxis, . Int_tÂ ; ndiv, . Double_tÂ ; start, . Double_tÂ ; stepÂ . ). overridevirtual . Implements TGeoShape.; Reimplemented in TGeoTrap. â—†Â GetAxisRange(). Double_t TGeoArb8::GetAxisRange ; (; Int_tÂ ; iaxis, . Double_t &Â ; xlo, . Double_t &Â ; xhiÂ . ); const. overridevirtual . Implements TGeoShape. â—†Â GetBoundingCylinder(). void TGeoArb8::GetBoundingCylinder ; (; Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:28161,safe,safe,28161,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,1,['safe'],['safe']
Safety,":DistFromInside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoCone. â—†Â DistFromInside_v(). void TGeoConeSeg::DistFromInside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoCone. â—†Â DistFromInsideS(). static Double_t TGeoConeSeg::DistFromInsideS ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Double_tÂ ; dz, . Double_tÂ ; rmin1, . Double_tÂ ; rmax1, . Double_tÂ ; rmin2, . Double_tÂ ; rmax2, . Double_tÂ ; c1, . Double_tÂ ; s1, . Double_tÂ ; c2, . Double_tÂ ; s2, . Double_tÂ ; cm, . Double_tÂ ; sm, . Double_tÂ ; cdfiÂ . ). static . â—†Â DistFromOutside(). Double_t TGeoConeSeg::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoCone. â—†Â DistFromOutside_v(). void TGeoConeSeg::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoCone. â—†Â DistFromOutsideS(). static Double_t TGeoConeSeg::DistFromOutsideS ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Double_tÂ ; dz, . Double_tÂ ; rmin1, . Double_tÂ ; rmax1, . Double_tÂ ; rmin2, . Double_tÂ ; rmax2, . Double_tÂ ; c1, . Double_tÂ ; s1, . Double_tÂ ; c2, . Double_tÂ ; s2, . Double_tÂ ; cm, . Double_tÂ ; sm, . Double_tÂ ; cdfiÂ . ). static . â—†Â DistToCons(). static Double_t TGeoConeSeg::DistToCons ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Double_tÂ ; r1, . Double_tÂ ; z1, . Double_tÂ ; r2, . Double_tÂ ; z2, . Double_tÂ ; phi1, . Double_tÂ ; phi2Â . ). static . â—†Â Divide(). TGeoVolume * TGeoConeSeg::Divide ; (; TGeoVolume *Â ; voldiv, . const char *Â ; divname, . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoConeSeg.html:29793,safe,safe,29793,doc/master/classTGeoConeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoConeSeg.html,1,['safe'],['safe']
Safety,":EventDefinition Event.h:51; TMVA::Event::GetValueFloat_t GetValue(UInt_t ivar) constreturn value of i'th variableDefinition Event.cxx:236; TMVA::Event::GetWeightDouble_t GetWeight() constreturn the event weight - depending on whether the flag IgnoreNegWeightsInTraining is or not.Definition Event.cxx:389; TMVA::Event::GetClassUInt_t GetClass() constDefinition Event.h:86; TMVA::MsgLoggerostringstream derivative to redirect and format outputDefinition MsgLogger.h:57; TMVA::PDFPDF wrapper for histograms; uses user-defined spline interpolation.Definition PDF.h:63; TMVA::PDF::GetXminDouble_t GetXmin() constDefinition PDF.h:104; TMVA::PDF::GetXmaxDouble_t GetXmax() constDefinition PDF.h:105; TMVA::PDF::GetValDouble_t GetVal(Double_t x) constreturns value PDF(x)Definition PDF.cxx:701; TMVA::ToolsGlobal auxiliary applications and data treatment routines.Definition Tools.h:76; TMVA::Tools::ComputeStatvoid ComputeStat(const std::vector< TMVA::Event * > &, std::vector< Float_t > *, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Double_t &, Int_t signalClass, Bool_t norm=kFALSE)sanity checkDefinition Tools.cxx:202; TMVA::Tools::GetParentvoid * GetParent(void *child)get parent nodeDefinition Tools.cxx:1140; TMVA::Tools::FormattedOutputvoid FormattedOutput(const std::vector< Double_t > &, const std::vector< TString > &, const TString titleVars, const TString titleValues, MsgLogger &logger, TString format=""%+1.3f"")formatted output of simple tableDefinition Tools.cxx:887; TMVA::Tools::HistoHasEquidistantBinsBool_t HistoHasEquidistantBins(const TH1 &h)Definition Tools.cxx:1486; TMVA::Tools::ParseFormatLineTList * ParseFormatLine(TString theString, const char *sep="":"")Parse the string and cut into labels separated by "":"".Definition Tools.cxx:401; TMVA::Tools::NormVariableDouble_t NormVariable(Double_t x, Double_t xmin, Double_t xmax)normalise to output range: [-1, 1]Definition Tools.cxx:110; TMVA::Tools::WriteFloatArbitraryPrecisionvoid WriteFloatArbitraryPrecision(Float",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:72446,sanity check,sanity checkDefinition,72446,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['sanity check'],['sanity checkDefinition']
Safety,":Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); Double_tTGeoArb8::SafetyToFace(Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoArb8::SetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidTGeoArb8::SetPlaneVertices(Double_t zpl, Double_t* vertices) const; virtual voidTGeoArb8::SetPoints(Double_t* points) const; virtual voidTGeoArb8::SetPoints(Float_t* points) const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoGtra.html:9724,Safe,SafetyToFace,9724,root/html530/TGeoGtra.html,https://root.cern,https://root.cern/root/html530/TGeoGtra.html,4,['Safe'],['SafetyToFace']
Safety,":Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoArb8.html:9558,Safe,SafetyPhi,9558,root/html534/TGeoArb8.html,https://root.cern,https://root.cern/root/html534/TGeoArb8.html,1,['Safe'],['SafetyPhi']
Safety,":Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tTGeoArb8::SafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoArb8::SetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoGtra.html:10489,Safe,SafetyPhi,10489,root/html534/TGeoGtra.html,https://root.cern,https://root.cern/root/html534/TGeoGtra.html,2,['Safe'],['SafetyPhi']
Safety,":Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetCurrentVertices(Double_t x0, Double_t y0, Double_t scale); voidSetCurrentZ(Double_t z, Int_t iz); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoXtru.html:10149,Safe,SafetyPhi,10149,root/html534/TGeoXtru.html,https://root.cern,https://root.cern/root/html534/TGeoXtru.html,1,['Safe'],['SafetyPhi']
Safety,":RCsvDS which allows to read comma separated files:; 1373~~~{.cpp}; 1374auto tdf = ROOT::RDF::FromCSV(""MuRun2010B.csv"");; 1375auto filteredEvents =; 1376 tdf.Filter(""Q1 * Q2 == -1""); 1377 .Define(""m"", ""sqrt(pow(E1 + E2, 2) - (pow(px1 + px2, 2) + pow(py1 + py2, 2) + pow(pz1 + pz2, 2)))"");; 1378auto h = filteredEvents.Histo1D(""m"");; 1379h->Draw();; 1380~~~; 1381 ; 1382See also FromNumpy (Python-only), FromRNTuple(), FromArrow(), FromSqlite().; 1383 ; 1384\anchor callgraphs; 1385### Computation graphs (storing and reusing sets of transformations); 1386 ; 1387As we saw, transformed dataframes can be stored as variables and reused multiple times to create modified versions of the dataset. This implicitly defines a **computation graph** in which; 1388several paths of filtering/creation of columns are executed simultaneously, and finally aggregated results are produced.; 1389 ; 1390RDataFrame detects when several actions use the same filter or the same defined column, and **only evaluates each; 1391filter or defined column once per event**, regardless of how many times that result is used down the computation graph.; 1392Objects read from each column are **built once and never copied**, for maximum efficiency.; 1393When ""upstream"" filters are not passed, subsequent filters, temporary column expressions and actions are not evaluated,; 1394so it might be advisable to put the strictest filters first in the graph.; 1395 ; 1396\anchor representgraph; 1397### Visualizing the computation graph; 1398It is possible to print the computation graph from any node to obtain a [DOT (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) representation either on the standard output; 1399or in a file.; 1400 ; 1401Invoking the function ROOT::RDF::SaveGraph() on any node that is not the head node, the computation graph of the branch; 1402the node belongs to is printed. By using the head node, the entire computation graph is printed.; 1403 ; 1404Following there is an exampl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:80440,detect,detects,80440,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['detect'],['detects']
Safety,":RCsvDS which allows to read comma separated files:; 1413~~~{.cpp}; 1414auto tdf = ROOT::RDF::FromCSV(""MuRun2010B.csv"");; 1415auto filteredEvents =; 1416 tdf.Filter(""Q1 * Q2 == -1""); 1417 .Define(""m"", ""sqrt(pow(E1 + E2, 2) - (pow(px1 + px2, 2) + pow(py1 + py2, 2) + pow(pz1 + pz2, 2)))"");; 1418auto h = filteredEvents.Histo1D(""m"");; 1419h->Draw();; 1420~~~; 1421 ; 1422See also FromNumpy (Python-only), FromRNTuple(), FromArrow(), FromSqlite().; 1423 ; 1424\anchor callgraphs; 1425### Computation graphs (storing and reusing sets of transformations); 1426 ; 1427As we saw, transformed dataframes can be stored as variables and reused multiple times to create modified versions of the dataset. This implicitly defines a **computation graph** in which; 1428several paths of filtering/creation of columns are executed simultaneously, and finally aggregated results are produced.; 1429 ; 1430RDataFrame detects when several actions use the same filter or the same defined column, and **only evaluates each; 1431filter or defined column once per event**, regardless of how many times that result is used down the computation graph.; 1432Objects read from each column are **built once and never copied**, for maximum efficiency.; 1433When ""upstream"" filters are not passed, subsequent filters, temporary column expressions and actions are not evaluated,; 1434so it might be advisable to put the strictest filters first in the graph.; 1435 ; 1436\anchor representgraph; 1437### Visualizing the computation graph; 1438It is possible to print the computation graph from any node to obtain a [DOT (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) representation either on the standard output; 1439or in a file.; 1440 ; 1441Invoking the function ROOT::RDF::SaveGraph() on any node that is not the head node, the computation graph of the branch; 1442the node belongs to is printed. By using the head node, the entire computation graph is printed.; 1443 ; 1444Following there is an exampl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:82120,detect,detects,82120,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['detect'],['detects']
Safety,":SetROOTVersion ; (; const char *Â ; rv). inline . Definition at line 159 of file TSlave.h. â—†Â SetSessionTag(). void TSlave::SetSessionTag ; (; const char *Â ; st). inline . Definition at line 161 of file TSlave.h. â—†Â SetSocket(). void TSlave::SetSocket ; (; TSocket *Â ; s). inlineprotected . Definition at line 112 of file TSlave.h. â—†Â SetStatus(). virtual void TSlave::SetStatus ; (; Int_tÂ ; st). inlineprotectedvirtual . Definition at line 113 of file TSlave.h. â—†Â SetTXSlaveHook(). void TSlave::SetTXSlaveHook ; (; TSlave_tÂ ; xslavehook). static . Set hook to TXSlave ctor. ; Definition at line 665 of file TSlave.cxx. â—†Â SetupServ(). Int_t TSlave::SetupServ ; (; Int_tÂ ; stype, . const char *Â ; conffileÂ . ). virtual . Init a PROOF slave object. ; Called via the TSlave ctor. The Init method is technology specific and is overwritten by derived classes. ; Reimplemented in TSlaveLite.; Definition at line 178 of file TSlave.cxx. â—†Â StopProcess(). void TSlave::StopProcess ; (; Bool_tÂ ; abort, . Int_tÂ ; timeoutÂ . ). protectedvirtual . Sent stop/abort request to PROOF server. ; Definition at line 629 of file TSlave.cxx. â—†Â Streamer(). void TSlave::Streamer ; (; TBuffer &Â ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TSlaveLite. â—†Â StreamerNVirtual(). void TSlave::StreamerNVirtual ; (; TBuffer &Â ; ClassDef_StreamerNVirtual_b). inline . Definition at line 167 of file TSlave.h. â—†Â Touch(). virtual void TSlave::Touch ; (; ). inlinevirtual . Definition at line 165 of file TSlave.h. Friends And Related Symbol Documentation. â—†Â TProof. friend class TProof. friend . Definition at line 48 of file TSlave.h. â—†Â TProofLite. friend class TProofLite. friend . Definition at line 49 of file TSlave.h. â—†Â TSlaveLite. friend class TSlaveLite. friend . Definition at line 50 of file TSlave.h. â—†Â TXSlave. friend class TXSlave. friend . Definition at line 51 of file TSlave.h. Member Data Documentation. â—†Â fArchComp. TString TSlave::fArchComp. protected ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSlave.html:23653,timeout,timeout,23653,doc/master/classTSlave.html,https://root.cern,https://root.cern/doc/master/classTSlave.html,1,['timeout'],['timeout']
Safety,":operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTFile::Print(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tReadBuffer(char* buf, Int_t len); virtual Bool_tReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TWebFile.html:10856,Recover,Recover,10856,root/html532/TWebFile.html,https://root.cern,https://root.cern/root/html532/TWebFile.html,2,['Recover'],['Recover']
Safety,":operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTFile::Print(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tReadBuffer(char* buf, Int_t len); virtual Bool_tReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFAL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TWebFile.html:10440,Recover,Recover,10440,root/html528/TWebFile.html,https://root.cern,https://root.cern/root/html528/TWebFile.html,1,['Recover'],['Recover']
Safety,":operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTFile::Print(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tReadBuffer(char* buf, Int_t len); virtual Bool_tReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TWebFile.html:10629,Recover,Recover,10629,root/html530/TWebFile.html,https://root.cern,https://root.cern/root/html530/TWebFile.html,1,['Recover'],['Recover']
Safety,":operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTFile::Print(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tReadBuffer(char* buf, Int_t len); virtual Bool_tReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDCacheFile.html:11169,Recover,Recover,11169,root/html532/TDCacheFile.html,https://root.cern,https://root.cern/root/html532/TDCacheFile.html,1,['Recover'],['Recover']
Safety,":operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTFile::Print(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tReadBuffer(char* buf, Int_t len); virtual Bool_tReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDCacheFile.html:10753,Recover,Recover,10753,root/html528/TDCacheFile.html,https://root.cern,https://root.cern/root/html528/TDCacheFile.html,1,['Recover'],['Recover']
Safety,":operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTFile::Print(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tReadBuffer(char* buf, Int_t len); virtual Bool_tReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TDCacheFile.html:10942,Recover,Recover,10942,root/html530/TDCacheFile.html,https://root.cern,https://root.cern/root/html530/TDCacheFile.html,1,['Recover'],['Recover']
Safety,"; (; ). inlineprivate . Get the slot number for this threadID, make a slot if needed. ; Definition at line 338 of file TThreadedObject.hxx. â—†Â Merge(). template<class T > . std::shared_ptr< T > ROOT::TThreadedObject< T >::Merge ; (; TThreadedObjectUtils::MergeFunctionType< T >Â ; mergeFunction = TThreadedObjectUtils::MergeTObjects<T>). inline . Merge all the thread private objects. ; Can be called once: it does not create any new object but destroys the present bookkeping collapsing all objects into the one at slot 0. ; Definition at line 294 of file TThreadedObject.hxx. â—†Â operator->(). template<class T > . T * ROOT::TThreadedObject< T >::operator-> ; (; ). inline . Access the wrapped object and allow to call its methods. ; Definition at line 286 of file TThreadedObject.hxx. â—†Â SetAtSlot(). template<class T > . void ROOT::TThreadedObject< T >::SetAtSlot ; (; unsignedÂ ; i, . std::shared_ptr< T >Â ; vÂ . ). inline . Set the value of a particular slot. ; This method is thread-safe as long as concurrent calls access different slots (i.e. pass a different argument) and no thread accesses slot i via the arrow operator, so mixing usage of SetAtSlot with usage of the arrow operator can be dangerous. ; Definition at line 227 of file TThreadedObject.hxx. â—†Â SnapshotMerge(). template<class T > . std::unique_ptr< T > ROOT::TThreadedObject< T >::SnapshotMerge ; (; TThreadedObjectUtils::MergeFunctionType< T >Â ; mergeFunction = TThreadedObjectUtils::MergeTObjects<T>). inline . Merge all the thread private objects. ; Can be called many times. It does create a new instance of class T to represent the ""Sum"" object. This method is not thread safe: correct or acceptable behaviours depend on the nature of T and of the merging function. ; Definition at line 312 of file TThreadedObject.hxx. Member Data Documentation. â—†Â fDirectories. template<class T > . std::deque<TDirectory*> ROOT::TThreadedObject< T >::fDirectories. private . A TDirectory per slot. ; Definition at line 332 of file TThreadedOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html:8608,safe,safe,8608,doc/v632/classROOT_1_1TThreadedObject.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html,2,['safe'],['safe']
Safety,"; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Double_t *Â ; normÂ . ). overridevirtual . Reimplemented from TGeoBBox. â—†Â ComputeNormal_v(). void TGeoPara::ComputeNormal_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; norms, . Int_tÂ ; vecsizeÂ . ). overridevirtual . Reimplemented from TGeoBBox. â—†Â Contains(). Bool_t TGeoPara::Contains ; (; const Double_t *Â ; point); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Contains_v(). void TGeoPara::Contains_v ; (; const Double_t *Â ; points, . Bool_t *Â ; inside, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DeclFileName(). static const char * TGeoPara::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 85 of file TGeoPara.h. â—†Â DistFromInside(). Double_t TGeoPara::DistFromInside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromInside_v(). void TGeoPara::DistFromInside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside(). Double_t TGeoPara::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside_v(). void TGeoPara::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Divide(). TGeoVolume * TGeoPara::Divide ; (; TGeoVolume *Â ; voldiv, . const char *Â ; divname, . Int_tÂ ; iaxis, . Int_tÂ ; ndiv, . Double_tÂ ; start, . Double_tÂ ; stepÂ . ). overridevirtual . Reimpleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPara.html:24701,safe,safe,24701,doc/master/classTGeoPara.html,https://root.cern,https://root.cern/doc/master/classTGeoPara.html,1,['safe'],['safe']
Safety,"; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Double_t *Â ; normÂ . ). overridevirtual . Reimplemented from TGeoBBox. â—†Â ComputeNormal_v(). void TGeoTrd1::ComputeNormal_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; norms, . Int_tÂ ; vecsizeÂ . ). overridevirtual . Reimplemented from TGeoBBox. â—†Â Contains(). Bool_t TGeoTrd1::Contains ; (; const Double_t *Â ; point); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Contains_v(). void TGeoTrd1::Contains_v ; (; const Double_t *Â ; points, . Bool_t *Â ; inside, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DeclFileName(). static const char * TGeoTrd1::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 78 of file TGeoTrd1.h. â—†Â DistFromInside(). Double_t TGeoTrd1::DistFromInside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromInside_v(). void TGeoTrd1::DistFromInside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside(). Double_t TGeoTrd1::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside_v(). void TGeoTrd1::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Divide(). TGeoVolume * TGeoTrd1::Divide ; (; TGeoVolume *Â ; voldiv, . const char *Â ; divname, . Int_tÂ ; iaxis, . Int_tÂ ; ndiv, . Double_tÂ ; start, . Double_tÂ ; stepÂ . ). overridevirtual . Reimpleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd1.html:24460,safe,safe,24460,doc/master/classTGeoTrd1.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd1.html,1,['safe'],['safe']
Safety,"; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Double_t *Â ; normÂ . ). overridevirtual . Reimplemented from TGeoBBox. â—†Â ComputeNormal_v(). void TGeoTrd2::ComputeNormal_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; norms, . Int_tÂ ; vecsizeÂ . ). overridevirtual . Reimplemented from TGeoBBox. â—†Â Contains(). Bool_t TGeoTrd2::Contains ; (; const Double_t *Â ; point); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Contains_v(). void TGeoTrd2::Contains_v ; (; const Double_t *Â ; points, . Bool_t *Â ; inside, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DeclFileName(). static const char * TGeoTrd2::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 80 of file TGeoTrd2.h. â—†Â DistFromInside(). Double_t TGeoTrd2::DistFromInside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromInside_v(). void TGeoTrd2::DistFromInside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside(). Double_t TGeoTrd2::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside_v(). void TGeoTrd2::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Divide(). TGeoVolume * TGeoTrd2::Divide ; (; TGeoVolume *Â ; voldiv, . const char *Â ; divname, . Int_tÂ ; iaxis, . Int_tÂ ; ndiv, . Double_tÂ ; start, . Double_tÂ ; stepÂ . ). overridevirtual . Reimpleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd2.html:24577,safe,safe,24577,doc/master/classTGeoTrd2.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd2.html,1,['safe'],['safe']
Safety,"; ). inline . Definition at line 247 of file TGeoNavigator.h. â—†Â PopPath() [2/2]. Bool_t TGeoNavigator::PopPath ; (; Int_tÂ ; index). inline . Definition at line 255 of file TGeoNavigator.h. â—†Â PopPoint() [1/2]. Bool_t TGeoNavigator::PopPoint ; (; ). inline . Definition at line 264 of file TGeoNavigator.h. â—†Â PopPoint() [2/2]. Bool_t TGeoNavigator::PopPoint ; (; Int_tÂ ; index). inline . Definition at line 272 of file TGeoNavigator.h. â—†Â PushPath(). Int_t TGeoNavigator::PushPath ; (; Int_tÂ ; startlevel = 0). inline . Definition at line 246 of file TGeoNavigator.h. â—†Â PushPoint(). Int_t TGeoNavigator::PushPoint ; (; Int_tÂ ; startlevel = 0). inline . Definition at line 263 of file TGeoNavigator.h. â—†Â ResetAll(). void TGeoNavigator::ResetAll ; (; ). Reset the navigator. ; Definition at line 2708 of file TGeoNavigator.cxx. â—†Â ResetState(). void TGeoNavigator::ResetState ; (; ). Reset current state flags. ; Definition at line 1643 of file TGeoNavigator.cxx. â—†Â Safety(). Double_t TGeoNavigator::Safety ; (; Bool_tÂ ; inside = kFALSE). Compute safe distance from the current point. ; This represent the distance from POINT to the closest boundary. ; Definition at line 1689 of file TGeoNavigator.cxx. â—†Â SafetyOverlaps(). void TGeoNavigator::SafetyOverlaps ; (; ). protected . Compute safe distance from the current point within an overlapping node. ; Definition at line 1846 of file TGeoNavigator.cxx. â—†Â SearchNode(). TGeoNode * TGeoNavigator::SearchNode ; (; Bool_tÂ ; downwards = kFALSE, . const TGeoNode *Â ; skipnode = nullptrÂ . ). Returns the deepest node containing fPoint, which must be set a priori. ; Check if parallel world navigation is enabled ; Definition at line 1924 of file TGeoNavigator.cxx. â—†Â SetCheckingOverlaps(). void TGeoNavigator::SetCheckingOverlaps ; (; Bool_tÂ ; flag = kTRUE). inline . Definition at line 147 of file TGeoNavigator.h. â—†Â SetCldirChecked(). void TGeoNavigator::SetCldirChecked ; (; Double_t *Â ; dir). inline . Definition at line 193 of file TGeoNavigator.h. â—†Â SetCur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:41337,Safe,Safety,41337,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['Safe'],['Safety']
Safety,"; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 54 of file TGeoShapeAssembly.h. â—†Â NeedsBBoxRecompute(). void TGeoShapeAssembly::NeedsBBoxRecompute ; (; ). inline . Definition at line 55 of file TGeoShapeAssembly.h. â—†Â RecomputeBoxLast(). void TGeoShapeAssembly::RecomputeBoxLast ; (; ). Recompute bounding box of the assembly after adding a node. ; Definition at line 114 of file TGeoShapeAssembly.cxx. â—†Â Safety(). Double_t TGeoShapeAssembly::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . computes the closest distance from given point to this shape, according to option. ; The matching point on the shape is stored in spoint. ; Reimplemented from TGeoBBox.; Definition at line 476 of file TGeoShapeAssembly.cxx. â—†Â Safety_v(). void TGeoShapeAssembly::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Compute safe distance from each of the points in the input array. ; Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values ; Reimplemented from TGeoBBox.; Definition at line 617 of file TGeoShapeAssembly.cxx. â—†Â SavePrimitive(). void TGeoShapeAssembly::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Definition at line 542 of file TGeoShapeAssembly.cxx. â—†Â SetPoints() [1/2]. void TGeoShapeAssembly::SetPoints ; (; Double_t *Â ; points); const. overridevirtual . No mesh for assemblies. ; Reimplemented from TGeoBBox.; Definition at line 547 of file TGeoShapeAssembly.cxx. â—†Â SetPoints() [2/2]. void TGeoShapeAssembly::SetPoints ; (; Float_t *Â ; points); const. overridevirtual . No mesh for assemblies. ; Reimplemented from TGeoBBox.; Definition at line 555 of file TGeoShapeAssembly.cxx. â—†Â SetSegsAndPols(). void TGeoShapeAssembly::SetSeg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShapeAssembly.html:30711,safe,safe,30711,doc/master/classTGeoShapeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoShapeAssembly.html,1,['safe'],['safe']
Safety,"; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. â—†Â IsA(). TClass * TGeoPcon::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon.; Definition at line 109 of file TGeoPcon.h. â—†Â IsCylType(). Bool_t TGeoPcon::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 91 of file TGeoPcon.h. â—†Â MakeBuffer3D(). TBuffer3D * TGeoPcon::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. â—†Â operator=(). TGeoPcon & TGeoPcon::operator= ; (; const TGeoPcon &Â ; ). protecteddelete . â—†Â Phi1(). Double_t & TGeoPcon::Phi1 ; (; ). inline . Definition at line 93 of file TGeoPcon.h. â—†Â Rmax(). Double_t & TGeoPcon::Rmax ; (; Int_tÂ ; ipl). inline . Definition at line 96 of file TGeoPcon.h. â—†Â Rmin(). Double_t & TGeoPcon::Rmin ; (; Int_tÂ ; ipl). inline . Definition at line 95 of file TGeoPcon.h. â—†Â Safety(). Double_t TGeoPcon::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. â—†Â Safety_v(). void TGeoPcon::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. â—†Â SafetyToSegment(). Double_t TGeoPcon::SafetyToSegment ; (; const Double_t *Â ; point, . Int_tÂ ; ipl, . Bool_tÂ ; in = kTRUE, . Double_tÂ ; safmin = TGeoShape::Big()Â . ); const. â—†Â SavePrimitive(). void TGeoPcon::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. â—†Â SetDimensions(). void TGeoPcon::SetDimensions ; (; Double_t *Â ; param). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. â—†Â SetPoints() [1/2]. void TGeoPc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPcon.html:31452,Safe,Safety,31452,doc/master/classTGeoPcon.html,https://root.cern,https://root.cern/doc/master/classTGeoPcon.html,1,['Safe'],['Safety']
Safety,"; , kAbortProcess; , kAbortFile; }; Â ; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; Â Â kBitMask = 0x00ffffff. }; Â ; enum Â { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; Â ; enum Â EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); }; Â ; enum Â EStatusBits { ; Â Â kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ; Â Â kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â ; Â Protected Member Functions inherited from TObject; virtual voidÂ DoError (int level, const char *location, const char *fmt, va_list va) const; Â Interface to ErrorHandler (protected). ; Â ; voidÂ MakeZombie (); Â ; Â Protected Attributes inherited from TSelector; EAbortÂ fAbort; Â Abort status. ; Â ; TList *Â fInput; Â List of objects available during processing. ; Â ; TObject *Â fObject; Â ! Current object if processing object (vs. TTree) ; Â ; TStringÂ fOption; Â Option given to TTree::Process. ; Â ; TSelectorList *Â fOutput; Â ! List of objects created during processing ; Â ; Long64_tÂ fStatus; Â Selector status. ; Â . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/h1analysis.h>. Inheritance diagram for h1analysis:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. â—†Â h1analysis(). h1analysis::h1analysis ; (; TTree *Â ; tree = nullptr). Definition at line 369 of file h1analysis.h. â—†Â ~h1analysis(). h1analysis::~h1analysis ; (; ). inlineoverride . Definition at line 345 of file h1analysis.h. Member Function Documentation. â—†Â Begin(). void h1analysis::Begin ; (; TTree *Â ; tree). overridevirtual . Reimplem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classh1analysis.html:18887,Abort,Abort,18887,doc/master/classh1analysis.html,https://root.cern,https://root.cern/doc/master/classh1analysis.html,1,['Abort'],['Abort']
Safety,"; , kAbortProcess; , kAbortFile; }; Â ; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; Â Â kBitMask = 0x00ffffff. }; Â ; enum Â { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; Â ; enum Â EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); }; Â ; enum Â EStatusBits { ; Â Â kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ; Â Â kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â ; Â Protected Member Functions inherited from TObject; virtual voidÂ DoError (int level, const char *location, const char *fmt, va_list va) const; Â Interface to ErrorHandler (protected). ; Â ; voidÂ MakeZombie (); Â ; Â Protected Attributes inherited from TSelector; EAbortÂ fAbort; Â Abort status. ; Â ; TList *Â fInput; Â List of objects available during processing. ; Â ; TObject *Â fObject; Â ! Current object if processing object (vs. TTree) ; Â ; TStringÂ fOption; Â Option given to TTree::Process. ; Â ; TSelectorList *Â fOutput; Â ! List of objects created during processing ; Â ; Long64_tÂ fStatus; Â Selector status. ; Â . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/h1analysisTreeReader.h>. Inheritance diagram for h1analysisTreeReader:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. â—†Â h1analysisTreeReader(). h1analysisTreeReader::h1analysisTreeReader ; (; TTree *Â ; = nullptr). inline . Definition at line 40 of file h1analysisTreeReader.h. â—†Â ~h1analysisTreeReader(). h1analysisTreeReader::~h1analysisTreeReader ; (; ). inlineoverride . Definition at line 61 of file h1analysisTreeReader.h. Member Func",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classh1analysisTreeReader.html:13017,Abort,Abort,13017,doc/master/classh1analysisTreeReader.html,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html,1,['Abort'],['Abort']
Safety,"; , kAbortProcess; , kAbortFile; }; Â ; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; Â Â kBitMask = 0x00ffffff. }; Â ; enum Â { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; Â ; enum Â EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); }; Â ; enum Â EStatusBits { ; Â Â kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ; Â Â kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â ; Â Protected Member Functions inherited from TObject; virtual voidÂ DoError (int level, const char *location, const char *fmt, va_list va) const; Â Interface to ErrorHandler (protected). ; Â ; voidÂ MakeZombie (); Â ; Â Protected Attributes inherited from TSelector; EAbortÂ fAbort; Â Abort status. ; Â ; TList *Â fInput; Â List of objects available during processing. ; Â ; TObject *Â fObject; Â ! Current object if processing object (vs. TTree) ; Â ; TStringÂ fOption; Â Option given to TTree::Process. ; Â ; TSelectorList *Â fOutput; Â ! List of objects created during processing ; Â ; Long64_tÂ fStatus; Â Selector status. ; Â . #include <RooProofDriverSelector.h>. Inheritance diagram for RooProofDriverSelector:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. â—†Â RooProofDriverSelector(). RooProofDriverSelector::RooProofDriverSelector ; (; TTree *Â ; = nullptr). inline . Definition at line 26 of file RooProofDriverSelector.h. Member Function Documentation. â—†Â Class(). static TClass * RooProofDriverSelector::Class ; (; ). static . ReturnsTClass describing this class . â—†Â Class_Name(). static const char * RooProofDriverSelector::Class_Name ; (; ). static . ReturnsN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProofDriverSelector.html:12432,Abort,Abort,12432,doc/master/classRooProofDriverSelector.html,https://root.cern,https://root.cern/doc/master/classRooProofDriverSelector.html,1,['Abort'],['Abort']
Safety,"; , kAbortProcess; , kAbortFile; }; Â ; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; Â Â kBitMask = 0x00ffffff. }; Â ; enum Â { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; Â ; enum Â EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); }; Â ; enum Â EStatusBits { ; Â Â kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ; Â Â kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â ; Â Protected Member Functions inherited from TObject; virtual voidÂ DoError (int level, const char *location, const char *fmt, va_list va) const; Â Interface to ErrorHandler (protected). ; Â ; voidÂ MakeZombie (); Â ; Â Protected Attributes inherited from TSelector; EAbortÂ fAbort; Â Abort status. ; Â ; TList *Â fInput; Â List of objects available during processing. ; Â ; TObject *Â fObject; Â ! Current object if processing object (vs. TTree) ; Â ; TStringÂ fOption; Â Option given to TTree::Process. ; Â ; TSelectorList *Â fOutput; Â ! List of objects created during processing ; Â ; Long64_tÂ fStatus; Â Selector status. ; Â . #include <TSelEvent.h>. Inheritance diagram for TSelEvent:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. â—†Â TSelEvent() [1/2]. TSelEvent::TSelEvent ; (; TTree *Â ; ). Constructor. ; Definition at line 48 of file TSelEvent.cxx. â—†Â TSelEvent() [2/2]. TSelEvent::TSelEvent ; (; ). Constructor. ; Definition at line 63 of file TSelEvent.cxx. â—†Â ~TSelEvent(). virtual TSelEvent::~TSelEvent ; (; ). inlinevirtual . Definition at line 104 of file TSelEvent.h. Member Function Documentation. â—†Â Begin(). void TSelEvent::Begin ; (; TTree *Â ; ). virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelEvent.html:14060,Abort,Abort,14060,doc/master/classTSelEvent.html,https://root.cern,https://root.cern/doc/master/classTSelEvent.html,1,['Abort'],['Abort']
Safety,"; , kAbortProcess; , kAbortFile; }; Â ; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; Â Â kBitMask = 0x00ffffff. }; Â ; enum Â { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; Â ; enum Â EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); }; Â ; enum Â EStatusBits { ; Â Â kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ; Â Â kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â ; Â Protected Member Functions inherited from TObject; virtual voidÂ DoError (int level, const char *location, const char *fmt, va_list va) const; Â Interface to ErrorHandler (protected). ; Â ; voidÂ MakeZombie (); Â ; Â Protected Attributes inherited from TSelector; EAbortÂ fAbort; Â Abort status. ; Â ; TList *Â fInput; Â List of objects available during processing. ; Â ; TObject *Â fObject; Â ! Current object if processing object (vs. TTree) ; Â ; TStringÂ fOption; Â Option given to TTree::Process. ; Â ; TSelectorList *Â fOutput; Â ! List of objects created during processing ; Â ; Long64_tÂ fStatus; Â Selector status. ; Â . #include <TSelHandleDataSet.h>. Inheritance diagram for TSelHandleDataSet:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. â—†Â TSelHandleDataSet(). TSelHandleDataSet::TSelHandleDataSet ; (; ). inline . Definition at line 42 of file TSelHandleDataSet.h. â—†Â ~TSelHandleDataSet(). TSelHandleDataSet::~TSelHandleDataSet ; (; ). inlineoverride . Definition at line 43 of file TSelHandleDataSet.h. Member Function Documentation. â—†Â Begin(). void TSelHandleDataSet::Begin ; (; TTree *Â ; ). inlineoverridevirtual . Reimplemented from TSelector.; Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelHandleDataSet.html:12620,Abort,Abort,12620,doc/master/classTSelHandleDataSet.html,https://root.cern,https://root.cern/doc/master/classTSelHandleDataSet.html,1,['Abort'],['Abort']
Safety,"; , kAbortProcess; , kAbortFile; }; Â ; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; Â Â kBitMask = 0x00ffffff. }; Â ; enum Â { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; Â ; enum Â EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); }; Â ; enum Â EStatusBits { ; Â Â kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ; Â Â kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â ; Â Protected Member Functions inherited from TObject; virtual voidÂ DoError (int level, const char *location, const char *fmt, va_list va) const; Â Interface to ErrorHandler (protected). ; Â ; voidÂ MakeZombie (); Â ; Â Protected Attributes inherited from TSelector; EAbortÂ fAbort; Â Abort status. ; Â ; TList *Â fInput; Â List of objects available during processing. ; Â ; TObject *Â fObject; Â ! Current object if processing object (vs. TTree) ; Â ; TStringÂ fOption; Â Option given to TTree::Process. ; Â ; TSelectorList *Â fOutput; Â ! List of objects created during processing ; Â ; Long64_tÂ fStatus; Â Selector status. ; Â . #include <TSelHist.h>. Inheritance diagram for TSelHist:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. â—†Â TSelHist(). TSelHist::TSelHist ; (; ). Constructor. ; Definition at line 45 of file TSelHist.cxx. â—†Â ~TSelHist(). TSelHist::~TSelHist ; (; ). override . Destructor. ; Definition at line 54 of file TSelHist.cxx. Member Function Documentation. â—†Â Begin(). void TSelHist::Begin ; (; TTree *Â ; tree). overridevirtual . The Begin() function is called at the start of the query. ; When running with PROOF Begin() is only called on the clien",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelHist.html:12667,Abort,Abort,12667,doc/master/classTSelHist.html,https://root.cern,https://root.cern/doc/master/classTSelHist.html,1,['Abort'],['Abort']
Safety,"; , kAbortProcess; , kAbortFile; }; Â ; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; Â Â kBitMask = 0x00ffffff. }; Â ; enum Â { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; Â ; enum Â EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); }; Â ; enum Â EStatusBits { ; Â Â kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ; Â Â kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â ; Â Protected Member Functions inherited from TObject; virtual voidÂ DoError (int level, const char *location, const char *fmt, va_list va) const; Â Interface to ErrorHandler (protected). ; Â ; voidÂ MakeZombie (); Â ; Â Protected Attributes inherited from TSelector; EAbortÂ fAbort; Â Abort status. ; Â ; TList *Â fInput; Â List of objects available during processing. ; Â ; TObject *Â fObject; Â ! Current object if processing object (vs. TTree) ; Â ; TStringÂ fOption; Â Option given to TTree::Process. ; Â ; TSelectorList *Â fOutput; Â ! List of objects created during processing ; Â ; Long64_tÂ fStatus; Â Selector status. ; Â . #include <TSelVerifyDataSet.h>. Inheritance diagram for TSelVerifyDataSet:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. â—†Â TSelVerifyDataSet() [1/2]. TSelVerifyDataSet::TSelVerifyDataSet ; (; TTree *Â ; ). Constructor. ; Definition at line 41 of file TSelVerifyDataSet.cxx. â—†Â TSelVerifyDataSet() [2/2]. TSelVerifyDataSet::TSelVerifyDataSet ; (; ). Constructor. ; Definition at line 49 of file TSelVerifyDataSet.cxx. â—†Â ~TSelVerifyDataSet(). TSelVerifyDataSet::~TSelVerifyDataSet ; (; ). inlineoverride . Definition at line 73 of file TSelV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelVerifyDataSet.html:12681,Abort,Abort,12681,doc/master/classTSelVerifyDataSet.html,https://root.cern,https://root.cern/doc/master/classTSelVerifyDataSet.html,1,['Abort'],['Abort']
Safety,"; , kAbortProcess; , kAbortFile; }; Â ; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; Â Â kBitMask = 0x00ffffff. }; Â ; enum Â { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; Â ; enum Â EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); }; Â ; enum Â EStatusBits { ; Â Â kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ; Â Â kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â ; Â Protected Member Functions inherited from TObject; virtual voidÂ DoError (int level, const char *location, const char *fmt, va_list va) const; Â Interface to ErrorHandler (protected). ; Â ; voidÂ MakeZombie (); Â ; Â Protected Attributes inherited from TSelector; EAbortÂ fAbort; Â Abort status. ; Â ; TList *Â fInput; Â List of objects available during processing. ; Â ; TObject *Â fObject; Â ! Current object if processing object (vs. TTree) ; Â ; TStringÂ fOption; Â Option given to TTree::Process. ; Â ; TSelectorList *Â fOutput; Â ! List of objects created during processing ; Â ; Long64_tÂ fStatus; Â Selector status. ; Â . #include <TSelectorEntries.h>. Inheritance diagram for TSelectorEntries:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. â—†Â TSelectorEntries() [1/2]. TSelectorEntries::TSelectorEntries ; (; TTree *Â ; tree = nullptr, . const char *Â ; selection = nullptrÂ . ). Default, constructor. ; Definition at line 46 of file TSelectorEntries.cxx. â—†Â TSelectorEntries() [2/2]. TSelectorEntries::TSelectorEntries ; (; const char *Â ; selection). Constructor. ; Definition at line 57 of file TSelectorEntries.cxx. â—†Â ~TSelectorEntries(). TSelectorEntries::~TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelectorEntries.html:13947,Abort,Abort,13947,doc/master/classTSelectorEntries.html,https://root.cern,https://root.cern/doc/master/classTSelectorEntries.html,1,['Abort'],['Abort']
Safety,"; - Xvtx array [nxy] of X coordinates of vertices; - Yvtx array [nxy] of Y coordinates of vertices; - z array [nz] of z plane positions; - scale array [nz] of scale factors; - x0 array [nz] of x offsets; - y0 array [nz] of y offsets. Author: R. Hatcher 2000.04.21. All XTRU shapes are correctly rendered in wire mode but can encounter; difficulty when rendered as a solid with hidden surfaces. These; exceptions occur if the outline shape is not a convex polygon.; Both the X3D and OpenGL renderers expect polygons to be convex.; The OpenGL spec specifies that points defining a polygon using the; GL_POLYGON primitive may be rendered as the convex hull of that set. Solid rendering under X3D can also give unexpected artifacts if; the combination of x-y-z offsets and scales for the segments are; chosen in such a manner that they represent a concave shape when; sliced along a plane parallel to the z axis. Choosing sets of point that represent a malformed polygon is; not supported, but testing for such a condition is not implemented; and thus it is left to the user to avoid this mistake. . Function Members (Methods); public:. TXTRU(); TXTRU(const TXTRU& xtru); TXTRU(const char* name, const char* title, const char* material, Int_t nyx, Int_t nz); virtual~TXTRU(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& xtru) const; virtual voidDefineSection(Int_t secNum, Float_t z, Float_t scale = 1., Float_t x0 = 0., Float_t y0 = 0.); virtual voidDefineVertex(Int_t pointNum, Float_t x, Float_t y); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXTRU.html:2042,avoid,avoid,2042,root/html528/TXTRU.html,https://root.cern,https://root.cern/root/html528/TXTRU.html,4,['avoid'],['avoid']
Safety,"; - Xvtx array [nxy] of X coordinates of vertices; - Yvtx array [nxy] of Y coordinates of vertices; - z array [nz] of z plane positions; - scale array [nz] of scale factors; - x0 array [nz] of x offsets; - y0 array [nz] of y offsets. Author: R. Hatcher 2000.04.21. All XTRU shapes are correctly rendered in wire mode but can encounter; difficulty when rendered as a solid with hidden surfaces. These; exceptions occur if the outline shape is not a convex polygon.; Both the X3D and OpenGL renderers expect polygons to be convex.; The OpenGL spec specifies that points defining a polygon using the; GL_POLYGON primitive may be rendered as the convex hull of that set. Solid rendering under X3D can also give unexpected artifacts if; the combination of x-y-z offsets and scales for the segments are; chosen in such a manner that they represent a concave shape when; sliced along a plane parallel to the z axis. Choosing sets of point that represent a malformed polygon is; not supported, but testing for such a condition is not implemented; and thus it is left to the user to avoid this mistake. . Function Members (Methods); public:. virtual~TXTRU(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& xtru) const; virtual voidDefineSection(Int_t secNum, Float_t z, Float_t scale = 1., Float_t x0 = 0., Float_t y0 = 0.); virtual voidDefineVertex(Int_t pointNum, Float_t x, Float_t y); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXTRU.html:2066,avoid,avoid,2066,root/html602/TXTRU.html,https://root.cern,https://root.cern/root/html602/TXTRU.html,2,['avoid'],['avoid']
Safety,"; . Â . Loading...; Searching...; No Matches. statsEditing.C File ReferenceTutorials Â» Histograms tutorials. Detailed Description; Edit statistics box. ; This example shows:; how to remove a stat element from the stat box; how to add a new one. ; TCanvas *statsEditing() {; // Create and plot a test histogram with stats; TCanvas *se = new TCanvas;; TH1F *h = new TH1F(""h"",""test"",100,-3,3);; h->FillRandom(""gaus"",3000);; gStyle->SetOptStat();; h->Draw();; se->Update();; ; // Retrieve the stat box; TPaveStats *ps = (TPaveStats*)se->GetPrimitive(""stats"");; ps->SetName(""mystats"");; TList *listOfLines = ps->GetListOfLines();; ; // Remove the RMS line; TText *tconst = ps->GetLineWith(""RMS"");; listOfLines->Remove(tconst);; ; // Add a new line in the stat box.; // Note that ""="" is a control character; TLatex *myt = new TLatex(0,0,""Test = 10"");; myt ->SetTextFont(42);; myt ->SetTextSize(0.04);; myt ->SetTextColor(kRed);; listOfLines->Add(myt);; ; // the following line is needed to avoid that the automatic redrawing of stats; h->SetStats(0);; ; se->Modified();; return se;; }; h#define h(i)Definition RSha256.hxx:106; kRed@ kRedDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::Updatevoid Update() overrideUpdate canvas pad buffers.Definition TCanvas.cxx:2489; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/statsEditing_8C.html:1073,avoid,avoid,1073,doc/master/statsEditing_8C.html,https://root.cern,https://root.cern/doc/master/statsEditing_8C.html,1,['avoid'],['avoid']
Safety,"; // NOLINT: silence clang-tidy warnings; 559}; 560 ; 561////////////////////////////////////////////////////////////////////////////////; 562/// File destructor.; 563 ; 564TFile::~TFile(); 565{; 566 Close(); // NOLINT: silence clang-tidy warnings; 567 ; 568 // In case where the TFile is still open at 'tear-down' time the order of operation will be; 569 // call Close(""nodelete""); 570 // then later call delete TFile; 571 // which means that at this point we might still have object held and those; 572 // might requires a 'valid' TFile object in their desctructor (for example,; 573 // TTree call's GetReadCache which expects a non-null fCacheReadMap).; 574 // So delete the objects (if any) now.; 575 ; 576 if (fList); 577 fList->Delete(""slow"");; 578 ; 579 SafeDelete(fAsyncHandle);; 580 SafeDelete(fCacheRead);; 581 SafeDelete(fCacheReadMap);; 582 SafeDelete(fCacheWrite);; 583 SafeDelete(fProcessIDs);; 584 SafeDelete(fFree);; 585 SafeDelete(fArchive);; 586 SafeDelete(fInfoCache);; 587 SafeDelete(fOpenPhases);; 588 ; 589 if (fGlobalRegistration) {; 590 R__LOCKGUARD(gROOTMutex);; 591 gROOT->GetListOfClosedObjects()->Remove(this);; 592 gROOT->GetUUIDs()->RemoveUUID(GetUniqueID());; 593 }; 594 ; 595 if (IsOnHeap()) {; 596 // Delete object from CINT symbol table so it can not be used anymore.; 597 // CINT object are always on the heap.; 598 gInterpreter->ResetGlobalVar(this);; 599 }; 600 ; 601 if (gDebug); 602 Info(""~TFile"", ""dtor called for %s [%zx]"", GetName(),(size_t)this);; 603}; 604 ; 605////////////////////////////////////////////////////////////////////////////////; 606/// Initialize a TFile object.; 607///; 608/// \param[in] create Create a new file.; 609///; 610/// TFile implementations providing asynchronous open functionality need to; 611/// override this method to run the appropriate checks before calling this; 612/// standard initialization part. See TNetXNGFile::Init for an example.; 613 ; 614void TFile::Init(Bool_t create); 615{; 616 if (fInitDone); 617 // Alread",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:21809,Safe,SafeDelete,21809,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,9,['Safe'],['SafeDelete']
Safety,"; // this is signal; 243 varVecB[nEventsB++] = theVar; // this is background; 244 }; 245 ; 246 if (theVar > xmax) xmax = theVar;; 247 if (theVar < xmin) xmin = theVar;; 248 }; 249 // ++nEventsS;; 250 // ++nEventsB;; 251 ; 252 // basic statistics; 253 // !!! TMath::Mean allows for weights, but NOT for negative weights; 254 // and TMath::RMS doesn't allow for weights all together...; 255 meanS = TMVA::Tools::Mean( nEventsS, varVecS, wgtVecS );; 256 meanB = TMVA::Tools::Mean( nEventsB, varVecB, wgtVecB );; 257 rmsS = TMVA::Tools::RMS ( nEventsS, varVecS, wgtVecS );; 258 rmsB = TMVA::Tools::RMS ( nEventsB, varVecB, wgtVecB );; 259 ; 260 delete [] varVecS;; 261 delete [] varVecB;; 262 delete [] wgtVecS;; 263 delete [] wgtVecB;; 264}; 265 ; 266////////////////////////////////////////////////////////////////////////////////; 267/// square-root of symmetric matrix; 268/// of course the resulting sqrtMat is also symmetric, but it's easier to; 269/// treat it as a general matrix; 270 ; 271TMatrixD* TMVA::Tools::GetSQRootMatrix( TMatrixDSym* symMat ); 272{; 273 Int_t n = symMat->GetNrows();; 274 ; 275 // compute eigenvectors; 276 TMatrixDSymEigen* eigen = new TMatrixDSymEigen( *symMat );; 277 ; 278 // D = ST C S; 279 TMatrixD* si = new TMatrixD( eigen->GetEigenVectors() );; 280 TMatrixD* s = new TMatrixD( *si ); // copy; 281 si->Transpose( *si ); // invert (= transpose); 282 ; 283 // diagonal matrices; 284 TMatrixD* d = new TMatrixD( n, n);; 285 d->Mult( (*si), (*symMat) ); (*d) *= (*s);; 286 ; 287 // sanity check: matrix must be diagonal and positive definit; 288 Int_t i, j;; 289 Double_t epsilon = 1.0e-8;; 290 for (i=0; i<n; i++) {; 291 for (j=0; j<n; j++) {; 292 if ((i != j && TMath::Abs((*d)(i,j))/TMath::Sqrt((*d)(i,i)*(*d)(j,j)) > epsilon) ||; 293 (i == j && (*d)(i,i) < 0)) {; 294 //d->Print();; 295 Log() << kWARNING << ""<GetSQRootMatrix> error in matrix diagonalization; printed S and B"" << Endl;; 296 }; 297 }; 298 }; 299 ; 300 // make exactly diagonal; 301 for (i=0; i<n; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:9958,sanity check,sanity check,9958,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['sanity check'],['sanity check']
Safety,"; 10 *************************************************************************/; 11 ; 12/**; 13\class TKey; 14\ingroup IO; 15 ; 16 Book space in a file, create I/O buffers, to fill them, (un)compress them.; 17 ; 18 The TKey class includes functions to book space in a file, to create I/O; 19 buffers, to fill these buffers, to compress/uncompress data buffers.; 20 Before saving (making persistent) an object in a file, a key must; 21 be created. The key structure contains all the information to; 22 uniquely identify a persistent object in a file.; 23 | Data Member | Explanation |; 24 |-------------|-------------|; 25 | fNbytes | Number of bytes for the compressed object and key. |; 26 | fObjlen | Length of uncompressed object. |; 27 | fDatime | Date/Time when the object was written. |; 28 | fKeylen | Number of bytes for the key structure. |; 29 | fCycle | Cycle number of the object. |; 30 | fSeekKey | Address of the object on file (points to fNbytes). This is a redundant information used to cross-check the data base integrity. |; 31 | fSeekPdir | Pointer to the directory supporting this object.|; 32 | fClassName | Object class name. |; 33 | fName | Name of the object. |; 34 | fTitle | Title of the object. |; 35 ; 36 In the 16 highest bits of fSeekPdir is encoded a pid offset. This; 37 offset is to be added to the pid index stored in the TRef object; 38 and the referenced TObject.; 39 ; 40 The TKey class is used by ROOT to:; 41 - Write an object in the current directory; 42 - Write a new ntuple buffer; 43 ; 44 The structure of a file is shown in TFile::TFile.; 45 The structure of a directory is shown in TDirectoryFile::TDirectoryFile.; 46 The TKey class is used by the TBasket class.; 47 See also TTree.; 48*/; 49 ; 50#include <atomic>; 51#include <iostream>; 52 ; 53#include ""TROOT.h""; 54#include ""TClass.h""; 55#include ""TDirectoryFile.h""; 56#include ""TFile.h""; 57#include ""TKey.h""; 58#include ""TBufferFile.h""; 59#include ""TFree.h""; 60#include ""TBrowser.h""; 61#include ""Bytes.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:1491,redund,redundant,1491,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,1,['redund'],['redundant']
Safety,"; 11825 mg_send_http_error(; 11826 conn,; 11827 403,; 11828 ""Error: Delete not possible\nDeleting %s is not allowed"",; 11829 path);; 11830 return;; 11831 }; 11832 ; 11833 /* Try to delete it. */; 11834 if (mg_remove(conn, path) == 0) {; 11835 /* Delete was successful: Return 204 without content. */; 11836 mg_response_header_start(conn, 204);; 11837 send_no_cache_header(conn);; 11838 send_additional_header(conn);; 11839 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11840 mg_response_header_send(conn);; 11841 ; 11842 } else {; 11843 /* Delete not successful (file locked). */; 11844 mg_send_http_error(conn,; 11845 423,; 11846 ""Error: Cannot delete file\nremove(%s): %s"",; 11847 path,; 11848 strerror(ERRNO));; 11849 }; 11850}; 11851#endif /* !NO_FILES */; 11852 ; 11853 ; 11854#if !defined(NO_FILESYSTEMS); 11855static void; 11856send_ssi_file(struct mg_connection *, const char *, struct mg_file *, int);; 11857 ; 11858 ; 11859static void; 11860do_ssi_include(struct mg_connection *conn,; 11861 const char *ssi,; 11862 char *tag,; 11863 int include_level); 11864{; 11865 char file_name[MG_BUF_LEN], path[512], *p;; 11866 struct mg_file file = STRUCT_FILE_INITIALIZER;; 11867 size_t len;; 11868 int truncated = 0;; 11869 ; 11870 if (conn == NULL) {; 11871 return;; 11872 }; 11873 ; 11874 /* sscanf() is safe here, since send_ssi_file() also uses buffer; 11875 * of size MG_BUF_LEN to get the tag. So strlen(tag) is; 11876 * always < MG_BUF_LEN. */; 11877 if (sscanf(tag, "" virtual=\""%511[^\""]\"""", file_name) == 1) {; 11878 /* File name is relative to the webserver root */; 11879 file_name[511] = 0;; 11880 (void)mg_snprintf(conn,; 11881 &truncated,; 11882 path,; 11883 sizeof(path),; 11884 ""%s/%s"",; 11885 conn->dom_ctx->config[DOCUMENT_ROOT],; 11886 file_name);; 11887 ; 11888 } else if (sscanf(tag, "" abspath=\""%511[^\""]\"""", file_name) == 1) {; 11889 /* File name is relative to the webserver working directory; 11890 * or it is absolute system path */; 11891 file_name[511] = 0;; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:343697,safe,safe,343697,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['safe'],['safe']
Safety,"; 11826 mg_send_http_error(; 11827 conn,; 11828 403,; 11829 ""Error: Delete not possible\nDeleting %s is not allowed"",; 11830 path);; 11831 return;; 11832 }; 11833 ; 11834 /* Try to delete it. */; 11835 if (mg_remove(conn, path) == 0) {; 11836 /* Delete was successful: Return 204 without content. */; 11837 mg_response_header_start(conn, 204);; 11838 send_no_cache_header(conn);; 11839 send_additional_header(conn);; 11840 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11841 mg_response_header_send(conn);; 11842 ; 11843 } else {; 11844 /* Delete not successful (file locked). */; 11845 mg_send_http_error(conn,; 11846 423,; 11847 ""Error: Cannot delete file\nremove(%s): %s"",; 11848 path,; 11849 strerror(ERRNO));; 11850 }; 11851}; 11852#endif /* !NO_FILES */; 11853 ; 11854 ; 11855#if !defined(NO_FILESYSTEMS); 11856static void; 11857send_ssi_file(struct mg_connection *, const char *, struct mg_file *, int);; 11858 ; 11859 ; 11860static void; 11861do_ssi_include(struct mg_connection *conn,; 11862 const char *ssi,; 11863 char *tag,; 11864 int include_level); 11865{; 11866 char file_name[MG_BUF_LEN], path[512], *p;; 11867 struct mg_file file = STRUCT_FILE_INITIALIZER;; 11868 size_t len;; 11869 int truncated = 0;; 11870 ; 11871 if (conn == NULL) {; 11872 return;; 11873 }; 11874 ; 11875 /* sscanf() is safe here, since send_ssi_file() also uses buffer; 11876 * of size MG_BUF_LEN to get the tag. So strlen(tag) is; 11877 * always < MG_BUF_LEN. */; 11878 if (sscanf(tag, "" virtual=\""%511[^\""]\"""", file_name) == 1) {; 11879 /* File name is relative to the webserver root */; 11880 file_name[511] = 0;; 11881 (void)mg_snprintf(conn,; 11882 &truncated,; 11883 path,; 11884 sizeof(path),; 11885 ""%s/%s"",; 11886 conn->dom_ctx->config[DOCUMENT_ROOT],; 11887 file_name);; 11888 ; 11889 } else if (sscanf(tag, "" abspath=\""%511[^\""]\"""", file_name) == 1) {; 11890 /* File name is relative to the webserver working directory; 11891 * or it is absolute system path */; 11892 file_name[511] = 0;; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:343730,safe,safe,343730,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['safe'],['safe']
Safety,"; 1205 // smooth; 1206 (*fVarHistB_smooth)[ivar]->Smooth(nsmooth);; 1207 ; 1208 // create PDFs; 1209 (*fVarPdfS)[ivar] = new PDF( TString(GetName()) + "" PDF Var Sig "" + GetInputVar( ivar ), (*fVarHistS_smooth)[ivar], PDF::kSpline2 );; 1210 (*fVarPdfB)[ivar] = new PDF( TString(GetName()) + "" PDF Var Bkg "" + GetInputVar( ivar ), (*fVarHistB_smooth)[ivar], PDF::kSpline2 );; 1211 }; 1212}; 1213 ; 1214////////////////////////////////////////////////////////////////////////////////; 1215/// read the cuts from stream; 1216 ; 1217void TMVA::MethodCuts::ReadWeightsFromStream( std::istream& istr ); 1218{; 1219 TString dummy;; 1220 UInt_t dummyInt;; 1221 ; 1222 // first the dimensions; 1223 istr >> dummy >> dummy;; 1224 // coverity[tainted_data_argument]; 1225 istr >> dummy >> fNbins;; 1226 ; 1227 // get rid of one read-in here because we read in once all ready to check for decorrelation; 1228 istr >> dummy >> dummy >> dummy >> dummy >> dummy >> dummy >> dummyInt >> dummy ;; 1229 ; 1230 // sanity check; 1231 if (dummyInt != Data()->GetNVariables()) {; 1232 Log() << kFATAL << ""<ReadWeightsFromStream> fatal error: mismatch ""; 1233 << ""in number of variables: "" << dummyInt << "" != "" << Data()->GetNVariables() << Endl;; 1234 }; 1235 //SetNvar(dummyInt);; 1236 ; 1237 // print some information; 1238 if (fFitMethod == kUseMonteCarlo) {; 1239 Log() << kWARNING << ""Read cuts optimised using sample of MC events"" << Endl;; 1240 }; 1241 else if (fFitMethod == kUseMonteCarloEvents) {; 1242 Log() << kWARNING << ""Read cuts optimised using sample of MC events"" << Endl;; 1243 }; 1244 else if (fFitMethod == kUseGeneticAlgorithm) {; 1245 Log() << kINFO << ""Read cuts optimised using Genetic Algorithm"" << Endl;; 1246 }; 1247 else if (fFitMethod == kUseSimulatedAnnealing) {; 1248 Log() << kINFO << ""Read cuts optimised using Simulated Annealing algorithm"" << Endl;; 1249 }; 1250 else if (fFitMethod == kUseEventScan) {; 1251 Log() << kINFO << ""Read cuts optimised using Full Event Scan"" << Endl;; 1252 }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:46225,sanity check,sanity check,46225,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['sanity check'],['sanity check']
Safety,"; 168 if (!fSync) gSystem->ResetTimer(this);; 169 }; 170}; 171 ; 172////////////////////////////////////////////////////////////////////////////////; 173/// Set the interpreter command to be executed at time out. Removes the; 174/// object to be notified (if it was set).; 175 ; 176void TTimer::SetCommand(const char *command); 177{; 178 fObject = nullptr;; 179 fCommand = command;; 180}; 181 ; 182////////////////////////////////////////////////////////////////////////////////; 183/// Set the object to be notified at time out. Removes the command to; 184/// be executed (if it was set).; 185 ; 186void TTimer::SetObject(TObject *object); 187{; 188 fObject = object;; 189 fCommand = """";; 190}; 191 ; 192////////////////////////////////////////////////////////////////////////////////; 193/// When the argument is true the a-synchronous timer (SIGALRM) signal; 194/// handler is set so that interrupted syscalls will not be restarted; 195/// by the kernel. This is typically used in case one wants to put a; 196/// timeout on an I/O operation. By default interrupted syscalls will; 197/// be restarted.; 198 ; 199void TTimer::SetInterruptSyscalls(Bool_t set); 200{; 201 fIntSyscalls = set;; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Starts the timer with a milliSec timeout. If milliSec is 0; 206/// then the timeout will be the minimum timeout (see TSystem::ESysConstants,; 207/// i.e. 10 ms), if milliSec is -1 then the time interval as previously; 208/// specified (in ctor or SetTime()) will be used.; 209/// If singleShot is kTRUE, the timer will be activated only once,; 210/// otherwise it will continue until it is stopped.; 211/// See also TurnOn(), Stop(), TurnOff().; 212 ; 213void TTimer::Start(Long_t milliSec, Bool_t singleShot); 214{; 215 if (milliSec >= 0); 216 SetTime(milliSec);; 217 Reset();; 218 TurnOn();; 219 if (singleShot); 220 Connect(this, ""Timeout()"", ""TTimer"", this, ""TurnOff()"");; 221 else; 222 Disconnect(thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8cxx_source.html:6749,timeout,timeout,6749,doc/master/TTimer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html,1,['timeout'],['timeout']
Safety,"; 1797 ; 1798 TObjArray *dataTypes;; 1799 pcmFile.GetObject(""__Typedefs"", dataTypes);; 1800 if (dataTypes) {; 1801 for (auto typedf : *dataTypes); 1802 gROOT->GetListOfTypes()->Add(typedf);; 1803 dataTypes->Clear(); // Ownership was transfered to TListOfTypes.; 1804 delete dataTypes;; 1805 }; 1806}; 1807 ; 1808////////////////////////////////////////////////////////////////////////////////; 1809/// Tries to load a rdict PCM, issues diagnostics if it fails.; 1810 ; 1811void TCling::LoadPCM(std::string pcmFileNameFullPath); 1812{; 1813 SuspendAutoLoadingRAII autoloadOff(this);; 1814 SuspendAutoParsing autoparseOff(this);; 1815 assert(!pcmFileNameFullPath.empty());; 1816 assert(llvm::sys::path::is_absolute(pcmFileNameFullPath));; 1817 ; 1818 // Easier to work with the ROOT interfaces.; 1819 TString pcmFileName = pcmFileNameFullPath;; 1820 ; 1821 // Prevent the ROOT-PCMs hitting this during auto-load during; 1822 // JITting - which will cause recursive compilation.; 1823 // Avoid to call the plugin manager at all.; 1824 R__InitStreamerInfoFactory();; 1825 ; 1826 TDirectory::TContext ctxt;; 1827 llvm::SaveAndRestore<Int_t> SaveGDebug(gDebug);; 1828 if (gDebug > 5) {; 1829 gDebug -= 5;; 1830 ::Info(""TCling::LoadPCM"", ""Loading ROOT PCM %s"", pcmFileName.Data());; 1831 } else {; 1832 gDebug = 0;; 1833 }; 1834 ; 1835 if (llvm::sys::fs::is_symlink_file(pcmFileNameFullPath)); 1836 pcmFileNameFullPath = ROOT::TMetaUtils::GetRealPath(pcmFileNameFullPath);; 1837 ; 1838 auto pendingRdict = fPendingRdicts.find(pcmFileNameFullPath);; 1839 if (pendingRdict != fPendingRdicts.end()) {; 1840 llvm::StringRef pcmContent = pendingRdict->second;; 1841 TMemFile::ZeroCopyView_t range{pcmContent.data(), pcmContent.size()};; 1842 std::string RDictFileOpts = pcmFileNameFullPath + ""?filetype=pcm"";; 1843 TMemFile pcmMemFile(RDictFileOpts.c_str(), range);; 1844 ; 1845 cling::Interpreter::PushTransactionRAII deserRAII(GetInterpreterImpl());; 1846 LoadPCMImpl(pcmMemFile);; 1847 // Currently the module",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:68572,Avoid,Avoid,68572,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Avoid'],['Avoid']
Safety,"; 1881 ; 1882#define STRUCT_FILE_INITIALIZER \; 1883 { \; 1884 {(uint64_t)0, (time_t)0, 0, 0, 0}, \; 1885 { \; 1886 (FILE *)NULL \; 1887 } \; 1888 }; 1889 ; 1890 ; 1891/* Describes listening socket, or socket which was accept()-ed by the master; 1892 * thread and queued for future handling by the worker thread. */; 1893struct socket {; 1894 SOCKET sock; /* Listening socket */; 1895 union usa lsa; /* Local socket address */; 1896 union usa rsa; /* Remote socket address */; 1897 unsigned char is_ssl; /* Is port SSL-ed */; 1898 unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL; 1899 * port */; 1900 unsigned char in_use; /* 0: invalid, 1: valid, 2: free */; 1901};; 1902 ; 1903 ; 1904/* Enum const for all options must be in sync with; 1905 * static struct mg_option config_options[]; 1906 * This is tested in the unit test (test/private.c); 1907 * ""Private Config Options""; 1908 */; 1909enum {; 1910 /* Once for each server */; 1911 LISTENING_PORTS,; 1912 NUM_THREADS,; 1913 RUN_AS_USER,; 1914 CONFIG_TCP_NODELAY, /* Prepended CONFIG_ to avoid conflict with the; 1915 * socket option typedef TCP_NODELAY. */; 1916 MAX_REQUEST_SIZE,; 1917 LINGER_TIMEOUT,; 1918 CONNECTION_QUEUE_SIZE,; 1919 LISTEN_BACKLOG_SIZE,; 1920#if defined(__linux__); 1921 ALLOW_SENDFILE_CALL,; 1922#endif; 1923#if defined(_WIN32); 1924 CASE_SENSITIVE_FILES,; 1925#endif; 1926 THROTTLE,; 1927 ENABLE_KEEP_ALIVE,; 1928 REQUEST_TIMEOUT,; 1929 KEEP_ALIVE_TIMEOUT,; 1930#if defined(USE_WEBSOCKET); 1931 WEBSOCKET_TIMEOUT,; 1932 ENABLE_WEBSOCKET_PING_PONG,; 1933#endif; 1934 DECODE_URL,; 1935 DECODE_QUERY_STRING,; 1936#if defined(USE_LUA); 1937 LUA_BACKGROUND_SCRIPT,; 1938 LUA_BACKGROUND_SCRIPT_PARAMS,; 1939#endif; 1940#if defined(USE_HTTP2); 1941 ENABLE_HTTP2,; 1942#endif; 1943 ; 1944 /* Once for each domain */; 1945 DOCUMENT_ROOT,; 1946 ; 1947 ACCESS_LOG_FILE,; 1948 ERROR_LOG_FILE,; 1949 ; 1950 CGI_EXTENSIONS,; 1951 CGI_ENVIRONMENT,; 1952 CGI_INTERPRETER,; 1953 CGI_INTERPRETER_ARGS,; 1954#if def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:58318,avoid,avoid,58318,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['avoid'],['avoid']
Safety,"; 1882 ; 1883#define STRUCT_FILE_INITIALIZER \; 1884 { \; 1885 {(uint64_t)0, (time_t)0, 0, 0, 0}, \; 1886 { \; 1887 (FILE *)NULL \; 1888 } \; 1889 }; 1890 ; 1891 ; 1892/* Describes listening socket, or socket which was accept()-ed by the master; 1893 * thread and queued for future handling by the worker thread. */; 1894struct socket {; 1895 SOCKET sock; /* Listening socket */; 1896 union usa lsa; /* Local socket address */; 1897 union usa rsa; /* Remote socket address */; 1898 unsigned char is_ssl; /* Is port SSL-ed */; 1899 unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL; 1900 * port */; 1901 unsigned char in_use; /* 0: invalid, 1: valid, 2: free */; 1902};; 1903 ; 1904 ; 1905/* Enum const for all options must be in sync with; 1906 * static struct mg_option config_options[]; 1907 * This is tested in the unit test (test/private.c); 1908 * ""Private Config Options""; 1909 */; 1910enum {; 1911 /* Once for each server */; 1912 LISTENING_PORTS,; 1913 NUM_THREADS,; 1914 RUN_AS_USER,; 1915 CONFIG_TCP_NODELAY, /* Prepended CONFIG_ to avoid conflict with the; 1916 * socket option typedef TCP_NODELAY. */; 1917 MAX_REQUEST_SIZE,; 1918 LINGER_TIMEOUT,; 1919 CONNECTION_QUEUE_SIZE,; 1920 LISTEN_BACKLOG_SIZE,; 1921#if defined(__linux__); 1922 ALLOW_SENDFILE_CALL,; 1923#endif; 1924#if defined(_WIN32); 1925 CASE_SENSITIVE_FILES,; 1926#endif; 1927 THROTTLE,; 1928 ENABLE_KEEP_ALIVE,; 1929 REQUEST_TIMEOUT,; 1930 KEEP_ALIVE_TIMEOUT,; 1931#if defined(USE_WEBSOCKET); 1932 WEBSOCKET_TIMEOUT,; 1933 ENABLE_WEBSOCKET_PING_PONG,; 1934#endif; 1935 DECODE_URL,; 1936 DECODE_QUERY_STRING,; 1937#if defined(USE_LUA); 1938 LUA_BACKGROUND_SCRIPT,; 1939 LUA_BACKGROUND_SCRIPT_PARAMS,; 1940#endif; 1941#if defined(USE_HTTP2); 1942 ENABLE_HTTP2,; 1943#endif; 1944 ; 1945 /* Once for each domain */; 1946 DOCUMENT_ROOT,; 1947 ; 1948 ACCESS_LOG_FILE,; 1949 ERROR_LOG_FILE,; 1950 ; 1951 CGI_EXTENSIONS,; 1952 CGI_ENVIRONMENT,; 1953 CGI_INTERPRETER,; 1954 CGI_INTERPRETER_ARGS,; 1955#if def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:58350,avoid,avoid,58350,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['avoid'],['avoid']
Safety,"; 194 ; 195 // ------------------------; 196 ; 197 // auxiliary functions to compute correlations; 198 TMatrixD* CalcCorrelationMatrix( DataSet*, const UInt_t classNumber );; 199 TMatrixD* CalcCovarianceMatrix ( DataSet*, const UInt_t classNumber );; 200 void CalcMinMax ( DataSet*, DataSetInfo& dsi );; 201 ; 202 // resets branch addresses to current event; 203 void ResetBranchAndEventAddresses( TTree* );; 204 void ResetCurrentTree() { fCurrentTree = nullptr; }; 205 void ChangeToNewTree( TreeInfo&, const DataSetInfo & );; 206 Bool_t CheckTTreeFormula( TTreeFormula* ttf, const TString& expression, Bool_t& hasDollar );; 207 ; 208 // verbosity; 209 Bool_t Verbose() { return fVerbose; }; 210 ; 211 // data members; 212 ; 213 // verbosity; 214 Bool_t fVerbose; ///< Verbosity; 215 TString fVerboseLevel; ///< VerboseLevel; 216 ; 217 // Printing; 218 Bool_t fCorrelations = kFALSE; ///< Whether to print correlations or not; 219 Bool_t fComputeCorrelations = kFALSE; ///< Whether to force computation of correlations or not; 220 ; 221 Bool_t fScaleWithPreselEff; ///< how to deal with requested #events in connection with preselection cuts; 222 ; 223 // the event; 224 TTree* fCurrentTree; ///< the tree, events are currently read from; 225 UInt_t fCurrentEvtIdx; ///< the current event (to avoid reading of the same event); 226 ; 227 // the formulas for reading the original tree; 228 std::vector<TTreeFormula*> fInputFormulas; ///< input variables; 229 std::vector<std::pair<TTreeFormula*, Int_t>> fInputTableFormulas; ///<! input variables expression for arrays; 230 std::vector<TTreeFormula *> fTargetFormulas; ///< targets; 231 std::vector<TTreeFormula*> fCutFormulas; ///< cuts; 232 std::vector<TTreeFormula*> fWeightFormula; ///< weights; 233 std::vector<TTreeFormula*> fSpectatorFormulas; ///< spectators; 234 ; 235 MsgLogger* fLogger; ///<! message logger; 236 MsgLogger& Log() const { return *fLogger; }; 237 public:; 238 ClassDef(DataSetFactory, 2);; 239 };; 240}; 241 ; 242#endif; Event.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8h_source.html:6965,avoid,avoid,6965,doc/master/DataSetFactory_8h_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8h_source.html,1,['avoid'],['avoid']
Safety,"; 1986 break;; 1987 }; 1988 }; 1989 }; 1990 ; 1991 if (found) {; 1992 delete pid;; 1993 pids->AddAtAndExpand(p,pidf);; 1994 p->IncrementCount();; 1995 return p;; 1996 }; 1997 ; 1998 pids->AddAtAndExpand(pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:72095,recover,recover,72095,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['recover'],['recover']
Safety,"; 23// //; 24////////////////////////////////////////////////////////////////////////////; 25 ; 26class TGeoManager;; 27class TGeoNode;; 28class TGeoVolume;; 29class TGeoMatrix;; 30class TGeoHMatrix;; 31 ; 32class TGeoNavigator : public TObject {; 33 ; 34protected:; 35 TGeoNavigator(const TGeoNavigator &) = delete;; 36 TGeoNavigator &operator=(const TGeoNavigator &) = delete;; 37 TGeoNode *FindInCluster(Int_t *cluster, Int_t nc);; 38 Int_t GetTouchedCluster(Int_t start, Double_t *point, Int_t *check_list, Int_t ncheck, Int_t *result);; 39 TGeoNode *CrossDivisionCell();; 40 void SafetyOverlaps();; 41 ; 42private:; 43 Double_t fStep; //! step to be done from current point and direction; 44 Double_t fSafety; //! safety radius from current point; 45 Double_t fLastSafety; //! last computed safety radius; 46 Double_t fNormal[3]; //! cosine of incident angle on current checked surface; 47 Double_t fCldir[3]; //! unit vector to current closest shape; 48 Double_t fCldirChecked[3]; //! unit vector to current checked shape; 49 Double_t fPoint[3]; //! current po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:1520,Safe,SafetyOverlaps,1520,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,3,"['Safe', 'safe']","['SafetyOverlaps', 'safety']"
Safety,"; 2503 ; 2504 paramList.add(*rrvInAbsReal);; 2505 }; 2506 ; 2507 std::vector<double> plusVar;; 2508 std::vector<double> minusVar;; 2509 plusVar.reserve(paramList.size());; 2510 minusVar.reserve(paramList.size());; 2511 ; 2512 // Create std::vector of plus,minus variations for each parameter; 2513 TMatrixDSym V(paramList.size() == fr.floatParsFinal().size() ?; 2514 fr.covarianceMatrix() :; 2515 fr.reducedCovarianceMatrix(paramList)) ;; 2516 ; 2517 for (std::size_t ivar=0 ; ivar<paramList.size() ; ivar++) {; 2518 ; 2519 auto& rrv = static_cast<RooRealVar&>(paramList[ivar]);; 2520 ; 2521 double cenVal = rrv.getVal() ;; 2522 double errVal = sqrt(V(ivar,ivar)) ;; 2523 ; 2524 // Make Plus variation; 2525 rrv.setVal(cenVal+errVal) ;; 2526 plusVar.push_back(getVal(nset)) ;; 2527 ; 2528 // Make Minus variation; 2529 rrv.setVal(cenVal-errVal) ;; 2530 minusVar.push_back(getVal(nset)) ;; 2531 ; 2532 rrv.setVal(cenVal) ;; 2533 }; 2534 ; 2535 // Re-evaluate this RooAbsReal with the central parameters just to be; 2536 // extra-safe that a call to `getPropagatedError()` doesn't change any state.; 2537 // It should not be necessary because thanks to the dirty flag propagation; 2538 // the RooAbsReal is re-evaluated anyway the next time getVal() is called.; 2539 // Still there are imaginable corner cases where it would not be triggered,; 2540 // for example if the user changes the RooFit operation more after the error; 2541 // propagation.; 2542 getVal(nset);; 2543 ; 2544 TMatrixDSym C(paramList.size()) ;; 2545 std::vector<double> errVec(paramList.size()) ;; 2546 for (std::size_t i=0 ; i<paramList.size() ; i++) {; 2547 errVec[i] = std::sqrt(V(i,i)) ;; 2548 for (std::size_t j=i ; j<paramList.size() ; j++) {; 2549 C(i,j) = V(i,j) / std::sqrt(V(i,i)*V(j,j));; 2550 C(j,i) = C(i,j) ;; 2551 }; 2552 }; 2553 ; 2554 // Make std::vector of variations; 2555 TVectorD F(plusVar.size()) ;; 2556 for (std::size_t j=0 ; j<plusVar.size() ; j++) {; 2557 F[j] = (plusVar[j]-minusVar[j]) * 0.5;; 2558 }; 25",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:111137,safe,safe,111137,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['safe'],['safe']
Safety,"; 2770 {; 2771 if(fStatisticOption != kFNormal); 2772 {; 2773 Warning(""GetEfficiencyErrorLow"",""frequentist confidence intervals for weights are only supported by the normal approximation"");; 2774 Info(""GetEfficiencyErrorLow"",""setting statistic option to kFNormal"");; 2775 const_cast<TEfficiency*>(this)->SetStatisticOption(kFNormal);; 2776 }; 2777 ; 2778 Double_t variance = ( pw2 * (1. - 2 * eff) + tw2 * eff *eff ) / ( tw * tw) ;; 2779 Double_t sigma = sqrt(variance);; 2780 ; 2781 Double_t prob = 0.5 * (1.- fConfLevel);; 2782 Double_t delta = ROOT::Math::normal_quantile_c(prob, sigma);; 2783 ; 2784 // avoid to return errors which makes eff-err < 0; 2785 return (eff - delta < 0) ? eff : delta;; 2786 }; 2787 }; 2788 else; 2789 {; 2790 if(TestBit(kIsBayesian)); 2791 {; 2792 // parameters for the beta prior distribution; 2793 Double_t alpha = TestBit(kUseBinPrior) ? GetBetaAlpha(bin) : GetBetaAlpha();; 2794 Double_t beta = TestBit(kUseBinPrior) ? GetBetaBeta(bin) : GetBetaBeta();; 2795 return (eff - Bayesian(total,passed,fConfLevel,alpha,beta,false,TestBit(kShortestInterval)));; 2796 }; 2797 else; 2798 return (eff - fBoundary(total,passed,fConfLevel,false));; 2799 }; 2800}; 2801 ; 2802////////////////////////////////////////////////////////////////////////////////; 2803/// Returns the upper error on the efficiency in the given global bin; 2804///; 2805/// The result depends on the current confidence level fConfLevel and the; 2806/// chosen statistic option fStatisticOption. See SetStatisticOption(Int_t) for; 2807/// more details.; 2808///; 2809/// Note: If the histograms are filled with weights, only bayesian methods and the; 2810/// normal approximation are supported.; 2811 ; 2812Double_t TEfficiency::GetEfficiencyErrorUp(Int_t bin) const; 2813{; 2814 Double_t total = fTotalHistogram->GetBinContent(bin);; 2815 Double_t passed = fPassedHistogram->GetBinContent(bin);; 2816 ; 2817 Double_t eff = GetEfficiency(bin);; 2818 ; 2819 // check whether weights have been used; 2820 i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEfficiency_8cxx_source.html:111727,avoid,avoid,111727,doc/master/TEfficiency_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html,1,['avoid'],['avoid']
Safety,"; 292/// Note that the compression settings may be changed at any time.; 293/// The new compression settings will only apply to branches created; 294/// or attached after the setting is changed and other objects written; 295/// after the setting is changed.; 296/// In case the file does not exist or is not a valid ROOT file,; 297/// it is made a Zombie. One can detect this situation with a code like:; 298/// ~~~{.cpp}; 299/// TFile f(""file.root"");; 300/// if (f.IsZombie()) {; 301/// std::cout << ""Error opening file"" << std::endl;; 302/// exit(-1);; 303/// }; 304/// ~~~; 305/// If you open a file instead with TFile::Open(""file.root"") use rather; 306/// the following code as a nullptr is returned.; 307/// ~~~{.cpp}; 308/// TFile* f = TFile::Open(""file.root"");; 309/// if (!f) {; 310/// std::cout << ""Error opening file"" << std::endl;; 311/// exit(-1);; 312/// }; 313/// ~~~; 314/// When opening the file, the system checks the validity of this directory.; 315/// If something wrong is detected, an automatic Recovery is performed. In; 316/// this case, the file is scanned sequentially reading all logical blocks; 317/// and attempting to rebuild a correct directory (see TFile::Recover).; 318/// One can disable the automatic recovery procedure when reading one; 319/// or more files by setting the environment variable ""TFile.Recover: 0""; 320/// in the system.rootrc file.; 321///; 322/// A bit `TFile::kReproducible` can be enabled specifying; 323/// the `""reproducible""` url option when creating the file:; 324/// ~~~{.cpp}; 325/// TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; 326/// ~~~; 327/// Unlike regular `TFile`s, the content of such file has reproducible binary; 328/// content when writing exactly same data. This achieved by writing pre-defined; 329/// values for creation and modification date of TKey/TDirectory objects and; 330/// null value for TUUID objects inside TFile. As drawback, TRef objects stored; 331/// in such file cannot be read co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:13097,detect,detected,13097,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,"['Recover', 'detect']","['Recovery', 'detected']"
Safety,"; 2963 ; 2964 ; 2965static void; 2966mg_strlcpy(char *dst, const char *src, size_t n); 2967{; 2968 for (; *src != '\0' && n > 1; n--) {; 2969 *dst++ = *src++;; 2970 }; 2971 *dst = '\0';; 2972}; 2973 ; 2974 ; 2975static int; 2976lowercase(const char *s); 2977{; 2978 return tolower((unsigned char)*s);; 2979}; 2980 ; 2981 ; 2982int; 2983mg_strncasecmp(const char *s1, const char *s2, size_t len); 2984{; 2985 int diff = 0;; 2986 ; 2987 if (len > 0) {; 2988 do {; 2989 diff = lowercase(s1++) - lowercase(s2++);; 2990 } while (diff == 0 && s1[-1] != '\0' && --len > 0);; 2991 }; 2992 ; 2993 return diff;; 2994}; 2995 ; 2996 ; 2997int; 2998mg_strcasecmp(const char *s1, const char *s2); 2999{; 3000 int diff;; 3001 ; 3002 do {; 3003 diff = lowercase(s1++) - lowercase(s2++);; 3004 } while (diff == 0 && s1[-1] != '\0');; 3005 ; 3006 return diff;; 3007}; 3008 ; 3009 ; 3010static char *; 3011mg_strndup_ctx(const char *ptr, size_t len, struct mg_context *ctx); 3012{; 3013 char *p;; 3014 (void)ctx; /* Avoid Visual Studio warning if USE_SERVER_STATS is not; 3015 * defined */; 3016 ; 3017 if ((p = (char *)mg_malloc_ctx(len + 1, ctx)) != NULL) {; 3018 mg_strlcpy(p, ptr, len + 1);; 3019 }; 3020 ; 3021 return p;; 3022}; 3023 ; 3024 ; 3025static char *; 3026mg_strdup_ctx(const char *str, struct mg_context *ctx); 3027{; 3028 return mg_strndup_ctx(str, strlen(str), ctx);; 3029}; 3030 ; 3031static char *; 3032mg_strdup(const char *str); 3033{; 3034 return mg_strndup_ctx(str, strlen(str), NULL);; 3035}; 3036 ; 3037 ; 3038static const char *; 3039mg_strcasestr(const char *big_str, const char *small_str); 3040{; 3041 size_t i, big_len = strlen(big_str), small_len = strlen(small_str);; 3042 ; 3043 if (big_len >= small_len) {; 3044 for (i = 0; i <= (big_len - small_len); i++) {; 3045 if (mg_strncasecmp(big_str + i, small_str, small_len) == 0) {; 3046 return big_str + i;; 3047 }; 3048 }; 3049 }; 3050 ; 3051 return NULL;; 3052}; 3053 ; 3054 ; 3055/* Return null terminated string of given maximum lengt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:91345,Avoid,Avoid,91345,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['Avoid'],['Avoid']
Safety,"; 2964 ; 2965 ; 2966static void; 2967mg_strlcpy(char *dst, const char *src, size_t n); 2968{; 2969 for (; *src != '\0' && n > 1; n--) {; 2970 *dst++ = *src++;; 2971 }; 2972 *dst = '\0';; 2973}; 2974 ; 2975 ; 2976static int; 2977lowercase(const char *s); 2978{; 2979 return tolower((unsigned char)*s);; 2980}; 2981 ; 2982 ; 2983int; 2984mg_strncasecmp(const char *s1, const char *s2, size_t len); 2985{; 2986 int diff = 0;; 2987 ; 2988 if (len > 0) {; 2989 do {; 2990 diff = lowercase(s1++) - lowercase(s2++);; 2991 } while (diff == 0 && s1[-1] != '\0' && --len > 0);; 2992 }; 2993 ; 2994 return diff;; 2995}; 2996 ; 2997 ; 2998int; 2999mg_strcasecmp(const char *s1, const char *s2); 3000{; 3001 int diff;; 3002 ; 3003 do {; 3004 diff = lowercase(s1++) - lowercase(s2++);; 3005 } while (diff == 0 && s1[-1] != '\0');; 3006 ; 3007 return diff;; 3008}; 3009 ; 3010 ; 3011static char *; 3012mg_strndup_ctx(const char *ptr, size_t len, struct mg_context *ctx); 3013{; 3014 char *p;; 3015 (void)ctx; /* Avoid Visual Studio warning if USE_SERVER_STATS is not; 3016 * defined */; 3017 ; 3018 if ((p = (char *)mg_malloc_ctx(len + 1, ctx)) != NULL) {; 3019 mg_strlcpy(p, ptr, len + 1);; 3020 }; 3021 ; 3022 return p;; 3023}; 3024 ; 3025 ; 3026static char *; 3027mg_strdup_ctx(const char *str, struct mg_context *ctx); 3028{; 3029 return mg_strndup_ctx(str, strlen(str), ctx);; 3030}; 3031 ; 3032static char *; 3033mg_strdup(const char *str); 3034{; 3035 return mg_strndup_ctx(str, strlen(str), NULL);; 3036}; 3037 ; 3038 ; 3039static const char *; 3040mg_strcasestr(const char *big_str, const char *small_str); 3041{; 3042 size_t i, big_len = strlen(big_str), small_len = strlen(small_str);; 3043 ; 3044 if (big_len >= small_len) {; 3045 for (i = 0; i <= (big_len - small_len); i++) {; 3046 if (mg_strncasecmp(big_str + i, small_str, small_len) == 0) {; 3047 return big_str + i;; 3048 }; 3049 }; 3050 }; 3051 ; 3052 return NULL;; 3053}; 3054 ; 3055 ; 3056/* Return null terminated string of given maximum lengt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:91377,Avoid,Avoid,91377,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['Avoid'],['Avoid']
Safety,"; 3 - any proofserv enters wait loop; Proof.GdbHook: 0; On the master to enable the parallel startup of workers using threads set next to â€œyesâ€ (default is â€œnoâ€):; Proof.ParallelStartup: no; Proof.StatsHist: no; Proof.StatsTrace: no; Proof.SlaveStatsTrace: no; Proof.CondorHome: /opt/condor; Proof.CondorConfig: /opt/condor/etc/condor_config; PEAC.GmUrl: http://somewhere:8080/clarens/; PEAC.LmUrl: http://elsewhere:8080/clarens/; 28.6.7.1 Server Authentication in TServerSocket; General setting: file with server access rules; SrvAuth.DaemonRc: /etc/root/system.daemonrc; Check of host equivalence via /etc/hosts.equiv or $HOME/.rhosts.; SrvAuth.CheckHostsEquivalence: 1; Force file opening via TNetFile (TNetXNGFile) if a hostname is specified in the Url. By default, for local files TFile::Open() invokes directly TFile.; TFile.ForceRemote: yes; Special cases for the TUrl parser, where the special cases are parsed in a protocol + file part, like rfio:host:/path/file.root, castor:/path/file.root or /alien/path/file.root. In case the file namespace descriptor ends with - the namespace is not a part of the filename. Extend in private .rootrc with a +Url.Special line.; Url.Special: file: rfio: hpss: castor: dcache:; +Url.Special: /alien/- /castor/; 28.6.7.2 PROOF XRD Client Variables; Debug level (if <=0 : none, 1 : low, 2 : medium, 3 : high); XProof.Debug: 0; Socket read timeout [in secs: default 10 secs]; XProof.ReadTimeout: 10; XNet.PrintTAG - Print a particular string the developers can choose to quickly recognize the version at run time [default - 0]; Example of custom setting for the Rint application (root.exe). This overrides the default specified above for a generic application. Color 5 is yellow.; Rint.Canvas.HighLightColor: 5; 28.7 Documentation to Download. The latest ROOT Users Guide; https://root.cern.ch/root/htmldoc/guides/users-guide/ROOTUsersGuide.html; ROOT Reference Guide; http://root.cern.ch/root/Reference.html. http://root.cern.ch/twiki/bin/view/ROOT/PROOFâ†©. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1265085,timeout,timeout,1265085,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['timeout'],['timeout']
Safety,"; 3415ROOT::Double_v TFormula::DoEvalVec(const ROOT::Double_v *x, const double *params) const; 3416{; 3417 if (!fReadyToExecute) {; 3418 Error(""Eval"", ""Formula is invalid and not ready to execute "");; 3419 for (auto it = fFuncs.begin(); it != fFuncs.end(); ++it) {; 3420 TFormulaFunction fun = *it;; 3421 if (!fun.fFound) {; 3422 printf(""%s is unknown.\n"", fun.GetName());; 3423 }; 3424 }; 3425 return TMath::QuietNaN();; 3426 }; 3427 // todo maybe save lambda ptr stuff for later; 3428 ; 3429 if (!fClingInitialized && fLazyInitialization) {; 3430 // try recompiling the formula. We need to lock because this is not anymore thread safe; 3431 R__LOCKGUARD(gROOTMutex);; 3432 // check again in case another thread has initialized the formula (see ROOT-10994); 3433 if (!fClingInitialized) {; 3434 auto thisFormula = const_cast<TFormula*>(this);; 3435 thisFormula->ReInitializeEvalMethod();; 3436 }; 3437 if (!fClingInitialized) {; 3438 Error(""DoEval"", ""Formula has error and it is not properly initialized "");; 3439 ROOT::Double_v res = TMath::QuietNaN();; 3440 return res;; 3441 }; 3442 }; 3443 ; 3444 ROOT::Double_v result = 0;; 3445 void *args[2];; 3446 ; 3447 ROOT::Double_v *vars = const_cast<ROOT::Double_v *>(x);; 3448 args[0] = &vars;; 3449 if (fNpar <= 0) {; 3450 (*fFuncPtr)(0, 1, args, &result);; 3451 }else {; 3452 double *pars = (params) ? const_cast<double *>(params) : const_cast<double *>(fClingParameters.data());; 3453 args[1] = &pars;; 3454 (*fFuncPtr)(0, 2, args, &result);; 3455 }; 3456 return result;; 3457}; 3458#endif // R__HAS_VECCORE; 3459 ; 3460 ; 3461//////////////////////////////////////////////////////////////////////////////; 3462/// Re-initialize eval method; 3463///; 3464/// This function is called by DoEval and DoEvalVector in case of a previous failure; 3465/// or in case of reading from a file; 3466////////////////////////////////////////////////////////////////////////////////; 3467void TFormula::ReInitializeEvalMethod() {; 3468 ; 3469 ; 3470 if (TestBit(TF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:130582,safe,safe,130582,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['safe'],['safe']
Safety,"; 3490 bool first(true) ;; 3491 for (Int_t i=0 ; i<numProxies() ; i++) {; 3492 RooAbsProxy* p = getProxy(i) ;; 3493 if (!p) continue ;; 3494 //if (p->name()[0]=='!') continue ;; 3495 if (first) {; 3496 first=false ;; 3497 } else {; 3498 oss << "", "" ;; 3499 }; 3500 p->print(oss,true) ;; 3501 }; 3502 ee.setServerValues(oss.str().c_str()) ;; 3503 }; 3504 ; 3505 std::ostringstream oss2 ;; 3506 printStream(oss2,kName|kClassName|kArgs,kInline) ;; 3507 ; 3508 if (evalErrorData().mode == PrintErrors) {; 3509 coutE(Eval) << ""RooAbsReal::logEvalError("" << GetName() << "") evaluation error, "" << std::endl; 3510 << "" origin : "" << oss2.str() << std::endl; 3511 << "" message : "" << ee._msg << std::endl; 3512 << "" server values: "" << ee._srvval << std::endl ;; 3513 } else if (evalErrorData().mode == CollectErrors) {; 3514 auto &evalErrorList = evalErrorData().errorList[this];; 3515 if (evalErrorList.second.size() >= 2048) {; 3516 // avoid overflowing the error list, so if there are very many, print; 3517 // the oldest one first, and pop it off the list; 3518 const EvalError& oee = evalErrorList.second.front();; 3519 // print to debug stream, since these would normally be suppressed, and; 3520 // we do not want to increase the error count in the message service...; 3521 ccoutD(Eval) << ""RooAbsReal::logEvalError("" << GetName(); 3522 << "") delayed evaluation error, "" << std::endl; 3523 << "" origin : "" << oss2.str() << std::endl; 3524 << "" message : "" << oee._msg << std::endl; 3525 << "" server values: "" << oee._srvval << std::endl ;; 3526 evalErrorList.second.pop_front();; 3527 }; 3528 evalErrorList.first = oss2.str() ;; 3529 evalErrorList.second.push_back(ee) ;; 3530 }; 3531 ; 3532 inLogEvalError = false ;; 3533 //coutE(Tracing) << ""RooAbsReal::logEvalError("" << GetName() << "") message = "" << message << std::endl ;; 3534}; 3535 ; 3536 ; 3537 ; 3538 ; 3539////////////////////////////////////////////////////////////////////////////////; 3540/// Clear the stack of evaluation error messag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:150327,avoid,avoid,150327,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['avoid'],['avoid']
Safety,"; 349By default the number of divisions on axis is optimised to show a coherent; 350labelling of the main tick marks. The number of division (`ndiv`) is a; 351composite integer given by:; 352 ; 353` ndiv = N1 + 100*N2 + 10000*N3`; 354 ; 355 - `N1` = number of 1st divisions.; 356 - `N2` = number of 2nd divisions.; 357 - `N3` = number of 3rd divisions.; 358 ; 359by default the value of `N1`, `N2` and `N3` are maximum; 360values. After optimisation the real number of divisions will be smaller or; 361equal to these value. If one wants to bypass the optimisation, the option `""N""`; 362should be given when the `TGaxis` is created. The option `""I""`; 363also act on the number of division as it will force an integer labelling of; 364the axis.; 365 ; 366On an histogram pointer `h` the number of divisions can be set in different ways:.; 367 ; 368- Directly on the histogram. The following will set the number of division; 369 to 510 on the X axis of `h`. To avoid optimization the number of divisions; 370 should be negative (ie: -510);; 371~~~ {.cpp}; 372 h->SetNdivisions(510, ""X"");; 373~~~; 374- On the axis itself:; 375~~~ {.cpp}; 376 h->GetXaxis()->SetNdivisions(510, kTRUE);; 377~~~; 378 ; 379The first parameter is the number of division. If it is negative of if the; 380second parameter is kFALSE then the number of divisions is not optimised.; 381And other signature is also allowed:; 382~~~ {.cpp}; 383 h->GetXaxis()->SetNdivisions(10, 5, 0, kTRUE);; 384~~~; 385\anchor GA12; 386## Maximum Number of Digits for the axis labels; 387 ; 388The static method `TGaxis::SetMaxDigits` sets the maximum number of; 389digits permitted for the axis labels above which the notation with 10^N is used.; 390For example, to accept 6 digits number like 900000 on an axis call; 391`TGaxis::SetMaxDigits(6)`. The default value is 5.; 392`fgMaxDigits` must be greater than 0.; 393Warning: even when called on a particular TGaxis* instance, this static function; 394changes globally the number of digits for al",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGaxis_8cxx_source.html:13812,avoid,avoid,13812,doc/master/TGaxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html,1,['avoid'],['avoid']
Safety,"; 368 ; 369 // Copy the input vectors into local arrays; 370 for (Int_t i = 0; i < fNpoints; ++i) {; 371 fX[i] = x[i];; 372 fY[i] = y[i];; 373 fZ[i] = z[i];; 374 }; 375}; 376 ; 377 ; 378////////////////////////////////////////////////////////////////////////////////; 379/// Graph2D constructor. The arrays fX, fY and fZ should be filled via; 380/// calls to SetPoint; 381 ; 382TGraph2D::TGraph2D(Int_t n); 383 : TNamed(""Graph2D"", ""Graph2D""), TAttLine(1, 1, 1), TAttFill(0, 1001), fNpoints(n); 384{; 385 Build(n);; 386 for (Int_t i = 0; i < fNpoints; i++) {; 387 fX[i] = 0.;; 388 fY[i] = 0.;; 389 fZ[i] = 0.;; 390 }; 391}; 392 ; 393 ; 394////////////////////////////////////////////////////////////////////////////////; 395/// Graph2D constructor reading input from filename; 396/// filename is assumed to contain at least three columns of numbers.; 397/// For files separated by a specific delimiter different from ' ' and '\\t' (e.g. ';' in csv files); 398/// you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; 399/// e.g. option="" \\t,;"" for columns of figures separated by any of these characters (' ', '\\t', ',', ';'); 400/// used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; 401/// Note in that case, the instantiation is about 2 times slower.; 402 ; 403TGraph2D::TGraph2D(const char *filename, const char *format, Option_t *option); 404 : TNamed(""Graph2D"", filename), TAttLine(1, 1, 1), TAttFill(0, 1001), fNpoints(0); 405{; 406 Double_t x, y, z;; 407 TString fname = filename;; 408 gSystem->ExpandPathName(fname);; 409 ; 410 std::ifstream infile(fname.Data());; 411 if (!infile.good()) {; 412 MakeZombie();; 413 Error(""TGraph2D"", ""Cannot open file: %s, TGraph2D is Zombie"", filename);; 414 return;; 415 } else {; 416 Build(100);; 417 }; 418 std::string line;; 419 Int_t np = 0;; 420 ; 421 if (strcmp(option, """") == 0) { // No delimiters specified (standard constructor).; 422 ; 423 while (std::getline(infile, line, '\n')) {; 424 if (3 != ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2D_8cxx_source.html:13492,avoid,avoid,13492,doc/master/TGraph2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html,1,['avoid'],['avoid']
Safety,"; 3738 if (GetOffset() == TStreamerInfo::kMissing) {; 3739 fObject = nullptr;; 3740 }; 3741 }; 3742 }; 3743 const bool isSplitNode = (fType == 2 || fType == 1 || (fType == 0 && fID == -2)) && !fBranches.IsEmpty();; 3744 if (fReadActionSequence && isSplitNode) {; 3745 TBranchElement *parent = dynamic_cast<TBranchElement*>(GetMother()->GetSubBranch(this));; 3746 auto index = parent->fBranches.IndexOf(this);; 3747 if (index >= 0) {; 3748 fReadActionSequence->AddToOffset( - parent->fBranchOffset[index] );; 3749 }; 3750 }; 3751 ; 3752 fInitOffsets = true;; 3753}; 3754 ; 3755////////////////////////////////////////////////////////////////////////////////; 3756/// Return true if more than one leaf, false otherwise.; 3757 ; 3758bool TBranchElement::IsFolder() const; 3759{; 3760 Int_t nbranches = fBranches.GetEntriesFast();; 3761 if (nbranches >= 1) {; 3762 return true;; 3763 }; 3764 TList* browsables = const_cast<TBranchElement*>(this)->GetBrowsables();; 3765 return browsables && browsables->GetSize();; 3766}; 3767 ; 3768////////////////////////////////////////////////////////////////////////////////; 3769/// Detect a collection written using a zero pointer in old versions of root.; 3770/// In versions of ROOT older than 4.00/03, if a collection (TClonesArray; 3771/// or STL container) was split but the pointer to the collection was zeroed; 3772/// out, nothing was saved. Hence there is no __easy__ way to detect the; 3773/// case. In newer versions, a zero is written so that a 'missing' collection; 3774/// appears to be an empty collection.; 3775 ; 3776bool TBranchElement::IsMissingCollection() const; 3777{; 3778 bool ismissing = false;; 3779 TBasket* basket = (TBasket*) fBaskets.UncheckedAt(fReadBasket);; 3780 if (basket && fTree) {; 3781 Long64_t entry = fTree->GetReadEntry();; 3782 Long64_t first = fBasketEntry[fReadBasket];; 3783 Long64_t last;; 3784 if (fReadBasket == fWriteBasket) {; 3785 last = fEntryNumber - 1;; 3786 } else {; 3787 last = fBasketEntry[fReadBasket+1] ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:138488,Detect,Detect,138488,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['Detect'],['Detect']
Safety,"; 394 delete fViewer3D;; 395 ; 396 // Required since we overload TObject::Hash.; 397 ROOT::CallRecursiveRemoveIfNeeded(*this);; 398 if (this == gPad); 399 gPad = nullptr;; 400}; 401 ; 402////////////////////////////////////////////////////////////////////////////////; 403/// Add an object to list of primitives with speicified draw option; 404/// When \par modified set to kTRUE (default) pad will be marked as modified; 405/// Let avoid usage of gPad when drawing object(s) in canvas or in subpads.; 406///; 407/// ~~~{.cpp}; 408/// auto c1 = new TCanvas(""c1"",""Canvas with subpoads"", 600, 600);; 409/// c1->Divide(2,2);; 410///; 411/// for (Int_t n = 1; n <= 4; ++n) {; 412/// auto h1 = new TH1I(TString::Format(""hist_%d"",n), ""Random hist"", 100, -5, 5);; 413/// h1->FillRandom(""gaus"", 2000 + n*1000);; 414/// c1->GetPad(n)->Add(h1);; 415/// }; 416/// ~~~; 417 ; 418void TPad::Add(TObject *obj, Option_t *opt, Bool_t modified); 419{; 420 if (!obj); 421 return;; 422 ; 423 if (!fPrimitives); 424 fPrimitives = new TList;; 425 ; 426 obj->SetBit(kMustCleanup);; 427 ; 428 fPrimitives->Add(obj, opt);; 429 ; 430 if (modified); 431 Modified();; 432}; 433 ; 434////////////////////////////////////////////////////////////////////////////////; 435/// Add an object as first in list of primitives with speicified draw option; 436/// When \par modified set to kTRUE (default) pad will be marked as modified; 437/// Let avoid usage of gPad when drawing object(s) in canvas or in subpads.; 438 ; 439void TPad::AddFirst(TObject *obj, Option_t *opt, Bool_t modified); 440{; 441 if (!obj); 442 return;; 443 ; 444 if (!fPrimitives); 445 fPrimitives = new TList;; 446 ; 447 obj->SetBit(kMustCleanup);; 448 ; 449 fPrimitives->AddFirst(obj, opt);; 450 ; 451 if (modified); 452 Modified();; 453}; 454 ; 455////////////////////////////////////////////////////////////////////////////////; 456/// Add a new TExec object to the list of Execs.; 457///; 458/// When an event occurs in the pad (mouse click, etc) the list of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:13061,avoid,avoid,13061,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['avoid'],['avoid']
Safety,"; 43 Double_t Capacity() const override;; 44 void ComputeBBox() override;; 45 void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override;; 46 void ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;; 47 void ComputeTwist();; 48 Bool_t Contains(const Double_t *point) const override;; 49 void Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override;; 50 Double_t DistToPlane(const Double_t *point, const Double_t *dir, Int_t ipl, Bool_t in) const;; 51 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 52 Double_t *safe = nullptr) const override;; 53 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 54 Double_t *step) const override;; 55 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 56 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 57 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 58 Double_t *step) const override;; 59 TGeoVolume *; 60 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 61 Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;; 62 void GetBoundingCylinder(Double_t *param) const override;; 63 Int_t GetByteCount() const override { return 100; }; 64 Double_t GetClosestEdge(const Double_t *point, Double_t *vert, Int_t &isegment) const;; 65 Bool_t GetPointsOnFacet(Int_t /*index*/, Int_t /*npoints*/, Double_t * /*array*/) const override;; 66 Double_t GetDz() const { return fDz; }; 67 Int_t; 68 GetFittingBox(const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;; 69 TGeoShape *GetMakeRuntimeShape(TGeoShape * /*mother*/, TGeoMatrix * /*mat*/) const override { return nullptr; }; 70 static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:2531,safe,safe,2531,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,1,['safe'],['safe']
Safety,"; 45#include ""TDataMember.h""; 46#include ""TMemberInspector.h""; 47#include ""TMethod.h""; 48#include ""TMethodArg.h""; 49#include ""TFunctionTemplate.h""; 50#include ""TObjArray.h""; 51#include ""TObjString.h""; 52#include ""TString.h""; 53#include ""THashList.h""; 54#include ""TVirtualPad.h""; 55#include ""TSystem.h""; 56#include ""TVirtualMutex.h""; 57#include ""TError.h""; 58#include ""TEnv.h""; 59#include ""TEnum.h""; 60#include ""TEnumConstant.h""; 61#include ""THashTable.h""; 62#include ""RConversionRuleParser.h""; 63#include ""RConfigure.h""; 64#include ""compiledata.h""; 65#include ""strlcpy.h""; 66#include ""snprintf.h""; 67#include ""TClingUtils.h""; 68#include ""TVirtualCollectionProxy.h""; 69#include ""TVirtualStreamerInfo.h""; 70#include ""TListOfDataMembers.h""; 71#include ""TListOfEnums.h""; 72#include ""TListOfEnumsWithLock.h""; 73#include ""TListOfFunctions.h""; 74#include ""TListOfFunctionTemplates.h""; 75#include ""TMemFile.h""; 76#include ""TProtoClass.h""; 77#include ""TStreamerInfo.h"" // This is here to avoid to use the plugin manager; 78#include ""ThreadLocalStorage.h""; 79#include ""TFile.h""; 80#include ""TKey.h""; 81#include ""ClingRAII.h""; 82 ; 83#include ""clang/AST/ASTContext.h""; 84#include ""clang/AST/Decl.h""; 85#include ""clang/AST/DeclarationName.h""; 86#include ""clang/AST/GlobalDecl.h""; 87#include ""clang/AST/RecordLayout.h""; 88#include ""clang/AST/DeclVisitor.h""; 89#include ""clang/AST/RecursiveASTVisitor.h""; 90#include ""clang/AST/Type.h""; 91#include ""clang/Basic/SourceLocation.h""; 92#include ""clang/Basic/Specifiers.h""; 93#include ""clang/Basic/TargetInfo.h""; 94#include ""clang/CodeGen/ModuleBuilder.h""; 95#include ""clang/Frontend/CompilerInstance.h""; 96#include ""clang/Frontend/FrontendDiagnostic.h""; 97#include ""clang/Lex/HeaderSearch.h""; 98#include ""clang/Lex/Preprocessor.h""; 99#include ""clang/Lex/PreprocessorOptions.h""; 100#include ""clang/Parse/Parser.h""; 101#include ""clang/Sema/Lookup.h""; 102#include ""clang/Sema/Sema.h""; 103#include ""clang/Serialization/ASTReader.h""; 104#include ""clang/Serialization/GlobalM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:2501,avoid,avoid,2501,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avoid'],['avoid']
Safety,"; 4775 TClingClassInfo *cl = (TClingClassInfo*)opaque_cl;; 4776 ; 4777 // Could trigger deserialization of decls.; 4778 cling::Interpreter::PushTransactionRAII RAII(GetInterpreterImpl());; 4779 ; 4780 if (cl) {; 4781 d = cl->GetDataMember(name);; 4782 // We check if the decl of the data member has an annotation which indicates; 4783 // an ioname.; 4784 // In case this is true, if the name requested is not the ioname, we; 4785 // return 0, as if the member did not exist. In some sense we override; 4786 // the information in the TClassInfo instance, isolating the typesystem in; 4787 // TClass from the one in the AST.; 4788 if (const ValueDecl* decl = (const ValueDecl*) d){; 4789 std::string ioName;; 4790 bool hasIoName = ROOT::TMetaUtils::ExtractAttrPropertyFromName(*decl,""ioname"",ioName);; 4791 if (hasIoName && ioName != name) return nullptr;; 4792 }; 4793 return d;; 4794 }; 4795 // We are looking up for something on the TU scope.; 4796 // FIXME: We do not want to go through TClingClassInfo(fInterpreter) because of redundant deserializations. That; 4797 // interface will actually construct iterators and walk over the decls on the global scope. In would return the first; 4798 // occurrence of a decl with the looked up name. However, that's not what C++ lookup would do: if we want to switch; 4799 // to a more complete C++ lookup interface we need sift through the found names and pick up the declarations which; 4800 // are only fulfilling ROOT's understanding for a Data Member.; 4801 // FIXME: We should probably deprecate the TClingClassInfo(fInterpreter) interface and replace it withe something; 4802 // similar as below.; 4803 using namespace clang;; 4804 Sema& SemaR = fInterpreter->getSema();; 4805 DeclarationName DName = &SemaR.Context.Idents.get(name);; 4806 ; 4807 LookupResult R(SemaR, DName, SourceLocation(), Sema::LookupOrdinaryName,; 4808 Sema::ForExternalRedeclaration);; 4809 ; 4810 cling::utils::Lookup::Named(&SemaR, R);; 4811 ; 4812 LookupResult::Filter F = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:186721,redund,redundant,186721,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['redund'],['redundant']
Safety,"; 528 SafeDelete(fOverlaps);; 529 }; 530 if (fRegions) {; 531 fRegions->Delete();; 532 SafeDelete(fRegions);; 533 }; 534 if (fMaterials) {; 535 fMaterials->Delete();; 536 SafeDelete(fMaterials);; 537 }; 538 SafeDelete(fElementTable);; 539 if (fMedia) {; 540 fMedia->Delete();; 541 SafeDelete(fMedia);; 542 }; 543 if (fHashVolumes) {; 544 fHashVolumes->Clear(""nodelete"");; 545 SafeDelete(fHashVolumes);; 546 }; 547 if (fHashGVolumes) {; 548 fHashGVolumes->Clear(""nodelete"");; 549 SafeDelete(fHashGVolumes);; 550 }; 551 if (fHashPNE) {; 552 fHashPNE->Delete();; 553 SafeDelete(fHashPNE);; 554 }; 555 if (fArrayPNE) {; 556 delete fArrayPNE;; 557 }; 558 if (fVolumes) {; 559 fVolumes->Delete();; 560 SafeDelete(fVolumes);; 561 }; 562 if (fShapes) {; 563 fShapes->Delete();; 564 SafeDelete(fShapes);; 565 }; 566 if (fPhysicalNodes) {; 567 fPhysicalNodes->Delete();; 568 SafeDelete(fPhysicalNodes);; 569 }; 570 if (fMatrices) {; 571 fMatrices->Delete();; 572 SafeDelete(fMatrices);; 573 }; 574 if (fTracks) {; 575 fTracks->Delete();; 576 SafeDelete(fTracks);; 577 }; 578 SafeDelete(fUniqueVolumes);; 579 if (fPdgNames) {; 580 fPdgNames->Delete();; 581 SafeDelete(fPdgNames);; 582 }; 583 if (fGDMLMatrices) {; 584 fGDMLMatrices->Delete();; 585 SafeDelete(fGDMLMatrices);; 586 }; 587 if (fOpticalSurfaces) {; 588 fOpticalSurfaces->Delete();; 589 SafeDelete(fOpticalSurfaces);; 590 }; 591 if (fSkinSurfaces) {; 592 fSkinSurfaces->Delete();; 593 SafeDelete(fSkinSurfaces);; 594 }; 595 if (fBorderSurfaces) {; 596 fBorderSurfaces->Delete();; 597 SafeDelete(fBorderSurfaces);; 598 }; 599 ClearNavigators();; 600 CleanGarbage();; 601 SafeDelete(fPainter);; 602 SafeDelete(fGLMatrix);; 603 if (fSizePNEId) {; 604 delete[] fKeyPNEId;; 605 delete[] fValuePNEId;; 606 }; 607 delete fParallelWorld;; 608 fIsGeomCleaning = kFALSE;; 609 gGeoIdentity = nullptr;; 610 gGeoManager = nullptr;; 611}; 612 ; 613////////////////////////////////////////////////////////////////////////////////; 614/// Add a material to the list.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:22564,Safe,SafeDelete,22564,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,9,['Safe'],['SafeDelete']
Safety,"; 58#ifdef R__USE_IMT; 59 friend class TBasket;; 60#endif; 61 ; 62public:; 63 /// Asynchronous open request status; 64 enum EAsyncOpenStatus { kAOSNotAsync = -1, kAOSFailure = 0,; 65 kAOSInProgress = 1, kAOSSuccess = 2 };; 66 /// Open timeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:1996,timeout,timeout,1996,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['timeout'],['timeout']
Safety,"; 65 void GetBoundingCylinder(Double_t *param) const override;; 66 const TBuffer3D &GetBuffer3D(Int_t reqSections, Bool_t localFrame) const override;; 67 Int_t GetByteCount() const override { return 48; }; 68 Bool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override;; 69 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 70 void GetMeshNumbers(Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;; 71 Int_t GetNmeshVertices() const override;; 72 virtual Double_t GetRmin() const { return fRmin; }; 73 virtual Double_t GetRmax() const { return fRmax; }; 74 virtual Double_t GetDz() const { return fDz; }; 75 Bool_t HasRmin() const { return (fRmin > 0) ? kTRUE : kFALSE; }; 76 void InspectShape() const override;; 77 Bool_t IsCylType() const override { return kTRUE; }; 78 TBuffer3D *MakeBuffer3D() const override;; 79 Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const override;; 80 void Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;; 81 static Double_t; 82 SafetyS(const Double_t *point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0);; 83 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 84 void SetTubeDimensions(Double_t rmin, Double_t rmax, Double_t dz);; 85 void SetDimensions(Double_t *param) override;; 86 void SetPoints(Double_t *points) const override;; 87 void SetPoints(Float_t *points) const override;; 88 void SetSegsAndPols(TBuffer3D &buff) const override;; 89 void Sizeof3D() const override;; 90 ; 91 ClassDefOverride(TGeoTube, 1) // cylindrical tube class; 92};; 93 ; 94class TGeoTubeSeg : public TGeoTube {; 95protected:; 96 // data members; 97 Double_t fPhi1; // first phi limit; 98 Double_t fPhi2; // second phi limit; 99 // Transient trigonometric data; 100 Double_t fS1; // sin(phi1); 101 Double_t fC1; // cos(phi1); 102 Double_t fS2; // sin(phi2); 103 Double_t fC2; // cos(phi2); 104 Double_t fSm; // sin(0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoTube_8h_source.html:4264,safe,safe,4264,doc/master/TGeoTube_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html,2,"['Safe', 'safe']","['SafetyS', 'safe']"
Safety,"; 659 return DisplacementVector3D<CoordSystem>(operator()(Vector(v)));; 660 }; 661 /**; 662 Transformation operation for Displacement Vector in any coordinate system; 663 */; 664 template <class CoordSystem>; 665 DisplacementVector3D<CoordSystem> operator*(const DisplacementVector3D<CoordSystem> &v) const; 666 {; 667 return operator()(v);; 668 }; 669 ; 670 /**; 671 Directly apply the inverse affine transformation on vectors.; 672 Avoids having to calculate the inverse as an intermediate result.; 673 This is possible since the inverse of a rotation is its transpose.; 674 */; 675 Vector ApplyInverse(const Vector &v) const; 676 {; 677 return Vector(fM[kXX] * v.X() + fM[kYX] * v.Y() + fM[kZX] * v.Z(),; 678 fM[kXY] * v.X() + fM[kYY] * v.Y() + fM[kZY] * v.Z(),; 679 fM[kXZ] * v.X() + fM[kYZ] * v.Y() + fM[kZZ] * v.Z());; 680 }; 681 ; 682 /**; 683 Directly apply the inverse affine transformation on points; 684 (first inverse translation then inverse rotation).; 685 Avoids having to calculate the inverse as an intermediate result.; 686 This is possible since the inverse of a rotation is its transpose.; 687 */; 688 Point ApplyInverse(const Point &p) const; 689 {; 690 Point tmp(p.X() - fM[kDX], p.Y() - fM[kDY], p.Z() - fM[kDZ]);; 691 return Point(fM[kXX] * tmp.X() + fM[kYX] * tmp.Y() + fM[kZX] * tmp.Z(),; 692 fM[kXY] * tmp.X() + fM[kYY] * tmp.Y() + fM[kZY] * tmp.Z(),; 693 fM[kXZ] * tmp.X() + fM[kYZ] * tmp.Y() + fM[kZZ] * tmp.Z());; 694 }; 695 ; 696 /**; 697 Directly apply the inverse affine transformation on an arbitrary; 698 coordinate-system point.; 699 Involves casting to Point(p) type.; 700 */; 701 template <class CoordSystem>; 702 PositionVector3D<CoordSystem> ApplyInverse(const PositionVector3D<CoordSystem> &p) const; 703 {; 704 return PositionVector3D<CoordSystem>(ApplyInverse(Point(p)));; 705 }; 706 ; 707 /**; 708 Directly apply the inverse affine transformation on an arbitrary; 709 coordinate-system vector.; 710 Involves casting to Vector(p) type.; 711 */; 712 template ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html:23459,Avoid,Avoids,23459,doc/master/GenVector_2Transform3D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html,1,['Avoid'],['Avoids']
Safety,"; 6834 ; 6835////////////////////////////////////////////////////////////////////////////////; 6836/// Check if adding nbytes to memory we are still below MaxVirtualsize.; 6837 ; 6838bool TTree::MemoryFull(Int_t nbytes); 6839{; 6840 if ((fTotalBuffers + nbytes) < fMaxVirtualSize) {; 6841 return false;; 6842 }; 6843 return true;; 6844}; 6845 ; 6846////////////////////////////////////////////////////////////////////////////////; 6847/// Static function merging the trees in the TList into a new tree.; 6848///; 6849/// Trees in the list can be memory or disk-resident trees.; 6850/// The new tree is created in the current directory (memory if gROOT).; 6851 ; 6852TTree* TTree::MergeTrees(TList* li, Option_t* options); 6853{; 6854 if (!li) return nullptr;; 6855 TIter next(li);; 6856 TTree *newtree = nullptr;; 6857 TObject *obj;; 6858 ; 6859 while ((obj=next())) {; 6860 if (!obj->InheritsFrom(TTree::Class())) continue;; 6861 TTree *tree = (TTree*)obj;; 6862 Long64_t nentries = tree->GetEntries();; 6863 if (nentries == 0) continue;; 6864 if (!newtree) {; 6865 newtree = (TTree*)tree->CloneTree(-1, options);; 6866 if (!newtree) continue;; 6867 ; 6868 // Once the cloning is done, separate the trees,; 6869 // to avoid as many side-effects as possible; 6870 // The list of clones is guaranteed to exist since we; 6871 // just cloned the tree.; 6872 tree->GetListOfClones()->Remove(newtree);; 6873 tree->ResetBranchAddresses();; 6874 newtree->ResetBranchAddresses();; 6875 continue;; 6876 }; 6877 ; 6878 newtree->CopyEntries(tree, -1, options, true);; 6879 }; 6880 if (newtree && newtree->GetTreeIndex()) {; 6881 newtree->GetTreeIndex()->Append(nullptr,false); // Force the sorting; 6882 }; 6883 return newtree;; 6884}; 6885 ; 6886////////////////////////////////////////////////////////////////////////////////; 6887/// Merge the trees in the TList into this tree.; 6888///; 6889/// Returns the total number of entries in the merged tree.; 6890 ; 6891Long64_t TTree::Merge(TCollection* li, Optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:268852,avoid,avoid,268852,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['avoid'],['avoid']
Safety,"; 697 newCols.AddDefine(std::move(newColumn));; 698 ; 699 RInterface<Proxied> newInterface(fProxiedPtr, *fLoopManager, std::move(newCols));; 700 ; 701 return newInterface;; 702 }; 703 ; 704 // clang-format off; 705 ////////////////////////////////////////////////////////////////////////////; 706 /// \brief Define a new column that is updated when the input sample changes.; 707 /// \param[in] name The name of the defined column.; 708 /// \param[in] expression A C++ callable that computes the new value of the defined column.; 709 /// \return the first node of the computation graph for which the new quantity is defined.; 710 ///; 711 /// The signature of the callable passed as second argument should be `T(unsigned int slot, const ROOT::RDF::RSampleInfo &id)`; 712 /// where:; 713 /// - `T` is the type of the defined column; 714 /// - `slot` is a number in the range [0, nThreads) that is different for each processing thread. This can simplify; 715 /// the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; 716 /// - `id` is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is; 717 /// being processed (see the class docs for more information).; 718 ///; 719 /// DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being; 720 /// processed or to inject a callback into the event loop that is only called when the processing of a new sample; 721 /// starts rather than at every entry.; 722 ///; 723 /// The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often.; 724 ///; 725 /// ### Example usage:; 726 /// ~~~{.cpp}; 727 /// ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; 728 /// df.DefinePerSample(""weightbysample"",; 729 /// [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); 730 /// { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; 731 /// ~~~; 732 // clang-format ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:37673,safe,safe,37673,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['safe'],['safe']
Safety,"; 895void TF1::SetFunction(PtrObj &p, MemFn memFn); 896{; 897 // set from a pointer to a member function; 898 fType = EFType::kPtrScalarFreeFcn;; 899 fFunctor = std::make_unique<TF1::TF1FunctorPointerImpl<double>>(ROOT::Math::ParamFunctor(p, memFn));; 900}; 901 ; 902template <class T>; 903inline T TF1::GradientPar(Int_t ipar, const T *x, Double_t eps); 904{; 905 if (fType == EFType::kTemplVec || fType == EFType::kTemplScalar) {; 906 return GradientParTempl<T>(ipar, x, eps);; 907 } else; 908 return GradientParTempl<Double_t>(ipar, (const Double_t *)x, eps);; 909}; 910 ; 911template <class T>; 912inline T TF1::GradientParTempl(Int_t ipar, const T *x, Double_t eps); 913{; 914 if (GetNpar() == 0); 915 return 0;; 916 ; 917 if (eps < 1e-10 || eps > 1) {; 918 Warning(""Derivative"", ""parameter esp=%g out of allowed range[1e-10,1], reset to 0.01"", eps);; 919 eps = 0.01;; 920 }; 921 Double_t h;; 922 TF1 *func = (TF1 *)this;; 923 Double_t *parameters = GetParameters();; 924 ; 925 // Copy parameters for thread safety; 926 std::vector<Double_t> parametersCopy(parameters, parameters + GetNpar());; 927 parameters = parametersCopy.data();; 928 ; 929 Double_t al, bl, h2;; 930 T f1, f2, g1, g2, d0, d2;; 931 ; 932 ((TF1 *)this)->GetParLimits(ipar, al, bl);; 933 if (al * bl != 0 && al >= bl) {; 934 // this parameter is fixed; 935 return 0;; 936 }; 937 ; 938 // check if error has been computer (is not zero); 939 if (func->GetParError(ipar) != 0); 940 h = eps * func->GetParError(ipar);; 941 else; 942 h = eps;; 943 ; 944 // save original parameters; 945 Double_t par0 = parameters[ipar];; 946 ; 947 parameters[ipar] = par0 + h;; 948 f1 = func->EvalPar(x, parameters);; 949 parameters[ipar] = par0 - h;; 950 f2 = func->EvalPar(x, parameters);; 951 parameters[ipar] = par0 + h / 2;; 952 g1 = func->EvalPar(x, parameters);; 953 parameters[ipar] = par0 - h / 2;; 954 g2 = func->EvalPar(x, parameters);; 955 ; 956 // compute the central differences; 957 h2 = 1 / (2. * h);; 958 d0 = f1 - f2;; 959 d2 = 2 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8h_source.html:38839,safe,safety,38839,doc/master/TF1_8h_source.html,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html,1,['safe'],['safety']
Safety,"; 904 return std::numeric_limits<Double_t>::quiet_NaN();; 905}; 906 ; 907////////////////////////////////////////////////////////////////////////////////; 908/// Returns a signaling NaN as defined by IEEE 754](http://en.wikipedia.org/wiki/NaN#Signaling_NaN).; 909 ; 910inline Double_t TMath::SignalingNaN() {; 911 return std::numeric_limits<Double_t>::signaling_NaN();; 912}; 913 ; 914////////////////////////////////////////////////////////////////////////////////; 915/// Returns an infinity as defined by the IEEE standard.; 916 ; 917inline Double_t TMath::Infinity() {; 918 return std::numeric_limits<Double_t>::infinity();; 919}; 920 ; 921////////////////////////////////////////////////////////////////////////////////; 922/// Returns maximum representation for type T.; 923 ; 924template<typename T>; 925inline T TMath::Limits<T>::Min() {; 926 return (std::numeric_limits<T>::min)(); //N.B. use this signature to avoid class with macro min() on Windows; 927}; 928 ; 929////////////////////////////////////////////////////////////////////////////////; 930/// Returns minimum double representation.; 931 ; 932template<typename T>; 933inline T TMath::Limits<T>::Max() {; 934 return (std::numeric_limits<T>::max)(); //N.B. use this signature to avoid class with macro max() on Windows; 935}; 936 ; 937////////////////////////////////////////////////////////////////////////////////; 938/// Returns minimum double representation.; 939 ; 940template<typename T>; 941inline T TMath::Limits<T>::Epsilon() {; 942 return std::numeric_limits<T>::epsilon();; 943}; 944 ; 945////////////////////////////////////////////////////////////////////////////////; 946// Advanced.; 947 ; 948////////////////////////////////////////////////////////////////////////////////; 949/// Calculates the Normalized Cross Product of two vectors.; 950 ; 951template <typename T> inline T TMath::NormCross(const T v1[3],const T v2[3],T out[3]); 952{; 953 return Normalize(Cross(v1,v2,out));; 954}; 955 ; 956///////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:33649,avoid,avoid,33649,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['avoid'],['avoid']
Safety,"; 9104 ; 9105////////////////////////////////////////////////////////////////////////////////; 9106/// Set number of entries to estimate variable limits.; 9107/// If n is -1, the estimate is set to be the current maximum; 9108/// for the tree (i.e. GetEntries() + 1); 9109/// If n is less than -1, the behavior is undefined.; 9110 ; 9111void TTree::SetEstimate(Long64_t n /* = 1000000 */); 9112{; 9113 if (n == 0) {; 9114 n = 10000;; 9115 } else if (n < 0) {; 9116 n = fEntries - n;; 9117 }; 9118 fEstimate = n;; 9119 GetPlayer();; 9120 if (fPlayer) {; 9121 fPlayer->SetEstimate(n);; 9122 }; 9123}; 9124 ; 9125////////////////////////////////////////////////////////////////////////////////; 9126/// Provide the end-user with the ability to enable/disable various experimental; 9127/// IO features for this TTree.; 9128///; 9129/// Returns all the newly-set IO settings.; 9130 ; 9131ROOT::TIOFeatures TTree::SetIOFeatures(const ROOT::TIOFeatures &features); 9132{; 9133 // Purposely ignore all unsupported bits; TIOFeatures implementation already warned the user about the; 9134 // error of their ways; this is just a safety check.; 9135 UChar_t featuresRequested = features.GetFeatures() & static_cast<UChar_t>(TBasket::EIOBits::kSupported);; 9136 ; 9137 UChar_t curFeatures = fIOFeatures.GetFeatures();; 9138 UChar_t newFeatures = ~curFeatures & featuresRequested;; 9139 curFeatures |= newFeatures;; 9140 fIOFeatures.Set(curFeatures);; 9141 ; 9142 ROOT::TIOFeatures newSettings(newFeatures);; 9143 return newSettings;; 9144}; 9145 ; 9146////////////////////////////////////////////////////////////////////////////////; 9147/// Set fFileNumber to number.; 9148/// fFileNumber is used by TTree::Fill to set the file name; 9149/// for a new file to be created when the current file exceeds fgTreeMaxSize.; 9150/// (see TTree::ChangeFile); 9151/// if fFileNumber=10, the new file name will have a suffix ""_11"",; 9152/// ie, fFileNumber is incremented before setting the file name; 9153 ; 9154void TTree:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:353057,safe,safety,353057,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['safe'],['safety']
Safety,"; 94 ; 95### Transformations; 96Transformations are a way to manipulate the data.; 97 ; 98| **Transformation** | **Description** |; 99|------------------|--------------------|; 100| Alias() | Introduce an alias for a particular column name. |; 101| DefaultValueFor() | If the value of the input column is missing, provide a default value instead. |; 102| Define() | Create a new column in the dataset. Example usages include adding a column that contains the invariant mass of a particle, or a selection of elements of an array (e.g. only the `pt`s of ""good"" muons). |; 103| DefinePerSample() | Define a new column that is updated when the input sample changes, e.g. when switching tree being processed in a chain. |; 104| DefineSlot() | Same as Define(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Define() transformation when using RDataFrame after ROOT::EnableImplicitMT(). DefineSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; 105| DefineSlotEntry() | Same as DefineSlot(), but the entry number is passed in addition to the slot number. This is meant as a helper in case the expression depends on the entry number. For details about entry numbers in multi-threaded runs, see [here](\ref helper-cols). |; 106| Filter() | Filter rows based on user-defined conditions. |; 107| FilterAvailable() | Specialized Filter. If the value of the input column is available, keep the entry, otherwise discard it. |; 108| FilterMissing() | Specialized Filter. If the value of the input column is missing, keep the entry, otherwise discard it. |; 109| Range() | Filter rows based on entry number (single-thread only). |; 110| Redefine() | Overwrite the value and/or type of an existing column. See Define() for more information. |; 111| RedefineSlot() | Overwrite the value ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:5667,safe,safe,5667,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety,"; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; Â» GEOM; Â» GEOM; Â» TGeoVolumeMulti. class TGeoVolumeMulti: public TGeoVolume. TGeoVolume - the base class representing solids. Volumes are the basic objects used in building the geometrical hierarchy.; They represent unpositioned objects but store all information about the; placement of the other volumes they may contain. Therefore a volume can; be replicated several times in the geometry. In order to create a volume, one; has to put togeather a shape and a medium which are already defined. Volumes; have to be named by users at creation time. Every different name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoVolumeMulti.html:1088,avoid,avoid,1088,root/html528/TGeoVolumeMulti.html,https://root.cern,https://root.cern/root/html528/TGeoVolumeMulti.html,3,['avoid'],['avoid']
Safety,"; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; Â» CORE; Â» BASE; Â» TTimer. class TTimer: public TSysEvtHandler. TTimer. Handles synchronous and a-synchronous timer events.; 1. synchronous timer is registered into TSystem and is processed; within the standard ROOT event-loop.; 2. asynchronous timer is passed to the operating system which sends; an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; - Sub-class TTimer and override the Notify() method.; - Re-implement the TObject::HandleTimer() method in your class; and pass a pointer to this object to timer, see the SetObject(); method.; - Pass an interpreter command to timer, see SetCommand() method.; - Create a TTimer, connect its Timeout() signal to the; appropriate methods. Then when the time is up it will emit a; Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as; kItimerResolution (currently 10 ms). Signal/slots example:; TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot. To emit the Timeout signal repeadetly with minimum timeout:; timer->Start(0, kFALSE);. Function Members (Methods); public:. virtual~TTimer(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTimer.html:1037,Timeout,Timeout,1037,root/html602/TTimer.html,https://root.cern,https://root.cern/root/html602/TTimer.html,2,['Timeout'],['Timeout']
Safety,"; Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TSocket(const TSocket& s); TSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSocket.html:13565,timeout,timeout,13565,root/html534/TSocket.html,https://root.cern,https://root.cern/root/html534/TSocket.html,3,['timeout'],['timeout']
Safety,"; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome Â» Development Coding Conventions. Naming conventions; Class definition conventions. Inline; Declaration Order. Avoid raw C types; Exception handling; Namespaces; Using comments to document the code; Source file layout. Header file layout; Implementation file layout. Preferred Coding Style. Indentation; Placing Braces and Spaces. ClangFormat; Astyle; Where to go from here. Naming conventions; For naming conventions we follow the Taligent rules. They have written a very large body of C++ and their rules seem well thought out. No need to invent something new. The only addition/change we made is to append an _t to typedefs and simple structs, e.g.:; typedef int Int_t ; struct Simple_t { ..... } ; ; Addherence to the rules is mandatory. After a while one really gets used to the fact that all class fields start with an f followed by a capitalized word, fEnergy, or that TStreamerInfo is a class. If the convention is sporadically violated debugging becomes a nightmare. The usage of a standard begin letter or token for the different types also makes it easy to parse and search the code using simple tools.; Class definition conventions; Also here the Talig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/coding-conventions.html:1964,Avoid,Avoid,1964,d/coding-conventions.html,https://root.cern,https://root.cern/d/coding-conventions.html,1,['Avoid'],['Avoid']
Safety,"; Int_tÂ BroadcastRaw (const void *buffer, Int_t length, ESlaves list=kActive); Â Broadcast a raw buffer of specified length to all slaves in the specified list. ; Â ; Int_tÂ BroadcastRaw (const void *buffer, Int_t length, TList *slaves); Â Broadcast a raw buffer of specified length to all slaves in the specified list. ; Â ; Int_tÂ BuildPackage (const char *package, EBuildPackageOpt opt=kBuildAll, Int_t chkveropt=TPackMgr::kCheckROOT, TList *workers=0); Â Build specified package. ; Â ; Bool_tÂ CheckFile (const char *file, TSlave *sl, Long_t modtime, Int_t cpopt=(kCp|kCpBin)); Â Check if a file needs to be send to the slave. ; Â ; voidÂ CleanGDirectory (TList *ol); Â Remove links to objects in list 'ol' from gDirectory. ; Â ; voidÂ ClearDataProgress (Int_t r, Int_t t); Â Progress bar for clear data. ; Â ; Int_tÂ Collect (const TSlave *sl, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE); Â Collect responses from slave sl. ; Â ; Int_tÂ Collect (TMonitor *mon, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE); Â Collect responses from the slave servers. ; Â ; Int_tÂ CollectInputFrom (TSocket *s, Int_t endtype=-1, Bool_t deactonfail=kFALSE); Â Collect and analyze available input from socket s. ; Â ; Bool_tÂ CreateMerger (TSlave *sl, Int_t port); Â Create a new merger. ; Â ; voidÂ DeActivateAsyncInput (); Â De-activate a-sync input handler. ; Â ; Int_tÂ DisablePackage (const char *package); Â Remove a specific package. ; Â ; Int_tÂ DisablePackages (); Â Remove all packages. ; Â ; Int_tÂ Exec (const char *cmd, ESlaves list, Bool_t plusMaster); Â Send command to be executed on the PROOF master and/or slaves. ; Â ; voidÂ FinalizationDone (); Â ; Int_tÂ FindNextFreeMerger (); Â Return a merger, which is both active and still accepts some workers to be assigned to it. ; Â ; TSlave *Â FindSlave (TSocket *s) const; Â Find slave that has TSocket s. Returns 0 in case slave is not found. ; Â ; virtual voidÂ FindUniqueSlaves (); Â Add to the fUniqueSlave list the active slaves that have a unique (user) fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:47883,timeout,timeout,47883,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['timeout'],['timeout']
Safety,"; Libraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoIntersection(); Default constructor. TGeoIntersection(const char* expr1, const char* expr2); Constructor. TGeoIntersection(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoIntersection(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a intersection of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a intersection of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this intersection. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. Â» Author: Andrei Gheata 30/05/02 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ Â» Last generated: 2010-12-10 11:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoIntersection.html:8751,safe,safe,8751,root/html528/TGeoIntersection.html,https://root.cern,https://root.cern/root/html528/TGeoIntersection.html,1,['safe'],['safe']
Safety,"; Libraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoIntersection(); Default constructor. TGeoIntersection(const char* expr1, const char* expr2); Constructor. TGeoIntersection(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoIntersection(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a intersection of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a intersection of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this intersection. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. Â» Author: Andrei Gheata 30/05/02 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ Â» Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoIntersection.html:8851,safe,safe,8851,root/html530/TGeoIntersection.html,https://root.cern,https://root.cern/root/html530/TGeoIntersection.html,1,['safe'],['safe']
Safety,"; Libraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoIntersection(); Default constructor. TGeoIntersection(const char* expr1, const char* expr2); Constructor. TGeoIntersection(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoIntersection(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a intersection of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a intersection of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this intersection. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. Â» Author: Andrei Gheata 30/05/02 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: :$Id: TGeoBoolNode.h 41234 2011-10-06 15:48:52Z agheata $ Â» Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoIntersection.html:9055,safe,safe,9055,root/html532/TGeoIntersection.html,https://root.cern,https://root.cern/root/html532/TGeoIntersection.html,1,['safe'],['safe']
Safety,"; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; Â» GUI; Â» SESSIONVIEWER; Â» TProofProgressDialog. class TProofProgressDialog. TProofProgressDialog. This class provides a query progress bar. Function Members (Methods); public:. virtual~TProofProgressDialog(); static TClass*Class(); voidCloseWindow(); voidDisableAsyn(); voidDoAbort(); voidDoAsyn(); voidDoClose(); voidDoEnableSpeedo(); voidDoKeep(Bool_t on); voidDoLog(); voidDoMemoryPlot(); voidDoPlotRateGraph(); voidDoSetLogQuery(Bool_t on); voidDoStop(); voidIndicateStop(Bool_t aborted); virtual TClass*IsA() const; voidLogMessage(const char* msg, Bool_t all); TProofProgressDialog&operator=(const TProofProgressDialog&); voidProgress(Long64_t total, Long64_t processed); voidProgress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); voidProgress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); voidResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidToggleOdometerInfos(); voidToggleThreshold(); TProofProgressDialog(const TProofProgressDialog&); TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries). private:. Float_tAdjustBytes(Float_t mbs, TString& sf). Data Members; private:. TGTextButton*fAbort; TGraph*fActWGraph; TGTextButton*fAsyn; Double_tfAvgMBRate; Double_tfAvgRate; TGProgressBar*fBarprogress bar; TGTextButton*fClose; TGTransientFrame*fDialogtransient frame, main dialog window; TGraph*fEffSGraph; TTimefEndTime; Long64_tfEntries; TGTextEntry*fEntry; TGLabel*fEst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofProgressDialog.html:720,abort,aborted,720,root/html602/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html602/TProofProgressDialog.html,2,['abort'],['aborted']
Safety,"; Reimplemented from TGeoBBox.; Definition at line 66 of file TGeoHalfSpace.h. â—†Â IsCylType(). Bool_t TGeoHalfSpace::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 57 of file TGeoHalfSpace.h. â—†Â operator=(). TGeoHalfSpace & TGeoHalfSpace::operator= ; (; const TGeoHalfSpace &Â ; ). privatedelete . â—†Â Safety(). Double_t TGeoHalfSpace::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . computes the closest distance from given point to this shape, according to option. ; The matching point on the shape is stored in spoint. ; Reimplemented from TGeoBBox.; Definition at line 202 of file TGeoHalfSpace.cxx. â—†Â Safety_v(). void TGeoHalfSpace::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Compute safe distance from each of the points in the input array. ; Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values ; Reimplemented from TGeoBBox.; Definition at line 291 of file TGeoHalfSpace.cxx. â—†Â SavePrimitive(). void TGeoHalfSpace::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Definition at line 215 of file TGeoHalfSpace.cxx. â—†Â SetDimensions(). void TGeoHalfSpace::SetDimensions ; (; Double_t *Â ; param). overridevirtual . Set half-space parameters as stored in an array. ; Reimplemented from TGeoBBox.; Definition at line 234 of file TGeoHalfSpace.cxx. â—†Â SetPoints() [1/2]. void TGeoHalfSpace::SetPoints ; (; Double_t *Â ; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 62 of file TGeoHalfSpace.h. â—†Â SetPoints() [2/2]. void TGeoHalfSpace::SetPoints ; (; Float_t *Â ; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 63 of file TGeoHalfSpace.h. â—†Â Sizeof3D(). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHalfSpace.html:31432,Safe,Safety,31432,doc/master/classTGeoHalfSpace.html,https://root.cern,https://root.cern/doc/master/classTGeoHalfSpace.html,1,['Safe'],['Safety']
Safety,"; Reimplemented in TEveTrackListProjected.; Definition at line 227 of file TEveTrack.h. â—†Â MakeTracks(). void TEveTrackList::MakeTracks ; (; Bool_tÂ ; recurse = kTRUE). Regenerate the visual representations of tracks. ; The momentum limits are rescanned during the same traversal. ; Definition at line 635 of file TEveTrack.cxx. â—†Â operator=(). TEveTrackList & TEveTrackList::operator= ; (; const TEveTrackList &Â ; ). private . â—†Â ProjectedClass(). TClass * TEveTrackList::ProjectedClass ; (; const TEveProjection *Â ; p); const. overridevirtual . Virtual from TEveProjectable, returns TEveTrackListProjected class. ; Reimplemented from TEveElementList.; Definition at line 1175 of file TEveTrack.cxx. â—†Â RoundMomentumLimit(). Double_t TEveTrackList::RoundMomentumLimit ; (; Double_tÂ ; x). protected . Round the momentum limit up to a nice value. ; Definition at line 710 of file TEveTrack.cxx. â—†Â SanitizeMinMaxCuts(). void TEveTrackList::SanitizeMinMaxCuts ; (; ). protected . Set Min/Max cuts so that they are within detected limits. ; Definition at line 723 of file TEveTrack.cxx. â—†Â SelectByP() [1/2]. void TEveTrackList::SelectByP ; (; Double_tÂ ; min_p, . Double_tÂ ; max_pÂ . ). Select visibility of tracks by momentum. ; If data-member fRecurse is set, the selection is applied recursively to all children. ; Definition at line 1040 of file TEveTrack.cxx. â—†Â SelectByP() [2/2]. void TEveTrackList::SelectByP ; (; Double_tÂ ; min_p, . Double_tÂ ; max_p, . TEveElement *Â ; elÂ . ). Select visibility of el's children tracks by momentum. ; Definition at line 1061 of file TEveTrack.cxx. â—†Â SelectByPt() [1/2]. void TEveTrackList::SelectByPt ; (; Double_tÂ ; min_pt, . Double_tÂ ; max_ptÂ . ). Select visibility of tracks by transverse momentum. ; If data-member fRecurse is set, the selection is applied recursively to all children. ; Definition at line 995 of file TEveTrack.cxx. â—†Â SelectByPt() [2/2]. void TEveTrackList::SelectByPt ; (; Double_tÂ ; min_pt, . Double_tÂ ; max_pt, . TEveElement *Â ; elÂ . ). Select v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTrackList.html:45252,detect,detected,45252,doc/master/classTEveTrackList.html,https://root.cern,https://root.cern/doc/master/classTEveTrackList.html,1,['detect'],['detected']
Safety,"; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooSimWSToolThe RooSimWSTool is a tool operating on RooWorkspace objects that can clone PDFs into a series of var...Definition RooSimWSTool.h:38; RooSimultaneousFacilitates simultaneous fitting of multiple PDFs to subsets of a given dataset.Definition RooSimultaneous.h:41; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf504_simwstoolDefinition rf504_simwstool.py:1; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::g; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::m; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::s; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::f; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooPolynomial::p; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::p0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooCategory::c; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooCategory::d; Splitrule for p.d.f model with state list ; parameter m is split with constraint in categories (c); [#1] INFO:ObjectHandling",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf504__simwstool_8C.html:4772,safe,safe,4772,doc/master/rf504__simwstool_8C.html,https://root.cern,https://root.cern/doc/master/rf504__simwstool_8C.html,1,['safe'],['safe']
Safety,"; Searching...; No Matches. hsimple.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_pyroot; 3## \notebook -js; 4## This program creates :; 5## - a one dimensional histogram; 6## - a two dimensional histogram; 7## - a profile histogram; 8## - a memory-resident ntuple; 9##; 10## These objects are filled with some random numbers and saved on a file.; 11##; 12## \macro_image; 13## \macro_code; 14##; 15## \author Wim Lavrijsen, Enric Tejedor; 16 ; 17from ROOT import TCanvas, TFile, TProfile, TNtuple, TH1F, TH2F; 18from ROOT import gROOT, gBenchmark, gRandom, gSystem; 19import ctypes; 20 ; 21# Create a new canvas, and customize it.; 22c1 = TCanvas( 'c1', 'Dynamic Filling Example', 200, 10, 700, 500 ); 23c1.SetFillColor( 42 ); 24c1.GetFrame().SetFillColor( 21 ); 25c1.GetFrame().SetBorderSize( 6 ); 26c1.GetFrame().SetBorderMode( -1 ); 27 ; 28# Create a new ROOT binary machine independent file.; 29# Note that this file may contain any kind of ROOT objects, histograms,; 30# pictures, graphics objects, detector geometries, tracks, events, etc..; 31# This file is now becoming the current directory.; 32 ; 33hfile = gROOT.FindObject( 'py-hsimple.root' ); 34if hfile:; 35 hfile.Close(); 36hfile = TFile( 'py-hsimple.root', 'RECREATE', 'Demo ROOT file with histograms' ); 37 ; 38# Create some histograms, a profile histogram and an ntuple; 39hpx = TH1F( 'hpx', 'This is the px distribution', 100, -4, 4 ); 40hpxpy = TH2F( 'hpxpy', 'py vs px', 40, -4, 4, 40, -4, 4 ); 41hprof = TProfile( 'hprof', 'Profile of pz versus px', 100, -4, 4, 0, 20 ); 42ntuple = TNtuple( 'ntuple', 'Demo ntuple', 'px:py:pz:random:i' ); 43 ; 44# Set canvas/frame attributes.; 45hpx.SetFillColor( 48 ); 46 ; 47gBenchmark.Start( 'hsimple' ); 48 ; 49# Initialize random number generator.; 50gRandom.SetSeed(); 51rannor, rndm = gRandom.Rannor, gRandom.Rndm; 52 ; 53# For speed, bind and cache the Fill member functions,; 54histos = [ 'hpx', 'hpxpy', 'hprof', 'ntuple' ]; 55for name in histos:; 56 exe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimple_8py_source.html:1136,detect,detector,1136,doc/master/hsimple_8py_source.html,https://root.cern,https://root.cern/doc/master/hsimple_8py_source.html,1,['detect'],['detector']
Safety,"; TGeoNavigator::GetNormalconst Double_t * GetNormal() constDefinition TGeoNavigator.h:168; TGeoNavigator::TopToMastervoid TopToMaster(const Double_t *top, Double_t *master) constConvert coordinates from top volume frame to master.Definition TGeoNavigator.cxx:2700; TGeoNavigator::SetCurrentPointvoid SetCurrentPoint(const Double_t *point)Definition TGeoNavigator.h:172; TGeoNavigator::fCurrentMatrixTGeoHMatrix * fCurrentMatrixbackup stateDefinition TGeoNavigator.h:81; TGeoNavigator::fOverlapClustersInt_t * fOverlapClusterscurrent recursive position in fOverlapClustersDefinition TGeoNavigator.h:60; TGeoNavigator::GetCldirconst Double_t * GetCldir() constDefinition TGeoNavigator.h:165; TGeoNavigator::fTopNodeTGeoNode * fTopNodecurrent nodeDefinition TGeoNavigator.h:76; TGeoNavigator::LocalToMasterVectvoid LocalToMasterVect(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:236; TGeoNavigator::IsSafeStepBool_t IsSafeStep(Double_t proposed, Double_t &newsafety) constIn case a previous safety value was computed, check if the safety region is still safe for the curren...Definition TGeoNavigator.cxx:2609; TGeoNavigator::SearchNodeTGeoNode * SearchNode(Bool_t downwards=kFALSE, const TGeoNode *skipnode=nullptr)Returns the deepest node containing fPoint, which must be set a priori.Definition TGeoNavigator.cxx:1924; TGeoNavigator::fLastSafetyDouble_t fLastSafetysafety radius from current pointDefinition TGeoNavigator.h:45; TGeoNavigator::~TGeoNavigator~TGeoNavigator() overrideDestructor.Definition TGeoNavigator.cxx:169; TGeoNavigator::TGeoNavigatorTGeoNavigator()global mode is caching enabled for parallel world safety callsDefinition TGeoNavigator.cxx:57; TGeoNavigator::SetCurrentDirectionvoid SetCurrentDirection(const Double_t *dir)Definition TGeoNavigator.h:185; TGeoNavigator::BuildCachevoid BuildCache(Bool_t dummy=kFALSE, Bool_t nodeid=kFALSE)Builds the cache for physical nodes and global matrices.Definition TGeoNavigator.cxx:182; TGeoNavigator::fNextDaug",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:31003,safe,safety,31003,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,3,['safe'],"['safe', 'safety']"
Safety,"; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }. TCanvas * GetStatsCanvas() const; { return fStatsCanvas; }. TEditQueryFrame * GetQueryEditFrame() const; { return fFD; }. Â» Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 Â» Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; Â» Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ Â» Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSessionQueryFrame.html:21908,Abort,Abort,21908,root/html528/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html,1,['Abort'],['Abort']
Safety,"; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }. TCanvas * GetStatsCanvas() const; { return fStatsCanvas; }. TEditQueryFrame * GetQueryEditFrame() const; { return fFD; }. Â» Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 Â» Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; Â» Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ Â» Last generated: 2011-07-04 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSessionQueryFrame.html:22008,Abort,Abort,22008,root/html530/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html530/TSessionQueryFrame.html,1,['Abort'],['Abort']
Safety,"; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome Â» Development Â» Git Primer Github ssh key. Using Github with ssh keys is preferred, as it's much easier to use. Here is how to set it up:; 1. Create an ssh key; Run; ssh-keygen -t rsa -b 4096 -C ""your_email@example.com"" -f ~/.ssh/github_id_rsa. The email address is for your convenience, it doesn't really matter what you put there; you can even use this to state the name of the computer that will use that key.; You can use a passphrase - but even without it's sufficiently safe, because only you have the secret key file! But please enabling Two Factor Authentication!; 2. Add the key to Github; Log in to https://github.com. In the top right corner, in a drop-down menu, click ""Settings"". Select ""SSH and GPG keys"" from the menu on the left. Click ""New SSH key"", add something as a title and copy the output of; cat ~/.ssh/github_id_rsa.pub. into the ""Key"" text box.; 3. Guide ssh to your key; Edit (or create) ~/.ssh/config and enter the following lines:; Host github.com; User git; PreferredAuthentications publickey; IdentityFile ~/.ssh/github_id_rsa. 4. Check; ssh -T git@github.com. should print; Hi UserName! You've successfully authenticated, but GitHub does not provide shell access. References. Create an ssh key; Add the key to Github; Check. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/github-ssh-key.html:2325,safe,safe,2325,d/github-ssh-key.html,https://root.cern,https://root.cern/d/github-ssh-key.html,1,['safe'],['safe']
Safety,"; X, . const Matrix_t &Â ; Y, . const Matrix_t &Â ; weights, . boolÂ ; applyDropout = false, . boolÂ ; includeRegularization = trueÂ . ). inline . Propagate the input batch X through the net and evaluate the error function for the resulting activations of the output layer. ; Definition at line 320 of file Net.h. â—†Â Prediction() [1/2]. template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t &Â ; Y_hat, . EOutputFunctionÂ ; fÂ . ); const. inline . Compute the neural network prediction obtained from applying the output function f to the activation of the last layer in the network. ; Definition at line 339 of file Net.h. â—†Â Prediction() [2/2]. template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t &Â ; Y_hat, . Matrix_t &Â ; X, . EOutputFunctionÂ ; fÂ . ). inline . Compute the neural network prediction obtained from forwarding the batch X through the neural network and applying the output function f to the activation of the last layer in the network. ; Definition at line 329 of file Net.h. â—†Â Print(). template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::Print. Definition at line 392 of file Net.h. â—†Â SetBatchSize(). template<typename Architecture_t , typename Layer_t = TLayer<Architecture_t>> . void TMVA::DNN::TNet< Architecture_t, Layer_t >::SetBatchSize ; (; size_tÂ ; batchSize). inline . Definition at line 148 of file Net.h. â—†Â SetDropoutProbabilities(). template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::SetDropoutProbabilities ; (; const std::vector< Double_t > &Â ; probabilities). Definition at line 378 of file Net.h. â—†Â SetInputWidth(). template<typename Architecture_t , typename Layer_t = TLayer<Architecture_t>> . void TMVA::DNN::TNet< Architecture_t, Layer_t >::SetInputWidth ; (; size_tÂ ; inputWidth). inline . Definition at line 149",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TNet.html:14337,predict,prediction,14337,doc/master/classTMVA_1_1DNN_1_1TNet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TNet.html,1,['predict'],['prediction']
Safety,"; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid caus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:2899,avoid,avoiding,2899,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['avoid'],['avoiding']
Safety,"; angles of the rotated axes:; Â  Double_t tx,ty,tz,px,py,pz;; Â  tx= a.ThetaX();; Â  ...; Â  pz= a.PhiZ();. Setting The Rotations; The member function SetToIdentity() will set the rotation object; to the identity (no rotation).; With a minor caveat, the Euler angles of the rotation may be set using; SetXEulerAngles() or individually set with SetXPhi(),; SetXTheta(), and SetXPsi(). These routines set the Euler; angles using the X-convention which is defined by a rotation about the Z-axis,; about the new X-axis, and about the new Z-axis. This is the convention used; in Landau and Lifshitz, Goldstein and other common physics texts. The; Y-convention euler angles can be set with SetYEulerAngles(),; SetYPhi(), SetYTheta(), and SetYPsi(). The caveat; is that Euler angles usually define the rotation of the new coordinate system; with respect to the original system, however, the TRotation class specifies; the rotation of the object in the original system (an active rotation). To; recover the usual Euler rotations (ie. rotate the system not the object), you; must take the inverse of the rotation.; The member functions SetXAxis(), SetYAxis(), and; SetZAxis() will create a rotation which rotates the requested axis; of the object to be parallel to a vector. If used with one argument, the; rotation about that axis is arbitrary. If used with two arguments, the; second variable defines the XY, YZ, or ZX; respectively. Inverse rotation; Â  TRotation a,b;; Â  ...; Â  b = a.Inverse();Â  // b is inverse of a, a is unchanged; Â  b = a.Invert();Â Â  // invert a and set b = a. Compound Rotations; The operator * has been implemented in a way that follows the; mathematical notation of a product of the two matrices which describe the; two consecutive rotations. Therefore the second rotation should be placed; first:; Â  r = r2 * r1;. Rotation of TVector3; The TRotation class provides an operator * which allows to express; a rotation of a TVector3 analog to the mathematical notation; Â  | x' |Â Â  | xx xy x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRotation.html:4203,recover,recover,4203,root/html602/TRotation.html,https://root.cern,https://root.cern/root/html602/TRotation.html,2,['recover'],['recover']
Safety,"; class Â FumiliErrorUpdator; Â In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...; Â ; class Â FumiliFCNAdapter; Â template wrapped class for adapting to FumiliFCNBase signature More...; Â ; class Â FumiliFCNBase; Â Extension of the FCNBase for the Fumili method. More...; Â ; class Â FumiliGradientCalculator; Â Fumili gradient calculator using external gradient provided by FCN Note that the computed Hessian and G2 are an approximation valid for small residuals. More...; Â ; class Â FumiliMaximumLikelihoodFCN; Â Extension of the FCNBase for the Fumili method. More...; Â ; class Â FumiliMinimizer; Â Instantiates the seed generator and Minimum builder for the Fumili minimization method. More...; Â ; class Â FumiliStandardChi2FCN; Â Class implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation. More...; Â ; class Â FumiliStandardMaximumLikelihoodFCN; Â Class implementing the Elements member function for the standard maximum likelihood method. More...; Â ; class Â FunctionGradient; Â ; class Â FunctionMinimizer; Â base class for function minimizers; user may give FCN or FCN with Gradient, Parameter starting values and initial Error guess (sigma) (or ""step size""), or Parameter starting values and initial covariance matrix; covariance matrix is stored in Upper triangular packed storage format, e.g. More...; Â ; class Â FunctionMinimum; Â class holding the full result of the minimization; both internal and external (MnUserParameterState) representation available for the parameters at the Minimum More...; Â ; class Â gen; Â ; class Â GenericFunction; Â Class from which all the other classes, representing functions, inherit. More...; Â ; class Â GradientC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Minuit2.html:3281,predict,predicted,3281,doc/v632/namespaceROOT_1_1Minuit2.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Minuit2.html,1,['predict'],['predicted']
Safety,"; class Â FumiliErrorUpdator; Â In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...; Â ; class Â FumiliFCNAdapter; Â template wrapped class for adapting to FumiliFCNBase signature More...; Â ; class Â FumiliFCNBase; Â Extension of the FCNBase for the Fumili method. More...; Â ; class Â FumiliGradientCalculator; Â Fumili gradient calculator using external gradient provided by FCN Note that the computed Hessian and G2 are an approximation valid for small residuals. More...; Â ; class Â FumiliMaximumLikelihoodFCN; Â Extension of the FCNBase for the Fumili method. More...; Â ; class Â FumiliMinimizer; Â Instantiates the seed generator and Minimum builder for the Fumili minimization method. More...; Â ; class Â FumiliStandardChi2FCN; Â Class implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation. More...; Â ; class Â FumiliStandardMaximumLikelihoodFCN; Â Class implementing the Elements member function for the standard maximum likelihood method. More...; Â ; class Â FunctionGradient; Â ; class Â FunctionMinimum; Â class holding the full result of the minimization; both internal and external (MnUserParameterState) representation available for the parameters at the Minimum More...; Â ; class Â gen; Â ; class Â GenericFunction; Â Class from which all the other classes, representing functions, inherit. More...; Â ; class Â GradientCalculator; Â interface class for gradient calculators More...; Â ; class Â HessianGradientCalculator; Â HessianGradientCalculator: class to calculate Gradient for Hessian. More...; Â ; class Â InitialGradientCalculator; Â Class to calculate an initial estimate of the gradient. More...; Â ; class Â LASquareMatrix; Â ; class Â LASymMatrix",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html:3372,predict,predicted,3372,doc/master/namespaceROOT_1_1Minuit2.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html,1,['predict'],['predicted']
Safety,"; decay channel; Calculate X-sections; (Geant3 only). Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t pdg) const. get methods. Return name of the particle specified by pdg. Double_t ParticleMass(Int_t pdg) const; Return mass of the particle specified by pdg. Double_t ParticleCharge(Int_t pdg) const; Return charge (in e units) of the particle specified by pdg. Double_t ParticleLifeTime(Int_t pdg) const; Return life time of the particle specified by pdg. TMCParticleType ParticleMCType(Int_t pdg) const; Return VMC type of the particle specified by pdg. void StopTrack(). methods for step management. action methods. Stop the transport of the current particle and skip to the next. void StopEvent(); Stop simulation of the current event and skip to the next. void StopRun(); Stop simulation of the current event and set the abort run flag to true. void SetMaxStep(Double_t ). set methods. Set the maximum step allowed till the particle is in the current medium. void SetMaxNStep(Int_t ); Set the maximum number of steps till the particle is in the current medium. void SetUserDecay(Int_t pdg); Force the decays of particles to be done with Pythia; and not with the Geant routines. void ForceDecayTime(Float_t ); Force the decay time of the current particle. Int_t CurrentVolID(Int_t& copyNo) const. tracking volume(s). Return the current volume ID and copy number. Int_t CurrentVolOffID(Int_t off, Int_t& copyNo) const; Return the current volume off upward in the geometrical tree; ID and copy number. const char* CurrentVolName() const; Return the current volume name. const char* CurrentVolOffName(Int_t off) const; Return the current volume off upward in the geometrical tree; name and copy number'; if name=0 no name is returned. const char* CurrentVolPath(); Return the path in geometry tree for th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMC.html:31053,abort,abort,31053,root/html528/TVirtualMC.html,https://root.cern,https://root.cern/root/html528/TVirtualMC.html,1,['abort'],['abort']
Safety,"; doublefLumiError; doublefNomLumi; TFile*fOut_f; stringstreamfResultsPrefixStr; stringfRowTitle; vector<string>fSystToFix; FILE*pFile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HistoToWorkspaceFactory(); {}. ~HistoToWorkspaceFactory(). HistoToWorkspaceFactory(string , string , vector<string> , double = 200, double = 20, int = 0, int = 6, TFile* = 0). string FilePrefixStr(string ). void ProcessExpectedHisto(TH1F* hist, RooWorkspace* proto, string prefix, string productPrefix, string systTerm, double low, double high, int lowBin, int highBin). void AddMultiVarGaussConstraint(RooWorkspace* proto, string prefix, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins. void LinInterpWithConstraint(RooWorkspace* proto, TH1F* nominal, vector<TH1F*> lowHist, vector<TH1F*> highHist, vector<string> sourceName, string prefix, string productPrefix, string systTerm, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins; make list of abstract parameters that interpolate in space of variations; range is set using defined macro (see top of the page). string AddNormFactor(RooWorkspace* , string& , string& , RooStats::HistFactory::EstimateSummary& , bool ). void AddEfficiencyTerms(RooWorkspace* proto, string prefix, string interpName, map<string,pair<double,double> > systMap, vector<string>& likelihoodTermNames, vector<string>& totSystTermNames); add variables for all the relative overall uncertainties we expect; range is set using defined macro (see top of the page); string range=""[0,-1,1]"";. void MakeTotalExpected(RooWorkspace* proto, string totName, string , string , int lowBin, int highBin, vector<string>& syst_x_expectedPrefixNames, vector<string>& normByNames); for ith b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HistFactory__HistoToWorkspaceFactory.html:8655,predict,predictions,8655,root/html528/RooStats__HistFactory__HistoToWorkspaceFactory.html,https://root.cern,https://root.cern/root/html528/RooStats__HistFactory__HistoToWorkspaceFactory.html,1,['predict'],['predictions']
Safety,"; fedm, . Double_t &Â ; errdef, . Int_t &Â ; npari, . Int_t &Â ; nparx, . Int_t &Â ; istatÂ . ). virtual . Returns concerning the current status of the minimization. ; User-called Namely, it returns:; FMIN: the best function value found so far; FEDM: the estimated vertical distance remaining to minimum; ERRDEF: the value of UP defining parameter uncertainties; NPARI: the number of currently variable parameters; NPARX: the highest (external) parameter number defined by user; ISTAT: a status integer indicating how good is the covariance matrix:; 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix . Definition at line 7638 of file TMinuit.cxx. â—†Â mntiny(). void TMinuit::mntiny ; (; Double_tÂ ; epsp1, . Double_t &Â ; epsbakÂ . ). virtual . To find the machine precision. ; Compares its argument with the value 1.0, and returns the value .TRUE. if they are equal. To find EPSMAC safely by foiling the Fortran optimiser ; Definition at line 7661 of file TMinuit.cxx. â—†Â mnunpt(). Bool_t TMinuit::mnunpt ; (; TString &Â ; cfname). Returns .TRUE. ; if CFNAME contains unprintable characters ; Definition at line 7670 of file TMinuit.cxx. â—†Â mnvert(). void TMinuit::mnvert ; (; Double_t *Â ; a, . Int_tÂ ; l, . Int_tÂ ; m, . Int_tÂ ; n, . Int_t &Â ; ifailÂ . ). virtual . Inverts a symmetric matrix. ; inverts a symmetric matrix. matrix is first scaled to have all ones on the diagonal (equivalent to change of units) but no pivoting is done since matrix is positive-definite. ; Definition at line 7696 of file TMinuit.cxx. â—†Â mnwarn(). void TMinuit::mnwarn ; (; const char *Â ; copt1, . const char *Â ; corg1, . const char *Â ; cmes1Â . ). virtual . Prints Warning messages. . If COPT='W', CMES is a WARning message from CORG.; If COPT='D', CMES is a DEBug message from CORG.; If SET WARnings is in effect (the default), this routine prints the warning message CMES coming from CORG.; If SET NOWarnings is in effect, the warning ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:65634,safe,safely,65634,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['safe'],['safely']
Safety,"; for (Int_t j = 0; j <= i; j++) {; Double_t sum = 0.;; for (Int_t k = 0; k < nrData; k++) {; sum += (data[i][k] - r[i]) * (data[j][k] - r[j]);; }; Covar(i,j) = Covar(j,i) = sum/nrData;; }; }; ; const TVectorD weight1 = OptimalInvest(2.0,r,Covar);; const TVectorD weight2 = OptimalInvest(10.,r,Covar);; ; cout << ""stock daily daily w1 w2"" <<endl;; cout << ""symb return sdv "" <<endl;; for (Int_t i = 0; i < nrStocks; i++); printf(""%s\t: %.3f %.3f %.3f %.3f\n"",stocks[i],r[i],TMath::Sqrt(Covar[i][i]),weight1[i],weight2[i]);; ; TCanvas *c1 = new TCanvas(""c1"",""Portfolio Optimizations"",10,10,800,900);; c1->Divide(1,2);; ; // utility function / risk profile; ; c1->cd(1);; gPad->SetGridx();; gPad->SetGridy();; ; TF1 *f1 = new TF1(""f1"",RiskProfile,0,2.5,1);; f1->SetParameter(0,2.0);; f1->SetLineColor(49);; f1->Draw(""AC"");; f1->GetHistogram()->SetXTitle(""dollar"");; f1->GetHistogram()->SetYTitle(""utility"");; f1->GetHistogram()->SetMinimum(0.0);; f1->GetHistogram()->SetMaximum(1.0);; TF1 *f2 = new TF1(""f2"",RiskProfile,0,2.5,1);; f2->SetParameter(0,10.);; f2->SetLineColor(50);; f2->Draw(""CSAME"");; ; TLegend *legend1 = new TLegend(0.50,0.65,0.70,0.82);; legend1->AddEntry(f1,""1-exp(-2.0*x)"",""l"");; legend1->AddEntry(f2,""1-exp(-10.*x)"",""l"");; legend1->Draw();; ; // vertical bar chart of portfolio distribution; ; c1->cd(2);; TH1F *h1 = new TH1F(""h1"",""Portfolio Distribution"",nrStocks,0,0);; TH1F *h2 = new TH1F(""h2"",""Portfolio Distribution"",nrStocks,0,0);; h1->SetStats(0);; h1->SetFillColor(49);; h2->SetFillColor(50);; h1->SetBarWidth(0.45);; h1->SetBarOffset(0.1);; h2->SetBarWidth(0.4);; h2->SetBarOffset(0.55);; for (Int_t i = 0; i < nrStocks; i++) {; h1->Fill(stocks[i],weight1[i]);; h2->Fill(stocks[i],weight2[i]);; }; ; h1->Draw(""BAR2 HIST"");; h2->Draw(""BAR2SAME HIST"");; ; TLegend *legend2 = new TLegend(0.50,0.65,0.70,0.82);; legend2->AddEntry(h1,""high risk"",""f"");; legend2->AddEntry(h2,""low risk"",""f"");; legend2->Draw();; }; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:12559,Risk,RiskProfile,12559,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,1,['Risk'],['RiskProfile']
Safety,"; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEnumConstant.h; TEnum.h; TEnv.h; kEnvUser@ kEnvUserDefinition TEnv.h:71; kEnvGlobal@ kEnvGlobalDefinition TEnv.h:70; kEnvLocal@ kEnvLocalDefinition TEnv.h:72; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; kWarningconstexpr Int_t kWarningDefinition TError.h:46; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; TFile.h; TFunctionTemplate.h; N#define N; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; cursorOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t cursorDefinition TGWin32VirtualXProxy.cxx:160; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Recta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:387387,abort,abort,387387,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['abort'],['abort']
Safety,"; gStyle->SetLineWidth(2.0);; gStyle->SetOptStat(11);; ; TObjArray hbiasNorm;; hbiasNorm.Add(new TH1D(""h0Norm"", ""Bias Histogram fit"",100,-5,5));; hbiasNorm.Add(new TH1D(""h1Norm"",""Bias Binomial fit"",100,-5,5));; TObjArray hbiasThreshold;; hbiasThreshold.Add(new TH1D(""h0Threshold"", ""Bias Histogram fit"",100,-5,5));; hbiasThreshold.Add(new TH1D(""h1Threshold"",""Bias Binomial fit"",100,-5,5));; TObjArray hbiasWidth;; hbiasWidth.Add(new TH1D(""h0Width"", ""Bias Histogram fit"",100,-5,5));; hbiasWidth.Add(new TH1D(""h1Width"",""Bias Binomial fit"",100,-5,5));; TH1D* hChisquared = new TH1D(""hChisquared"",; ""#chi^{2} probability (Baker-Cousins)"", 200, 0.0, 1.0);; ; TVirtualFitter::SetDefaultFitter(""Minuit2"");; ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(""Gauss"");; ; // Note: in order to be able to use TH1::FillRandom() to generate; // pseudo-experiments, we use a trick: generate ""selected""; // and ""non-selected"" samples independently. These are; // statistically independent and therefore can be safely; // added to yield the ""before selection"" sample.; ; ; // Define (arbitrarily?) a distribution of input events.; // Here: assume a x^(-2) distribution. Boundaries: [10, 100].; ; double xmin =10, xmax = 100;; TH1D* hM2D = new TH1D(""hM2D"", ""x^(-2) denominator distribution"",; 45, xmin, xmax);; TH1D* hM2N = new TH1D(""hM2N"", ""x^(-2) numerator distribution"",; 45, xmin, xmax);; TH1D* hM2E = new TH1D(""hM2E"", ""x^(-2) efficiency"",; 45, xmin, xmax);; ; TF1* fM2D = new TF1(""fM2D"", ""(1-[0]/(1+exp(([1]-x)/[2])))/(x*x)"",; xmin, xmax);; TF1* fM2N = new TF1(""fM2N"", ""[0]/(1+exp(([1]-x)/[2]))/(x*x)"",; xmin, xmax);; TF1* fM2Fit = new TF1(""fM2Fit"", ""[0]/(1+exp(([1]-x)/[2]))"",; xmin, xmax);; TF1* fM2Fit2 = nullptr;; ; TRandom3 rb(seed);; ; // First try: use a single set of parameters.; // For each try, we need to find the overall normalization; ; double normalization = 0.80;; double threshold = 25.0;; double width = 5.0;; ; fM2D->SetParameter(0, normalization);; fM2D->SetParameter(1, threshold);; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TestBinomial_8C.html:48716,safe,safely,48716,doc/master/TestBinomial_8C.html,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html,1,['safe'],['safely']
Safety,"; i++); 2264 col[i] = kGray;; 2265 ; 2266 // here we should create a new TColor with the same rgb as in the default; 2267 // ROOT colors used below; 2268 col[3] = kYellow - 10;; 2269 col[4] = col[5] = kGreen - 10;; 2270 col[6] = col[7] = kBlue - 7;; 2271 col[8] = col[9] = kMagenta - 3;; 2272 col[10] = col[11] = kRed - 10;; 2273 col[12] = kGray + 1;; 2274 col[13] = kBlue - 10;; 2275 col[14] = kOrange + 7;; 2276 col[16] = kYellow + 1;; 2277 col[20] = kYellow - 10;; 2278 col[24] = col[25] = col[26] = kBlue - 8;; 2279 col[29] = kOrange + 9;; 2280 col[79] = kOrange - 2;; 2281 ; 2282 TGeoVolume *vol;; 2283 TIter next(fVolumes);; 2284 while ((vol = (TGeoVolume *)next())) {; 2285 TGeoMedium *med = vol->GetMedium();; 2286 if (!med); 2287 continue;; 2288 TGeoMaterial *mat = med->GetMaterial();; 2289 Int_t matZ = (Int_t)mat->GetZ();; 2290 vol->SetLineColor(col[matZ]);; 2291 if (mat->GetDensity() < 0.1); 2292 vol->SetTransparency(60);; 2293 }; 2294}; 2295 ; 2296////////////////////////////////////////////////////////////////////////////////; 2297/// Compute safe distance from the current point. This represent the distance; 2298/// from POINT to the closest boundary.; 2299 ; 2300Double_t TGeoManager::Safety(Bool_t inside); 2301{; 2302 return GetCurrentNavigator()->Safety(inside);; 2303}; 2304 ; 2305////////////////////////////////////////////////////////////////////////////////; 2306/// Set volume attributes in G3 style.; 2307 ; 2308void TGeoManager::SetVolumeAttribute(const char *name, const char *att, Int_t val); 2309{; 2310 TGeoVolume *volume;; 2311 Bool_t all = kFALSE;; 2312 if (strstr(name, ""*"")); 2313 all = kTRUE;; 2314 Int_t ivo = 0;; 2315 TIter next(fVolumes);; 2316 TString chatt = att;; 2317 chatt.ToLower();; 2318 while ((volume = (TGeoVolume *)next())) {; 2319 if (strcmp(volume->GetName(), name) && !all); 2320 continue;; 2321 ivo++;; 2322 if (chatt.Contains(""colo"")); 2323 volume->SetLineColor(val);; 2324 if (chatt.Contains(""lsty"")); 2325 volume->SetLineStyle(val);; 2326",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:82535,safe,safe,82535,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['safe'],['safe']
Safety,"; ipl, . Double_t &Â ; snext, . Double_tÂ ; stepmaxÂ . ); const. protected . â—†Â LocatePhi(). void TGeoPgon::LocatePhi ; (; const Double_t *Â ; point, . Int_t &Â ; ipsecÂ . ); const. protected . â—†Â MakeBuffer3D(). TBuffer3D * TGeoPgon::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoPcon. â—†Â operator=(). TGeoPgon & TGeoPgon::operator= ; (; const TGeoPgon &Â ; ). protecteddelete . â—†Â Rpg(). Double_t TGeoPgon::Rpg ; (; Double_tÂ ; z, . Int_tÂ ; ipl, . Bool_tÂ ; inner, . Double_t &Â ; a, . Double_t &Â ; bÂ . ); const. protected . â—†Â Rproj(). Double_t TGeoPgon::Rproj ; (; Double_tÂ ; z, . const Double_t *Â ; point, . const Double_t *Â ; dir, . Double_tÂ ; cphi, . Double_tÂ ; sphi, . Double_t &Â ; a, . Double_t &Â ; bÂ . ); const. protected . â—†Â Safety(). Double_t TGeoPgon::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Reimplemented from TGeoPcon. â—†Â Safety_v(). void TGeoPgon::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoPcon. â—†Â SafetyToSegment(). Double_t TGeoPgon::SafetyToSegment ; (; const Double_t *Â ; point, . Int_tÂ ; ipl, . Int_tÂ ; iphi, . Bool_tÂ ; in, . Double_tÂ ; safphi, . Double_tÂ ; safmin = TGeoShape::Big()Â . ); const. â—†Â SavePrimitive(). void TGeoPgon::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoPcon. â—†Â SetDimensions(). void TGeoPgon::SetDimensions ; (; Double_t *Â ; param). overridevirtual . Reimplemented from TGeoPcon. â—†Â SetNedges(). void TGeoPgon::SetNedges ; (; Int_tÂ ; ne). inline . Definition at line 108 of file TGeoPgon.h. â—†Â SetPoints() [1/2]. void TGeoPgon::SetPoints ; (; Double_t *Â ; points); const. overridevirtual . Reimplemented from TGeoPcon. â—†Â SetPoints() [2/2]. void TGeoPgon::SetPoints ; (; Float_t *Â ; points); const. overridevirtual . Reimplemented from TGeoPcon. â—†Â SetS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPgon.html:32914,safe,safe,32914,doc/master/classTGeoPgon.html,https://root.cern,https://root.cern/doc/master/classTGeoPgon.html,1,['safe'],['safe']
Safety,"; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortfAbortabort status; TList*fInputlist of objects available during processing; TObject*fObjectcurrent object if processing object (vs. TTree); TStringfOptionoption given to TTree::Process; TSelectorList*fOutputlist of objects created during processing; Long64_tfStatusselector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (eithe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSelector.html:9278,Abort,Abort,9278,root/html528/TSelector.html,https://root.cern,https://root.cern/root/html528/TSelector.html,3,['Abort'],['Abort']
Safety,"; m.AddLine(""model.compile(loss = 'binary_crossentropy', optimizer = Adam(learning_rate = 0.001), weighted_metrics = ['accuracy'])"");; m.AddLine(""model.save('Higgs_model.h5')"");; m.AddLine(""model.summary()"");; ; m.SaveSource(""make_higgs_model.py"");; // execute; auto ret = (TString *)gROOT->ProcessLine(""TMVA::Python_Executable()"");; TString python_exe = (ret) ? *(ret) : ""python"";; gSystem->Exec(python_exe + "" make_higgs_model.py"");; ; if (gSystem->AccessPathName(""Higgs_model.h5"")) {; Warning(""TMVA_Higgs_Classification"", ""Error creating Keras model file - skip using Keras"");; } else {; // book PyKeras method only if Keras model could be created; Info(""TMVA_Higgs_Classification"", ""Booking tf.Keras Dense model"");; factory.BookMethod(; loader, TMVA::Types::kPyKeras, ""PyKeras"",; ""H:!V:VarTransform=None:FilenameModel=Higgs_model.h5:tf.keras:""; ""FilenameTrainedModel=Higgs_trained_model.h5:NumEpochs=20:BatchSize=100:""; ""GpuOptions=allow_growth=True""); // needed for RTX NVidia card and to avoid TF allocates all GPU memory; }; }; ; /**; ## Train Methods; ; Here we train all the previously booked methods.; ; */; ; factory.TrainAllMethods();; ; /**; ## Test all methods; ; Now we test and evaluate all methods using the test data set; */; ; factory.TestAllMethods();; ; factory.EvaluateAllMethods();; ; /// after we get the ROC curve and we display; ; auto c1 = factory.GetROCCurve(loader);; c1->Draw();; ; /// at the end we close the output file which contains the evaluation result of all methods and it can be used by TMVAGUI; /// to display additional plots; ; outputFile->Close();; ; ; }; Double_tdouble Double_tDefinition RtypesCore.h:59; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in wa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:69048,avoid,avoid,69048,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['avoid'],['avoid']
Safety,"; new TMatrixDSparse(*a,TMatrixDSparse::kMult,*b);. TMatrixDSparse * MultiplyMSparseM(const TMatrixDSparse* a, const TMatrixD* b) const; multiply a Sparse matrix with a non-sparse matrix; a: pointer to sparse matrix; b: pointer to non-sparse matrix; this is a replacement for the call; new TMatrixDSparse(*a,TMatrixDSparse::kMult,*b);. void AddMSparse(TMatrixDSparse* dest, Double_t f, const TMatrixDSparse* src) const; a replacement for; (*dest) += f*(*src). TString GetOutputBinName(Int_t iBinX) const; given a bin number, return the name of the output bin; this method makes more sense for the class TUnfoldDnesity; where it gets overwritten. TUnfold(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea); set up unfolding matrix and initial regularisation scheme; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; constraint: type of constraint to use; data members initialized to something different from zero:; fA: filled from hist_A; fDA: filled from hist_A; fX0: filled from hist_A; fL: filled depending on the regularisation scheme; Treatment of overflow bins; Bins where the unfolding input (Detector level) is in overflow; are used for the efficiency correction. They have to be filled; properly!; Bins where the unfolding output (Generator level) is in overflow; are treated as a part of the generator level distribution.; I.e. the unfolding output could have non-zero overflow bins if the; input matrix does have such bins. ~TUnfold(void); delete all data members. void SetBias(const TH1* bias); initialize alternative bias from histogram; modifies data member fX0. Int_t RegularizeSize(int bin, Double_t scale = 1.); add regularisation on the size of bin i; bin: bin number; scale: size of the regularisation; return value: number of conditions which have been skipped; modifies data member fL. Int_t Reg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfold.html:22887,Detect,Detector,22887,root/html602/TUnfold.html,https://root.cern,https://root.cern/root/html602/TUnfold.html,2,['Detect'],['Detector']
Safety,"; new TMatrixDSparse(*a,TMatrixDSparse::kMult,*b);. TMatrixDSparse * MultiplyMSparseM(const TMatrixDSparse* a, const TMatrixD* b) const; multiply a Sparse matrix with a non-sparse matrix; a: pointer to sparse matrix; b: pointer to non-sparse matrix; this is a replacement for the call; new TMatrixDSparse(*a,TMatrixDSparse::kMult,*b);. void AddMSparse(TMatrixDSparse* dest, Double_t f, const TMatrixDSparse* src) const; a replacement for; (*dest) += f*(*src). TString GetOutputBinName(Int_t iBinX) const; given a bin number, return the name of the output bin; this method makes more sense for the class TUnfoldDnesity; where it gets overwritten. TUnfold(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea); set up unfolding matrix and initial regularisation scheme; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; constraint: type of constraint to use; data members initialized to something different from zero:; fA: filled from hist_A; fDA: filled from hist_A; fX0: filled from hist_A; fL: filled depending on the regularisation scheme; Treatment of overflow bins; Bins where the unfolding input (Detector level) is in overflow; are used for the efficiency correction. They have to be filled; properly!; Bins where the unfolding output (Generator level) is in overflow; are treated as a part of the generator level distribution.; I.e. the unfolding output could have non-zero overflow bins if the; input matrix does have such bins. ~TUnfold(void); delete all data members. void SetBias(const TH1* bias); initialize alternative bias from histogram; modifies data member fX0. Int_t RegularizeSize(int bin, Double_t scale = 1.0); add regularisation on the size of bin i; bin: bin number; scale: size of the regularisation; return value: number of conditions which have been skipped; modifies data member fL. Int_t Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfold.html:22228,Detect,Detector,22228,root/html534/TUnfold.html,https://root.cern,https://root.cern/root/html534/TUnfold.html,1,['Detect'],['Detector']
Safety,"; num_features = len(input_columns); ; ; def calc_accuracy(targets, pred):; return torch.sum(targets == pred.round()) / pred.size(0); ; ; # Initialize PyTorch model; model = torch.nn.Sequential(; torch.nn.Linear(num_features, 300),; torch.nn.Tanh(),; torch.nn.Linear(300, 300),; torch.nn.Tanh(),; torch.nn.Linear(300, 300),; torch.nn.Tanh(),; torch.nn.Linear(300, 1),; torch.nn.Sigmoid(),; ); loss_fn = torch.nn.MSELoss(reduction=""mean""); optimizer = torch.optim.SGD(model.parameters(), lr=0.01, momentum=0.9); ; ; # Loop through the training set and train model; for i, (x_train, y_train) in enumerate(gen_train):; # Make prediction and calculate loss; pred = model(x_train).view(-1); loss = loss_fn(pred, y_train); ; # improve model; model.zero_grad(); loss.backward(); optimizer.step(); ; # Calculate accuracy; accuracy = calc_accuracy(y_train, pred); ; print(f""Training => accuracy: {accuracy}""); ; #################################################################; # Validation; #################################################################; ; # Evaluate the model on the validation set; for i, (x_train, y_train) in enumerate(gen_validation):; # Make prediction and calculate accuracy; pred = model(x_train).view(-1); accuracy = calc_accuracy(y_train, pred); ; print(f""Validation => accuracy: {accuracy}""); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h uns",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBatchGenerator__PyTorch_8py.html:2022,predict,prediction,2022,doc/master/RBatchGenerator__PyTorch_8py.html,https://root.cern,https://root.cern/doc/master/RBatchGenerator__PyTorch_8py.html,1,['predict'],['prediction']
Safety,"; nÂ . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 447 of file TBufferSQL.cxx. â—†Â WriteFastArray() [3/15]. void TBufferSQL::WriteFastArray ; (; const Double_t *Â ; d, . Long64_tÂ ; nÂ . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 688 of file TBufferSQL.cxx. â—†Â WriteFastArray() [4/15]. void TBufferSQL::WriteFastArray ; (; const Float_t *Â ; f, . Long64_tÂ ; nÂ . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 668 of file TBufferSQL.cxx. â—†Â WriteFastArray() [5/15]. void TBufferSQL::WriteFastArray ; (; const Int_t *Â ; ii, . Long64_tÂ ; nÂ . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 547 of file TBufferSQL.cxx. â—†Â WriteFastArray() [6/15]. void TBufferSQL::WriteFastArray ; (; const Long64_t *Â ; l, . Long64_tÂ ; nÂ . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL.html:52058,abort,aborts,52058,doc/master/classTBufferSQL.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL.html,1,['abort'],['aborts']
Safety,"; nÂ . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 588 of file TBufferSQL.cxx. â—†Â WriteFastArray() [8/15]. void TBufferSQL::WriteFastArray ; (; const Short_t *Â ; h, . Long64_tÂ ; nÂ . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 506 of file TBufferSQL.cxx. â—†Â WriteFastArray() [9/15]. void TBufferSQL::WriteFastArray ; (; const UChar_t *Â ; uc, . Long64_tÂ ; nÂ . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 486 of file TBufferSQL.cxx. â—†Â WriteFastArray() [10/15]. void TBufferSQL::WriteFastArray ; (; const UInt_t *Â ; ui, . Long64_tÂ ; nÂ . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 568 of file TBufferSQL.cxx. â—†Â WriteFastArray() [11/15]. void TBufferSQL::WriteFastArray ; (; const ULong64_t *Â ; ul, . Long64_tÂ ; nÂ . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL.html:54248,abort,aborts,54248,doc/master/classTBufferSQL.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL.html,1,['abort'],['aborts']
Safety,"; points, . Bool_t *Â ; inside, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. â—†Â DeclFileName(). static const char * TGeoPcon::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 109 of file TGeoPcon.h. â—†Â DefineSection(). virtual void TGeoPcon::DefineSection ; (; Int_tÂ ; snum, . Double_tÂ ; z, . Double_tÂ ; rmin, . Double_tÂ ; rmaxÂ . ). virtual . â—†Â DistancetoPrimitive(). Int_t TGeoPcon::DistancetoPrimitive ; (; Int_tÂ ; px, . Int_tÂ ; pyÂ . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. â—†Â DistFromInside(). Double_t TGeoPcon::DistFromInside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. â—†Â DistFromInside_v(). void TGeoPcon::DistFromInside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. â—†Â DistFromOutside(). Double_t TGeoPcon::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. â—†Â DistFromOutside_v(). void TGeoPcon::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. â—†Â DistToSegZ(). Double_t TGeoPcon::DistToSegZ ; (; const Double_t *Â ; point, . const Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPcon.html:26251,safe,safe,26251,doc/master/classTGeoPcon.html,https://root.cern,https://root.cern/doc/master/classTGeoPcon.html,1,['safe'],['safe']
Safety,"; print(""Running with nthreads = {}"".format(ROOT.GetThreadPoolSize())); else:; print(""Running in serial mode since ROOT does not support MT""); ; ; ; ; outputFile = None; if writeOutputFile:; outputFile = TFile.Open(""TMVA_CNN_ClassificationOutput.root"", ""RECREATE""); ; ; ## Create TMVA Factory; ; # Create the Factory class. Later you can choose the methods; # whose performance you'd like to investigate.; ; # The factory is the major TMVA object you have to interact with. Here is the list of parameters you need to pass; ; # - The first argument is the base of the name of all the output; # weight files in the directory weight/ that will be created with the; # method parameters; ; # - The second argument is the output file for the training results; ; # - The third argument is a string option defining some general configuration for the TMVA session.; # For example all TMVA output can be suppressed by removing the ""!"" (not) in front of the ""Silent"" argument in the; # option string; ; # - note that we disable any pre-transformation of the input variables and we avoid computing correlations between; # input variables; ; ; factory = TMVA.Factory(; ""TMVA_CNN_Classification"",; outputFile,; V=False,; ROC=True,; Silent=False,; Color=True,; AnalysisType=""Classification"",; Transformations=None,; Correlations=False,; ); ; ; ## Declare DataLoader(s); ; # The next step is to declare the DataLoader class that deals with input variables; ; # Define the input variables that shall be used for the MVA training; # note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; ; # In this case the input data consists of an image of 16x16 pixels. Each single pixel is a branch in a ROOT TTree; ; loader = TMVA.DataLoader(""dataset""); ; ; ## Setup Dataset(s); ; # Define input data file and signal and background trees; ; ; imgSize = 16 * 16; inputFileName = ""images_data_16x16.root""; ; # if the input file does not exist create it; if ROOT.gSystem.AccessPathName",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:5888,avoid,avoid,5888,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['avoid'],['avoid']
Safety,"; static Bool_tÂ Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr); Â Disconnects signal in object sender from slot_method in object receiver. ; Â . Protected Types; enum Â ESlaves { kAll; , kActive; , kUnique; , kAllUnique; }; Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â . Protected Member Functions; Â TProof (); Â Protected constructor to be used by classes deriving from TProof (they have to call Init themselves and override StartSlaves appropriately). ; Â ; Int_tÂ AddWorkers (TList *wrks); Â Works on the master node only. ; Â ; Int_tÂ AssertPath (const char *path, Bool_t writable); Â Make sure that 'path' exists; if 'writable' is kTRUE, make also sure that the path is writable. ; Â ; Int_tÂ Collect (ESlaves list=kActive, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE); Â Collect responses from the slave servers. ; Â ; Int_tÂ Collect (TList *slaves, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE); Â Collect responses from the slave servers. ; Â ; TSlave *Â CreateSlave (const char *url, const char *ord, Int_t perf, const char *image, const char *workdir); Â Create a new TSlave of type TSlave::kSlave. ; Â ; TSlave *Â CreateSubmaster (const char *url, const char *ord, const char *image, const char *msd, Int_t nwk=1); Â Create a new TSlave of type TSlave::kMaster. ; Â ; TList *Â GetEnabledPackages () const; Â ; TList *Â GetListOfActiveSlaves () const; Â ; TVirtualProofPlayer *Â GetPlayer () const; Â ; TPluginHandler *Â GetProgressDialog () const; Â ; Int_tÂ GetSandbox (TString &sb, Bool_t assert=kFALSE, const char *rc=0); Â Set the sandbox path from ' Proof.Sandbox' or the alternative var 'rc'. ; Â ; voidÂ HandleLibIncPath (const char *what, Bool_t add, const char *dirs); Â Handle lib, inc search paths modification request. ; Â ; Int_tÂ HandleOutputOptions (TString &opt, TString &target, Int_t action); Â Extract from opt information about output handling settings. ; Â ; Int_tÂ In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:37133,timeout,timeout,37133,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['timeout'],['timeout']
Safety,"; static const char *Â DeclFileName (); Â ; static EAsyncOpenStatusÂ GetAsyncOpenStatus (const char *name); Â Get status of the async open request related to 'name'. ; Â ; static EAsyncOpenStatusÂ GetAsyncOpenStatus (TFileOpenHandle *handle); Â Get status of the async open request related to 'handle'. ; Â ; static const char *Â GetCacheFileDir (); Â Get the directory where to locally stage/cache remote files. ; Â ; static const TUrl *Â GetEndpointUrl (const char *name); Â Get final URL for file being opened asynchronously. ; Â ; static Long64_tÂ GetFileBytesRead (); Â Static function returning the total number of bytes read from all files. ; Â ; static Long64_tÂ GetFileBytesWritten (); Â Static function returning the total number of bytes written to all files. ; Â ; static Long64_tÂ GetFileCounter (); Â ; static Int_tÂ GetFileReadCalls (); Â Static function returning the total number of read calls from all files. ; Â ; static Bool_tÂ GetOnlyStaged (); Â Returns staged only flag. ; Â ; static UInt_tÂ GetOpenTimeout (); Â Returns open timeout (in ms). ; Â ; static Int_tÂ GetReadaheadSize (); Â Static function returning the readahead buffer size. ; Â ; static Bool_tÂ GetReadStreamerInfo (); Â If the streamerinfos are to be read at file opening. ; Â ; static EFileTypeÂ GetType (const char *name, Option_t *option="""", TString *prefix=nullptr); Â Resolve the file type as a function of the protocol field in 'name'. ; Â ; static voidÂ IncrementFileCounter (); Â ; static TFile *Â Open (const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0); Â Create / open a file. ; Â ; static TFile *Â Open (TFileOpenHandle *handle); Â Waits for the completion of an asynchronous open request. ; Â ; static Bool_tÂ SetCacheFileDir (std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE); Â Sets the directory where to locally stage/cache remote files. ; Â ; static voidÂ SetFileBytesRead (Long64_t bytes=0); Â ; static v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMemFile.html:28897,timeout,timeout,28897,doc/master/classTMemFile.html,https://root.cern,https://root.cern/doc/master/classTMemFile.html,15,['timeout'],['timeout']
Safety,"; static void*FindDynLib(const char* lib); TSystem*TSystem::FindHelper(const char* path, void* dirptr = 0); TString&TSystem::GetLastErrorString(); const TString&TSystem::GetLastErrorString() const; virtual const char*GetLinkedLibraries(); voidTObject::MakeZombie(); static const char*TSystem::StripOffProto(const char* path, const char* proto); static Func_tUnixDynFindSymbol(const char* lib, const char* entry); static voidUnixDynListLibs(const char* lib = """"); static voidUnixDynListSymbols(const char* lib, const char* re = """"); static intUnixDynLoad(const char* lib); static voidUnixDynUnload(const char* lib); static intUnixFilestat(const char* path, FileStat_t& buf); static intUnixFSstat(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); static const char*UnixGetdirentry(void* dir); static const char*UnixHomedirectory(const char* user = 0); static voidUnixIgnoreSignal(ESignals sig, Bool_t ignore); static intUnixMakedir(const char* name); static Long64_tUnixNow(); static void*UnixOpendir(const char* name); static intUnixRecv(int sock, void* buf, int len, int flag); static voidUnixResetSignal(ESignals sig); static voidUnixResetSignals(); static intUnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); static intUnixSend(int sock, const void* buf, int len, int flag); static intUnixSetitimer(Long_t ms); static voidUnixSigAlarmInterruptsSyscalls(Bool_t set); static voidUnixSignal(ESignals sig, void* h); static const char*UnixSigname(ESignals sig); static intUnixTcpConnect(const char* hostname, int port, int tcpwindowsize); static intUnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize); static intUnixUdpConnect(const char* hostname, int port); static intUnixUdpService(int port, int backlog); static intUnixUnixConnect(int port); static intUnixUnixConnect(const char* path); static intUnixUnixService(int port, int backlog); static intUnixUnixService(const char* sockpath, int backlog); static intUnixWaitchild().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:15905,timeout,timeout,15905,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,1,['timeout'],['timeout']
Safety,"; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside(). Double_t TGeoXtru::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside_v(). void TGeoXtru::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistToPlane(). Double_t TGeoXtru::DistToPlane ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iz, . Int_tÂ ; ivert, . Double_tÂ ; stepmax, . Bool_tÂ ; inÂ . ); const. protected . â—†Â DrawPolygon(). void TGeoXtru::DrawPolygon ; (; Option_t *Â ; option = """"). â—†Â GetBuffer3D(). const TBuffer3D & TGeoXtru::GetBuffer3D ; (; Int_tÂ ; reqSections, . Bool_tÂ ; localFrameÂ . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoBBox. â—†Â GetMakeRuntimeShape(). TGeoShape * TGeoXtru::GetMakeRuntimeShape ; (; TGeoShape *Â ; , . TGeoMatrix *Â ; Â . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 104 of file TGeoXtru.h. â—†Â GetMeshNumbers(). void TGeoXtru::GetMeshNumbers ; (; Int_t &Â ; nvert, . Int_t &Â ; nsegs, . Int_t &Â ; npolsÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â GetNmeshVertices(). Int_t TGeoXtru::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â GetNvert(). Int_t TGeoXtru::GetNvert ; (; ); const. inline . Definition at line 96 of file TGeoXtru.h. â—†Â GetNz(). Int_t TGeoXtru::GetNz ; (; ); const. inline . Definition at line 95 of file TGeoXtru.h. â—†Â GetPlaneNormal(). void TGeoXtru::GetPlaneNormal ; (; const Double_t *Â ; vert, . Double_t *Â ; normÂ . ); const. protected . â—†Â GetPlaneVertices(). void TGeoXtru::GetPlaneVertices ; (; Int_tÂ ; iz, . Int_tÂ ; ivert, . Double_t *Â ; vert",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoXtru.html:27437,avoid,avoid,27437,doc/master/classTGeoXtru.html,https://root.cern,https://root.cern/doc/master/classTGeoXtru.html,1,['avoid'],['avoid']
Safety,"; virtual Bool_tÂ CompileVariables (); Â Compiles each variable from fTreeDrawArgsParser for the tree fTree. ; Â ; voidÂ FillWeight (); Â Get weight from input list, if any. ; Â ; virtual Bool_tÂ ProcessSingle (Long64_t, Int_t); Â Processes a single variable from an entry. ; Â ; voidÂ SetCanvas (const char *objname); Â Move to a canvas named <name>_canvas; create the canvas if not existing. ; Â ; voidÂ SetDrawAtt (TObject *o); Â Set the drawing attributes from the input list. ; Â ; voidÂ SetError (const char *sub, const char *mesg); Â Sets the error status. ; Â ; Â Protected Member Functions inherited from TObject; virtual voidÂ DoError (int level, const char *location, const char *fmt, va_list va) const; Â Interface to ErrorHandler (protected). ; Â ; voidÂ MakeZombie (); Â . Protected Attributes; TGraph *Â fGraph; Â ; Â Protected Attributes inherited from TProofDraw; Int_tÂ fDimension; Â ; TStringÂ fInitialExp; Â ; TTreeFormulaManager *Â fManager; Â ; Int_tÂ fMultiplicity; Â ; Bool_tÂ fObjEval; Â ; TTreeFormula *Â fSelect; Â ; TStringÂ fSelection; Â ; TStatus *Â fStatus; Â ; TTree *Â fTree; Â ; TTreeDrawArgsParserÂ fTreeDrawArgsParser; Â ; TTreeFormula *Â fVar [4]; Â ; Double_tÂ fWeight; Â ; Â Protected Attributes inherited from TSelector; EAbortÂ fAbort; Â Abort status. ; Â ; TList *Â fInput; Â List of objects available during processing. ; Â ; TObject *Â fObject; Â ! Current object if processing object (vs. TTree) ; Â ; TStringÂ fOption; Â Option given to TTree::Process. ; Â ; TSelectorList *Â fOutput; Â ! List of objects created during processing ; Â ; Long64_tÂ fStatus; Â Selector status. ; Â . Additional Inherited Members; Â Public Types inherited from TSelector; enum Â EAbort { kContinue; , kAbortProcess; , kAbortFile; }; Â ; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; Â Â kBitMask = 0x00ffffff. }; Â ; enum Â { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; Â ; enum Â EDe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawGraph.html:13070,Abort,Abort,13070,doc/master/classTProofDrawGraph.html,https://root.cern,https://root.cern/doc/master/classTProofDrawGraph.html,1,['Abort'],['Abort']
Safety,"; virtual Bool_tÂ CompileVariables (); Â Compiles each variable from fTreeDrawArgsParser for the tree fTree. ; Â ; voidÂ FillWeight (); Â Get weight from input list, if any. ; Â ; virtual Bool_tÂ ProcessSingle (Long64_t, Int_t); Â Processes a single variable from an entry. ; Â ; voidÂ SetCanvas (const char *objname); Â Move to a canvas named <name>_canvas; create the canvas if not existing. ; Â ; voidÂ SetDrawAtt (TObject *o); Â Set the drawing attributes from the input list. ; Â ; voidÂ SetError (const char *sub, const char *mesg); Â Sets the error status. ; Â ; Â Protected Member Functions inherited from TObject; virtual voidÂ DoError (int level, const char *location, const char *fmt, va_list va) const; Â Interface to ErrorHandler (protected). ; Â ; voidÂ MakeZombie (); Â . Protected Attributes; TH1 *Â fHistogram; Â ; Â Protected Attributes inherited from TProofDraw; Int_tÂ fDimension; Â ; TStringÂ fInitialExp; Â ; TTreeFormulaManager *Â fManager; Â ; Int_tÂ fMultiplicity; Â ; Bool_tÂ fObjEval; Â ; TTreeFormula *Â fSelect; Â ; TStringÂ fSelection; Â ; TStatus *Â fStatus; Â ; TTree *Â fTree; Â ; TTreeDrawArgsParserÂ fTreeDrawArgsParser; Â ; TTreeFormula *Â fVar [4]; Â ; Double_tÂ fWeight; Â ; Â Protected Attributes inherited from TSelector; EAbortÂ fAbort; Â Abort status. ; Â ; TList *Â fInput; Â List of objects available during processing. ; Â ; TObject *Â fObject; Â ! Current object if processing object (vs. TTree) ; Â ; TStringÂ fOption; Â Option given to TTree::Process. ; Â ; TSelectorList *Â fOutput; Â ! List of objects created during processing ; Â ; Long64_tÂ fStatus; Â Selector status. ; Â . Private Member Functions; voidÂ DefVar1D (); Â Define vars for 1D Histogram. ; Â ; voidÂ DefVar2D (); Â Define variables for 2D histogram. ; Â ; voidÂ DefVar3D (); Â Define variables for 3D histogram. ; Â . Additional Inherited Members; Â Public Types inherited from TSelector; enum Â EAbort { kContinue; , kAbortProcess; , kAbortFile; }; Â ; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawHist.html:13334,Abort,Abort,13334,doc/master/classTProofDrawHist.html,https://root.cern,https://root.cern/doc/master/classTProofDrawHist.html,1,['Abort'],['Abort']
Safety,"; virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidComputeTwist(); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoArb8.html:2691,safe,safe,2691,root/html528/TGeoArb8.html,https://root.cern,https://root.cern/root/html528/TGeoArb8.html,1,['safe'],['safe']
Safety,"; virtual Int_tÂ GetOption (ESockOptions opt, Int_t &val); Â Get socket options. Returns -1 in case of error. ; Â ; Int_tÂ GetPort () const; Â ; Int_tÂ GetRemoteProtocol () const; Â ; TSecContext *Â GetSecContext () const; Â ; const char *Â GetService () const; Â ; Int_tÂ GetServType () const; Â ; const char *Â GetUrl () const; Â ; TClass *Â IsA () const override; Â ; virtual Bool_tÂ IsValid () const; Â ; virtual Int_tÂ Reconnect (); Â ; virtual Int_tÂ Recv (char *mess, Int_t max); Â Receive a character string message of maximum max length. ; Â ; virtual Int_tÂ Recv (char *mess, Int_t max, Int_t &kind); Â Receive a character string message of maximum max length. ; Â ; virtual Int_tÂ Recv (Int_t &status, Int_t &kind); Â Receives a status and a message type. ; Â ; virtual Int_tÂ Recv (TMessage *&mess); Â Receive a TMessage object. ; Â ; virtual Int_tÂ RecvRaw (void *buffer, Int_t length, ESendRecvOptions opt=kDefault); Â Receive a raw buffer of specified length bytes. ; Â ; virtual Int_tÂ Select (Int_t interest=kRead, Long_t timeout=-1); Â Waits for this socket to change status. ; Â ; virtual Int_tÂ Send (const char *mess, Int_t kind=kMESS_STRING); Â Send a character string buffer. ; Â ; virtual Int_tÂ Send (const TMessage &mess); Â Send a TMessage object. ; Â ; virtual Int_tÂ Send (Int_t kind); Â Send a single message opcode. ; Â ; virtual Int_tÂ Send (Int_t status, Int_t kind); Â Send a status and a single message opcode. ; Â ; virtual Int_tÂ SendObject (const TObject *obj, Int_t kind=kMESS_OBJECT); Â Send an object. ; Â ; virtual Int_tÂ SendRaw (const void *buffer, Int_t length, ESendRecvOptions opt=kDefault); Â Send a raw buffer of specified length. ; Â ; voidÂ SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal); Â See comments for function SetCompressionSettings. ; Â ; voidÂ SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin); Â See comments for function SetCompressionSettings. ; Â ; voidÂ SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUDPSocket.html:3588,timeout,timeout,3588,doc/master/classTUDPSocket.html,https://root.cern,https://root.cern/doc/master/classTUDPSocket.html,1,['timeout'],['timeout']
Safety,"; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoBoolNode::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidTGeoBoolNode::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoIntersection.html:2513,safe,safe,2513,root/html534/TGeoIntersection.html,https://root.cern,https://root.cern/root/html534/TGeoIntersection.html,9,['safe'],['safe']
Safety,"; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowCache(Bool_t all = kFALSE); virtual voidShowData(); voidShowDataSet(const char* dataset = """", const char* opt = ""filter:SsCc""); virtual voidShowDataSetCache(const char* dataset = 0); voidShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* optStr = """"); voidShowEnabledPackages(Bool_t all = kFALSE); voidShowFeedback() const; voidShowLog(Int_t qry = -1); voidShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp) const; voidShowMissingFiles(TQueryResult* qr = 0); voidShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidShowParameters(const char* wildcard = ""PROOF_*"") const; voidShowQueries(Option_t* opt = """"); virtual voidShowStagingStatusDataSet(const char* dataset, const char* optStr = ""filter:SsCc""); virtual Int_tTNamed::Sizeof() const; voidStartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTouch(); TProof(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Int_tUploadDataSet(const char*, TList*, const char* = 0, Int_t = 0, TList* = 0); Int_tUploadDataSet(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tUploadDataSetFromFile(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tUploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar, TList* workers = 0); virtual voidTObject::UseCurrentStyle(); Bool_tUseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:17383,abort,abort,17383,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,2,['abort'],['abort']
Safety,"; virtual voidÂ ClearThreadData () const; Â ; virtual voidÂ ComputeBBox ()=0; Â ; virtual voidÂ ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm)=0; Â ; virtual voidÂ ComputeNormal_v (const Double_t *, const Double_t *, Double_t *, Int_t); Â ; virtual Bool_tÂ Contains (const Double_t *point) const =0; Â ; virtual voidÂ Contains_v (const Double_t *, Bool_t *, Int_t) const; Â ; virtual Bool_tÂ CouldBeCrossed (const Double_t *point, const Double_t *dir) const =0; Â ; virtual voidÂ CreateThreadData (Int_t); Â ; Int_tÂ DistancetoPrimitive (Int_t px, Int_t py) override=0; Â Computes distance from point (px,py) to the object. ; Â ; virtual Double_tÂ DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; Â ; virtual voidÂ DistFromInside_v (const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *) const; Â ; virtual Double_tÂ DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; Â ; virtual voidÂ DistFromOutside_v (const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *) const; Â ; virtual TGeoVolume *Â Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step)=0; Â ; voidÂ Draw (Option_t *option="""") override; Â Draw this shape. ; Â ; voidÂ ExecuteEvent (Int_t event, Int_t px, Int_t py) override; Â Execute mouse actions on this shape. ; Â ; virtual const char *Â GetAxisName (Int_t iaxis) const =0; Â ; virtual Double_tÂ GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const =0; Â ; virtual voidÂ GetBoundingCylinder (Double_t *param) const =0; Â ; virtual const TBuffer3D &Â GetBuffer3D (Int_t reqSections, Bool_t localFrame) const; Â Stub implementation to avoid forcing implementation at this stage. ; Â ; virtual Int_tÂ GetByteCount () const =0; Â ; virtual Int_tÂ GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:10221,safe,safe,10221,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,2,['safe'],['safe']
Safety,"; virtual~TGeoSubtraction(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoBoolNode::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoSubtraction.html:2424,safe,safe,2424,root/html532/TGeoSubtraction.html,https://root.cern,https://root.cern/root/html532/TGeoSubtraction.html,1,['safe'],['safe']
Safety,"; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoConeSeg&operator=(const TGeoConeSeg&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(const Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidTGeoCone::SetConeDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); voidSetConsDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoConeSeg.html:9937,safe,safe,9937,root/html534/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html,1,['safe'],['safe']
Safety,"; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTubeSeg&operator=(const TGeoTubeSeg&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeSeg.html:10003,safe,safe,10003,root/html534/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html,1,['safe'],['safe']
Safety,"; voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnableTimeout(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidTProofServ::ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static voidTProofServ::FilterLocalroot(TString& path, const char* url = ""root://dum/""); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidTProofServ::FlushLogFile(); TObject*TProofServ::Get(const char* namecycle); Int_tTProofServ::GetActSessions() const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXProofServ.html:4082,abort,abort,4082,root/html534/TXProofServ.html,https://root.cern,https://root.cern/root/html534/TXProofServ.html,1,['abort'],['abort']
Safety,"; voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnableTimeout(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidTProofServ::ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidTProofServ::FlushLogFile(); TObject*TProofServ::Get(const char* namecycle); Int_tTProofServ::GetActSessions() const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; TProofLockPath*TProofServ::GetCacheLock(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXProofServ.html:4082,abort,abort,4082,root/html528/TXProofServ.html,https://root.cern,https://root.cern/root/html528/TXProofServ.html,3,['abort'],['abort']
Safety,"; w80r, . Bool_t &Â ; w80v, . TString &Â ; wmsgÂ . ). protected . Check the memory usage, if requested. ; Return kTRUE if OK, kFALSE if above 95% of at least one between virtual or resident limits are depassed. ; Definition at line 1512 of file TProofPlayer.cxx. â—†Â Class(). static TClass * TProofPlayer::Class ; (; ). static . ReturnsTClass describing this class . â—†Â Class_Name(). static const char * TProofPlayer::Class_Name ; (; ). static . ReturnsName of this class . â—†Â Class_Version(). static constexpr Version_t TProofPlayer::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 228 of file TProofPlayer.h. â—†Â ClearInput(). void TProofPlayer::ClearInput ; (; ). overridevirtual . Clear input list. ; Implements TVirtualProofPlayer.; Definition at line 468 of file TProofPlayer.cxx. â—†Â CreateDrawFeedback(). TDrawFeedback * TProofPlayer::CreateDrawFeedback ; (; TProof *Â ; p). overridevirtual . Draw feedback creation proxy. ; When accessed via TProof avoids link dependency on libProofPlayer. ; Implements TVirtualProofPlayer.; Definition at line 733 of file TProofPlayer.cxx. â—†Â DeclFileName(). static const char * TProofPlayer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 228 of file TProofPlayer.h. â—†Â DeleteDrawFeedback(). void TProofPlayer::DeleteDrawFeedback ; (; TDrawFeedback *Â ; f). overridevirtual . Delete draw feedback object. ; Implements TVirtualProofPlayer.; Definition at line 750 of file TProofPlayer.cxx. â—†Â DrawCanvas(). Int_t TProofPlayer::DrawCanvas ; (; TObject *Â ; obj). protectedvirtual . Draw the object if it is a canvas. ; Return 0 in case of success, 1 if it is not a canvas or libProofDraw is not available. ; Definition at line 1696 of file TProofPlayer.cxx. â—†Â DrawSelect(). Long64_t TProofPlayer::DrawSelect ; (; TDSet *Â ; set, . const char *Â ; varexp, . const char *Â ; selection, . Option_t *Â ; option = """", . Long64_tÂ ; nentries = -1, . Long64_tÂ ; firstentry",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:27139,avoid,avoids,27139,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['avoid'],['avoids']
Safety,"; we do y; }; However, there is one special case, namely functions: they have the opening brace at the beginning of the next line, thus:; int function (int x); {; body of function; }; Functions are special (you can't nest them in C/C++).; Note that the closing brace is empty on a line of its own, except in the cases where it is followed by a continuation of the same statement, ie a while in a do-statement or an else in an if-statement, like this:; do {; body of do - loop; } while ( condition ) ;; and; if (x == y) {; ...; } else if (x > y) {; ...; } else {; ... ; }; Note that this brace-placement also minimizes the number of empty (or almost empty) lines, without any loss of readability. Thus, as the supply of new-lines on your screen is not a renewable resource (think 25-line terminal screens here), you have more empty lines to put comments on.; Notice also in the above examples the usage of spaces around keywords, operators and parenthesis/braces. Avoid the following free styles:; if (x == y) {; or any derivative thereof.; ClangFormat; ClangFormat is a Clang tool which allows you to format your code. This is the configuration file for it:; ---; Language: Cpp; # BasedOnStyle: LLVM; AccessModifierOffset: -3; AlignAfterOpenBracket: Align; AlignConsecutiveAssignments: true; # This would be nice to have but seems to also (mis)align function parameters; AlignConsecutiveDeclarations: true; AlignEscapedNewlinesLeft: true; AlignOperands: true; AlignTrailingComments: true; AllowAllParametersOfDeclarationOnNextLine: true; AllowShortBlocksOnASingleLine: false; AllowShortCaseLabelsOnASingleLine: true; AllowShortFunctionsOnASingleLine: Inline; AllowShortIfStatementsOnASingleLine: true; AllowShortLoopsOnASingleLine: true; # This option is ""deprecated and is retained for backwards compatibility.""; # AlwaysBreakAfterDefinitionReturnType: None; AlwaysBreakAfterReturnType: None; AlwaysBreakBeforeMultilineStrings: false; AlwaysBreakTemplateDeclarations: true; BinPackArguments: true; B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/coding-conventions.html:8549,Avoid,Avoid,8549,d/coding-conventions.html,https://root.cern,https://root.cern/d/coding-conventions.html,1,['Avoid'],['Avoid']
Safety,"; }; Â ; Â Protected Member Functions inherited from TObject; virtual voidÂ DoError (int level, const char *location, const char *fmt, va_list va) const; Â Interface to ErrorHandler (protected). ; Â ; voidÂ MakeZombie (); Â . #include <TFilePrefetch.h>. Inheritance diagram for TFilePrefetch:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. â—†Â TFilePrefetch(). TFilePrefetch::TFilePrefetch ; (; TFile *Â ; file). Constructor. ; Definition at line 54 of file TFilePrefetch.cxx. â—†Â ~TFilePrefetch(). TFilePrefetch::~TFilePrefetch ; (; ). override . Destructor. ; Definition at line 72 of file TFilePrefetch.cxx. Member Function Documentation. â—†Â AddPendingBlock(). void TFilePrefetch::AddPendingBlock ; (; TFPBlock *Â ; block). Safe method to add a block to the pendingList. ; Definition at line 223 of file TFilePrefetch.cxx. â—†Â AddReadBlock(). void TFilePrefetch::AddReadBlock ; (; TFPBlock *Â ; block). Safe method to add a block to the readList. ; Definition at line 259 of file TFilePrefetch.cxx. â—†Â BinarySearchReadList(). Bool_t TFilePrefetch::BinarySearchReadList ; (; TFPBlock *Â ; blockObj, . Long64_tÂ ; offset, . Int_tÂ ; len, . Int_t *Â ; indexÂ . ). Search for a requested element in a block and return the index. ; Definition at line 144 of file TFilePrefetch.cxx. â—†Â CheckBlockInCache(). Bool_t TFilePrefetch::CheckBlockInCache ; (; char *&Â ; path, . TFPBlock *Â ; blockÂ . ). Test if the block is in cache. ; Definition at line 395 of file TFilePrefetch.cxx. â—†Â Class(). static TClass * TFilePrefetch::Class ; (; ). static . ReturnsTClass describing this class . â—†Â Class_Name(). static const char * TFilePrefetch::Class_Name ; (; ). static . ReturnsName of this class . â—†Â Class_Version(). static constexpr Version_t TFilePrefetch::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 84 of file TFilePrefetch.h. â—†Â CreateBlockObj(). TFPBlock * TFilePrefetch::CreateBlockObj ; (;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFilePrefetch.html:13993,Safe,Safe,13993,doc/master/classTFilePrefetch.html,https://root.cern,https://root.cern/doc/master/classTFilePrefetch.html,1,['Safe'],['Safe']
Safety,"; Â  Example showing an histogram with reverse axis. ; Â ; Â sparsehist.C; Â Evaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ; Â ; Â statsEditing.C; Â  Edit statistics box. ; Â ; Â testSmooth.C; Â  Histogram smoothing. ; Â ; Â th2polyBoxes.C; Â  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly). ; Â ; Â th2polyEurope.C; Â  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it. ; Â ; Â th2polyHoneycomb.C; Â  This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly). ; Â ; Â th2polyUSA.C; Â  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option. ; Â ; Â thstack2palettecolor.C; Â  Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color). ; Â ; Â thstackcolorscheme.C; Â  This example demonstrates how to use the accessible color schemes with THStack. ; Â ; Â thstackpalettecolor.C; Â  Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; Â ; Â tprofile2polyRealistic.C; Â  Different charges depending on region ; Â ; Â tprofile2polyRealisticModuleError.C; Â  Simulate faulty detector panel w.r.t. ; Â ; Â transpad.C; Â  Example of a canvas showing two histograms with different scales. ; Â ; Â twoscales.C; Â  Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ; Â ; Â twoscales.py; Â  Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ; Â ; Â xyplot.C; Â  Example showing how to produce a plot with an orthogonal axis system centered at (0,0). ; Â ; Â ZoomHistogram.C; Â  Changing the Range on the X-Axis of a Histogram ; Â . tutorialshist. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 Â Â ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:6287,detect,detector,6287,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,1,['detect'],['detector']
Safety,"; Â . Public Member Functions; Â RWebDisplayHandle (const std::string &url); Â constructor ; Â ; virtualÂ ~RWebDisplayHandle ()=default; Â required virtual destructor for correct cleanup at the end ; Â ; const std::string &Â GetContent () const; Â get content ; Â ; const std::string &Â GetUrl () const; Â returns url of start web display ; Â ; virtual boolÂ Resize (int, int); Â resize web window - if possible ; Â ; voidÂ SetContent (const std::string &cont); Â set content ; Â . Static Public Member Functions; static boolÂ CanProduceImages (const std::string &browser=""""); Â Returns true if image production for specified browser kind is supported If browser not specified - use currently configured browser or try to test existing web browsers. ; Â ; static std::unique_ptr< RWebDisplayHandle >Â Display (const RWebDisplayArgs &args); Â Create web display. ; Â ; static boolÂ DisplayUrl (const std::string &url); Â Display provided url in configured web browser. ; Â ; static std::stringÂ GetImageFormat (const std::string &fname); Â Detect image format There is special handling of "".screenshot.pdf"" and "".screenshot.png"" extensions Creation of such files relies on headless browser functionality and fully supported only by Chrome browser. ; Â ; static boolÂ NeedHttpServer (const RWebDisplayArgs &args); Â Check if http server required for display. ; Â ; static boolÂ ProduceImage (const std::string &fname, const std::string &json, int width=800, int height=600, const char *batch_file=nullptr); Â Produce image file using JSON data as source Invokes JSROOT drawing functionality in headless browser - Google Chrome or Mozilla Firefox. ; Â ; static boolÂ ProduceImages (const std::string &fname, const std::vector< std::string > &jsons, const std::vector< int > &widths, const std::vector< int > &heights, const char *batch_file=nullptr); Â Produce image file(s) using JSON data as source Invokes JSROOT drawing functionality in headless browser - Google Chrome or Mozilla Firefox. ; Â ; static boolÂ ProduceImages (const std::vecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebDisplayHandle.html:1764,Detect,Detect,1764,doc/master/classROOT_1_1RWebDisplayHandle.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebDisplayHandle.html,1,['Detect'],['Detect']
Safety,"; Â ; TGeoVolume *Â Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; Â ; const char *Â GetAxisName (Int_t iaxis) const override; Â ; Double_tÂ GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override; Â ; voidÂ GetBoundingCylinder (Double_t *param) const override; Â ; const TBuffer3D &Â GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override; Â Stub implementation to avoid forcing implementation at this stage. ; Â ; Int_tÂ GetByteCount () const override; Â ; virtual Double_tÂ GetDz () const; Â ; TGeoShape *Â GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override; Â ; voidÂ GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override; Â ; Int_tÂ GetNmeshVertices () const override; Â ; Bool_tÂ GetPointsOnSegments (Int_t npoints, Double_t *array) const override; Â ; virtual Double_tÂ GetRmax1 () const; Â ; virtual Double_tÂ GetRmax2 () const; Â ; virtual Double_tÂ GetRmin1 () const; Â ; virtual Double_tÂ GetRmin2 () const; Â ; voidÂ InspectShape () const override; Â ; TClass *Â IsA () const override; Â ; Bool_tÂ IsCylType () const override; Â ; TBuffer3D *Â MakeBuffer3D () const override; Â ; Double_tÂ Safety (const Double_t *point, Bool_t in=kTRUE) const override; Â ; voidÂ Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; Â ; voidÂ SavePrimitive (std::ostream &out, Option_t *option="""") override; Â Save a primitive as a C++ statement(s) on output stream ""out"". ; Â ; voidÂ SetConeDimensions (Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Â ; voidÂ SetDimensions (Double_t *param) override; Â ; voidÂ SetPoints (Double_t *points) const override; Â ; voidÂ SetPoints (Float_t *points) const override; Â ; voidÂ SetSegsAndPols (TBuffer3D &buffer) const override; Â ; voidÂ Sizeof3D () const override; Â ; voidÂ Streamer (TBuffer &) override; Â Stream an object of class TObject. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCone.html:2974,Safe,Safety,2974,doc/master/classTGeoCone.html,https://root.cern,https://root.cern/doc/master/classTGeoCone.html,2,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"; Â ; TList *Â GetOutputList () const override; Â ; voidÂ Init (TTree *tree) override; Â ; TClass *Â IsA () const override; Â ; boolÂ Notify () override; Â This method must be overridden to handle object notification (the base implementation is no-op). ; Â ; boolÂ Process (Long64_t entry) override; Â The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; Â ; voidÂ SetInputList (TList *input) override; Â ; voidÂ SetObject (TObject *obj) override; Â ; voidÂ SetOption (const char *option) override; Â ; voidÂ SlaveBegin (TTree *tree) override; Â ; voidÂ SlaveTerminate () override; Â ; voidÂ Streamer (TBuffer &) override; Â Stream an object of class TObject. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; Int_tÂ Version () const override; Â ; Â Public Member Functions inherited from TSelector; Â TSelector (); Â Default selector ctor. ; Â ; Â ~TSelector () override; Â Selector destructor. ; Â ; virtual voidÂ Abort (const char *why, EAbort what=kAbortProcess); Â Abort processing. ; Â ; virtual voidÂ Begin (TTree *); Â ; virtual EAbortÂ GetAbort () const; Â ; virtual TList *Â GetInputList () const; Â ; const char *Â GetOption () const override; Â ; virtual Long64_tÂ GetStatus () const; Â ; virtual voidÂ ImportOutput (TList *output); Â Imports the content of 'output' in the internal output list. ; Â ; TClass *Â IsA () const override; Â ; boolÂ Notify () override; Â This method must be overridden to handle object notification (the base implementation is no-op). ; Â ; virtual boolÂ ProcessCut (Long64_t); Â This method is called before processing entry. ; Â ; virtual voidÂ ProcessFill (Long64_t); Â This method is called for all selected entries. ; Â ; virtual voidÂ ResetAbort (); Â ; virtual voidÂ SetStatus (Long64_t status); Â ; voidÂ Streamer (TBuffer &) override; Â Stream an object of class TObject. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; virtual voidÂ Terminate (); Â ; Â Public Member Functions inherited from TObject; Â TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProofDriverSelector.html:1456,Abort,Abort,1456,doc/master/classRooProofDriverSelector.html,https://root.cern,https://root.cern/doc/master/classRooProofDriverSelector.html,2,['Abort'],['Abort']
Safety,"; Â ; boolÂ _prohibitServerRedirect = false; Â Set of owned component. ; Â ; RooRefArrayÂ _proxyList; Â ; ProxyListCacheÂ _proxyListCache; Â ; RefCountList_tÂ _serverList; Â ; boolÂ _shapeDirty = true; Â ; std::map< std::string, std::string >Â _stringAttrib; Â ; boolÂ _valueDirty = true; Â ; Â Protected Attributes inherited from TNamed; TStringÂ fName; Â ; TStringÂ fTitle; Â . Static Protected Attributes; static boolÂ _doFloorGlobal = false; Â Global flag for introducing floor at zero in pdf. ; Â ; Â Static Protected Attributes inherited from RooAbsReal; static Int_tÂ _evalErrorCount = 0; Â ; static std::map< const RooAbsArg *, std::pair< std::string, std::list< EvalError > > >Â _evalErrorList; Â ; static ErrorLoggingModeÂ _evalErrorMode = RooAbsReal::PrintErrors; Â ; static boolÂ _globalSelectComp = false; Â ; static boolÂ _hideOffset = true; Â Offset hiding flag. ; Â ; Â Static Protected Attributes inherited from RooAbsArg; static boolÂ _inhibitDirty; Â ; static boolÂ _verboseDirty; Â cache of the list of proxies. Avoids type casting. ; Â ; Â Static Protected Attributes inherited from RooPrintable; static Int_tÂ _nameLength; Â . Additional Inherited Members; Â Public Types inherited from RooAbsReal; enum Â ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; }; Â ; typedef std::map< constRooAbsArg *, std::pair< std::string, std::list< EvalError > > >::const_iteratorÂ EvalErrorIter; Â ; enum Â ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; }; Â ; usingÂ value_type = double; Â ; Â Public Types inherited from RooAbsArg; enum Â CacheMode { Always =0; , NotAdvised =1; , Never =2; }; Â ; enum Â ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; }; Â ; enum Â OperMode { Auto =0; , AClean =1; , ADirty =2; }; Â ; usingÂ RefCountList_t = RooSTLRefCountList< RooAbsArg >; Â ; usingÂ RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >; Â ; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumFunc.html:52292,Avoid,Avoids,52292,doc/v632/classRooRealSumFunc.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumFunc.html,1,['Avoid'],['Avoids']
Safety,; Â ; voidÂ MakeZombie (); Â . Protected Attributes; ROOT::R::TRFunctionImportÂ asfactor; Â ; std::vector< UInt_t >Â fFactorNumeric; Â ; TStringÂ fHiddenActFunc; Â ; TStringÂ fInitFunc; Â ; TStringÂ fInitFuncParams; Â ; TStringÂ fLearnFunc; Â ; TStringÂ fLearnFuncParams; Â ; Bool_tÂ fLinOut; Â ; UInt_tÂ fMaxit; Â ; ROOT::R::TRObject *Â fModel; Â ; UInt_tÂ fMvaCounter; Â ; TStringÂ fNetType; Â ; std::vector< Float_t >Â fProbResultForTestSig; Â ; std::vector< Float_t >Â fProbResultForTrainSig; Â ; TStringÂ fPruneFunc; Â ; TStringÂ fPruneFuncParams; Â ; Bool_tÂ fShufflePatterns; Â ; TStringÂ fSize; Â ; TStringÂ fUpdateFunc; Â ; TStringÂ fUpdateFuncParams; Â ; ROOT::R::TRFunctionImportÂ mlp; Â ; ROOT::R::TRFunctionImportÂ predict; Â ; Â Protected Attributes inherited from TMVA::RMethodBase; ROOT::R::TRDataFrameÂ fDfSpectators; Â ; ROOT::R::TRDataFrameÂ fDfTest; Â ; ROOT::R::TRDataFrameÂ fDfTrain; Â ; std::vector< std::string >Â fFactorTest; Â ; std::vector< std::string >Â fFactorTrain; Â ; TVectorDÂ fWeightTest; Â ; TVectorDÂ fWeightTrain; Â ; ROOT::R::TRInterface &Â r; Â ; Â Protected Attributes inherited from TMVA::MethodBase; Types::EAnalysisTypeÂ fAnalysisType; Â ; UInt_tÂ fBackgroundClass; Â ; boolÂ fExitFromTraining = false; Â ; std::vector< TString > *Â fInputVars; Â ; IPythonInteractive *Â fInteractive = nullptr; Â temporary dataset used when evaluating on a different data (used by MethodCategory::GetMvaValues) ; Â ; UInt_tÂ fIPyCurrentIter = 0; Â ; UInt_tÂ fIPyMaxIter = 0; Â ; std::vector< Float_t > *Â fMulticlassReturnVal; Â ; Int_tÂ fNbins; Â ; Int_tÂ fNbinsH; Â ; Int_tÂ fNbinsMVAoutput; Â ; Ranking *Â fRanking; Â ; std::vector< Float_t > *Â fRegressionReturnVal; Â ; Results *Â fResults; Â ; UInt_tÂ fSignalClass; Â ; DataSet *Â fTmpData = nullptr; Â temporary event when testing on a different DataSet than the own one ; Â ; const Event *Â fTmpEvent; Â ; Â Protected Attributes inherited from TMVA::Configurable; MsgLogger *Â fLogger; Â ! message logger ; Â ; Â Protected Attributes inherited from TNamed; TStringÂ fName; Â ; TStringÂ fTitle; Â . Static Protected Attribute,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodRSNNS.html:24794,predict,predict,24794,doc/master/classTMVA_1_1MethodRSNNS.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodRSNNS.html,1,['predict'],['predict']
Safety,"; Â ; voidÂ SetDataCallBack (WebWindowDataCallback_t func); Â Set call-back function for data, received from the clients via websocket. ; Â ; voidÂ SetDefaultPage (const std::string &page); Â Set content of default window HTML page This page returns when URL address of the window will be requested Either HTML code or file name in the form ""file:/home/user/data/file.htm"" One also can using default locations like ""file:rootui5sys/canv/canvas.html"". ; Â ; voidÂ SetDisconnectCallBack (WebWindowConnectCallback_t func); Â Set call-back function for disconnecting. ; Â ; voidÂ SetGeometry (unsigned width, unsigned height); Â Set window geometry. Will be applied if supported by used web display (like CEF or Chromium) ; Â ; voidÂ SetMaxQueueLength (unsigned len=10); Â configures maximal queue length of data which can be held by window ; Â ; voidÂ SetNativeOnlyConn (bool on=true); Â configures that only native (own-created) connections are allowed ; Â ; voidÂ SetOperationTmout (float tm=50.); Â Set timeout for synchronous WebWindow operations. ; Â ; voidÂ SetPanelName (const std::string &name); Â Configure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel.html"" as default HTML page At the moment only FitPanel is existing. ; Â ; voidÂ SetPosition (unsigned x, unsigned y); Â Set window position. Will be applied if supported by used web display (like CEF or Chromium) ; Â ; voidÂ SetRequireAuthKey (bool on); Â Configure if authentication key in connection string is required. ; Â ; voidÂ SetUseCurrentDir (bool on=true); Â Configure if window can access local files via currentdir/ path of http server. ; Â ; voidÂ SetUserArgs (const std::string &args); Â Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON code injected into main HTML document into connectWebWindow({}) Must be set before RWebWindow::Show() method is called. ; Â ; unsignedÂ Show (const RWebDisplayArgs &args=""""); Â Show window in specified location. ; Â ; voidÂ StartThread (); Â Star",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:8838,timeout,timeout,8838,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,2,['timeout'],['timeout']
Safety,"; Â ; Â TGeoTrd2 (Double_t *params); Â ; Â TGeoTrd2 (Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); Â ; Â ~TGeoTrd2 () override; Â ; Double_tÂ Capacity () const override; Â ; voidÂ ComputeBBox () override; Â ; voidÂ ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override; Â ; voidÂ ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override; Â ; Bool_tÂ Contains (const Double_t *point) const override; Â ; voidÂ Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override; Â ; Double_tÂ DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; Â ; voidÂ DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; Â ; Double_tÂ DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; Â ; voidÂ DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; Â ; TGeoVolume *Â Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; Â ; Double_tÂ GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override; Â ; voidÂ GetBoundingCylinder (Double_t *param) const override; Â ; Int_tÂ GetByteCount () const override; Â ; Double_tÂ GetDx1 () const; Â ; Double_tÂ GetDx2 () const; Â ; Double_tÂ GetDy1 () const; Â ; Double_tÂ GetDy2 () const; Â ; Double_tÂ GetDz () const; Â ; Int_tÂ GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override; Â ; TGeoShape *Â GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override; Â ; voidÂ GetOppositeCorner (const Double_t *point, Int_t inorm, Double_t *vertex, Double_t *normals) const; Â ; voidÂ GetVisibleCorner (const Double_t *point, Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd2.html:1482,safe,safe,1482,doc/master/classTGeoTrd2.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd2.html,1,['safe'],['safe']
Safety,"; Â A page as being stored on disk, that is packed and compressed. More...; Â ; class Â ROOT::Experimental::Internal::ROnDiskPageMap; Â A memory region that contains packed and compressed pages. More...; Â ; class Â ROOT::Experimental::Internal::ROnDiskPageMapHeap; Â An ROnDiskPageMap that is used for an fMemory allocated as an array of unsigned char. More...; Â ; class Â ROOT::Experimental::Internal::RPage; Â A page is a slice of a column that is mapped into memory. More...; Â ; class Â ROOT::Experimental::Internal::RPageAllocator; Â Abstract interface to allocate and release pages. More...; Â ; class Â ROOT::Experimental::Internal::RPageAllocatorHeap; Â Uses standard C++ memory allocation for the column data pages. More...; Â ; class Â ROOT::Experimental::Internal::RPageNullSink; Â Dummy sink that discards all pages. More...; Â ; class Â ROOT::Experimental::Internal::RPagePersistentSink; Â Base class for a sink with a physical storage backend. More...; Â ; class Â ROOT::Experimental::Internal::RPagePool; Â A thread-safe cache of pages loaded from the page source. More...; Â ; class Â ROOT::Experimental::RClusterDescriptor::RPageRange; Â Records the partition of data into pages for a particular column in a particular cluster. More...; Â ; class Â ROOT::Experimental::Internal::RPageRef; Â Reference to a page stored in the page pool. More...; Â ; class Â ROOT::Experimental::Internal::RPageSink; Â Abstract interface to write data into an ntuple. More...; Â ; class Â ROOT::Experimental::Internal::RPageSinkBuf; Â Wrapper sink that coalesces cluster column page writes. More...; Â ; class Â ROOT::Experimental::Internal::RPageSinkDaos; Â Storage provider that writes ntuple pages to into a DAOS container. More...; Â ; class Â ROOT::Experimental::Internal::RPageSinkFile; Â Storage provider that write ntuple pages into a file. More...; Â ; class Â ROOT::Experimental::Internal::RPageSource; Â Abstract interface to read data from an ntuple. More...; Â ; class Â ROOT::Experimental::Internal::RPageSourceDaos; Â Storage provider ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__NTuple.html:12224,safe,safe,12224,doc/master/group__NTuple.html,https://root.cern,https://root.cern/doc/master/group__NTuple.html,1,['safe'],['safe']
Safety,"; Â Destructor. ; Â ; voidÂ Begin (TTree *) override; Â Executed by the client before processing. ; Â ; voidÂ Init (TTree *) override; Â Init the tree. ; Â ; TClass *Â IsA () const override; Â ; Bool_tÂ Notify () override; Â Called when a new tree is loaded. ; Â ; Bool_tÂ Process (Long64_t) override; Â Executed for each entry. ; Â ; voidÂ SlaveBegin (TTree *) override; Â Executed by each slave before processing. ; Â ; voidÂ SlaveTerminate () override; Â Executed by each slave after the processing has finished, before returning the results to the client. ; Â ; voidÂ Streamer (TBuffer &) override; Â Stream an object of class TObject. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; voidÂ Terminate () override; Â Executed by the client after getting the processing retults. ; Â ; intÂ Version () const override; Â ; Â Public Member Functions inherited from TSelector; Â TSelector (); Â Default selector ctor. ; Â ; Â ~TSelector () override; Â Selector destructor. ; Â ; virtual voidÂ Abort (const char *why, EAbort what=kAbortProcess); Â Abort processing. ; Â ; virtual EAbortÂ GetAbort () const; Â ; virtual Int_tÂ GetEntry (Long64_t, Int_t=0); Â ; virtual TList *Â GetInputList () const; Â ; const char *Â GetOption () const override; Â ; virtual TList *Â GetOutputList () const; Â ; virtual Long64_tÂ GetStatus () const; Â ; virtual voidÂ ImportOutput (TList *output); Â Imports the content of 'output' in the internal output list. ; Â ; TClass *Â IsA () const override; Â ; boolÂ Notify () override; Â This method must be overridden to handle object notification (the base implementation is no-op). ; Â ; virtual boolÂ ProcessCut (Long64_t); Â This method is called before processing entry. ; Â ; virtual voidÂ ProcessFill (Long64_t); Â This method is called for all selected entries. ; Â ; virtual voidÂ ResetAbort (); Â ; virtual voidÂ SetInputList (TList *input); Â ; virtual voidÂ SetObject (TObject *obj); Â ; virtual voidÂ SetOption (const char *option); Â ; virtual voidÂ SetStatus (Long64_t status); Â ; voidÂ Streamer (TBuffer &) overri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDraw.html:1516,Abort,Abort,1516,doc/master/classTProofDraw.html,https://root.cern,https://root.cern/doc/master/classTProofDraw.html,2,['Abort'],['Abort']
Safety,; Â Interface to ErrorHandler (protected). ; Â ; voidÂ MakeZombie (); Â . Protected Attributes; ROOT::R::TRFunctionImportÂ asfactor; Â ; Float_tÂ fCacheSize; Â ; Float_tÂ fCoef0; Â ; Float_tÂ fCost; Â ; Float_tÂ fCross; Â ; Int_tÂ fDegree; Â ; Float_tÂ fEpsilon; Â ; Bool_tÂ fFitted; Â ; Float_tÂ fGamma; Â ; TStringÂ fKernel; Â ; ROOT::R::TRObject *Â fModel; Â ; UInt_tÂ fMvaCounter; Â ; Float_tÂ fNu; Â ; Bool_tÂ fProbability; Â ; std::vector< Float_t >Â fProbResultForTestSig; Â ; std::vector< Float_t >Â fProbResultForTrainSig; Â ; Bool_tÂ fScale; Â ; Bool_tÂ fShrinking; Â ; Float_tÂ fTolerance; Â ; TStringÂ fType; Â ; ROOT::R::TRFunctionImportÂ predict; Â ; ROOT::R::TRFunctionImportÂ svm; Â ; Â Protected Attributes inherited from TMVA::RMethodBase; ROOT::R::TRDataFrameÂ fDfSpectators; Â ; ROOT::R::TRDataFrameÂ fDfTest; Â ; ROOT::R::TRDataFrameÂ fDfTrain; Â ; std::vector< std::string >Â fFactorTest; Â ; std::vector< std::string >Â fFactorTrain; Â ; TVectorDÂ fWeightTest; Â ; TVectorDÂ fWeightTrain; Â ; ROOT::R::TRInterface &Â r; Â ; Â Protected Attributes inherited from TMVA::MethodBase; Types::EAnalysisTypeÂ fAnalysisType; Â ; UInt_tÂ fBackgroundClass; Â ; boolÂ fExitFromTraining = false; Â ; std::vector< TString > *Â fInputVars; Â ; IPythonInteractive *Â fInteractive = nullptr; Â temporary dataset used when evaluating on a different data (used by MethodCategory::GetMvaValues) ; Â ; UInt_tÂ fIPyCurrentIter = 0; Â ; UInt_tÂ fIPyMaxIter = 0; Â ; std::vector< Float_t > *Â fMulticlassReturnVal; Â ; Int_tÂ fNbins; Â ; Int_tÂ fNbinsH; Â ; Int_tÂ fNbinsMVAoutput; Â ; Ranking *Â fRanking; Â ; std::vector< Float_t > *Â fRegressionReturnVal; Â ; Results *Â fResults; Â ; UInt_tÂ fSignalClass; Â ; DataSet *Â fTmpData = nullptr; Â temporary event when testing on a different DataSet than the own one ; Â ; const Event *Â fTmpEvent; Â ; Â Protected Attributes inherited from TMVA::Configurable; MsgLogger *Â fLogger; Â ! message logger ; Â ; Â Protected Attributes inherited from TNamed; TStringÂ fName; Â ; TStringÂ fTitle; Â . Static Protected Attributes; static Bool_tÂ IsModuleLoaded = ROOT::R:,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodRSVM.html:24671,predict,predict,24671,doc/master/classTMVA_1_1MethodRSVM.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodRSVM.html,1,['predict'],['predict']
Safety,"; Â MethodMLP (DataSetInfo &theData, const TString &theWeightFile); Â constructor from a weight file ; Â ; virtualÂ ~MethodMLP (); Â destructor nothing to be done ; Â ; Double_tÂ ComputeEstimator (std::vector< Double_t > &parameters); Â this function is called by GeneticANN for GA optimization ; Â ; Double_tÂ EstimatorFunction (std::vector< Double_t > &parameters); Â interface to the estimate ; Â ; Double_tÂ GetMvaValue (Double_t *err=nullptr, Double_t *errUpper=nullptr); Â get the mva value generated by the NN ; Â ; virtual Bool_tÂ HasAnalysisType (Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); Â MLP can handle classification with 2 classes and regression with one regression-target. ; Â ; boolÂ HasInverseHessian (); Â ; virtual TClass *Â IsA () const; Â ; virtual voidÂ Streamer (TBuffer &); Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; voidÂ Train (); Â ; Â Public Member Functions inherited from TMVA::MethodANNBase; Â MethodANNBase (const TString &jobName, Types::EMVA methodType, const TString &methodTitle, DataSetInfo &theData, const TString &theOption); Â standard constructor Note: Right now it is an option to choose the neuron input function, but only the input function ""sum"" leads to weight convergence â€“ otherwise the weights go to nan and lead to an ABORT. ; Â ; Â MethodANNBase (Types::EMVA methodType, DataSetInfo &theData, const TString &theWeightFile); Â construct the Method from the weight file ; Â ; virtualÂ ~MethodANNBase (); Â destructor ; Â ; voidÂ AddWeightsXMLTo (void *parent) const; Â create XML description of ANN classifier ; Â ; const Ranking *Â CreateRanking (); Â compute ranking of input variables by summing function of weights ; Â ; Bool_tÂ Debug () const; Â who the hell makes such strange Debug flags that even use ""global pointers"".. ; Â ; template<typename WriteIterator > ; voidÂ GetLayerActivation (size_t layer, WriteIterator writeIterator); Â ; virtual const std::vector< Float_t > &Â GetMulticlassValues (); Â get the multiclass classification ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:2900,ABORT,ABORT,2900,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['ABORT'],['ABORT']
Safety,"; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; Â Â kBitMask = 0x00ffffff. }; Â ; enum Â { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; Â ; enum Â EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); }; Â ; enum Â EStatusBits { ; Â Â kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ; Â Â kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; Â ; Â Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for allÂ cases; Â ; static Bool_tÂ DEPRECATED; Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â ; Â Protected Member Functions inherited from TGeoTubeSeg; voidÂ InitTrigonometry (); Â ; Â Protected Member Functions inherited from TGeoTube; Â TGeoTube (const TGeoTube &)=delete; Â ; TGeoTube &Â operator= (const TGeoTube &)=delete; Â ; Â Protected Member Functions inherited from TGeoBBox; Â TGeoBBox (const TGeoBBox &)=delete; Â ; voidÂ FillBuffer3D (TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) const override; Â Fill the supplied buffer, with sections in desired frame See TBuffer3D.h for explanation of sections, frame etc. ; Â ; TGeoBBox &Â operator= (const TGeoBBox &)=delete; Â ; Â Protected Member Functions inherited from TGeoShape; Int_tÂ GetBasicColor () const; Â Get the basic color (0-7). ; Â ; voidÂ SetOnBoundary (Bool_t); Â ; voidÂ TransformPoints (Double_t *points, UInt_t NbPoints) const; Â Tranform a set of points (LocalToMaster) ; Â ; Â Protected Member Functions inherited from TObject; virtual voidÂ DoError (int level, const char *location, const char *fmt, va_list va) const; Â Interface to ErrorHandler (protected). ; Â ; voidÂ MakeZombie (); Â . #include <TGeoTube.h>. Inheritance diagram for TGeoCtub:. This b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCtub.html:26882,detect,detection,26882,doc/master/classTGeoCtub.html,https://root.cern,https://root.cern/doc/master/classTGeoCtub.html,1,['detect'],['detection']
Safety,"; Â Same functionality as TGeoNavigator::FindNextDaughterBoundary for the parallel world. ; Â ; TGeoPhysicalNode *Â FindNodeBVH (Double_t point[3]); Â Finds physical node containing the point. ; Â ; TGeoPhysicalNode *Â FindNodeLoop (Double_t point[3]); Â Finds physical node containing the point using simple algorithm (for debugging) ; Â ; TGeoPhysicalNode *Â FindNodeOrig (Double_t point[3]); Â Finds physical node containing the point (original version based on TGeoVoxelFinder) ; Â ; std::pair< double, double >Â GetBVHSafetyCandidates (double point[3], std::vector< int > &candidates, double margin=0.) const; Â Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ; Â ; std::pair< double, double >Â GetLoopSafetyCandidates (double point[3], std::vector< int > &candidates, double margin=0.) const; Â Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ; Â ; voidÂ InitSafetyVoxel (TGeoVoxelGridIndex const &); Â Method to initialize the safety voxel at a specific 3D voxel (grid) index. ; Â ; Double_tÂ SafetyBVH (Double_t point[3], Double_t safmax=1.E30); Â Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ; Â ; Double_tÂ SafetyLoop (Double_t point[3], Double_t safmax=1.E30); Â Compute safety for the parallel world (trivial loop version for comparison/debugging) ; Â ; Double_tÂ SafetyOrig (Double_t point[3], Double_t safmax=1.E30); Â Compute safety for the parallel world (original version based on TGeoVoxelFinder) ; Â ; voidÂ TestVoxelGrid (); Â ; Double_tÂ VoxelSafety (Double_t point[3], Double_t safmax=1.E30); Â Compute safety for the parallel world used BVH structure with addiditional on-the-fly 3D grid/voxel caching â€”> essentially an O(1) algorithm !) ; Â . Additional Inherited Members; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â . #include <TGeoParallelWorld.h>. Inheritance diagram for TGeoP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:16103,safe,safety,16103,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['safe'],['safety']
Safety,"; Â Set a transparent marker color. ; Â ; virtual voidÂ SetMarkerSize (Size_t msize=1); Â Set the marker size. ; Â ; virtual voidÂ SetMarkerStyle (Style_t mstyle=1); Â Set the marker style. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â . Static Public Member Functions; static TClass *Â Class (); Â ; static const char *Â Class_Name (); Â ; static constexpr Version_tÂ Class_Version (); Â ; static const char *Â DeclFileName (); Â ; Â Static Public Member Functions inherited from TF1; static voidÂ AbsValue (Bool_t reject=kTRUE); Â Static function: set the fgAbsValue flag. ; Â ; static voidÂ CalcGaussLegendreSamplingPoints (Int_t num, Double_t *x, Double_t *w, Double_t eps=3.0e-11); Â Type safe interface (static method) The number of sampling points are taken from the TGraph. ; Â ; static TClass *Â Class (); Â ; static const char *Â Class_Name (); Â ; static constexpr Version_tÂ Class_Version (); Â ; static const char *Â DeclFileName (); Â ; static Bool_tÂ DefaultAddToGlobalList (Bool_t on=kTRUE); Â Static method to add/avoid to add automatically functions to the global list (gROOT->GetListOfFunctions() ) After having called this static method, all the functions created afterwards will follow the desired behaviour. ; Â ; static Double_tÂ DerivativeError (); Â Static function returning the error of the last call to the of Derivative's functions. ; Â ; static TF1 *Â GetCurrent (); Â Static function returning the current function being processed. ; Â ; static voidÂ InitStandardFunctions (); Â Create the basic function objects. ; Â ; static Bool_tÂ RejectedPoint (); Â See TF1::RejectPoint above. ; Â ; static voidÂ RejectPoint (Bool_t reject=kTRUE); Â Static function to set the global flag to reject points the fgRejectPoint global flag is tested by all fit functions if TRUE the point is not included in the fit. ; Â ; static voidÂ SetCurrent (TF1 *f1); Â Static function setting the current function. ; Â ; Â Static Public Member Functions inherited from TNamed; static TClass *Â Class (); Â ; static const char ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF12.html:32537,avoid,avoid,32537,doc/master/classTF12.html,https://root.cern,https://root.cern/doc/master/classTF12.html,2,['avoid'],['avoid']
Safety,"; Â TEventIterObj (TDSet *dset, TSelector *sel, Long64_t first, Long64_t num); Â Constructor. ; Â ; Â ~TEventIterObj () override; Â Destructor. ; Â ; Long64_tÂ GetCacheSize () override; Â ; Int_tÂ GetLearnEntries () override; Â ; Long64_tÂ GetNextEvent () override; Â Get next event. ; Â ; Int_tÂ GetNextPacket (Long64_t &first, Long64_t &num) override; Â Get loop range. ; Â ; TClass *Â IsA () const override; Â ; voidÂ Streamer (TBuffer &) override; Â Stream an object of class TObject. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; Â Public Member Functions inherited from TEventIter; Â TEventIter (); Â Default constructor. ; Â ; Â TEventIter (TDSet *dset, TSelector *sel, Long64_t first, Long64_t num); Â Constructor. ; Â ; Â ~TEventIter () override; Â Destructor. ; Â ; virtual Long64_tÂ GetEntryNumber (Long64_t); Â ; TList *Â GetPackets (); Â ; virtual voidÂ InvalidatePacket (); Â Invalidated the current packet (if any) by setting the TDSetElement::kCorrupted bit. ; Â ; virtual voidÂ StopProcess (Bool_t abort); Â Set flag to stop the process. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; Â Public Member Functions inherited from TObject; Â TObject (); Â TObject constructor. ; Â ; Â TObject (const TObject &object); Â TObject copy ctor. ; Â ; virtualÂ ~TObject (); Â TObject destructor. ; Â ; voidÂ AbstractMethod (const char *method) const; Â Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ; Â ; virtual voidÂ AppendPad (Option_t *option=""""); Â Append graphics object to current pad. ; Â ; virtual voidÂ Browse (TBrowser *b); Â Browse object. May be overridden for another default action. ; Â ; ULong_tÂ CheckedHash (); Â Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ; Â ; virtual const char *Â ClassName () const; Â Returns name of class to which the object belongs. ; Â ; virtual voidÂ Clear (Option_t *=""""); Â ; virtual TObject *Â Clone (const char *newname=""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEventIterObj.html:1419,abort,abort,1419,doc/master/classTEventIterObj.html,https://root.cern,https://root.cern/doc/master/classTEventIterObj.html,1,['abort'],['abort']
Safety,"; Â Â kInnerClass = 1<<3; , kInnedMostClass = 1<<4; , kDropStlDefault = 1<<5; , kDropComparator = 1<<6; , ; Â Â kDropAllDefault = 1<<7; , kLong64 = 1<<8; , kDropStd = 1<<9; , kKeepOuterConst = 1<<10; , ; Â Â kResolveTypedef = 1<<11; , kDropPredicate = 1<<12; , kDropHash = 1<<13. }; Â ; enum Â ESTLType { ; Â Â kNotSTL = ROOT::kNotSTL; , kVector = ROOT::kSTLvector; , kList = ROOT::kSTLlist; , kForwardlist = ROOT::kSTLforwardlist; , ; Â Â kDeque = ROOT::kSTLdeque; , kMap = ROOT::kSTLmap; , kMultiMap = ROOT::kSTLmultimap; , kSet = ROOT::kSTLset; , ; Â Â kMultiSet = ROOT::kSTLmultiset; , kUnorderedSet = ROOT::kSTLunorderedset; , kUnorderedMultiSet = ROOT::kSTLunorderedmultiset; , kUnorderedMap = ROOT::kSTLunorderedmap; , ; Â Â kUnorderedMultiMap = ROOT::kSTLunorderedmultimap; , kBitSet = ROOT::kSTLbitset; , kEnd = ROOT::kSTLend. }; Â . Functions; std::stringÂ CleanType (const char *typeDesc, int mode=0, const char **tail=nullptr); Â Cleanup type description, redundant blanks removed and redundant tail ignored return *tail = pointer to last used character if (mode==0) keep keywords if (mode==1) remove keywords outside the template params if (mode>=2) remove the keywords everywhere. ; Â ; char *Â DemangleName (const char *mangled_name, int &errorCode); Â ; char *Â DemangleTypeIdName (const std::type_info &ti, int &errorCode); Â Demangle in a portable way the type id name. ; Â ; EComplexTypeÂ GetComplexType (const char *); Â ; std::stringÂ GetLong64_Name (const char *original); Â Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. ; Â ; std::stringÂ GetLong64_Name (const std::string &original); Â Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'. ; Â ; std::stringÂ GetNameForIO (const std::string &templateInstanceName, TClassEdit::EModType mode=TClassEdit::kNone, bool *hasChanged=nullptr); Â ; voidÂ GetNormalizedName (std::string &norm_name, std::string_view name); Â Return the normalized name. ; Â ; intÂ GetSplit (const char *type, std::vector< std::string > &out",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTClassEdit.html:1600,redund,redundant,1600,doc/master/namespaceTClassEdit.html,https://root.cern,https://root.cern/doc/master/namespaceTClassEdit.html,2,['redund'],['redundant']
Safety,";; 100 void AddFileHandler(TFileHandler *fh) override;; 101 TFileHandler *RemoveFileHandler(TFileHandler *fh) override;; 102 ; 103 //---- Floating Point Exceptions Control --------------------; 104 Int_t GetFPEMask() override;; 105 Int_t SetFPEMask(Int_t mask = kDefaultMask) override;; 106 ; 107 //---- Time & Date ------------------------------------------; 108 TTime Now() override;; 109 void AddTimer(TTimer *ti) override;; 110 TTimer *RemoveTimer(TTimer *ti) override;; 111 void ResetTimer(TTimer *ti) override;; 112 Bool_t DispatchTimers(Bool_t mode);; 113 void Sleep(UInt_t milliSec) override;; 114 ; 115 //---- Processes --------------------------------------------; 116 Int_t Exec(const char *shellcmd) override;; 117 FILE *OpenPipe(const char *shellcmd, const char *mode) override;; 118 int ClosePipe(FILE *pipe) override;; 119 int GetPid() override;; 120 void StackTrace() override;; 121 ; 122 [[ noreturn ]] void Exit (int code, Bool_t mode = kTRUE) override;; 123 [[ noreturn ]] void Abort (int code = 0) override;; 124 ; 125 //---- Directories ------------------------------------------; 126 int MakeDirectory(const char *name) override;; 127 void *OpenDirectory(const char *name) override;; 128 void FreeDirectory(void *dirp) override;; 129 const char *GetDirEntry(void *dirp) override;; 130 Bool_t ChangeDirectory(const char *path) override;; 131 const char *WorkingDirectory() override;; 132 std::string GetWorkingDirectory() const override;; 133 const char *HomeDirectory(const char *userName = nullptr) override;; 134 std::string GetHomeDirectory(const char *userName = nullptr) const override;; 135 const char *TempDirectory() const override;; 136 FILE *TempFileName(TString &base, const char *dir = nullptr, const char *suffix = nullptr) override;; 137 ; 138 //---- Paths & Files ----------------------------------------; 139 const char *PrependPathName(const char *dir, TString& name) override;; 140 Bool_t ExpandPathName(TString &patbuf) override;; 141 char *ExpandPathName(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8h_source.html:5173,Abort,Abort,5173,doc/master/TUnixSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html,1,['Abort'],['Abort']
Safety,";; 30class TGeoHMatrix;; 31 ; 32class TGeoNavigator : public TObject {; 33 ; 34protected:; 35 TGeoNavigator(const TGeoNavigator &) = delete;; 36 TGeoNavigator &operator=(const TGeoNavigator &) = delete;; 37 TGeoNode *FindInCluster(Int_t *cluster, Int_t nc);; 38 Int_t GetTouchedCluster(Int_t start, Double_t *point, Int_t *check_list, Int_t ncheck, Int_t *result);; 39 TGeoNode *CrossDivisionCell();; 40 void SafetyOverlaps();; 41 ; 42private:; 43 Double_t fStep; //! step to be done from current point and direction; 44 Double_t fSafety; //! safety radius from current point; 45 Double_t fLastSafety; //! last computed safety radius; 46 Double_t fNormal[3]; //! cosine of incident angle on current checked surface; 47 Double_t fCldir[3]; //! unit vector to current closest shape; 48 Double_t fCldirChecked[3]; //! unit vector to current checked shape; 49 Double_t fPoint[3]; //! current point; 50 Double_t fDirection[3]; //! current direction; 51 Double_t fLastPoint[3]; //! last point for which safety was computed; 52 Double_t fLastPWSaftyPnt[3]; //! last point for which parallel world safety was ""evaluated""; 53 Double_t fLastPWSafety{-1}; //! last safety returned from parallel world (negative if invalid); 54 Int_t fThreadId; //! thread id for this navigator; 55 Int_t fLevel; //! current geometry level;; 56 Int_t fNmany; //! number of overlapping nodes on current branch; 57 Int_t fNextDaughterIndex; //! next daughter index after FindNextBoundary; 58 Int_t fOverlapSize; //! current size of fOverlapClusters; 59 Int_t fOverlapMark; //! current recursive position in fOverlapClusters; 60 Int_t *fOverlapClusters; //! internal array for overlaps; 61 Bool_t fSearchOverlaps; //! flag set when an overlapping cluster is searched; 62 Bool_t fCurrentOverlapping; //! flags the type of the current node; 63 Bool_t fStartSafe; //! flag a safe start for point classification; 64 Bool_t fIsEntering; //! flag if current step just got into a new node; 65 Bool_t fIsExiting; //! flag that current track ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:2108,safe,safety,2108,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safety']
Safety,";; 7506 return compRes == cling::Interpreter::kFailure;; 7507}; 7508 ; 7509////////////////////////////////////////////////////////////////////////////////; 7510/// Load the declarations from text into the interpreter.; 7511/// Note that this cannot be (top level) statements; text must contain; 7512/// top level declarations.; 7513/// Returns true on success, false on failure.; 7514 ; 7515Bool_t TCling::LoadText(const char* text) const; 7516{; 7517 return (fInterpreter->declare(text) == cling::Interpreter::kSuccess);; 7518}; 7519 ; 7520////////////////////////////////////////////////////////////////////////////////; 7521/// Interface to cling function; 7522 ; 7523const char* TCling::MapCppName(const char* name) const; 7524{; 7525 TTHREAD_TLS_DECL(std::string,buffer);; 7526 ROOT::TMetaUtils::GetCppName(buffer,name);; 7527 return buffer.c_str(); // NOLINT; 7528}; 7529 ; 7530////////////////////////////////////////////////////////////////////////////////; 7531/// [Place holder for Mutex Lock]; 7532/// Provide the interpreter with a way to; 7533/// acquire a lock used to protect critical section; 7534/// of its code (non-thread safe parts).; 7535 ; 7536void TCling::SetAlloclockfunc(void (* /* p */ )()) const; 7537{; 7538 // nothing to do for now.; 7539}; 7540 ; 7541////////////////////////////////////////////////////////////////////////////////; 7542/// [Place holder for Mutex Unlock] Provide the interpreter with a way to; 7543/// release a lock used to protect critical section; 7544/// of its code (non-thread safe parts).; 7545 ; 7546void TCling::SetAllocunlockfunc(void (* /* p */ )()) const; 7547{; 7548 // nothing to do for now.; 7549}; 7550 ; 7551////////////////////////////////////////////////////////////////////////////////; 7552/// Returns if class AutoLoading is currently enabled.; 7553 ; 7554bool TCling::IsClassAutoLoadingEnabled() const; 7555{; 7556 if (IsFromRootCling()); 7557 return false;; 7558 if (!fClingCallbacks); 7559 return false;; 7560 return fClingCall",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:294052,safe,safe,294052,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['safe'],['safe']
Safety,";; }; ; //write a Tree; TFile *hfile = new TFile(""clonesA_Event.root"",""RECREATE"",""Test TClonesArray"");; TTree *tree = new TTree(""clonesA_Event"",""An example of a ROOT tree"");; TUsrSevtData1 *event1 = new TUsrSevtData1();; TUsrSevtData2 *event2 = new TUsrSevtData2();; tree->Branch(""top1"",""TUsrSevtData1"",&event1,8000,99);; tree->Branch(""top2"",""TUsrSevtData2"",&event2,8000,99);; for (Int_t ev = 0; ev < 10; ev++) {; cout << ""event "" << ev << endl;; event1->SetEvent(ev);; event2->SetEvent(ev);; tree->Fill();; if (ev <3) tree->Show(ev);; }; tree->Write();; tree->Print();; delete hfile;; }; ; void clonesA_Event_r(); {; //read the Tree; TFile * hfile = new TFile(""clonesA_Event.root"");; TTree *tree = (TTree*)hfile->Get(""clonesA_Event"");; ; TUsrSevtData1 * event1 = 0;; TUsrSevtData2 * event2 = 0;; tree->SetBranchAddress(""top1"",&event1);; tree->SetBranchAddress(""top2"",&event2);; for (Int_t ev = 0; ev < 8; ev++) {; tree->Show(ev);; cout << ""Pileup event1: "" << event1->GetPileup() << endl;; cout << ""Pileup event2: "" << event2->GetPileup() << endl;; event1->Clear();; event2->Clear();; // gObjectTable->Print(); // detect possible memory leaks; }; delete hfile;; }; ; void clonesA_Event(bool /*secondrun*/) {; // Embedding this load inside the first run of the script is not yet; // supported in v6; // gROOT->ProcessLine("".L clonesA_Event.cxx+""); // compile shared lib; clonesA_Event_w(); // write the tree; clonesA_Event_r(); // read back the tree; }; ; #endif; s1#define s1(x)Definition RSha256.hxx:91; Int_tint Int_tDefinition RtypesCore.h:45; gROOT#define gROOTDefinition TROOT.h:406; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TMrbSubevent_Caen::Clearvoid Clear(Option_t *="""")Definition clonesA_Ev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/clonesA__Event_8C.html:2301,detect,detect,2301,doc/master/clonesA__Event_8C.html,https://root.cern,https://root.cern/doc/master/clonesA__Event_8C.html,1,['detect'],['detect']
Safety,"< "" absl = "" << fIntLen << "";"" << std::endl;; 605 ; 606 out << "" auto "" << name << "" = new TGeoMaterial(\"""" << GetName() << ""\"", a, z, density, radl, absl);"" << std::endl;; 607 out << "" "" << name << ""->SetIndex("" << GetIndex() << "");"" << std::endl;; 608 SetBit(TGeoMaterial::kMatSavePrimitive);; 609}; 610 ; 611////////////////////////////////////////////////////////////////////////////////; 612/// Get some default color related to this material.; 613 ; 614Int_t TGeoMaterial::GetDefaultColor() const; 615{; 616 Int_t id = 1 + gGeoManager->GetListOfMaterials()->IndexOf(this);; 617 return (2 + id % 6);; 618}; 619 ; 620////////////////////////////////////////////////////////////////////////////////; 621/// Get a pointer to the element this material is made of.; 622/// This second call is to avoid warnings to not call a virtual; 623/// method from the constructor; 624 ; 625TGeoElement *TGeoMaterial::GetElement() const; 626{; 627 if (fElement); 628 return fElement;; 629 TGeoElementTable *table = gGeoManager->GetElementTable();; 630 return table->GetElement(Int_t(fZ));; 631}; 632 ; 633////////////////////////////////////////////////////////////////////////////////; 634/// Get a pointer to the element this material is made of.; 635 ; 636TGeoElement *TGeoMaterial::GetElement(Int_t) const; 637{; 638 if (fElement); 639 return fElement;; 640 TGeoElementTable *table = gGeoManager->GetElementTable();; 641 return table->GetElement(Int_t(fZ));; 642}; 643 ; 644////////////////////////////////////////////////////////////////////////////////; 645/// Single interface to get element properties.; 646 ; 647void TGeoMaterial::GetElementProp(Double_t &a, Double_t &z, Double_t &w, Int_t); 648{; 649 a = fA;; 650 z = fZ;; 651 w = 1.;; 652}; 653 ; 654////////////////////////////////////////////////////////////////////////////////; 655/// Retrieve material index in the list of materials; 656 ; 657Int_t TGeoMaterial::GetIndex(); 658{; 659 if (fIndex >= 0); 660 return fIndex;; 661 TList *matlist = g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:21499,avoid,avoid,21499,doc/master/TGeoMaterial_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html,1,['avoid'],['avoid']
Safety,"< "" n-event variables "" << nVariables << "" expected input matrix "" << n1 << "" x "" << n2; 1918 << Endl;; 1919 }; 1920 } else {; 1921 if (n1*n2 != nVariables || n0 != batchSize) {; 1922 Log() << kFATAL << ""Input Event variable dimensions are not compatible with the built network architecture""; 1923 << "" n-event variables "" << nVariables << "" expected input tensor "" << n0 << "" x "" << n1 << "" x "" << n2; 1924 << Endl;; 1925 }; 1926 }; 1927 }; 1928 ; 1929 auto batch = testData.GetTensorBatch();; 1930 auto inputTensor = batch.GetInput();; 1931 ; 1932 auto xInput = batch.GetInput();; 1933 // make the prediction; 1934 deepNet.Prediction(yHat, xInput, fOutputFunction);; 1935 for (size_t i = 0; i < batchSize; ++i) {; 1936 double value = yHat(i,0);; 1937 mvaValues[ievt + i] = (TMath::IsNaN(value)) ? -999. : value;; 1938 }; 1939 }; 1940 else {; 1941 // case of remaining events: compute prediction by single event !; 1942 for (Long64_t i = ievt; i < lastEvt; ++i) {; 1943 Data()->SetCurrentEvent(i);; 1944 mvaValues[i] = GetMvaValue();; 1945 }; 1946 }; 1947 }; 1948 ; 1949 if (logProgress) {; 1950 Log() << kINFO; 1951 << ""Elapsed time for evaluation of "" << nEvents << "" events: ""; 1952 << timer.GetElapsedTime() << "" "" << Endl;; 1953 }; 1954 ; 1955 return mvaValues;; 1956}; 1957 ; 1958//////////////////////////////////////////////////////////////////////////; 1959/// Get the regression output values for a single event; 1960//////////////////////////////////////////////////////////////////////////; 1961const std::vector<Float_t> & TMVA::MethodDL::GetRegressionValues(); 1962{; 1963 ; 1964 FillInputTensor ();; 1965 ; 1966 // perform the network prediction; 1967 fNet->Prediction(*fYHat, fXInput, fOutputFunction);; 1968 ; 1969 size_t nTargets = DataInfo().GetNTargets();; 1970 R__ASSERT(nTargets == fYHat->GetNcols());; 1971 ; 1972 std::vector<Float_t> output(nTargets);; 1973 for (size_t i = 0; i < nTargets; i++); 1974 output[i] = (*fYHat)(0, i);; 1975 ; 1976 // ned to transform back output ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:77419,predict,prediction,77419,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['predict'],['prediction']
Safety,"< 0 && rc != -2) {; 1164 SysError(""DispatchOneEvent"", ""select: read error on %d"", fd);; 1165 fReadmask->Clr(fd);; 1166 }; 1167 }; 1168 if (fWritemask->IsSet(fd)) {; 1169 rc = UnixSelect(fd+1, nullptr, &t, 0);; 1170 if (rc < 0 && rc != -2) {; 1171 SysError(""DispatchOneEvent"", ""select: write error on %d"", fd);; 1172 fWritemask->Clr(fd);; 1173 }; 1174 }; 1175 t.Clr(fd);; 1176 }; 1177 }; 1178 }; 1179}; 1180 ; 1181////////////////////////////////////////////////////////////////////////////////; 1182/// Sleep milliSec milliseconds.; 1183 ; 1184void TUnixSystem::Sleep(UInt_t milliSec); 1185{; 1186 struct timeval tv;; 1187 ; 1188 tv.tv_sec = milliSec / 1000;; 1189 tv.tv_usec = (milliSec % 1000) * 1000;; 1190 ; 1191 select(0, nullptr, nullptr, nullptr, &tv);; 1192}; 1193 ; 1194////////////////////////////////////////////////////////////////////////////////; 1195/// Select on file descriptors. The timeout to is in millisec. Returns; 1196/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 1197/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 1198/// the errno has been reset and the method can be called again. Returns; 1199/// -4 in case the list did not contain any file handlers or file handlers; 1200/// with file descriptor >= 0.; 1201 ; 1202Int_t TUnixSystem::Select(TList *act, Long_t to); 1203{; 1204 Int_t rc = -4;; 1205 ; 1206 TFdSet rd, wr;; 1207 Int_t mxfd = -1;; 1208 TIter next(act);; 1209 TFileHandler *h = nullptr;; 1210 while ((h = (TFileHandler *) next())) {; 1211 Int_t fd = h->GetFd();; 1212 if (fd > -1) {; 1213 if (h->HasReadInterest()) {; 1214 rd.Set(fd);; 1215 mxfd = TMath::Max(mxfd, fd);; 1216 }; 1217 if (h->HasWriteInterest()) {; 1218 wr.Set(fd);; 1219 mxfd = TMath::Max(mxfd, fd);; 1220 }; 1221 h->ResetReadyMask();; 1222 }; 1223 }; 1224 if (mxfd > -1); 1225 rc = UnixSelect(mxfd+1, &rd, &wr, to);; 1226 ; 1227 // Set readiness bits; 1228 if (rc > 0) {; 1229 next.Reset();; 1230 while ((h = (TFileHandler *) next())) {; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:36685,timeout,timeout,36685,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['timeout'],['timeout']
Safety,"<=0 && valxmin > 0) valxmax = valxmin;; 294 else if (valxmin <=0 && valxmax <= 0) { valxmin = 1; valxmax = 1; }; 295 ; 296 double slope = std::log( valxmax/valxmin) / (xmax - xmin);; 297 double constant = std::log(valxmin) - slope * xmin;; 298 f1->SetParameters(constant, slope);; 299}; 300 ; 301 ; 302////////////////////////////////////////////////////////////////////////////////; 303/// Compute Initial values of parameters for a gaussian; 304/// derived from function H1InitGaus defined in TH1.cxx; 305 ; 306void InitGaus(const ROOT::Fit::BinData & data, TF1 * f1); 307{; 308 ; 309 static const double sqrtpi = 2.506628;; 310 ; 311 // - Compute mean value and RMS of the data; 312 unsigned int n = data.Size();; 313 if (n == 0) return;; 314 double sumx = 0;; 315 double sumx2 = 0;; 316 double allcha = 0;; 317 double valmax = 0;; 318 double rangex = data.Coords(n-1)[0] - data.Coords(0)[0];; 319 // to avoid binwidth = 0 set arbitrarly to 1; 320 double binwidth = 1;; 321 if ( rangex > 0) binwidth = rangex;; 322 double x0 = 0;; 323 for (unsigned int i = 0; i < n; ++ i) {; 324 double val;; 325 double x = *(data.GetPoint(i,val) );; 326 sumx += val*x;; 327 sumx2 += val*x*x;; 328 allcha += val;; 329 if (val > valmax) valmax = val;; 330 if (i > 0) {; 331 double dx = x - x0;; 332 if (dx < binwidth) binwidth = dx;; 333 }; 334 x0 = x;; 335 }; 336 ; 337 if (allcha <= 0) return;; 338 double mean = sumx/allcha;; 339 double rms = sumx2/allcha - mean*mean;; 340 ; 341 ; 342 if (rms > 0); 343 rms = std::sqrt(rms);; 344 else; 345 rms = binwidth*n/4;; 346 ; 347 ; 348 //if the distribution is really gaussian, the best approximation; 349 //is binwidx*allcha/(sqrtpi*rms); 350 //However, in case of non-gaussian tails, this underestimates; 351 //the normalisation constant. In this case the maximum value; 352 //is a better approximation.; 353 //We take the average of both quantities; 354 ; 355// printf(""valmax %f other %f bw %f allcha %f rms %f \n"",valmax, binwidth*allcha/(sqrtpi*rms),; 356// binwi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitInterface_8cxx_source.html:10616,avoid,avoid,10616,doc/master/HFitInterface_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitInterface_8cxx_source.html,1,['avoid'],['avoid']
Safety,"<string>fSystToFix; FILE*pFile. private:. stringfObsName; vector<std::string>fObsNameVec; vector<string>fPreprocessFunctions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HistoToWorkspaceFactoryFast(); {}. ~HistoToWorkspaceFactoryFast(). HistoToWorkspaceFactoryFast(string , string , vector<string> , double = 200, double = 20, int = 0, int = 6, TFile* = 0). string FilePrefixStr(string ). void ProcessExpectedHisto(TH1* hist, RooWorkspace* proto, string prefix, string productPrefix, string systTerm, double low, double high, int lowBin, int highBin). void AddMultiVarGaussConstraint(RooWorkspace* proto, string prefix, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins. void LinInterpWithConstraint(RooWorkspace* proto, TH1* nominal, vector<TH1*> lowHist, vector<TH1*> highHist, vector<string> sourceName, string prefix, string productPrefix, string systTerm, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins; require dimension >=1 or <=3. { fObsNameVec.push_back(fObsName); }. string AddNormFactor(RooWorkspace* , string& , string& , RooStats::HistFactory::EstimateSummary& , bool ). void AddEfficiencyTerms(RooWorkspace* proto, string prefix, string interpName, map<string,pair<double,double> > systMap, vector<string>& likelihoodTermNames, vector<string>& totSystTermNames); add variables for all the relative overall uncertainties we expect; range is set using defined macro (see top of the page); string range=""[0,-1,1]"";. void MakeTotalExpected(RooWorkspace* proto, string totName, string , string , int lowBin, int highBin, vector<string>& syst_x_expectedPrefixNames, vector<string>& normByNames); for ith bin calculate totN_i = lumi * sum_j expected_j * syst_j. void Ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html:9482,predict,predictions,9482,root/html532/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,https://root.cern,https://root.cern/root/html532/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,1,['predict'],['predictions']
Safety,"= """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoCone.html:2338,safe,safe,2338,root/html532/TGeoCone.html,https://root.cern,https://root.cern/root/html532/TGeoCone.html,1,['safe'],['safe']
Safety,"= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2727 of file TProof.cxx. â—†Â Collect() [3/4]. Int_t TProof::Collect ; (; TList *Â ; slaves, . Long_tÂ ; timeout = -1, . Int_tÂ ; endtype = -1, . Bool_tÂ ; deactonfail = kFALSEÂ . ). protected . Collect responses from the slave servers. ; Returns the number of slaves that responded. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2696 of file TProof.cxx. â—†Â Collect() [4/4]. Int_t TProof::Collect ; (; TMonitor *Â ; mon, . Long_tÂ ; timeout = -1, . Int_tÂ ; endtype = -1, . Bool_tÂ ; deactonfail = kFALSEÂ . ). private . Collect responses from the slave servers. ; Returns the number of messages received. Can be 0 if there are no active slaves. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. Collect also stops its execution from time to time to check for new workers in Dynamic Startup mode. ; Definition at line 2756 of file TProof.cxx. â—†Â CollectInputFrom(). Int_t TProof::CollectInputFrom ; (; TSocket *Â ; s, . Int_tÂ ; endtype = -1, . Bool_tÂ ; deactonfail = kFALSEÂ . ). private . Collect and analyze available input from socket s. ; Returns 0 on success, -1 if any failure occurs. ; Definition at line 3060 of file TProof.cxx. â—†Â CreateDrawFeedback(). TDrawFeedback * TProof::CreateDrawFeedback ; (; ). Draw feedback creation proxy. ; When accessed via TProof avoids link dependency on libProofPlayer. ; Definition at line 10094 of file TProof.cxx. â—†Â CreateMerger(). Bool_t TProof::CreateMerger ; (; TSlave *Â ; sl, . Int_tÂ ; portÂ . ). private . Create a new merger. ; Definition at line 4454 of file TProof.cxx. â—†Â CreateSlave(). TSlave * TProof::CreateSlave ; (; const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:78599,timeout,timeout,78599,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,3,['timeout'],['timeout']
Safety,"= 100;; const int maxepochs = 20;; ; int nTotEvts = nevts; // total events to be generated for signal or background; ; bool useKeras = true;; ; ; bool useTMVA_RNN = true;; bool useTMVA_DNN = true;; bool useTMVA_BDT = false;; ; std::vector<std::string> rnn_types = {""RNN"", ""LSTM"", ""GRU""};; std::vector<bool> use_rnn_type = {1, 1, 1};; if (use_type >=0 && use_type < 3) {; use_rnn_type = {0,0,0};; use_rnn_type[use_type] = 1;; }; bool useGPU = true; // use GPU for TMVA if available; ; #ifndef R__HAS_TMVAGPU; useGPU = false;; #ifndef R__HAS_TMVACPU; Warning(""TMVA_RNN_Classification"", ""TMVA is not build with GPU or CPU multi-thread support. Cannot use TMVA Deep Learning for RNN"");; useTMVA_RNN = false;; #endif; #endif; ; ; TString archString = (useGPU) ? ""GPU"" : ""CPU"";; ; bool writeOutputFile = true;; ; ; ; const char *rnn_type = ""RNN"";; ; #ifdef R__HAS_PYMVA; TMVA::PyMethodBase::PyInitialize();; #else; useKeras = false;; #endif; ; #ifdef R__USE_IMT; int num_threads = 4; // use max 4 threads; // switch off MT in OpenBLAS to avoid conflict with tbb; gSystem->Setenv(""OMP_NUM_THREADS"", ""1"");; ; // do enable MT running; if (num_threads >= 0) {; ROOT::EnableImplicitMT(num_threads);; }; #endif; ; TMVA::Config::Instance();; ; std::cout << ""Running with nthreads = "" << ROOT::GetThreadPoolSize() << std::endl;; ; TString inputFileName = ""time_data_t10_d30.root"";; ; bool fileExist = !gSystem->AccessPathName(inputFileName);; ; // if file does not exists create it; if (!fileExist) {; MakeTimeData(nTotEvts,ntime, ninput);; }; ; ; auto inputFile = TFile::Open(inputFileName);; if (!inputFile) {; Error(""TMVA_RNN_Classification"", ""Error opening input file %s - exit"", inputFileName.Data());; return;; }; ; ; std::cout << ""--- RNNClassification : Using input file: "" << inputFile->GetName() << std::endl;; ; // Create a ROOT output file where TMVA will store ntuples, histograms, etc.; TString outfileName(TString::Format(""data_RNN_%s.root"", archString.Data()));; TFile *outputFile = nullptr;; if (w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:61255,avoid,avoid,61255,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['avoid'],['avoid']
Safety,"= R();; 239 return tot == 0 ? *this : DisplacementVector2D(*this) / tot;; 240 }; 241 ; 242 // ------ Setting individual elements present in coordinate system ------; 243 ; 244 /**; 245 Change X - Cartesian2D coordinates only; 246 */; 247 DisplacementVector2D<CoordSystem, Tag>& SetX (Scalar a) {; 248 fCoordinates.SetX(a);; 249 return *this;; 250 }; 251 ; 252 /**; 253 Change Y - Cartesian2D coordinates only; 254 */; 255 DisplacementVector2D<CoordSystem, Tag>& SetY (Scalar a) {; 256 fCoordinates.SetY(a);; 257 return *this;; 258 }; 259 ; 260 ; 261 /**; 262 Change R - Polar2D coordinates only; 263 */; 264 DisplacementVector2D<CoordSystem, Tag>& SetR (Scalar a) {; 265 fCoordinates.SetR(a);; 266 return *this;; 267 }; 268 ; 269 ; 270 /**; 271 Change Phi - Polar2D coordinates; 272 */; 273 DisplacementVector2D<CoordSystem, Tag>& SetPhi (Scalar ang) {; 274 fCoordinates.SetPhi(ang);; 275 return *this;; 276 }; 277 ; 278 ; 279 ; 280 // ------ Operations combining two vectors ------; 281 // -- need to have the specialized version in order to avoid; 282 ; 283 /**; 284 Return the scalar (dot) product of two displacement vectors.; 285 It is possible to perform the product for any type of vector coordinates,; 286 but they must have the same coordinate system tag; 287 */; 288 template< class OtherCoords >; 289 Scalar Dot( const DisplacementVector2D<OtherCoords,Tag> & v) const {; 290 return X()*v.X() + Y()*v.Y();; 291 }; 292 /**; 293 Return the scalar (dot) product of two vectors.; 294 It is possible to perform the product for any classes; 295 implementing x() and y() member functions; 296 */; 297 template< class OtherVector >; 298 Scalar Dot( const OtherVector & v) const {; 299 return X()*v.x() + Y()*v.y();; 300 }; 301 ; 302 ; 303 ; 304 /**; 305 Self Addition with a displacement vector.; 306 */; 307 template <class OtherCoords>; 308 DisplacementVector2D & operator+=; 309 (const DisplacementVector2D<OtherCoords,Tag> & v) {; 310 SetXY( X() + v.X(), Y() + v.Y() );; 311 return *this;; 312 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2DisplacementVector2D_8h_source.html:8217,avoid,avoid,8217,doc/master/GenVector_2DisplacementVector2D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector2D_8h_source.html,1,['avoid'],['avoid']
Safety,"= TMath::Min(1.,(Double_t)iw/(Double_t)ih);; 4643 Double_t hndc = TMath::Min(1.,(Double_t)ih/(Double_t)iw);; 4644 Double_t rh = hndc/(Double_t)ih;; 4645 Double_t rw = wndc/(Double_t)iw;; 4646 Double_t x1ndc = (Double_t)ix1*rw;; 4647 Double_t y1ndc = (Double_t)iy1*rh;; 4648 Double_t x2ndc = (Double_t)ix2*rw;; 4649 Double_t y2ndc = (Double_t)iy2*rh;; 4650 ; 4651 // Ratios to convert user space in TRUE normalized space (NDC); 4652 Double_t rx1,ry1,rx2,ry2;; 4653 gPad->GetRange(rx1,ry1,rx2,ry2);; 4654 Double_t rx = (x2ndc-x1ndc)/(rx2-rx1);; 4655 Double_t ry = (y2ndc-y1ndc)/(ry2-ry1);; 4656 ; 4657 // The first part of the filled area is made of the graph points.; 4658 // Make sure that two adjacent points are different.; 4659 xf[0] = rx*(x[0]-rx1)+x1ndc;; 4660 yf[0] = ry*(y[0]-ry1)+y1ndc;; 4661 nf = 0;; 4662 for (i=1; i<n; i++) {; 4663 if (x[i]==x[i-1] && y[i]==y[i-1]) continue;; 4664 nf++;; 4665 xf[nf] = rx*(x[i]-rx1)+x1ndc;; 4666 if (xf[i]==xf[i-1]) xf[i] += 0.000001; // add an epsilon to avoid exact vertical lines.; 4667 yf[nf] = ry*(y[i]-ry1)+y1ndc;; 4668 }; 4669 ; 4670 // For each graph points a shifted points is computed to build up; 4671 // the second part of the filled area. First and last points are; 4672 // treated as special cases, outside of the loop.; 4673 if (xf[1]==xf[0]) {; 4674 a = TMath::PiOver2();; 4675 } else {; 4676 a = TMath::ATan((yf[1]-yf[0])/(xf[1]-xf[0]));; 4677 }; 4678 if (xf[0]<=xf[1]) {; 4679 xt[0] = xf[0]-w*TMath::Sin(a);; 4680 yt[0] = yf[0]+w*TMath::Cos(a);; 4681 } else {; 4682 xt[0] = xf[0]+w*TMath::Sin(a);; 4683 yt[0] = yf[0]-w*TMath::Cos(a);; 4684 }; 4685 ; 4686 if (xf[nf]==xf[nf-1]) {; 4687 a = TMath::PiOver2();; 4688 } else {; 4689 a = TMath::ATan((yf[nf]-yf[nf-1])/(xf[nf]-xf[nf-1]));; 4690 }; 4691 if (xf[nf]>=xf[nf-1]) {; 4692 xt[nf] = xf[nf]-w*TMath::Sin(a);; 4693 yt[nf] = yf[nf]+w*TMath::Cos(a);; 4694 } else {; 4695 xt[nf] = xf[nf]+w*TMath::Sin(a);; 4696 yt[nf] = yf[nf]-w*TMath::Cos(a);; 4697 }; 4698 ; 4699 Double_t xi0,yi0,xi1,yi1,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:164455,avoid,avoid,164455,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['avoid'],['avoid']
Safety,"= TVirtualTreePlayer::kMaxEntries; Â ; Â Protected Types inherited from TTree; enum Â ELockStatusBits { ; Â Â kFindBranch = (1ULL << ( 0 )); , kFindLeaf = (1ULL << ( 1 )); , kGetAlias = (1ULL << ( 2 )); , kGetBranch = (1ULL << ( 3 )); , ; Â Â kGetEntry = (1ULL << ( 4 )); , kGetEntryWithIndex = (1ULL << ( 5 )); , kGetFriend = (1ULL << ( 6 )); , kGetFriendAlias = (1ULL << ( 7 )); , ; Â Â kGetLeaf = (1ULL << ( 8 )); , kLoadTree = (1ULL << ( 9 )); , kPrint = (1ULL << ( 10 )); , kRemoveFriend = (1ULL << ( 11 )); , ; Â Â kSetBranchStatus = (1ULL << ( 12 )). }; Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â ; Â Protected Member Functions inherited from TTree; virtual TBranch *Â BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel); Â Same as TTree::Branch() with added check that addobj matches className. ; Â ; virtual TBranch *Â BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel); Â Same as TTree::Branch but automatic detection of the class name. ; Â ; virtual TBranch *Â BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel); Â ; virtual TBranch *Â BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel); Â Same as TTree::Branch but automatic detection of the class name. ; Â ; virtual TBranch *Â BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel); Â Same as TTree::Branch but automatic detection of the class name. ; Â ; virtual TBranch *Â BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel); Â Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ; Â ; virtual Int_tÂ CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHbookTree.html:46854,detect,detection,46854,doc/master/classTHbookTree.html,https://root.cern,https://root.cern/doc/master/classTHbookTree.html,1,['detect'],['detection']
Safety,"= col[11] = kRed - 10;; 2273 col[12] = kGray + 1;; 2274 col[13] = kBlue - 10;; 2275 col[14] = kOrange + 7;; 2276 col[16] = kYellow + 1;; 2277 col[20] = kYellow - 10;; 2278 col[24] = col[25] = col[26] = kBlue - 8;; 2279 col[29] = kOrange + 9;; 2280 col[79] = kOrange - 2;; 2281 ; 2282 TGeoVolume *vol;; 2283 TIter next(fVolumes);; 2284 while ((vol = (TGeoVolume *)next())) {; 2285 TGeoMedium *med = vol->GetMedium();; 2286 if (!med); 2287 continue;; 2288 TGeoMaterial *mat = med->GetMaterial();; 2289 Int_t matZ = (Int_t)mat->GetZ();; 2290 vol->SetLineColor(col[matZ]);; 2291 if (mat->GetDensity() < 0.1); 2292 vol->SetTransparency(60);; 2293 }; 2294}; 2295 ; 2296////////////////////////////////////////////////////////////////////////////////; 2297/// Compute safe distance from the current point. This represent the distance; 2298/// from POINT to the closest boundary.; 2299 ; 2300Double_t TGeoManager::Safety(Bool_t inside); 2301{; 2302 return GetCurrentNavigator()->Safety(inside);; 2303}; 2304 ; 2305////////////////////////////////////////////////////////////////////////////////; 2306/// Set volume attributes in G3 style.; 2307 ; 2308void TGeoManager::SetVolumeAttribute(const char *name, const char *att, Int_t val); 2309{; 2310 TGeoVolume *volume;; 2311 Bool_t all = kFALSE;; 2312 if (strstr(name, ""*"")); 2313 all = kTRUE;; 2314 Int_t ivo = 0;; 2315 TIter next(fVolumes);; 2316 TString chatt = att;; 2317 chatt.ToLower();; 2318 while ((volume = (TGeoVolume *)next())) {; 2319 if (strcmp(volume->GetName(), name) && !all); 2320 continue;; 2321 ivo++;; 2322 if (chatt.Contains(""colo"")); 2323 volume->SetLineColor(val);; 2324 if (chatt.Contains(""lsty"")); 2325 volume->SetLineStyle(val);; 2326 if (chatt.Contains(""lwid"")); 2327 volume->SetLineWidth(val);; 2328 if (chatt.Contains(""fill"")); 2329 volume->SetFillColor(val);; 2330 if (chatt.Contains(""seen"")); 2331 volume->SetVisibility(val);; 2332 }; 2333 TIter next1(fGVolumes);; 2334 while ((volume = (TGeoVolume *)next1())) {; 2335 if (strcmp(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:82680,Safe,Safety,82680,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,2,['Safe'],['Safety']
Safety,"= j;; 571}; 572 ; 573////////////////////////////////////////////////////////////////////////////////; 574/// Handle idle timeout. When this timer expires the registered idle command; 575/// will be executed by this routine and a signal will be emitted.; 576 ; 577void TApplication::HandleIdleTimer(); 578{; 579 if (!fIdleCommand.IsNull()); 580 ProcessLine(GetIdleCommand());; 581 ; 582 Emit(""HandleIdleTimer()"");; 583}; 584 ; 585////////////////////////////////////////////////////////////////////////////////; 586/// Handle exceptions (kSigBus, kSigSegmentationViolation,; 587/// kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; 588/// Specific TApplication implementations may want something different here.; 589 ; 590void TApplication::HandleException(Int_t sig); 591{; 592 if (TROOT::Initialized()) {; 593 if (gException) {; 594 gInterpreter->RewindDictionary();; 595 gInterpreter->ClearFileBusy();; 596 }; 597 if (fExitOnException == kExit); 598 gSystem->Exit(128 + sig);; 599 else if (fExitOnException == kAbort); 600 gSystem->Abort();; 601 else; 602 Throw(sig);; 603 }; 604 gSystem->Exit(128 + sig);; 605}; 606 ; 607////////////////////////////////////////////////////////////////////////////////; 608/// Set the exit on exception option. Setting this option determines what; 609/// happens in HandleException() in case an exception (kSigBus,; 610/// kSigSegmentationViolation, kSigIllegalInstruction or kSigFloatingException); 611/// is trapped. Choices are: kDontExit (default), kExit or kAbort.; 612/// Returns the previous value.; 613 ; 614TApplication::EExitOnException TApplication::ExitOnException(TApplication::EExitOnException opt); 615{; 616 EExitOnException old = fExitOnException;; 617 fExitOnException = opt;; 618 return old;; 619}; 620 ; 621/////////////////////////////////////////////////////////////////////////////////; 622/// The function generates and executes a command that loads the Doxygen URL in; 623/// a browser. It works for Mac, Windows and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:20503,Abort,Abort,20503,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['Abort'],['Abort']
Safety,"= kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const void* obj, const TClass* cl); Convert object of any class to xml structures; Return pointer on top xml element. void* XmlReadAny(XMLNodePointer_t node, void* obj, TClass** cl); Recreate object from xml structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. void WriteObject(const TObject* obj); Convert object into xml structures.; !!! Should be used only by TBufferXML itself.; Use ConvertToXML() methods to convert your object to xml; Redefined here to avoid gcc 3.x warning. TXMLStackObj* PushStack(XMLNodePointer_t current, Bool_t simple = kFALSE); add new level to xml stack. TXMLStackObj* PopStack(); remove one level from xml stack. TXMLStackObj* Stack(Int_t depth = 0); return xml stack object of specified depth. XMLNodePointer_t StackNode(); return pointer on current xml node. void ShiftStack(const char* info = 0); shift stack node to next. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0 no compression.; level = 1 minimal compression level but fast. level = 9 maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negativ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBufferXML.html:27037,avoid,avoid,27037,root/html530/TBufferXML.html,https://root.cern,https://root.cern/root/html530/TBufferXML.html,5,['avoid'],['avoid']
Safety,"= kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const void* obj, const TClass* cl); Convert object of any class to xml structures; Return pointer on top xml element. void* XmlReadAny(XMLNodePointer_t node, void* obj, TClass** cl); Recreate object from xml structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. void WriteObject(const TObject* obj); Convert object into xml structures.; !!! Should be used only by TBufferXML itself.; Use ConvertToXML() methods to convert your object to xml; Redefined here to avoid gcc 3.x warning. TXMLStackObj* PushStack(XMLNodePointer_t current, Bool_t simple = kFALSE); add new level to xml stack. TXMLStackObj* PopStack(); remove one level from xml stack. TXMLStackObj* Stack(Int_t depth = 0); return xml stack object of specified depth. XMLNodePointer_t StackNode(); return pointer on current xml node. void ShiftStack(const char* info = 0); shift stack node to next. void XmlWriteBlock(XMLNodePointer_t node); write binary data block from buffer to xml; this data can be produced only by direct call of TBuffer::WriteBuf() functions. void XmlReadBlock(XMLNodePointer_t node); read binary block of data from xml. Bool_t ProcessPointer(const void* ptr, XMLNodePointer_t node); Add ""ptr"" attribute to node, if ptr is null or; if ptr is pointer on object, which is already saved in buffer; Automatically add ""ref"" attribute to node, where referenced object is stored. void RegisterPointer(const void* ptr, XMLNodePointer_t node); Register p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferXML.html:25915,avoid,avoid,25915,root/html526/TBufferXML.html,https://root.cern,https://root.cern/root/html526/TBufferXML.html,2,['avoid'],['avoid']
Safety,"= kFALSE, Double_t* w = 0); Smooth data with Super smoother*-*-*-. Smooth the (x, y) values by Friedman's ``super smoother''. Arguments:; grin: graph for smoothing. span: the fraction of the observations in the span of the running lines; smoother, or 0 to choose this by leave-one-out cross-validation.; bass: controls the smoothness of the fitted curve.; Values of up to 10 indicate increasing smoothness.; isPeriodic: if TRUE, the x values are assumed to be in [0, 1]; and of period 1.; w: case weights. Details:; supsmu is a running lines smoother which chooses between three spans for; the lines. The running lines smoothers are symmetric, with k/2 data points; each side of the predicted point, and values of k as 0.5 * n, 0.2 * n and; 0.05 * n, where n is the number of data points. If span is specified,; a single smoother with span span * n is used. The best of the three smoothers is chosen by cross-validation for each; prediction. The best spans are then smoothed by a running lines smoother; and the final prediction chosen by linear interpolation. The FORTRAN code says: ``For small samples (n < 40) or if there are; substantial serial correlations between observations close in x - value,; then a prespecified fixed span smoother (span > 0) should be used.; Reasonable span values are 0.2 to 0.4.''. References:; Friedman, J. H. (1984) SMART User's Guide.; Laboratory for Computational Statistics,; Stanford University Technical Report No. 1. Friedman, J. H. (1984) A variable span scatterplot smoother.; Laboratory for Computational Statistics,; Stanford University Technical Report No. 5. void BDRsupsmu(Int_t n, Double_t* x, Double_t* y, Double_t* w, Int_t iper, Double_t span, Double_t alpha, Double_t* smo, Double_t* sc); Friedmannï¿½s super smoother *-*-*-*-*-. super smoother (Friedman, 1984). version 10/10/84. coded and copywrite (c) 1984 by:. Jerome H. Friedman; department of statistics; and; stanford linear accelerator center; stanford university. all rights reserved. input:;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphSmooth.html:11547,predict,prediction,11547,root/html528/TGraphSmooth.html,https://root.cern,https://root.cern/root/html528/TGraphSmooth.html,6,['predict'],['prediction']
Safety,"= nullptr;; 3221 } else {; 3222 renamed = branchClass && branchElem->GetNewClass() && (branchClass != branchElem->GetNewClass());; 3223 }; 3224 } else {; 3225 renamed = fTargetClass != fBranchClass;; 3226 }; 3227 if (!branchClass) {; 3228 Error(""InitializeOffsets"", ""Could not find class for branch: %s"", GetName());; 3229 fInitOffsets = true;; 3230 return;; 3231 }; 3232 ; 3233 //------------------------------------------------------------------------; 3234 // Extract the name of the STL branch in case it has been split.; 3235 //////////////////////////////////////////////////////////////////////////; 3236 ; 3237 TString stlParentName;; 3238 bool stlParentNameUpdated = false;; 3239 if( fType == 4 ); 3240 {; 3241 TBranch *br = GetMother()->GetSubBranch( this );; 3242 stlParentName = br->GetName();; 3243 stlParentName = stlParentName.Strip( TString::kTrailing, '.' );; 3244 ; 3245 // We may ourself contain the 'Mother' branch name.; 3246 // To avoid code duplication, we delegate the removal; 3247 // of the mother's name to the first sub-branch loop.; 3248 }; 3249 ; 3250 // Loop over our sub-branches and compute their offsets.; 3251 for (Int_t subBranchIdx = 0; subBranchIdx < nbranches; ++subBranchIdx) {; 3252 bool alternateElement = false;; 3253 ; 3254 fBranchOffset[subBranchIdx] = 0;; 3255 TBranchElement* subBranch = dynamic_cast<TBranchElement*> (fBranches[subBranchIdx]);; 3256 if (subBranch == nullptr) {; 3257 // -- Skip sub-branches that are not TBranchElements.; 3258 continue;; 3259 }; 3260 ; 3261 if (renamed) {; 3262 if (subBranch->fBranchClass == branchClass) {; 3263 if (branchElem) subBranch->SetTargetClass(branchElem->GetNewClass()->GetName());; 3264 else subBranch->SetTargetClass(fTargetClass->GetName());; 3265 }; 3266 }; 3267 ; 3268 TVirtualStreamerInfo* sinfo = subBranch->GetInfoImp();; 3269 if (!sinfo) {; 3270 Warning(""InitializeOffsets"", ""No streamer info for branch: %s subbranch: %s"", GetName(), subBranch->GetName());; 3271 fBranchOffset[subBranchIdx] = TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:116178,avoid,avoid,116178,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['avoid'],['avoid']
Safety,"= true;; 1567 TString path = gSystem->GetDirName(fFileName), com;; 1568 TObjString *objs = nullptr;; 1569 TIter nxr(xrl);; 1570 while ((objs = (TObjString *) nxr())) {; 1571 Int_t rc = 0;; 1572 if ((rc = GetCommonString(path, objs->GetString(), com)) != 2) {; 1573 TUrl ucom(com);; 1574 if (strlen(ucom.GetFile()) > 0 && strcmp(ucom.GetFile(), ""/"")) {; 1575 objs->SetString(com.Data());; 1576 newobjs = false;; 1577 break;; 1578 }; 1579 }; 1580 }; 1581 if (newobjs) xrl->Add(new TObjString(path));; 1582 ; 1583 // Done; 1584 nrl = xrl->GetSize();; 1585 if (notify) {; 1586 Printf("" * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ *"");; 1587 Printf("" * Entry-list: %s"", GetName());; 1588 Printf("" * %d common root paths found"", nrl);; 1589 nxr.Reset();; 1590 while ((objs = (TObjString *) nxr())) {; 1591 Printf("" * %s"", objs->GetName());; 1592 }; 1593 Printf("" * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ *"");; 1594 }; 1595 ; 1596 if (xrl != roots) {; 1597 xrl->SetOwner(true);; 1598 SafeDelete(xrl);; 1599 }; 1600 ; 1601 // Done; 1602 return nrl;; 1603}; 1604 ; 1605////////////////////////////////////////////////////////////////////////////////; 1606/// Scan TEntryList in 'fn' to find the common parts of paths.; 1607/// If 'roots' is defined, add the found roots to the list as TObjStrings.; 1608/// Return the number of common root paths found.; 1609 ; 1610Int_t TEntryList::Scan(const char *fn, TList *roots); 1611{; 1612 // Open the file for updating; 1613 TFile *fl = TFile::Open(fn);; 1614 if (!fl || (fl&& fl->IsZombie())) {; 1615 ::Error(""TEntryList::Relocate"", ""file '%s' cannot be open for reading"", fn);; 1616 return -1;; 1617 }; 1618 ; 1619 Int_t nrs = 0;; 1620 // Read the lists; 1621 TIter nxk(fl->GetListOfKeys());; 1622 TKey *key = nullptr;; 1623 while ((key = (TKey *) nxk())) {; 1624 if (!strcmp(key->GetClassName(), ""TEntryList"")) {; 1625 TEntryList *enl = dynamic_cast<TEntryList *>(fl->Get(key->GetName()));; 1626 if (enl) {; 1627 nrs += enl->Sca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEntryList_8cxx_source.html:53291,Safe,SafeDelete,53291,doc/master/TEntryList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,"=(const TIterator&) const; Bool_toperator!=(const TTreeFriendLeafIter&) const; TObject*TIterator::operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator& rhs); TTreeFriendLeafIter&operator=(const TTreeFriendLeafIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TTreeFriendLeafIter(). Data Members; protected:. Bool_tfDirectioniteration direction; TIterator*fLeafItercurrent leaf sub-iterator.; TTree*fTreetree being iterated; TIterator*fTreeItercurrent tree sub-iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeFriendLeafIter(const TTree* t, Bool_t dir = kIterForward); Create a new iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. TTreeFriendLeafIter(const TTreeFriendLeafIter& iter); Copy constructor. Does NOT copy the 'cursor' location!. TIterator& operator=(const TIterator& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TTreeFriendLeafIter& operator=(const TTreeFriendLeafIter& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TObject* Next(); Go the next friend element. Option_t* GetOption() const; Returns the object option stored in the list. void Reset(Option_t* option = """"). TTreeFriendLeafIter(); { }. ~TTreeFriendLeafIter(); { SafeDelete(fLeafIter); SafeDelete(fTreeIter); }. const TCollection * GetCollection() const; { return 0; }. TObject * operator*() const; TODO: Implement me. Â» Author: Rene Brun 12/01/96 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/tree:$Id$ Â» Last generated: 2015-05-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeFriendLeafIter.html:2296,Safe,SafeDelete,2296,root/html534/TTreeFriendLeafIter.html,https://root.cern,https://root.cern/root/html534/TTreeFriendLeafIter.html,2,['Safe'],['SafeDelete']
Safety,"=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; ... (remaining 14 messages suppressed); ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=-3.35967 cHl3=-9.58704 cHq3=-6.27461; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:13955,recover,recover,13955,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,"=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; ... (remaining 14 messages suppressed); ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=-3.35967 cHl3=-9.58704 cHq3=-6.27461; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:13836,recover,recover,13836,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,"=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; ... (remaining 14 messages suppressed); ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=-3.35967 cHl3=-9.58704 cHq3=-6.27461; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:13717,recover,recover,13717,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,"=========================; Total params: 577820 (2.20 MB); Trainable params: 577800 (2.20 MB); Non-trainable params: 20 (80.00 Byte); _________________________________________________________________; Factory : Booking method: â›[1mPyKerasâ›[0m; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Loading Keras Model ; : Loaded model from file: model_cnn.h5; Factory : Booking method: â›[1mPyTorchâ›[0m; : ; : Using PyTorch - setting special configuration options ; : Using PyTorch version 2; : Setup PyTorch Model for training; : Executing user initialization code from /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/tmva/PyTorch_Generate_CNN_Model.py; running Torch code defining the model....; The PyTorch CNN model is created and saved as PyTorchModelCNN.pt; : Loaded pytorch train function: ; : Loaded pytorch optimizer: ; : Loaded pytorch loss function: ; : Loaded pytorch predict function: ; : Loaded model from file: PyTorchModelCNN.pt; Factory : â›[1mTrain all methodsâ›[0m; Factory : Train method: BDT for Classification; : ; BDT : #events: (reweighted) sig: 800 bkg: 800; : #events: (unweighted) sig: 800 bkg: 800; : Training 200 Decision Trees ... patience please; : Elapsed time for training with 1600 events: 0.877 sec ; BDT : [dataset] : Evaluation of BDT on training sample (1600 events); : Elapsed time for evaluation of 1600 events: 0.0172 sec ; : Creating xml weight file: â›[0;36mdataset/weights/TMVA_CNN_Classification_BDT.weights.xmlâ›[0m; : Creating standalone class: â›[0;36mdataset/weights/TMVA_CNN_Classification_BDT.class.Câ›[0m; : TMVA_CNN_ClassificationOutput.root:/dataset/Method_BDT/BDT; Factory : Training finished; : ; Factory : Train method: TMVA_DNN_CPU for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 8 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:9262,predict,predict,9262,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['predict'],['predict']
Safety,"=> 'i' (paper); 'par' <=> 'j' (paper). Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> describing the data <n>. Since <m> is unknown, the data distribution is; used instead,; lambda = L(y;n) / L(n;n).; Note that this ratio is 1 if the fit is perfect. The chi2 value is then; computed according to; chi2 = -2*ln(lambda).; This parameter can be shown to follow a Chi-square distribution. See for; example S. Baker and R. Cousins, ""Clarification of the use of chi-square; and likelihood functions in fits to histograms"", Nucl. Instr. Meth. A221,; pp. 437-442 (1984). Int_t GetNDF() const; return the number of degrees of freedom in the fit; the fNDF parameter has been previously computed during a fit.; The number of degrees of freedom corresponds to the number of points; used in the fit minus the number of templates. Double_t GetProb() const; return the fit probability. void ComputeChisquareLambda(); Method used internally to compute the likelihood ratio chi2; See the function GetChisquare() for details. TH1* GetMCPrediction(Int_t parm) const; Return the adjusted MC template (Aji) for template (parm).; Note that the (Aji) times fractions only sum to the total prediction; of the fit if all weights are 1.; Note also that the histogram is managed by the TFractionFitter class, so the returned pointer will be invalid if; the class is deleted. TFractionFitter(). Double_t EvaluateFCN(const Double_t* par); FCN evaluation. Â» Last changed: root/hist:$Id$ Â» Last generated: 2015-06-02 15:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFractionFitter.html:20415,predict,prediction,20415,root/html604/TFractionFitter.html,https://root.cern,https://root.cern/root/html604/TFractionFitter.html,1,['predict'],['prediction']
Safety,"=> 'i' (paper); 'par' <=> 'j' (paper). Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> describing the data <n>. Since <m> is unknown, the data distribution is; used instead,; lambda = L(y;n) / L(n;n).; Note that this ratio is 1 if the fit is perfect. The chi2 value is then; computed according to; chi2 = -2*ln(lambda).; This parameter can be shown to follow a Chi-square distribution. See for; example S. Baker and R. Cousins, ""Clarification of the use of chi-square; and likelihood functions in fits to histograms"", Nucl. Instr. Meth. A221,; pp. 437-442 (1984). Int_t GetNDF() const; return the number of degrees of freedom in the fit; the fNDF parameter has been previously computed during a fit.; The number of degrees of freedom corresponds to the number of points; used in the fit minus the number of templates. Double_t GetProb() const; return the fit probability. void ComputeChisquareLambda(); Method used internally to compute the likelihood ratio chi2; See the function GetChisquare() for details. TH1* GetMCPrediction(Int_t parm) const; Return the adjusted MC template (Aji) for template (parm).; Note that the (Aji) times fractions only sum to the total prediction; of the fit if all weights are 1.; Note also that the histogram is managed by the TFractionFitter class, so the returned pointer will be invalid if; the class is deleted. TFractionFitter(). Double_t EvaluateFCN(const Double_t* par); FCN evaluation. Â» Last changed: root/hist:$Id$ Â» Last generated: 2015-06-30 14:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFractionFitter.html:20415,predict,prediction,20415,root/html602/TFractionFitter.html,https://root.cern,https://root.cern/root/html602/TFractionFitter.html,1,['predict'],['prediction']
Safety,"> // for make_shared, allocator, shared_ptr; 27#include <ostream> // ostringstream; 28#include <stdexcept>; 29#include <string>; 30#include <vector>; 31 ; 32// clang-format off; 33/**; 34* \class ROOT::RDataFrame; 35* \ingroup dataframe; 36* \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python.; 37 ; 38In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; 39on their machines completely transparently.<br>; 40Skip to the [class reference](#reference) or keep reading for the user guide.; 41 ; 42In a nutshell:; 43~~~{.cpp}; 44ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; 45ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; 46auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; 47myHisto->Draw(); // Event loop is run here, upon first access to a result; 48~~~; 49 ; 50Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; 51care of their execution. The implementation automatically puts in place several low level optimisations such as; 52multi-thread parallelization and caching.; 53 ; 54\htmlonly; 55<a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; 56alt=""DOI""></a>; 57\endhtmlonly; 58 ; 59## For the impatient user; 60You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python.; 61 ; 62## Table of Contents; 63- [Cheat sheet](\ref cheatsheet); 64- [Introduction](\ref introduction); 65- [Crash course](\ref crash-course); 66- [Working with collections](\ref collections); 67- [Transformations: manipulating data](\ref transformations); 68- [Actions: getting results](\ref actions); 69- [Distributed execution in Python](\ref distrdf); 70- [Perf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:2202,safe,safe,2202,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,2,['safe'],['safe']
Safety,"> = 0>; 441 RInterface<Proxied, DS_t> Define(std::string_view name, F expression, const ColumnNames_t &columns = {}); 442 {; 443 return DefineImpl<F, RDFDetail::ExtraArgsForDefine::None>(name, std::move(expression), columns, ""Define"");; 444 }; 445 // clang-format on; 446 ; 447 // clang-format off; 448 ////////////////////////////////////////////////////////////////////////////; 449 /// \brief Define a new column with a value dependent on the processing slot.; 450 /// \param[in] name The name of the defined column.; 451 /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; 452 /// \param[in] columns Names of the columns/branches in input to the producer function (excluding the slot number).; 453 /// \return the first node of the computation graph for which the new quantity is defined.; 454 ///; 455 /// This alternative implementation of `Define` is meant as a helper to evaluate new column values in a thread-safe manner.; 456 /// The expression must be a callable of signature R(unsigned int, T1, T2, ...) where `T1, T2...` are the types; 457 /// of the columns that the expression takes as input. The first parameter is reserved for an unsigned integer; 458 /// representing a ""slot number"". RDataFrame guarantees that different threads will invoke the expression with; 459 /// different slot numbers - slot numbers will range from zero to ROOT::GetThreadPoolSize()-1.; 460 ///; 461 /// The following two calls are equivalent, although `DefineSlot` is slightly more performant:; 462 /// ~~~{.cpp}; 463 /// int function(unsigned int, double, double);; 464 /// df.Define(""x"", function, {""rdfslot_"", ""column1"", ""column2""}); 465 /// df.DefineSlot(""x"", function, {""column1"", ""column2""}); 466 /// ~~~; 467 ///; 468 /// See Define() for more information.; 469 template <typename F>; 470 RInterface<Proxied, DS_t> DefineSlot(std::string_view name, F expressi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:22750,safe,safe,22750,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['safe'],['safe']
Safety,"> fServer! central communication with the all used displaysDefinition RWebWindowsManager.hxx:41; ROOT::RWebWindowsManager::SetLoopbackModestatic void SetLoopbackMode(bool on=true)Set loopback mode for THttpServer used for web widgets By default is on.Definition RWebWindowsManager.cxx:128; ROOT::RWebWindowsManager::IsMainThrdstatic bool IsMainThrd()Returns true when called from main process Main process recognized at the moment when library is load...Definition RWebWindowsManager.cxx:104; ROOT::RWebWindowsManager::Instancestatic std::shared_ptr< RWebWindowsManager > & Instance()Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel.Definition RWebWindowsManager.cxx:78; ROOT::RWebWindowsManager::InformListenerbool InformListener(const std::string &msg)If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket.Definition RWebWindowsManager.cxx:227; ROOT::RWebWindowsManager::fLaunchTmoutfloat fLaunchTmout! timeout in seconds to start browser process, default 30sDefinition RWebWindowsManager.hxx:49; ROOT::RWebWindowsManager::GetUrlstd::string GetUrl(RWebWindow &win, bool remote=false, std::string *produced_key=nullptr)Provide URL address to access specified window from inside or from remote.Definition RWebWindowsManager.cxx:600; ROOT::RWebWindowsManager::Unregistervoid Unregister(RWebWindow &win)Release all references to specified window Called from RWebWindow destructor.Definition RWebWindowsManager.cxx:591; ROOT::RWebWindowsManager::IsLoopbackModestatic bool IsLoopbackMode()Returns true if loopback mode used by THttpServer for web widgets.Definition RWebWindowsManager.cxx:146; ROOT::RWebWindowsManager::CreateWindowstd::shared_ptr< RWebWindow > CreateWindow()Creates new window To show window, RWebWindow::Show() have to be called.Definition RWebWindowsManager.cxx:536; TExecTExec is a utility class that can be used to execute a C++ command when some event happens in a pad.Definition TExec.h:26; THtt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html:11087,timeout,timeout,11087,doc/v632/RWebWindowsManager_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html,1,['timeout'],['timeout']
Safety,"> fServer! central communication with the all used displaysDefinition RWebWindowsManager.hxx:45; ROOT::RWebWindowsManager::SetLoopbackModestatic void SetLoopbackMode(bool on=true)Set loopback mode for THttpServer used for web widgets By default is on.Definition RWebWindowsManager.cxx:129; ROOT::RWebWindowsManager::IsMainThrdstatic bool IsMainThrd()Returns true when called from main process Main process recognized at the moment when library is load...Definition RWebWindowsManager.cxx:105; ROOT::RWebWindowsManager::Instancestatic std::shared_ptr< RWebWindowsManager > & Instance()Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel.Definition RWebWindowsManager.cxx:79; ROOT::RWebWindowsManager::InformListenerbool InformListener(const std::string &msg)If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket.Definition RWebWindowsManager.cxx:299; ROOT::RWebWindowsManager::fLaunchTmoutfloat fLaunchTmout! timeout in seconds to start browser process, default 30sDefinition RWebWindowsManager.hxx:53; ROOT::RWebWindowsManager::GetServerLocationsstatic std::map< std::string, std::string > GetServerLocations()Returns server locations as <std::string, std::string> Key is location name (with slash at the end) a...Definition RWebWindowsManager.cxx:209; ROOT::RWebWindowsManager::GetUrlstd::string GetUrl(RWebWindow &win, bool remote=false, std::string *produced_key=nullptr)Provide URL address to access specified window from inside or from remote.Definition RWebWindowsManager.cxx:686; ROOT::RWebWindowsManager::Unregistervoid Unregister(RWebWindow &win)Release all references to specified window Called from RWebWindow destructor.Definition RWebWindowsManager.cxx:674; ROOT::RWebWindowsManager::IsLoopbackModestatic bool IsLoopbackMode()Returns true if loopback mode used by THttpServer for web widgets.Definition RWebWindowsManager.cxx:147; ROOT::RWebWindowsManager::CreateWindowstd::shared_ptr< RWebWindow > Create",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html:12586,timeout,timeout,12586,doc/master/RWebWindowsManager_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html,1,['timeout'],['timeout']
Safety,">Add(run);; The first parameter of the Add method is a pointer to a TTask, the second parameter is the string to show in the browser. If the string is left out, the name of the task is used.; After executing, the script above the browser will look like in this figure.; 10.5 Execute and Debug Tasks; The browser can be used to start a task, set break points at the beginning of a task or when the task has completed. At a breakpoint, data structures generated by the execution up this point may be inspected asynchronously and then the execution can be resumed by selecting the â€œContinueâ€ function of a task.; A task may be active or inactive (controlled by TTask::SetActive). When a task is inactive, its sub tasks are not executed. A task tree may be made persistent, saving the status of all the tasks.; 11 Input/Output. This chapter covers the saving and reading of objects to and from ROOT files. It begins with an explanation of the physical layout of a ROOT file. It includes a discussion on compression, and file recovery. Then we explain the logical file, the class TFile and its methods. We show how to navigate in a file, how to save objects and read them back. We also include a discussion on Streamers. Streamers are the methods responsible to capture an objects current state to save it to disk or send it over the network. At the end of the chapter is a discussion on the two specialized ROOT files: TNetFile and TWebFile.; 11.1 The Physical Layout of ROOT Files; A ROOT file is like a UNIX file directory. It can contain directories and objects organized in unlimited number of levels. It also is stored in machine independent format (ASCII, IEEE floating point, Big Endian byte ordering). To look at the physical layout of a ROOT file, we first create one. This example creates a ROOT file and 15 histograms, fills each histogram with 1000 entries from a Gaussian distribution, and writes them to the file.; {; char name[10], title[20];; TObjArray Hlist(0); // create an array of His",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:429126,recover,recovery,429126,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['recover'],['recovery']
Safety,">GetYaxis()->SetTitle( var1 );; ; frameS->SetLabelSize( 0.04, ""X"" );; frameS->SetLabelSize( 0.04, ""Y"" );; frameS->SetTitleSize( 0.05, ""X"" );; frameS->SetTitleSize( 0.05, ""Y"" );; ; // and plot; frameS->Draw();; frameB->Draw( ""same"" );; ; // Draw legend; TLegend *legend = new TLegend( 1 - c->GetRightMargin() - 0.32, 1 - c->GetTopMargin() - 0.12,; 1 - c->GetRightMargin(), 1 - c->GetTopMargin() );; legend->SetFillStyle( 1 );; legend->AddEntry(frameS,""Signal"",""p"");; legend->AddEntry(frameB,""Background"",""p"");; legend->Draw(""same"");; legend->SetBorderSize(1);; legend->SetMargin( 0.3 );; ; }; ; TMatrixD* produceSqrtMat( const TMatrixD& covMat ); {; Double_t sum = 0;; Int_t size = covMat.GetNrows();;; TMatrixD* sqrtMat = new TMatrixD( size, size );; ; for (Int_t i=0; i< size; i++) {; ; sum = 0;; for (Int_t j=0;j< i; j++) sum += (*sqrtMat)(i,j) * (*sqrtMat)(i,j);; ; (*sqrtMat)(i,i) = TMath::Sqrt(TMath::Abs(covMat(i,i) - sum));; ; for (Int_t k=i+1 ;k<size; k++) {; ; sum = 0;; for (Int_t l=0; l<i; l++) sum += (*sqrtMat)(k,l) * (*sqrtMat)(i,l);; ; (*sqrtMat)(k,i) = (covMat(k,i) - sum) / (*sqrtMat)(i,i);; ; }; }; return sqrtMat;; }; ; void getGaussRnd( TArrayD& v, const TMatrixD& sqrtMat, TRandom& R ); {; // generate ""size"" correlated Gaussian random numbers; ; // sanity check; const Int_t size = sqrtMat.GetNrows();; if (size != v.GetSize()); cout << ""<getGaussRnd> too short input vector: "" << size << "" "" << v.GetSize() << endl;; ; Double_t* tmpVec = new Double_t[size];; ; for (Int_t i=0; i<size; i++) {; Double_t x, y, z;; y = R.Rndm();; z = R.Rndm();; x = 2*TMath::Pi()*z;; tmpVec[i] = TMath::Sin(x) * TMath::Sqrt(-2.0*TMath::Log(y));; }; ; for (Int_t i=0; i<size; i++) {; v[i] = 0;; for (Int_t j=0; j<=i; j++) v[i] += sqrtMat(i,j) * tmpVec[j];; }; ; delete[] tmpVec;; }; ; // create the data; void create_lin_Nvar_withFriend(Int_t N = 2000); {; const Int_t nvar = 4;; const Int_t nvar2 = 1;; Float_t xvar[nvar];; ; // output file; TFile* dataFile = TFile::Open( ""data.root"", ""RECREATE"" ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/createData_8C.html:3664,sanity check,sanity check,3664,doc/master/createData_8C.html,https://root.cern,https://root.cern/doc/master/createData_8C.html,1,['sanity check'],['sanity check']
Safety,"AKE_BUILD_TYPE: allow highest level of optimisation of the GCC and Clang compilers (-Ofast).; Support ccache activation with cmake configuration switch.; Support link to jemalloc and tcmalloc allocators.; Careful suppression of known and understood warnings, e.g.Â coming from external packages. Patch Releases; Release 6.04/02; Platform Support. Added support for Intel icc 15. Build System. Define ROOT_XXX_FLAGS in ROOTConfig.cmake for use by client packages ROOT-7401; Enabled c++14 in CLING when compiling ROOT with c++14 enabled (CMake: -Dcxx14=ON, classic: â€“enable-cxx14). Dictionary Generation. Uniform style of warnings, use standard ROOT logging facilities rather than cout/cerr.; Do not add as autoparse keys stl classes, stl (nested) containers templated with plain old data or integers. Core. Fixed support for dictionary for class with inlined namespace.; Do not treat Mac OSXâ€™s â€œcl_kernelsâ€ dylinker entry as a library ROOT-7436. TDirectory::TContext. Fixed a thread safety issue in TMVA by updating TDirectory::TContext.; We added a default constructor to TDirectory::TContext which record the current directory and will restore it at destruction time and does not change the current directory.; The constructor for TDirectory::TContext that takes a single TDirectory pointer as an argument was changed to set gDirectory to zero when being passed a null pointer; previously it was interpreting a null pointer as a request to not change the current directory - this behavior is now implement by the default constructor. I/O. Fix the issue described at ROOT-7500 : crash due to change in base class which versioned derived class. Proof. Add support for aliases ROOT-7392; Fix issue with trees in sub-directories causing stressProof test #29 to fail. Interpreter. Fix unloading of code ROOT-7290; Fix template instantiations in cling internals ROOT-7364; Forget erroneous decls in case of errors ROOT-7295; Work around binutils issue (ld crash building llvm) on MacOSX with GCC (pull requ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:25983,safe,safety,25983,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['safe'],['safety']
Safety,"ALSE); virtual voidShowData(); voidTProof::ShowDataSet(const char* dataset = """", const char* opt = ""filter:SsCc""); virtual voidShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* = 0); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector&); voidTProof::ShowMissingFiles(TQueryResult* qr = 0); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual voidTProof::ShowStagingStatusDataSet(const char* dataset, const char* optStr = ""filter:SsCc""); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char*, TList*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadDataSet(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadDataSetFromFile(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar, TList* workers = 0); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* uri, const char* = 0); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:18533,abort,abort,18533,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,1,['abort'],['abort']
Safety,"ARS. Composite shapes may be used.; 2. gGeoManager->SetClippingShape(clip1);; One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);. Perform ray-tracing:gGeoManager->GetTopVolume()->Raytrace();. One can redo the steps 2-3 as many times as needed. Let us look how the rootgeom example looks clipped with a tube. Ray-tracing example with box-clipping. 18.8 Representing Misalignments of the Ideal Geometry; The ideal positioning of a detector does not match its position in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information.; 18.8.1 Physical Nodes; Physical nodes are the actual â€œtouchableâ€ objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 106-109, therefore it is impossible to create all physical nodes as objects in memory. In TGeo, physical nodes are represented by the class TGeoPhysicalNode and can be created on demand for alignment purposes:; TGeoPhysicalNode(const char* path); The knowledge of the path to the objects that need to be misaligned is essential since there is no other way of identifying them. One can however create â€œsymbolic linksâ€ to any complex path to make it more representable for the object it desig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1013547,Detect,Detector,1013547,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Detect'],['Detector']
Safety,"AbsArg &testArgÂ const { return observableOverlaps(depList, testArg); Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â ; Â Static Protected Member Functions inherited from RooAbsReal; static voidÂ globalSelectComp (bool flag); Â Global switch controlling the activation of the selectComp() functionality. ; Â ; Â Static Protected Member Functions inherited from RooAbsArg; static voidÂ ioStreamerPass2Finalize (); Â Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ; Â ; Â Static Protected Attributes inherited from RooAbsHiddenReal; static RooCategory *Â _dummyBlindState = nullptr; Â ; Â Static Protected Attributes inherited from RooAbsReal; static boolÂ _globalSelectComp = false; Â ; static boolÂ _hideOffset = true; Â Offset hiding flag. ; Â ; Â Static Protected Attributes inherited from RooAbsArg; static boolÂ _inhibitDirty; Â ; static boolÂ _verboseDirty; Â cache of the list of proxies. Avoids type casting. ; Â ; Â Static Protected Attributes inherited from RooPrintable; static Int_tÂ _nameLength; Â . #include <RooUnblindCPAsymVar.h>. Inheritance diagram for RooUnblindCPAsymVar:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. â—†Â RooUnblindCPAsymVar() [1/4]. RooUnblindCPAsymVar::RooUnblindCPAsymVar ; (; ). Default constructor. ; Definition at line 40 of file RooUnblindCPAsymVar.cxx. â—†Â RooUnblindCPAsymVar() [2/4]. RooUnblindCPAsymVar::RooUnblindCPAsymVar ; (; const char *Â ; name, . const char *Â ; title, . const char *Â ; blindString, . RooAbsReal &Â ; cpasymÂ . ). Constructor from a given RooAbsReal (to hold the blind value) and a set of blinding parameters. ; Definition at line 47 of file RooUnblindCPAsymVar.cxx. â—†Â RooUnblindCPAsymVar() [3/4]. RooUnblindCPAsymVar::RooUnblindCPAsymVar ; (; const char *Â ; name, . const char *Â ; title, . const char *Â ; blindString, . RooAbsReal &Â ; cpasym, . RooAbsCate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooUnblindCPAsymVar.html:62028,Avoid,Avoids,62028,doc/master/classRooUnblindCPAsymVar.html,https://root.cern,https://root.cern/doc/master/classRooUnblindCPAsymVar.html,1,['Avoid'],['Avoids']
Safety,"AbsArg &testArgÂ const { return observableOverlaps(depList, testArg); Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â ; Â Static Protected Member Functions inherited from RooAbsReal; static voidÂ globalSelectComp (bool flag); Â Global switch controlling the activation of the selectComp() functionality. ; Â ; Â Static Protected Member Functions inherited from RooAbsArg; static voidÂ ioStreamerPass2Finalize (); Â Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ; Â ; Â Static Protected Attributes inherited from RooAbsHiddenReal; static RooCategory *Â _dummyBlindState = nullptr; Â ; Â Static Protected Attributes inherited from RooAbsReal; static boolÂ _globalSelectComp = false; Â ; static boolÂ _hideOffset = true; Â Offset hiding flag. ; Â ; Â Static Protected Attributes inherited from RooAbsArg; static boolÂ _inhibitDirty; Â ; static boolÂ _verboseDirty; Â cache of the list of proxies. Avoids type casting. ; Â ; Â Static Protected Attributes inherited from RooPrintable; static Int_tÂ _nameLength; Â . #include <RooUnblindOffset.h>. Inheritance diagram for RooUnblindOffset:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. â—†Â RooUnblindOffset() [1/4]. RooUnblindOffset::RooUnblindOffset ; (; ). default . â—†Â RooUnblindOffset() [2/4]. RooUnblindOffset::RooUnblindOffset ; (; const char *Â ; name, . const char *Â ; title, . const char *Â ; blindString, . doubleÂ ; scale, . RooAbsReal &Â ; blindValueÂ . ). Constructor from a given RooAbsReal (to hold the blind value) and a set of blinding parameters. ; Definition at line 40 of file RooUnblindOffset.cxx. â—†Â RooUnblindOffset() [3/4]. RooUnblindOffset::RooUnblindOffset ; (; const char *Â ; name, . const char *Â ; title, . const char *Â ; blindString, . doubleÂ ; scale, . RooAbsReal &Â ; blindValue, . RooAbsCategory &Â ; blindStateÂ . ). Constructor from a given RooAbsReal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooUnblindOffset.html:61929,Avoid,Avoids,61929,doc/master/classRooUnblindOffset.html,https://root.cern,https://root.cern/doc/master/classRooUnblindOffset.html,1,['Avoid'],['Avoids']
Safety,"AbsArg &testArgÂ const { return observableOverlaps(depList, testArg); Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â ; Â Static Protected Member Functions inherited from RooAbsReal; static voidÂ globalSelectComp (bool flag); Â Global switch controlling the activation of the selectComp() functionality. ; Â ; Â Static Protected Member Functions inherited from RooAbsArg; static voidÂ ioStreamerPass2Finalize (); Â Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ; Â ; Â Static Protected Attributes inherited from RooAbsHiddenReal; static RooCategory *Â _dummyBlindState = nullptr; Â ; Â Static Protected Attributes inherited from RooAbsReal; static boolÂ _globalSelectComp = false; Â ; static boolÂ _hideOffset = true; Â Offset hiding flag. ; Â ; Â Static Protected Attributes inherited from RooAbsArg; static boolÂ _inhibitDirty; Â ; static boolÂ _verboseDirty; Â cache of the list of proxies. Avoids type casting. ; Â ; Â Static Protected Attributes inherited from RooPrintable; static Int_tÂ _nameLength; Â . #include <RooUnblindPrecision.h>. Inheritance diagram for RooUnblindPrecision:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. â—†Â RooUnblindPrecision() [1/4]. RooUnblindPrecision::RooUnblindPrecision ; (; ). default . â—†Â RooUnblindPrecision() [2/4]. RooUnblindPrecision::RooUnblindPrecision ; (; const char *Â ; name, . const char *Â ; title, . const char *Â ; blindString, . doubleÂ ; centralValue, . doubleÂ ; scale, . RooAbsReal &Â ; blindValue, . boolÂ ; sin2betaMode = falseÂ . ). Constructor from a given RooAbsReal (to hold the blind value) and a set of blinding parameters. ; Definition at line 40 of file RooUnblindPrecision.cxx. â—†Â RooUnblindPrecision() [3/4]. RooUnblindPrecision::RooUnblindPrecision ; (; const char *Â ; name, . const char *Â ; title, . const char *Â ; blindString, . doubleÂ ; centralValue, . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooUnblindPrecision.html:62054,Avoid,Avoids,62054,doc/master/classRooUnblindPrecision.html,https://root.cern,https://root.cern/doc/master/classRooUnblindPrecision.html,1,['Avoid'],['Avoids']
Safety,"AbsArg &testArgÂ const { return observableOverlaps(depList, testArg); Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â ; Â Static Protected Member Functions inherited from RooAbsReal; static voidÂ globalSelectComp (bool flag); Â Global switch controlling the activation of the selectComp() functionality. ; Â ; Â Static Protected Member Functions inherited from RooAbsArg; static voidÂ ioStreamerPass2Finalize (); Â Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ; Â ; Â Static Protected Attributes inherited from RooAbsHiddenReal; static RooCategory *Â _dummyBlindState = nullptr; Â ; Â Static Protected Attributes inherited from RooAbsReal; static boolÂ _globalSelectComp = false; Â ; static boolÂ _hideOffset = true; Â Offset hiding flag. ; Â ; Â Static Protected Attributes inherited from RooAbsArg; static boolÂ _inhibitDirty; Â ; static boolÂ _verboseDirty; Â cache of the list of proxies. Avoids type casting. ; Â ; Â Static Protected Attributes inherited from RooPrintable; static Int_tÂ _nameLength; Â . #include <RooUnblindUniform.h>. Inheritance diagram for RooUnblindUniform:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. â—†Â RooUnblindUniform() [1/3]. RooUnblindUniform::RooUnblindUniform ; (; ). default . â—†Â RooUnblindUniform() [2/3]. RooUnblindUniform::RooUnblindUniform ; (; const char *Â ; name, . const char *Â ; title, . const char *Â ; blindString, . doubleÂ ; scale, . RooAbsReal &Â ; blindValueÂ . ). Constructor from a given RooAbsReal (to hold the blinded value) and a set of blinding parameters. ; Parameters. nameName of this transformation ; titleTitle (for plotting) ; blindStringString to initialise the random generator ; scaleScale the offset. High values make the blinding more violent. ; blindValueThe parameter to be blinded. After the fit, this parameter will only hold the blinded values. . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooUnblindUniform.html:61751,Avoid,Avoids,61751,doc/master/classRooUnblindUniform.html,https://root.cern,https://root.cern/doc/master/classRooUnblindUniform.html,1,['Avoid'],['Avoids']
Safety,"Adj[i]/closeAdj[i-1];; ; return *r;; }; ; #ifndef __MAKECINT__; //---------------------------------------------------------------------------; TVectorD OptimalInvest(Double_t riskFactor,TVectorD r,TMatrixDSym Covar); {; // what the quadratic programming package will do:; //; // minimize c^T x + ( 1/2 ) x^T Q x; // subject to A x = b; // clo <= C x <= cup; // xlo <= x <= xup; // what we want :; //; // maximize c^T x - k ( 1/2 ) x^T Q x; // subject to sum_x x_i = 1; // 0 <= x_i; ; // We have nrStocks weights to determine,; // 1 equality- and 0 inequality- equations (the simple square boundary; // condition (xlo <= x <= xup) does not count); ; const Int_t nrVar = nrStocks;; const Int_t nrEqual = 1;; const Int_t nrInEqual = 0;; ; // flip the sign of the objective function because we want to maximize; TVectorD c = -1.*r;; TMatrixDSym Q = riskFactor*Covar;; ; // equality equation; TMatrixD A(nrEqual,nrVar); A = 1;; TVectorD b(nrEqual); b = 1;; ; // inequality equation; //; // - although not applicable in the current situation since nrInEqual = 0, one; // has to specify not only clo and cup but also an index vector iclo and icup,; // whose values are either 0 or 1 . If iclo[j] = 1, the lower boundary condition; // is active on x[j], etc. ...; ; TMatrixD C (nrInEqual,nrVar);; TVectorD clo (nrInEqual);; TVectorD cup (nrInEqual);; TVectorD iclo(nrInEqual);; TVectorD icup(nrInEqual);; ; // simple square boundary condition : 0 <= x_i, so only xlo is relevant .; // Like for clo and cup above, we have to define an index vector ixlo and ixup .; // Since each variable has the lower boundary, we can set the whole vector; // ixlo = 1; ; TVectorD xlo (nrVar); xlo = 0;; TVectorD xup (nrVar); xup = 0;; TVectorD ixlo(nrVar); ixlo = 1;; TVectorD ixup(nrVar); ixup = 0;; ; // setup the quadratic programming problem . Since a small number of variables are; // involved and ""Q"" has everywhere entries, we chose the dense version ""TQpProbDens"" .; // In case of a sparse formulation, simply replace",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:8332,risk,riskFactor,8332,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,1,['risk'],['riskFactor']
Safety,"AlwaysDirty' mode for this node. ; Â ; const TNamed *Â _namePtr = nullptr; Â Pointer to global cache manager for any expensive components created by this object. ; Â ; OperModeÂ _operMode = Auto; Â ; RooArgSet *Â _ownedComponents = nullptr; Â ; boolÂ _prohibitServerRedirect = false; Â Set of owned component. ; Â ; RooRefArrayÂ _proxyList; Â ; ProxyListCacheÂ _proxyListCache; Â ; RefCountList_tÂ _serverList; Â ; boolÂ _shapeDirty = true; Â ; std::map< std::string, std::string >Â _stringAttrib; Â ; boolÂ _valueDirty = true; Â ; Â Protected Attributes inherited from TNamed; TStringÂ fName; Â ; TStringÂ fTitle; Â . Static Protected Attributes; static TStringÂ _normRangeOverride; Â ; static Int_tÂ _verboseEval = 0; Â ; Â Static Protected Attributes inherited from RooAbsReal; static boolÂ _globalSelectComp = false; Â ; static boolÂ _hideOffset = true; Â Offset hiding flag. ; Â ; Â Static Protected Attributes inherited from RooAbsArg; static boolÂ _inhibitDirty; Â ; static boolÂ _verboseDirty; Â cache of the list of proxies. Avoids type casting. ; Â ; Â Static Protected Attributes inherited from RooPrintable; static Int_tÂ _nameLength; Â . Private Member Functions; std::unique_ptr< RooDataSet >Â generate (RooAbsGenContext &context, const RooArgSet &whatVars, const RooDataSet *prototype, double nEvents, bool verbose, bool randProtoOrder, bool resampleProto, bool skipInit=false, bool extended=false) const; Â Internal method. ; Â ; voidÂ logBatchComputationErrors (std::span< const double > &outputs, std::size_t begin) const; Â Scan through outputs and fix+log all nans and negative values. ; Â ; virtual RooPlot *Â paramOn (RooPlot *frame, const RooArgSet &params, bool showConstants=false, const char *label="""", double xmin=0.65, double xmax=0.99, double ymax=0.95, const RooCmdArg *formatCmd=nullptr); Â Add a text box with the current parameter values and their errors to the frame. ; Â ; voidÂ setActiveNormSet (RooArgSet const *normSet) const; Â Setter for the _normSet member, which should never be set directly. ; Â ; boolÂ traceEvalPdf (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:78208,Avoid,Avoids,78208,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['Avoid'],['Avoids']
Safety,"Application has been created; 183 gSystem->NotifyApplicationCreated();; 184 ; 185 fAppImp = gGuiFactory->CreateApplicationImp(appClassName, argc, argv);; 186 ResetBit(kProcessRemotely);; 187 ; 188 // Initialize the graphics environment; 189 if (gClassTable->GetDict(""TPad"")) {; 190 fgGraphNeeded = kTRUE;; 191 InitializeGraphics(gROOT->IsWebDisplay());; 192 }; 193 ; 194 // Save current interpreter context; 195 gInterpreter->SaveContext();; 196 gInterpreter->SaveGlobalsContext();; 197 ; 198 // to allow user to interact with TCanvas's under WIN32; 199 gROOT->SetLineHasBeenProcessed();; 200 ; 201 //Needs to be done last; 202 gApplication = this;; 203 gROOT->SetApplication(this);; 204 ; 205}; 206 ; 207////////////////////////////////////////////////////////////////////////////////; 208/// TApplication dtor.; 209 ; 210TApplication::~TApplication(); 211{; 212 for (int i = 0; i < fArgc; i++); 213 if (fArgv[i]) delete [] fArgv[i];; 214 delete [] fArgv;; 215 ; 216 if (fgApplications); 217 fgApplications->Remove(this);; 218 ; 219 // Reduce the risk of the files or sockets being closed after the; 220 // end of 'main' (or more exactly before the library start being; 221 // unloaded).; 222 if (fgApplications == nullptr || fgApplications->FirstLink() == nullptr ) {; 223 TROOT::ShutDown();; 224 }; 225 ; 226 // Now that all the canvases and files have been closed we can; 227 // delete the implementation.; 228 SafeDelete(fAppImp);; 229}; 230 ; 231////////////////////////////////////////////////////////////////////////////////; 232/// Static method. This method should be called from static library; 233/// initializers if the library needs the low level graphics system.; 234 ; 235void TApplication::NeedGraphicsLibs(); 236{; 237 fgGraphNeeded = kTRUE;; 238}; 239 ; 240////////////////////////////////////////////////////////////////////////////////; 241/// Initialize the graphics environment.; 242/// If @param only_web is specified, only web-related part of graphics is loaded; 243 ; 244voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:7729,risk,risk,7729,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['risk'],['risk']
Safety,"Architecture_t::PrintTensor(deepNet.GetLayerAt(0)->GetWeightsAt(1), ""Inference: state weights"");; 1866 // }; 1867 }; 1868 ; 1869 size_t n1 = deepNet.GetBatchHeight();; 1870 size_t n2 = deepNet.GetBatchWidth();; 1871 size_t n0 = deepNet.GetBatchSize();; 1872 // treat case where batchHeight is the batchSize in case of first Dense layers (then we need to set to fNet batch size); 1873 if (batchDepth == 1 && GetInputHeight() == 1 && GetInputDepth() == 1) {; 1874 n1 = deepNet.GetBatchSize();; 1875 n0 = 1;; 1876 }; 1877 //this->SetBatchDepth(n0);; 1878 Long64_t nEvents = lastEvt - firstEvt;; 1879 TMVAInput_t testTuple = std::tie(GetEventCollection(Data()->GetCurrentType()), DataInfo());; 1880 TensorDataLoader_t testData(testTuple, nEvents, batchSize, {inputDepth, inputHeight, inputWidth}, {n0, n1, n2}, deepNet.GetOutputWidth(), 1);; 1881 ; 1882 ; 1883 // Tensor_t xInput;; 1884 // for (size_t i = 0; i < n0; ++i); 1885 // xInput.emplace_back(Matrix_t(n1,n2));; 1886 ; 1887 // create pointer to output matrix used for the predictions; 1888 Matrix_t yHat(deepNet.GetBatchSize(), deepNet.GetOutputWidth() );; 1889 ; 1890 // use timer; 1891 Timer timer( nEvents, GetName(), kTRUE );; 1892 ; 1893 if (logProgress); 1894 Log() << kHEADER << Form(""[%s] : "",DataInfo().GetName()); 1895 << ""Evaluation of "" << GetMethodName() << "" on ""; 1896 << (Data()->GetCurrentType() == Types::kTraining ? ""training"" : ""testing""); 1897 << "" sample ("" << nEvents << "" events)"" << Endl;; 1898 ; 1899 ; 1900 // eventg loop; 1901 std::vector<double> mvaValues(nEvents);; 1902 ; 1903 ; 1904 for ( Long64_t ievt = firstEvt; ievt < lastEvt; ievt+=batchSize) {; 1905 ; 1906 Long64_t ievt_end = ievt + batchSize;; 1907 // case of batch prediction for; 1908 if (ievt_end <= lastEvt) {; 1909 ; 1910 if (ievt == firstEvt) {; 1911 Data()->SetCurrentEvent(ievt);; 1912 size_t nVariables = GetEvent()->GetNVariables();; 1913 ; 1914 if (n1 == batchSize && n0 == 1) {; 1915 if (n2 != nVariables) {; 1916 Log() << kFATAL << ""Input Even",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:75474,predict,predictions,75474,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['predict'],['predictions']
Safety,"ArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder)Utility function for createRunningIntegral that construct an object implementing the numeric scanning...Definition RooAbsReal.cxx:3810; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const char *rangeName) constCreate integral over observables in iset in range named rangeName.Definition RooAbsReal.h:207; RooAbsReal::defaultErrorLevelvirtual double defaultErrorLevel() constDefinition RooAbsReal.h:248; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret function value.Definition RooAbsReal.cxx:3360; RooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:37786,sanity check,sanity check,37786,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,2,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"Array(const Float_t arr[16]); Set matrix from Float_t array. void SetupRotation(Int_t i, Int_t j, Double_t f); Setup the matrix as an elementary rotation.; Optimized versions of left/right multiplication with an elementary; rotation matrix are implemented in RotatePF/RotateLF.; Expects identity matrix. void SetupFromToVec(const TEveVector& from, const TEveVector& to); A function for creating a rotation matrix that rotates a vector called; ""from"" into another vector called ""to"".; Input : from[3], to[3] which both must be *normalized* non-zero vectors; Output: mtx[3][3] -- a 3x3 matrix in colum-major form; Authors: Tomas Mï¿½ller, John Hughes; ""Efficiently Building a Matrix to Rotate One Vector to Another""; Journal of Graphics Tools, 4(4):1-4, 1999. void MultLeft(const TEveTrans& t); Multiply from left: this = t * this. void MultRight(const TEveTrans& t); Multiply from right: this = this * t. TEveTrans operator*(const TEveTrans& t); Copy, multiply from right and return product.; Avoid unless necessary. void TransposeRotationPart(); Transpose 3x3 rotation sub-matrix. void MoveLF(Int_t ai, Double_t amount); Move in local-frame along axis with index ai. void Move3LF(Double_t x, Double_t y, Double_t z); General move in local-frame. void RotateLF(Int_t i1, Int_t i2, Double_t amount); Rotate in local frame. Does optimised version of MultRight. void MovePF(Int_t ai, Double_t amount); Move in parent-frame along axis index ai. void Move3PF(Double_t x, Double_t y, Double_t z); General move in parent-frame. void RotatePF(Int_t i1, Int_t i2, Double_t amount); Rotate in parent frame. Does optimised version of MultLeft. void Move(const TEveTrans& a, Int_t ai, Double_t amount); Move in a's coord-system along axis-index ai. void Move3(const TEveTrans& a, Double_t x, Double_t y, Double_t z); General move in a's coord-system. void Rotate(const TEveTrans& a, Int_t i1, Int_t i2, Double_t amount); Rotate in a's coord-system, rotating base vector with index i1; into i2. void SetBaseVec(Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveTrans.html:11121,Avoid,Avoid,11121,root/html528/TEveTrans.html,https://root.cern,https://root.cern/root/html528/TEveTrans.html,6,['Avoid'],['Avoid']
Safety,"Assembly.h. â—†Â NeedsBBoxRecompute(). void TGeoShapeAssembly::NeedsBBoxRecompute ; (; ). inline . Definition at line 55 of file TGeoShapeAssembly.h. â—†Â RecomputeBoxLast(). void TGeoShapeAssembly::RecomputeBoxLast ; (; ). Recompute bounding box of the assembly after adding a node. ; Definition at line 114 of file TGeoShapeAssembly.cxx. â—†Â Safety(). Double_t TGeoShapeAssembly::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . computes the closest distance from given point to this shape, according to option. ; The matching point on the shape is stored in spoint. ; Reimplemented from TGeoBBox.; Definition at line 476 of file TGeoShapeAssembly.cxx. â—†Â Safety_v(). void TGeoShapeAssembly::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Compute safe distance from each of the points in the input array. ; Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values ; Reimplemented from TGeoBBox.; Definition at line 617 of file TGeoShapeAssembly.cxx. â—†Â SavePrimitive(). void TGeoShapeAssembly::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Definition at line 542 of file TGeoShapeAssembly.cxx. â—†Â SetPoints() [1/2]. void TGeoShapeAssembly::SetPoints ; (; Double_t *Â ; points); const. overridevirtual . No mesh for assemblies. ; Reimplemented from TGeoBBox.; Definition at line 547 of file TGeoShapeAssembly.cxx. â—†Â SetPoints() [2/2]. void TGeoShapeAssembly::SetPoints ; (; Float_t *Â ; points); const. overridevirtual . No mesh for assemblies. ; Reimplemented from TGeoBBox.; Definition at line 555 of file TGeoShapeAssembly.cxx. â—†Â SetSegsAndPols(). void TGeoShapeAssembly::SetSegsAndPols ; (; TBuffer3D &Â ; buff); const. overridevirtual . Fill TBuffer3D structure for segments and poly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShapeAssembly.html:30869,Safe,Safety,30869,doc/master/classTGeoShapeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoShapeAssembly.html,1,['Safe'],['Safety']
Safety,"AsyncOpen(expandedUrl, opts, ftitle, compress, netopt);; 4146 // Check the result in steps of 1 millisec; 4147 TFile::EAsyncOpenStatus aos = TFile::kAOSNotAsync;; 4148 aos = TFile::GetAsyncOpenStatus(fh);; 4149 Int_t xtms = toms;; 4150 while (aos == TFile::kAOSInProgress && xtms > 0) {; 4151 gSystem->Sleep(1);; 4152 xtms -= 1;; 4153 aos = TFile::GetAsyncOpenStatus(fh);; 4154 }; 4155 if (aos == TFile::kAOSNotAsync || aos == TFile::kAOSSuccess) {; 4156 // Do open the file now; 4157 f = TFile::Open(fh);; 4158 if (gDebug > 0) {; 4159 if (aos == TFile::kAOSSuccess); 4160 ::Info(""TFile::Open"", ""waited %d millisec for asynchronous open"", toms - xtms);; 4161 else; 4162 ::Info(""TFile::Open"", ""timeout option not supported (requires asynchronous""; 4163 "" open support)"");; 4164 }; 4165 } else {; 4166 if (xtms <= 0); 4167 ::Error(""TFile::Open"", ""timeout expired while opening '%s'"", expandedUrl.Data());; 4168 // Cleanup the request; 4169 SafeDelete(fh);; 4170 }; 4171 // Done; 4172 return f;; 4173 } else {; 4174 ::Warning(""TFile::Open"", ""incomplete 'TIMEOUT=' option specification - ignored"");; 4175 opts.ReplaceAll(""TIMEOUT="", """");; 4176 }; 4177 }; 4178 ; 4179 // We will use this from now on; 4180 const char *option = opts;; 4181 ; 4182 // Many URLs? Redirect output and print errors in case of global failure; 4183 TString namelist(expandedUrl);; 4184 Ssiz_t ip = namelist.Index(""|"");; 4185 Bool_t rediroutput = (ip != kNPOS &&; 4186 ip != namelist.Length()-1 && gDebug <= 0) ? kTRUE : kFALSE;; 4187 RedirectHandle_t rh;; 4188 if (rediroutput) {; 4189 TString outf = "".TFileOpen_"";; 4190 FILE *fout = gSystem->TempFileName(outf);; 4191 if (fout) {; 4192 fclose(fout);; 4193 gSystem->RedirectOutput(outf, ""w"", &rh);; 4194 }; 4195 }; 4196 ; 4197 // Try sequentially all names in 'names'; 4198 TString name, n;; 4199 Ssiz_t from = 0;; 4200 while (namelist.Tokenize(n, from, ""|"") && !f) {; 4201 ; 4202 // check if we read through a file cache; 4203 if (!strcasecmp(option, ""CACHEREAD"") ||; 4204 ((!s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:152689,Safe,SafeDelete,152689,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,"['Safe', 'TIMEOUT']","['SafeDelete', 'TIMEOUT']"
Safety,"Attr::CreateImplicit(C, comment.str(), nullptr, 0));; 392 } else if (!isGenreflex) {; 393 // Here we check if we are in presence of a selection file so that; 394 // the comment does not ends up as a decoration in the AST,; 395 // Nevertheless, w/o PCMS this has no effect, since the headers; 396 // are parsed at runtime and the information in the AST dumped by; 397 // rootcling is not relevant.; 398 (*I)->addAttr(AnnotateAttr::CreateImplicit(C, comment.str(), nullptr, 0));; 399 }; 400 }; 401 // Match decls with sel rules if we are in presence of a selection file; 402 // and the cast was successful; 403 if (isGenreflex && thisClassSelectionRule != nullptr) {; 404 const std::list<VariableSelectionRule> &fieldSelRules = thisClassSelectionRule->GetFieldSelectionRules();; 405 ; 406 // This check is here to avoid asserts in debug mode (LLVMDEV env variable set); 407 if (FieldDecl *fieldDecl = dyn_cast<FieldDecl>(*I)) {; 408 AnnotateFieldDecl(*fieldDecl, fieldSelRules);; 409 }; 410 } // End presence of XML selection file; 411 }; 412 }; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416 ; 417size_t GetFullArrayLength(const clang::ConstantArrayType *arrayType); 418{; 419 if (!arrayType); 420 return 0;; 421 llvm::APInt len = arrayType->getSize();; 422 while (const clang::ConstantArrayType *subArrayType = llvm::dyn_cast<clang::ConstantArrayType>(arrayType->getArrayElementTypeNoTypeQual())) {; 423 len *= subArrayType->getSize();; 424 arrayType = subArrayType;; 425 }; 426 return len.getLimitedValue();; 427}; 428 ; 429////////////////////////////////////////////////////////////////////////////////; 430 ; 431bool InheritsFromTObject(const clang::RecordDecl *cl,; 432 const cling::Interpreter &interp); 433{; 434 static const clang::CXXRecordDecl *TObject_decl; 435 = ROOT::TMetaUtils::ScopeSearch(""TObject"", interp, true /*diag*/, nullptr);; 436 ; 437 const clang::CXXRecordDecl *clxx = llvm::dyn_cast<clang::CXXRecordDecl>(cl);; 438 retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:14746,avoid,avoid,14746,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['avoid'],['avoid']
Safety,"AxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyS(Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetTubeDimensions(Double_t rmin, Double_t rmax, Double_t dz); Set tube dimensions. void SetDimensions(Double_t* param); Set tube dimensions starting from a list. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n random points located on the line segments of the shape mesh.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation is implemented. void SetPoints(Double_t* points) const; create tube mesh points. void SetPoints(Float_t* points) const; create tube mesh points. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTube.html:16363,Safe,SafetyS,16363,root/html528/TGeoTube.html,https://root.cern,https://root.cern/root/html528/TGeoTube.html,3,['Safe'],['SafetyS']
Safety,"BBox. â—†Â GetPointsOnSegments(). Bool_t TGeoEltu::GetPointsOnSegments ; (; Int_tÂ ; , . Double_t *Â ; Â . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 54 of file TGeoEltu.h. â—†Â InspectShape(). void TGeoEltu::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â IsA(). TClass * TGeoEltu::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 65 of file TGeoEltu.h. â—†Â IsCylType(). Bool_t TGeoEltu::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 56 of file TGeoEltu.h. â—†Â operator=(). TGeoEltu & TGeoEltu::operator= ; (; const TGeoEltu &Â ; ). privatedelete . â—†Â Safety(). Double_t TGeoEltu::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Safety_v(). void TGeoEltu::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â SavePrimitive(). void TGeoEltu::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. â—†Â SetDimensions(). void TGeoEltu::SetDimensions ; (; Double_t *Â ; param). overridevirtual . Reimplemented from TGeoBBox. â—†Â SetEltuDimensions(). void TGeoEltu::SetEltuDimensions ; (; Double_tÂ ; a, . Double_tÂ ; b, . Double_tÂ ; dzÂ . ). â—†Â SetPoints() [1/2]. void TGeoEltu::SetPoints ; (; Double_t *Â ; points); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â SetPoints() [2/2]. void TGeoEltu::SetPoints ; (; Float_t *Â ; points); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Streamer(). void TGeoEltu::Streamer ; (; TBuffer &Â ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGeoBBox. â—†Â StreamerNVirtual(). void TGeoEltu::StreamerNVirtual ; (; TBuf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoEltu.html:31570,safe,safe,31570,doc/master/classTGeoEltu.html,https://root.cern,https://root.cern/doc/master/classTGeoEltu.html,1,['safe'],['safe']
Safety,"BBox.; Definition at line 91 of file TGeoPcon.h. â—†Â MakeBuffer3D(). TBuffer3D * TGeoPcon::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. â—†Â operator=(). TGeoPcon & TGeoPcon::operator= ; (; const TGeoPcon &Â ; ). protecteddelete . â—†Â Phi1(). Double_t & TGeoPcon::Phi1 ; (; ). inline . Definition at line 93 of file TGeoPcon.h. â—†Â Rmax(). Double_t & TGeoPcon::Rmax ; (; Int_tÂ ; ipl). inline . Definition at line 96 of file TGeoPcon.h. â—†Â Rmin(). Double_t & TGeoPcon::Rmin ; (; Int_tÂ ; ipl). inline . Definition at line 95 of file TGeoPcon.h. â—†Â Safety(). Double_t TGeoPcon::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. â—†Â Safety_v(). void TGeoPcon::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. â—†Â SafetyToSegment(). Double_t TGeoPcon::SafetyToSegment ; (; const Double_t *Â ; point, . Int_tÂ ; ipl, . Bool_tÂ ; in = kTRUE, . Double_tÂ ; safmin = TGeoShape::Big()Â . ); const. â—†Â SavePrimitive(). void TGeoPcon::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. â—†Â SetDimensions(). void TGeoPcon::SetDimensions ; (; Double_t *Â ; param). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. â—†Â SetPoints() [1/2]. void TGeoPcon::SetPoints ; (; Double_t *Â ; points); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. â—†Â SetPoints() [2/2]. void TGeoPcon::SetPoints ; (; Float_t *Â ; points); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. â—†Â SetSegsAndPols(). void TGeoPcon::SetSegsAndPols ; (; TBuffer3D &Â ; buff); const. overridevirtual . Reimplemented from TGeoBBox.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPcon.html:31853,Safe,SafetyToSegment,31853,doc/master/classTGeoPcon.html,https://root.cern,https://root.cern/doc/master/classTGeoPcon.html,1,['Safe'],['SafetyToSegment']
Safety,"Besides the prefetching mechanisms there is also a local caching option which can be enabled by the user. Both capabilities are disabled by default and must be explicitly enabled by the user. ; Definition at line 33 of file TFilePrefetch.h. Public Member Functions; Â TFilePrefetch (TFile *); Â Constructor. ; Â ; Â ~TFilePrefetch () override; Â Destructor. ; Â ; voidÂ AddPendingBlock (TFPBlock *); Â Safe method to add a block to the pendingList. ; Â ; voidÂ AddReadBlock (TFPBlock *); Â Safe method to add a block to the readList. ; Â ; Bool_tÂ BinarySearchReadList (TFPBlock *, Long64_t, Int_t, Int_t *); Â Search for a requested element in a block and return the index. ; Â ; Bool_tÂ CheckBlockInCache (char *&, TFPBlock *); Â Test if the block is in cache. ; Â ; TFPBlock *Â CreateBlockObj (Long64_t *, Int_t *, Int_t); Â Create a new block or recycle an old one. ; Â ; char *Â GetBlockFromCache (const char *, Int_t); Â Return a buffer from cache. ; Â ; std::condition_variable &Â GetCondNewBlock (); Â ; TFPBlock *Â GetPendingBlock (); Â Safe method to remove a block from the pendingList. ; Â ; TThread *Â GetThread () const; Â Return reference to the consumer thread. ; Â ; Long64_tÂ GetWaitTime (); Â Return the time spent wating for buffer to be read in microseconds. ; Â ; TClass *Â IsA () const override; Â ; Bool_tÂ IsPrefetchFinished () const; Â ; voidÂ ReadAsync (TFPBlock *, Bool_t &); Â Read one block and insert it in prefetchBuffers list. ; Â ; voidÂ ReadBlock (Long64_t *, Int_t *, Int_t); Â Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. ; Â ; Bool_tÂ ReadBuffer (char *, Long64_t, Int_t); Â Return a prefetched element. ; Â ; voidÂ ReadListOfBlocks (); Â Get blocks specified in prefetchBlocks. ; Â ; voidÂ SaveBlockInCache (TFPBlock *); Â Save the block content in cache. ; Â ; Bool_tÂ SetCache (const char *); Â Set the path of the cache directory. ; Â ; voidÂ SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect); Â Change the file. ; Â ; voidÂ Streamer (TBuffer &) override; Â Stream an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFilePrefetch.html:1712,Safe,Safe,1712,doc/master/classTFilePrefetch.html,https://root.cern,https://root.cern/doc/master/classTFilePrefetch.html,1,['Safe'],['Safe']
Safety,"Blight] = {} +/- {}"".format(Asig2.getVal(), Asig2.getError())); ; can.SaveAs(""rf709_BarlowBeeston.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; [#0] WARNING:InputArguments -- The parameter 'sigG' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model0_over_model0_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model0_over_model0_Int[x]_sumData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2388.31039421315518; Edm = 3.25299757922590944e-06; Nfcn = 60; Abkg = 0.0614547 +/- 0.00211669 (limited); Asig = 0.833778 +/- 0.1898 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html:8283,safe,safe,8283,doc/master/rf709__BarlowBeeston_8py.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html,1,['safe'],['safe']
Safety,"BoolNode.cxx. â—†Â GetBooleanOperator(). EGeoBoolType TGeoUnion::GetBooleanOperator ; (; ); const. inlineoverridevirtual . Implements TGeoBoolNode.; Definition at line 118 of file TGeoBoolNode.h. â—†Â GetNpoints(). Int_t TGeoUnion::GetNpoints ; (; ). overridevirtual . Returns number of vertices for the composite shape described by this union. ; Implements TGeoBoolNode.; Definition at line 778 of file TGeoBoolNode.cxx. â—†Â IsA(). TClass * TGeoUnion::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBoolNode.; Definition at line 128 of file TGeoBoolNode.h. â—†Â MakeClone(). TGeoBoolNode * TGeoUnion::MakeClone ; (; ); const. overridevirtual . Make a clone of this. Pointers are preserved. ; Implements TGeoBoolNode.; Definition at line 432 of file TGeoBoolNode.cxx. â—†Â Paint(). void TGeoUnion::Paint ; (; Option_t *Â ; option). overridevirtual . Paint method. ; Reimplemented from TGeoBoolNode.; Definition at line 440 of file TGeoBoolNode.cxx. â—†Â Safety(). Double_t TGeoUnion::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Compute safety distance for a union node;. ; Implements TGeoBoolNode.; Definition at line 822 of file TGeoBoolNode.cxx. â—†Â SavePrimitive(). void TGeoUnion::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBoolNode.; Definition at line 846 of file TGeoBoolNode.cxx. â—†Â Sizeof3D(). void TGeoUnion::Sizeof3D ; (; ); const. overridevirtual . Register 3D size of this shape. ; Reimplemented from TGeoBoolNode.; Definition at line 865 of file TGeoBoolNode.cxx. â—†Â Streamer(). void TGeoUnion::Streamer ; (; TBuffer &Â ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGeoBoolNode. â—†Â StreamerNVirtual(). void TGeoUnion::StreamerNVirtual ; (; TBuffer &Â ; ClassDef_StreamerNVirtual_b). inline . Definition at line 128 of file TGeoBoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoUnion.html:18052,Safe,Safety,18052,doc/master/classTGeoUnion.html,https://root.cern,https://root.cern/doc/master/classTGeoUnion.html,1,['Safe'],['Safety']
Safety,"Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCone.html:3108,safe,safe,3108,root/html534/TGeoCone.html,https://root.cern,https://root.cern/root/html534/TGeoCone.html,3,['safe'],['safe']
Safety,"Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tTGeoBBox::Safety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidTGeoBBox::Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTGeoBBox::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFromFaceSet(TGLFaceSet* fs); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveGeoPolyShape.html:8814,safe,safe,8814,root/html534/TEveGeoPolyShape.html,https://root.cern,https://root.cern/root/html534/TEveGeoPolyShape.html,1,['safe'],['safe']
Safety,"Bool_tÂ Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr); Â Disconnects ""class signal"". ; Â ; static Bool_tÂ Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr); Â Disconnects signal in object sender from slot_method in object receiver. ; Â . Protected Types; enum Â ESlaves { kAll; , kActive; , kUnique; , kAllUnique; }; Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â . Protected Member Functions; Â TProof (); Â Protected constructor to be used by classes deriving from TProof (they have to call Init themselves and override StartSlaves appropriately). ; Â ; Int_tÂ AddWorkers (TList *wrks); Â Works on the master node only. ; Â ; Int_tÂ AssertPath (const char *path, Bool_t writable); Â Make sure that 'path' exists; if 'writable' is kTRUE, make also sure that the path is writable. ; Â ; Int_tÂ Collect (ESlaves list=kActive, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE); Â Collect responses from the slave servers. ; Â ; Int_tÂ Collect (TList *slaves, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE); Â Collect responses from the slave servers. ; Â ; TSlave *Â CreateSlave (const char *url, const char *ord, Int_t perf, const char *image, const char *workdir); Â Create a new TSlave of type TSlave::kSlave. ; Â ; TSlave *Â CreateSubmaster (const char *url, const char *ord, const char *image, const char *msd, Int_t nwk=1); Â Create a new TSlave of type TSlave::kMaster. ; Â ; TList *Â GetEnabledPackages () const; Â ; TList *Â GetListOfActiveSlaves () const; Â ; TVirtualProofPlayer *Â GetPlayer () const; Â ; TPluginHandler *Â GetProgressDialog () const; Â ; Int_tÂ GetSandbox (TString &sb, Bool_t assert=kFALSE, const char *rc=0); Â Set the sandbox path from ' Proof.Sandbox' or the alternative var 'rc'. ; Â ; voidÂ HandleLibIncPath (const char *what, Bool_t add, const char *dirs); Â Handle lib, inc search paths modification request. ; Â ; I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:36990,timeout,timeout,36990,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['timeout'],['timeout']
Safety,"Buffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBuffer(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBuffer(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBuffer.html:18871,avoid,avoiding,18871,root/html602/TBuffer.html,https://root.cern,https://root.cern/root/html602/TBuffer.html,2,['avoid'],['avoiding']
Safety,"BufferFile::WriteFastArray ; (; const UChar_t *Â ; c, . Long64_tÂ ; nÂ . ). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 517 of file TBufferFile.h. â—†Â WriteFastArray() [10/15]. void TBufferFile::WriteFastArray ; (; const UInt_t *Â ; i, . Long64_tÂ ; nÂ . ). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 523 of file TBufferFile.h. â—†Â WriteFastArray() [11/15]. void TBufferFile::WriteFastArray ; (; const ULong64_t *Â ; l, . Long64_tÂ ; nÂ . ). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 526 of file TBufferFile.h. â—†Â WriteFastArray() [12/15]. void TBufferFile::WriteFastArray ; (; const ULong_t *Â ; ll, . Long64_tÂ ; nÂ . ). overridevirtual . Write array of n unsigned longs into the I/O buffer with 8-byte width. ; This is an explicit case for unsigned longs since signed longs have a special tobuf(). NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2153 of file TBufferFile.cxx. â—†Â WriteFastArray() [13/15]. void TBufferFile::WriteFastArray ; (; const UShort_t *Â ; h, . Long64_tÂ ; nÂ . ). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 520 of file TBufferFile.h. â—†Â WriteFastArray() [14/15]. Int_t TBufferFile::WriteFastArray ; (; void **Â ; start, . const TClass *Â ; cl, . Long64_tÂ ; n = 1, . Bool_tÂ ; isPreAlloc = kFALSE, . TMemberStreamer *Â ; streamer = nullptrÂ . ). overridevirtual . Write an array of object starting at the address '*start' and of length 'n' the objects in the array are of class 'cl' 'isPreAlloc' indicates whether the data member is marked with '->' Return: . 0: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.); -1: underflow, operation ski",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:85548,abort,aborts,85548,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['abort'],['aborts']
Safety,"CacheObject(). void RooFFTConvPdf::fillCacheObject ; (; RooAbsCachedPdf::PdfCacheElem &Â ; cache); const. overrideprotectedvirtual . Fill the contents of the cache the FFT convolution output. ; Implements RooAbsCachedPdf.; Definition at line 479 of file RooFFTConvPdf.cxx. â—†Â fillCacheSlice(). void RooFFTConvPdf::fillCacheSlice ; (; FFTCacheElem &Â ; cache, . const RooArgSet &Â ; slicePositionÂ . ); const. protected . Fill a slice of cachePdf with the output of the FFT convolution calculation. ; Definition at line 559 of file RooFFTConvPdf.cxx. â—†Â genContext(). RooAbsGenContext * RooFFTConvPdf::genContext ; (; const RooArgSet &Â ; vars, . const RooDataSet *Â ; prototype = nullptr, . const RooArgSet *Â ; auxProto = nullptr, . boolÂ ; verbose = falseÂ . ); const. overrideprotectedvirtual . Create appropriate generator context for this convolution. ; If both input p.d.f.s support internal generation, if it is safe to use them and if no observables other than the convolution observable are requested for generation, use the specialized convolution generator context which implements a smearing strategy in the convolution observable. If not return the regular accept/reject generator context ; Reimplemented from RooAbsPdf.; Definition at line 864 of file RooFFTConvPdf.cxx. â—†Â getMaxVal(). Int_t RooFFTConvPdf::getMaxVal ; (; const RooArgSet &Â ; vars); const. inlineoverridevirtual . Advertise capability to determine maximum value of function for given set of observables. ; If no direct generator method is provided, this information will assist the accept/reject generator to operate more efficiently as it can skip the initial trial sampling phase to empirically find the function maximum ; Reimplemented from RooAbsReal.; Definition at line 61 of file RooFFTConvPdf.h. â—†Â histNameSuffix(). TString RooFFTConvPdf::histNameSuffix ; (; ); const. overrideprotectedvirtual . Suffix for cache histogram (added in addition to suffix for cache name) ; Reimplemented from RooAbsCachedPdf.; Definition at li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:91254,safe,safe,91254,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['safe'],['safe']
Safety,"CacheWrite * GetCacheWrite() constReturn a pointer to the current write cache.Definition TFile.cxx:1279; TFile::SetFileReadCallsstatic void SetFileReadCalls(Int_t readcalls=0)Definition TFile.cxx:4614; TFile::fgCacheFileDirstatic TString fgCacheFileDirDirectory where to locally stage files.Definition TFile.h:124; TFile::SysReadvirtual Int_t SysRead(Int_t fd, void *buf, Int_t len)Interface to system read. All arguments like in POSIX read().Definition TFile.cxx:4506; TFile::fVersionInt_t fVersionFile format version.Definition TFile.h:83; TFile::Printvoid Print(Option_t *option="""") const overridePrint all objects in the file.Definition TFile.cxx:1706; TFile::fgFileCounterstatic std::atomic< Long64_t > fgFileCounterCounter for all opened files.Definition TFile.h:132; TFile::GetAsyncOpenStatusvirtual EAsyncOpenStatus GetAsyncOpenStatus()Definition TFile.h:137; TFile::Streamervoid Streamer(TBuffer &) overrideStream a TFile object.Definition TFile.cxx:2405; TFile::GetOpenTimeoutstatic UInt_t GetOpenTimeout()Returns open timeout (in ms).Definition TFile.cxx:4734; TFile::CpProgressstatic void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &watch)Print file copy progress.Definition TFile.cxx:4975; TFile::fgOnlyStagedstatic Bool_t fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails.Definition TFile.h:128; TFile::GetNProcessIDsvirtual Int_t GetNProcessIDs() constDefinition TFile.h:239; TFile::fMustFlushBool_t fMustFlush!True if the file buffers must be flushedDefinition TFile.h:106; TFile::fUrlTUrl fUrl!URL of fileDefinition TFile.h:110; TFile::WriteBufferViaCacheInt_t WriteBufferViaCache(const char *buf, Int_t len)Write buffer via cache.Definition TFile.cxx:2519; TFile::GetFileBytesReadstatic Long64_t GetFileBytesRead()Static function returning the total number of bytes read from all files.Definition TFile.cxx:4574; TFile::ReadBufferViaCacheInt_t ReadBufferViaCache(char *buf, Int_t len)Read buffer via cache.Definition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:216146,timeout,timeout,216146,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['timeout'],['timeout']
Safety,"Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; Double_tDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTorus.html:2113,safe,safe,2113,root/html528/TGeoTorus.html,https://root.cern,https://root.cern/root/html528/TGeoTorus.html,1,['safe'],['safe']
Safety,"Center(); { fPushAction = kPushCamCenter; RefreshPadEditor(this); }. void PickAnnotate(); { fPushAction = kPushAnnotate; RefreshPadEditor(this); }. TGLCameraOverlay* GetCameraOverlay() const; { return fCameraOverlay; }. void SetCameraOverlay(TGLCameraOverlay* m); { fCameraOverlay = m; }. Bool_t GetStereo() const; Stereo. { return fStereo; }. Float_t GetStereoZeroParallax() const; { return fStereoZeroParallax; }. Float_t GetStereoEyeOffsetFac() const; { return fStereoEyeOffsetFac; }. Float_t GetStereoFrustumAsymFac() const; { return fStereoFrustumAsymFac; }. void SetStereo(Bool_t s); { fStereo = s; }. void SetStereoZeroParallax(Float_t f); { fStereoZeroParallax = f; }. void SetStereoEyeOffsetFac(Float_t f); { fStereoEyeOffsetFac = f; }. void SetStereoFrustumAsymFac(Float_t f); { fStereoFrustumAsymFac = f; }. EPushAction GetPushAction() const; Push / drag action. { return fPushAction; }. EDragAction GetDragAction() const; { return fDragAction; }. Float_t GetMaxSceneDrawTimeHQ() const; Draw and selection; Scene rendering timeouts. { return fMaxSceneDrawTimeHQ; }. Float_t GetMaxSceneDrawTimeLQ() const; { return fMaxSceneDrawTimeLQ; }. void SetMaxSceneDrawTimeHQ(Float_t t); { fMaxSceneDrawTimeHQ = t; }. void SetMaxSceneDrawTimeLQ(Float_t t); { fMaxSceneDrawTimeLQ = t; }. const char* GetPictureFileName() const; { return fPictureFileName.Data(); }. void SetPictureFileName(const TString& f); { fPictureFileName = f; }. Float_t GetFader() const; { return fFader; }. void SetFader(Float_t x); { fFader = x; }. Bool_t GetIgnoreSizesOnUpdate() const; { return fIgnoreSizesOnUpdate; }. void SetIgnoreSizesOnUpdate(Bool_t v); { fIgnoreSizesOnUpdate = v; }. Bool_t GetResetCamerasOnUpdate() const; { return fResetCamerasOnUpdate; }. void SetResetCamerasOnUpdate(Bool_t v); { fResetCamerasOnUpdate = v; }. void Activated(); { Emit(""Activated()""); }. void DoubleClicked(); { Emit(""DoubleClicked()""); }. TGEventHandler * GetEventHandler() const; { return fEventHandler; }. TGedEditor* GetGedEdito",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLViewer.html:37749,timeout,timeouts,37749,root/html528/TGLViewer.html,https://root.cern,https://root.cern/root/html528/TGLViewer.html,5,['timeout'],['timeouts']
Safety,"CheckingOverlaps() constDefinition TGeoNavigator.h:138; TGeoNavigator::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:235; TGeoNavigator::fCacheTGeoNodeCache * fCachecurrent geometryDefinition TGeoNavigator.h:73; TGeoNavigator::fStartSafeBool_t fStartSafeflags the type of the current nodeDefinition TGeoNavigator.h:63; TGeoNavigator::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoNavigator.cxx:405; TGeoNavigator::GetNextNodeTGeoNode * GetNextNode() constDefinition TGeoNavigator.h:154; TGeoNavigator::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoNavigator.cxx:1689; TGeoNavigator::GetCldirCheckedconst Double_t * GetCldirChecked() constDefinition TGeoNavigator.h:164; TGeoNavigator::GotoSafeLevelBool_t GotoSafeLevel()Go upwards the tree until a non-overlapping node.Definition TGeoNavigator.cxx:2357; TGeoNavigator::fNormalDouble_t fNormal[3]last computed safety radiusDefinition TGeoNavigator.h:46; TGeoNavigator::GetLastSafetyDouble_t GetLastSafety() constDefinition TGeoNavigator.h:127; TGeoNavigator::PopPointBool_t PopPoint(Int_t index)Definition TGeoNavigator.h:272; TGeoNavigator::cdBool_t cd(const char *path="""")Browse the tree of nodes starting from top node according to pathname.Definition TGeoNavigator.cxx:210; TGeoNavigator::fLastPointDouble_t fLastPoint[3]current directionDefinition TGeoNavigator.h:51; TGeoNavigator::GetStepDouble_t GetStep() constDefinition TGeoNavigator.h:128; TGeoNavigator::IsSameLocationBool_t IsSameLocation() constDefinition TGeoNavigator.h:133; TGeoNavigator::fCldirDouble_t fCldir[3]cosine of incident angle on current checked surfaceDefinition TGeoNavigator.h:47; TGeoNavigator::fIsStepEnteringBool_t fIsStepEnteringflag that current track is about to leave current nodeDefinition TGeoNavigator.h:66; TGeoNavigator::SetLastPointvoid SetLastPoint(Double_t x, Double_t y, Double_t z)Definition TGeoNav",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:21001,safe,safety,21001,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safety']
Safety,"ClassInfo);; 6171 }; 6172 } else {; 6173 ; 6174 if (fStreamer) {; 6175 kl->fStreamerType = kExternal;; 6176 kl->fStreamerImpl = &TClass::StreamerExternal;; 6177 }; 6178 ; 6179 kl->fStreamerType |= kEmulatedStreamer;; 6180 kl->SetStreamerImpl();; 6181 // fProperty was *not* set so that it can be forced to be recalculated; 6182 // next time.; 6183 return 0;; 6184 }; 6185 ; 6186 return fProperty;; 6187}; 6188 ; 6189////////////////////////////////////////////////////////////////////////////////; 6190/// Internal routine to set calculate the class properties that can only be; 6191/// known at run-time, for example whether the Hash member function and the; 6192/// destructor are consistent.; 6193 ; 6194void TClass::SetRuntimeProperties(); 6195{; 6196 // For now, no need to lock this routines as fRuntimeProperties is; 6197 // the only atomic set here and this is done at the end; 6198 // and there is no downside if the execution is done twice.; 6199 ; 6200 // Note SetRuntimeProperties is set to const as it is technically; 6201 // thread-safe.; 6202 ; 6203 UChar_t properties = static_cast<UChar_t>(ERuntimeProperties::kSet);; 6204 ; 6205 if (ROOT::Internal::TCheckHashRecursiveRemoveConsistency::Check(*this)); 6206 properties |= static_cast<UChar_t>(ERuntimeProperties::kConsistentHash);; 6207 ; 6208 const_cast<TClass *>(this)->fRuntimeProperties = properties;; 6209}; 6210 ; 6211////////////////////////////////////////////////////////////////////////////////; 6212/// Internal routine to set fStreamerImpl based on the value of; 6213/// fStreamerType.; 6214 ; 6215void TClass::SetStreamerImpl(); 6216{; 6217 switch (fStreamerType) {; 6218 case kTObject: fStreamerImpl = &TClass::StreamerTObject; break;; 6219 case kForeign: fStreamerImpl = &TClass::StreamerStreamerInfo; break;; 6220 case kExternal: fStreamerImpl = &TClass::StreamerExternal; break;; 6221 case kInstrumented: {; 6222 if (fConvStreamerFunc) fStreamerImpl = &TClass::ConvStreamerInstrumented;; 6223 else if (fStreamerFunc) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:238590,safe,safe,238590,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['safe'],['safe']
Safety,"ClassInfo);; 6238 }; 6239 } else {; 6240 ; 6241 if (fStreamer) {; 6242 kl->fStreamerType = kExternal;; 6243 kl->fStreamerImpl = &TClass::StreamerExternal;; 6244 }; 6245 ; 6246 kl->fStreamerType |= kEmulatedStreamer;; 6247 kl->SetStreamerImpl();; 6248 // fProperty was *not* set so that it can be forced to be recalculated; 6249 // next time.; 6250 return 0;; 6251 }; 6252 ; 6253 return fProperty;; 6254}; 6255 ; 6256////////////////////////////////////////////////////////////////////////////////; 6257/// Internal routine to set calculate the class properties that can only be; 6258/// known at run-time, for example whether the Hash member function and the; 6259/// destructor are consistent.; 6260 ; 6261void TClass::SetRuntimeProperties(); 6262{; 6263 // For now, no need to lock this routines as fRuntimeProperties is; 6264 // the only atomic set here and this is done at the end; 6265 // and there is no downside if the execution is done twice.; 6266 ; 6267 // Note SetRuntimeProperties is set to const as it is technically; 6268 // thread-safe.; 6269 ; 6270 UChar_t properties = static_cast<UChar_t>(ERuntimeProperties::kSet);; 6271 ; 6272 if (ROOT::Internal::TCheckHashRecursiveRemoveConsistency::Check(*this)); 6273 properties |= static_cast<UChar_t>(ERuntimeProperties::kConsistentHash);; 6274 ; 6275 const_cast<TClass *>(this)->fRuntimeProperties = properties;; 6276}; 6277 ; 6278////////////////////////////////////////////////////////////////////////////////; 6279/// Internal routine to set fStreamerImpl based on the value of; 6280/// fStreamerType.; 6281 ; 6282void TClass::SetStreamerImpl(); 6283{; 6284 switch (fStreamerType) {; 6285 case kTObject: fStreamerImpl = &TClass::StreamerTObject; break;; 6286 case kForeign: fStreamerImpl = &TClass::StreamerStreamerInfo; break;; 6287 case kExternal: fStreamerImpl = &TClass::StreamerExternal; break;; 6288 case kInstrumented: {; 6289 if (fConvStreamerFunc) fStreamerImpl = &TClass::ConvStreamerInstrumented;; 6290 else if (fStreamerFunc) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:241341,safe,safe,241341,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['safe'],['safe']
Safety,"Cling::DriverConfig& config); 6226{; 6227 ; 6228 assert(!gDriverConfig && ""Driver configuration already set!"");; 6229 gDriverConfig = &config;; 6230 ; 6231 gBuildingROOT = config.fBuildingROOTStage1; // gets refined later; 6232 ; 6233 std::string exeName = ExtractFileName(GetExePath());; 6234#ifdef __APPLE__; 6235 // _dyld_get_image_name() on macOS11 and later sometimes returns ""rootcling"" for ""genreflex"".; 6236 // Fix that (while still initializing the binary path, needed for ROOTSYS) by updating the; 6237 // exeName to argv[0]:; 6238 exeName = ExtractFileName(argv[0]);; 6239#endif; 6240 ; 6241 // Select according to the name of the executable the procedure to follow:; 6242 // 1) RootCling; 6243 // 2) GenReflex; 6244 // The default is rootcling; 6245 ; 6246 int retVal = 0;; 6247 ; 6248 if (std::string::npos != exeName.find(""genreflex"")); 6249 retVal = GenReflexMain(argc, argv);; 6250 else // rootcling or default; 6251 retVal = RootClingMain(argc, argv);; 6252 ; 6253 gDriverConfig = nullptr;; 6254 ; 6255 if (ROOT::TMetaUtils::GetNumberOfErrors()){; 6256 ROOT::TMetaUtils::Info(nullptr,""Problems have been detected during the generation of the dictionary.\n"");; 6257 return 1;; 6258 }; 6259 return retVal;; 6260}; DictSelectionReader.hSelect classes and assign properties using C++ syntax.; FoundationUtils.hxxThe file contains utilities which are foundational and could be used across the core component of ROO...; LinkdefReader.h; OptionParser.hThis is the only file required to use The Lean Mean C++ Option Parser.; DEBUG#define DEBUGDefinition Polynomial.cxx:40; RConfig.hxx; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; RStl.h; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; RtypesCore.h; Scanner.h; SelectionRules.h; TClassEdit.h; X#define X(type, nam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:245500,detect,detected,245500,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['detect'],['detected']
Safety,"CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile.Recover: 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. TKey* CreateKey(TDirectory* mother, const TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFile.html:27725,recover,recovery,27725,root/html534/TFile.html,https://root.cern,https://root.cern/root/html534/TFile.html,1,['recover'],['recovery']
Safety,"Compute DistFromOutside and propagate with d2 making sure that the shape is not re-entered. Swap direction and call DistFromOutside that should fall back on the same point on the boundary (at d2). Propagate back on boundary then compute DistFromInside that should be bigger than d1. Plot d-(d1+d2) ; Definition at line 1771 of file TGeoChecker.cxx. â—†Â ShapeNormal(). void TGeoChecker::ShapeNormal ; (; TGeoShape *Â ; shape, . Int_tÂ ; nsamples, . Option_t *Â ; optionÂ . ). Check of validity of the normal for a given shape. ; Sample points inside the shape. Generate directions randomly in cos(theta) and propagate to boundary. Compute normal and safety at crossing point, plot the point and generate a random direction so that (dir) dot (norm) <0. ; Definition at line 2014 of file TGeoChecker.cxx. â—†Â ShapeSafety(). void TGeoChecker::ShapeSafety ; (; TGeoShape *Â ; shape, . Int_tÂ ; nsamples, . Option_t *Â ; optionÂ . ). Check of validity of safe distance for a given shape. ; Sample points inside the 2x bounding box and compute safety. Generate directions randomly in cos(theta) and compute distance to boundary. Check if distance to boundary is bigger than safety. ; Definition at line 1940 of file TGeoChecker.cxx. â—†Â ShootRay(). Double_t * TGeoChecker::ShootRay ; (; Double_t *Â ; start, . Double_tÂ ; dirx, . Double_tÂ ; diry, . Double_tÂ ; dirz, . Double_t *Â ; array, . Int_t &Â ; nelem, . Int_t &Â ; dim, . Double_t *Â ; endpoint = nullptrÂ . ); const. Shoot one ray from start point with direction (dirx,diry,dirz). ; Fills input array with points just after boundary crossings. ; Definition at line 2614 of file TGeoChecker.cxx. â—†Â Streamer(). void TGeoChecker::Streamer ; (; TBuffer &Â ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. â—†Â StreamerNVirtual(). void TGeoChecker::StreamerNVirtual ; (; TBuffer &Â ; ClassDef_StreamerNVirtual_b). inline . Definition at line 100 of file TGeoChecker.h. â—†Â Test(). void TGeoChecker::Test ; (; Int_tÂ ; npoints, . Option_t *Â ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoChecker.html:27851,safe,safety,27851,doc/master/classTGeoChecker.html,https://root.cern,https://root.cern/doc/master/classTGeoChecker.html,1,['safe'],['safety']
Safety,"ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override; Â ; Bool_tÂ Contains (const Double_t *point) const override; Â ; voidÂ Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override; Â ; voidÂ CreateThreadData (Int_t nthreads) override; Â ; Bool_tÂ DefinePolygon (Int_t nvert, const Double_t *xv, const Double_t *yv); Â ; virtual voidÂ DefineSection (Int_t snum, Double_t z, Double_t x0=0., Double_t y0=0., Double_t scale=1.); Â ; Int_tÂ DistancetoPrimitive (Int_t px, Int_t py) override; Â Computes distance from point (px,py) to the object. ; Â ; Double_tÂ DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; Â ; voidÂ DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; Â ; Double_tÂ DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; Â ; voidÂ DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; Â ; voidÂ DrawPolygon (Option_t *option=""""); Â ; const TBuffer3D &Â GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override; Â Stub implementation to avoid forcing implementation at this stage. ; Â ; TGeoShape *Â GetMakeRuntimeShape (TGeoShape *, TGeoMatrix *) const override; Â ; voidÂ GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override; Â ; Int_tÂ GetNmeshVertices () const override; Â ; Int_tÂ GetNvert () const; Â ; Int_tÂ GetNz () const; Â ; Double_tÂ GetScale (Int_t i) const; Â ; ThreadData_t &Â GetThreadData () const; Â ; Double_tÂ GetX (Int_t i) const; Â ; Double_tÂ GetXOffset (Int_t i) const; Â ; Double_tÂ GetY (Int_t i) const; Â ; Double_tÂ GetYOffset (Int_t i) const; Â ; Double_t *Â GetZ () const; Â ; Double_tÂ GetZ (Int_t ipl) const; Â ; voidÂ InspectShape () const override; Â ; TClass ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoXtru.html:1466,safe,safe,1466,doc/master/classTGeoXtru.html,https://root.cern,https://root.cern/doc/master/classTGeoXtru.html,3,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"Contains(). Bool_t TGeoSphere::Contains ; (; const Double_t *Â ; point); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Contains_v(). void TGeoSphere::Contains_v ; (; const Double_t *Â ; points, . Bool_t *Â ; inside, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DeclFileName(). static const char * TGeoSphere::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 96 of file TGeoSphere.h. â—†Â DistancetoPrimitive(). Int_t TGeoSphere::DistancetoPrimitive ; (; Int_tÂ ; px, . Int_tÂ ; pyÂ . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoBBox. â—†Â DistFromInside(). Double_t TGeoSphere::DistFromInside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromInside_v(). void TGeoSphere::DistFromInside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside(). Double_t TGeoSphere::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside_v(). void TGeoSphere::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistToSphere(). Double_t TGeoSphere::DistToSphere ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Double_tÂ ; rsph, . Bool_tÂ ; check = kTRUE, . Bool_tÂ ; firstcross = kTRUEÂ . ); cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSphere.html:25650,safe,safe,25650,doc/master/classTGeoSphere.html,https://root.cern,https://root.cern/doc/master/classTGeoSphere.html,1,['safe'],['safe']
Safety,"ConvertFromJSONChecked (const char *str, const TClass *expectedClass); Â Read objects from JSON, one can reuse existing object. ; Â ; Â Static Protected Member Functions inherited from TBufferIO; static R__ALWAYS_INLINE ULong_tÂ Void_Hash (const void *ptr); Â Return hash value for provided object. ; Â . Protected Attributes; Int_tÂ fArrayCompact {0}; Â ! 0 - no array compression, 1 - exclude leading/trailing zeros, 2 - check value repetition ; Â ; TStringÂ fArraySepar; Â ! depending from compression level, "", "" or "","" ; Â ; Int_tÂ fCompact {0}; Â ! 0 - no any compression, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all ; Â ; unsignedÂ fJsonrCnt {0}; Â ! counter for all objects, used for referencing ; Â ; Bool_tÂ fMapAsObject {kFALSE}; Â ! when true, std::map will be converted into JSON object ; Â ; TStringÂ fNumericLocale; Â ! stored value of setlocale(LC_NUMERIC), which should be recovered at the end ; Â ; TStringÂ fOutBuffer; Â ! main output buffer for json code ; Â ; TString *Â fOutput {nullptr}; Â ! current output buffer for json code ; Â ; TStringÂ fSemicolon; Â ! depending from compression level, "" : "" or "":"" ; Â ; std::vector< const TClass * >Â fSkipClasses; Â ! list of classes, which class info is not stored ; Â ; std::deque< std::unique_ptr< TJSONStackObj > >Â fStack; Â ! hierarchy of currently streamed element ; Â ; TStringÂ fTypeNameTag; Â ! JSON member used for storing class name, when empty - no class name will be stored ; Â ; TStringÂ fTypeVersionTag; Â ! JSON member used to store class version, default empty ; Â ; TStringÂ fValue; Â ! buffer for current value ; Â ; Â Protected Attributes inherited from TBufferIO; TExMap *Â fClassMap {nullptr}; Â Map containing object,class pairs for reading. ; Â ; Int_tÂ fDisplacement {0}; Â Value to be added to the map offsets. ; Â ; TExMap *Â fMap {nullptr}; Â Map containing object,offset pairs for reading/writing. ; Â ; Int_tÂ fMapCount {0}; Â Number of objects or classes in map. ; Â ; Int_tÂ fMapSize {0}; Â Default size of map. ; Â ; UShort_tÂ fPidOffset {0}; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:49945,recover,recovered,49945,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,1,['recover'],['recovered']
Safety,"Ctub(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute minimum bounding box of the ctub. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; check if point is contained in the cut tube; check the lower cut plane. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. Double_t GetZcoord(Double_t xc, Double_t yc, Double_t zc) const; compute real Z coordinate of a point belonging to either lower or; higher caps (z should be either +fDz or -fDz). Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the cut tube. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the cut tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the tube along one axis. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); set dimensions of a cut tube. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCtub.html:16695,safe,safe,16695,root/html534/TGeoCtub.html,https://root.cern,https://root.cern/root/html534/TGeoCtub.html,3,['safe'],['safe']
Safety,"CurPadcurrent pad from which to import; TStyle*fCurStylestyle to copy or to rename; Int_tfMode1=new, 2=rename, 3=import; TGTextEntry*fNameTStyle name text entry; TGLabel*fNameLabelname label; TGTextButton*fOKsave button; TStyleManager*fStyleManagerparent style manager; TGTextEntry*fTitleTStyle title text entry; TGLabel*fTitleLabeltitle label; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGLabel*fWarnLabellabel for warnings. Class Charts. Inheritance Chart:. TObject. â†; TGObject. â†; TGWindow. TQObject. â†; TGFrame. â†; TGCompositeFrame. â†; TGMainFrame. â†; TGTransientFrame. â†; TStyleDialog. Function documentation; TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0); Constructor. Create the dialog window and draw it centered over the; main window 'mf'. A pointer to the style to copy or rename is given; by 'cur' and the parameter 'mode' specify the mode:; 1 = copy | 2 = rename | 3 = import from canvas. ~TStyleDialog(); Destructor. void DoCancel(); Slot called when the Cancel button is clicked. Close the window; without saving submitted changes. void DoCloseWindow(); Slot called when the window is closed via the window manager.; Close the window without saving submitted changes. void DoOK(); Slot called when the OK button is clicked. Rename or create the style; before closing the window. void DoUpdate(); Slot called every time the name is changed. Provide some protection; to avoid letting the user use an empty name or an already used one.; A warning message can be shown and the OK button disabled. TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0). Â» Author: Denis Favre-Miville 08/09/05 Â» Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; Â» Last changed: root/ged:$Id$ Â» Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TStyleDialog.html:24747,avoid,avoid,24747,root/html604/TStyleDialog.html,https://root.cern,https://root.cern/root/html604/TStyleDialog.html,1,['avoid'],['avoid']
Safety,"CurPadcurrent pad from which to import; TStyle*fCurStylestyle to copy or to rename; Int_tfMode1=new, 2=rename, 3=import; TGTextEntry*fNameTStyle name text entry; TGLabel*fNameLabelname label; TGTextButton*fOKsave button; TStyleManager*fStyleManagerparent style manager; TGTextEntry*fTitleTStyle title text entry; TGLabel*fTitleLabeltitle label; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGLabel*fWarnLabellabel for warnings. Class Charts. Inheritance Chart:. TObject. â†; TGObject. â†; TGWindow. TQObject. â†; TGFrame. â†; TGCompositeFrame. â†; TGMainFrame. â†; TGTransientFrame. â†; TStyleDialog. Function documentation; TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0); Constructor. Create the dialog window and draw it centered over the; main window 'mf'. A pointer to the style to copy or rename is given; by 'cur' and the parameter 'mode' specify the mode:; 1 = copy | 2 = rename | 3 = import from canvas. ~TStyleDialog(); Destructor. void DoCancel(); Slot called when the Cancel button is clicked. Close the window; without saving submitted changes. void DoCloseWindow(); Slot called when the window is closed via the window manager.; Close the window without saving submitted changes. void DoOK(); Slot called when the OK button is clicked. Rename or create the style; before closing the window. void DoUpdate(); Slot called every time the name is changed. Provide some protection; to avoid letting the user use an empty name or an already used one.; A warning message can be shown and the OK button disabled. TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0). Â» Author: Denis Favre-Miville 08/09/05 Â» Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; Â» Last changed: root/ged:$Id$ Â» Last generated: 2015-06-30 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStyleDialog.html:24747,avoid,avoid,24747,root/html602/TStyleDialog.html,https://root.cern,https://root.cern/root/html602/TStyleDialog.html,1,['avoid'],['avoid']
Safety,"CurrentNodeId() const { return fCache->GetCurrentNodeId(); }; 161 const Double_t *GetCurrentPoint() const { return fPoint; }; 162 const Double_t *GetCurrentDirection() const { return fDirection; }; 163 TGeoVolume *GetCurrentVolume() const { return fCurrentNode->GetVolume(); }; 164 const Double_t *GetCldirChecked() const { return fCldirChecked; }; 165 const Double_t *GetCldir() const { return fCldir; }; 166 TGeoHMatrix *GetDivMatrix() const { return fDivMatrix; }; 167 // Double_t GetNormalChecked() const {return fNormalChecked;}; 168 const Double_t *GetNormal() const { return fNormal; }; 169 Int_t GetLevel() const { return fLevel; }; 170 const char *GetPath() const;; 171 Int_t GetStackLevel() const { return fCache->GetStackLevel(); }; 172 void SetCurrentPoint(const Double_t *point) { memcpy(fPoint, point, 3 * sizeof(Double_t)); }; 173 void SetCurrentPoint(Double_t x, Double_t y, Double_t z); 174 {; 175 fPoint[0] = x;; 176 fPoint[1] = y;; 177 fPoint[2] = z;; 178 }; 179 void SetLastPoint(Double_t x, Double_t y, Double_t z); 180 {; 181 fLastPoint[0] = x;; 182 fLastPoint[1] = y;; 183 fLastPoint[2] = z;; 184 }; 185 void SetCurrentDirection(const Double_t *dir) { memcpy(fDirection, dir, 3 * sizeof(Double_t)); }; 186 void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); 187 {; 188 fDirection[0] = nx;; 189 fDirection[1] = ny;; 190 fDirection[2] = nz;; 191 }; 192 // void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}; 193 void SetCldirChecked(Double_t *dir) { memcpy(fCldirChecked, dir, 3 * sizeof(Double_t)); }; 194 void SetLastSafetyForPoint(Double_t safe, const Double_t *point); 195 {; 196 fLastSafety = safe;; 197 memcpy(fLastPoint, point, 3 * sizeof(Double_t));; 198 }; 199 void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); 200 {; 201 fLastSafety = safe;; 202 fLastPoint[0] = x;; 203 fLastPoint[1] = y, fLastPoint[2] = z;; 204 }; 205 ; 206 // Check if we have a cached safety value from parallel world, and if this can still be used.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:9948,safe,safe,9948,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,5,['safe'],"['safe', 'safety']"
Safety,"D &Â ; xdiag). pure virtual . Implemented in TQpLinSolverDens, and TQpLinSolverSparse. â—†Â PutZDiagonal(). virtual void TQpLinSolverBase::PutZDiagonal ; (; TVectorD &Â ; zdiag). pure virtual . Implemented in TQpLinSolverDens, and TQpLinSolverSparse. â—†Â SeparateVars(). void TQpLinSolverBase::SeparateVars ; (; TVectorD &Â ; x_in, . TVectorD &Â ; y_in, . TVectorD &Â ; z_in, . TVectorD &Â ; vars_inÂ . ). virtual . Extracts three component vectors from a given aggregated vector. ; vars_in (input) aggregated vector x_in (output) first part of vars y_in (output) middle part of vars z_in (output) last part of vars ; Definition at line 302 of file TQpLinSolverBase.cxx. â—†Â Solve(). void TQpLinSolverBase::Solve ; (; TQpDataBase *Â ; prob, . TQpVar *Â ; vars, . TQpResidual *Â ; res, . TQpVar *Â ; stepÂ . ). virtual . Solves the system for a given set of residuals. ; Assembles the right-hand side appropriate to the matrix factored in factor, solves the system using the factorization produced there, partitions the solution vector into step components, then recovers the step components eliminated during the block elimination that produced the augmented system form . ; Definition at line 162 of file TQpLinSolverBase.cxx. â—†Â SolveCompressed(). virtual void TQpLinSolverBase::SolveCompressed ; (; TVectorD &Â ; rhs). pure virtual . Implemented in TQpLinSolverDens, and TQpLinSolverSparse. â—†Â SolveXYZS(). void TQpLinSolverBase::SolveXYZS ; (; TVectorD &Â ; stepx, . TVectorD &Â ; stepy, . TVectorD &Â ; stepz, . TVectorD &Â ; steps, . TVectorD &Â ; ztemp, . TQpDataBase *Â ; dataÂ . ). virtual . Assemble right-hand side of augmented system and call SolveCompressed to solve it. ; Definition at line 261 of file TQpLinSolverBase.cxx. Member Data Documentation. â—†Â fCloIndex. TVectorD TQpLinSolverBase::fCloIndex. protected . Definition at line 84 of file TQpLinSolverBase.h. â—†Â fCupIndex. TVectorD TQpLinSolverBase::fCupIndex. protected . Definition at line 82 of file TQpLinSolverBase.h. â—†Â fDd. TVectorD TQpLinSolverBase::fDd.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQpLinSolverBase.html:14838,recover,recovers,14838,doc/master/classTQpLinSolverBase.html,https://root.cern,https://root.cern/doc/master/classTQpLinSolverBase.html,1,['recover'],['recovers']
Safety,"D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoHype(); constructors. Int_t GetByteCount() const; {return 64;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Double_t GetStIn() const; {return fStIn;}. Double_t GetStOut() const; {return fStOut;}. Bool_t HasInner() const; {return !TestShapeBit(kGeoRSeg);}. Bool_t IsCylType() const; {return kTRUE;}. Â» Author: Mihaela Gheata 20/11/04 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/geom:$Id$ Â» Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHype.html:20245,safe,safe,20245,root/html534/TGeoHype.html,https://root.cern,https://root.cern/root/html534/TGeoHype.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoHype(); constructors. Int_t GetByteCount() const; {return 64;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Double_t GetStIn() const; {return fStIn;}. Double_t GetStOut() const; {return fStOut;}. Bool_t HasInner() const; {return !TestShapeBit(kGeoRSeg);}. Bool_t IsCylType() const; {return kTRUE;}. Â» Author: Mihaela Gheata 20/11/04 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/geom:$Id$ Â» Last generated: 2015-06-02 16:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoHype.html:21999,safe,safe,21999,root/html604/TGeoHype.html,https://root.cern,https://root.cern/root/html604/TGeoHype.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoHype(); constructors. Int_t GetByteCount() const; {return 64;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Double_t GetStIn() const; {return fStIn;}. Double_t GetStOut() const; {return fStOut;}. Bool_t HasInner() const; {return !TestShapeBit(kGeoRSeg);}. Bool_t IsCylType() const; {return kTRUE;}. Â» Author: Mihaela Gheata 20/11/04 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/geom:$Id$ Â» Last generated: 2015-06-30 15:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHype.html:21999,safe,safe,21999,root/html602/TGeoHype.html,https://root.cern,https://root.cern/root/html602/TGeoHype.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"D(n*(n+1)+2, n*(2*n+3), n*(n+2));. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoParaboloid(); constructors. Double_t GetRlo() const; {return fRlo;}. Double_t GetRhi() const; {return fRhi;}. Double_t GetDz() const; {return fDz;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. Â» Author: Mihaela Gheata 20/06/04 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/geom:$Id$ Â» Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoParaboloid.html:17957,safe,safe,17957,root/html534/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"D(n*(n+1)+2, n*(2*n+3), n*(n+2));. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoParaboloid(); constructors. Double_t GetRlo() const; {return fRlo;}. Double_t GetRhi() const; {return fRhi;}. Double_t GetDz() const; {return fDz;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. Â» Author: Mihaela Gheata 20/06/04 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/geom:$Id$ Â» Last generated: 2015-06-02 16:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoParaboloid.html:19711,safe,safe,19711,root/html604/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html604/TGeoParaboloid.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"D(n*(n+1)+2, n*(2*n+3), n*(n+2));. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoParaboloid(); constructors. Double_t GetRlo() const; {return fRlo;}. Double_t GetRhi() const; {return fRhi;}. Double_t GetDz() const; {return fDz;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. Â» Author: Mihaela Gheata 20/06/04 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/geom:$Id$ Â» Last generated: 2015-06-30 15:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoParaboloid.html:19711,safe,safe,19711,root/html602/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html602/TGeoParaboloid.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"D::kRawSizes) {; ...; buffer.SetSectionsValid(TBuffer3D::kRawSizes);; }; }; // Complete kRaw tesselation section; if ((reqSections & TBuffer3D::kRaw) &&; buffer.SectionsValid(TBuffer3D::kRawSizes)) {; SetPoints(buffer.fPnts);; // Transform points to master frame if viewer requires it; // The fLocalFrame flag and translation matrix will have; // already been set in TGeoShape::FillBuffer3D() as required; if (!buffer.fLocalFrame); TransformPoints(buffer.fPnts, buffer.NbPnts());; SetSegsAndPols(buffer);; buffer.SetSectionsValid(TBuffer3D::kRaw);; }; return buffer;; }; Note:. we use a static TBuffer3D derived object for efficiency - once the object is added the buffer can be reused.; kRawSize (the calculation of tessellation sizing required in buffer) and kRaw (the actual filling of tessellation) is split, as the X3D viewer requires two publication passes - one to establish the full tessellation capacity for all shapes, and another to actually add them. Splitting avoids having to do the expensive tessellation on the first pass. 9.13.4.4 Shape Specific TBuffer3D Derived Classes; Currently we provide the following shape specific classes, which the GL Viewer can take advantage of (see TBuffer3D.h and TBuffer3DTypes.h). TBuffer3DSphere - solid, hollow and cut spheres (GL Viewer only supports solid spheres at present - cut / hollow ones will be requested as tessellated objects by client.); TBuffer3DTube - basic tube with inner/outer radius and length.; TBuffer3DTubeSeg - angle tube segment.; TBuffer3DCutTube - angle tube segment with plane cut ends. See the above example from TGeoSphere::GetBuffer3D and also equivalent functions in TGeoTube, TGeoTubeSeg and TGeoCtub. Anyone is free to add new TBuffer3D classes, but it should be clear that one or more viewers will require updating to be able to take advantage of them. Hence we only provide classes which existing viewers can benefit from. The number of native shapes in GL Viewer will be expanded in the future.; 9.13.4.5 Master ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:410585,avoid,avoids,410585,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoids']
Safety,"DF to be considered fixed when calculating the SWeights and be sure to NOT include the yields in that list.; After fixing non-yield parameters, this function will start a fit by calling pdf->fitTo(*fSData, RooFit::Extended(true), RooFit::SumW2Error(true), RooFit::PrintLevel(-1), RooFit::PrintEvalErrors(-1)).; RooStats::SPlot::fSDataRooDataSet * fSDataDefinition SPlot.h:82; RooFit::SumW2ErrorRooCmdArg SumW2Error(bool flag)Definition RooGlobalFunc.cxx:733; RooFit::PrintEvalErrorsRooCmdArg PrintEvalErrors(Int_t numErrors)Definition RooGlobalFunc.cxx:725; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::ExtendedRooCmdArg Extended(bool flag=true)Definition RooGlobalFunc.cxx:466; One can pass additional arguments to fitTo, such as RooFit::Range(""fitrange""), as arg5, arg6, arg7, arg8.; NoteA RooFit::Range may be necessary to get expected results if you initially fit in a range and/or called pdf->fixCoefRange(""fitrange"") on pdf. Pass arg5, arg6, arg7, arg8 AT YOUR OWN RISK.; Parameters. [in]pdfPDF to fit to data to compute s weights. ; [in]yieldsTmpYields to use to compute s weights. ; [in]projDepsThese will not be normalized over when calculating the sWeights, and will be considered parameters, not observables. ; [in]includeWeightsInclude weights of the input data in calculation of s weights. ; [in]arg5,arg6,arg7,arg8Optional additional arguments for the fitting step. PyROOT; The SPlot::AddSWeight function is pythonized with the command argument pythonization. For example, the following code is equivalent in PyROOT: splot = ROOT.RooStats.SPlot(""sData"", ""An SPlot"", data, massModel, [zYield, qcdYield]); ; # Directly passing a RooCmdArg:; splot.AddSWeight(pdf, [zYield, qcdYield], ROOT.RooStats.RooCmdArg(""Strategy"", 0), ROOT.RooStats.RooCmdArg(""InitialHesse"", 1)); ; # With keyword arguments:; splot.AddSWeight(pdf, [zYield, qcdYield], Strategy=3, InitialHesse=1). Definition at line 404 of file SPlot.cxx. â—†Â Class(). static TClass * RooS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1SPlot.html:22861,RISK,RISK,22861,doc/master/classRooStats_1_1SPlot.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1SPlot.html,1,['RISK'],['RISK']
Safety,"DFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf315_projectpdfDefinition rf315_projectpdf.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigmax' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_Int[y]_Norm[x,y]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_Int[y]_Norm[x,y]_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a1: using 0.4; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for y: using 0.4; [#1] INFO:NumericIntegration -- RooR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf315__projectpdf_8C.html:6838,safe,safe,6838,doc/master/rf315__projectpdf_8C.html,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8C.html,1,['safe'],['safe']
Safety,"Data""); voidAddExpData(Double_t* sigExp, Double_t* bkgExp, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); voidAddExpDataWithSideband(Double_t* sigExp, Double_t* bkgExp, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); voidAddModel(Double_t* sigExp, Int_t nchan, RooWorkspace* ws, const char* pdfName = ""CombinedPdf"", const char* masterSignalName = ""masterSignal""); static TClass*Class(); virtual TClass*IsA() const; RooStats::NumberCountingPdfFactoryNumberCountingPdfFactory(); RooStats::NumberCountingPdfFactoryNumberCountingPdfFactory(const RooStats::NumberCountingPdfFactory&); RooStats::NumberCountingPdfFactory&operator=(const RooStats::NumberCountingPdfFactory&); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. RooRealVar*SafeObservableCreation(RooWorkspace* ws, const char* varName, Double_t value); RooRealVar*SafeObservableCreation(RooWorkspace* ws, const char* varName, Double_t value, Double_t maximum). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; NumberCountingPdfFactory(); constructor. ~NumberCountingPdfFactory(); destructor. void AddModel(Double_t* sigExp, Int_t nchan, RooWorkspace* ws, const char* pdfName = ""CombinedPdf"", const char* masterSignalName = ""masterSignal""); This method produces a PDF for N channels with uncorrelated background; uncertainty. It relates the signal in each channel to a master signal strength times the; expected signal in each channel. For the future, perhaps this method should be extended to include the efficiency terms automatically. void AddExpData(Double_t* sigExp, Double_t* bkgExp, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); Arguements are an array of expected signal, expected background, and relative; background uncertainty (eg. 0.1 for 10% uncertainty), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__NumberCountingPdfFactory.html:2494,Safe,SafeObservableCreation,2494,root/html526/RooStats__NumberCountingPdfFactory.html,https://root.cern,https://root.cern/root/html526/RooStats__NumberCountingPdfFactory.html,2,['Safe'],['SafeObservableCreation']
Safety,"DeclFileName(). static const char * TFractionFitter::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 112 of file TFractionFitter.h. â—†Â ErrorAnalysis(). void TFractionFitter::ErrorAnalysis ; (; Double_tÂ ; UP). Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. ; Definition at line 583 of file TFractionFitter.cxx. â—†Â EvaluateFCN(). Double_t TFractionFitter::EvaluateFCN ; (; const Double_t *Â ; par). inline . Definition at line 66 of file TFractionFitter.h. â—†Â ExcludeBin(). void TFractionFitter::ExcludeBin ; (; Int_tÂ ; bin). Exclude the given bin from the fit. ; The bin numbering to be used is that of TH1::GetBin(). ; Definition at line 418 of file TFractionFitter.cxx. â—†Â FindPrediction(). void TFractionFitter::FindPrediction ; (; intÂ ; bin, . double &Â ; t_i, . int &Â ; k_0, . double &Â ; A_kiÂ . ); const. private . Function used internally to obtain the template prediction in the individual bins 'bin' <=> 'i' (paper) 'par' <=> 'j' (paper) ; Definition at line 757 of file TFractionFitter.cxx. â—†Â Fit(). TFitResultPtr TFractionFitter::Fit ; (; ). Perform the fit with the default UP value. ; The value returned is the minimisation status. ; Definition at line 553 of file TFractionFitter.cxx. â—†Â GetChisquare(). Double_t TFractionFitter::GetChisquare ; (; ); const. Return the likelihood ratio Chi-squared (chi2) for the fit. ; The value is computed when the fit is executed successfully. Chi2 calculation is based on the ""likelihood ratio"" lambda, lambda = L(y;n) / L(m;n), where L(y;n) is the likelihood of the fit result <y> describing the data <n> and L(m;n) is the likelihood of an unknown ""true"" underlying distribution <m> describing the data <n>. Since <m> is unknown, the data distribution is used instead, lambda = L(y;n) / L(n;n). Note that this ratio is 1 if the fit is perfect. The chi2 value is then computed according to chi2 = -2*ln(lambda). This parameter can be shown to follow a Chi-s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFractionFitter.html:25496,predict,prediction,25496,doc/master/classTFractionFitter.html,https://root.cern,https://root.cern/doc/master/classTFractionFitter.html,1,['predict'],['prediction']
Safety,"DeclId_t and for keep track of TFunction that were described unloaded function ; Â CTListOfFunctionsIterIterator for TListOfFunctions ; Â CTListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFunction that were described unloaded function ; Â CTListOfTypesA collection of TDataType designed to hold the typedef information and numerical type information ; Â CTLockFileA scoped lock based on files ; Â CTLockGuard; Â â–ºCTLorentzRotation; Â CTLorentzRotationRow; Â CTLorentzVector; Â CTMacOSXSystem; Â CTMacroClass supporting a collection of lines with C++ code ; Â CTMakeProject; Â CTMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval (therefore TMap does not conserve the order of the entries) ; Â CTMapFileThis class implements a shared memory region mapped to a file ; Â CTMapIterIterator of map ; Â CTMapRecKeep track of an object in the mapped file ; Â CTMarkerManages Markers ; Â CTMarker3DBoxA special 3-D marker designed for event display ; Â CTMaterialManages a detector material ; Â CTMathTextTo draw TeX Mathematical Formula ; Â CTMatrixDEigen; Â CTMatrixDSymEigen; Â CTMatrixT; Â CTMatrixTBase; Â CTMatrixTColumn; Â CTMatrixTColumn_const; Â CTMatrixTDiag; Â CTMatrixTDiag_const; Â CTMatrixTFlat; Â CTMatrixTFlat_const; Â CTMatrixTLazy; Â CTMatrixTRow; Â CTMatrixTRow_const; Â CTMatrixTSparse; Â CTMatrixTSparseDiag; Â CTMatrixTSparseDiag_const; Â CTMatrixTSparseRow; Â CTMatrixTSparseRow_const; Â CTMatrixTSub; Â CTMatrixTSub_const; Â CTMatrixTSym; Â CTMatrixTSymLazy; Â CTMCParticle; Â CTMCVerbose; Â CTMD5This code implements the MD5 message-digest algorithm ; Â CTMehrotraSolver; Â CTMemberInspectorAbstract base class for accessing the data-members of a class ; Â CTMemberStreamer; Â â–ºCTMemFileA TMemFile is like a normal TFile except that it reads and writes only from memory ; Â CTMemBlock; Â CTMemStat; Â CTMemStatHook; Â CTMemStatShowUtility class post-processing the file generated by TMemStat (default memstat.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:141727,detect,detector,141727,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['detect'],['detector']
Safety,"Default constructor. ; Â ; Â TEventIterUnit (TDSet *dset, TSelector *sel, Long64_t num); Â Main constructor. ; Â ; Â ~TEventIterUnit () override; Â ; Long64_tÂ GetCacheSize () override; Â ; Int_tÂ GetLearnEntries () override; Â ; Long64_tÂ GetNextEvent () override; Â Get next event. ; Â ; Int_tÂ GetNextPacket (Long64_t &first, Long64_t &num) override; Â Get loop range. ; Â ; TClass *Â IsA () const override; Â ; voidÂ Streamer (TBuffer &) override; Â Stream an object of class TObject. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; Â Public Member Functions inherited from TEventIter; Â TEventIter (); Â Default constructor. ; Â ; Â TEventIter (TDSet *dset, TSelector *sel, Long64_t first, Long64_t num); Â Constructor. ; Â ; Â ~TEventIter () override; Â Destructor. ; Â ; virtual Long64_tÂ GetEntryNumber (Long64_t); Â ; TList *Â GetPackets (); Â ; virtual voidÂ InvalidatePacket (); Â Invalidated the current packet (if any) by setting the TDSetElement::kCorrupted bit. ; Â ; virtual voidÂ StopProcess (Bool_t abort); Â Set flag to stop the process. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; Â Public Member Functions inherited from TObject; Â TObject (); Â TObject constructor. ; Â ; Â TObject (const TObject &object); Â TObject copy ctor. ; Â ; virtualÂ ~TObject (); Â TObject destructor. ; Â ; voidÂ AbstractMethod (const char *method) const; Â Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ; Â ; virtual voidÂ AppendPad (Option_t *option=""""); Â Append graphics object to current pad. ; Â ; virtual voidÂ Browse (TBrowser *b); Â Browse object. May be overridden for another default action. ; Â ; ULong_tÂ CheckedHash (); Â Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ; Â ; virtual const char *Â ClassName () const; Â Returns name of class to which the object belongs. ; Â ; virtual voidÂ Clear (Option_t *=""""); Â ; virtual TObject *Â Clone (const char *newname=""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEventIterUnit.html:1374,abort,abort,1374,doc/master/classTEventIterUnit.html,https://root.cern,https://root.cern/doc/master/classTEventIterUnit.html,1,['abort'],['abort']
Safety,"Default constructor. ; Â ; Â TGeoUnion (const char *expr1, const char *expr2); Â Constructor. ; Â ; Â TGeoUnion (TGeoShape *left, TGeoShape *right, TGeoMatrix *lmat=nullptr, TGeoMatrix *rmat=nullptr); Â Constructor providing pointers to components. ; Â ; Â ~TGeoUnion () override; Â Destructor â€” deletion of components handled by TGeoManager class. ; Â ; voidÂ ComputeBBox (Double_t &dx, Double_t &dy, Double_t &dz, Double_t *origin) override; Â Compute bounding box corresponding to a union of two shapes. ; Â ; voidÂ ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override; Â Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. ; Â ; Bool_tÂ Contains (const Double_t *point) const override; Â Find if a union of two shapes contains a given point. ; Â ; Int_tÂ DistanceToPrimitive (Int_t px, Int_t py) override; Â Compute minimum distance to shape vertices. ; Â ; Double_tÂ DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override; Â Computes distance from a given point inside the shape to its boundary. ; Â ; Double_tÂ DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override; Â Compute distance from a given outside point to the shape. ; Â ; EGeoBoolTypeÂ GetBooleanOperator () const override; Â ; Int_tÂ GetNpoints () override; Â Returns number of vertices for the composite shape described by this union. ; Â ; TClass *Â IsA () const override; Â ; TGeoBoolNode *Â MakeClone () const override; Â Make a clone of this. Pointers are preserved. ; Â ; voidÂ Paint (Option_t *option) override; Â Paint method. ; Â ; Double_tÂ Safety (const Double_t *point, Bool_t in=kTRUE) const override; Â Compute safety distance for a union node;. ; Â ; voidÂ SavePrimitive (std::ostream &out, Option_t *option="""") override; Â Save a primitive as a C++ statement(s) on output stream ""out"". ; Â ; voidÂ Sizeof3D () const override; Â Register 3D size of this shap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoUnion.html:1347,safe,safe,1347,doc/master/classTGeoUnion.html,https://root.cern,https://root.cern/doc/master/classTGeoUnion.html,1,['safe'],['safe']
Safety,"DefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGCheckButton*fCursorCheckBoxCheck box ""Show mouse cursor"" for replaying; time_tfElapsedplaying/recording time; Window_tfFilteredIds[12]IDs of these windows in GUI recorder; TRecorder*fRecorderRecorder; TGPictureButton*fReplayButton for start of replaying; time_tfStartplaying/recording time; TGPictureButton*fStartStopButton for start and stop of recording; TGLabel*fStatusLabel with actual status; TGLabel*fTimeDisplayLabel with time counter; TTimer*fTimerTimer for handling GUI of recorder; static const Int_tfgWidgetsCountNumber of windows in GUI recorder. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGRecorder(const TGWindow* p = 0, UInt_t w = 230, UInt_t h = 150); The GUI for the recorder. void SetDefault(); Sets GUI to the default inactive state. void Update(); Called when fTimer timeouts (every 0.025 second); Updates GUI of recorder. void StartStop(); Handles push of the fStartStop button; according to the current recorder state. void Replay(); Handles push of fReplay button; according to the current recorder state. ~TGRecorder(); Destructor. Cleanup the GUI. TRecorder & operator=(const TGRecorder& ). TGRecorder(const TGWindow* p = 0, UInt_t w = 230, UInt_t h = 150). Â» Author: Katerina Opocenska 11/09/2008 Â» Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; Â» Last changed: root/gui:$Id$ Â» Last generated: 2015-06-02 15:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGRecorder.html:23072,timeout,timeouts,23072,root/html604/TGRecorder.html,https://root.cern,https://root.cern/root/html604/TGRecorder.html,1,['timeout'],['timeouts']
Safety,"DefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGCheckButton*fCursorCheckBoxCheck box ""Show mouse cursor"" for replaying; time_tfElapsedplaying/recording time; Window_tfFilteredIds[12]IDs of these windows in GUI recorder; TRecorder*fRecorderRecorder; TGPictureButton*fReplayButton for start of replaying; time_tfStartplaying/recording time; TGPictureButton*fStartStopButton for start and stop of recording; TGLabel*fStatusLabel with actual status; TGLabel*fTimeDisplayLabel with time counter; TTimer*fTimerTimer for handling GUI of recorder; static const Int_tfgWidgetsCountNumber of windows in GUI recorder. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGRecorder(const TGWindow* p = 0, UInt_t w = 230, UInt_t h = 150); The GUI for the recorder. void SetDefault(); Sets GUI to the default inactive state. void Update(); Called when fTimer timeouts (every 0.025 second); Updates GUI of recorder. void StartStop(); Handles push of the fStartStop button; according to the current recorder state. void Replay(); Handles push of fReplay button; according to the current recorder state. ~TGRecorder(); Destructor. Cleanup the GUI. TRecorder & operator=(const TGRecorder& ). TGRecorder(const TGWindow* p = 0, UInt_t w = 230, UInt_t h = 150). Â» Author: Katerina Opocenska 11/09/2008 Â» Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; Â» Last changed: root/gui:$Id$ Â» Last generated: 2015-06-30 14:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGRecorder.html:23072,timeout,timeouts,23072,root/html602/TGRecorder.html,https://root.cern,https://root.cern/root/html602/TGRecorder.html,1,['timeout'],['timeouts']
Safety,"Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::ClassNameRooCmdArg ClassName(const char *name)Definition RooGlobalFunc.cxx:1004; RooFit::TopicRooCmdArg Topic(Int_t topic)Definition RooGlobalFunc.cxx:996; RooFit::OutputFileRooCmdArg OutputFile(const char *fileName)Definition RooGlobalFunc.cxx:517; RooFit::VerboseRooCmdArg Verbose(bool flag=true)Definition RooGlobalFunc.cxx:645; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf506_msgserviceDefinition rf506_msgservice.py:1; RooMsgService::StreamConfig::addTopicvoid addTopic(RooFit::MsgTopic newTopic)Definition RooMsgService.h:118; RooMsgService::StreamConfig::removeTopicvoid removeTopic(RooFit::MsgTopic oldTopic)Definition RooMsgService.h:122; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf506__msgservice_8C.html:6530,safe,safe,6530,doc/master/rf506__msgservice_8C.html,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html,1,['safe'],['safe']
Safety,"Definition TClassTable.h:53; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::SetUnloadedvoid SetUnloaded()Call this method to indicate that the shared library containing this class's code has been removed (u...Definition TClass.cxx:6309; TClass::SetClassVersionvoid SetClassVersion(Version_t version)Private function.Definition TClass.cxx:5675; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TInterpreter::RegisterTClassUpdatevirtual void RegisterTClassUpdate(TClass *oldcl, DictFuncPtr_t dict)=0; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringColle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClassTable_8cxx_source.html:46208,safe,safe,46208,doc/v632/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html,1,['safe'],['safe']
Safety,"Definition TClassTable.h:53; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::SetUnloadedvoid SetUnloaded()Call this method to indicate that the shared library containing this class's code has been removed (u...Definition TClass.cxx:6376; TClass::SetClassVersionvoid SetClassVersion(Version_t version)Private function.Definition TClass.cxx:5742; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TInterpreter::RegisterTClassUpdatevirtual void RegisterTClassUpdate(TClass *oldcl, DictFuncPtr_t dict)=0; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringColle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:46208,safe,safe,46208,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,1,['safe'],['safe']
Safety,"Definition TGeoManager.cxx:2736; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; TGeoManager::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoManager.cxx:2300; Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current step length. The new point and its corresponding state will be automatically computed:; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; TGeoManager::StepTGeoNode * Step(Bool_t is_geom=kTRUE, Bool_t cross=kTRUE)Make a rectilinear step of length fStep from current point (fPoint) on current direction (fDirection)...Definition TGeoManager.cxx:3638; We will explain the method above by its use cases. The input flag is_geom allows specifying if the step is limited by geometrical reasons (a boundary crossing) or is an arbitrary step. The flag cross can be used in case the step is made ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:86853,safe,safe,86853,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,7,"['Safe', 'safe']","['Safety', 'safe', 'safety']"
Safety,"Definition TTimer.h:75; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; TTimer::CheckTimerBool_t CheckTimer(const TTime &now)Check if timer timed out.Definition TTimer.cxx:130; TTimer::SetObjectvoid SetObject(TObject *object)Set the object to be notified at time out.Definition TTimer.cxx:186; TTimer::SingleShotstatic void SingleShot(Int_t milliSec, const char *receiver_class, void *receiver, const char *method)This static function calls a slot after a given time interval.Definition TTimer.cxx:258; TTimer::Addvoid Add() overrideDefinition TTimer.h:85; TTimer::fObjectTObject * fObjectDefinition TTimer.h:60; TTimer::SetTimevoid SetTime(Long_t milliSec)Definition TTimer.h:91; TTimer::fAbsTimeTTime fAbsTimeDefinition TTimer.h:55; TTimer::IsInterruptingSyscallsBool_t IsInterruptingSyscalls() constDefinition TTimer.h:82; TTimer::HasTimedOutBool_t HasTimedOut() constDefinition TTimer.h:79; TTimer::GetTimeTTime GetTime() constDefinition TTimer.h:76; TTimer::Removevoid Remove() overrideDefinition TTimer.h:86; TTimer::fTimeoutBool_t fTimeoutDefinition TTimer.h:56; TTimer::TTimerTTimer(const TTimer &)=delete; TTimer::IsSyncBool_t IsSync() constDefinition TTimer.h:80; TTimer::NotifyBool_t Notify() overrideNotify when timer times out.Definition TTimer.cxx:145; TTimer::fSyncBool_t fSyncDefinition TTimer.h:57; TTimer::IsRunningBool_t IsRunning()This function checks if the timer is running within gSystem (Has been started and did not finish yet)...Definition TTimer.cxx:279; TTimer::operator=TTimer & operator=(const TTimer &)=delete; TTimer::Stopvirtual void Stop()Definition TTimer.h:94; TTimer::GetTimerIDUInt_t GetTimerID()Definition TTimer.h:77; TTimer::fIntSyscallsBool_t fIntSyscallsDefinition TTimer.h:58; TTimer::Timeoutvirtual void Timeout()Definition TTimer.h:97; TTimer::fTimeIDUInt_t fTimeIDDefinition TTimer.h:59; bool; unsigned int. corebaseincTTimer.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:04 (GVA Time) using Doxygen 1.9.8 Â Â ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8h_source.html:8341,Timeout,Timeoutvirtual,8341,doc/master/TTimer_8h_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8h_source.html,2,['Timeout'],"['Timeout', 'Timeoutvirtual']"
Safety,"Definition TUnixSystem.cxx:5318; TUnixSystem::Exitvoid Exit(int code, Bool_t mode=kTRUE) overrideExit the application.Definition TUnixSystem.cxx:2187; TUnixSystem::AnnounceTcpServiceint AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize=-1) overrideAnnounce TCP/IP service.Definition TUnixSystem.cxx:3241; TUnixSystem::TUnixSystemTUnixSystem()Definition TUnixSystem.cxx:575; TUnixSystem::AddDynamicPathvoid AddDynamicPath(const char *lib) overrideAdd a new directory to the dynamic path.Definition TUnixSystem.cxx:4725; TUnixSystem::SetDynamicPathvoid SetDynamicPath(const char *lib) overrideSet the dynamic path to a new value.Definition TUnixSystem.cxx:4748; TUnixSystem::ClosePipeint ClosePipe(FILE *pipe) overrideClose the pipe.Definition TUnixSystem.cxx:2171; TUnixSystem::GetHomeDirectorystd::string GetHomeDirectory(const char *userName=nullptr) const overrideReturn the user's home directory.Definition TUnixSystem.cxx:1491; TUnixSystem::SelectInt_t Select(TList *active, Long_t timeout) overrideSelect on file descriptors.Definition TUnixSystem.cxx:1202; TUnixSystem::Unsetenvvoid Unsetenv(const char *name) overrideUnset environment variable.Definition TUnixSystem.cxx:2145; TUnixSystem::~TUnixSystemvirtual ~TUnixSystem()Reset to original state.Definition TUnixSystem.cxx:581; TUnixSystem::Abortvoid Abort(int code=0) overrideAbort the application.Definition TUnixSystem.cxx:2202; TUnixSystem::Syslogvoid Syslog(ELogLevel level, const char *mess) overrideSend mess to syslog daemon.Definition TUnixSystem.cxx:2654; TUnixSystem::GetGroupInfoUserGroup_t * GetGroupInfo(Int_t gid) overrideReturns all group info in the UserGroup_t structure.Definition TUnixSystem.cxx:2099; TUnixSystem::GetUidInt_t GetUid(const char *user=nullptr) overrideReturns the user's id. If user = 0, returns current user's id.Definition TUnixSystem.cxx:2005; TUnixSystem::ExpandPathNameBool_t ExpandPathName(TString &patbuf) overrideExpand a pathname getting rid of special shell characters li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:206683,timeout,timeout,206683,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,2,['timeout'],['timeout']
Safety,"Definition at line 85 of file TXMLFile.h. â—†Â ReadFromFile(). Bool_t TXMLFile::ReadFromFile ; (; ). protected . read document from file Now full content of document reads into the memory Then document decomposed to separate keys and streamer info structures All irrelevant data will be cleaned ; Definition at line 559 of file TXMLFile.cxx. â—†Â ReadKeysList(). Int_t TXMLFile::ReadKeysList ; (; TDirectory *Â ; dir, . XMLNodePointer_tÂ ; topnodeÂ . ). protected . Read list of keys for directory. ; Definition at line 630 of file TXMLFile.cxx. â—†Â ReadStreamerElement(). void TXMLFile::ReadStreamerElement ; (; XMLNodePointer_tÂ ; node, . TStreamerInfo *Â ; infoÂ . ). protected . read and reconstruct single TStreamerElement from xml node ; Definition at line 825 of file TXMLFile.cxx. â—†Â Recover(). Int_t TXMLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is importa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:66633,recover,recovered,66633,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['recover'],['recovered']
Safety,"Definition at line 98 of file TGeoXtru.h. â—†Â GetYOffset(). Double_t TGeoXtru::GetYOffset ; (; Int_tÂ ; i); const. inline . Definition at line 100 of file TGeoXtru.h. â—†Â GetZ() [1/2]. Double_t * TGeoXtru::GetZ ; (; ); const. inline . Definition at line 102 of file TGeoXtru.h. â—†Â GetZ() [2/2]. Double_t TGeoXtru::GetZ ; (; Int_tÂ ; ipl); const. â—†Â InspectShape(). void TGeoXtru::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â IsA(). TClass * TGeoXtru::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 121 of file TGeoXtru.h. â—†Â IsPointInsidePlane(). Bool_t TGeoXtru::IsPointInsidePlane ; (; const Double_t *Â ; point, . Double_t *Â ; vert, . Double_t *Â ; normÂ . ); const. protected . â—†Â MakeBuffer3D(). TBuffer3D * TGeoXtru::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â operator=(). TGeoXtru & TGeoXtru::operator= ; (; const TGeoXtru &Â ; ). protecteddelete . â—†Â Safety(). Double_t TGeoXtru::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Safety_v(). void TGeoXtru::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â SafetyToSector(). Double_t TGeoXtru::SafetyToSector ; (; const Double_t *Â ; point, . Int_tÂ ; iz, . Double_tÂ ; safmin, . Bool_tÂ ; inÂ . ). protected . â—†Â SavePrimitive(). void TGeoXtru::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. â—†Â SetCurrentVertices(). void TGeoXtru::SetCurrentVertices ; (; Double_tÂ ; x0, . Double_tÂ ; y0, . Double_tÂ ; scaleÂ . ). â—†Â SetCurrentZ(). void TGeoXtru::SetCurrentZ ; (; Double_tÂ ; z, . Int_tÂ ; izÂ . ). â—†Â SetDimensions(). void TGeoXtru::SetDimensions ; (; Double_t *Â ; param). overridevirtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoXtru.html:29957,Safe,Safety,29957,doc/master/classTGeoXtru.html,https://root.cern,https://root.cern/doc/master/classTGeoXtru.html,1,['Safe'],['Safety']
Safety,"Destructor. ; Â ; Long64_tÂ GetCacheSize () override; Â Return the size in bytes of the cache, if any Return -1 if not used. ; Â ; Int_tÂ GetLearnEntries () override; Â Return the number of entries in the learning phase. ; Â ; Long64_tÂ GetNextEvent () override; Â Get next event. ; Â ; Int_tÂ GetNextPacket (Long64_t &first, Long64_t &num) override; Â Get loop range. ; Â ; TClass *Â IsA () const override; Â ; voidÂ Streamer (TBuffer &) override; Â Stream an object of class TObject. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; Â Public Member Functions inherited from TEventIter; Â TEventIter (); Â Default constructor. ; Â ; Â TEventIter (TDSet *dset, TSelector *sel, Long64_t first, Long64_t num); Â Constructor. ; Â ; Â ~TEventIter () override; Â Destructor. ; Â ; virtual Long64_tÂ GetEntryNumber (Long64_t); Â ; TList *Â GetPackets (); Â ; virtual voidÂ InvalidatePacket (); Â Invalidated the current packet (if any) by setting the TDSetElement::kCorrupted bit. ; Â ; virtual voidÂ StopProcess (Bool_t abort); Â Set flag to stop the process. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; Â Public Member Functions inherited from TObject; Â TObject (); Â TObject constructor. ; Â ; Â TObject (const TObject &object); Â TObject copy ctor. ; Â ; virtualÂ ~TObject (); Â TObject destructor. ; Â ; voidÂ AbstractMethod (const char *method) const; Â Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ; Â ; virtual voidÂ AppendPad (Option_t *option=""""); Â Append graphics object to current pad. ; Â ; virtual voidÂ Browse (TBrowser *b); Â Browse object. May be overridden for another default action. ; Â ; ULong_tÂ CheckedHash (); Â Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ; Â ; virtual const char *Â ClassName () const; Â Returns name of class to which the object belongs. ; Â ; virtual voidÂ Clear (Option_t *=""""); Â ; virtual TObject *Â Clone (const char *newname=""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEventIterTree.html:1620,abort,abort,1620,doc/master/classTEventIterTree.html,https://root.cern,https://root.cern/doc/master/classTEventIterTree.html,1,['abort'],['abort']
Safety,"Destructor. void Build(TSessionViewer* gui); Build query information frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }. TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h). TCanvas * GetStatsCanvas() const; { return fStatsCanvas; }. TEditQueryFrame * GetQueryEditFrame() const; { return fFD; }. void Progress(Long64_t total, Long64_t processed). Â» Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 Â» Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; Â» Last changed: root/sessionviewer:$Id$ Â» Last generated: 2015-06-02 16:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TSessionQueryFrame.html:23374,Abort,Abort,23374,root/html604/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html604/TSessionQueryFrame.html,1,['Abort'],['Abort']
Safety,"Destructor. void Build(TSessionViewer* gui); Build query information frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }. TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h). TCanvas * GetStatsCanvas() const; { return fStatsCanvas; }. TEditQueryFrame * GetQueryEditFrame() const; { return fFD; }. void Progress(Long64_t total, Long64_t processed). Â» Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 Â» Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; Â» Last changed: root/sessionviewer:$Id$ Â» Last generated: 2015-06-30 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSessionQueryFrame.html:23374,Abort,Abort,23374,root/html602/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html602/TSessionQueryFrame.html,1,['Abort'],['Abort']
Safety,"Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }. TCanvas * GetStatsCanvas() const; { return fStatsCanvas; }. TEditQueryFrame * GetQueryEditFrame() const; { return fFD; }. void Progress(Long64_t total, Long64_t processed). Â» Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 Â» Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; Â» Last changed: root/sessionviewer:$Id: TSessionViewer.h 40088 2011-06-30 15:10:06Z bellenot $ Â» Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSessionQueryFrame.html:22221,Abort,Abort,22221,root/html532/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html532/TSessionQueryFrame.html,1,['Abort'],['Abort']
Safety,"Dir() const; { return fSessionDir; }. const char * GetPackageDir() const; { return fPackageDir; }. const char * GetDataDir() const; { return fDataDir; }. const char * GetDataDirOpts() const; { return fDataDirOpts; }. Int_t GetProtocol() const; { return fProtocol; }. const char * GetOrdinal() const; { return fOrdinal; }. Int_t GetGroupId() const; { return fGroupId; }. Int_t GetGroupSize() const; { return fGroupSize; }. Int_t GetLogLevel() const; { return fLogLevel; }. TSocket * GetSocket() const; { return fSocket; }. Float_t GetRealTime() const; { return fRealTime; }. Float_t GetCpuTime() const; { return fCpuTime; }. Int_t GetQuerySeqNum() const; { return fQuerySeqNum; }. Int_t GetTotSessions() const; { return fTotSessions; }. Int_t GetActSessions() const; { return fActSessions; }. Float_t GetEffSessions() const; { return fEffSessions; }. TList * GetEnabledPackages() const; { return fEnabledPackages; }. Int_t GetInflateFactor() const; { return fInflateFactor; }. Long64_t GetMsgSizeHWM() const; { return fMsgSizeHWM; }. const char * GetPrefix() const; { return fPrefix; }. TProofLockPath * GetCacheLock(); { return fCacheLock; }. EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE). void HandleTermination(); { Terminate(0); }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsEndMaster() const; { return fEndMaster; }. Bool_t IsMaster() const; { return fMasterServ; }. Bool_t IsTopMaster() const; { return fOrdinal == ""0""; }. void ReleaseWorker(const char* ); { }. void DisableTimeout(); Disable / Enable read timeout. { }. void EnableTimeout(); { }. void LogToMaster(Bool_t on = kTRUE); Log control. { fSendLogToMaster = on; }. Â» Author: Fons Rademakers 16/02/97 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/proof:$Id$ Â» Last generated: 2015-03-25 16:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:34943,timeout,timeout,34943,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,1,['timeout'],['timeout']
Safety,"DivVec(const TMatrixD& mat, const TVectorD& vec, Int_t zero = 0); static voidRegularisedSymMatInvert(TMatrixDSym& mat, Double_t eps = 1e-3); static voidV2H(const TVectorD& vec, TH1D& histo); static TVectorDVecDiv(const TVectorD& vec1, const TVectorD& vec2, Int_t zero = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. const TH2D*fAdetDetector response matrix; TH2D*fBcovcovariance matrix of measured distribution (data); const TH1D*fBdatmeasured distribution (data); const TH1D*fBinireconstructed distribution (MC); TH1D*fDHist! Distribution of d (for checking regularization); Int_tfDdim! Derivative for curvature matrix; Int_tfKReg! Regularisation parameter; Bool_tfMatToyMode! Internal switch for evaluation of statistical uncertainties from response matrix; Int_tfNdim! Truth and reconstructed dimensions; Bool_tfNormalize! Normalize unfolded spectrum to 1; TH1D*fSVHist! Distribution of singular values; Bool_tfToyMode! Internal switch for covariance matrix propagation; TH1D*fToyhisto! Toy MC histogram; TH2D*fToymat! Toy MC detector response matrix; const TH1D*fXinitruth distribution (MC); TH2D*fXinv! Computed inverse of covariance matrix; TH2D*fXtau! Computed regularized covariance matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Alternative constructor; User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. TSVDUnfold(const TH1D* bdat, TH2D* Bcov, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor; Initialisation of TSVDUnfold; User provides data and MC test spec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSVDUnfold.html:7177,detect,detector,7177,root/html530/TSVDUnfold.html,https://root.cern,https://root.cern/root/html530/TSVDUnfold.html,3,['detect'],['detector']
Safety,"Double_t TGeoPgon::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoPcon. â—†Â DistFromOutside_v(). void TGeoPgon::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoPcon. â—†Â Divide(). TGeoVolume * TGeoPgon::Divide ; (; TGeoVolume *Â ; voldiv, . const char *Â ; divname, . Int_tÂ ; iaxis, . Int_tÂ ; ndiv, . Double_tÂ ; start, . Double_tÂ ; stepÂ . ). overridevirtual . Reimplemented from TGeoPcon. â—†Â GetBoundingCylinder(). void TGeoPgon::GetBoundingCylinder ; (; Double_t *Â ; param); const. overridevirtual . Reimplemented from TGeoPcon. â—†Â GetBuffer3D(). const TBuffer3D & TGeoPgon::GetBuffer3D ; (; Int_tÂ ; reqSections, . Bool_tÂ ; localFrameÂ . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoPcon. â—†Â GetByteCount(). Int_t TGeoPgon::GetByteCount ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoPcon.; Definition at line 90 of file TGeoPgon.h. â—†Â GetMakeRuntimeShape(). TGeoShape * TGeoPgon::GetMakeRuntimeShape ; (; TGeoShape *Â ; , . TGeoMatrix *Â ; Â . ); const. inlineoverridevirtual . Reimplemented from TGeoPcon.; Definition at line 91 of file TGeoPgon.h. â—†Â GetMeshNumbers(). void TGeoPgon::GetMeshNumbers ; (; Int_t &Â ; nvert, . Int_t &Â ; nsegs, . Int_t &Â ; npolsÂ . ); const. overridevirtual . Reimplemented from TGeoPcon. â—†Â GetNedges(). Int_t TGeoPgon::GetNedges ; (; ); const. inline . Definition at line 93 of file TGeoPgon.h. â—†Â GetNmeshVertices(). Int_t TGeoPgon::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoPcon. â—†Â GetNsegments(). Int_t TGeoPgon::GetNsegments ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoPcon.; Definition at line 95 of file TGeoPgon.h. â—†Â GetPhiCross",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPgon.html:29919,avoid,avoid,29919,doc/master/classTGeoPgon.html,https://root.cern,https://root.cern/doc/master/classTGeoPgon.html,1,['avoid'],['avoid']
Safety,"Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTorus&operator=(const TGeoTorus&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidSetSegsAndPols(TBuffer3D& buff) const; voidTGeoShape::S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTorus.html:7952,Safe,SafetyPhi,7952,root/html530/TGeoTorus.html,https://root.cern,https://root.cern/root/html530/TGeoTorus.html,2,['Safe'],['SafetyPhi']
Safety,"Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr); Â ; Â ~TGeoBBox () override; Â ; Double_tÂ Capacity () const override; Â ; voidÂ ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override; Â ; voidÂ ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override; Â ; Bool_tÂ Contains (const Double_t *point) const override; Â ; voidÂ Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override; Â ; Bool_tÂ CouldBeCrossed (const Double_t *point, const Double_t *dir) const override; Â ; Double_tÂ DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; Â ; voidÂ DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; Â ; Double_tÂ DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; Â ; voidÂ DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; Â ; TGeoVolume *Â Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; Â ; const char *Â GetAxisName (Int_t iaxis) const override; Â ; Double_tÂ GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override; Â ; voidÂ GetBoundingCylinder (Double_t *param) const override; Â ; Int_tÂ GetByteCount () const override; Â ; virtual Double_tÂ GetDX () const; Â ; virtual Double_tÂ GetDY () const; Â ; virtual Double_tÂ GetDZ () const; Â ; virtual Double_tÂ GetFacetArea (Int_t index=0) const; Â ; Int_tÂ GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override; Â ; TGeoShape *Â GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override; Â ; virtual const Double_t *Â GetOrigin () const; Â ; virtual Bool_tÂ GetPointsOnFacet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTessellated.html:6817,safe,safe,6817,doc/master/classTGeoTessellated.html,https://root.cern,https://root.cern/doc/master/classTGeoTessellated.html,1,['safe'],['safe']
Safety,"Double_t dy, Double_t dz, Double_t *origin=nullptr); Â ; Â TGeoBBox (Double_t *param); Â ; Â TGeoBBox (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr); Â ; Â ~TGeoBBox () override; Â ; Double_tÂ Capacity () const override; Â ; voidÂ ComputeBBox () override; Â ; voidÂ ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override; Â ; voidÂ ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override; Â ; Bool_tÂ Contains (const Double_t *point) const override; Â ; voidÂ Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override; Â ; Bool_tÂ CouldBeCrossed (const Double_t *point, const Double_t *dir) const override; Â ; Int_tÂ DistancetoPrimitive (Int_t px, Int_t py) override; Â Computes distance from point (px,py) to the object. ; Â ; const char *Â GetAxisName (Int_t iaxis) const override; Â ; Double_tÂ GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override; Â ; voidÂ GetBoundingCylinder (Double_t *param) const override; Â ; const TBuffer3D &Â GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override; Â Stub implementation to avoid forcing implementation at this stage. ; Â ; Int_tÂ GetByteCount () const override; Â ; virtual Double_tÂ GetDX () const; Â ; virtual Double_tÂ GetDY () const; Â ; virtual Double_tÂ GetDZ () const; Â ; virtual Double_tÂ GetFacetArea (Int_t index=0) const; Â ; Int_tÂ GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override; Â ; voidÂ GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override; Â ; Int_tÂ GetNmeshVertices () const override; Â ; virtual const Double_t *Â GetOrigin () const; Â ; Bool_tÂ GetPointsOnSegments (Int_t npoints, Double_t *array) const override; Â ; voidÂ InspectShape () const override; Â ; Bool_tÂ IsCylType () const override; Â ; virtual Bool_tÂ IsNullBox () const; Â ; Bool_tÂ IsValidBox () const override; Â ; TBuffer3D *Â MakeBuffer3D () const override; Â ; voidÂ SetBoxDimensions (Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoGtra.html:7377,avoid,avoid,7377,doc/master/classTGeoGtra.html,https://root.cern,https://root.cern/doc/master/classTGeoGtra.html,2,['avoid'],['avoid']
Safety,"Double_t phi2, Int_t skipz=0); Â ; Â Static Public Member Functions inherited from TGeoCone; static Double_tÂ Capacity (Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Â ; static TClass *Â Class (); Â ; static const char *Â Class_Name (); Â ; static constexpr Version_tÂ Class_Version (); Â ; static voidÂ ComputeNormalS (const Double_t *point, const Double_t *dir, Double_t *norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Â ; static const char *Â DeclFileName (); Â ; static Double_tÂ DistFromInsideS (const Double_t *point, const Double_t *dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Â ; static Double_tÂ DistFromOutsideS (const Double_t *point, const Double_t *dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Â ; static voidÂ DistToCone (const Double_t *point, const Double_t *dir, Double_t dz, Double_t r1, Double_t r2, Double_t &b, Double_t &delta); Â ; static Double_tÂ SafetyS (const Double_t *point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Int_t skipz=0); Â ; Â Static Public Member Functions inherited from TGeoBBox; static Bool_tÂ AreOverlapping (const TGeoBBox *box1, const TGeoMatrix *mat1, const TGeoBBox *box2, const TGeoMatrix *mat2) R__DEPRECATED(6; Â ; static TClass *Â Class (); Â ; static const char *Â Class_Name (); Â ; static constexpr Version_tÂ Class_Version (); Â ; static Bool_tÂ Contains (const Double_t *point, Double_t dx, Double_t dy, Double_t dz, const Double_t *origin); Â ; static const char *Â DeclFileName (); Â ; static Double_tÂ DistFromInside (const Double_t *point, const Double_t *dir, Double_t dx, Double_t dy, Double_t dz, const Double_t *origin, Double_t stepmax=TGeoShape::Big()); Â ; static Double_tÂ DistFromOutside (const Double_t *point, const Double_t *dir, Double_t dx, Double_t dy, Double_t dz, const Double_t *origin, Double_t stepmax=TGeoShape::Big()); Â ; Â Static Public Member Functions inherite",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoConeSeg.html:17535,Safe,SafetyS,17535,doc/master/classTGeoConeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoConeSeg.html,1,['Safe'],['SafetyS']
Safety,"Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoArb8.html:9352,safe,safe,9352,root/html602/TGeoArb8.html,https://root.cern,https://root.cern/root/html602/TGeoArb8.html,2,['safe'],['safe']
Safety,"Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetCurrentVertices(Double_t x0, Double_t y0, Double_t scale); voidSetCurrentZ(Double_t z, Int_t iz); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoXtru.html:10008,safe,safe,10008,root/html602/TGeoXtru.html,https://root.cern,https://root.cern/root/html602/TGeoXtru.html,2,['safe'],['safe']
Safety,"Double_t step) override; Â Cannot divide assemblies. ; Â ; TGeoShape *Â GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override; Â in case shape has some negative parameters, these has to be computed in order to fit the mother ; Â ; voidÂ GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override; Â Returns numbers of vertices, segments and polygons composing the shape mesh. ; Â ; Int_tÂ GetNmeshVertices () const override; Â ; voidÂ InspectShape () const override; Â print shape parameters ; Â ; TClass *Â IsA () const override; Â ; Bool_tÂ IsAssembly () const override; Â ; Bool_tÂ IsCylType () const override; Â ; voidÂ NeedsBBoxRecompute (); Â ; voidÂ RecomputeBoxLast (); Â Recompute bounding box of the assembly after adding a node. ; Â ; Double_tÂ Safety (const Double_t *point, Bool_t in=kTRUE) const override; Â computes the closest distance from given point to this shape, according to option. ; Â ; voidÂ Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; Â Compute safe distance from each of the points in the input array. ; Â ; voidÂ SavePrimitive (std::ostream &out, Option_t *option="""") override; Â Save a primitive as a C++ statement(s) on output stream ""out"". ; Â ; voidÂ SetPoints (Double_t *points) const override; Â No mesh for assemblies. ; Â ; voidÂ SetPoints (Float_t *points) const override; Â No mesh for assemblies. ; Â ; voidÂ SetSegsAndPols (TBuffer3D &buff) const override; Â Fill TBuffer3D structure for segments and polygons. ; Â ; voidÂ Streamer (TBuffer &) override; Â Stream an object of class TObject. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; Â Public Member Functions inherited from TGeoBBox; Â TGeoBBox (); Â ; Â TGeoBBox (const char *name, Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr); Â ; Â TGeoBBox (Double_t *param); Â ; Â TGeoBBox (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr); Â ; Â ~TGeoBBox () override; Â ; Double_tÂ Capacity () const override; Â ; Bool_tÂ C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShapeAssembly.html:3664,safe,safe,3664,doc/master/classTGeoShapeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoShapeAssembly.html,2,['safe'],['safe']
Safety,"Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t RadiusHypeSq(Double_t z, Bool_t inner) const; Compute r^2 = x^2 + y^2 at a given z coordinate, for either inner or outer hyperbolas. Double_t ZHypeSq(Double_t r, Bool_t inner) const; Compute z^2 at a given r^2, for either inner or outer hyperbolas. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyToHype(Double_t* point, Bool_t inner, Bool_t in) const; Compute an underestimate of the closest distance from a point to inner or; outer infinite hyperbolas. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetHypeDimensions(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Set dimensions of the hyperboloid. void SetDimensions(Double_t* param); Set dimensions of the hyperboloid starting from an array.; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. void SetPoints(Double_t* points) const; create tube mesh points. void SetPoints(Float_t* points) const; create tube mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHype.html:16334,Safe,Safety,16334,root/html528/TGeoHype.html,https://root.cern,https://root.cern/root/html528/TGeoHype.html,3,['Safe'],['Safety']
Safety,"Double_t* dir, Double_t* norm); static TEveGeoPolyShape*Construct(TGeoCompositeShape* cshp, Int_t n_seg); virtual Bool_tTGeoBBox::Contains(Double_t* point) const; static Bool_tTGeoBBox::Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTGeoBBox::DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoBBox::DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual Double_tTGeoBBox::DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoBBox::DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*TGeoBBox::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveGeoPolyShape.html:2159,safe,safe,2159,root/html528/TEveGeoPolyShape.html,https://root.cern,https://root.cern/root/html528/TEveGeoPolyShape.html,3,['safe'],['safe']
Safety,"Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the paraboloid and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the paraboloid along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SetParaboloidDimensions(Double_t rlo, Double_t rhi, Double_t dz); Set paraboloid dimensions. void SetDimensions(Double_t* param); Set paraboloid dimensions starting from an array. void SetPoints(Double_t* points) const; Create paraboloid mesh points.; Npoints = n*(n+1) + 2; ifirst = 0; ipoint(i,j) = 1+i*n+j; i=[0,n] j=[0,n-1]; ilast = 1+n*(n+1); Nsegments = n*(2*n+3); lower: (0, j+1); j=[0,n-1]; circle(i): (n*i+1+j, n*i+1+(j+1)%n); i=[0,n] j=[0,n-1]; generator(i): (n*i+1+j, n*(i+1)+1+j); i,j=[0,n-1]; upper: (n*n+1+j, (n+1)*n+1) j=[0,n-1]; Npolygons = n*(n+2); lower: (n+j, (j+1)%n, j) j=[0,n-1]; lateral(i): ((2*i+1)*n+j, 2*(i+1)*n+j, (2*i+3)*n+j, 2*(i+1)*n+(j+1)%n); i,j = [0,n-1]; upper: ((2n+1)*n+j, 2*n*(n+1)+(j+1)%n, 2*n*(n+1)+j) j=[0,n-1]. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoParaboloid.html:14282,Safe,Safety,14282,root/html530/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html530/TGeoParaboloid.html,2,['Safe'],['Safety']
Safety,"Double_t* norm) const; Returns normal vector to the planar quadrilateral defined by vector VERT.; The normal points outwards the xtru. void GetPlaneVertices(Int_t iz, Int_t ivert, Double_t* vert) const; Returns (x,y,z) of 3 vertices of the surface defined by Z sections (iz, iz+1); and polygon vertices (ivert, ivert+1). No range check. Bool_t IsPointInsidePlane(const Double_t* point, Double_t* vert, Double_t* norm) const; Check if the quadrilateral defined by VERT contains a coplanar POINT. void InspectShape() const; Print actual Xtru parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t SafetyToSector(const Double_t* point, Int_t iz, Double_t safmin, Bool_t in); Compute safety to sector iz, returning also the closest segment index. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint.; ---> localize the Z segment. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetCurrentZ(Double_t z, Int_t iz); Recompute current section vertices for a given Z position within range of section iz. void SetCurrentVertices(Double_t x0, Double_t y0, Double_t scale); Set current vertex coordinates according X0, Y0 and SCALE. void SetDimensions(Double_t* param); param[0] = nz // number of z planes. param[1] = z1 // Z position of first plane; param[2] = x1 // X position of first plane; param[3] = y1 // Y position of first plane; param[4] = scale1 // scale factor for first plane. param[4*(nz-1]+1] = zn; param[4*(nz-1)+2] = xn; param[4*(nz-1)+3] = yn; param[4*(nz-1)+4] = scalen. void SetPoints(Double_t* points) const; create polycone mesh points. void SetPoints(Float_t* points) const; creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoXtru.html:18586,Safe,Safety,18586,root/html534/TGeoXtru.html,https://root.cern,https://root.cern/root/html534/TGeoXtru.html,3,['Safe'],['Safety']
Safety,"Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*dir[1]; The distance can be computed as :; D = -B +/- DELTA; where DELTA.GT.0 and D.GT.0. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radial division; creates all volume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTube.html:15579,safe,safe,15579,root/html534/TGeoTube.html,https://root.cern,https://root.cern/root/html534/TGeoTube.html,9,['safe'],['safe']
Safety,"Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingIn(Double_t* point, Double_t* dir, Int_t ipl, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Check boundary crossing inside phi slices. Return distance snext to first crossing; if smaller than stepmax.; Protection in case point is in phi gap or close to phi boundaries and exiting. Bool_t SliceCrossing(Double_t* point, Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Check boundary crossing inside phi slices. Return distance snext to first crossing; if smaller than stepmax. Bool_t IsCrossingSlice(Double_t* point, Double_t* dir, Int_t iphi, Double_t sstart, Int_t& ipl, Double_t& snext, Double_t stepmax) const; Check crossing of a given pgon slice, from a starting point inside the slice. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the polygone. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polygone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. Phi divisions are; allowed only if nedges%ndiv=0 and create polygone ""segments"" with nedges/ndiv edges.; Z divisions can be performed if the divided range is in between two consecutive Z planes.; In case a wrong division axis is supplied, returns pointer to volume that was divided. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. void InspectShape(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPgon.html:16240,safe,safe,16240,root/html528/TGeoPgon.html,https://root.cern,https://root.cern/root/html528/TGeoPgon.html,3,['safe'],['safe']
Safety,"Double_tÂ ; phi, . Double_tÂ ; h1, . Double_tÂ ; bl1, . Double_tÂ ; tl1, . Double_tÂ ; alpha1, . Double_tÂ ; h2, . Double_tÂ ; bl2, . Double_tÂ ; tl2, . Double_tÂ ; alpha2Â . ). â—†Â ~TGeoTrap(). TGeoTrap::~TGeoTrap ; (; ). override . Member Function Documentation. â—†Â Class(). static TClass * TGeoTrap::Class ; (; ). static . ReturnsTClass describing this class . â—†Â Class_Name(). static const char * TGeoTrap::Class_Name ; (; ). static . ReturnsName of this class . â—†Â Class_Version(). static constexpr Version_t TGeoTrap::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 146 of file TGeoArb8.h. â—†Â DeclFileName(). static const char * TGeoTrap::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 146 of file TGeoArb8.h. â—†Â DistFromInside(). Double_t TGeoTrap::DistFromInside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoArb8. â—†Â DistFromInside_v(). void TGeoTrap::DistFromInside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoArb8. â—†Â DistFromOutside(). Double_t TGeoTrap::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoArb8. â—†Â DistFromOutside_v(). void TGeoTrap::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoArb8. â—†Â Divide(). TGeoVolume * TGeoTrap::Divide ; (; TGeoVolume *Â ; voldiv, . const char *Â ; divname, . Int_tÂ ; iaxis, . Int_tÂ ; ndiv, . Double_tÂ ; start, . Double_tÂ ; stepÂ . ). overridevirtual . Reimpleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrap.html:26673,safe,safe,26673,doc/master/classTGeoTrap.html,https://root.cern,https://root.cern/doc/master/classTGeoTrap.html,1,['safe'],['safe']
Safety,"Double_tÂ ; startzÂ . ); const. overridevirtual . Geometry checking method (see TGeoChecker). ; Implements TVirtualGeoPainter.; Definition at line 226 of file TGeoPainter.cxx. â—†Â CheckGeometryFull(). void TGeoPainter::CheckGeometryFull ; (; Bool_tÂ ; checkoverlaps = kTRUE, . Bool_tÂ ; checkcrossings = kTRUE, . Int_tÂ ; nrays = 10000, . const Double_t *Â ; vertex = nullptrÂ . ). overridevirtual . Geometry checking method (see: TGeoManager::CheckGeometry()) ; Implements TVirtualGeoPainter.; Definition at line 218 of file TGeoPainter.cxx. â—†Â CheckOverlaps(). void TGeoPainter::CheckOverlaps ; (; const TGeoVolume *Â ; vol, . Double_tÂ ; ovlp = 0.1, . Option_t *Â ; option = """"Â . ); const. overridevirtual . Check overlaps for the top volume of the geometry, within a limit OVLP. ; Implements TVirtualGeoPainter.; Definition at line 234 of file TGeoPainter.cxx. â—†Â CheckPoint(). void TGeoPainter::CheckPoint ; (; Double_tÂ ; x = 0, . Double_tÂ ; y = 0, . Double_tÂ ; z = 0, . Option_t *Â ; option = """", . Double_tÂ ; safety = 0.Â . ). overridevirtual . Check current point in the geometry. ; Implements TVirtualGeoPainter.; Definition at line 242 of file TGeoPainter.cxx. â—†Â CheckShape(). void TGeoPainter::CheckShape ; (; TGeoShape *Â ; shape, . Int_tÂ ; testNo, . Int_tÂ ; nsamples, . Option_t *Â ; optionÂ . ). overridevirtual . Test for shape navigation methods. ; Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate directions randomly in cos(theta). Compute DistFromInside and move the point with bigger distance. Compute DistFromOutside back from new point. Plot d-(d1+d2) . Implements TVirtualGeoPainter.; Definition at line 254 of file TGeoPainter.cxx. â—†Â ClearVisibleVolumes(). void TGeoPainter::ClearVisibleVolumes ; (; ). protected . Clear the list of visible volumes reset the kVisOnScreen bit for volumes previously in the list. ; Definition at line 263 of file TGeoPainter.cxx. â—†Â CountNodes(). Int_t TGeoPainter::CountNodes ; (; TGeoVolume *Â ; vol, . Int_tÂ ; levelÂ . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPainter.html:24845,safe,safety,24845,doc/master/classTGeoPainter.html,https://root.cern,https://root.cern/doc/master/classTGeoPainter.html,1,['safe'],['safety']
Safety,"E = F->param_end(); I != E; ++I) {; 1027 clang::ParmVarDecl* P = *I;; 1028 ; 1029 if (prototype != """"); 1030 prototype += "","";; 1031 ; 1032 //std::string type = P->getType().getAsString();; 1033 std::string type = P->getType().getAsString();; 1034 if (type.at(type.length()-1) == '*') {; 1035 type.at(type.length()-2) = '*';; 1036 type.erase(type.length()-1);; 1037 }; 1038 prototype += type;; 1039 }; 1040 ; 1041 prototype = ""("" + prototype + "")"";; 1042 return true;; 1043 }; 1044 else {; 1045 ShowWarning(""can't convert Decl to FunctionDecl"","""");; 1046 return false;; 1047 }; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051 ; 1052void RScanner::Scan(const clang::ASTContext &C); 1053{; 1054 fSourceManager = &C.getSourceManager();; 1055 ; 1056// if (fVerboseLevel >= 3) fSelectionRules.PrintSelectionRules();; 1057 ; 1058 if (fVerboseLevel > 0 && fSelectionRules.GetHasFileNameRule()) {; 1059 std::cout<<""File name detected""<<std::endl;; 1060 }; 1061 ; 1062 if (fScanType == EScanType::kTwoPasses); 1063 TraverseDecl(C.getTranslationUnitDecl());; 1064 ; 1065 fFirstPass=false;; 1066 fselectedRecordDecls.clear();; 1067 fSelectedEnums.clear();; 1068 fSelectedTypedefs.clear();; 1069 fSelectedVariables.clear();; 1070 fSelectedFunctions.clear();; 1071 TraverseDecl(C.getTranslationUnitDecl());; 1072 ; 1073 // The RecursiveASTVisitor uses range-based for; we must not modify the AST; 1074 // during iteration / visitation. Instead, buffer the lookups that could; 1075 // potentially create new template specializations, and handle them here:; 1076 AddDelayedAnnotatedRecordDecls();; 1077}; 1078 ; 1079 ; 1080////////////////////////////////////////////////////////////////////////////////; 1081/// Set the callback to the RecordDecl and return the previous one.; 1082 ; 1083RScanner::DeclCallback RScanner::SetRecordDeclCallback(RScanner::DeclCallback callback); 1084{; 1085 DeclCallback old = fRecordDeclCallback;; 1086 fRecordDeclCallback = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Scanner_8cxx_source.html:36563,detect,detected,36563,doc/master/Scanner_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html,1,['detect'],['detected']
Safety,"E). Set processing bit according to 'on'. ; Definition at line 274 of file TProofPlayer.cxx. â—†Â SetStopTimer(). void TProofPlayer::SetStopTimer ; (; Bool_tÂ ; on = kTRUE, . Bool_tÂ ; abort = kFALSE, . Int_tÂ ; timeout = 0Â . ). overridevirtual . Enable/disable the timer to stop/abort processing. ; The 'timeout' is in seconds. ; Implements TVirtualProofPlayer.; Definition at line 323 of file TProofPlayer.cxx. â—†Â SetupFeedback(). void TProofPlayer::SetupFeedback ; (; ). protectedvirtual . Set up feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, and TProofPlayerLite.; Definition at line 1642 of file TProofPlayer.cxx. â—†Â StopFeedback(). void TProofPlayer::StopFeedback ; (; ). virtual . Stop feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, and TProofPlayerSlave.; Definition at line 1650 of file TProofPlayer.cxx. â—†Â StopProcess(). void TProofPlayer::StopProcess ; (; Bool_tÂ ; abort, . Int_tÂ ; timeout = -1Â . ). overridevirtual . Stop the process after this event. ; If timeout is positive, start a timer firing after timeout seconds to hard-stop time-expensive events. ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 287 of file TProofPlayer.cxx. â—†Â StoreFeedback(). void TProofPlayer::StoreFeedback ; (; TObject *Â ; slave, . TList *Â ; outÂ . ). overridevirtual . Store feedback list (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote, and TProofPlayerLite.; Definition at line 689 of file TProofPlayer.cxx. â—†Â StoreOutput(). void TProofPlayer::StoreOutput ; (; TList *Â ; out). overridevirtual . Store output list (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 681 of file TProofPlayer.cxx. â—†Â Streamer(). void TProofPlayer::Streamer ; (; TBuffer &Â ; R__b). overridevirtual . Stream an ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:42539,abort,abort,42539,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['abort'],['abort']
Safety,"E); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowCache(Bool_t all = kFALSE); voidTProof::ShowData(); voidTProof::ShowDataSet(const char* dataset = """", const char* opt = ""M""); virtual voidShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* = 0); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* uri, const char* = 0); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Writ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:16739,timeout,timeout,16739,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,1,['timeout'],['timeout']
Safety,"EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TListTHtml::TFileSysDir::fDirs; TListTHtml::TFileSysDir::fFiles; Int_tTHtml::TFileSysEntry::fLevellevel of directory; TStringTHtml::TFileSysEntry::fNamename of the element; THtml::TFileSysDir*THtml::TFileSysEntry::fParentparent directory. private:. THashTablefEntrieshash map of all filenames without paths; TStringfIgnorePathregexp of path to ignore while building entry tree; TExMapfMapInoinode to TFileSysDir map, to detect softlinks; Int_tfMaxLevelmaximum level of directory nesting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Fill(); Recursively fill entries by parsing the path specified in GetName();; can be a THtml::GetDirDelimiter() delimited list of paths. TFileSysDB(const char* path, const char* ignorePath, Int_t maxdirlevel); { Fill(); }. TExMap& GetMapIno(); { return fMapIno; }. THashTable& GetEntries(); { return fEntries; }. const TString& GetIgnore() const; { return fIgnorePath; }. Int_t GetMaxLevel() const; { return fMaxLevel; }. TString fInputPath; // directories to look for classes; prepended to Decl/ ImplFileName(). Â» Author: Nenad Buncic 18/10/95 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/html:$Id$ Â» Last generated: 2015-06-30 15:12; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THtml__TFileSysDB.html:7235,detect,detect,7235,root/html602/THtml__TFileSysDB.html,https://root.cern,https://root.cern/root/html602/THtml__TFileSysDB.html,1,['detect'],['detect']
Safety,"EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TListTHtml::TFileSysDir::fDirs; TListTHtml::TFileSysDir::fFiles; Int_tTHtml::TFileSysEntry::fLevellevel of directory; TStringTHtml::TFileSysEntry::fNamename of the element; THtml::TFileSysDir*THtml::TFileSysEntry::fParentparent directory. private:. THashTablefEntrieshash map of all filenames without paths; TStringfIgnorePathregexp of path to ignore while building entry tree; TExMapfMapInoinode to TFileSysDir map, to detect softlinks; Int_tfMaxLevelmaximum level of directory nesting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Fill(); Recursively fill entries by parsing the path specified in GetName();; can be a THtml::GetDirDelimiter() delimited list of paths. TFileSysDB(const char* path, const char* ignorePath, Int_t maxdirlevel); { Fill(); }. TExMap& GetMapIno(); { return fMapIno; }. THashTable& GetEntries(); { return fEntries; }. const TString& GetIgnore() const; { return fIgnorePath; }. Int_t GetMaxLevel() const; { return fMaxLevel; }. TString fInputPath; // directories to look for classes; prepended to Decl/ ImplFileName(). Â» Author: Nenad Buncic 18/10/95 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/html:$Id$ Â» Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THtml__TFileSysDB.html:7235,detect,detect,7235,root/html604/THtml__TFileSysDB.html,https://root.cern,https://root.cern/root/html604/THtml__TFileSysDB.html,1,['detect'],['detect']
Safety,"Eltu(const char* name, Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = A; param[1] = B; param[2] = dz. ~TGeoEltu(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetEltuDimensions(Double_t a, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoEltu.html:13214,safe,safe,13214,root/html528/TGeoEltu.html,https://root.cern,https://root.cern/root/html528/TGeoEltu.html,6,['safe'],['safe']
Safety,"Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # IntegrateBins() command argument. Now, the pdf is not evaluated at the; # bin centers, but numerically integrated over each bin and divided by the; # bin width. The parameter for IntegrateBins() is the required precision; # for the numeric integrals. This is computationally expensive, but the; # bias is now not a problem anymore.; fit5 = powerlaw.fitTo(powerlaw_data, IntegrateBins=1e-3, Save=True, PrintLevel=-1, SumW2Error=False); fit5.Print(); ; # Improving numerical stability; # -----------------------------; ; # There is one more problem with binned fits that is related to the binning; # effects because often, a binned fit is affected by both problems.; #; # The issue is numerical stability for fits with a greatly different number; # of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; # the NLL, where \f[n\f] is the number of observations in the bin, and; # \f[p\f] the predicted probability to have an event in that bin. The; # difference in the logarithms for each bin is small, but the difference in; # \f[n\f] can be orders of magnitudes! Therefore, when summing these terms,; # lots of numerical precision is lost for the bins with less events.; ; # We can study this with the example of an exponential plus a Gaussian. The; # Gaussian is only a faint signal in the tail of the exponential where; # there are not so many events. And we can't afford any precision loss for; # these bins, otherwise we can't fit the Gaussian.; ; x.setBins(100) # It's not about binning effects anymore, so reset the number of bins.; ; mu = ROOT.RooRealVar(""mu"", ""mu"", 3.0, 0.1, 5.1); sigma = ROOT.RooRealVar(""sigma"", ""sigma"", 0.5, 0.01, 5.0); gauss = ROOT.RooGaussian(""gauss"", ""gauss"", x, mu, sigma); ; nsig = ROOT.RooRealVar(""nsig"", ""nsig"", 10000, 0, 1e9); nbkg = ROOT.RooRealVar(""nbkg"", ""nbkg"", 10000000, 0, 1e9); frac = ROOT.RooRealVar(""fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:5945,predict,predicted,5945,doc/master/rf614__binned__fit__problems_8py.html,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html,1,['predict'],['predicted']
Safety,"ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; ErrorHandlerFunc_tvoid(* ErrorHandlerFunc_t)(int level, Bool_t abort, const char *location, const char *msg)Definition TError.h:71; kBreakconstexpr Int_t kBreakDefinition TError.h:48; kInfoconstexpr Int_t kInfoDefinition TError.h:45; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kSysErrorconstexpr Int_t kSysErrorDefinition TError.h:49; kUnsetconstexpr Int_t kUnsetDefinition TError.h:43; va_copy#define va_copy(x, y)Definition civetweb.c:1000; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:60; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::GetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler()Definition TError.cxx:51; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. corefoundationsrcTError.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:10 (GVA Time) using Doxygen 1.9.8 Â Â ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8cxx_source.html:12032,abort,abort,12032,doc/master/TError_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html,1,['abort'],['abort']
Safety,"Eval_InitThreads();; 63#endif; 64#endif; 65 ; 66 // try again to see if the interpreter is initialized; 67 if (!Py_IsInitialized()) {; 68 // give up ...; 69 std::cerr << ""Error: python has not been initialized; returning."" << std::endl;; 70 return false;; 71 }; 72 ; 73 // set the command line arguments on python's sys.argv; 74#if PY_VERSION_HEX < 0x03000000; 75 char* argv[] = {const_cast<char*>(""cppyy"")};; 76#elif PY_VERSION_HEX < 0x03080000; 77 wchar_t* argv[] = {const_cast<wchar_t*>(L""cppyy"")};; 78#endif; 79#if PY_VERSION_HEX < 0x03080000; 80 PySys_SetArgv(sizeof(argv)/sizeof(argv[0]), argv);; 81#endif; 82 ; 83 // force loading of the cppyy module; 84 PyRun_SimpleString(const_cast<char*>(""import cppyy""));; 85 }; 86 ; 87 if (!gMainDict) {; 88 // retrieve the main dictionary; 89 gMainDict = PyModule_GetDict(; 90 PyImport_AddModule(const_cast<char*>(""__main__"")));; 91 // The gMainDict is borrowed, i.e. we are not calling Py_INCREF(gMainDict).; 92 // Like this, we avoid unexpectedly affecting how long __main__ is kept; 93 // alive. The gMainDict is only used in Exec(), ExecScript(), and Eval(),; 94 // which should not be called after __main__ is garbage collected anyway.; 95 }; 96 ; 97// declare success ...; 98 isInitialized = true;; 99 return true;; 100}; 101 ; 102} // unnamed namespace; 103 ; 104 ; 105//- C++ access to cppyy objects ---------------------------------------------; 106void* CPyCppyy::Instance_AsVoidPtr(PyObject* pyobject); 107{; 108// Extract the object pointer held by the CPPInstance pyobject.; 109 if (!Initialize()); 110 return nullptr;; 111 ; 112// check validity of cast; 113 if (!CPPInstance_Check(pyobject)); 114 return nullptr;; 115 ; 116// get held object (may be null); 117 return ((CPPInstance*)pyobject)->GetObject();; 118}; 119 ; 120//-----------------------------------------------------------------------------; 121PyObject* CPyCppyy::Instance_FromVoidPtr(; 122 void* addr, const std::string& classname, bool python_owns); 123{; 124// Bind the ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/API_8cxx_source.html:2974,avoid,avoid,2974,doc/master/API_8cxx_source.html,https://root.cern,https://root.cern/doc/master/API_8cxx_source.html,1,['avoid'],['avoid']
Safety,"Execute command and return output in TString.; 679 ; 680TString TSystem::GetFromPipe(const char *command); 681{; 682 TString out;; 683 ; 684 FILE *pipe = OpenPipe(command, ""r"");; 685 if (!pipe) {; 686 SysError(""GetFromPipe"", ""cannot run command \""%s\"""", command);; 687 return out;; 688 }; 689 ; 690 TString line;; 691 while (line.Gets(pipe)) {; 692 if (out != """"); 693 out += ""\n"";; 694 out += line;; 695 }; 696 ; 697 Int_t r = ClosePipe(pipe);; 698 if (r) {; 699 Error(""GetFromPipe"", ""command \""%s\"" returned %d"", command, r);; 700 }; 701 return out;; 702}; 703 ; 704////////////////////////////////////////////////////////////////////////////////; 705/// Get process id.; 706 ; 707int TSystem::GetPid(); 708{; 709 AbstractMethod(""GetPid"");; 710 return -1;; 711}; 712 ; 713////////////////////////////////////////////////////////////////////////////////; 714/// Exit the application.; 715 ; 716void TSystem::Exit(int, Bool_t); 717{; 718 AbstractMethod(""Exit"");; 719 throw; // unreachable; 720}; 721 ; 722////////////////////////////////////////////////////////////////////////////////; 723/// Abort the application.; 724 ; 725void TSystem::Abort(int); 726{; 727 AbstractMethod(""Abort"");; 728 throw; // unreachable; 729}; 730 ; 731////////////////////////////////////////////////////////////////////////////////; 732/// Print a stack trace.; 733 ; 734void TSystem::StackTrace(); 735{; 736 AbstractMethod(""StackTrace"");; 737}; 738 ; 739 ; 740//---- Directories -------------------------------------------------------------; 741 ; 742////////////////////////////////////////////////////////////////////////////////; 743/// Create helper TSystem to handle file and directory operations that; 744/// might be special for remote file access.; 745 ; 746TSystem *TSystem::FindHelper(const char *path, void *dirptr); 747{; 748 TSystem *helper = nullptr;; 749 {; 750 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 751 ; 752 if (!fHelpers) {; 753 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 754 fHelpers = new TOrdCollection",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:21983,Abort,Abort,21983,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['Abort'],['Abort']
Safety,"FALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerRemote(TProof* proof = 0); TProofPlayerRemote(const TProofPlayerRemote&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerRemote.html:11271,abort,abort,11271,root/html602/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html602/TProofPlayerRemote.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"FHelpers.hxx:346; ROOT::RDF::Experimental::ProgressHelper::fTotalFilesunsigned int fTotalFilesDefinition RDFHelpers.hxx:344; ROOT::RDF::Experimental::ProgressHelper::RecordEvtCountAndTimestd::pair< std::size_t, std::chrono::seconds > RecordEvtCountAndTime()Record current event counts and time stamp, populate evts/s statistics array.Definition RDFHelpers.cxx:174; ROOT::RDF::Experimental::ProgressHelper::registerNewSamplevoid registerNewSample(unsigned int, const ROOT::RDF::RSampleInfo &id)Register a new sample for completion statistics.Definition RDFHelpers.hxx:378; ROOT::RDF::Experimental::ProgressHelper::fUseShellColoursbool fUseShellColoursDefinition RDFHelpers.hxx:348; ROOT::RDF::Experimental::ProgressHelper::PrintProgressBarvoid PrintProgressBar(std::ostream &stream, std::size_t currentEventCount) constPrint a progress bar of width ProgressHelper::fBarWidth if fGetNEventsOfCurrentFile is known.Definition RDFHelpers.cxx:303; ROOT::RDF::Experimental::ProgressHelper::operator()void operator()(unsigned int, T &value)Thread-safe callback for RDataFrame.Definition RDFHelpers.hxx:389; ROOT::RDF::Experimental::ProgressHelper::PrintStatsvoid PrintStats(std::ostream &stream, std::size_t currentEventCount, std::chrono::seconds totalElapsedSeconds) constPrint event and time statistics.Definition RDFHelpers.cxx:225; ROOT::RDF::Experimental::ProgressHelper::fSampleNameToEventEntriesstd::map< std::string, ULong64_t > fSampleNameToEventEntriesDefinition RDFHelpers.hxx:338; ROOT::RDF::Experimental::ProgressHelper::fTreestd::shared_ptr< TTree > fTreeDefinition RDFHelpers.hxx:350; ROOT::RDF::Experimental::ProgressHelper::fIncrementstd::size_t fIncrementDefinition RDFHelpers.hxx:335; ROOT::RDF::Experimental::ProgressHelper::fLastProcessedEventsstd::size_t fLastProcessedEventsDefinition RDFHelpers.hxx:334; ROOT::RDF::Experimental::ProgressHelper::fSampleNameToEventEntriesMutexstd::mutex fSampleNameToEventEntriesMutexDefinition RDFHelpers.hxx:337; ROOT::RDF::Experimental::ProgressHelp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:23492,safe,safe,23492,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['safe'],['safe']
Safety,"File, . const std::string &Â ; title = """", . const std::string &Â ; fname = """"Â . ). constructor When title not specified, default will be used ; Definition at line 43 of file RFileDialog.cxx. â—†Â ~RFileDialog(). RFileDialog::~RFileDialog ; (; ). virtual . destructor ; Definition at line 90 of file RFileDialog.cxx. Member Function Documentation. â—†Â Dialog(). std::string RFileDialog::Dialog ; (; EDialogTypesÂ ; kind, . const std::string &Â ; title, . const std::string &Â ; fnameÂ . ). staticprotected . Start specified dialog type. ; Definition at line 374 of file RFileDialog.cxx. â—†Â Embed(). std::shared_ptr< RFileDialog > RFileDialog::Embed ; (; const std::shared_ptr< RWebWindow > &Â ; window, . unsignedÂ ; connid, . const std::string &Â ; argsÂ . ). static . Create dialog instance to use as embedded dialog inside other widget Embedded dialog started on the client side where FileDialogController.SaveAs() method called Such method immediately send message with ""FILEDIALOG:"" prefix On the server side widget should detect such message and call RFileDialog::Embed() providing received string as second argument. ; Returned instance of shared_ptr<RFileDialog> may be used to assign callback when file is selected ; Definition at line 437 of file RFileDialog.cxx. â—†Â GetCanChangePath(). bool ROOT::RFileDialog::GetCanChangePath ; (; ); const. inline . Returns true if working path can be change with gui elements. ; Definition at line 100 of file RFileDialog.hxx. â—†Â GetFileName(). const std::string & ROOT::RFileDialog::GetFileName ; (; ); const. inline . Definition at line 112 of file RFileDialog.hxx. â—†Â GetNameFilters(). const auto & ROOT::RFileDialog::GetNameFilters ; (; ); const. inline . Returns array of name filters. ; Definition at line 94 of file RFileDialog.hxx. â—†Â GetRegexp(). std::string RFileDialog::GetRegexp ; (; const std::string &Â ; name); const. protected . Returns regexp for selected filter String should have form ""Filter name (*.ext1 *.ext2 ...) ; Definition at line 191 of file RFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RFileDialog.html:6447,detect,detect,6447,doc/v632/classROOT_1_1RFileDialog.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RFileDialog.html,1,['detect'],['detect']
Safety,"File, . const std::string &Â ; title = """", . const std::string &Â ; fname = """"Â . ). constructor When title not specified, default will be used ; Definition at line 44 of file RFileDialog.cxx. â—†Â ~RFileDialog(). RFileDialog::~RFileDialog ; (; ). virtual . destructor ; Definition at line 91 of file RFileDialog.cxx. Member Function Documentation. â—†Â Dialog(). std::string RFileDialog::Dialog ; (; EDialogTypesÂ ; kind, . const std::string &Â ; title, . const std::string &Â ; fnameÂ . ). staticprotected . Start specified dialog type. ; Definition at line 375 of file RFileDialog.cxx. â—†Â Embed(). std::shared_ptr< RFileDialog > RFileDialog::Embed ; (; const std::shared_ptr< RWebWindow > &Â ; window, . unsignedÂ ; connid, . const std::string &Â ; argsÂ . ). static . Create dialog instance to use as embedded dialog inside other widget Embedded dialog started on the client side where FileDialogController.SaveAs() method called Such method immediately send message with ""FILEDIALOG:"" prefix On the server side widget should detect such message and call RFileDialog::Embed() providing received string as second argument. ; Returned instance of shared_ptr<RFileDialog> may be used to assign callback when file is selected ; Definition at line 438 of file RFileDialog.cxx. â—†Â GetCanChangePath(). bool ROOT::RFileDialog::GetCanChangePath ; (; ); const. inline . Returns true if working path can be change with gui elements. ; Definition at line 100 of file RFileDialog.hxx. â—†Â GetFileName(). const std::string & ROOT::RFileDialog::GetFileName ; (; ); const. inline . Definition at line 112 of file RFileDialog.hxx. â—†Â GetNameFilters(). const auto & ROOT::RFileDialog::GetNameFilters ; (; ); const. inline . Returns array of name filters. ; Definition at line 94 of file RFileDialog.hxx. â—†Â GetRegexp(). std::string RFileDialog::GetRegexp ; (; const std::string &Â ; name); const. protected . Returns regexp for selected filter String should have form ""Filter name (*.ext1 *.ext2 ...) ; Definition at line 192 of file RFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RFileDialog.html:6439,detect,detect,6439,doc/master/classROOT_1_1RFileDialog.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RFileDialog.html,1,['detect'],['detect']
Safety,"File.h. â—†Â GetNbytesFree(). virtual Int_t TFile::GetNbytesFree ; (; ); const. inlinevirtual . Reimplemented in TSQLFile, and TXMLFile.; Definition at line 249 of file TFile.h. â—†Â GetNbytesInfo(). virtual Int_t TFile::GetNbytesInfo ; (; ); const. inlinevirtual . Reimplemented in TSQLFile, and TXMLFile.; Definition at line 248 of file TFile.h. â—†Â GetNewUrl(). virtual TString TFile::GetNewUrl ; (; ). inlinevirtual . Reimplemented in TDavixFile, and TNetXNGFile.; Definition at line 250 of file TFile.h. â—†Â GetNfree(). virtual Int_t TFile::GetNfree ; (; ); const. inlinevirtual . Reimplemented in TSQLFile, and TXMLFile.; Definition at line 238 of file TFile.h. â—†Â GetNProcessIDs(). virtual Int_t TFile::GetNProcessIDs ; (; ); const. inlinevirtual . Definition at line 239 of file TFile.h. â—†Â GetOnlyStaged(). Bool_t TFile::GetOnlyStaged ; (; ). static . Returns staged only flag. ; Definition at line 4754 of file TFile.cxx. â—†Â GetOpenTimeout(). UInt_t TFile::GetOpenTimeout ; (; ). static . Returns open timeout (in ms). ; Definition at line 4734 of file TFile.cxx. â—†Â GetOption(). Option_t * TFile::GetOption ; (; ); const. inlineoverridevirtual . Reimplemented from TObject.; Definition at line 240 of file TFile.h. â—†Â GetReadaheadSize(). Int_t TFile::GetReadaheadSize ; (; ). static . Static function returning the readahead buffer size. ; Definition at line 4599 of file TFile.cxx. â—†Â GetReadCalls(). virtual Int_t TFile::GetReadCalls ; (; ); const. inlinevirtual . Definition at line 244 of file TFile.h. â—†Â GetReadStreamerInfo(). Bool_t TFile::GetReadStreamerInfo ; (; ). static . If the streamerinfos are to be read at file opening. ; See TFile::SetReadStreamerInfo for more documentation. ; Definition at line 3742 of file TFile.cxx. â—†Â GetRecordHeader(). Int_t TFile::GetRecordHeader ; (; char *Â ; buf, . Long64_tÂ ; first, . Int_tÂ ; maxbytes, . Int_t &Â ; nbytes, . Int_t &Â ; objlen, . Int_t &Â ; keylenÂ . ). Read the logical record header starting at a certain postion. ; Parameters. [in]bufpointer to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:67215,timeout,timeout,67215,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['timeout'],['timeout']
Safety,"Find if a union of two shapes contains a given point. ; Â ; Int_tÂ DistanceToPrimitive (Int_t px, Int_t py) override; Â Compute minimum distance to shape vertices. ; Â ; Double_tÂ DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override; Â Computes distance from a given point inside the shape to its boundary. ; Â ; Double_tÂ DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override; Â Compute distance from a given outside point to the shape. ; Â ; EGeoBoolTypeÂ GetBooleanOperator () const override; Â ; Int_tÂ GetNpoints () override; Â Returns number of vertices for the composite shape described by this union. ; Â ; TClass *Â IsA () const override; Â ; TGeoBoolNode *Â MakeClone () const override; Â Make a clone of this. Pointers are preserved. ; Â ; voidÂ Paint (Option_t *option) override; Â Paint method. ; Â ; Double_tÂ Safety (const Double_t *point, Bool_t in=kTRUE) const override; Â Compute safety distance for a union node;. ; Â ; voidÂ SavePrimitive (std::ostream &out, Option_t *option="""") override; Â Save a primitive as a C++ statement(s) on output stream ""out"". ; Â ; voidÂ Sizeof3D () const override; Â Register 3D size of this shape. ; Â ; voidÂ Streamer (TBuffer &) override; Â Stream an object of class TObject. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; Â Public Member Functions inherited from TGeoBoolNode; Â TGeoBoolNode (); Â Default constructor. ; Â ; Â TGeoBoolNode (const char *expr1, const char *expr2); Â Constructor called by TGeoCompositeShape providing 2 subexpressions for the 2 branches. ; Â ; Â TGeoBoolNode (TGeoShape *left, TGeoShape *right, TGeoMatrix *lmat=nullptr, TGeoMatrix *rmat=nullptr); Â Constructor providing left and right shapes and matrices (in the Boolean operation). ; Â ; Â ~TGeoBoolNode () override; Â Destructor. ; Â ; voidÂ ClearThreadData () const; Â ; voidÂ CreateThreadData (Int_t nthreads); Â Create thread data ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoUnion.html:2025,Safe,Safety,2025,doc/master/classTGeoUnion.html,https://root.cern,https://root.cern/doc/master/classTGeoUnion.html,2,"['Safe', 'safe']","['Safety', 'safety']"
Safety,"Finder) ; Definition at line 318 of file TGeoParallelWorld.cxx. â—†Â GetAccelerationMode(). AccelerationMode const & TGeoParallelWorld::GetAccelerationMode ; (; ); const. inline . Definition at line 96 of file TGeoParallelWorld.h. â—†Â GetBVHSafetyCandidates(). std::pair< double, double > TGeoParallelWorld::GetBVHSafetyCandidates ; (; doubleÂ ; point[3], . std::vector< int > &Â ; candidates, . doubleÂ ; margin = 0.Â . ); const. private . Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ; Uses BVH to do so. ; Definition at line 802 of file TGeoParallelWorld.cxx. â—†Â GetGeometry(). TGeoManager * TGeoParallelWorld::GetGeometry ; (; ); const. inline . Definition at line 142 of file TGeoParallelWorld.h. â—†Â GetLoopSafetyCandidates(). std::pair< double, double > TGeoParallelWorld::GetLoopSafetyCandidates ; (; doubleÂ ; point[3], . std::vector< int > &Â ; candidates, . doubleÂ ; margin = 0.Â . ); const. private . Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ; Uses trivial algorithm to do so. ; Definition at line 740 of file TGeoParallelWorld.cxx. â—†Â GetVolume(). TGeoVolume * TGeoParallelWorld::GetVolume ; (; ); const. inline . Definition at line 144 of file TGeoParallelWorld.h. â—†Â InitSafetyVoxel(). void TGeoParallelWorld::InitSafetyVoxel ; (; TGeoVoxelGridIndex const &Â ; vi). private . Method to initialize the safety voxel at a specific 3D voxel (grid) index. ; Definition at line 916 of file TGeoParallelWorld.cxx. â—†Â IsA(). TClass * TGeoParallelWorld::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 184 of file TGeoParallelWorld.h. â—†Â IsClosed(). Bool_t TGeoParallelWorld::IsClosed ; (; ); const. inline . Definition at line 143 of file TGeoParallelWorld.h. â—†Â IsUsingOverlaps(). Bool_t TGeoParallelWorld::IsUsingOverlaps ; (; ); const. inline . Definition at line 81 of file TGeoParallelWorld.h. â—†Â operator=(). TGeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:23843,safe,safety,23843,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['safe'],['safety']
Safety,"Fit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3438,recover,recovery,3438,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['recover'],['recovery']
Safety,"Float_t *Â ; zÂ . ). Graph2D constructor with three vectors of floats as input. ; Definition at line 281 of file TGraph2D.cxx. â—†Â TGraph2D() [5/9]. TGraph2D::TGraph2D ; (; Int_tÂ ; n, . Double_t *Â ; x, . Double_t *Â ; y, . Double_t *Â ; zÂ . ). Graph2D constructor with three vectors of doubles as input. ; Definition at line 298 of file TGraph2D.cxx. â—†Â TGraph2D() [6/9]. TGraph2D::TGraph2D ; (; TH2 *Â ; h2). Graph2D constructor with a TH2 (h2) as input. ; Only the h2's bins within the X and Y axis ranges are used. Empty bins, recognized when both content and errors are zero, are excluded. ; Definition at line 317 of file TGraph2D.cxx. â—†Â TGraph2D() [7/9]. TGraph2D::TGraph2D ; (; const char *Â ; name, . const char *Â ; title, . Int_tÂ ; n, . Double_t *Â ; x, . Double_t *Â ; y, . Double_t *Â ; zÂ . ). Graph2D constructor with name, title and three vectors of doubles as input. ; name : name of 2D graph (avoid blanks) title : 2D graph title if title is of the form ""stringt;stringx;stringy;stringz"" the 2D graph title is set to stringt, the x axis title to stringx, the y axis title to stringy,etc ; Definition at line 363 of file TGraph2D.cxx. â—†Â TGraph2D() [8/9]. TGraph2D::TGraph2D ; (; const char *Â ; filename, . const char *Â ; format = ""%lgÂ %lgÂ %lg"", . Option_t *Â ; option = """"Â . ). Graph2D constructor reading input from filename filename is assumed to contain at least three columns of numbers. ; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files) you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument, e.g. option="" \\t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';') used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1""). Note in that case, the instantiation is about 2 times slower. ; Definition at line 403 of file TGraph2D.cxx. â—†Â TGraph2D() [9/9]. TGraph2D::TGraph2D ; (; const TGraph2D &Â ; g). Graph2D copy constructor. ; copy everything apart from the list of contained f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph2D.html:36495,avoid,avoid,36495,doc/master/classTGraph2D.html,https://root.cern,https://root.cern/doc/master/classTGraph2D.html,1,['avoid'],['avoid']
Safety,"For example h->Project3D(""name_xy"") will generate an histogram with the name: h3dname_name_xy.; NOTE 2: If an histogram of the same type and with the same name already exists in current Directory, the histogram is reset and filled again with the projected contents of the TH3.; NOTE 3: The number of entries in the projected histogram is estimated from the number of effective entries for all the cells included in the projection.; NOTE 4: underflow/overflow are included by default in the projection To exclude underflow and/or overflow (for both axis in case of a projection to a 1D histogram) use option ""NUF"" and/or ""NOF"" With SetRange() you can have all bins except underflow/overflow only if you set the axis bit range as following after having called SetRange: axis->SetRange(1, axis->GetNbins());; NOTE 5: If TH1::AddDirectory is set to false, a new histogram is always created and the ownership of the returned pointer is delegated to the user. Be sure in this case to call delete on it after it's no longer needed, to avoid memory leaks. ; Definition at line 2409 of file TH3.cxx. â—†Â Project3DProfile(). TProfile2D * TH3::Project3DProfile ; (; Option_t *Â ; option = ""xy""); const. virtual . Project a 3-d histogram into a 2-d profile histograms depending on the option parameter option may contain a combination of the characters x,y,z option = ""xy"" return the x versus y projection into a TProfile2D histogram option = ""yx"" return the y versus x projection into a TProfile2D histogram option = ""xz"" return the x versus z projection into a TProfile2D histogram option = ""zx"" return the z versus x projection into a TProfile2D histogram option = ""yz"" return the y versus z projection into a TProfile2D histogram option = ""zy"" return the z versus y projection into a TProfile2D histogram NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal. ; option = ""o"" original axis range of the target axes will be kept, but only bins inside the selected range will be filled.; The projection i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:92782,avoid,avoid,92782,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,1,['avoid'],['avoid']
Safety,"For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside). - returns director cosines of normal to the crossed shape surface from a; given point towards a direction. One has to specify if the point is inside; or outside shape. According to this, the normal will be outwards or inwards; shape respectively. Normal components are statically stored by shape class,; so it has to be copied after retr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShape.html:4754,safe,safe,4754,root/html528/TGeoShape.html,https://root.cern,https://root.cern/root/html528/TGeoShape.html,3,['safe'],['safe']
Safety,"For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(const Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside). - returns director cosines of normal to the crossed shape surface from a; given point towards a direction. One has to specify if the point is inside; or outside shape. According to this, the normal will be outwards or inwards; shape respectively. Normal components are statically stored by shape class,; so it has to be copied afte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShape.html:4760,safe,safe,4760,root/html534/TGeoShape.html,https://root.cern,https://root.cern/root/html534/TGeoShape.html,3,['safe'],['safe']
Safety,"For radialdivision; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point InitTrigonometry();to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz = 0); Static method to compute the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetTubsDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); Set dimensions of the tube segment.; The segment will be from phiStart to phiEnd expressed in degree. void SetDimensions(Double_t* param); Set dimensions of the tube segment starting from a list. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n random points located on the line segments of the shape mesh.; The output array must be provided with a length of minimum 3*npoints. Returns; tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeSeg.html:18551,Safe,Safety,18551,root/html534/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html,3,['Safe'],['Safety']
Safety,"Form(""VarProp[%i]"",ivar) << Endl;; 420 }; 421 (*fFitParams)[ivar] = theFitP;; 422 ; 423 if (theFitP != kNotEnforced); 424 Log() << kINFO << ""Use \"""" << fAllVarsI[ivar]; 425 << ""\"" cuts for variable: "" << ""'"" << (*fInputVars)[ivar] << ""'"" << Endl;; 426 }; 427}; 428 ; 429////////////////////////////////////////////////////////////////////////////////; 430/// cut evaluation: returns 1.0 if event passed, 0.0 otherwise; 431 ; 432Double_t TMVA::MethodCuts::GetMvaValue( Double_t* err, Double_t* errUpper ); 433{; 434 // cannot determine error; 435 NoErrorCalc(err, errUpper);; 436 ; 437 // sanity check; 438 if (fCutMin == NULL || fCutMax == NULL || fNbins == 0) {; 439 Log() << kFATAL << ""<Eval_Cuts> fCutMin/Max have zero pointer. ""; 440 << ""Did you book Cuts ?"" << Endl;; 441 }; 442 ; 443 const Event* ev = GetEvent();; 444 ; 445 // sanity check; 446 if (fTestSignalEff > 0) {; 447 // get efficiency bin; 448 Int_t ibin = fEffBvsSLocal->FindBin( fTestSignalEff );; 449 if (ibin < 0 ) ibin = 0;; 450 else if (ibin >= fNbins) ibin = fNbins - 1;; 451 ; 452 Bool_t passed = kTRUE;; 453 for (UInt_t ivar=0; ivar<GetNvar(); ivar++); 454 passed &= ( (ev->GetValue(ivar) > fCutMin[ivar][ibin]) &&; 455 (ev->GetValue(ivar) <= fCutMax[ivar][ibin]) );; 456 ; 457 return passed ? 1. : 0. ;; 458 }; 459 else return 0;; 460}; 461 ; 462////////////////////////////////////////////////////////////////////////////////; 463/// print cuts; 464 ; 465void TMVA::MethodCuts::PrintCuts( Double_t effS ) const; 466{; 467 std::vector<Double_t> cutsMin;; 468 std::vector<Double_t> cutsMax;; 469 Int_t ibin = fEffBvsSLocal->FindBin( effS );; 470 ; 471 Double_t trueEffS = GetCuts( effS, cutsMin, cutsMax );; 472 ; 473 // retrieve variable expressions (could be transformations); 474 std::vector<TString>* varVec = 0;; 475 if (GetTransformationHandler().GetNumOfTransformations() == 0) {; 476 // no transformation applied, replace by current variables; 477 varVec = new std::vector<TString>;; 478 for (UInt_t ivar=0; ivar<cutsM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:16586,sanity check,sanity check,16586,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['sanity check'],['sanity check']
Safety,"Frame execution logs; Creating an RDataFrame from a dataset specification file; Adding a progress bar. Efficient analysis in Python; Class reference. Cheat sheet; These are the operations which can be performed with RDataFrame. Transformations; Transformations are a way to manipulate the data. Transformation Description . Alias() Introduce an alias for a particular column name. . Define() Create a new column in the dataset. Example usages include adding a column that contains the invariant mass of a particle, or a selection of elements of an array (e.g. only the pts of ""good"" muons). . DefinePerSample() Define a new column that is updated when the input sample changes, e.g. when switching tree being processed in a chain. . DefineSlot() Same as Define(), but the user-defined function must take an extra unsigned int slot as its first parameter. slot will take a different value, 0 to nThreads - 1, for each thread of execution. This is meant as a helper in writing thread-safe Define() transformation when using RDataFrame after ROOT::EnableImplicitMT(). DefineSlot() works just as well with single-thread execution: in that case slot will always be 0. . DefineSlotEntry() Same as DefineSlot(), but the entry number is passed in addition to the slot number. This is meant as a helper in case the expression depends on the entry number. For details about entry numbers in multi-threaded runs, see here. . Filter() Filter rows based on user-defined conditions. . Range() Filter rows based on entry number (single-thread only). . Redefine() Overwrite the value and/or type of an existing column. See Define() for more information. . RedefineSlot() Overwrite the value and/or type of an existing column. See DefineSlot() for more information. . RedefineSlotEntry() Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. . Vary() Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). . Actions; A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:3461,safe,safe,3461,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['safe'],['safe']
Safety,"FromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; Â ; voidÂ DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; Â ; Double_tÂ DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; Â ; voidÂ DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; Â ; Double_tÂ DistToPlane (const Double_t *point, const Double_t *dir, Int_t ipl, Bool_t in) const; Â ; TGeoVolume *Â Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; Â ; Double_tÂ GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override; Â ; voidÂ GetBoundingCylinder (Double_t *param) const override; Â ; Int_tÂ GetByteCount () const override; Â ; Double_tÂ GetClosestEdge (const Double_t *point, Double_t *vert, Int_t &isegment) const; Â ; Double_tÂ GetDz () const; Â ; Int_tÂ GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override; Â ; TGeoShape *Â GetMakeRuntimeShape (TGeoShape *, TGeoMatrix *) const override; Â ; Bool_tÂ GetPointsOnFacet (Int_t, Int_t, Double_t *) const override; Â ; Double_tÂ GetTwist (Int_t iseg) const; Â ; Double_t *Â GetVertices (); Â ; voidÂ InspectShape () const override; Â ; TClass *Â IsA () const override; Â ; Bool_tÂ IsCylType () const override; Â ; Bool_tÂ IsTwisted () const; Â ; Double_tÂ Safety (const Double_t *point, Bool_t in=kTRUE) const override; Â ; voidÂ Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; Â ; Double_tÂ SafetyToFace (const Double_t *point, Int_t iseg, Bool_t in) const; Â ; voidÂ SavePrimitive (std::ostream &out, Option_t *option="""") override; Â Save a primitive as a C++ statement(s) on output stream ""out"".",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:2641,Safe,Safety,2641,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,3,"['Safe', 'safe']","['Safety', 'SafetyToFace', 'safe']"
Safety,"FromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPacketizerMulti.html:5886,abort,abort,5886,root/html534/TPacketizerMulti.html,https://root.cern,https://root.cern/root/html534/TPacketizerMulti.html,1,['abort'],['abort']
Safety,"GFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TVirtualPad*fCurPadcurrent pad from which to import; TStyle*fCurStylestyle to copy or to rename; Int_tfMode1=new, 2=rename, 3=import; TGTextEntry*fNameTStyle name text entry; TGLabel*fNameLabelname label; TGTextButton*fOKsave button; TStyleManager*fStyleManagerparent style manager; TGTextEntry*fTitleTStyle title text entry; TGLabel*fTitleLabeltitle label; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGLabel*fWarnLabellabel for warnings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0); Constructor. Create the dialog window and draw it centered over the; main window 'mf'. A pointer to the style to copy or rename is given; by 'cur' and the parameter 'mode' specify the mode:; 1 = copy | 2 = rename | 3 = import from canvas. ~TStyleDialog(); Destructor. void DoCancel(); Slot called when the Cancel button is clicked. Close the window; without saving submitted changes. void DoCloseWindow(); Slot called when the window is closed via the window manager.; Close the window without saving submitted changes. void DoOK(); Slot called when the OK button is clicked. Rename or create the style; before closing the window. void DoUpdate(); Slot called every time the name is changed. Provide some protection; to avoid letting the user use an empty name or an already used one.; A warning message can be shown and the OK button disabled. Â» Author: Denis Favre-Miville 08/09/05 Â» Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; Â» Last changed: root/ged:$Id: TStyleDialog.h,v 1.0 2005/09/08 Â» Last generated: 2010-09-27 10:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyleDialog.html:23154,avoid,avoid,23154,root/html528/TStyleDialog.html,https://root.cern,https://root.cern/root/html528/TStyleDialog.html,1,['avoid'],['avoid']
Safety,"GFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TVirtualPad*fCurPadcurrent pad from which to import; TStyle*fCurStylestyle to copy or to rename; Int_tfMode1=new, 2=rename, 3=import; TGTextEntry*fNameTStyle name text entry; TGLabel*fNameLabelname label; TGTextButton*fOKsave button; TStyleManager*fStyleManagerparent style manager; TGTextEntry*fTitleTStyle title text entry; TGLabel*fTitleLabeltitle label; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGLabel*fWarnLabellabel for warnings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0); Constructor. Create the dialog window and draw it centered over the; main window 'mf'. A pointer to the style to copy or rename is given; by 'cur' and the parameter 'mode' specify the mode:; 1 = copy | 2 = rename | 3 = import from canvas. ~TStyleDialog(); Destructor. void DoCancel(); Slot called when the Cancel button is clicked. Close the window; without saving submitted changes. void DoCloseWindow(); Slot called when the window is closed via the window manager.; Close the window without saving submitted changes. void DoOK(); Slot called when the OK button is clicked. Rename or create the style; before closing the window. void DoUpdate(); Slot called every time the name is changed. Provide some protection; to avoid letting the user use an empty name or an already used one.; A warning message can be shown and the OK button disabled. Â» Author: Denis Favre-Miville 08/09/05 Â» Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; Â» Last changed: root/ged:$Id: TStyleDialog.h,v 1.0 2005/09/08 Â» Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TStyleDialog.html:23307,avoid,avoid,23307,root/html530/TStyleDialog.html,https://root.cern,https://root.cern/root/html530/TStyleDialog.html,1,['avoid'],['avoid']
Safety,"GFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TVirtualPad*fCurPadcurrent pad from which to import; TStyle*fCurStylestyle to copy or to rename; Int_tfMode1=new, 2=rename, 3=import; TGTextEntry*fNameTStyle name text entry; TGLabel*fNameLabelname label; TGTextButton*fOKsave button; TStyleManager*fStyleManagerparent style manager; TGTextEntry*fTitleTStyle title text entry; TGLabel*fTitleLabeltitle label; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGLabel*fWarnLabellabel for warnings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0); Constructor. Create the dialog window and draw it centered over the; main window 'mf'. A pointer to the style to copy or rename is given; by 'cur' and the parameter 'mode' specify the mode:; 1 = copy | 2 = rename | 3 = import from canvas. ~TStyleDialog(); Destructor. void DoCancel(); Slot called when the Cancel button is clicked. Close the window; without saving submitted changes. void DoCloseWindow(); Slot called when the window is closed via the window manager.; Close the window without saving submitted changes. void DoOK(); Slot called when the OK button is clicked. Rename or create the style; before closing the window. void DoUpdate(); Slot called every time the name is changed. Provide some protection; to avoid letting the user use an empty name or an already used one.; A warning message can be shown and the OK button disabled. Â» Author: Denis Favre-Miville 08/09/05 Â» Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; Â» Last changed: root/ged:$Id: TStyleDialog.h,v 1.0 2005/09/08 Â» Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStyleDialog.html:23307,avoid,avoid,23307,root/html532/TStyleDialog.html,https://root.cern,https://root.cern/root/html532/TStyleDialog.html,1,['avoid'],['avoid']
Safety,"GFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TVirtualPad*fCurPadcurrent pad from which to import; TStyle*fCurStylestyle to copy or to rename; Int_tfMode1=new, 2=rename, 3=import; TGTextEntry*fNameTStyle name text entry; TGLabel*fNameLabelname label; TGTextButton*fOKsave button; TStyleManager*fStyleManagerparent style manager; TGTextEntry*fTitleTStyle title text entry; TGLabel*fTitleLabeltitle label; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGLabel*fWarnLabellabel for warnings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0); Constructor. Create the dialog window and draw it centered over the; main window 'mf'. A pointer to the style to copy or rename is given; by 'cur' and the parameter 'mode' specify the mode:; 1 = copy | 2 = rename | 3 = import from canvas. ~TStyleDialog(); Destructor. void DoCancel(); Slot called when the Cancel button is clicked. Close the window; without saving submitted changes. void DoCloseWindow(); Slot called when the window is closed via the window manager.; Close the window without saving submitted changes. void DoOK(); Slot called when the OK button is clicked. Rename or create the style; before closing the window. void DoUpdate(); Slot called every time the name is changed. Provide some protection; to avoid letting the user use an empty name or an already used one.; A warning message can be shown and the OK button disabled. Â» Author: Denis Favre-Miville 08/09/05 Â» Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; Â» Last changed: root/ged:$Id: TStyleDialog.h,v 1.0 2005/09/08 Â» Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStyleDialog.html:23326,avoid,avoid,23326,root/html534/TStyleDialog.html,https://root.cern,https://root.cern/root/html534/TStyleDialog.html,1,['avoid'],['avoid']
Safety,"GeoBBox. â—†Â DistFromOutside_v(). void TGeoEltu::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Divide(). TGeoVolume * TGeoEltu::Divide ; (; TGeoVolume *Â ; voldiv, . const char *Â ; divname, . Int_tÂ ; iaxis, . Int_tÂ ; ndiv, . Double_tÂ ; start, . Double_tÂ ; stepÂ . ). overridevirtual . Reimplemented from TGeoBBox. â—†Â GetA(). virtual Double_t TGeoEltu::GetA ; (; ); const. inlinevirtual . Definition at line 47 of file TGeoEltu.h. â—†Â GetB(). virtual Double_t TGeoEltu::GetB ; (; ); const. inlinevirtual . Definition at line 48 of file TGeoEltu.h. â—†Â GetBoundingCylinder(). void TGeoEltu::GetBoundingCylinder ; (; Double_t *Â ; param); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â GetBuffer3D(). const TBuffer3D & TGeoEltu::GetBuffer3D ; (; Int_tÂ ; reqSections, . Bool_tÂ ; localFrameÂ . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoBBox. â—†Â GetMakeRuntimeShape(). TGeoShape * TGeoEltu::GetMakeRuntimeShape ; (; TGeoShape *Â ; mother, . TGeoMatrix *Â ; matÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â GetMeshNumbers(). void TGeoEltu::GetMeshNumbers ; (; Int_t &Â ; nvert, . Int_t &Â ; nsegs, . Int_t &Â ; npolsÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â GetNmeshVertices(). Int_t TGeoEltu::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â GetPointsOnSegments(). Bool_t TGeoEltu::GetPointsOnSegments ; (; Int_tÂ ; , . Double_t *Â ; Â . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 54 of file TGeoEltu.h. â—†Â InspectShape(). void TGeoEltu::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â IsA(). TClass * TGeoEltu::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 65 of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoEltu.html:30038,avoid,avoid,30038,doc/master/classTGeoEltu.html,https://root.cern,https://root.cern/doc/master/classTGeoEltu.html,1,['avoid'],['avoid']
Safety,"GeoCtub::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".; TGeoCtub::GetNhighconst Double_t * GetNhigh() constDefinition TGeoTube.h:214; TGeoCtub::ComputeBBoxvoid ComputeBBox() override; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoTubeSegDefinition TGeoTube.h:94; TGeoTubeSeg::DistFromOutsideDouble_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoTubeSeg::ComputeNormal_vvoid ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override; TGeoTubeSeg::SetPointsvoid SetPoints(Double_t *points) const override; TGeoTubeSeg::CapacityDouble_t Capacity() const override; TGeoTubeSeg::TGeoTubeSegTGeoTubeSeg(); TGeoTubeSeg::~TGeoTubeSeg~TGeoTubeSeg() override; TGeoTubeSeg::DistFromInsideSstatic Double_t DistFromInsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); TGeoTubeSeg::Safety_vvoid Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; TGeoTubeSeg::fPhi1Double_t fPhi1Definition TGeoTube.h:97; TGeoTubeSeg::MakeBuffer3DTBuffer3D * MakeBuffer3D() const override; TGeoTubeSeg::Sizeof3Dvoid Sizeof3D() const override; TGeoTubeSeg::GetPointsOnSegmentsBool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override; TGeoTubeSeg::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override; TGeoTubeSeg::fPhi2Double_t fPhi2Definition TGeoTube.h:98; TGeoTubeSeg::ComputeNormalvoid ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) overr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoTube_8h_source.html:17829,safe,safe,17829,doc/master/TGeoTube_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html,2,['safe'],['safe']
Safety,"GeoEltu::GetMeshNumbers ; (; Int_t &Â ; nvert, . Int_t &Â ; nsegs, . Int_t &Â ; npolsÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â GetNmeshVertices(). Int_t TGeoEltu::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â GetPointsOnSegments(). Bool_t TGeoEltu::GetPointsOnSegments ; (; Int_tÂ ; , . Double_t *Â ; Â . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 54 of file TGeoEltu.h. â—†Â InspectShape(). void TGeoEltu::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â IsA(). TClass * TGeoEltu::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 65 of file TGeoEltu.h. â—†Â IsCylType(). Bool_t TGeoEltu::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 56 of file TGeoEltu.h. â—†Â operator=(). TGeoEltu & TGeoEltu::operator= ; (; const TGeoEltu &Â ; ). privatedelete . â—†Â Safety(). Double_t TGeoEltu::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Safety_v(). void TGeoEltu::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â SavePrimitive(). void TGeoEltu::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. â—†Â SetDimensions(). void TGeoEltu::SetDimensions ; (; Double_t *Â ; param). overridevirtual . Reimplemented from TGeoBBox. â—†Â SetEltuDimensions(). void TGeoEltu::SetEltuDimensions ; (; Double_tÂ ; a, . Double_tÂ ; b, . Double_tÂ ; dzÂ . ). â—†Â SetPoints() [1/2]. void TGeoEltu::SetPoints ; (; Double_t *Â ; points); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â SetPoints() [2/2]. void TGeoEltu::SetPoints ; (; Float_t *Â ; points); const. ov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoEltu.html:31310,Safe,Safety,31310,doc/master/classTGeoEltu.html,https://root.cern,https://root.cern/doc/master/classTGeoEltu.html,1,['Safe'],['Safety']
Safety,"GeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); virtual~TGeoIntersection(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoIntersection.html:2388,safe,safe,2388,root/html528/TGeoIntersection.html,https://root.cern,https://root.cern/root/html528/TGeoIntersection.html,2,['safe'],['safe']
Safety,"GeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tTGeoArb8::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTrap.html:2924,safe,safe,2924,root/html528/TGeoTrap.html,https://root.cern,https://root.cern/root/html528/TGeoTrap.html,1,['safe'],['safe']
Safety,"GeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tTGeoArb8::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoGtra.html:2903,safe,safe,2903,root/html528/TGeoGtra.html,https://root.cern,https://root.cern/root/html528/TGeoGtra.html,1,['safe'],['safe']
Safety,"GeoNavigatorArray::operator=TGeoNavigatorArray & operator=(const TGeoNavigatorArray &)=delete; TGeoNavigatorArray::fGeoManagerTGeoManager * fGeoManagerDefinition TGeoNavigator.h:297; TGeoNavigatorArray::SetCurrentNavigatorTGeoNavigator * SetCurrentNavigator(Int_t inav)Definition TGeoNavigator.h:309; TGeoNavigatorArray::~TGeoNavigatorArray~TGeoNavigatorArray() overrideDefinition TGeoNavigator.h:305; TGeoNavigatorClass providing navigation API for TGeo geometries.Definition TGeoNavigator.h:32; TGeoNavigator::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoNavigator.cxx:352; TGeoNavigator::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoNavigator.cxx:2648; TGeoNavigator::GetMotherTGeoNode * GetMother(Int_t up=1) constDefinition TGeoNavigator.h:155; TGeoNavigator::SetCurrentPointvoid SetCurrentPoint(Double_t x, Double_t y, Double_t z)Definition TGeoNavigator.h:173; TGeoNavigator::fLastPWSaftyPntDouble_t fLastPWSaftyPnt[3]last point for which safety was computedDefinition TGeoNavigator.h:52; TGeoNavigator::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoNavigator.cxx:2657; TGeoNavigator::fPointDouble_t fPoint[3]unit vector to current checked shapeDefinition TGeoNavigator.h:49; TGeoNavigator::IsStepExitingBool_t IsStepExiting() constDefinition TGeoNavigator.h:143; TGeoNavigator::fSearchOverlapsBool_t fSearchOverlapsinternal array for overlapsDefinition TGeoNavigator.h:61; TGeoNavigator::fIsExitingBool_t fIsExitingflag if current step just got into a new nodeDefinition TGeoNavigator.h:65; TGeoNavigator::fPathTString fPathcurrent local matrix of the selected division cellDefinition TGeoNavigator.h:84; TGeoNavigator::fDivMatrixTGeoHMatrix * fDivMatrixcurrent pointer to cached global matrixDefinition TGeoNavigator.h:83; TGeoNavigator::PopPathBool_t PopPath()Definition TGeoNavigator.h:247; TGeoNavigator::CrossBoundaryAndLocateTGeoNode * CrossBoundar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:18484,safe,safety,18484,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safety']
Safety,"GeoPcon. â—†Â Contains_v(). void TGeoPgon::Contains_v ; (; const Double_t *Â ; points, . Bool_t *Â ; inside, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoPcon. â—†Â CreateThreadData(). void TGeoPgon::CreateThreadData ; (; Int_tÂ ; nthreads). overridevirtual . Reimplemented from TGeoShape. â—†Â DeclFileName(). static const char * TGeoPgon::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 118 of file TGeoPgon.h. â—†Â DistancetoPrimitive(). Int_t TGeoPgon::DistancetoPrimitive ; (; Int_tÂ ; px, . Int_tÂ ; pyÂ . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoPcon. â—†Â DistFromInside(). Double_t TGeoPgon::DistFromInside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoPcon. â—†Â DistFromInside_v(). void TGeoPgon::DistFromInside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoPcon. â—†Â DistFromOutside(). Double_t TGeoPgon::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoPcon. â—†Â DistFromOutside_v(). void TGeoPgon::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoPcon. â—†Â Divide(). TGeoVolume * TGeoPgon::Divide ; (; TGeoVolume *Â ; voldiv, . const char *Â ; divname, . Int_tÂ ; iaxis, . Int_tÂ ; ndiv, . Double_tÂ ; start, . Double_tÂ ; stepÂ . ). overridevirtual . Reimpleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPgon.html:28600,safe,safe,28600,doc/master/classTGeoPgon.html,https://root.cern,https://root.cern/doc/master/classTGeoPgon.html,1,['safe'],['safe']
Safety,"GeoScaledShape.cxx. â—†Â DistFromInside(). Double_t TGeoScaledShape::DistFromInside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Compute distance from inside point to surface of the scaled shape. ; Reimplemented from TGeoBBox.; Definition at line 143 of file TGeoScaledShape.cxx. â—†Â DistFromInside_v(). void TGeoScaledShape::DistFromInside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Compute distance from array of input points having directions specified by dirs. Store output in dists. ; Reimplemented from TGeoBBox.; Definition at line 402 of file TGeoScaledShape.cxx. â—†Â DistFromOutside(). Double_t TGeoScaledShape::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Compute distance from outside point to surface of the scaled shape. ; Reimplemented from TGeoBBox.; Definition at line 162 of file TGeoScaledShape.cxx. â—†Â DistFromOutside_v(). void TGeoScaledShape::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Compute distance from array of input points having directions specified by dirs. Store output in dists. ; Reimplemented from TGeoBBox.; Definition at line 412 of file TGeoScaledShape.cxx. â—†Â Divide(). TGeoVolume * TGeoScaledShape::Divide ; (; TGeoVolume *Â ; voldiv, . const char *Â ; divname, . Int_tÂ ; iaxis, . Int_tÂ ; ndiv, . Double_tÂ ; start, . Double_tÂ ; stepÂ . ). overridevirtual . Cannot divide assemblies. ; Reimplemented from TGeoBBox.; Definition at line 186 of file TGeoScaledShape.cxx. â—†Â GetBuffer3D(). const TBuffer3D & TGeoScaledShape::GetBuffer3D ; (; Int_tÂ ; reqSections, . Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoScaledShape.html:28069,safe,safe,28069,doc/master/classTGeoScaledShape.html,https://root.cern,https://root.cern/doc/master/classTGeoScaledShape.html,1,['safe'],['safe']
Safety,"GeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPara.html:2537,safe,safe,2537,root/html534/TGeoPara.html,https://root.cern,https://root.cern/root/html534/TGeoPara.html,9,['safe'],['safe']
Safety,"GeoSubtraction (const char *expr1, const char *expr2); Â Constructor. ; Â ; Â TGeoSubtraction (TGeoShape *left, TGeoShape *right, TGeoMatrix *lmat=nullptr, TGeoMatrix *rmat=nullptr); Â Constructor providing pointers to components. ; Â ; Â ~TGeoSubtraction () override; Â Destructor â€” deletion of components handled by TGeoManager class. ; Â ; voidÂ ComputeBBox (Double_t &dx, Double_t &dy, Double_t &dz, Double_t *origin) override; Â Compute bounding box corresponding to a subtraction of two shapes. ; Â ; voidÂ ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override; Â Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. ; Â ; Bool_tÂ Contains (const Double_t *point) const override; Â Find if a subtraction of two shapes contains a given point. ; Â ; Int_tÂ DistanceToPrimitive (Int_t px, Int_t py) override; Â Compute minimum distance to shape vertices. ; Â ; Double_tÂ DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override; Â Compute distance from a given point inside to the shape boundary. ; Â ; Double_tÂ DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override; Â Compute distance from a given point outside to the shape. ; Â ; EGeoBoolTypeÂ GetBooleanOperator () const override; Â ; Int_tÂ GetNpoints () override; Â Returns number of vertices for the composite shape described by this subtraction. ; Â ; TClass *Â IsA () const override; Â ; TGeoBoolNode *Â MakeClone () const override; Â Make a clone of this. Pointers are preserved. ; Â ; voidÂ Paint (Option_t *option) override; Â Paint method. ; Â ; Double_tÂ Safety (const Double_t *point, Bool_t in=kTRUE) const override; Â Compute safety distance for a union node;. ; Â ; voidÂ SavePrimitive (std::ostream &out, Option_t *option="""") override; Â Save a primitive as a C++ statement(s) on output stream ""out"". ; Â ; voidÂ Sizeof3D () const override; Â Register 3D size of this ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSubtraction.html:1395,safe,safe,1395,doc/master/classTGeoSubtraction.html,https://root.cern,https://root.cern/doc/master/classTGeoSubtraction.html,1,['safe'],['safe']
Safety,"GeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(const Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. TGeoBoolNode& operator=(const TGeoSubtraction& ). EGeoBoolType GetBooleanOperator() const. TGeoSubtraction(); constructors. Â» Author: Andrei Gheata 30/05/02 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: :$Id$ Â» Last generated: 2015-06-02 16:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoSubtraction.html:10202,safe,safe,10202,root/html604/TGeoSubtraction.html,https://root.cern,https://root.cern/root/html604/TGeoSubtraction.html,3,"['Safe', 'safe']","['Safety', 'safe', 'safety']"
Safety,"GeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(const Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. TGeoBoolNode& operator=(const TGeoSubtraction& ). EGeoBoolType GetBooleanOperator() const. TGeoSubtraction(); constructors. Â» Author: Andrei Gheata 30/05/02 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: :$Id$ Â» Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoSubtraction.html:10202,safe,safe,10202,root/html602/TGeoSubtraction.html,https://root.cern,https://root.cern/root/html602/TGeoSubtraction.html,3,"['Safe', 'safe']","['Safety', 'safe', 'safety']"
Safety,"GeoTorus::GetR ; (; ); const. inline . Definition at line 73 of file TGeoTorus.h. â—†Â GetRmax(). Double_t TGeoTorus::GetRmax ; (; ); const. inline . Definition at line 75 of file TGeoTorus.h. â—†Â GetRmin(). Double_t TGeoTorus::GetRmin ; (; ); const. inline . Definition at line 74 of file TGeoTorus.h. â—†Â InspectShape(). void TGeoTorus::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â IsA(). TClass * TGeoTorus::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 91 of file TGeoTorus.h. â—†Â IsCylType(). Bool_t TGeoTorus::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 79 of file TGeoTorus.h. â—†Â MakeBuffer3D(). TBuffer3D * TGeoTorus::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â operator=(). TGeoTorus & TGeoTorus::operator= ; (; const TGeoTorus &Â ; ). protecteddelete . â—†Â Safety(). Double_t TGeoTorus::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Safety_v(). void TGeoTorus::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â SavePrimitive(). void TGeoTorus::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. â—†Â SetDimensions(). void TGeoTorus::SetDimensions ; (; Double_t *Â ; param). overridevirtual . Reimplemented from TGeoBBox. â—†Â SetPoints() [1/2]. void TGeoTorus::SetPoints ; (; Double_t *Â ; points); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â SetPoints() [2/2]. void TGeoTorus::SetPoints ; (; Float_t *Â ; points); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â SetSegsAndPols(). void TGeoTorus::SetSegsAndPols ; (; TBuffer3D &Â ; buff); const. overridevirtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTorus.html:29499,Safe,Safety,29499,doc/master/classTGeoTorus.html,https://root.cern,https://root.cern/doc/master/classTGeoTorus.html,1,['Safe'],['Safety']
Safety,"GeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not his daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. TGeoVolume(); TGeoVolume(const char* name, const TGeoShape* shape, const TGeoMedium* med = 0); virtual~TGeoVolume(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddNode(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat = 0, Option_t* option = """"); voidAddNodeOffset(TGeoVolume* vol, Int_t copy_no, Double_t offset = 0, Option_t* option = """"); virtual voidAddNodeOverlap(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat = 0, Option_t* option = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); Double_tCapacity() const; virtual voidcd(Int_t inode) const; voidCheckGeometry(Int_t nrays = 1, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0) const; voidCheckOverlaps(Double_t ovlp = 0.1, O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:17308,avoid,avoid,17308,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,1,['avoid'],['avoid']
Safety,"GeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not his daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. TGeoVolumeAssembly(); TGeoVolumeAssembly(const char* name); TGeoVolumeAssembly(const TGeoVolumeAssembly&); virtual~TGeoVolumeAssembly(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddNode(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat = 0, Option_t* option = """"); voidTGeoVolume::AddNodeOffset(TGeoVolume* vol, Int_t copy_no, Double_t offset = 0, Option_t* option = """"); virtual voidAddNodeOverlap(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat, Option_t* option); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGeoVolume::Browse(TBrowser* b); Double_tTGeoVolume::Capacity() const; virtual voidTGeoVolume::cd(Int_t inode) const; voidTGeoVolume::CheckGeometry(Int_t nrays = 1, Double_t startx = 0, Double_t starty = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolumeAssembly.html:17271,avoid,avoid,17271,root/html534/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html534/TGeoVolumeAssembly.html,1,['avoid'],['avoid']
Safety,"GeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not his daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. TGeoVolumeMulti(); TGeoVolumeMulti(const char* name, TGeoMedium* med = 0); virtual~TGeoVolumeMulti(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddNode(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat, Option_t* option = """"); voidTGeoVolume::AddNodeOffset(TGeoVolume* vol, Int_t copy_no, Double_t offset = 0, Option_t* option = """"); virtual voidAddNodeOverlap(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat, Option_t* option = """"); voidAddVolume(TGeoVolume* vol); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGeoVolume::Browse(TBrowser* b); Double_tTGeoVolume::Capacity() const; virtual voidTGeoVolume::cd(Int_t inode) const; voidTGeoVolume::CheckGeometry(Int_t nrays = 1, Double_t startx = 0, Double_t starty = 0,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolumeMulti.html:17262,avoid,avoid,17262,root/html534/TGeoVolumeMulti.html,https://root.cern,https://root.cern/root/html534/TGeoVolumeMulti.html,1,['avoid'],['avoid']
Safety,"GeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not its daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. virtual~TGeoVolume(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddNode(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat = 0, Option_t* option = """"); voidAddNodeOffset(TGeoVolume* vol, Int_t copy_no, Double_t offset = 0, Option_t* option = """"); virtual voidAddNodeOverlap(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat = 0, Option_t* option = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); Double_tCapacity() const; virtual voidcd(Int_t inode) const; voidCheckGeometry(Int_t nrays = 1, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0) const; voidCheckOverlaps(Double_t ovlp = 0.10000000000000001, Option_t* option = """") constMENU ; voidCheckShape(Int_t testNo, Int_t nsamples =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolume.html:17308,avoid,avoid,17308,root/html602/TGeoVolume.html,https://root.cern,https://root.cern/root/html602/TGeoVolume.html,2,['avoid'],['avoid']
Safety,"GeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not its daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. virtual~TGeoVolumeAssembly(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddNode(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat = 0, Option_t* option = """"); voidTGeoVolume::AddNodeOffset(TGeoVolume* vol, Int_t copy_no, Double_t offset = 0, Option_t* option = """"); virtual voidAddNodeOverlap(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat, Option_t* option); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGeoVolume::Browse(TBrowser* b); Double_tTGeoVolume::Capacity() const; virtual voidTGeoVolume::cd(Int_t inode) const; voidTGeoVolume::CheckGeometry(Int_t nrays = 1, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0) const; voidTGeoVolume::CheckOverlaps(Double_t ovlp = 0.10000000000000001, Option_t*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolumeAssembly.html:17271,avoid,avoid,17271,root/html602/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html602/TGeoVolumeAssembly.html,2,['avoid'],['avoid']
Safety,"GeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not its daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. virtual~TGeoVolumeMulti(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddNode(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat, Option_t* option = """"); voidTGeoVolume::AddNodeOffset(TGeoVolume* vol, Int_t copy_no, Double_t offset = 0, Option_t* option = """"); virtual voidAddNodeOverlap(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat, Option_t* option = """"); voidAddVolume(TGeoVolume* vol); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGeoVolume::Browse(TBrowser* b); Double_tTGeoVolume::Capacity() const; virtual voidTGeoVolume::cd(Int_t inode) const; voidTGeoVolume::CheckGeometry(Int_t nrays = 1, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0) const; voidTGeoVolume::CheckOverlaps(Double_t ovlp = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolumeMulti.html:17262,avoid,avoid,17262,root/html602/TGeoVolumeMulti.html,https://root.cern,https://root.cern/root/html602/TGeoVolumeMulti.html,2,['avoid'],['avoid']
Safety,"Geometryvoid CheckGeometry(Option_t *option="""")Perform last checks on the geometry.Definition TGeoManager.cxx:3831; TGeoManager::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on this manager.Definition TGeoManager.cxx:3950; TGeoManager::MakeVolumeAssemblyTGeoVolumeAssembly * MakeVolumeAssembly(const char *name)Make an assembly of volumes.Definition TGeoManager.cxx:3553; TGeoManager::GetBombModeInt_t GetBombMode() constDefinition TGeoManager.h:210; TGeoManager::AddRegionInt_t AddRegion(TGeoRegion *region)Add a new region of volumes.Definition TGeoManager.cxx:633; TGeoManager::SelectTrackingMediavoid SelectTrackingMedia()Define different tracking media.Definition TGeoManager.cxx:3708; TGeoManager::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoManager.cxx:1698; TGeoManager::CdTopvoid CdTop()Make top level node the current node.Definition TGeoManager.cxx:1672; TGeoManager::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoManager.cxx:2300; TGeoManager::fKeyPNEIdInt_t * fKeyPNEIdDefinition TGeoManager.h:142; TGeoManager::DefaultAnglesvoid DefaultAngles()Set default angles for a given view.Definition TGeoManager.cxx:1818; TGeoManager::MixtureTGeoMaterial * Mixture(const char *name, Float_t *a, Float_t *z, Double_t dens, Int_t nelem, Float_t *wmat, Int_t uid)Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,...Definition TGeoManager.cxx:1296; TGeoManager::ThreadsMap_tstd::map< std::thread::id, Int_t > ThreadsMap_tDefinition TGeoManager.h:114; TGeoManager::CheckPointvoid CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)Classify a given point. See TGeoChecker::CheckPoint().Definition TGeoManager.cxx:3770; TGeoManager::SetUseParallelWorldNavvoid SetUseParallelWorldNav(Bool_t flag)Activate/deactivate usage of parallel world navigation.Definition TGeoManage",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:212936,Safe,Safety,212936,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,2,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"GetDNDFinished(); { return fgDNDFinished; }. Atom_t GetDNDVersion(); { return fgDNDVersion; }. Atom_t GetDNDActionCopy(); { return fgDNDActionCopy; }. Atom_t GetDNDActionMove(); { return fgDNDActionMove; }. Atom_t GetDNDActionLink(); { return fgDNDActionLink; }. Atom_t GetDNDActionAsk(); { return fgDNDActionAsk; }. Atom_t GetDNDActionPrivate(); { return fgDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGDNDManager.html:10232,timeout,timeout,10232,root/html528/TGDNDManager.html,https://root.cern,https://root.cern/root/html528/TGDNDManager.html,4,['timeout'],['timeout']
Safety,"GetDNDFinished(); { return fgDNDFinished; }. Atom_t GetDNDVersion(); { return fgDNDVersion; }. Atom_t GetDNDActionCopy(); { return fgDNDActionCopy; }. Atom_t GetDNDActionMove(); { return fgDNDActionMove; }. Atom_t GetDNDActionLink(); { return fgDNDActionLink; }. Atom_t GetDNDActionAsk(); { return fgDNDActionAsk; }. Atom_t GetDNDActionPrivate(); { return fgDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t[3] dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGDNDManager.html:10927,timeout,timeout,10927,root/html602/TGDNDManager.html,https://root.cern,https://root.cern/root/html602/TGDNDManager.html,2,['timeout'],['timeout']
Safety,"GetH1 ; (; ); const. inline . Definition at line 132 of file TGeoArb8.h. â—†Â GetH2(). Double_t TGeoTrap::GetH2 ; (; ); const. inline . Definition at line 136 of file TGeoArb8.h. â—†Â GetMakeRuntimeShape(). TGeoShape * TGeoTrap::GetMakeRuntimeShape ; (; TGeoShape *Â ; mother, . TGeoMatrix *Â ; matÂ . ); const. overridevirtual . Reimplemented from TGeoArb8. â—†Â GetPhi(). Double_t TGeoTrap::GetPhi ; (; ); const. inline . Definition at line 131 of file TGeoArb8.h. â—†Â GetTheta(). Double_t TGeoTrap::GetTheta ; (; ); const. inline . Definition at line 130 of file TGeoArb8.h. â—†Â GetTl1(). Double_t TGeoTrap::GetTl1 ; (; ); const. inline . Definition at line 134 of file TGeoArb8.h. â—†Â GetTl2(). Double_t TGeoTrap::GetTl2 ; (; ); const. inline . Definition at line 138 of file TGeoArb8.h. â—†Â IsA(). TClass * TGeoTrap::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoArb8.; Definition at line 146 of file TGeoArb8.h. â—†Â Safety(). Double_t TGeoTrap::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Reimplemented from TGeoArb8. â—†Â Safety_v(). void TGeoTrap::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoArb8. â—†Â SavePrimitive(). void TGeoTrap::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoArb8. â—†Â SetDimensions(). void TGeoTrap::SetDimensions ; (; Double_t *Â ; param). overridevirtual . Reimplemented from TGeoArb8. â—†Â Streamer(). void TGeoTrap::Streamer ; (; TBuffer &Â ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGeoArb8. â—†Â StreamerNVirtual(). void TGeoTrap::StreamerNVirtual ; (; TBuffer &Â ; ClassDef_StreamerNVirtual_b). inline . Definition at line 146 of file TGeoArb8.h. Member Data Documentation. â—†Â fAlpha1. Double_t TGeoTrap::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrap.html:29147,Safe,Safety,29147,doc/master/classTGeoTrap.html,https://root.cern,https://root.cern/doc/master/classTGeoTrap.html,1,['Safe'],['Safety']
Safety,"GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n random points located on the line segments of the shape mesh.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation is implemented. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buffer) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyS(Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Int_t skipz = 0); computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetConeDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Set cone dimensions. void SetDimensions(Double_t* param); Set cone dimensions from an array. void SetPoints(Double_t* points) const; Create cone mesh points. void SetPoints(Float_t* points) const; Create cone mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if (!painter) return;; Int_t n = gGeoManager",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCone.html:16584,Safe,SafetyS,16584,root/html528/TGeoCone.html,https://root.cern,https://root.cern/root/html528/TGeoCone.html,3,['Safe'],['SafetyS']
Safety,"GetNbins() ) lastBinY += 1;; 1274 }; 1275 }; 1276 // check for labels axis. In that case corresponding statistics do not make sense and it is set to zero; 1277 Bool_t labelXaxis = ((const_cast<TAxis&>(fXaxis)).GetLabels() && fXaxis.CanExtend() );; 1278 Bool_t labelYaxis = ((const_cast<TAxis&>(fYaxis)).GetLabels() && fYaxis.CanExtend() );; 1279 ; 1280 for (Int_t biny = firstBinY; biny <= lastBinY; ++biny) {; 1281 Double_t y = (!labelYaxis) ? fYaxis.GetBinCenter(biny) : 0;; 1282 for (Int_t binx = firstBinX; binx <= lastBinX; ++binx) {; 1283 Double_t x = (!labelXaxis) ? fXaxis.GetBinCenter(binx) : 0;; 1284 //w = TMath::Abs(GetBinContent(bin));; 1285 Int_t bin = GetBin(binx,biny);; 1286 Double_t w = RetrieveBinContent(bin);; 1287 Double_t wx = w * x; // avoid some extra multiplications at the expense of some clarity; 1288 Double_t wy = w * y;; 1289 ; 1290 stats[0] += w;; 1291 stats[1] += GetBinErrorSqUnchecked(bin);; 1292 stats[2] += wx;; 1293 stats[3] += wx * x;; 1294 stats[4] += wy;; 1295 stats[5] += wy * y;; 1296 stats[6] += wx * y;; 1297 }; 1298 }; 1299 } else {; 1300 stats[0] = fTsumw;; 1301 stats[1] = fTsumw2;; 1302 stats[2] = fTsumwx;; 1303 stats[3] = fTsumwx2;; 1304 stats[4] = fTsumwy;; 1305 stats[5] = fTsumwy2;; 1306 stats[6] = fTsumwxy;; 1307 }; 1308}; 1309 ; 1310 ; 1311////////////////////////////////////////////////////////////////////////////////; 1312/// Return integral of bin contents. Only bins in the bins range are considered.; 1313/// By default the integral is computed as the sum of bin contents in the range.; 1314/// if option ""width"" is specified, the integral is the sum of; 1315/// the bin contents multiplied by the bin width in x and in y.; 1316 ; 1317Double_t TH2::Integral(Option_t *option) const; 1318{; 1319 return Integral(fXaxis.GetFirst(),fXaxis.GetLast(),; 1320 fYaxis.GetFirst(),fYaxis.GetLast(),option);; 1321}; 1322 ; 1323 ; 1324////////////////////////////////////////////////////////////////////////////////; 1325/// Return integral of bin ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:52254,avoid,avoid,52254,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['avoid'],['avoid']
Safety,"GetStOut(). Double_t TGeoHype::GetStOut ; (; ); const. inline . Definition at line 73 of file TGeoHype.h. â—†Â HasInner(). Bool_t TGeoHype::HasInner ; (; ); const. inline . Definition at line 74 of file TGeoHype.h. â—†Â InspectShape(). void TGeoHype::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â IsA(). TClass * TGeoHype::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 92 of file TGeoHype.h. â—†Â IsCylType(). Bool_t TGeoHype::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 78 of file TGeoHype.h. â—†Â MakeBuffer3D(). TBuffer3D * TGeoHype::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â operator=(). TGeoHype & TGeoHype::operator= ; (; const TGeoHype &Â ; ). privatedelete . â—†Â RadiusHypeSq(). Double_t TGeoHype::RadiusHypeSq ; (; Double_tÂ ; z, . Bool_tÂ ; innerÂ . ); const. â—†Â Safety(). Double_t TGeoHype::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Safety_v(). void TGeoHype::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â SafetyToHype(). Double_t TGeoHype::SafetyToHype ; (; const Double_t *Â ; point, . Bool_tÂ ; inner, . Bool_tÂ ; inÂ . ); const. â—†Â SavePrimitive(). void TGeoHype::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. â—†Â SetDimensions(). void TGeoHype::SetDimensions ; (; Double_t *Â ; param). overridevirtual . Reimplemented from TGeoBBox. â—†Â SetHypeDimensions(). void TGeoHype::SetHypeDimensions ; (; Double_tÂ ; rin, . Double_tÂ ; stin, . Double_tÂ ; rout, . Double_tÂ ; stout, . Double_tÂ ; dzÂ . ). â—†Â SetPoints() [1/2]. void TGeoHype::SetPoints ; (; Double_t *Â ; points); co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHype.html:33121,Safe,Safety,33121,doc/master/classTGeoHype.html,https://root.cern,https://root.cern/doc/master/classTGeoHype.html,1,['Safe'],['Safety']
Safety,"GetSumOfWeights()*intBin;; 148 ; 149 if (nS > 0 && nB > 0) {; 150 for (Int_t bin=0; bin<nstep; bin++) {; 151 Double_t s = S->GetBinContent( bin+1 )/Double_t(nS);; 152 Double_t b = B->GetBinContent( bin+1 )/Double_t(nB);; 153 // separation; 154 if (s + b > 0) separation += (s - b)*(s - b)/(s + b);; 155 }; 156 separation *= (0.5*intBin);; 157 }; 158 else {; 159 Log() << kWARNING << ""<GetSeparation> histograms with zero entries: ""; 160 << nS << "" : "" << nB << "" cannot compute separation""; 161 << Endl;; 162 separation = 0;; 163 }; 164 ; 165 return separation;; 166}; 167 ; 168////////////////////////////////////////////////////////////////////////////////; 169/// compute ""separation"" defined as; 170/// \f[; 171/// <s2> = \frac{1}{2} \int_{-\infty}^{+\infty} \frac{(S(x) - B(x))^2}{(S(x) + B(x))} dx; 172/// \f]; 173 ; 174Double_t TMVA::Tools::GetSeparation( const PDF& pdfS, const PDF& pdfB ) const; 175{; 176 Double_t xmin = pdfS.GetXmin();; 177 Double_t xmax = pdfS.GetXmax();; 178 // sanity check; 179 if (xmin != pdfB.GetXmin() || xmax != pdfB.GetXmax()) {; 180 Log() << kFATAL << ""<GetSeparation> Mismatch in PDF limits: ""; 181 << xmin << "" "" << pdfB.GetXmin() << xmax << "" "" << pdfB.GetXmax() << Endl;; 182 }; 183 ; 184 Double_t separation = 0;; 185 Int_t nstep = 100;; 186 Double_t intBin = (xmax - xmin)/Double_t(nstep);; 187 for (Int_t bin=0; bin<nstep; bin++) {; 188 Double_t x = (bin + 0.5)*intBin + xmin;; 189 Double_t s = pdfS.GetVal( x );; 190 Double_t b = pdfB.GetVal( x );; 191 // separation; 192 if (s + b > 0) separation += (s - b)*(s - b)/(s + b);; 193 }; 194 separation *= (0.5*intBin);; 195 ; 196 return separation;; 197}; 198 ; 199////////////////////////////////////////////////////////////////////////////////; 200/// sanity check; 201 ; 202void TMVA::Tools::ComputeStat( const std::vector<TMVA::Event*>& events, std::vector<Float_t>* valVec,; 203 Double_t& meanS, Double_t& meanB,; 204 Double_t& rmsS, Double_t& rmsB,; 205 Double_t& xmin, Double_t& xmax,; 206 Int_t sign",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:6082,sanity check,sanity check,6082,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['sanity check'],['sanity check']
Safety,"GradientVector ; (; ). protected . make gradient vector ; Definition at line 1375 of file RuleFitParams.cxx. â—†Â MakeTstGradientVector(). void TMVA::RuleFitParams::MakeTstGradientVector ; (; ). protected . make test gradient vector for all tau same algorithm as MakeGradientVector() ; Definition at line 1259 of file RuleFitParams.cxx. â—†Â Optimism(). Double_t TMVA::RuleFitParams::Optimism ; (; ). protected . implementation of eq. ; 7.17 in Hastie,Tibshirani & Friedman book this is the covariance between the estimated response yhat and the true value y. NOT REALLY SURE IF THIS IS CORRECT! â€” THIS IS NOT USED â€” ; Definition at line 925 of file RuleFitParams.cxx. â—†Â Penalty(). Double_t TMVA::RuleFitParams::Penalty ; (; ); const. This is the ""lasso"" penalty To be used for regression. ; â€” NOT USED â€” ; Definition at line 356 of file RuleFitParams.cxx. â—†Â Risk() [1/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_tÂ ; ind1, . UInt_tÂ ; ind2, . Double_tÂ ; neffÂ . ); const. risk assessment ; Definition at line 314 of file RuleFitParams.cxx. â—†Â Risk() [2/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_tÂ ; ind1, . UInt_tÂ ; ind2, . Double_tÂ ; neff, . UInt_tÂ ; itauÂ . ); const. risk assessment for tau model <itau> ; Definition at line 334 of file RuleFitParams.cxx. â—†Â RiskPath(). Double_t TMVA::RuleFitParams::RiskPath ; (; ); const. inline . Definition at line 108 of file RuleFitParams.h. â—†Â RiskPerf() [1/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; ); const. inline . Definition at line 109 of file RuleFitParams.h. â—†Â RiskPerf() [2/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; UInt_tÂ ; itau); const. inline . Definition at line 110 of file RuleFitParams.h. â—†Â RiskPerfTst(). UInt_t TMVA::RuleFitParams::RiskPerfTst ; (; ). Estimates the error rate with the current set of parameters. ; using the <Perf> subsample. Return the tau index giving the lowest error ; Definition at line 1201 of file RuleFitParams.cxx. â—†Â SetGDErrScale(). void TMVA::RuleFitParams::SetGDErrScale ; (; Double_tÂ ; s). inline",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:16567,risk,risk,16567,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['risk'],['risk']
Safety,"GraphAsymmErrors::TGraphAsymmErrors ; (; const TH1 *Â ; pass, . const TH1 *Â ; total, . Option_t *Â ; option = """"Â . ). Creates a TGraphAsymmErrors by dividing two input TH1 histograms: pass/total. ; (see TGraphAsymmErrors::Divide) ; Definition at line 260 of file TGraphAsymmErrors.cxx. â—†Â TGraphAsymmErrors() [10/10]. TGraphAsymmErrors::TGraphAsymmErrors ; (; const char *Â ; filename, . const char *Â ; format = ""%lgÂ %lgÂ %lgÂ %lgÂ %lgÂ %lg"", . Option_t *Â ; option = """"Â . ). TGraphAsymmErrors constructor reading input from filename filename is assumed to contain at least 2 columns of numbers. ; convention for format (default=""%lg %lg %lg %lg %lg %lg""); format = ""%lg %lg"" read only 2 first columns into X, Y; format = ""%lg %lg %lg %lg"" read only 4 first columns into X, Y, ELY, EHY; format = ""%lg %lg %lg %lg %lg %lg"" read only 6 first columns into X, Y, EXL, EYH, EYL, EHY. For files separated by a specific delimiter different from â€˜â€™ 'and'\t'(e.g.';'in csv files) you can avoid using%*sto bypass this delimiter by explicitly specify the""option"" argument, e.g. option="" \\t,;"" for columns of figures separated by any of these characters â€˜(â€™ ', '\t', ',', ';') used once(e.g. ""1;1"")or in a combined way("" 1;,;; 1""). Note in that case, the instantiation is about 2 times slower. In case a delimiter is specified, the format""%lg %lg %lg""` will read X,Y,EX. ; Definition at line 299 of file TGraphAsymmErrors.cxx. â—†Â ~TGraphAsymmErrors(). TGraphAsymmErrors::~TGraphAsymmErrors ; (; ). override . TGraphAsymmErrors default destructor. ; Definition at line 433 of file TGraphAsymmErrors.cxx. Member Function Documentation. â—†Â AddPointError(). void TGraphAsymmErrors::AddPointError ; (; Double_tÂ ; x, . Double_tÂ ; y, . Double_tÂ ; exl = 0., . Double_tÂ ; exh = 0., . Double_tÂ ; eyl = 0., . Double_tÂ ; eyh = 0.Â . ). virtual . Add a point with asymmetric errorbars to the graph. ; Definition at line 451 of file TGraphAsymmErrors.cxx. â—†Â Allocate(). Double_t ** TGraphAsymmErrors::Allocate ; (; Int_tÂ ; size). overrid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphAsymmErrors.html:39677,avoid,avoid,39677,doc/master/classTGraphAsymmErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphAsymmErrors.html,1,['avoid'],['avoid']
Safety,"Group_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:30273,Abort,Abort,30273,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,6,['Abort'],['Abort']
Safety,"GuessObsAndNuisance(const RooAbsData& data); Makes sensible guesses of observables, parameters of interest; and nuisance parameters. Defaults:; observables: determined from data,; global observables = explicit obs - obs from data; parameters of interest: empty,; nuisance parameters: all parameters except parameters of interest. We use NULL to mean not set, so we don't want to fill; with empty RooArgSets. void Print(Option_t* option = """") const; print contents. void SetWS(RooWorkspace& ws); set a workspace that owns all the necessary components for the analysis. RooWorkspace * GetWS() const; get from TRef. void SetSnapshot(const RooArgSet& set); save snaphot in the workspace; and use values passed with the set. const RooArgSet * GetSnapshot() const; Load the snapshot from ws and return the corresponding set with the snapshot values.; User must delete returned RooArgSet. void LoadSnapshot() const; load the snapshot from ws if it exists. void DefineSetInWS(const char* name, const RooArgSet& set); helper functions to avoid code duplication. void ImportPdfInWS(const RooAbsPdf& pdf); internal function to import Pdf in WS. void ImportDataInWS(RooAbsData& data); internal function to import data in WS. ModelConfig(RooWorkspace* ws = 0). ModelConfig(const char* name, RooWorkspace* ws = 0). ModelConfig(const char* name, const char* title, RooWorkspace* ws = 0). ModelConfig * Clone(const char* name = """") const; clone. void SetWorkspace(RooWorkspace& ws); alias for SetWS(...). { SetWS(ws); }. void SetProtoData(RooAbsData& data); Set the proto DataSet, add to the the workspace if not already there. SetProtoData(const char* name). void SetPdf(const RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. SetPdf(const char* name). void SetPriorPdf(const RooAbsPdf& pdf); Set the Prior Pdf, add to the the workspace if not already there. SetPriorPdf(const char* name). void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__ModelConfig.html:9056,avoid,avoid,9056,root/html528/RooStats__ModelConfig.html,https://root.cern,https://root.cern/root/html528/RooStats__ModelConfig.html,3,['avoid'],['avoid']
Safety,"H2 (h2) as input.; Only the h2's bins within the X and Y axis ranges are used.; Empty bins, recognized when both content and errors are zero, are excluded. TGraph2D(const char* name, const char* title, Int_t n, Double_t* x, Double_t* y, Double_t* z); Graph2D constructor with name, title and three vectors of doubles as input.; name : name of 2D graph (avoid blanks); title : 2D graph title; if title is of the form ""stringt;stringx;stringy;stringz""; the 2D graph title is set to stringt, the x axis title to stringx,; the y axis title to stringy,etc. TGraph2D(Int_t n); Graph2D constructor. The arrays fX, fY and fZ should be filled via; calls to SetPoint. TGraph2D(const char* filename, const char* format = ""%lg %lg %lg"", Option_t* option = """"); Graph2D constructor reading input from filename; filename is assumed to contain at least three columns of numbers.; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files); you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower. TGraph2D(const TGraph2D& ); Graph2D copy constructor. ~TGraph2D(); TGraph2D destructor. TGraph2D& operator=(const TGraph2D& ); Graph2D operator ""="". void Build(Int_t n); Creates the 2D graph basic data structure. void Clear(Option_t* option = """"); Free all memory allocated by this object. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the graph to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); Computes distance from point px,py to a graph. void Draw(Option_t* option = """"); Specific drawing options can be used to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraph2D.html:18866,avoid,avoid,18866,root/html532/TGraph2D.html,https://root.cern,https://root.cern/root/html532/TGraph2D.html,1,['avoid'],['avoid']
Safety,"H2 (h2) as input.; Only the h2's bins within the X and Y axis ranges are used.; Empty bins, recognized when both content and errors are zero, are excluded. TGraph2D(const char* name, const char* title, Int_t n, Double_t* x, Double_t* y, Double_t* z); Graph2D constructor with name, title and three vectors of doubles as input.; name : name of 2D graph (avoid blanks); title : 2D graph title; if title is of the form ""stringt;stringx;stringy;stringz""; the 2D graph title is set to stringt, the x axis title to stringx,; the y axis title to stringy,etc. TGraph2D(Int_t n); Graph2D constructor. The arrays fX, fY and fZ should be filled via; calls to SetPoint. TGraph2D(const char* filename, const char* format = ""%lg %lg %lg"", Option_t* option = """"); Graph2D constructor reading input from filename; filename is assumed to contain at least three columns of numbers.; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files); you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower. TGraph2D(const TGraph2D& ); Graph2D copy constructor.; copy everything apart from the list of contained functions. ~TGraph2D(); TGraph2D destructor. TGraph2D& operator=(const TGraph2D& ); Graph2D operator ""="". void Build(Int_t n); Creates the 2D graph basic data structure. void Browse(TBrowser* ); Browse. void Clear(Option_t* option = """"); Free all memory allocated by this object. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the graph to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); Computes distance from poi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraph2D.html:19177,avoid,avoid,19177,root/html534/TGraph2D.html,https://root.cern,https://root.cern/root/html534/TGraph2D.html,3,['avoid'],['avoid']
Safety,"HEADER> IdTransformation : Ranking result (top variable is best ranked); : -----------------------------; : Rank : Variable : Separation; : -----------------------------; : 1 : var4 : 3.564e-01; : 2 : var3 : 2.899e-01; : 3 : var1 : 2.792e-01; : 4 : var2 : 2.260e-01; : -----------------------------; <HEADER> Factory : Train method: BDT for Classification; : ; <HEADER> BDT : #events: (reweighted) sig: 3000 bkg: 3000; : #events: (unweighted) sig: 3000 bkg: 3000; : Training 300 Decision Trees ... patience please; : Elapsed time for training with 6000 events: 0.538 sec ; <HEADER> BDT : [tmva003_BDT] : Evaluation of BDT on training sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0709 sec ; : Creating xml weight file: tmva003_BDT/weights/tmva003_BDT.weights.xml; : Creating standalone class: tmva003_BDT/weights/tmva003_BDT.class.C; : TMVARR.root:/tmva003_BDT/Method_BDT/BDT; <HEADER> Factory : Training finished; : ; : Ranking input variables (method specific)...; <HEADER> BDT : Ranking result (top variable is best ranked); : --------------------------------------; : Rank : Variable : Variable Importance; : --------------------------------------; : 1 : var4 : 3.940e-01; : 2 : var1 : 2.619e-01; : 3 : var2 : 1.849e-01; : 4 : var3 : 1.592e-01; : --------------------------------------; <HEADER> Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: tmva003_BDT/weights/tmva003_BDT.weights.xml; Single-event inference: 0.233873; ; RTensor input for inference on data of multiple events:; { { -1.14361, -0.822373, -0.495426, -0.629427 } { 2.14344, -0.0189228, 0.26703, 1.26749 } { -0.443913, 0.486827, 0.139535, 0.611483 } }; ; Prediction performed on multiple events: { 0.173541, -0.0540229, 0.266502 }; ; DateJuly 2019 ; AuthorStefan Wunsch ; Definition in file tmva003_RReader.C. tutorialstmvatmva003_RReader.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8 Â Â ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva003__RReader_8C.html:11256,Predict,Prediction,11256,doc/master/tmva003__RReader_8C.html,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html,1,['Predict'],['Prediction']
Safety,"HEP,JDAHEP ; DOUBLE PRECISION PHEP,VHEP ; The generic member functions SetParameter and GetParameter can be overloaded to set and get parameters of the event generator.; Note, if the derived class interfaces a (set of) Fortran common blocks (like TPythia, TVenus does), one better make the derived class a singleton. That is, something like; class MyGenerator : public TGenerator ; { ; public: ; static MyGenerator* Instance() ; { ; if (!fgInstance) fgInstance = new MyGenerator; ; return fgInstance; ; } ; void GenerateEvent() { ... } ; void ImportParticles(TClonesArray* a, Option_t opt="""") {...} ; Int_t ImportParticles(Option_t opt="""") { ... } ; Int_t SetParameter(const char* name, Double_t val) { ... } ; Double_t GetParameter(const char* name) { ... } ; virtual ~MyGenerator() { ... } ; protected: ; MyGenerator() { ... } ; MyGenerator(const MyGenerator& o) { ... } ; MyGenerator& operator=(const MyGenerator& o) { ... } ; static MyGenerator* fgInstance; ; ClassDefOverride(MyGenerator,0); ; }; ; Having multiple objects accessing the same common blocks is not ; safe. . Concrete TGenerator classes can be loaded in scripts and subseqent- ; ly used in compiled code: . // MyRun.h ; class MyRun : public TObject ; { ; public: ; static MyRun* Instance() { ... } ; void SetGenerator(TGenerator* g) { fGenerator = g; } ; void Run(Int_t n, Option_t* option="""") ; { ; TFile* file = TFile::Open(""file.root"",""RECREATE""); ; TTree* tree = new TTree(""T"",""T""); ; TClonesArray* p = new TClonesArray(""TParticles""); ; tree->Branch(""particles"", &p); ; for (Int_t event = 0; event < n; event++) { ; fGenerator->GenerateEvent(); ; fGenerator->ImportParticles(p,option); ; tree->Fill(); ; } ; file->Write(); ; file->Close(); ; } ; ... ; protected: ; TGenerator* fGenerator; ; ClassDefOverride(MyRun,0); ; }; ; ; // Config.C ; void Config() ; { ; MyRun* run = MyRun::Instance(); ; run->SetGenerator(MyGenerator::Instance()); ; } ; ; // main.cxx ; int ; main(int argc, char** argv) ; { ; TApplication app("""", 0, 0)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenerator.html:2719,safe,safe,2719,doc/master/classTGenerator.html,https://root.cern,https://root.cern/doc/master/classTGenerator.html,1,['safe'],['safe']
Safety,"HIS_NOW)). Definition at line 475 of file RConfig.hxx. â—†Â R__ALWAYS_INLINE. #define R__ALWAYS_INLINEÂ Â Â inline. Definition at line 552 of file RConfig.hxx. â—†Â R__ALWAYS_SUGGEST_ALTERNATIVE. #define R__ALWAYS_SUGGEST_ALTERNATIVE; (; Â ; ALTERNATIVE); Â Â Â  _R__DEPRECATED_LATER(""There is a superior alternative: "" ALTERNATIVE). Definition at line 515 of file RConfig.hxx. â—†Â R__ANSISTREAM. #define R__ANSISTREAMÂ Â Â /* ANSI C++ Standard Library conformant */. Definition at line 37 of file RConfig.hxx. â—†Â R__DEPRECATED. #define R__DEPRECATED; (; Â ; MAJOR, . Â ; MINOR, . Â ; REASONÂ . ); Â Â Â  _R__JOIN3_(_R__DEPRECATED_,MAJOR,MINOR)(""will be removed in ROOT v"" #MAJOR ""."" #MINOR "": "" REASON). Definition at line 504 of file RConfig.hxx. â—†Â R__HIDDEN. #define R__HIDDEN. Definition at line 349 of file RConfig.hxx. â—†Â R__INTENTIONALLY_UNINIT_BEGIN. #define R__INTENTIONALLY_UNINIT_BEGIN. Definition at line 541 of file RConfig.hxx. â—†Â R__INTENTIONALLY_UNINIT_END. #define R__INTENTIONALLY_UNINIT_END. Definition at line 542 of file RConfig.hxx. â—†Â R__likely. #define R__likely; (; Â ; expr); Â Â Â expr. Definition at line 587 of file RConfig.hxx. â—†Â R__NEVER_INLINE. #define R__NEVER_INLINEÂ Â Â inline. Definition at line 564 of file RConfig.hxx. â—†Â R__SIZEDDELETE. #define R__SIZEDDELETE. Definition at line 341 of file RConfig.hxx. â—†Â R__SSTREAM. #define R__SSTREAMÂ Â Â /* use sstream or strstream header */. Definition at line 38 of file RConfig.hxx. â—†Â R__SUGGEST_ALTERNATIVE. #define R__SUGGEST_ALTERNATIVE; (; Â ; ALTERNATIVE). Definition at line 512 of file RConfig.hxx. â—†Â R__unlikely. #define R__unlikely; (; Â ; expr); Â Â Â expr. Definition at line 586 of file RConfig.hxx. â—†Â R__USE_SHADOW_CLASS. #define R__USE_SHADOW_CLASS. Definition at line 34 of file RConfig.hxx. â—†Â SafeDelete. #define SafeDelete; (; Â ; p); Â Â Â { delete p; p = nullptr; }. Definition at line 525 of file RConfig.hxx. corefoundationincROOTRConfig.hxx. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:09:45 (GVA Time) using Doxygen 1.9.8 Â Â ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RConfig_8hxx.html:5478,Safe,SafeDelete,5478,doc/v632/RConfig_8hxx.html,https://root.cern,https://root.cern/doc/v632/RConfig_8hxx.html,2,['Safe'],['SafeDelete']
Safety,"HistB_smooth)[ivar]->Write();; 1424 (*fVarPdfS)[ivar]->GetPDFHist()->Write();; 1425 (*fVarPdfB)[ivar]->GetPDFHist()->Write();; 1426 }; 1427 }; 1428}; 1429 ; 1430////////////////////////////////////////////////////////////////////////////////; 1431/// Overloaded function to create background efficiency (rejection) versus; 1432/// signal efficiency plot (first call of this function).; 1433///; 1434/// The function returns the signal efficiency at background efficiency; 1435/// indicated in theString; 1436///; 1437/// ""theString"" must have two entries:; 1438/// - `[0]`: ""Efficiency""; 1439/// - `[1]`: the value of background efficiency at which the signal efficiency; 1440/// is to be returned; 1441 ; 1442Double_t TMVA::MethodCuts::GetTrainingEfficiency(const TString& theString); 1443{; 1444 // parse input string for required background efficiency; 1445 TList* list = gTools().ParseFormatLine( theString );; 1446 // sanity check; 1447 if (list->GetSize() != 2) {; 1448 Log() << kFATAL << ""<GetTrainingEfficiency> wrong number of arguments""; 1449 << "" in string: "" << theString; 1450 << "" | required format, e.g., Efficiency:0.05"" << Endl;; 1451 return -1;; 1452 }; 1453 ; 1454 Results* results = Data()->GetResults(GetMethodName(), Types::kTesting, GetAnalysisType());; 1455 ; 1456 // that will be the value of the efficiency retured (does not affect; 1457 // the efficiency-vs-bkg plot which is done anyway.; 1458 Float_t effBref = atof( ((TObjString*)list->At(1))->GetString() );; 1459 ; 1460 delete list;; 1461 ; 1462 // first round ? --> create histograms; 1463 if (results->GetHist(""EFF_BVSS_TR"")==0) {; 1464 ; 1465 if (fBinaryTreeS != 0) { delete fBinaryTreeS; fBinaryTreeS = 0; }; 1466 if (fBinaryTreeB != 0) { delete fBinaryTreeB; fBinaryTreeB = 0; }; 1467 ; 1468 fBinaryTreeS = new BinarySearchTree();; 1469 fBinaryTreeS->Fill( GetEventCollection(Types::kTraining), fSignalClass );; 1470 fBinaryTreeB = new BinarySearchTree();; 1471 fBinaryTreeB->Fill( GetEventCollection(Types::kTrai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:55450,sanity check,sanity check,55450,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['sanity check'],['sanity check']
Safety,"HistoTrue when SetHistogram has been called. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraph2D(); Graph2D default constructor. TGraph2D(Int_t n, Int_t* x, Int_t* y, Int_t* z); Graph2D constructor with three vectors of ints as input. TGraph2D(Int_t n, Float_t* x, Float_t* y, Float_t* z); Graph2D constructor with three vectors of floats as input. TGraph2D(Int_t n, Double_t* x, Double_t* y, Double_t* z); Graph2D constructor with three vectors of doubles as input. TGraph2D(TH2* h2); Graph2D constructor with a TH2 (h2) as input.; Only the h2's bins within the X and Y axis ranges are used.; Empty bins, recognized when both content and errors are zero, are excluded. TGraph2D(const char* name, const char* title, Int_t n, Double_t* x, Double_t* y, Double_t* z); Graph2D constructor with name, title and three vectors of doubles as input.; name : name of 2D graph (avoid blanks); title : 2D graph title; if title is of the form ""stringt;stringx;stringy;stringz""; the 2D graph title is set to stringt, the x axis title to stringx,; the y axis title to stringy,etc. TGraph2D(Int_t n); Graph2D constructor. The arrays fX, fY and fZ should be filled via; calls to SetPoint. TGraph2D(const char* filename, const char* format = ""%lg %lg %lg"", Option_t* option = """"); Graph2D constructor reading input from filename; filename is assumed to contain at least three columns of numbers. TGraph2D(const TGraph2D& ); Graph2D copy constructor. ~TGraph2D(); TGraph2D destructor. TGraph2D& operator=(const TGraph2D& ); Graph2D operator ""="". void Build(Int_t n); Creates the 2D graph basic data structure. void Clear(Option_t* option = """"); Free all memory allocated by this object. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the graph to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraph2D.html:18149,avoid,avoid,18149,root/html528/TGraph2D.html,https://root.cern,https://root.cern/root/html528/TGraph2D.html,2,['avoid'],['avoid']
Safety,"HistoTrue when SetHistogram has been called. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraph2D(); Graph2D default constructor. TGraph2D(Int_t n, Int_t* x, Int_t* y, Int_t* z); Graph2D constructor with three vectors of ints as input. TGraph2D(Int_t n, Float_t* x, Float_t* y, Float_t* z); Graph2D constructor with three vectors of floats as input. TGraph2D(Int_t n, Double_t* x, Double_t* y, Double_t* z); Graph2D constructor with three vectors of doubles as input. TGraph2D(TH2* h2); Graph2D constructor with a TH2 (h2) as input.; Only the h2's bins within the X and Y axis ranges are used.; Empty bins, recognized when both content and errors are zero, are excluded. TGraph2D(const char* name, const char* title, Int_t n, Double_t* x, Double_t* y, Double_t* z); Graph2D constructor with name, title and three vectors of doubles as input.; name : name of 2D graph (avoid blanks); title : 2D graph title; if title is of the form ""stringt;stringx;stringy;stringz""; the 2D graph title is set to stringt, the x axis title to stringx,; the y axis title to stringy,etc. TGraph2D(Int_t n); Graph2D constructor. The arrays fX, fY and fZ should be filled via; calls to SetPoint. TGraph2D(const char* filename, const char* format = ""%lg %lg %lg"", Option_t* option = """"); Graph2D constructor reading input from filename; filename is assumed to contain at least three columns of numbers.; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files); you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower. TGraph2D(const TGraph2D& ); Graph2D copy constructor. ~TGraph2D(); TGraph2D destructor. TGraph2D& operator=(const TGraph2D& ); Graph2D operator ""="". void Buil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraph2D.html:18249,avoid,avoid,18249,root/html532/TGraph2D.html,https://root.cern,https://root.cern/root/html532/TGraph2D.html,1,['avoid'],['avoid']
Safety,"HistoTrue when SetHistogram has been called. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraph2D(); Graph2D default constructor. TGraph2D(Int_t n, Int_t* x, Int_t* y, Int_t* z); Graph2D constructor with three vectors of ints as input. TGraph2D(Int_t n, Float_t* x, Float_t* y, Float_t* z); Graph2D constructor with three vectors of floats as input. TGraph2D(Int_t n, Double_t* x, Double_t* y, Double_t* z); Graph2D constructor with three vectors of doubles as input. TGraph2D(TH2* h2); Graph2D constructor with a TH2 (h2) as input.; Only the h2's bins within the X and Y axis ranges are used.; Empty bins, recognized when both content and errors are zero, are excluded. TGraph2D(const char* name, const char* title, Int_t n, Double_t* x, Double_t* y, Double_t* z); Graph2D constructor with name, title and three vectors of doubles as input.; name : name of 2D graph (avoid blanks); title : 2D graph title; if title is of the form ""stringt;stringx;stringy;stringz""; the 2D graph title is set to stringt, the x axis title to stringx,; the y axis title to stringy,etc. TGraph2D(Int_t n); Graph2D constructor. The arrays fX, fY and fZ should be filled via; calls to SetPoint. TGraph2D(const char* filename, const char* format = ""%lg %lg %lg"", Option_t* option = """"); Graph2D constructor reading input from filename; filename is assumed to contain at least three columns of numbers.; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files); you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower. TGraph2D(const TGraph2D& ); Graph2D copy constructor.; copy everything apart from the list of contained functions. ~TGraph2D(); TGraph2D destructor. TGraph2D&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraph2D.html:18560,avoid,avoid,18560,root/html534/TGraph2D.html,https://root.cern,https://root.cern/root/html534/TGraph2D.html,3,['avoid'],['avoid']
Safety,"Hook(TSlave_t xslavehook); virtual voidTObject::SetUniqueID(UInt_t uid); virtual Int_tSetupServ(Int_t stype, const char* conffile); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTSlave::Touch(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTSlave::FlushSocket(); virtual voidTSlave::Interrupt(Int_t type); voidTObject::MakeZombie(); virtual Int_tTSlave::Ping(); virtual TObjString*TSlave::SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); virtual Int_tTSlave::SendGroupPriority(const char*, Int_t); virtual voidTSlave::SetAlias(const char* alias); voidTSlave::SetSocket(TSocket* s); virtual voidTSlave::SetStatus(Int_t st); virtual voidTSlave::StopProcess(Bool_t abort, Int_t timeout). private:. voidInit(). Data Members; public:. enum TSlave::ESlaveType { kMaster; kSlave; };; enum TSlave::ESlaveStatus { kInvalid; kActive; kInactive; };; enum TSlave::EStatusBits { kOutputRequested; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info obtained from slave); TStringTSlave::fGroupslave's group id; TStringTS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSlaveLite.html:6648,abort,abort,6648,root/html534/TSlaveLite.html,https://root.cern,https://root.cern/root/html534/TSlaveLite.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"ID = rhs.fUniqueID; // when really unique don't copy; 300 if (IsOnHeap()) { // test uses fBits so don't move next line; 301 fBits = rhs.fBits;; 302 fBits |= kIsOnHeap;; 303 } else {; 304 fBits = rhs.fBits;; 305 fBits &= ~kIsOnHeap;; 306 }; 307 fBits &= ~kIsReferenced;; 308 fBits &= ~kCanDelete;; 309 }; 310 return *this;; 311}; 312 ; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// @brief Check and record whether this class has a consistent; 316/// Hash/RecursiveRemove setup (*) and then return the regular Hash value for; 317/// this object. The intent is for this routine to be called instead of directly; 318/// calling the function Hash during ""insert"" operations. See TObject::HasInconsistenTObjectHash();; 319///; 320/// (*) The setup is consistent when all classes in the class hierarchy that overload; 321/// TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 322/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 323 ; 324inline ULong_t TObject::CheckedHash(); 325{; 326 // Testing and recording whether we already called HasInconstistentTObjectHash; 327 // for this object could save some cpu cycles in some circuntances (at the cost; 328 // of reserving yet another bit).; 329 // For each insert (CheckedHash is called only for insert in THashList/THashTable), it; 330 // cost one memory fetch, one arithmetic operation and one branching.; 331 // This save a virtual function call which itself contains a static variable memory; 332 // fetch, a branching (of whether the static was already set or not).; 333 // Given that a virtual function call is essentially 2 memory fetches (virtual table; 334 // location and then content), one arithmetic operation and one function call/jump),; 335 // we guess-estimate that the version recording-then-testing-prior-check would start; 336 // saving cpu cycle when each object is inserted in average 1.5 times in a THashList/THash",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8h_source.html:13454,safe,safe,13454,doc/master/TObject_8h_source.html,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html,1,['safe'],['safe']
Safety,"ID::GetPIDs();; 1977 TIter next(pidslist);; 1978 TProcessID *p;; 1979 bool found = false;; 1980 ; 1981 {; 1982 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 1983 while ((p = (TProcessID*)next())) {; 1984 if (!strcmp(p->GetTitle(),pid->GetTitle())) {; 1985 found = true;; 1986 break;; 1987 }; 1988 }; 1989 }; 1990 ; 1991 if (found) {; 1992 delete pid;; 1993 pids->AddAtAndExpand(p,pidf);; 1994 p->IncrementCount();; 1995 return p;; 1996 }; 1997 ; 1998 pids->AddAtAndExpand(pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:71807,recover,recovered,71807,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['recover'],['recovered']
Safety,"IN or EWOULDBLOCK in both cases,; 6384 * if the timeout is reached and if the socket was set to non-; 6385 * blocking in close_socket_gracefully, so we can not distinguish; 6386 * here. We have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN(err)) {; 6389 /* TODO (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6428 ; 6429 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6430 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6431 if (n == -2) {; 6432 if (nread == 0) {; 6433 nread = -1; /* Propagate the error */; 6434 }; 6435 break;; 6436 } else if (n == -1) {; 6437 /* timeout */; 6438 if (timeout >= 0.0) {; 6439 now = mg_get_current_time_ns();; 6440 if ((now - start_time) <= timeout_ns) {; 6441 continue;; 6442 }; 6443 }; 6444 break;; 6445 } else if (n == 0) {; 6446 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:186891,timeout,timeout,186891,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"IN or EWOULDBLOCK in both cases,; 6385 * if the timeout is reached and if the socket was set to non-; 6386 * blocking in close_socket_gracefully, so we can not distinguish; 6387 * here. We have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN(err)) {; 6390 /* TODO (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6429 ; 6430 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6431 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6432 if (n == -2) {; 6433 if (nread == 0) {; 6434 nread = -1; /* Propagate the error */; 6435 }; 6436 break;; 6437 } else if (n == -1) {; 6438 /* timeout */; 6439 if (timeout >= 0.0) {; 6440 now = mg_get_current_time_ns();; 6441 if ((now - start_time) <= timeout_ns) {; 6442 continue;; 6443 }; 6444 }; 6445 break;; 6446 } else if (n == 0) {; 6447 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:186923,timeout,timeout,186923,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"INOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double* fractions, double& Ti, int& k0, double& Aki) const; Function used internally to obtain the template prediction in the individual bins. Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> describing the data <n>. Since <m> is unknown, the data distribution is; used instead,; lambda = L(y;n) / L(n;n).; Note that this ratio is 1 if the fit is perfect. The chi2 value is then; computed according to; chi2 = -2*ln(lambda).; This parameter can be shown to follow a Chi-square distribution. See for; example S. Baker and R. Cousins, ""Clarification of the use of chi-square; and likelihood functions in fits to histograms"", Nucl. Instr. Meth. A221, ; pp. 437-442 (1984). Int_t GetNDF() const; return the num",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFractionFitter.html:16975,predict,prediction,16975,root/html528/TFractionFitter.html,https://root.cern,https://root.cern/root/html528/TFractionFitter.html,3,['predict'],['prediction']
Safety,"IS_NOW)). Definition at line 475 of file RConfig.hxx. â—†Â R__ALWAYS_INLINE. #define R__ALWAYS_INLINEÂ Â Â inline. Definition at line 552 of file RConfig.hxx. â—†Â R__ALWAYS_SUGGEST_ALTERNATIVE. #define R__ALWAYS_SUGGEST_ALTERNATIVE; (; Â ; ALTERNATIVE); Â Â Â  _R__DEPRECATED_LATER(""There is a superior alternative: "" ALTERNATIVE). Definition at line 515 of file RConfig.hxx. â—†Â R__ANSISTREAM. #define R__ANSISTREAMÂ Â Â /* ANSI C++ Standard Library conformant */. Definition at line 37 of file RConfig.hxx. â—†Â R__DEPRECATED. #define R__DEPRECATED; (; Â ; MAJOR, . Â ; MINOR, . Â ; REASONÂ . ); Â Â Â  _R__JOIN3_(_R__DEPRECATED_,MAJOR,MINOR)(""will be removed in ROOT v"" #MAJOR ""."" #MINOR "": "" REASON). Definition at line 504 of file RConfig.hxx. â—†Â R__HIDDEN. #define R__HIDDEN. Definition at line 349 of file RConfig.hxx. â—†Â R__INTENTIONALLY_UNINIT_BEGIN. #define R__INTENTIONALLY_UNINIT_BEGIN. Definition at line 541 of file RConfig.hxx. â—†Â R__INTENTIONALLY_UNINIT_END. #define R__INTENTIONALLY_UNINIT_END. Definition at line 542 of file RConfig.hxx. â—†Â R__likely. #define R__likely; (; Â ; expr); Â Â Â expr. Definition at line 587 of file RConfig.hxx. â—†Â R__NEVER_INLINE. #define R__NEVER_INLINEÂ Â Â inline. Definition at line 564 of file RConfig.hxx. â—†Â R__SIZEDDELETE. #define R__SIZEDDELETE. Definition at line 341 of file RConfig.hxx. â—†Â R__SSTREAM. #define R__SSTREAMÂ Â Â /* use sstream or strstream header */. Definition at line 38 of file RConfig.hxx. â—†Â R__SUGGEST_ALTERNATIVE. #define R__SUGGEST_ALTERNATIVE; (; Â ; ALTERNATIVE). Definition at line 512 of file RConfig.hxx. â—†Â R__unlikely. #define R__unlikely; (; Â ; expr); Â Â Â expr. Definition at line 586 of file RConfig.hxx. â—†Â R__USE_SHADOW_CLASS. #define R__USE_SHADOW_CLASS. Definition at line 34 of file RConfig.hxx. â—†Â SafeDelete. #define SafeDelete; (; Â ; p); Â Â Â { delete p; p = nullptr; }. Definition at line 525 of file RConfig.hxx. corefoundationincROOTRConfig.hxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:14 (GVA Time) using Doxygen 1.9.8 Â Â ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RConfig_8hxx.html:5479,Safe,SafeDelete,5479,doc/master/RConfig_8hxx.html,https://root.cern,https://root.cern/doc/master/RConfig_8hxx.html,2,['Safe'],['SafeDelete']
Safety,"IT,; Matevz Tadel, UCSD/CMS, Eve,; Vassil Vassilev, CERN/SFT; Wouter Verkerke, NIKHEF/Atlas, RooFit,; Omar, Zapata, Medellin, Columbia; Maciej Zimnoch, GSoC, Poland; ROOT reference manual; The ROOT reference manual has been moved into Doxygen. Still some work and polish has to be done but the reference guide in this new format is now online and can be seen from the ROOT home page.; Core Libraries; Dictionary generation; Fixed the dictionary generation in the case of class inside a namespace marked inlined.; Added mechanisms to stop the dictionary generation while parsing the XML and while selecting in presence of duplicates.; Fix ROOT-7760 : fully allow the usage of the dylib extension on OSx.; Fix ROOT-7723 : allow IOCtors to have as argument a ref to a type called void.; We added a dictionary for map as part of the default STL dictionary.; We added support for template parameter packs in class name involved in the I/O.; Thread safety and thread awareness; We added the function TMethodCall::GetCallFunc to allow direct access to the function wrapper.; We reduced thread serialization in TClass::GetCheckSum, TClass::GetBaseClassOffset and TClass::Property; TObjArray::Delete was updated to allow its caller to explicitly avoid costly checks (extra RecursiveRemove and lock); We removed the need to create a TThread object per thread in a multi-threaded application. Now ROOT can be used with any threading model (e.g.Â OpenMP, STL threads, TBB) transparently. All the internal synchronisation mechanisms of ROOT are activated by a single call: ROOT::EnableThreadSafety() which is the successor of the existing TThread::Initialize. This call must take place if ROOT needs to be used in a thread safe manner.; The implementation of TSemaphore was redone based on C++11 thread primitive in order to prevent cases where some of request post were lost.; TDirectory::TContext; We added a default constructor to TDirectory::TContext which record the current directory and will restore it at d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:3302,safe,safety,3302,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['safe'],['safety']
Safety,"If no boundary is found,; 2732/// propagate current point along current direction with fStep=STEPMAX. Otherwise; 2733/// propagate with fStep=SNEXT (distance to boundary) and locate/return the next; 2734/// node.; 2735 ; 2736TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax, Bool_t compsafe); 2737{; 2738 return GetCurrentNavigator()->FindNextBoundaryAndStep(stepmax, compsafe);; 2739}; 2740 ; 2741////////////////////////////////////////////////////////////////////////////////; 2742/// Find distance to next boundary and store it in fStep. Returns node to which this; 2743/// boundary belongs. If PATH is specified, compute only distance to the node to which; 2744/// PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; 2745/// than this value. STEPMAX represent the step to be made imposed by other reasons than; 2746/// geometry (usually physics processes). Therefore in this case this method provides the; 2747/// answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; 2748/// fStep with a big number.; 2749/// In case frombdr=kTRUE, the isotropic safety is set to zero.; 2750///; 2751/// Note : safety distance for the current point is computed ONLY in case STEPMAX is; 2752/// specified, otherwise users have to call explicitly TGeoManager::Safety() if; 2753/// they want this computed for the current point.; 2754 ; 2755TGeoNode *TGeoManager::FindNextBoundary(Double_t stepmax, const char *path, Bool_t frombdr); 2756{; 2757 // convert current point and direction to local reference; 2758 return GetCurrentNavigator()->FindNextBoundary(stepmax, path, frombdr);; 2759}; 2760 ; 2761////////////////////////////////////////////////////////////////////////////////; 2762/// Computes as fStep the distance to next daughter of the current volume.; 2763/// The point and direction must be converted in the coordinate system of the current volume.; 2764/// The proposed step limit is fStep.; 2765 ; 2766TGeoNode *TGeoM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:98177,safe,safe,98177,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['safe'],['safe']
Safety,"Imp->ShowToolTips(kTRUE);; 671 }; 672}; 673 ; 674////////////////////////////////////////////////////////////////////////////////; 675/// Canvas destructor; 676 ; 677TCanvas::~TCanvas(); 678{; 679 Destructor();; 680}; 681 ; 682////////////////////////////////////////////////////////////////////////////////; 683/// Browse.; 684 ; 685void TCanvas::Browse(TBrowser *b); 686{; 687 Draw();; 688 cd();; 689 if (fgIsFolder) fPrimitives->Browse(b);; 690}; 691 ; 692////////////////////////////////////////////////////////////////////////////////; 693/// Actual canvas destructor.; 694 ; 695void TCanvas::Destructor(); 696{; 697 if (gThreadXAR) {; 698 void *arr[2];; 699 arr[1] = this;; 700 if ((*gThreadXAR)(""CDEL"", 2, arr, nullptr)) return;; 701 }; 702 ; 703 if (ROOT::Detail::HasBeenDeleted(this)) return;; 704 ; 705 SafeDelete(fContextMenu);; 706 if (!gPad) return;; 707 ; 708 Close();; 709 ; 710 //If not yet (batch mode?).; 711 SafeDelete(fPainter);; 712}; 713 ; 714////////////////////////////////////////////////////////////////////////////////; 715/// Set current canvas & pad. Returns the new current pad,; 716/// or 0 in case of failure.; 717/// See TPad::cd() for an explanation of the parameter.; 718 ; 719TVirtualPad *TCanvas::cd(Int_t subpadnumber); 720{; 721 if (fCanvasID == -1) return nullptr;; 722 ; 723 TPad::cd(subpadnumber);; 724 ; 725 // in case doublebuffer is off, draw directly onto display window; 726 if (!IsBatch() && !IsWeb() && !fDoubleBuffer); 727 gVirtualX->SelectWindow(fCanvasID);//Ok, does not matter for glpad.; 728 ; 729 return gPad;; 730}; 731 ; 732////////////////////////////////////////////////////////////////////////////////; 733/// Remove all primitives from the canvas.; 734/// If option ""D"" is specified, direct sub-pads are cleared but not deleted.; 735/// This option is not recursive, i.e. pads in direct sub-pads are deleted.; 736 ; 737void TCanvas::Clear(Option_t *option); 738{; 739 if (fCanvasID == -1) return;; 740 ; 741 R__LOCKGUARD(gROOTMutex);; 742 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:23143,Safe,SafeDelete,23143,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,"Implements TBuffer.; Definition at line 3376 of file TBufferJSON.cxx. â—†Â WriteFastArray() [11/15]. void TBufferJSON::WriteFastArray ; (; const ULong64_t *Â ; l, . Long64_tÂ ; nÂ . ). finalvirtual . Write array of ULong64_t to buffer. ; Implements TBuffer.; Definition at line 3408 of file TBufferJSON.cxx. â—†Â WriteFastArray() [12/15]. void TBufferJSON::WriteFastArray ; (; const ULong_t *Â ; l, . Long64_tÂ ; nÂ . ). finalvirtual . Write array of ULong_t to buffer. ; Implements TBuffer.; Definition at line 3392 of file TBufferJSON.cxx. â—†Â WriteFastArray() [13/15]. void TBufferJSON::WriteFastArray ; (; const UShort_t *Â ; h, . Long64_tÂ ; nÂ . ). finalvirtual . Write array of UShort_t to buffer. ; Implements TBuffer.; Definition at line 3360 of file TBufferJSON.cxx. â—†Â WriteFastArray() [14/15]. Int_t TBufferJSON::WriteFastArray ; (; void **Â ; startp, . const TClass *Â ; cl, . Long64_tÂ ; n = 1, . Bool_tÂ ; isPreAlloc = kFALSE, . TMemberStreamer *Â ; s = nullptrÂ . ). finalvirtual . Recall TBuffer function to avoid gcc warning message. ; Implements TBuffer.; Definition at line 3485 of file TBufferJSON.cxx. â—†Â WriteFastArray() [15/15]. void TBufferJSON::WriteFastArray ; (; void *Â ; start, . const TClass *Â ; cl, . Long64_tÂ ; n = 1, . TMemberStreamer *Â ; s = nullptrÂ . ). finalvirtual . Recall TBuffer function to avoid gcc warning message. ; Implements TBuffer.; Definition at line 3432 of file TBufferJSON.cxx. â—†Â WriteFastArrayString(). void TBufferJSON::WriteFastArrayString ; (; const Char_t *Â ; c, . Long64_tÂ ; nÂ . ). finalvirtual . Write array of Char_t to buffer. ; Implements TBuffer.; Definition at line 3336 of file TBufferJSON.cxx. â—†Â WriteFloat(). void TBufferJSON::WriteFloat ; (; Float_tÂ ; f). finalvirtual . Writes Float_t value to buffer. ; Implements TBuffer.; Definition at line 3828 of file TBufferJSON.cxx. â—†Â WriteInt(). void TBufferJSON::WriteInt ; (; Int_tÂ ; i). finalvirtual . Writes Int_t value to buffer. ; Implements TBuffer.; Definition at line 3774 of file TBufferJSON.cxx. â—†Â Write",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:96474,avoid,avoid,96474,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,1,['avoid'],['avoid']
Safety,"In case the file does not exist or is not a valid ROOT file,; 297/// it is made a Zombie. One can detect this situation with a code like:; 298/// ~~~{.cpp}; 299/// TFile f(""file.root"");; 300/// if (f.IsZombie()) {; 301/// std::cout << ""Error opening file"" << std::endl;; 302/// exit(-1);; 303/// }; 304/// ~~~; 305/// If you open a file instead with TFile::Open(""file.root"") use rather; 306/// the following code as a nullptr is returned.; 307/// ~~~{.cpp}; 308/// TFile* f = TFile::Open(""file.root"");; 309/// if (!f) {; 310/// std::cout << ""Error opening file"" << std::endl;; 311/// exit(-1);; 312/// }; 313/// ~~~; 314/// When opening the file, the system checks the validity of this directory.; 315/// If something wrong is detected, an automatic Recovery is performed. In; 316/// this case, the file is scanned sequentially reading all logical blocks; 317/// and attempting to rebuild a correct directory (see TFile::Recover).; 318/// One can disable the automatic recovery procedure when reading one; 319/// or more files by setting the environment variable ""TFile.Recover: 0""; 320/// in the system.rootrc file.; 321///; 322/// A bit `TFile::kReproducible` can be enabled specifying; 323/// the `""reproducible""` url option when creating the file:; 324/// ~~~{.cpp}; 325/// TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; 326/// ~~~; 327/// Unlike regular `TFile`s, the content of such file has reproducible binary; 328/// content when writing exactly same data. This achieved by writing pre-defined; 329/// values for creation and modification date of TKey/TDirectory objects and; 330/// null value for TUUID objects inside TFile. As drawback, TRef objects stored; 331/// in such file cannot be read correctly.; 332///; 333/// In case the name of the file is not reproducible either (in case of; 334/// creating temporary filenames) a value can be passed to the reproducible; 335/// option to replace the name stored in the file.; 336/// ~~~{.cpp}; 337/// TFile *f = T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:13339,recover,recovery,13339,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['recover'],['recovery']
Safety,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). Â» Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ Â» Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:11297,avoid,avoid,11297,root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,15,['avoid'],['avoid']
Safety,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). Â» Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ Â» Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:11363,avoid,avoid,11363,root/html528/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,13,['avoid'],['avoid']
Safety,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). Â» Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ Â» Last generated: 2010-09-23 19:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:10989,avoid,avoid,10989,root/html528/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,2,['avoid'],['avoid']
Safety,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). Â» Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ Â» Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:11365,avoid,avoid,11365,root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,15,['avoid'],['avoid']
Safety,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). Â» Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ Â» Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:11365,avoid,avoid,11365,root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,15,['avoid'],['avoid']
Safety,"In this case **RDataFrame infers the type of the column** from the TTree itself. This; 1196is why we never needed to specify the column types for all actions in the above snippets.; 1197 ; 1198When the column type is not a common one such as `int`, `double`, `char` or `float` it is nonetheless good practice to; 1199specify it as a template parameter to the action itself, like this:; 1200~~~{.cpp}; 1201df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; 1202df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; 1203~~~; 1204 ; 1205Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime; 1206overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal.; 1207 ; 1208When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing `x = 0` rather than `x == 0`:; 1209 ; 1210~~~{.cpp}; 1211// this throws an error (note the typo); 1212df.Define(""x"", ""0"").Filter(""x = 0"");; 1213~~~; 1214 ; 1215\anchor generic-actions; 1216### User-defined custom actions; 1217RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same; 1218time, it allows users to inject their own action code to perform arbitrarily complex data reductions.; 1219 ; 1220#### Implementing custom actions with Book(); 1221 ; 1222Through the Book() method, users can implement a custom action and have access to the same features; 1223that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the; 1224event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:; 1225 ; 1226~~~{.cpp}; 1227#include <ROOT/RDataFrame.hxx>; 1228#include <memory>; 1229 ; 1230class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; 1231 std",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:71207,avoid,avoids,71207,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['avoid'],['avoids']
Safety,"In this case **RDataFrame infers the type of the column** from the TTree itself. This; 1236is why we never needed to specify the column types for all actions in the above snippets.; 1237 ; 1238When the column type is not a common one such as `int`, `double`, `char` or `float` it is nonetheless good practice to; 1239specify it as a template parameter to the action itself, like this:; 1240~~~{.cpp}; 1241df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; 1242df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; 1243~~~; 1244 ; 1245Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime; 1246overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal.; 1247 ; 1248When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing `x = 0` rather than `x == 0`:; 1249 ; 1250~~~{.cpp}; 1251// this throws an error (note the typo); 1252df.Define(""x"", ""0"").Filter(""x = 0"");; 1253~~~; 1254 ; 1255\anchor generic-actions; 1256### User-defined custom actions; 1257RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same; 1258time, it allows users to inject their own action code to perform arbitrarily complex data reductions.; 1259 ; 1260#### Implementing custom actions with Book(); 1261 ; 1262Through the Book() method, users can implement a custom action and have access to the same features; 1263that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the; 1264event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:; 1265 ; 1266~~~{.cpp}; 1267#include <ROOT/RDataFrame.hxx>; 1268#include <memory>; 1269 ; 1270class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; 1271 std",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:72887,avoid,avoids,72887,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['avoid'],['avoids']
Safety,"Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. Â» Author: Andrei Gheata 30/05/02 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ Â» Last generated: 2010-12-10 11:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoUnion.html:8660,safe,safe,8660,root/html528/TGeoUnion.html,https://root.cern,https://root.cern/root/html528/TGeoUnion.html,1,['safe'],['safe']
Safety,"Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. Â» Author: Andrei Gheata 30/05/02 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ Â» Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoUnion.html:8760,safe,safe,8760,root/html530/TGeoUnion.html,https://root.cern,https://root.cern/root/html530/TGeoUnion.html,1,['safe'],['safe']
Safety,"Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. Â» Author: Andrei Gheata 30/05/02 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: :$Id: TGeoBoolNode.h 41234 2011-10-06 15:48:52Z agheata $ Â» Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoUnion.html:8964,safe,safe,8964,root/html532/TGeoUnion.html,https://root.cern,https://root.cern/root/html532/TGeoUnion.html,1,['safe'],['safe']
Safety,"Inherited Members; Includes; Libraries. Function documentation; TGeoEltu(); Dummy constructor. TGeoEltu(Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(const char* name, Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = A; param[1] = B; param[2] = dz. ~TGeoEltu(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoEltu.html:13021,safe,safe,13021,root/html528/TGeoEltu.html,https://root.cern,https://root.cern/root/html528/TGeoEltu.html,3,['safe'],['safe']
Safety,"Inherited Members; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â . #include <TSystem.h>. Inheritance diagram for TSystem:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. â—†Â EAclicMode. enum TSystem::EAclicMode. EnumeratorkDefaultÂ ; kDebugÂ ; kOptÂ . Definition at line 269 of file TSystem.h. â—†Â EAclicProperties. enum TSystem::EAclicProperties. EnumeratorkFlatBuildDirÂ . Definition at line 270 of file TSystem.h. Constructor & Destructor Documentation. â—†Â TSystem() [1/2]. TSystem::TSystem ; (; const TSystem &Â ; ). privatedelete . â—†Â TSystem() [2/2]. TSystem::TSystem ; (; const char *Â ; name = ""Generic"", . const char *Â ; title = ""GenericÂ System""Â . ). Create a new OS interface. ; Definition at line 125 of file TSystem.cxx. â—†Â ~TSystem(). TSystem::~TSystem ; (; ). virtual . Delete the OS interface. ; Definition at line 139 of file TSystem.cxx. Member Function Documentation. â—†Â Abort(). void TSystem::Abort ; (; intÂ ; code = 0). virtual . Abort the application. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 725 of file TSystem.cxx. â—†Â AcceptConnection(). int TSystem::AcceptConnection ; (; intÂ ; sock). virtual . Accept a connection. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 2381 of file TSystem.cxx. â—†Â AccessPathName(). Bool_t TSystem::AccessPathName ; (; const char *Â ; path, . EAccessModeÂ ; mode = kFileExistsÂ . ). virtual . Returns FALSE if one can access a file using the specified access mode. ; The file name must not contain any special shell characters line ~ or $, in those cases first call ExpandPathName(). Attention, bizarre convention of return value!! ; Reimplemented in TDCacheSystem, TNetSystem, TWebSystem, TUnixSystem, and TWinNTSystem.; Definition at line 1296 of file TSystem.cxx. â—†Â AddDynamicPath(). void TSystem::AddDynamicPath ; (; const char *Â ; pathname). virtual . Add a new directory to the dynamic p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:34300,Abort,Abort,34300,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['Abort'],['Abort']
Safety,"Int_t DistancetoPrimitive(Int_t px, Int_t py) overrideComputes distance from point (px,py) to the object.; TGeoTubeSeg::InitTrigonometryvoid InitTrigonometry(); TGeoTubeSeg::DivideTGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; TGeoTubeSeg::GetByteCountInt_t GetByteCount() const overrideDefinition TGeoTube.h:149; TGeoTubeSeg::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoTubeSeg::SetTubsDimensionsvoid SetTubsDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); TGeoTubeSeg::GetPhi2Double_t GetPhi2() constDefinition TGeoTube.h:155; TGeoTubeSeg::fC1Double_t fC1Definition TGeoTube.h:101; TGeoTubeSeg::GetNmeshVerticesInt_t GetNmeshVertices() const override; TGeoTubeSeg::fS1Double_t fS1Definition TGeoTube.h:100; TGeoTubeSeg::fS2Double_t fS2Definition TGeoTube.h:102; TGeoTubeSeg::GetBuffer3Dconst TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const overrideStub implementation to avoid forcing implementation at this stage.; TGeoTubeSeg::GetAxisRangeDouble_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override; TGeoTubeSeg::GetMeshNumbersvoid GetMeshNumbers(Int_t &nvert, Int_t &nsegs, Int_t &npols) const override; TGeoTubeSeg::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".; TGeoTubeSeg::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoTubeSeg::SafetySstatic Double_t SafetyS(const Double_t *point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz=0); TGeoTubeSeg::TGeoTubeSegTGeoTubeSeg(Double_t *params); TGeoTubeSeg::fSmDouble_t fSmDefinition TGeoTube.h:104; TGeoTubeSeg::Contains_vvoid Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoTube_8h_source.html:22039,avoid,avoid,22039,doc/master/TGeoTube_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html,1,['avoid'],['avoid']
Safety,"Int_t Write(const char *name=nullptr, Int_t opt=0, Int_t bufsiz=0) overrideWrite memory objects to this file.Definition TFile.cxx:2436; TFile::fAsyncOpenStatusEAsyncOpenStatus fAsyncOpenStatus!Status of an asynchronous open requestDefinition TFile.h:109; TFile::fGlobalRegistrationbool fGlobalRegistration! if true, bypass use of global listsDefinition TFile.h:115; TFile::fSumBufferDouble_t fSumBufferSum of buffer sizes of objects written so far.Definition TFile.h:73; TFile::fIsArchiveBool_t fIsArchive!True if this is a pure archive fileDefinition TFile.h:102; TFile::GetListOfProcessIDsTObjArray * GetListOfProcessIDs() constDefinition TFile.h:236; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TFile::GetCompressionAlgorithmInt_t GetCompressionAlgorithm() constDefinition TFile.h:385; TFile::fgReadCallsstatic std::atomic< Int_t > fgReadCallsNumber of bytes read from all TFile objects.Definition TFile.h:133; TFile::Recovervirtual Int_t Recover()Attempt to recover file if not correctly closed.Definition TFile.cxx:2048; TFile::GetStreamerInfoListvirtual TList * GetStreamerInfoList() finalRead the list of TStreamerInfo objects written to this file.Definition TFile.cxx:1445; TFile::WriteHeadervirtual void WriteHeader()Write File Header.Definition TFile.cxx:2615; TFile::EStatusBitsEStatusBitsTFile status bits. BIT(13) is taken up by TObject.Definition TFile.h:183; TFile::kRecovered@ kRecoveredDefinition TFile.h:191; TFile::kReproducible@ kReproducibleDefinition TFile.h:197; TFile::kDevNull@ kDevNullDefinition TFile.h:193; TFile::kHasReferences@ kHasReferencesDefinition TFile.h:192; TFile::kRedirected@ kRedirectedDefinition TFile.h:196; TFile::k630forwardCompatibility@ k630forwardCompatibilityDefinition TFile.h:190; TFile::kWriteError@ kWriteErrorDefinition TFile.h:194; TFile::kBinaryFile@ kBinaryFileDefinition TFile.h:195; TFile::OpenFromCachestatic TFile * OpenFromCache(const char *name, Option_t *="""", const char *ftitle="""", Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:47294,Recover,Recovervirtual,47294,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,3,"['Recover', 'recover']","['Recover', 'Recovervirtual', 'recover']"
Safety,"Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidTHttpEngine::Process(); voidTHttpEngine::SetServer(THttpServer* serv). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. void*fCallbacks! call-back table for civetweb webserver; void*fCtx! civetweb context; Bool_tfDebug! debug mode; TStringTNamed::fNameobject identifier; THttpServer*THttpEngine::fServer! object server; TStringTNamed::fTitleobject title; TStringfTopName! name of top item. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCivetweb(); constructor. ~TCivetweb(); destructor. Int_t ProcessLog(const char* message); process civetweb log message, can be used to detect critical errors. Bool_t Create(const char* args); Creates embedded civetweb server; As main argument, http port should be specified like ""8090"".; Or one can provide combination of ipaddress and portnumber like 127.0.0.1:8090; Extra parameters like in URL string could be specified after '?' mark:; thrds=N - there N is number of threads used by the civetweb (default is 5); top=name - configure top name, visible in the web browser; auth_file=filename - authentication file name, created with htdigets utility; auth_domain=domain - authentication domain; loopback - bind specified port to loopback 127.0.0.1 address; debug - enable debug mode, server always returns html page with request info. TCivetweb(). const char * GetTopName() const. Bool_t IsDebugMode() const; indicates that. Â» Last changed: Mon Jun 29 16:38:47 2015 Â» Last generated: 2015-06-29 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCivetweb.html:6965,detect,detect,6965,root/html534/TCivetweb.html,https://root.cern,https://root.cern/root/html534/TCivetweb.html,1,['detect'],['detect']
Safety,"Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayWithFactor(Float_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Float16_t from buffer. void ReadFastArrayWithNbits(Float_t* ptr, Int_t n, Int_t nbits); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArrayWithFactor(Double_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Double32_t from buffer. void ReadFastArrayWithNbits(Double_t* ptr, Int_t n, Int_t nbits); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteArray(const Float_t* f, Int_t n); Wri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferJSON.html:32808,avoid,avoid,32808,root/html534/TBufferJSON.html,https://root.cern,https://root.cern/root/html534/TBufferJSON.html,6,['avoid'],['avoid']
Safety,"Int_t n); read array of UInt_t from buffer. void ReadFastArray(Long_t *l, Int_t n); read array of Long_t from buffer. void ReadFastArray(ULong_t *l, Int_t n); read array of ULong_t from buffer. void ReadFastArray(Long64_t *l, Int_t n); read array of Long64_t from buffer. void ReadFastArray(ULong64_t *l, Int_t n); read array of ULong64_t from buffer. void ReadFastArray(Float_t *f, Int_t n); read array of Float_t from buffer. void ReadFastArray(Double_t *d, Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t *b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t *c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t *c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t *h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t *h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t *i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t *i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t *l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t *l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Long64_t *l, Int_t n); Write array of Long64_t to buffer. void WriteArray(const ULong64_t *l, Int_t n); Write array of ULong64_t to buffer. void WriteArray(const Float_t *f, Int_t n); Wri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferXML.html:35537,avoid,avoid,35537,root/html526/TBufferXML.html,https://root.cern,https://root.cern/root/html526/TBufferXML.html,1,['avoid'],['avoid']
Safety,"Int_t n); read array of UInt_t from buffer. void ReadFastArray(Long_t* l, Int_t n); read array of Long_t from buffer. void ReadFastArray(ULong_t* l, Int_t n); read array of ULong_t from buffer. void ReadFastArray(Long64_t* l, Int_t n); read array of Long64_t from buffer. void ReadFastArray(ULong64_t* l, Int_t n); read array of ULong64_t from buffer. void ReadFastArray(Float_t* f, Int_t n); read array of Float_t from buffer. void ReadFastArray(Double_t* d, Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteArray(const Float_t* f, Int_t n); Wri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferXML.html:37468,avoid,avoid,37468,root/html528/TBufferXML.html,https://root.cern,https://root.cern/root/html528/TBufferXML.html,3,['avoid'],['avoid']
Safety,"Int_t nbytes, TDirectory* motherDir); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If object with same name already exist in memory delete it (like; TDirectoryFile::Get() is doing), except when the key references a; folder in which case we don't want to re-read the folder object; since it might contain new objects not yet saved. void Create(Int_t nbytes, TFile* f = 0); Create a TKey object of specified size; if externFile!=0, key will be allocated in specified file,; otherwise file of mother directory will be used. ~TKey(); TKey default destructor. void Delete(Option_t* option = """"); Delete an object from the file.; Note: the key is not deleted. You s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TKey.html:11057,avoid,avoid,11057,root/html602/TKey.html,https://root.cern,https://root.cern/root/html602/TKey.html,2,['avoid'],['avoid']
Safety,"Int_t opt, const char* rfile = 0, TProof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TProof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TList* workers); Int_tBroadcastObject(const TObject* obj, Int_t kind, TList* slaves); Int_tBroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT, TProof::ESlaves list = kActive); Int_tBroadcastRaw(const void* buffer, Int_t length, TList* slaves); Int_tBroadcastRaw(const void* buffer, Int_t length, TProof::ESlaves list = kActive); Int_tBuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = 2, TList* workers = 0); Int_tBuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0, Int_t chkveropt = 2); Bool_tCheckFile(const char* file, TSlave* sl, Long_t modtime, Int_t cpopt = (kCp|kCpBin)); voidCleanGDirectory(TList* ol); voidClearDataProgress(Int_t r, Int_t t); Int_tCollect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Bool_tCreateMerger(TSlave* sl, Int_t port); voidDeActivateAsyncInput(); Int_tDisablePackage(const char* package); Int_tDisablePackageOnClient(const char* package); Int_tDisablePackages(); Int_tExec(const char* cmd, TProof::ESlaves list, Bool_t plusMaster); voidFinalizationDone(); Int_tFindNextFreeMerger(); TSlave*FindSlave(TSocket* s) const; virtual voidFindUniqueSlaves(); Int_tGetActiveMergersCount(); static TList*GetDataSetSrvMaps(const TString& srvmaps); TList*GetListOfBadSlaves() const; TList*GetListOfInactiveSlaves() const; TList*GetListOfSlaves() const; TList*GetListOfUniqueSlaves() const; Int_tGetNumberOfActiveSlaves() const; Int_tGetNumberOfBadSlaves() const; Int_tGetNumberOfInactiveSlaves() const; Int_tGetNumberOfSlaves() const; Int_tGetN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:23192,timeout,timeout,23192,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['timeout'],['timeout']
Safety,"Int_t opt, const char* rfile = 0, TProof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TProof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TList* workers); Int_tBroadcastObject(const TObject* obj, Int_t kind, TList* slaves); Int_tBroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT, TProof::ESlaves list = kActive); Int_tBroadcastRaw(const void* buffer, Int_t length, TList* slaves); Int_tBroadcastRaw(const void* buffer, Int_t length, TProof::ESlaves list = kActive); Int_tBuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = kCheckROOT); Int_tBuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0, Int_t chkveropt = kCheckROOT); Bool_tCheckFile(const char* file, TSlave* sl, Long_t modtime, Int_t cpopt = (kCp | kCpBin)); voidCleanGDirectory(TList* ol); voidClearDataProgress(Int_t r, Int_t t); Int_tCollect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Bool_tCreateMerger(TSlave* sl, Int_t port); voidDeActivateAsyncInput(); Int_tDisablePackage(const char* package); Int_tDisablePackageOnClient(const char* package); Int_tDisablePackages(); Int_tExec(const char* cmd, TProof::ESlaves list, Bool_t plusMaster); voidFinalizationDone(); Int_tFindNextFreeMerger(); TSlave*FindSlave(TSocket* s) const; virtual voidFindUniqueSlaves(); Int_tGetActiveMergersCount(); static TList*GetDataSetSrvMaps(const TString& srvmaps); TList*GetListOfBadSlaves() const; TList*GetListOfInactiveSlaves() const; TList*GetListOfSlaves() const; TList*GetListOfUniqueSlaves() const; Int_tGetNumberOfActiveSlaves() const; Int_tGetNumberOfBadSlaves() const; Int_tGetNumberOfInactiveSlaves() const; Int_tGetNumberOfSlaves() const; Int_tGetN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:23065,timeout,timeout,23065,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,1,['timeout'],['timeout']
Safety,"Inverse ; (; const Point &Â ; p); const. inline . Directly apply the inverse affine transformation on points (first inverse translation then inverse rotation). ; Avoids having to calculate the inverse as an intermediate result. This is possible since the inverse of a rotation is its transpose. ; Definition at line 688 of file Transform3D.h. â—†Â ApplyInverse() [3/4]. template<typename T = double> . template<class CoordSystem > . PositionVector3D< CoordSystem > ROOT::Math::Impl::Transform3D< T >::ApplyInverse ; (; const PositionVector3D< CoordSystem > &Â ; p); const. inline . Directly apply the inverse affine transformation on an arbitrary coordinate-system point. ; Involves casting to Point(p) type. ; Definition at line 702 of file Transform3D.h. â—†Â ApplyInverse() [4/4]. template<typename T = double> . Vector ROOT::Math::Impl::Transform3D< T >::ApplyInverse ; (; const Vector &Â ; v); const. inline . Directly apply the inverse affine transformation on vectors. ; Avoids having to calculate the inverse as an intermediate result. This is possible since the inverse of a rotation is its transpose. ; Definition at line 675 of file Transform3D.h. â—†Â AssignFrom() [1/3]. template<typename T = double> . void ROOT::Math::Impl::Transform3D< T >::AssignFrom ; (; const Rotation3D &Â ; r). inlineprotected . make transformation from only rotations (zero translation) ; Definition at line 930 of file Transform3D.h. â—†Â AssignFrom() [2/3]. template<typename T = double> . void ROOT::Math::Impl::Transform3D< T >::AssignFrom ; (; const Rotation3D &Â ; r, . const Vector &Â ; vÂ . ). inlineprotected . make transformation from first a rotation then a translation ; Definition at line 906 of file Transform3D.h. â—†Â AssignFrom() [3/3]. template<typename T = double> . void ROOT::Math::Impl::Transform3D< T >::AssignFrom ; (; const Vector &Â ; v). inlineprotected . make transformation from only translation (identity rotations) ; Definition at line 945 of file Transform3D.h. â—†Â GetComponents() [1/3]. template<typena",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Impl_1_1Transform3D.html:23247,Avoid,Avoids,23247,doc/master/classROOT_1_1Math_1_1Impl_1_1Transform3D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Impl_1_1Transform3D.html,1,['Avoid'],['Avoids']
Safety,"IsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance Chart:. TObject. â†; TNamed. â†; TVirtualMCGeometry. â†. TGeoMCGeometry. Function documentation; TVirtualMCGeometry(const char* name, const char* title). Standard constructor. TVirtualMCGeometry(). Default constructor. ~TVirtualMCGeometry(). Destructor. TVirtualMCGeometry(const char* name, const char* title); Standard constructor. void Material(Int_t& kmat, const char* name, Double_t a, Double_t z, Double_t dens, Double_t radl, Double_t absl, Float_t* buf, Int_t nwbuf). detector composition. Define a material; kmat number assigned to the material; name material name; a atomic mass in au; z atomic number; dens density in g/cm3; absl absorption length in cm;; if >=0 it is ignored and the program; calculates it, if <0. -absl is taken; radl radiation length in cm; if >=0 it is ignored and the program; calculates it, if <0. -radl is taken; buf pointer to an array of user words; nwbuf number of user words. void Mixture(Int_t& kmat, const char* name, Float_t* a, Float_t* z, Double_t dens, Int_t nlmat, Float_t* wmat); The same as previous but in double precision; Define mixture or compound; with a number kmat composed by the basic nlmat materials defined; by arrays a, z and wmat. If nlmat > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then wmat contains the number of atoms; of a given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMCGeometry.html:10056,detect,detector,10056,root/html602/TVirtualMCGeometry.html,https://root.cern,https://root.cern/root/html602/TVirtualMCGeometry.html,2,['detect'],['detector']
Safety,"IsUsingOverlaps ; (; ); const. inline . Definition at line 81 of file TGeoParallelWorld.h. â—†Â operator=(). TGeoParallelWorld & TGeoParallelWorld::operator= ; (; const TGeoParallelWorld &Â ; ). protecteddelete . â—†Â PrintBVH(). void TGeoParallelWorld::PrintBVH ; (; ); const. Prints the BVH. ; Definition at line 374 of file TGeoParallelWorld.cxx. â—†Â PrintDetectedOverlaps(). Int_t TGeoParallelWorld::PrintDetectedOverlaps ; (; ); const. Print the overlaps which were detected during real tracking. ; Definition at line 135 of file TGeoParallelWorld.cxx. â—†Â RefreshPhysicalNodes(). void TGeoParallelWorld::RefreshPhysicalNodes ; (; ). Refresh the node pointers and re-voxelize. ; To be called mandatory in case re-alignment happened. ; Definition at line 198 of file TGeoParallelWorld.cxx. â—†Â ResetOverlaps(). void TGeoParallelWorld::ResetOverlaps ; (; ); const. Reset overlapflag for all volumes in geometry. ; Definition at line 154 of file TGeoParallelWorld.cxx. â—†Â Safety(). Double_t TGeoParallelWorld::Safety ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). inline . Definition at line 118 of file TGeoParallelWorld.h. â—†Â SafetyBVH(). double TGeoParallelWorld::SafetyBVH ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). private . Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ; Definition at line 1027 of file TGeoParallelWorld.cxx. â—†Â SafetyLoop(). Double_t TGeoParallelWorld::SafetyLoop ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). private . Compute safety for the parallel world (trivial loop version for comparison/debugging) ; Definition at line 1207 of file TGeoParallelWorld.cxx. â—†Â SafetyOrig(). Double_t TGeoParallelWorld::SafetyOrig ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). private . Compute safety for the parallel world (original version based on TGeoVoxelFinder) ; Definition at line 1145 of file TGeoParallelWorld.cxx. â—†Â SetAccelerationMode(). void TGeoPara",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:25715,Safe,Safety,25715,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['Safe'],['Safety']
Safety,"It does this presently by forcing a repaint on the attached TPad object - hence you should attach you master geometry object to the pad (via TObject::Draw()), and perform the publishing to the viewer in response to TObject::Paint().; 9.13.4.9 Physical IDs; TVirtualViewer3D provides for two methods of object addition:; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID,; const TBuffer3D & buffer,; Bool_t *addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs will generate sequential IDs for each physical object internally. Scene rebuilds will require destruction and recreation of all physical objects. For the second you can specify an identifier from the client side, which must be unique and stable - i.e.Â the IDs of a published object is consistent, regardless of changes in termination of contained child geometry branches. In this case the viewer can safely cache the physical objects across scene rebuilds, discarding those no longer of interest.; 9.13.4.10 Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer is not interested in a certain object due to limits/size then it will also not be interest in any of the contained branch of siblings. Both TBuffer3D::AddObject() methods have an addChildren return parameter. The viewer will complete this (if passed) indicating if children of the object just sent are worth sending.; 9.13.4.11 Recycling TBuffer3D; Once add TBuffer3D::AddObject() has been called, the contents are copied to the viewerâ€™s internal data structures. You are free to destroy this TBuffer3D, or recycle it for the next object if suitable.; 9.13.4.12 Examples; For an example of a simple geometry, working in master reference frame examine the code under $ROOTSYS/g3d. For a more complex example, which works in both master and local frames, and uses logical/physical division of shape geometry and placement, examine th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:417139,safe,safely,417139,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safely']
Safety,"It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item will generate the event:; kC_COMMAND, kCM_MENU, menu id, user data. Function Members (Methods); public:. TGMenuBar(const TGWindow* p = 0, UInt_t w = 60, UInt_t h = 20, UInt_t options = kHorizontalFrame|kRaisedFrame); virtual~TGMenuBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAddPopup(TGHotString* s, TGPopupMenu* menu, TGLayoutHints* l, TGPopupMenu* before = 0); virtual voidAddPopup(const char* s, TGPopupMenu* menu, TGLayoutHints* l, TGPopupMenu* before = 0); virtual TGPopupMenu*AddPopup(const TString& s, Int_t padle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGMenuBar.html:1663,avoid,avoid,1663,root/html528/TGMenuBar.html,https://root.cern,https://root.cern/root/html528/TGMenuBar.html,4,['avoid'],['avoid']
Safety,"It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item will generate the event:; kC_COMMAND, kCM_MENU, menu id, user data. Function Members (Methods); public:. TGMenuTitle(const TGWindow* p = 0, TGHotString* s = 0, TGPopupMenu* menu = 0, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = 0); virtual~TGMenuTitle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGMenuTitle.html:1659,avoid,avoid,1659,root/html528/TGMenuTitle.html,https://root.cern,https://root.cern/root/html528/TGMenuTitle.html,4,['avoid'],['avoid']
Safety,"It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item will generate the event:; kC_COMMAND, kCM_MENU, menu id, user data. Function Members (Methods); public:. TGPopupMenu(const TGWindow* p = 0, UInt_t w = 10, UInt_t h = 10, UInt_t options = 0); virtual~TGPopupMenu(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(Bool_t); virtual voidActivate(TGMenuEntry* entry); virtual voidActivated(Int_t id)SIGNAL ; virtual voidAddEntry(TGHotString* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidAddEntry(const char* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAddLabel(TGHotString* s, const TGPicture* p = 0, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGPopupMenu.html:1659,avoid,avoid,1659,root/html528/TGPopupMenu.html,https://root.cern,https://root.cern/root/html528/TGPopupMenu.html,4,['avoid'],['avoid']
Safety,"It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item will generate the event:; kC_COMMAND, kCM_MENU, menu id, user data. Function Members (Methods); public:. virtual~TGMenuBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAddPopup(TGHotString* s, TGPopupMenu* menu, TGLayoutHints* l, TGPopupMenu* before = 0); virtual voidAddPopup(const char* s, TGPopupMenu* menu, TGLayoutHints* l, TGPopupMenu* before = 0); virtual TGPopupMenu*AddPopup(const TString& s, Int_t padleft = 4, Int_t padright = 0, Int_t padtop = 0, Int_t padbottom = 0); virtual voidAddTitle(TGMenuTitle* title, TGL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGMenuBar.html:1663,avoid,avoid,1663,root/html602/TGMenuBar.html,https://root.cern,https://root.cern/root/html602/TGMenuBar.html,2,['avoid'],['avoid']
Safety,"It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item will generate the event:; kC_COMMAND, kCM_MENU, menu id, user data. Function Members (Methods); public:. virtual~TGMenuEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGMenuEntry.html:1659,avoid,avoid,1659,root/html602/TGMenuEntry.html,https://root.cern,https://root.cern/root/html602/TGMenuEntry.html,2,['avoid'],['avoid']
Safety,"It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item will generate the event:; kC_COMMAND, kCM_MENU, menu id, user data. Function Members (Methods); public:. virtual~TGMenuTitle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGMenuTitle.html:1659,avoid,avoid,1659,root/html602/TGMenuTitle.html,https://root.cern,https://root.cern/root/html602/TGMenuTitle.html,2,['avoid'],['avoid']
Safety,"It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item will generate the event:; kC_COMMAND, kCM_MENU, menu id, user data. Function Members (Methods); public:. virtual~TGPopupMenu(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(Bool_t); virtual voidActivate(TGMenuEntry* entry); virtual voidActivated(Int_t id)SIGNAL ; virtual voidAddEntry(TGHotString* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidAddEntry(const char* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAddLabel(TGHotString* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidAddLabel(const char* s, const TGPicture* p = 0, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGPopupMenu.html:1659,avoid,avoid,1659,root/html602/TGPopupMenu.html,https://root.cern,https://root.cern/root/html602/TGPopupMenu.html,2,['avoid'],['avoid']
Safety,"Iterations-number of iterations in deconvolution operation; markov-logical variable, if it is true, first the source spectrum; is replaced by new spectrum calculated using Markov; chains method.; averWindow-averanging window of searched peaks, for details; we refer to manual (applies only for Markov method). . Peaks searching; Â ; Goal:; to identify automatically the peaks in spectrum with the presence of the; continuous background, one-fold coincidences (ridges) and statistical; fluctuations - noise. ; Â ; The common problems connected with correct peak; identification in two-dimensional coincidence spectra are. non-sensitivity to noise, i.e., only statistically; relevant peaks should be identified; non-sensitivity of the algorithm to continuous; background; non-sensitivity to one-fold coincidences (coincidences; peak ï¿½ background in both dimensions) and their crossings; ability to identify peaks close to the edges of the; spectrum region. Usually peak finders fail to detect them; resolution, decomposition of doublets and multiplets.; The algorithm should be able to recognize close positioned peaks. ; ability to identify peaks with different sigma. Â ; Function:; Int_t TSpectrum2::SearchHighRes (double **source,double **dest, int ssizex, int ssizey, double sigma, double threshold,; bool backgroundRemove,int deconIterations,; bool markov,; int averWindow); ï¿½ï¿½; Â ; This; function searches for peaks in source spectrum. It is based on deconvolution; method. First the background is removed (if desired), then Markov smoothed; spectrum is calculated (if desired), then the response function is generated; according to given sigma and deconvolution is carried out. The order of peaks; is arranged according to their heights in the spectrum after background; elimination. The highest peak is the first in the list. On success it returns; number of found peaks.; Â ; Parameters:; ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ source-pointer to the matrix of source; spectrumï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ; ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ dest-resulting spectrum ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum2.html:37131,detect,detect,37131,root/html602/TSpectrum2.html,https://root.cern,https://root.cern/root/html602/TSpectrum2.html,2,['detect'],['detect']
Safety,"Iterations-number of iterations in deconvolution operation; markov-logical variable, if it is true, first the source spectrum; is replaced by new spectrum calculated using Markov; chains method.; averWindow-averanging window of searched peaks, for details; we refer to manual (applies only for Markov method). . Peaks searching; Â ; Goal:; to identify automatically the peaks in spectrum with the presence of the; continuous background, one-fold coincidences (ridges) and statistical; fluctuations - noise. ; Â ; The common problems connected with correct peak; identification in two-dimensional coincidence spectra are. non-sensitivity to noise, i.e., only statistically; relevant peaks should be identified; non-sensitivity of the algorithm to continuous; background; non-sensitivity to one-fold coincidences (coincidences; peak ï¿½ background in both dimensions) and their crossings; ability to identify peaks close to the edges of the; spectrum region. Usually peak finders fail to detect them; resolution, decomposition of doublets and multiplets.; The algorithm should be able to recognize close positioned peaks. ; ability to identify peaks with different sigma. Â ; Function:; Int_t TSpectrum2::SearchHighRes (float **source,float **dest, int ssizex, int ssizey, float sigma, double threshold,; bool backgroundRemove,int deconIterations,; bool markov,; int averWindow); ï¿½ï¿½; Â ; This; function searches for peaks in source spectrum. It is based on deconvolution; method. First the background is removed (if desired), then Markov smoothed; spectrum is calculated (if desired), then the response function is generated; according to given sigma and deconvolution is carried out. The order of peaks; is arranged according to their heights in the spectrum after background; elimination. The highest peak is the first in the list. On success it returns; number of found peaks.; Â ; Parameters:; ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ source-pointer to the matrix of source; spectrumï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ; ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ dest-resulting spectrum aft",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2.html:36294,detect,detect,36294,root/html528/TSpectrum2.html,https://root.cern,https://root.cern/root/html528/TSpectrum2.html,4,['detect'],['detect']
Safety,"Keys(TList* listOfKeys); Remove the TKey duplication,; leave the keys with highest cycle number only; Sort if first. void Reset(); Reset the status of the iterator. void SetCursorPosition(const char* keyNameToFind); Find the key by the name provided. TKey * SkipObjects(Int_t nSkip = 1). Returns the TKey pointer to the nSkip TKey object from the current one; nSkip = 0; the state of the iterator is not changed. nSkip > 0; iterator skips nSkip objects in the container.; the direction of the iteration is; sign(nSkip)*kIterForward. Returns: TKey that can be used to fetch the object from the TDirectory. TKey * NextEventKey(UInt_t eventNumber = UInt_t(-1), UInt_t runNumber = UInt_t(-1), const char* name = ""*""). TObject * NextEventGet(UInt_t eventNumber = UInt_t(-1), UInt_t runNumber = UInt_t(-1), const char* name = ""*""); reads, creates and returns the object by TKey name that matches; the ""name"" .""runNumber"" ."" eventNumber"" schema; Attention: This method does create a new TObject and it is the user; code responsibility to take care (delete) this object to avoid; memory leak. TObject * ReadObj(const TKey* key) const; Read the next TObject from for the TDirectory by TKey provided. Int_t NextEventPut(TObject* obj, UInt_t eventNum, UInt_t runNumber, const char* name = 0); Create a special TKey name with obj provided and write it out. TString MapName(const char* name, const char* localSystemKey = 0, const char* mountedFileSystemKey = 0). MapName(const char *name, const char *localSystemKey,const char *mountedFileSystemKey). Substitute the logical name with the real one if any; 1. add a line into system.rootrc or ~/.rootrc or ./.rootrc. TFileIter.ForeignFileMap mapFile // the name of the file; to map the local name; to the global file service. If this line is omitted then TFileIter class seeks for; the default mapping file in the current directory ""io.config"". const char * GetResourceName(). {return ""ForeignFileMap"";}. const char * GetDefaultMapFileName(). {return ""io.config"";}.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileIter.html:9742,avoid,avoid,9742,root/html528/TFileIter.html,https://root.cern,https://root.cern/root/html528/TFileIter.html,6,['avoid'],['avoid']
Safety,"L << ""The STANDARD architecture has been deprecated. ""; 439 ""Please use Architecture=CPU or Architecture=CPU.""; 440 ""See the TMVA Users' Guide for instructions if you ""; 441 ""encounter problems.""; 442 << Endl;; 443 }; 444 ; 445 if (fArchitectureString == ""OPENCL"") {; 446 Log() << kERROR << ""The OPENCL architecture has not been implemented yet. ""; 447 ""Please use Architecture=CPU or Architecture=CPU for the ""; 448 ""time being. See the TMVA Users' Guide for instructions ""; 449 ""if you encounter problems.""; 450 << Endl;; 451 Log() << kFATAL << ""The OPENCL architecture has not been implemented yet. ""; 452 ""Please use Architecture=CPU or Architecture=CPU for the ""; 453 ""time being. See the TMVA Users' Guide for instructions ""; 454 ""if you encounter problems.""; 455 << Endl;; 456 }; 457 ; 458 if (fArchitectureString == ""GPU"") {; 459#ifndef DNNCUDA // Included only if DNNCUDA flag is _not_ set.; 460 Log() << kERROR << ""CUDA backend not enabled. Please make sure ""; 461 ""you have CUDA installed and it was successfully ""; 462 ""detected by CMAKE.""; 463 << Endl;; 464 Log() << kFATAL << ""CUDA backend not enabled. Please make sure ""; 465 ""you have CUDA installed and it was successfully ""; 466 ""detected by CMAKE.""; 467 << Endl;; 468#endif // DNNCUDA; 469 }; 470 ; 471 if (fArchitectureString == ""CPU"") {; 472#ifndef DNNCPU // Included only if DNNCPU flag is _not_ set.; 473 Log() << kERROR << ""Multi-core CPU backend not enabled. Please make sure ""; 474 ""you have a BLAS implementation and it was successfully ""; 475 ""detected by CMake as well that the imt CMake flag is set.""; 476 << Endl;; 477 Log() << kFATAL << ""Multi-core CPU backend not enabled. Please make sure ""; 478 ""you have a BLAS implementation and it was successfully ""; 479 ""detected by CMake as well that the imt CMake flag is set.""; 480 << Endl;; 481#endif // DNNCPU; 482 }; 483 ; 484 //; 485 // Set network structure.; 486 //; 487 ; 488 fLayout = TMVA::MethodDNN::ParseLayoutString (fLayoutString);; 489 size_t inputSize = GetNV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:15733,detect,detected,15733,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['detect'],['detected']
Safety,"L << ( 4 )); , kGetEntryWithIndex = (1ULL << ( 5 )); , kGetFriend = (1ULL << ( 6 )); , kGetFriendAlias = (1ULL << ( 7 )); , ; Â Â kGetLeaf = (1ULL << ( 8 )); , kLoadTree = (1ULL << ( 9 )); , kPrint = (1ULL << ( 10 )); , kRemoveFriend = (1ULL << ( 11 )); , ; Â Â kSetBranchStatus = (1ULL << ( 12 )). }; Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â . Protected Member Functions; virtual TBranch *Â BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel); Â Same as TTree::Branch() with added check that addobj matches className. ; Â ; virtual TBranch *Â BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel); Â Same as TTree::Branch but automatic detection of the class name. ; Â ; virtual TBranch *Â BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel); Â ; virtual TBranch *Â BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel); Â Same as TTree::Branch but automatic detection of the class name. ; Â ; virtual TBranch *Â BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel); Â Same as TTree::Branch but automatic detection of the class name. ; Â ; virtual TBranch *Â BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel); Â Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ; Â ; virtual Int_tÂ CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr); Â Check whether or not the address described by the last 3 parameters matches the content of the branch. ; Â ; Long64_tÂ GetCacheAutoSize (bool withDefault=false); Â Used for automatic sizing of the cache. ; Â ; virtual TLeaf *Â GetLeafImpl (const char *branchname, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:57751,detect,detection,57751,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['detect'],['detection']
Safety,"L) {; 15696 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15697 OPENSSL_REMOVE_THREAD_STATE();; 15698 return 0;; 15699 }; 15700 SSL_set_app_data(conn->ssl, (char *)conn);; 15701 ; 15702 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15703 if (ret != 1) {; 15704 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15705 SSL_free(conn->ssl);; 15706 conn->ssl = NULL;; 15707 OPENSSL_REMOVE_THREAD_STATE();; 15708 return 0;; 15709 }; 15710 ; 15711 if (client_options) {; 15712 if (client_options->host_name) {; 15713 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15714 }; 15715 }; 15716 ; 15717 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15718 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15719 /* NOTE: The loop below acts as a back-off, so we can end; 15720 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15721 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15722 if (to >= 0) {; 15723 timeout = (unsigned)to;; 15724 }; 15725 }; 15726 ; 15727 /* SSL functions may fail and require to be called again:; 15728 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15729 * Here ""func"" could be SSL_connect or SSL_accept. */; 15730 for (i = 0; i <= timeout; i += 50) {; 15731 ERR_clear_error();; 15732 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15733 ret = func(conn->ssl);; 15734 if (ret != 1) {; 15735 err = SSL_get_error(conn->ssl, ret);; 15736 if ((err == SSL_ERROR_WANT_CONNECT); 15737 || (err == SSL_ERROR_WANT_ACCEPT); 15738 || (err == SSL_ERROR_WANT_READ) || (err == SSL_ERROR_WANT_WRITE); 15739 || (err == SSL_ERROR_WANT_X509_LOOKUP)) {; 15740 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 15741 /* Don't wait if the server is going to be stopped. */; 15742 break;; 15743 }; 15744 if (err == SSL_ERROR_WANT_X509_LOOKUP) {; 15745 /* Simply retry the function call. */; 15746 mg_sleep(50);; 15747 } else {; 15748 /* Need to retry the function call ""later",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:464602,timeout,timeout,464602,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"L) {; 15697 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15698 OPENSSL_REMOVE_THREAD_STATE();; 15699 return 0;; 15700 }; 15701 SSL_set_app_data(conn->ssl, (char *)conn);; 15702 ; 15703 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15704 if (ret != 1) {; 15705 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15706 SSL_free(conn->ssl);; 15707 conn->ssl = NULL;; 15708 OPENSSL_REMOVE_THREAD_STATE();; 15709 return 0;; 15710 }; 15711 ; 15712 if (client_options) {; 15713 if (client_options->host_name) {; 15714 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15715 }; 15716 }; 15717 ; 15718 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15719 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15720 /* NOTE: The loop below acts as a back-off, so we can end; 15721 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15722 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15723 if (to >= 0) {; 15724 timeout = (unsigned)to;; 15725 }; 15726 }; 15727 ; 15728 /* SSL functions may fail and require to be called again:; 15729 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15730 * Here ""func"" could be SSL_connect or SSL_accept. */; 15731 for (i = 0; i <= timeout; i += 50) {; 15732 ERR_clear_error();; 15733 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15734 ret = func(conn->ssl);; 15735 if (ret != 1) {; 15736 err = SSL_get_error(conn->ssl, ret);; 15737 if ((err == SSL_ERROR_WANT_CONNECT); 15738 || (err == SSL_ERROR_WANT_ACCEPT); 15739 || (err == SSL_ERROR_WANT_READ) || (err == SSL_ERROR_WANT_WRITE); 15740 || (err == SSL_ERROR_WANT_X509_LOOKUP)) {; 15741 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 15742 /* Don't wait if the server is going to be stopped. */; 15743 break;; 15744 }; 15745 if (err == SSL_ERROR_WANT_X509_LOOKUP) {; 15746 /* Simply retry the function call. */; 15747 mg_sleep(50);; 15748 } else {; 15749 /* Need to retry the function call ""later",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:464635,timeout,timeout,464635,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"LEN = 8192; , kBUFFERSIZE = 8192; , kItimerResolution = 10; }; Â . Functions; voidÂ ROOT::AddClass (const char *cname, Version_t id, const std::type_info &info, DictFuncPtr_t dict, Int_t pragmabits); Â Global function called by the ctor of a class's init class (see the ClassImp macro). ; Â ; ROOT::TClassAlt *Â ROOT::AddClassAlternate (const char *normName, const char *alternate); Â Global function called by GenerateInitInstance. ; Â ; voidÂ ROOT::Class_ShowMembers (TClass *cl, const void *obj, TMemberInspector &); Â Indirect call to the implementation of ShowMember allowing [forward] declaration with out a full definition of the TClass class. ; Â ; TClass *Â ROOT::CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il); Â Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Â ; voidÂ ROOT::Internal::DefaultStreamer (TBuffer &R__b, const TClass *cl, void *objpointer); Â Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer.h. ; Â ; const TInitBehavior *Â ROOT::Internal::DefineBehavior (void *, void *); Â ; Bool_tÂ ROOT::Internal::HasConsistentHashMember (const char *clName); Â Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; Â ; Bool_tÂ ROOT::Internal::HasConsistentHashMember (TClass &clRef); Â Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; Â ; template<class Tmpl > ; TBuffer &Â operator<< (TBuffer &buf, const Tmpl *obj); Â ; template<class Tmpl > ; TBuffer &Â operator>> (TBuffer &buf, Tmpl *&obj); Â ; TNamed *Â ROOT::RegisterClassTemplate (const char *name, const char *file, Int_t line); Â Global function to register the implementation file and line of a class template (i.e. ; Â ; voidÂ ROOT::RemoveClass (const char *cname, TClass *cl); Â Global function called by the dtor of a class's init class (see the ClassImp macro). ; Â ; voidÂ ROOT::RemoveClassAlternate (ROOT::TClassAlt *); Â ; voidÂ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Rtypes_8h.html:5807,avoid,avoid,5807,doc/master/Rtypes_8h.html,https://root.cern,https://root.cern/doc/master/Rtypes_8h.html,2,['avoid'],['avoid']
Safety,"LS-1; ++i) { // LumiSection; std::cout << ""[In Progress] LumiSection "" << i << std::endl;; for (int j = 0; j < numEvents; ++j) { // Events; Double_t r1 = ran.Gaus(0, 10);; Double_t r2 = ran.Gaus(0, 8);; Double_t rok = ran.Gaus(10, 1);; Double_t rbad1 = ran.Gaus(8, 5);; Double_t rbad2 = ran.Gaus(-8, 5);; ; Double_t val = rok;; ; xoffset1 += 0.00002;; yoffset1 += 0.00002;; ; xoffset2 += 0.00003;; yoffset2 += 0.00004;; ; if (r2 > 3. - yoffset1 && r2 < 8. - yoffset1 &&; r1 > 1. + xoffset1 && r1 < 5. + xoffset1 ) {; val -= rbad1;; }; ; if (r2 > -10 + yoffset2 && r2 < -8 + yoffset2 &&; r1 > -6 + xoffset2 && r1 < 8 + xoffset2 ) {; val -= rbad2;; }; ; tot_avg_ls[i].Fill(r1, r2, val);; det_avg_ls[i].Fill(r1, r2, val);; det_err_ls[i].Fill(r1, r2, val);; }; ; std::string title;; ; c1->cd(i+1);; title = ""Global View: Avg in LS "" + std::to_string(i);; tot_avg_ls[i].SetTitle(title.c_str());; tot_avg_ls[i].SetStats(false);; tot_avg_ls[i].Draw(""COLZ"");; c1->Update();; ; c1->cd((i+1)+NUM_LS);; title = ""Detector View: Avg in LS "" + std::to_string(i);; det_avg_ls[i].SetTitle(title.c_str());; det_avg_ls[i].SetStats(false);; det_avg_ls[i].Draw(""COLZ"");; c1->Update();; ; c1->cd((i+1)+(NUM_LS*2));; title = ""Detector View: Error in LS "" + std::to_string(i);; det_err_ls[i].SetTitle(title.c_str());; det_err_ls[i].SetStats(false);; det_err_ls[i].SetContentToError();; det_err_ls[i].Draw(""COLZ"");; c1->Update();; }; ; std::vector<TProfile2Poly*> tot_avg_v;; std::vector<TProfile2Poly*> det_avg_v;; for (int t = 0; t < NUM_LS; t++){; tot_avg_v.push_back(&tot_avg_ls[t]);; det_avg_v.push_back(&det_avg_ls[t]);; }; ; std::cout << ""[In Progress] Merging"" << std::endl;; ; tot_merge->Merge(tot_avg_v);; c2->cd(1);; tot_merge->SetTitle(""Total average merge"");; tot_merge->Draw(""COLZ"");; ; det_avg_merge->Merge(det_avg_v);; c2->cd(2);; det_avg_merge->SetTitle(""Detector average merge"");; det_avg_merge->SetContentToAverage(); // implicit; det_avg_merge->Draw(""COLZ"");; ; det_err_merge->Merge(det_avg_v);; c2->cd(3)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tprofile2polyRealistic_8C.html:3934,Detect,Detector,3934,doc/master/tprofile2polyRealistic_8C.html,https://root.cern,https://root.cern/doc/master/tprofile2polyRealistic_8C.html,1,['Detect'],['Detector']
Safety,"LSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); static voidTXMLSetup::SetNameSpaceBase(const char* namespacebase); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidSetStoreStreamerInfos(Bool_t iConvert = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetUsedDtd(Bool_t use = kTRUE); virtual voidSetUseNamespaces(Bool_t iUseNamespaces = kTRUE); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidSetXmlLayout(TXMLSetup::EXMLLayout layout); virtual voidShowMembers(TMemberInspector& insp); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tSizeof() const; virtual voidStreamer(TBuffer& b); voidS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLFile.html:14791,timeout,timeout,14791,root/html528/TXMLFile.html,https://root.cern,https://root.cern/root/html528/TXMLFile.html,1,['timeout'],['timeout']
Safety,"L_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >fStagedOptimization: Keep staged array once they were created; type_info&fTypeinfoType information; TGenCollectionProxy::Value*fValDescriptor of the Value_type; intfValDiffOffset between two consecutive value_types (memory layout).; intfValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*fValueDescriptor of the container value type; TStreamerInfoActions::TActionSequence*fWriteMemberWise. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeleteItem(void* ptr); Delete individual item from STL container. s. Streamer(TBuffer& refBuffer). s. Streamer(TBuffer& refBuffer). else s-> Clear(). void Resize(size_t nelement). TGenCollectionProxy* Initialize(Bool_t silent) const; Late initialization of collection proxy. TGenCollectionProxy* InitializeEx(Bool_t silent); Some hack to avoid const-ness. void CheckFunctions() const; Allow to check function pointers. TGenCollectionProxy(). TVirtualCollectionProxy* Generate() const; Virtual copy constructor. TGenCollectionProxy(const TGenCollectionProxy& copy); Copy constructor. TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); Initializing constructor. TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl). virtual ~TGenCollectionProxy(); Standard destructor. TClass * GetCollectionClass(); Return a pointer to the TClass representing the container. Int_t GetCollectionType(); Return the type of collection see TClassEdit::ESTLType. ULong_t GetIncrement(); Return the offset between two consecutive value_types (memory layout). UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objstart); Push new proxy environment. void PopProxy(); Pop old proxy environment. Bool_t HasPointers() const; Return true if the content is of type 'point",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGenCollectionProxy.html:6386,avoid,avoid,6386,root/html532/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html,1,['avoid'],['avoid']
Safety,"LegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints. void CalcGaussLegendreSamplingPoints(). Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points this routine fills the arrays x and w; of length num, containing the abscissa and weight of the Gauss-Legendre; n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. num is the number of sampling points (>0); x and w are arrays of size num; eps is the relative precision. If num<=0 or eps<=0 no action is done. Reference: Numerical Recipes in C, Second Edition. Â» Last changed: root/mathcore:$Id: GaussLegendreIntegrator.h 36764 2010-11-19 10:02:00Z moneta $ Â» Last generated: 2010-11-19 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GaussLegendreIntegrator.html:4542,unsafe,unsafe,4542,root/html528/ROOT__Math__GaussLegendreIntegrator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GaussLegendreIntegrator.html,1,['unsafe'],['unsafe']
Safety,"LegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints. void CalcGaussLegendreSamplingPoints(). Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points this routine fills the arrays x and w; of length num, containing the abscissa and weight of the Gauss-Legendre; n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. num is the number of sampling points (>0); x and w are arrays of size num; eps is the relative precision. If num<=0 or eps<=0 no action is done. Reference: Numerical Recipes in C, Second Edition. Â» Last changed: root/mathcore:$Id: GaussLegendreIntegrator.h 36764 2010-11-19 10:02:00Z moneta $ Â» Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__GaussLegendreIntegrator.html:4544,unsafe,unsafe,4544,root/html530/ROOT__Math__GaussLegendreIntegrator.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__GaussLegendreIntegrator.html,1,['unsafe'],['unsafe']
Safety,"LegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints. void CalcGaussLegendreSamplingPoints(). Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points this routine fills the arrays x and w; of length num, containing the abscissa and weight of the Gauss-Legendre; n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. num is the number of sampling points (>0); x and w are arrays of size num; eps is the relative precision. If num<=0 or eps<=0 no action is done. Reference: Numerical Recipes in C, Second Edition. Â» Last changed: root/mathcore:$Id: GaussLegendreIntegrator.h 36764 2010-11-19 10:02:00Z moneta $ Â» Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:4544,unsafe,unsafe,4544,root/html532/ROOT__Math__GaussLegendreIntegrator.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html,1,['unsafe'],['unsafe']
Safety,"LineGLGL-renderer for TEveLine class ; Â CTEveLineProjectedProjected copy of a TEveLine ; Â CTEveListTreeItemSpecial list-tree-item for Eve ; Â CTEveMacroSub-class of TMacro, overriding Exec to unload the previous version and cleanup after the execution ; Â CTEveMagFieldAbstract base-class for interfacing to magnetic field needed by the TEveTrackPropagator ; Â CTEveMagFieldConstImplements constant magnetic field, given by a vector fB ; Â CTEveMagFieldDuoImplements constant magnetic filed that switches on given axial radius fR2 from vector fBIn to fBOut ; Â â–ºCTEveManagerCentral application manager for Eve ; Â CTExceptionHandlerException handler for Eve exceptions ; Â CTRedrawDisabler; Â CTEveMCRecCrossRef; Â CTEveMCTrack; Â CTEventIter; Â CTEventIterObj; Â â–ºCTEventIterTree; Â CTFileTree; Â CTEventIterUnit; Â CTEventListA TEventList object is a list of selected events (entries) in a TTree ; Â CTEvePadThis was intended as a TPad wrapper to allow smart updates of groups of pads ; Â CTEvePadHolderException safe wrapper for setting gPad ; Â â–ºCTEveParamListCollection of named parameters ; Â CBoolConfig_t; Â CFloatConfig_t; Â CIntConfig_t; Â CTEveParamListEditorGUI editor for TEveParamList ; Â CTEvePathMarkTSpecial-point on track: ; Â CTEvePlot3DDescription of TEvePlot3D ; Â CTEvePlot3DGLOpenGL renderer class for TEvePlot3D ; Â CTEvePointSelectorTEvePointSelector is a sub-class of TSelectorDraw for direct extraction of point-like data from a Tree ; Â CTEvePointSelectorConsumerTEvePointSelectorConsumer is a virtual base for classes that can be filled from TTree data via the TEvePointSelector class ; Â CTEvePointSetTEvePointSet is a render-element holding a collection of 3D points with optional per-point TRef and an arbitrary number of integer ids (to be used for signal, volume-id, track-id, etc) ; Â CTEvePointSetArrayAn array of point-sets with each point-set playing a role of a bin in a histogram ; Â CTEvePointSetArrayEditorEditor for TEvePointSetArray class ; Â CTEvePointSetProjectedProjected copy of a TEv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:105451,safe,safe,105451,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['safe'],['safe']
Safety,"Link(); lnk; lnk = lnk->Next()) {; 961 TTree* clone = (TTree*) lnk->GetObject();; 962 // clone->ResetBranchAddresses();; 963 ; 964 // Reset only the branch we have set the address of.; 965 CopyAddresses(clone,true);; 966 }; 967 }; 968 // Get rid of our branches, note that this will also release; 969 // any memory allocated by TBranchElement::SetAddress().; 970 fBranches.Delete();; 971 ; 972 // The TBranch destructor is using fDirectory to detect whether it; 973 // owns the TFile that contains its data (See TBranch::~TBranch); 974 fDirectory = nullptr;; 975 ; 976 // FIXME: We must consider what to do with the reset of these if we are a clone.; 977 delete fPlayer;; 978 fPlayer = nullptr;; 979 if (fExternalFriends) {; 980 using namespace ROOT::Detail;; 981 for(auto fetree : TRangeStaticCast<TFriendElement>(*fExternalFriends)); 982 fetree->Reset();; 983 fExternalFriends->Clear(""nodelete"");; 984 SafeDelete(fExternalFriends);; 985 }; 986 if (fFriends) {; 987 fFriends->Delete();; 988 delete fFriends;; 989 fFriends = nullptr;; 990 }; 991 if (fAliases) {; 992 fAliases->Delete();; 993 delete fAliases;; 994 fAliases = nullptr;; 995 }; 996 if (fUserInfo) {; 997 fUserInfo->Delete();; 998 delete fUserInfo;; 999 fUserInfo = nullptr;; 1000 }; 1001 if (fClones) {; 1002 // Clone trees should no longer be removed from fClones when they are deleted.; 1003 {; 1004 R__LOCKGUARD(gROOTMutex);; 1005 gROOT->GetListOfCleanups()->Remove(fClones);; 1006 }; 1007 // Note: fClones does not own its content.; 1008 delete fClones;; 1009 fClones = nullptr;; 1010 }; 1011 if (fEntryList) {; 1012 if (fEntryList->TestBit(kCanDelete) && fEntryList->GetDirectory()==nullptr) {; 1013 // Delete the entry list if it is marked to be deleted and it is not also; 1014 // owned by a directory. (Otherwise we would need to make sure that a; 1015 // TDirectoryFile that has a TTree in it does a 'slow' TList::Delete.; 1016 delete fEntryList;; 1017 fEntryList=nullptr;; 1018 }; 1019 }; 1020 delete fTreeIndex;; 1021 fTreeIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:35705,Safe,SafeDelete,35705,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,"Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; Â» GUI; Â» SESSIONVIEWER; Â» TProofProgressDialog. class TProofProgressDialog. TProofProgressDialog. This class provides a query progress bar. Function Members (Methods); public:. TProofProgressDialog(const TProofProgressDialog&); TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries); virtual~TProofProgressDialog(); static TClass*Class(); voidCloseWindow(); voidDisableAsyn(); voidDoAbort(); voidDoAsyn(); voidDoClose(); voidDoEnableSpeedo(); voidDoKeep(Bool_t on); voidDoLog(); voidDoMemoryPlot(); voidDoPlotRateGraph(); voidDoSetLogQuery(Bool_t on); voidDoStop(); voidIndicateStop(Bool_t aborted); virtual TClass*IsA() const; voidLogMessage(const char* msg, Bool_t all); TProofProgressDialog&operator=(const TProofProgressDialog&); voidProgress(Long64_t total, Long64_t processed); voidProgress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); voidProgress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); voidResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidToggleOdometerInfos(); voidToggleThreshold(). private:. Float_tAdjustBytes(Float_t mbs, TString& sf). Data Members; public:. enum EQueryStatus { kRunning; kDone; kStopped; kAborted; kIncomplete; };. private:. TGTextButton*fAbort; TGraph*fActWGraph; TGTextButton*fAsyn; Double_tfAvgMBRate; Double_tfAvgRate; TGProgressBar*fBarprogress bar; TGTextButton*fClose; TGTransientFrame*fDialogtransient frame, main dialog window; TGraph*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofProgressDialog.html:877,abort,aborted,877,root/html534/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html534/TProofProgressDialog.html,1,['abort'],['aborted']
Safety,"Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#if !defined(CGI_ENVIRONMENT_SIZE); 486#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */; 487#endif; 488 ; 489/* Maximum number of environment variables. */; 490#if !defined(MAX_CGI_ENVIR_VARS); 491#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */; 492#endif; 493 ; 494/* General purpose buffer size. */; 49",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:16508,timeout,timeouts,16508,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,4,['timeout'],['timeouts']
Safety,"LowBin; doublefLumiError; doublefNomLumi; TFile*fOut_f; stringstreamfResultsPrefixStr; stringfRowTitle; vector<string>fSystToFix; FILE*pFile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HistoToWorkspaceFactory(). ~HistoToWorkspaceFactory(). HistoToWorkspaceFactory(string , string , vector<string> , double = 200, double = 20, int = 0, int = 6, TFile* = 0). string FilePrefixStr(string ). void ProcessExpectedHisto(TH1* hist, RooWorkspace* proto, string prefix, string productPrefix, string systTerm, double low, double high, int lowBin, int highBin). void AddMultiVarGaussConstraint(RooWorkspace* proto, string prefix, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins. void LinInterpWithConstraint(RooWorkspace* proto, TH1* nominal, vector<TH1*> lowHist, vector<TH1*> highHist, vector<string> sourceName, string prefix, string productPrefix, string systTerm, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins; make list of abstract parameters that interpolate in space of variations; range is set using defined macro (see top of the page). string AddNormFactor(RooWorkspace* , string& , string& , RooStats::HistFactory::EstimateSummary& , bool ). void AddEfficiencyTerms(RooWorkspace* proto, string prefix, string interpName, map<string,pair<double,double> > systMap, vector<string>& likelihoodTermNames, vector<string>& totSystTermNames); add variables for all the relative overall uncertainties we expect; range is set using defined macro (see top of the page); string range=""[0,-1,1]"";. void MakeTotalExpected(RooWorkspace* proto, string totName, string , string , int lowBin, int highBin, vector<string>& syst_x_expectedPrefixNames, vector<string>& normByNames); for ith bi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HistFactory__HistoToWorkspaceFactory.html:8712,predict,predictions,8712,root/html532/RooStats__HistFactory__HistoToWorkspaceFactory.html,https://root.cern,https://root.cern/root/html532/RooStats__HistFactory__HistoToWorkspaceFactory.html,1,['predict'],['predictions']
Safety,"M and parameters and uncertainties in form of std::vector containers.; 3.5.2 Memory allocation and thread safety; Differently to the version of M , the version has its own memory manager (StackAllocator. The user can select between the standard dynamic memory allocation and deallocation (default) and performance-optimized stackâ€“like allocation (optional). However, the library is not thread save using stackâ€“allocation.; 3.5.3 M parameters; Differently to the version of M there is no limit on the number of parameters, variable or non-variable. Memory allocation is done dynamically according to the actual needs and â€œon demandâ€. There is no protection against an upper limit on the number of parameters, however the â€œtechnologicalâ€ limitations of M can be seen around a maximum of 15 free parameters at a time.; 3.6 Interference with other packages; The new M has been designed to interfere as little as possible with other programs or packages which may be loaded at the same time. M is thread safe by default. Optionally the user can select a different way of dynamically allocating memory in the class StackAllacator for M , in which case (and after an entire recompilation of the whole library) the thread safety is lost.; 3.7 Floating-point precision; [install:epsmac]; M is entirely based on double precision. The actual floating point precision of double precision (32â€“bit or 64â€“bit) is platform dependent and can even vary on the same platform, depending on whether a floating point number is read from memory a CPU register.; The argument of the userâ€™s implementation of FCNBase::operator() is therefore a std:vector\(<\)double\(>\). M expects that the calculations inside \(\mbox{FCN}\) will be performed approximately to the same accuracy.; The accuracy M expects is called machine precision (MnMachinePrecision, see [api:epsmac]) and can be printed on demand using std::cout. If the user fools M by making internal \(\mbox{FCN}\) computations in single precision, M will interpret roun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:27542,safe,safe,27542,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['safe'],['safe']
Safety,"M and parameters and uncertainties in form of std::vector containers.; 3.5.2 Memory allocation and thread safety; Differently to the version of M , the version has its own memory manager (StackAllocator. The user can select between the standard dynamic memory allocation and deallocation (default) and performance-optimized stackâ€“like allocation (optional). However, the library is not thread save using stackâ€“allocation.; 3.5.3 M parameters; Differently to the version of M there is no limit on the number of parameters, variable or non-variable. Memory allocation is done dynamically according to the actual needs and â€œon demandâ€. There is no protection against an upper limit on the number of parameters, however the â€œtechnologicalâ€ limitations of M can be seen around a maximum of 15 free parameters at a time.; 3.6 Interference with other packages; The new M has been designed to interfere as little as possible with other programs or packages which may be loaded at the same time. M is thread safe by default. Optionally the user can select a different way of dynamically allocating memory in the class StackAllacator for M , in which case (and after an entire recompiliation of the whole library) the thread safety is lost.; 3.7 Floating-point precision; [install:epsmac]; M is entirely based on double precision. The actual floating point precision of double precision (32â€“bit or 64â€“bit) is platform dependent and can even vary on the same platform, depending on whether a floating point number is read from memory a CPU register.; The argument of the userâ€™s implementation of FCNBase::operator() is therefore a std:vector\(<\)double\(>\). M expects that the calculations inside \(\mbox{FCN}\) will be performed approximately to the same accuracy.; The accuracy M expects is called machine precision (MnMachinePrecision, see [api:epsmac]) and can be printed on demand using std::cout. If the user fools M by making internal \(\mbox{FCN}\) computations in single precision, M will interpret rou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:31565,safe,safe,31565,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['safe'],['safe']
Safety,"Mask = 0x00ffffff. }; Â ; enum Â { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; Â ; enum Â EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); }; Â ; enum Â EStatusBits { ; Â Â kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ; Â Â kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; Â . Public Member Functions; Â TAuthenticate (TSocket *sock, const char *remote, const char *proto, const char *user=""""); Â Create authentication object. ; Â ; virtualÂ ~TAuthenticate (); Â ; Bool_tÂ Authenticate (); Â Authenticate to remote rootd or proofd server. ; Â ; Int_tÂ AuthExists (TString User, Int_t method, const char *Options, Int_t *Message, Int_t *Rflag, CheckSecCtx_t funcheck); Â Check if we have a valid established sec context in memory Retrieves relevant info and negotiates with server. ; Â ; voidÂ CatchTimeOut (); Â Called in connection with a timer timeout. ; Â ; Bool_tÂ CheckNetrc (TString &user, TString &passwd); Â Try to get user name and passwd from the ~/.rootnetrc or ~/.netrc files. ; Â ; Bool_tÂ CheckNetrc (TString &user, TString &passwd, Bool_t &pwhash, Bool_t srppwd); Â Try to get user name and passwd from the ~/.rootnetrc or ~/.netrc files. ; Â ; THostAuth *Â GetHostAuth () const; Â ; const char *Â GetProtocol () const; Â ; const char *Â GetRemoteHost () const; Â ; Int_tÂ GetRSAKeyType () const; Â ; TRootSecContext *Â GetSecContext () const; Â ; TSocket *Â GetSocket () const; Â ; const char *Â GetUser () const; Â ; Int_tÂ HasTimedOut () const; Â ; TClass *Â IsA () const override; Â ; voidÂ SetRSAKeyType (Int_t key); Â ; voidÂ SetSecContext (TRootSecContext *ctx); Â ; voidÂ Streamer (TBuffer &) override; Â Stream an object of class TObject. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; Â Public Member Functions inherited from TObject; Â TObject (); Â TObject constructor. ; Â ; Â TObject (const TObject &obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:1748,timeout,timeout,1748,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['timeout'],['timeout']
Safety,"MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TEventIterUnit&operator=(const TEventIterUnit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPreProcessEvent(Long64_t); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidTEventIter::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEventIterUnit.html:4780,abort,abort,4780,root/html534/TEventIterUnit.html,https://root.cern,https://root.cern/root/html534/TEventIterUnit.html,1,['abort'],['abort']
Safety,"Member Functions |; Protected Attributes |; Static Protected Attributes |; List of all members ; TMemFile Class ReferenceInput/Output Library. ; A TMemFile is like a normal TFile except that it reads and writes only from memory. ; Definition at line 19 of file TMemFile.h. Classes; struct Â TMemBlock; Â ; struct Â ZeroCopyView_t; Â A read-only memory range which we do not control. More...; Â . Public Types; usingÂ ExternalDataPtr_t = std::shared_ptr< const std::vector< char > >; Â ; Â Public Types inherited from TFile; enum Â { kStartBigFile = 2000000000; }; Â ; enum Â EAsyncOpenStatus { kAOSNotAsync = -1; , kAOSFailure = 0; , kAOSInProgress = 1; , kAOSSuccess = 2; }; Â Asynchronous open request status. More...; Â ; enum Â ECacheAction { kDisconnect = 0; , kDoNotDisconnect = 1; }; Â TTreeCache flushing semantics. More...; Â ; enum Â EFileType { ; Â Â kDefault = 0; , kLocal = 1; , kNet = 2; , kWeb = 3; , ; Â Â kFile = 4; , kMerge = 5. }; Â File type. More...; Â ; enum Â EOpenTimeOut { kInstantTimeout = 0; , kEternalTimeout = 999999999; }; Â Open timeout constants. More...; Â ; enum Â ERelativeTo { kBeg = 0; , kCur = 1; , kEnd = 2; }; Â ; enum Â EStatusBits { ; Â Â k630forwardCompatibility = (1ULL << ( 2 )); , kRecovered = (1ULL << ( 10 )); , kHasReferences = (1ULL << ( 11 )); , kDevNull = (1ULL << ( 12 )); , ; Â Â kWriteError = (1ULL << ( 14 )); , kBinaryFile = (1ULL << ( 15 )); , kRedirected = (1ULL << ( 16 )); , kReproducible = (1ULL << ( 17 )). }; Â TFile status bits. BIT(13) is taken up by TObject. More...; Â ; Â Public Types inherited from TDirectoryFile; enum Â EStatusBits { kCloseDirectory = (1ULL << ( 7 )); }; Â ; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; Â Â kBitMask = 0x00ffffff. }; Â ; enum Â { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; Â ; enum Â EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); }; Â ; enum Â EStatusBits { ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMemFile.html:1290,timeout,timeout,1290,doc/master/classTMemFile.html,https://root.cern,https://root.cern/doc/master/classTMemFile.html,2,['timeout'],['timeout']
Safety,"Method method = kSpline2, Int_t minnsmooth = 0, Int_t maxnsmooth = 0, Bool_t checkHist = kFALSE, Bool_t norm = kTRUE); constructor of spline based PDF:. PDF(const TString& name, const TH1* theHist, TMVA::KDEKernel::EKernelType ktype, TMVA::KDEKernel::EKernelIter kiter, TMVA::KDEKernel::EKernelBorder kborder, Float_t FineFactor, Bool_t norm = kTRUE); constructor of kernel based PDF:. PDF(const TString& name, const TString& options, const TString& suffix = """", TMVA::PDF* defaultPDF = 0, Bool_t norm = kTRUE). ~PDF(); destructor. void BuildPDF(const TH1* theHist). Int_t GetHistNBins(Int_t evtNum = 0). void BuildSplinePDF(); build the PDF from the original histograms. void BuildKDEPDF(); creates high-binned reference histogram to be used instead of the; PDF for speed reasons. void SmoothHistogram(). void FillHistToGraph(); Simple conversion. void FillSplineToHist(); creates high-binned reference histogram to be used instead of the; PDF for speed reasons. void CheckHist() const; sanity check: compare PDF with original histogram. void ValidatePDF(TH1* original = 0) const; comparison of original histogram with reference PDF. Double_t GetIntegral() const; computes normalisation. Double_t IGetVal(Double_t* , Double_t* ); static external auxiliary function (integrand). Double_t GetIntegral(Double_t xmin, Double_t xmax); computes PDF integral within given ranges. Double_t GetVal(Double_t x) const; returns value PDF(x). Double_t GetValInverse(Double_t y, Bool_t isMonotonouslyIncreasingFunction = kFALSE) const; returns value PDF^{-1}(y). void FindBinInverse(const TH1* histogram, Int_t& lowerBin, Int_t& higherBin, Double_t& lowerBinValue, Double_t& higherBinValue, Double_t y, Bool_t isMonotonouslyIncreasingFunction = kFALSE) const; find bin from value on ordinate. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; PDFInterpol[ivar] <string> Spline0, Spline1, Spline2 <default>, Spline3, Spline5, KDE used to interpolate re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDF.html:11029,sanity check,sanity check,11029,root/html530/TMVA__PDF.html,https://root.cern,https://root.cern/root/html530/TMVA__PDF.html,5,['sanity check'],['sanity check']
Safety,"Method method = kSpline2, Int_t minnsmooth = 0, Int_t maxnsmooth = 0, Bool_t checkHist = kFALSE, Bool_t norm = kTRUE); constructor of spline based PDF:. PDF(const TString& name, const TH1* theHist, TMVA::KDEKernel::EKernelType ktype, TMVA::KDEKernel::EKernelIter kiter, TMVA::KDEKernel::EKernelBorder kborder, Float_t FineFactor, Bool_t norm = kTRUE); constructor of kernel based PDF:. PDF(const TString& name, const TString& options, const TString& suffix = """", TMVA::PDF* defaultPDF = 0, Bool_t norm = kTRUE). ~PDF(); destructor. void BuildPDF(const TH1* theHist). Int_t GetHistNBins(Int_t evtNum = 0). void BuildSplinePDF(); build the PDF from the original histograms. void BuildKDEPDF(); creates high-binned reference histogram to be used instead of the; PDF for speed reasons. void SmoothHistogram(). void FillHistToGraph(); Simple conversion. void FillSplineToHist(); creates high-binned reference histogram to be used instead of the; PDF for speed reasons. void CheckHist() const; sanity check: compare PDF with original histogram. void ValidatePDF(TH1* original = 0) const; comparison of original histogram with reference PDF. Double_t GetIntegral() const; computes normalisation. Double_t IGetVal(Double_t* , Double_t* ); static external auxiliary function (integrand). Double_t GetIntegral(Double_t xmin, Double_t xmax); computes PDF integral within given ranges. Double_t GetVal(Double_t x) const; returns value PDF(x). void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; PDFInterpol[ivar] <string> Spline0, Spline1, Spline2 <default>, Spline3, Spline5, KDE used to interpolate reference histograms; if no variable index is given, it is valid for ALL the variables. NSmooth <int> how often the input histos are smoothed; MinNSmooth <int> min number of smoothing iterations, for bins with most data; MaxNSmooth <int> max number of smoothing iterations, for bins with least data; NAvEvtPerBin <int> minimum average number of events",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__PDF.html:10673,sanity check,sanity check,10673,root/html528/TMVA__PDF.html,https://root.cern,https://root.cern/root/html528/TMVA__PDF.html,1,['sanity check'],['sanity check']
Safety,"Mode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DistSampler(); default constructor. {}. virtual ~DistSampler(); virtual destructor. void SetFunction(Function & func, unsigned int dim); set the parent function distribution to use for sampling (generic case). DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); need to clone to avoid temporary. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). unsigned int NDim() const; return the dimension of the parent distribution (and the data). { return fData.size(); }. bool Init(const char* = """"). initialize the generators with the given algorithm; Implemented by derived classes who needs it; (like UnuranSampler); If nothing is specified use default algorithm; from DistSamplerOptions::SetDefaultAlgorithm. { return true;}. bool Init(const ROOT::Math::DistSamplerOptions& opt). initialize the generators with the given option; which my include the algorithm but also more if; the method is re-impelmented by derived class; The default implementation calls the above method; passing just the algorithm name. void SetRandom(TRandom* ). Set the random engine to be used; To be implemented by the derived classes who provides; random sampling. {}. void SetSeed(unsi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__DistSampler.html:2874,avoid,avoid,2874,root/html602/ROOT__Math__DistSampler.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__DistSampler.html,2,['avoid'],['avoid']
Safety,"Model.; Definition at line 185 of file RooResolutionModel.cxx. â—†Â Class(). static TClass * RooResolutionModel::Class ; (; ). static . ReturnsTClass describing this class . â—†Â Class_Name(). static const char * RooResolutionModel::Class_Name ; (; ). static . ReturnsName of this class . â—†Â Class_Version(). static constexpr Version_t RooResolutionModel::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 81 of file RooResolutionModel.h. â—†Â clone(). TObject * RooResolutionModel::clone ; (; const char *Â ; newname); const. overridepure virtual . Implements RooAbsArg.; Implemented in RooGaussModel, RooGExpModel, RooAddModel, and RooTruthModel. â—†Â convolution(). RooResolutionModel * RooResolutionModel::convolution ; (; RooFormulaVar *Â ; inBasis, . RooAbsArg *Â ; ownerÂ . ); const. virtual . Instantiate a clone of this resolution model representing a convolution with given basis function. ; The owners object name is incorporated in the clones name to avoid multiple convolution objects with the same name in complex PDF structures.; Note: The 'inBasis' formula expression must be a RooFormulaVar that encodes the formula in the title of the object and this expression must be an exact match against the implemented basis function strings (see derived class implementation of method basisCode() for those strings ; Reimplemented in RooAddModel.; Definition at line 143 of file RooResolutionModel.cxx. â—†Â convVar(). RooAbsRealLValue & RooResolutionModel::convVar ; (; ); const. inline . Return the convolution variable of the resolution model. ; Definition at line 49 of file RooResolutionModel.h. â—†Â DeclFileName(). static const char * RooResolutionModel::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 81 of file RooResolutionModel.h. â—†Â getNorm(). double RooResolutionModel::getNorm ; (; const RooArgSet *Â ; nset = nullptr); const. overridevirtual . Return the integral of this PDF over all ele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooResolutionModel.html:79428,avoid,avoid,79428,doc/master/classRooResolutionModel.html,https://root.cern,https://root.cern/doc/master/classRooResolutionModel.html,1,['avoid'],['avoid']
Safety,"More...; Â ; class Â TEveLineProjected; Â Projected copy of a TEveLine. More...; Â ; class Â TEveElement::TEveListTreeInfo; Â Structure holding information about TGListTree and TGListTreeItem that represents given TEveElement. More...; Â ; class Â TEveListTreeItem; Â Special list-tree-item for Eve. More...; Â ; class Â TEveMacro; Â Sub-class of TMacro, overriding Exec to unload the previous version and cleanup after the execution. More...; Â ; class Â TEveMagField; Â Abstract base-class for interfacing to magnetic field needed by the TEveTrackPropagator. More...; Â ; class Â TEveMagFieldConst; Â Implements constant magnetic field, given by a vector fB. More...; Â ; class Â TEveMagFieldDuo; Â Implements constant magnetic filed that switches on given axial radius fR2 from vector fBIn to fBOut. More...; Â ; class Â TEveManager; Â Central application manager for Eve. More...; Â ; class Â TEvePad; Â This was intended as a TPad wrapper to allow smart updates of groups of pads. More...; Â ; class Â TEvePadHolder; Â Exception safe wrapper for setting gPad. More...; Â ; class Â TEveParamList; Â Collection of named parameters. More...; Â ; class Â TEveParamListEditor; Â GUI editor for TEveParamList. More...; Â ; class Â TEvePathMarkT< TT >; Â Special-point on track: More...; Â ; class Â TEvePlot3D; Â Description of TEvePlot3D. More...; Â ; class Â TEvePlot3DGL; Â OpenGL renderer class for TEvePlot3D. More...; Â ; class Â TEvePointSelector; Â TEvePointSelector is a sub-class of TSelectorDraw for direct extraction of point-like data from a Tree. More...; Â ; class Â TEvePointSelectorConsumer; Â TEvePointSelectorConsumer is a virtual base for classes that can be filled from TTree data via the TEvePointSelector class. More...; Â ; class Â TEvePointSet; Â TEvePointSet is a render-element holding a collection of 3D points with optional per-point TRef and an arbitrary number of integer ids (to be used for signal, volume-id, track-id, etc). More...; Â ; class Â TEvePointSetArray; Â An array of point-sets with each point-set playing a role ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__TEve.html:10466,safe,safe,10466,doc/master/group__TEve.html,https://root.cern,https://root.cern/doc/master/group__TEve.html,1,['safe'],['safe']
Safety,"N; Build the new libGenVector library. gfal; ON; GFAL support, requires libgfal. glite; ON; gLite support, requires libglite-api-wrapper v.3 from GSI (https://subversion.gsi.de/trac/dgrid/wiki). globus; OFF; Globus authentication support, requires Globus toolkit. gminimal; OFF; Do not automatically search for support libraries, but include X11. gnuinstall; OFF; Perform installation following the GNU guidelines. gsl_shared; OFF; Enable linking against shared libraries for GSL (default no). gviz; ON; Graphs visualization support, requires graphviz. hdfs; ON; HDFS support; requires libhdfs from HDFS >= 0.19.1. http; *; HTTP Server support. imt; ON; Enable ROOT Multithreading Capabilities (default ON from version 6.10). jemalloc; OFF; Using the jemalloc allocator. krb5; ON; Kerberos5 support, requires Kerberos libs. ldap; ON; LDAP support, requires (Open)LDAP libs. mathmore; ON; Build the new libMathMore extended math library, requires GSL (vers. >= 1.8). memstat; *; A memory statistics utility, helps to detect memory leaks. minimal; OFF; Do not automatically search for support libraries. minuit2; *; Build the new libMinuit2 minimizer library. monalisa; ON; Monalisa monitoring support, requires libapmoncpp. mt; OFF; Multi-threading support (deprecated and unused since ROOT v6.12). mysql; ON; MySQL support, requires libmysqlclient. odbc; ON; ODBC support, requires libiodbc or libodbc. opengl; ON; OpenGL support, requires libGL and libGLU. oracle; ON; Oracle support, requires libocci. pgsql; ON; PostgreSQL support, requires libpq. pythia6; ON; Pythia6 EG support, requires libPythia6. pythia6_nolink; OFF; Delayed linking of Pythia6 library. pythia8; ON; Pythia8 EG support, requires libPythia8. python; ON; Python ROOT bindings, requires python >= 2.2. qt. Qt graphics backend, requires libqt >= 4.8. qtgsi; *; GSI's Qt integration, requires libqt >= 4.8. roofit; *; Build the libRooFit advanced fitting package. root7; OFF; ROOT 7 support (read more). roottest; OFF; Include root",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:10655,detect,detect,10655,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['detect'],['detect']
Safety,"NCE OLD PYTHON VERSIONS ARE NOT SUPPORTED BY CPPYY:; 369// Right now we use C++ objects to automatize memory management. One could use; 370// RAAI and the Python memory allocation API (PEP 445) once some old Python; 371// version is deprecated in CPPYY. That new feature is available since version; 372// 3.4 and the preprocessor branching to also support that would be so; 373// complicated to make the code unreadable.; 374 std::vector<std::wstring> argv2;; 375 argv2.reserve(argc);; 376 argv2.emplace_back(name.c_str(), &name[name.size()]);; 377 ; 378 for (int i = 1; i < argc; ++i) {; 379 auto iarg = args[i - 1].c_str();; 380 argv2.emplace_back(iarg, &iarg[strlen(iarg)]);; 381 }; 382 ; 383#if PY_VERSION_HEX < 0x03080000; 384// Before version 3.8, the code is one simple line; 385 wchar_t *argv2_arr[argc];; 386 for (int i = 0; i < argc; ++i) {; 387 argv2_arr[i] = const_cast<wchar_t *>(argv2[i].c_str());; 388 }; 389 PySys_SetArgv(argc, argv2_arr);; 390 ; 391#else; 392// Here we comply to ""PEP 587 â€“ Python Initialization Configuration"" to avoid; 393// deprecation warnings at compile time.; 394 class PyConfigHelperRAAI {; 395 public:; 396 PyConfigHelperRAAI(const std::vector<std::wstring> &argv2); 397 {; 398 PyConfig_InitPythonConfig(&fConfig);; 399 fConfig.parse_argv = 1;; 400 UpdateArgv(argv2);; 401 InitFromConfig();; 402 }; 403 ~PyConfigHelperRAAI() { PyConfig_Clear(&fConfig); }; 404 ; 405 private:; 406 void InitFromConfig() { Py_InitializeFromConfig(&fConfig); };; 407 void UpdateArgv(const std::vector<std::wstring> &argv2); 408 {; 409 auto WideStringListAppendHelper = [](PyWideStringList *wslist, const wchar_t *wcstr) {; 410 PyStatus append_status = PyWideStringList_Append(wslist, wcstr);; 411 if (PyStatus_IsError(append_status)) {; 412 std::wcerr << ""Error: could not append element "" << wcstr << "" to arglist - "" << append_status.err_msg; 413 << std::endl;; 414 }; 415 };; 416 WideStringListAppendHelper(&fConfig.argv, Py_GetProgramName());; 417 for (const auto &iarg : ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/API_8cxx_source.html:13598,avoid,avoid,13598,doc/master/API_8cxx_source.html,https://root.cern,https://root.cern/doc/master/API_8cxx_source.html,1,['avoid'],['avoid']
Safety,"NTSystem Class Reference. . Definition at line 58 of file TWinNTSystem.h. Public Types; typedef Bool_t(*Â ThreadMsgFunc_t) (MSG *); Â ; Â Public Types inherited from TSystem; enum Â EAclicMode { kDefault; , kDebug; , kOpt; }; Â ; enum Â EAclicProperties { kFlatBuildDir = (1ULL << ( 0 )); }; Â ; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; Â Â kBitMask = 0x00ffffff. }; Â ; enum Â { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; Â ; enum Â EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); }; Â ; enum Â EStatusBits { ; Â Â kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ; Â Â kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). }; Â . Public Member Functions; Â TWinNTSystem (); Â ctor ; Â ; virtualÂ ~TWinNTSystem (); Â dtor ; Â ; voidÂ Abort (int code=0) override; Â Abort the application. ; Â ; intÂ AcceptConnection (int sock) override; Â Accept a connection. ; Â ; Bool_tÂ AccessPathName (const char *path, EAccessMode mode=kFileExists) override; Â Returns FALSE if one can access a file using the specified access mode. ; Â ; voidÂ AddDynamicPath (const char *dir) override; Â Add a new directory to the dynamic path. ; Â ; voidÂ AddFileHandler (TFileHandler *fh) override; Â Add a file handler to the list of system file handlers. ; Â ; voidÂ AddSignalHandler (TSignalHandler *sh) override; Â Add a signal handler to list of system signal handlers. ; Â ; voidÂ AddTimer (TTimer *ti) override; Â Add timer to list of system timers. ; Â ; intÂ AnnounceTcpService (int port, Bool_t reuse, int backlog, int tcpwindowsize=-1) override; Â Announce TCP/IP service. ; Â ; intÂ AnnounceUdpService (int port, int backlog) override; Â Announce UDP service. ; Â ; intÂ AnnounceUnixService (const char *sockpath, int backlog) override; Â Open a socke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:1390,Abort,Abort,1390,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,2,['Abort'],['Abort']
Safety,"NTuple (for n-tuple and nested tuple) is the experimental evolution of TTree columnar data storage. RNTuple introduces new interfaces that aim to be more robust. In particular, the new interfaces are type-safe through the use of templates, and the ownership is well-defined through the use of smart pointers. For instance tree->Branch(""px"", &Category, ""px/F"");; becomes auto px = model->MakeField<float>(""px"");; // px is std::shared_ptr<float>; The physical layout changes slightly from big endian to little endian so that it matches the in-memory layout on most modern architectures. Combined with a clear separation of offset/index data and payload data for collections, uncompressed RNTuple data can be directly mapped to memory without further copies. Goals; RNTuple shall investigate improvements of the TTree I/O in the following ways. More speed; Improve mapping to vectorized and parallel hardware; For types known at compile / JIT time: generate optimized code; Optimized for simple types (float, int, and vectors of them); Better memory control: work with a fixed budget of pre-defined I/O buffers; Naturally thread-safe and asynchronous interfaces. More robust interfaces; Compile-time type safety by default; Decomposition into layers: logical layer, primitives layer, storage layer; Separation of data model and live data; Self-contained I/O code to support creation of a standalone I/O library. Concepts; At the logical layer, the user defines a data model using the RNTupleModel class. The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree. The data model can contain (nested) collections, e.g., a type can be std::vector<std::vector<float>>.; Each serializable type is represented by a field, concretely by a templated version of RField, e.g. RField<double>. A field can generate or adopt an associated value, which represents a memory location storing a value of the given C++ type. These distinguished memory locations are th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/md_tree_2ntuple_2v7_2doc_2README.html:1260,safe,safe,1260,doc/master/md_tree_2ntuple_2v7_2doc_2README.html,https://root.cern,https://root.cern/doc/master/md_tree_2ntuple_2v7_2doc_2README.html,1,['safe'],['safe']
Safety,"Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. Double_t EvalInstance(Int_t i = 0, const char** stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeFormula.html:22194,redund,redundant,22194,root/html528/TTreeFormula.html,https://root.cern,https://root.cern/root/html528/TTreeFormula.html,3,['redund'],['redundant']
Safety,"Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char** stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* =======",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeFormula.html:22512,redund,redundant,22512,root/html534/TTreeFormula.html,https://root.cern,https://root.cern/root/html534/TTreeFormula.html,1,['redund'],['redundant']
Safety,"Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char*[] stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* ======",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeFormula.html:27762,redund,redundant,27762,root/html602/TTreeFormula.html,https://root.cern,https://root.cern/root/html602/TTreeFormula.html,2,['redund'],['redundant']
Safety,Navigator.h. â—†Â fDirection. Double_t TGeoNavigator::fDirection[3]. private . current point ; Definition at line 50 of file TGeoNavigator.h. â—†Â fDivMatrix. TGeoHMatrix* TGeoNavigator::fDivMatrix. private . current pointer to cached global matrix ; Definition at line 83 of file TGeoNavigator.h. â—†Â fForcedNode. TGeoNode* TGeoNavigator::fForcedNode. private . next node that will be crossed ; Definition at line 79 of file TGeoNavigator.h. â—†Â fGeometry. TGeoManager* TGeoNavigator::fGeometry. private . flag that last geometric step was null ; Definition at line 72 of file TGeoNavigator.h. â—†Â fGlobalMatrix. TGeoHMatrix* TGeoNavigator::fGlobalMatrix. private . current stored global matrix ; Definition at line 82 of file TGeoNavigator.h. â—†Â fgUsePWSafetyCaching. Bool_t TGeoNavigator::fgUsePWSafetyCaching = kFALSE. staticprivate . path to current node ; Definition at line 86 of file TGeoNavigator.h. â—†Â fIsEntering. Bool_t TGeoNavigator::fIsEntering. private . flag a safe start for point classification ; Definition at line 64 of file TGeoNavigator.h. â—†Â fIsExiting. Bool_t TGeoNavigator::fIsExiting. private . flag if current step just got into a new node ; Definition at line 65 of file TGeoNavigator.h. â—†Â fIsNullStep. Bool_t TGeoNavigator::fIsNullStep. private . flag that a new point is in the same node as previous ; Definition at line 71 of file TGeoNavigator.h. â—†Â fIsOnBoundary. Bool_t TGeoNavigator::fIsOnBoundary. private . flag that current point is outside geometry ; Definition at line 69 of file TGeoNavigator.h. â—†Â fIsOutside. Bool_t TGeoNavigator::fIsOutside. private . flag that next geometric step will exit current volume ; Definition at line 68 of file TGeoNavigator.h. â—†Â fIsSameLocation. Bool_t TGeoNavigator::fIsSameLocation. private . flag that current point is on some boundary ; Definition at line 70 of file TGeoNavigator.h. â—†Â fIsStepEntering. Bool_t TGeoNavigator::fIsStepEntering. private . flag that current track is about to leave current node ; Definition at line 66 of file T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:47285,safe,safe,47285,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['safe'],['safe']
Safety,"NmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoCone. â—†Â GetPhi1(). Double_t TGeoConeSeg::GetPhi1 ; (; ); const. inline . Definition at line 166 of file TGeoCone.h. â—†Â GetPhi2(). Double_t TGeoConeSeg::GetPhi2 ; (; ); const. inline . Definition at line 167 of file TGeoCone.h. â—†Â GetPointsOnSegments(). Bool_t TGeoConeSeg::GetPointsOnSegments ; (; Int_tÂ ; npoints, . Double_t *Â ; arrayÂ . ); const. overridevirtual . Reimplemented from TGeoCone. â—†Â InitTrigonometry(). void TGeoConeSeg::InitTrigonometry ; (; ). protected . â—†Â InspectShape(). void TGeoConeSeg::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoCone. â—†Â IsA(). TClass * TGeoConeSeg::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoCone.; Definition at line 183 of file TGeoCone.h. â—†Â MakeBuffer3D(). TBuffer3D * TGeoConeSeg::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoCone. â—†Â Safety(). Double_t TGeoConeSeg::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Reimplemented from TGeoCone. â—†Â Safety_v(). void TGeoConeSeg::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoCone. â—†Â SafetyS(). static Double_t TGeoConeSeg::SafetyS ; (; const Double_t *Â ; point, . Bool_tÂ ; in, . Double_tÂ ; dz, . Double_tÂ ; rmin1, . Double_tÂ ; rmax1, . Double_tÂ ; rmin2, . Double_tÂ ; rmax2, . Double_tÂ ; phi1, . Double_tÂ ; phi2, . Int_tÂ ; skipz = 0Â . ). static . â—†Â SavePrimitive(). void TGeoConeSeg::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoCone. â—†Â SetConsDimensions(). void TGeoConeSeg::SetConsDimensions ; (; Double_tÂ ; dz, . Double_tÂ ; rmin1, . Double_tÂ ; rmax1, . Double_tÂ ; rmin2, . Double_tÂ ; rmax2, . Double_tÂ ; phi1, . Double_tÂ ; phi2Â . ). â—†Â S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoConeSeg.html:33011,Safe,Safety,33011,doc/master/classTGeoConeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoConeSeg.html,1,['Safe'],['Safety']
Safety,"NmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoTube. â—†Â GetPhi1(). Double_t TGeoTubeSeg::GetPhi1 ; (; ); const. inline . Definition at line 154 of file TGeoTube.h. â—†Â GetPhi2(). Double_t TGeoTubeSeg::GetPhi2 ; (; ); const. inline . Definition at line 155 of file TGeoTube.h. â—†Â GetPointsOnSegments(). Bool_t TGeoTubeSeg::GetPointsOnSegments ; (; Int_tÂ ; npoints, . Double_t *Â ; arrayÂ . ); const. overridevirtual . Reimplemented from TGeoTube. â—†Â InitTrigonometry(). void TGeoTubeSeg::InitTrigonometry ; (; ). protected . â—†Â InspectShape(). void TGeoTubeSeg::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoTube. â—†Â IsA(). TClass * TGeoTubeSeg::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoTube.; Definition at line 170 of file TGeoTube.h. â—†Â MakeBuffer3D(). TBuffer3D * TGeoTubeSeg::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoTube. â—†Â Safety(). Double_t TGeoTubeSeg::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Reimplemented from TGeoTube. â—†Â Safety_v(). void TGeoTubeSeg::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoTube. â—†Â SafetyS(). static Double_t TGeoTubeSeg::SafetyS ; (; const Double_t *Â ; point, . Bool_tÂ ; in, . Double_tÂ ; rmin, . Double_tÂ ; rmax, . Double_tÂ ; dz, . Double_tÂ ; phi1, . Double_tÂ ; phi2, . Int_tÂ ; skipz = 0Â . ). static . â—†Â SavePrimitive(). void TGeoTubeSeg::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoTube. â—†Â SetDimensions(). void TGeoTubeSeg::SetDimensions ; (; Double_t *Â ; param). overridevirtual . Reimplemented from TGeoTube. â—†Â SetPoints() [1/2]. void TGeoTubeSeg::SetPoints ; (; Double_t *Â ; points); const. overridevirtual . Reimplemented from TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTubeSeg.html:31595,Safe,Safety,31595,doc/master/classTGeoTubeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoTubeSeg.html,1,['Safe'],['Safety']
Safety,"Node * TGeoNavigator::FindInCluster ; (; Int_t *Â ; cluster, . Int_tÂ ; ncÂ . ). protected . Find a node inside a cluster of overlapping nodes. ; Current node must be on top of all the nodes in cluster. Always nc>1. ; Definition at line 2159 of file TGeoNavigator.cxx. â—†Â FindNextBoundary(). TGeoNode * TGeoNavigator::FindNextBoundary ; (; Double_tÂ ; stepmax = TGeoShape::Big(), . const char *Â ; path = """", . Bool_tÂ ; frombdr = kFALSEÂ . ). Find distance to next boundary and store it in fStep. ; Returns node to which this boundary belongs. If PATH is specified, compute only distance to the node to which PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller than this value. STEPMAX represent the step to be made imposed by other reasons than geometry (usually physics processes). Therefore in this case this method provides the answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling fStep with a big number. In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is specified, otherwise users have to call explicitly TGeoManager::Safety() if they want this computed for the current point. ; Definition at line 624 of file TGeoNavigator.cxx. â—†Â FindNextBoundaryAndStep(). TGeoNode * TGeoNavigator::FindNextBoundaryAndStep ; (; Double_tÂ ; stepmax = TGeoShape::Big(), . Bool_tÂ ; compsafe = kFALSEÂ . ). Compute distance to next boundary within STEPMAX. ; If no boundary is found, propagate current point along current direction with fStep=STEPMAX. Otherwise propagate with fStep=SNEXT (distance to boundary) and locate/return the next node. ; Definition at line 1178 of file TGeoNavigator.cxx. â—†Â FindNextDaughterBoundary(). TGeoNode * TGeoNavigator::FindNextDaughterBoundary ; (; Double_t *Â ; point, . Double_t *Â ; dir, . Int_t &Â ; idaughter, . Bool_tÂ ; compmatrix = kFALSEÂ . ). Computes as fStep the distance to next daughter of the current volume. ; The po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:27536,safe,safety,27536,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['safe'],['safety']
Safety,"NumberCountingData""); voidAddExpData(Double_t* sigExp, Double_t* bkgExp, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); voidAddExpDataWithSideband(Double_t* sigExp, Double_t* bkgExp, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); voidAddModel(Double_t* sigExp, Int_t nchan, RooWorkspace* ws, const char* pdfName = ""CombinedPdf"", const char* masterSignalName = ""masterSignal""); static TClass*Class(); virtual TClass*IsA() const; RooStats::NumberCountingPdfFactoryNumberCountingPdfFactory(); RooStats::NumberCountingPdfFactoryNumberCountingPdfFactory(const RooStats::NumberCountingPdfFactory&); RooStats::NumberCountingPdfFactory&operator=(const RooStats::NumberCountingPdfFactory&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. RooRealVar*SafeObservableCreation(RooWorkspace* ws, const char* varName, Double_t value); RooRealVar*SafeObservableCreation(RooWorkspace* ws, const char* varName, Double_t value, Double_t maximum). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; NumberCountingPdfFactory(); constructor. ~NumberCountingPdfFactory(); destructor. void AddModel(Double_t* sigExp, Int_t nchan, RooWorkspace* ws, const char* pdfName = ""CombinedPdf"", const char* masterSignalName = ""masterSignal""); This method produces a PDF for N channels with uncorrelated background; uncertainty. It relates the signal in each channel to a master signal strength times the; expected signal in each channel. For the future, perhaps this method should be extended to include the efficiency terms automatically. void AddExpData(Double_t* sigExp, Double_t* bkgExp, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); Arguements are an array of expected signal, expected background, and relative; background uncertainty (eg. 0.1 for 10% uncertainty), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__NumberCountingPdfFactory.html:2470,Safe,SafeObservableCreation,2470,root/html528/RooStats__NumberCountingPdfFactory.html,https://root.cern,https://root.cern/root/html528/RooStats__NumberCountingPdfFactory.html,6,['Safe'],['SafeObservableCreation']
Safety,"O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete();; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method. The diffrent Add() methods of; TObjArray and its base classes are not allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offer the possibility to allocate and delete memory.; Forgetting to delete allocated memory is a programming error that originate ""leaks"",; i.e. the memory of your process grows and eventually your program crashes.; Even if you *always* delete the allocated memory, the recovered space may not be; efficiently reused. The process knows that there are portions of free memory,; but when you allocate it again, a fresh piece of memory is grabbed.; Your program is free from semantic errors, but the total memory of your process; still grows. Moreover your program's memory is full of ""holes"" which reduce the; efficiency of memory access, this is called ""memory fragmentation"".; Moreover new / delete are expensive operations in terms of CPU time. Without entering into technical details, the TClonesArray allow to ""reuse"" the; same portion of memory for new/delete avoiding memory fragmentation and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reused, the Clear() method is employed.; To provide its benefits, each TClonesArray must be allocated *once* per process; and disposed of (deleted) *only when not needed any more*.; So a job should see *only one* deletion for each TClonesArray, w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:1738,recover,recovered,1738,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,2,['recover'],['recovered']
Safety,"OOT = &GetROOT1;; 882 ; 883 // Mark the object as invalid, so that we can veto some actions; 884 // (like autoloading) while we are in the destructor.; 885 SetBit(TObject::kInvalidObject);; 886 ; 887 // Turn-off the global mutex to avoid recreating mutexes that have; 888 // already been deleted during the destruction phase; 889 if (gGlobalMutex) {; 890 TVirtualMutex *m = gGlobalMutex;; 891 gGlobalMutex = nullptr;; 892 delete m;; 893 }; 894 ; 895 // Return when error occurred in TCling, i.e. when setup file(s) are; 896 // out of date; 897 if (!fVersionInt) return;; 898 ; 899 // ATTENTION!!! Order is important!; 900 ; 901 SafeDelete(fBrowsables);; 902 ; 903 // FIXME: Causes rootcling to deadlock, debug and uncomment; 904 // SafeDelete(fRootFolder);; 905 ; 906#ifdef R__COMPLETE_MEM_TERMINATION; 907 fSpecials->Delete(); SafeDelete(fSpecials); // delete special objects : PostScript, Minuit, Html; 908#endif; 909 ; 910 fClosedObjects->Delete(""slow""); // and closed files; 911 fFiles->Delete(""slow""); // and files; 912 SafeDelete(fFiles);; 913 fSecContexts->Delete(""slow""); SafeDelete(fSecContexts); // and security contexts; 914 fSockets->Delete(); SafeDelete(fSockets); // and sockets; 915 fMappedFiles->Delete(""slow""); // and mapped files; 916 TSeqCollection *tl = fMappedFiles; fMappedFiles = nullptr; delete tl;; 917 ; 918 SafeDelete(fClosedObjects);; 919 ; 920 delete fUUIDs;; 921 TProcessID::Cleanup(); // and list of ProcessIDs; 922 ; 923 fFunctions->Delete(); SafeDelete(fFunctions); // etc..; 924 fGeometries->Delete(); SafeDelete(fGeometries);; 925 fBrowsers->Delete(); SafeDelete(fBrowsers);; 926 SafeDelete(fCanvases);; 927 fColors->Delete(); SafeDelete(fColors);; 928 fStyles->Delete(); SafeDelete(fStyles);; 929 ; 930#ifdef R__COMPLETE_MEM_TERMINATION; 931 if (gGuiFactory != gBatchGuiFactory) SafeDelete(gGuiFactory);; 932 SafeDelete(gBatchGuiFactory);; 933 if (gGXBatch != gVirtualX) SafeDelete(gGXBatch);; 934 SafeDelete(gVirtualX);; 935#endif; 936 ; 937 // Stop emitting signa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:35763,Safe,SafeDelete,35763,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,16,['Safe'],['SafeDelete']
Safety,"OOT now works on linuxarm64 / AArch64 / ARMv8 64-bit - thanks, David Abdurachmanov!; ROOT supports GCC 5.0 (using the GCC4 ABI) and XCode 6.3, Mac OSX 10.10.3; Thread-Safety; A lot of effort went into improving the thread-safety of Core and Meta classes / functions. A special thanks to Chris Jones from CMS!; std::string_view; Introduce a preview of C++17â€™s std::string_view. To take advantage of this new class use:; #include ""RStringView.h""; The documentation of this can be found at http://en.cppreference.com/w/cpp/experimental/basic_string_view The implementation provided is extracted from libcxx. Whenever the current compiler and standard library provide an implmentation, it is used.; The type string_view describes an object that can refer to a constant contiguous sequence of char-like objects with the first element of the sequence at position zero.; This type is used throughout the ROOT code to avoid copying strings when a sub-string is needed and to extent interfaces that uses to take a const char* to take a std::string_view as thus be able to be directly directly passed a TString, a std::string or a std::string_view. Usage example:; // With SetName(std::string_view); std::string str; â€¦; obj.SetName( str );; obj.SetName( {str.data()+pos, len} );; Meta library; Backward Incompatibilities; TIsAProxyâ€™s constructor no longer take the optional and unused 2nd argument which was reserved for a â€˜contextâ€™. This context was unused in TIsAProxy itself and was not accessible from derived classes.; Interpreter; The new interface TInterpreter::Declare(const char* code) will declare the code to the interpreter with all interpreter extensions disabled, i.e.Â as â€œproperâ€ C++ code. No autoloading or synamic lookup will be performed.; A new R__LOAD_LIBRARY(libWhatever) will load libWhatever at parse time. This allows ROOT to resolve symbols from this library very early on. It is a work-around for the following code from ROOT 5:; // ROOT 5:; void func() {; gSystem->Load(""libEvent"");;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:3570,avoid,avoid,3570,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['avoid'],['avoid']
Safety,"OOT offers the concept of friends for TTree and TChain:; 266if is good practice to rely on friend trees rather than adding a branch manually.; 267 ; 268\anchor fullexample; 269## An Example; 270 ; 271Begin_Macro; 272../../../tutorials/tree/tree.C; 273End_Macro; 274 ; 275~~~ {.cpp}; 276 // A simple example with histograms and a tree; 277 //; 278 // This program creates :; 279 // - a one dimensional histogram; 280 // - a two dimensional histogram; 281 // - a profile histogram; 282 // - a tree; 283 //; 284 // These objects are filled with some random numbers and saved on a file.; 285 ; 286 #include ""TFile.h""; 287 #include ""TH1.h""; 288 #include ""TH2.h""; 289 #include ""TProfile.h""; 290 #include ""TRandom.h""; 291 #include ""TTree.h""; 292 ; 293 //__________________________________________________________________________; 294 main(int argc, char **argv); 295 {; 296 // Create a new ROOT binary machine independent file.; 297 // Note that this file may contain any kind of ROOT objects, histograms,trees; 298 // pictures, graphics objects, detector geometries, tracks, events, etc..; 299 // This file is now becoming the current directory.; 300 TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");; 301 ; 302 // Create some histograms and a profile histogram; 303 TH1F hpx(""hpx"",""This is the px distribution"",100,-4,4);; 304 TH2F hpxpy(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; 305 TProfile hprof(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; 306 ; 307 // Define some simple structures; 308 typedef struct {Float_t x,y,z;} POINT;; 309 typedef struct {; 310 Int_t ntrack,nseg,nvertex;; 311 UInt_t flag;; 312 Float_t temperature;; 313 } EVENTN;; 314 POINT point;; 315 EVENTN eventn;; 316 ; 317 // Create a ROOT Tree; 318 TTree tree(""T"",""An example of ROOT tree with a few branches"");; 319 tree.Branch(""point"",&point,""x:y:z"");; 320 tree.Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; 321 tree.Branch(""hpx"",""TH1F"",&hpx,128000,0);; 322 ; 323 Float_t px,p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:13928,detect,detector,13928,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['detect'],['detector']
Safety,"OOT-7867 - memprobe script is broken when using CMake; ROOT-7992 - Destructor of TMinuit is not thread safe; ROOT-8048 - ShortTypes doesnâ€™t always strip default stdlib template args; ROOT-8055 - File corruption after TTree deletion; ROOT-8066 - problems creating dictionaries in pyROOT; ROOT-8067 - Source code tree left â€œpollutedâ€ with â€œinterpreter/llvm/src/utils/llvm-build/llvmbuild/*.pyc; ROOT-8068 - Fix file flags for bin/setxrd.* bin/thisroot.*; ROOT-8097 - null pointer dereference in TProtoClass::FillTClass with gcc6 build; ROOT-8117 - Particle in TPDGCode.h but not in TDatabasePDG; ROOT-8145 - TMethodCall::InitWithPrototype keeps accumulating memory on successive calls; ROOT-8149 - Memory leak in TList I/O. Release 6.06/06; Released on July 6, 2016; Cling. Properly handle try-catch functions. ROOT-8034; Fix handling of template parameter pack in the forward declaration printer. ROOT-8096. Core. Fix the validity of TRef after the first ProcessID is full.; Fix thread safety of TSystem::ExpandPathName ROOT-8205. Dictionaries. Do not autoparse headers for classes in the pch.; Avoid autoparse on IsForeign() if possible.; Check for new-style empty pcm with key named â€œEMPTYâ€ created since commit 90047b0cba6fd295f5c5722749a0d043fbc11ea5.; Do not insert macro definition of ROOTCLING into the pch. TTree. Properly handle the last element of arrays in the TTreeFormula functions MinIf and MaxIf ROOT-7258; Fix detection of errors that appears in nested TTreeFormula ROOT-8218; Avoid autoparse looking for default constructor in TTreeCloner::CopyStreamerInfos(). Bugs fixed in this release. [ROOT-6753] - PROOF-Lite doesnâ€™t find TSelector type from an already loaded library; [ROOT-7258] - MinIf and MaxIf TTreeFormula functions ignore last element; [ROOT-8038] - [patch] â€œfor e in getSTLLikeCollection()â€ crashes pyroot; [ROOT-8166] - Update INSTALL to reflect CMake; [ROOT-8184] - Error building XrdSysPthread with GCC 6.1; [ROOT-8197] - rootcp not preserving kSingleKey; [ROOT-8205] -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:31192,safe,safety,31192,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['safe'],['safety']
Safety,"OT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; 500 // clang-format on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @param[in] numthreads Number of threads to use. If not specified or; 510 /// set to zero, the number of threads is automatically; 511 /// decided by the implementation. Any other value is; 512 /// used as a hint.; 513 ///; 514 /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.; 515 /// The following objects and methods automatically take advantage of; 516 /// multi-threading if a call to `EnableImplicitMT` has been made before usage:; 517 ///; 518 /// - RDataFrame internally runs the event-loop by parallelizing over clusters of entries; 519 /// - TTree::GetEntry reads multiple branches in parallel; 520 /// - TTree::FlushBaskets wr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:18118,safe,safety,18118,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['safe'],['safety']
Safety,"OT-7480] - improvement of the occincdir search in configure. Tasks. [ROOT-7583] - Let thisroot add ROOT to CMAKE_PREFIX_PATH. Release 6.04/06; Build. Building ROOT with cmake command not in my PATH now fixed ROOT-7715; Fix builtin_xrootd option that was not working for XROOTD version 4.2.2.; Option gnuinstall also sets RPATH in librries and executables in installation directory; Various fixes for MacOS X 10.11 ROOT-7680. Core. Fix thread safety of the creation of TMethodCall from a TFunction.; Fix dictionary generation of STL collection involving one of ROOTâ€™s core classes when the user header contains only a forward declaration of the class [ROOT-7695]. Bugs. [ROOT-7680] - Canâ€™t build v6-02-12 on MacOS X 10.11; [ROOT-7695] - Segmentation violation in rootcint; [ROOT-7709] - PyROOT not functional with system-default Python version on MacOS X 10.11; [ROOT-7715] - Building ROOT with CMake not in my PATH fails. Release 6.04/08; Build. Add â€“disable-search-usrlocal to configure/make to be able to avoid conflict with incompatible installation (e.g.Â homebrew).; Add /opt/X11 to configure/make search for include files and libraries.; Updates PCRE to 8.37 (current upstream version) which can detect PPC64LE machine.; Fail cmake configuration if the specified CMAKE_BUILD_TYPE is unknown; Fix RPATH for MacOSX (El Capitan) to avoid building with -Drpath=ON. The default uses rpath=@loader_path/../lib. Core. Add missing protection when creating new StreamerInfo.; Add accessor functions and functionality needed by CMS event display.; Do not delete resource when replaceing default TApplication. Interpreter. Prevent crash in expressions which contain use undefined identifier ROOT-7737; Disable unnecessary code during dictionary generation that triggered problem due to the lack of support for template parameter packs ROOT-7708; Add suport in the type and name normalization routine for template parameter packs ROOT-7708. IO. For backward compatibility with ROOT5, allow to define IO const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:32642,avoid,avoid,32642,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['avoid'],['avoid']
Safety,"OT/RLogger.hxx>; 19#include <ROOT/RNTupleImtTaskScheduler.hxx>; 20#include <ROOT/RNTupleFillContext.hxx>; 21#include <ROOT/RNTupleMetrics.hxx>; 22#include <ROOT/RNTupleModel.hxx>; 23#include <ROOT/RNTupleWriteOptions.hxx>; 24#include <ROOT/RPageSinkBuf.hxx>; 25#include <ROOT/RPageStorage.hxx>; 26#include <ROOT/RPageStorageFile.hxx>; 27 ; 28#include <TROOT.h>; 29 ; 30#include <utility>; 31 ; 32ROOT::Experimental::RNTupleWriter::RNTupleWriter(std::unique_ptr<ROOT::Experimental::RNTupleModel> model,; 33 std::unique_ptr<ROOT::Experimental::Internal::RPageSink> sink); 34 : fFillContext(std::move(model), std::move(sink)), fMetrics(""RNTupleWriter""); 35{; 36#ifdef R__USE_IMT; 37 if (IsImplicitMTEnabled() &&; 38 fFillContext.fSink->GetWriteOptions().GetUseImplicitMT() == RNTupleWriteOptions::EImplicitMT::kDefault) {; 39 fZipTasks = std::make_unique<Internal::RNTupleImtTaskScheduler>();; 40 fFillContext.fSink->SetTaskScheduler(fZipTasks.get());; 41 }; 42#endif; 43 // Observe directly the sink's metrics to avoid an additional prefix from the fill context.; 44 fMetrics.ObserveMetrics(fFillContext.fSink->GetMetrics());; 45}; 46 ; 47ROOT::Experimental::RNTupleWriter::~RNTupleWriter(); 48{; 49 try {; 50 CommitCluster(true /* commitClusterGroup */);; 51 fFillContext.fSink->CommitDataset();; 52 } catch (const RException &err) {; 53 R__LOG_ERROR(NTupleLog()) << ""failure committing ntuple: "" << err.GetError().GetReport();; 54 }; 55}; 56 ; 57std::unique_ptr<ROOT::Experimental::RNTupleWriter>; 58ROOT::Experimental::RNTupleWriter::Create(std::unique_ptr<RNTupleModel> model,; 59 std::unique_ptr<Internal::RPageSink> sink, const RNTupleWriteOptions &options); 60{; 61 if (model->GetRegisteredSubfields().size() > 0) {; 62 throw RException(R__FAIL(""cannot create an RNTupleWriter from a model with registered subfields""));; 63 }; 64 if (options.GetUseBufferedWrite()) {; 65 sink = std::make_unique<Internal::RPageSinkBuf>(std::move(sink));; 66 }; 67 return std::unique_ptr<RNTupleWriter>(new RNTuple",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleWriter_8cxx_source.html:1915,avoid,avoid,1915,doc/master/RNTupleWriter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_t_allRRVAll contents are RRV; RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents.; TNamed*_structureTag! Structure tag; TNamed*_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. RooFIter fwdIterator() const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCollection.html:10178,safe,safeDeleteList,10178,root/html532/RooAbsCollection.html,https://root.cern,https://root.cern/root/html532/RooAbsCollection.html,2,['safe'],"['safe', 'safeDeleteList']"
Safety,"Object * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; RooFit::ComponentsRooCmdArg Components(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:128; RooFit::InvisibleRooCmdArg Invisible(bool inv=true)Definition RooGlobalFunc.cxx:276; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf205_compplotDefinition rf205_compplot.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg1,bkg2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg1,bkg2,sig); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (bkg1,bkg2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg1,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf205__compplot_8C.html:7028,safe,safe,7028,doc/master/rf205__compplot_8C.html,https://root.cern,https://root.cern/doc/master/rf205__compplot_8C.html,1,['safe'],['safe']
Safety,"Object*Next(); virtual booloperator!=(const TIterator&) const; booloperator!=(const TTreeFriendLeafIter&) const; TObject*TIterator::operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator& rhs); TTreeFriendLeafIter&operator=(const TTreeFriendLeafIter& rhs); virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TTreeFriendLeafIter(). Data Members; protected:. Bool_tfDirectioniteration direction; TIterator*fLeafItercurrent leaf sub-iterator.; TTree*fTreetree being iterated; TIterator*fTreeItercurrent tree sub-iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeFriendLeafIter(const TTree* t, Bool_t dir = kIterForward); Create a new iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. TTreeFriendLeafIter(const TTreeFriendLeafIter& iter); Copy constructor. Does NOT copy the 'cursor' location!. TIterator& operator=(const TIterator& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TTreeFriendLeafIter& operator=(const TTreeFriendLeafIter& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TObject* Next(); Go the next friend element. Option_t* GetOption() const; Returns the object option stored in the list. void Reset(Option_t* option = """"). TTreeFriendLeafIter(); { }. ~TTreeFriendLeafIter(); { SafeDelete(fLeafIter); SafeDelete(fTreeIter); }. const TCollection * GetCollection() const; { return 0; }. TObject * operator*() const; TODO: Implement me. Â» Author: Rene Brun 12/01/96 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/tree:$Id: TTree.h 37444 2010-12-09 18:12:26Z pcanal $ Â» Last generated: 2010-12-09 22:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeFriendLeafIter.html:2214,Safe,SafeDelete,2214,root/html528/TTreeFriendLeafIter.html,https://root.cern,https://root.cern/root/html528/TTreeFriendLeafIter.html,2,['Safe'],['SafeDelete']
Safety,"Object*Next(); virtual booloperator!=(const TIterator&) const; booloperator!=(const TTreeFriendLeafIter&) const; TObject*TIterator::operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator& rhs); TTreeFriendLeafIter&operator=(const TTreeFriendLeafIter& rhs); virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TTreeFriendLeafIter(). Data Members; protected:. Bool_tfDirectioniteration direction; TIterator*fLeafItercurrent leaf sub-iterator.; TTree*fTreetree being iterated; TIterator*fTreeItercurrent tree sub-iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeFriendLeafIter(const TTree* t, Bool_t dir = kIterForward); Create a new iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. TTreeFriendLeafIter(const TTreeFriendLeafIter& iter); Copy constructor. Does NOT copy the 'cursor' location!. TIterator& operator=(const TIterator& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TTreeFriendLeafIter& operator=(const TTreeFriendLeafIter& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TObject* Next(); Go the next friend element. Option_t* GetOption() const; Returns the object option stored in the list. void Reset(Option_t* option = """"). TTreeFriendLeafIter(); { }. ~TTreeFriendLeafIter(); { SafeDelete(fLeafIter); SafeDelete(fTreeIter); }. const TCollection * GetCollection() const; { return 0; }. TObject * operator*() const; TODO: Implement me. Â» Author: Rene Brun 12/01/96 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/tree:$Id: TTree.h 39643 2011-06-09 17:32:22Z pcanal $ Â» Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeFriendLeafIter.html:2214,Safe,SafeDelete,2214,root/html530/TTreeFriendLeafIter.html,https://root.cern,https://root.cern/root/html530/TTreeFriendLeafIter.html,2,['Safe'],['SafeDelete']
Safety,"Object*Next(); virtual booloperator!=(const TIterator&) const; booloperator!=(const TTreeFriendLeafIter&) const; TObject*TIterator::operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator& rhs); TTreeFriendLeafIter&operator=(const TTreeFriendLeafIter& rhs); virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TTreeFriendLeafIter(). Data Members; protected:. Bool_tfDirectioniteration direction; TIterator*fLeafItercurrent leaf sub-iterator.; TTree*fTreetree being iterated; TIterator*fTreeItercurrent tree sub-iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeFriendLeafIter(const TTree* t, Bool_t dir = kIterForward); Create a new iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. TTreeFriendLeafIter(const TTreeFriendLeafIter& iter); Copy constructor. Does NOT copy the 'cursor' location!. TIterator& operator=(const TIterator& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TTreeFriendLeafIter& operator=(const TTreeFriendLeafIter& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TObject* Next(); Go the next friend element. Option_t* GetOption() const; Returns the object option stored in the list. void Reset(Option_t* option = """"). TTreeFriendLeafIter(); { }. ~TTreeFriendLeafIter(); { SafeDelete(fLeafIter); SafeDelete(fTreeIter); }. const TCollection * GetCollection() const; { return 0; }. TObject * operator*() const; TODO: Implement me. Â» Author: Rene Brun 12/01/96 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/tree:$Id: TTree.h 41101 2011-10-03 16:23:48Z pcanal $ Â» Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeFriendLeafIter.html:2214,Safe,SafeDelete,2214,root/html532/TTreeFriendLeafIter.html,https://root.cern,https://root.cern/root/html532/TTreeFriendLeafIter.html,2,['Safe'],['SafeDelete']
Safety,"Object::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidsafeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCollection(); Destructor. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCollection.html:9591,safe,safeDeleteList,9591,root/html526/RooAbsCollection.html,https://root.cern,https://root.cern/root/html526/RooAbsCollection.html,4,['safe'],"['safe', 'safeDeleteList']"
Safety,"Object::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Bool_tfIgnoreDupignore duplicates, don't issue warning; TStringfRcNameresource file base name; THashList*fTablehash table containing env records. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEnv(const char* name = """"); Create a resource table and read the (possibly) three resource files, i.e; $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>), $HOME/<name> and; ./<name>. ROOT always reads "".rootrc"" (in TROOT::InitSystem()). You can; read additional user defined resource files by creating addtional TEnv; objects. By setting the shell variable ROOTENV_NO_HOME=1 the reading of; the $HOME/<name> resource file will be skipped. This might be useful in; case the home directory resides on an automounted remote file system; and one wants to avoid the file system from being mounted. ~TEnv(); Delete the resource table. const char * Getvalue(const char* name); Returns the character value for a named resouce. Int_t GetValue(const char* name, Int_t dflt); Returns the integer value for a resource. If the resource is not found; return the dflt value. Double_t GetValue(const char* name, Double_t dflt); Returns the double value for a resource. If the resource is not found; return the dflt value. const char * GetValue(const char* name, const char* dflt); Returns the character value for a named resouce. If the resource is; not found the dflt value is returned. TEnvRec * Lookup(const char* n); Loop over all resource records and return the one with name.; Return 0 in case name is not in the resoucre table. void Print(Option_t* option = """") const; Print all resources or the global, user or local resources separately. void PrintEnv(EEnvLevel level = kEnvAll) const; Print all resources for a certain le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEnv.html:9301,avoid,avoid,9301,root/html602/TEnv.html,https://root.cern,https://root.cern/root/html602/TEnv.html,2,['avoid'],['avoid']
Safety,"Object::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tTGeoBBox::Safety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidTGeoBBox::Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTGeoBBox::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFromFaceSet(TGLFaceSet* fs); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGeoBBox::SetPoints(Double_t* points) const; virtual voidTGeoBBox::SetPoints(Float_t* points) const; voidTGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveGeoPolyShape.html:8921,Safe,SafetySeg,8921,root/html602/TEveGeoPolyShape.html,https://root.cern,https://root.cern/root/html602/TEveGeoPolyShape.html,2,['Safe'],['SafetySeg']
Safety,"Object::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoHalfSpace&operator=(const TGeoHalfSpace&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t*) const; virtual voidSetPoints(Float_t*) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidTGeoBBox::SetSegsAndPols(TBuffer3D& b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHalfSpace.html:8618,Safe,SafetySeg,8618,root/html534/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html,1,['Safe'],['SafetySeg']
Safety,"Object::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTVirtualPacketizer::StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TPacketizer(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizer.html:5951,abort,abort,5951,root/html602/TPacketizer.html,https://root.cern,https://root.cern/root/html602/TPacketizer.html,2,['abort'],['abort']
Safety,"Object::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTube&operator=(const TGeoTube&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidSetSegsAndPols(TBuffer3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTube.html:9803,Safe,SafetySeg,9803,root/html534/TGeoTube.html,https://root.cern,https://root.cern/root/html534/TGeoTube.html,3,['Safe'],['SafetySeg']
Safety,"Object; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool ; TNamed*RooAbsCollection::_structureTag! Structure tag; TNamed*RooAbsCollection::_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooArgSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooArgSet(); Default constructor. RooArgSet(const RooArgList& list); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const RooArgList& list, const RooAbsArg* var1); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooArgSet.html:14499,avoid,avoid,14499,root/html532/RooArgSet.html,https://root.cern,https://root.cern/root/html532/RooArgSet.html,2,['avoid'],['avoid']
Safety,"OfActives(). ; Definition at line 482 of file TMonitor.cxx. â—†Â Ready(). void TMonitor::Ready ; (; TSocket *Â ; sock). virtual . Emit signal when some socket is ready. ; Definition at line 530 of file TMonitor.cxx. â—†Â Remove(). void TMonitor::Remove ; (; TSocket *Â ; sock). virtual . Remove a socket from the monitor. ; Definition at line 214 of file TMonitor.cxx. â—†Â RemoveAll(). void TMonitor::RemoveAll ; (; ). virtual . Remove all sockets from the monitor. ; Definition at line 241 of file TMonitor.cxx. â—†Â ResetInterrupt(). void TMonitor::ResetInterrupt ; (; ). inline . Definition at line 72 of file TMonitor.h. â—†Â Select() [1/3]. TSocket * TMonitor::Select ; (; ). Return pointer to socket for which an event is waiting. ; Select can be interrupt by a call to Interrupt() (e.g. connected with a Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable in such a case. Return 0 in case of error. ; Definition at line 322 of file TMonitor.cxx. â—†Â Select() [2/3]. TSocket * TMonitor::Select ; (; Long_tÂ ; timeout). Return pointer to socket for which an event is waiting. ; Wait a maximum of timeout milliseconds. If return is due to timeout it returns (TSocket *)-1. Select() can be interrupt by a call to Interrupt() (e.g. connected with a Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable in such a case. Return 0 in case of any other error situation. ; Definition at line 348 of file TMonitor.cxx. â—†Â Select() [3/3]. Int_t TMonitor::Select ; (; TList *Â ; rdready, . TList *Â ; wrready, . Long_tÂ ; timeoutÂ . ). Return numbers of sockets that are ready for reading or writing. ; Wait a maximum of timeout milliseconds. Return 0 if timed-out. Return < 0 in case of error. If rdready and/or wrready are not 0, the lists of sockets with something to read and/or write are also returned. ; Definition at line 377 of file TMonitor.cxx. â—†Â SetInterest(). void TMonitor::SetInterest ; (; TSocket *Â ; sock, . Int_tÂ ; interest = kReadÂ . ). virtual . Set interest mask for socke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:21859,timeout,timeout,21859,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['timeout'],['timeout']
Safety,"Offset needs to be increment if the key/basket is copied; 1378 // and need to be zero for new key/basket.; 1379 Long64_t pdir;; 1380 b >> pdir;; 1381 fPidOffset = pdir >> kPidOffsetShift;; 1382 fSeekPdir = pdir & kPidOffsetMask;; 1383 } else {; 1384 UInt_t seekkey, seekdir;; 1385 b >> seekkey; fSeekKey = (Long64_t)seekkey;; 1386 b >> seekdir; fSeekPdir= (Long64_t)seekdir;; 1387 }; 1388 fClassName.Streamer(b);; 1389 //the following test required for forward and backward compatibility; 1390 if (fClassName == ""TDirectory"") {; 1391 fClassName = ""TDirectoryFile"";; 1392 SetBit(kIsDirectoryFile);; 1393 }; 1394 fName.Streamer(b);; 1395 fTitle.Streamer(b);; 1396 if (fKeylen < 0) {; 1397 Error(""Streamer"",""The value of fKeylen is incorrect (%d) ; trying to recover by setting it to zero"",fKeylen);; 1398 MakeZombie();; 1399 fKeylen = 0;; 1400 }; 1401 if (fObjlen < 0) {; 1402 Error(""Streamer"",""The value of fObjlen is incorrect (%d) ; trying to recover by setting it to zero"",fObjlen);; 1403 MakeZombie();; 1404 fObjlen = 0;; 1405 }; 1406 if (fNbytes < 0) {; 1407 Error(""Streamer"",""The value of fNbytes is incorrect (%d) ; trying to recover by setting it to zero"",fNbytes);; 1408 MakeZombie();; 1409 fNbytes = 0;; 1410 }; 1411 ; 1412 } else {; 1413 b << fNbytes;; 1414 version = (Version_t)fVersion;; 1415 b << version;; 1416 b << fObjlen;; 1417 if (fDatime.Get() == 0) fDatime.Set();; 1418 if (TestBit(TKey::kReproducible)); 1419 TDatime((UInt_t) 1).Streamer(b);; 1420 else; 1421 fDatime.Streamer(b);; 1422 b << fKeylen;; 1423 b << fCycle;; 1424 if (fVersion > 1000) {; 1425 b << fSeekKey;; 1426 ; 1427 // We currently store in the 16 highest bit of fSeekPdir the value of; 1428 // fPidOffset. This offset is used when a key (or basket) is transfered from one; 1429 // file to the other. In this case the TRef and TObject might have stored a; 1430 // pid index (to retrieve TProcessIDs) which refered to their order on the original; 1431 // file, the fPidOffset is to be added to those values to corr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:49449,recover,recover,49449,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,3,['recover'],['recover']
Safety,"OnlyPrepStep = (1ULL << ( 3 )); }; Â . #include <TSystem.h>. Inheritance diagram for TSystem:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. â—†Â EAclicMode. enum TSystem::EAclicMode. EnumeratorkDefaultÂ ; kDebugÂ ; kOptÂ . Definition at line 269 of file TSystem.h. â—†Â EAclicProperties. enum TSystem::EAclicProperties. EnumeratorkFlatBuildDirÂ . Definition at line 270 of file TSystem.h. Constructor & Destructor Documentation. â—†Â TSystem() [1/2]. TSystem::TSystem ; (; const TSystem &Â ; ). privatedelete . â—†Â TSystem() [2/2]. TSystem::TSystem ; (; const char *Â ; name = ""Generic"", . const char *Â ; title = ""GenericÂ System""Â . ). Create a new OS interface. ; Definition at line 125 of file TSystem.cxx. â—†Â ~TSystem(). TSystem::~TSystem ; (; ). virtual . Delete the OS interface. ; Definition at line 139 of file TSystem.cxx. Member Function Documentation. â—†Â Abort(). void TSystem::Abort ; (; intÂ ; code = 0). virtual . Abort the application. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 725 of file TSystem.cxx. â—†Â AcceptConnection(). int TSystem::AcceptConnection ; (; intÂ ; sock). virtual . Accept a connection. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 2381 of file TSystem.cxx. â—†Â AccessPathName(). Bool_t TSystem::AccessPathName ; (; const char *Â ; path, . EAccessModeÂ ; mode = kFileExistsÂ . ). virtual . Returns FALSE if one can access a file using the specified access mode. ; The file name must not contain any special shell characters line ~ or $, in those cases first call ExpandPathName(). Attention, bizarre convention of return value!! ; Reimplemented in TDCacheSystem, TNetSystem, TWebSystem, TUnixSystem, and TWinNTSystem.; Definition at line 1296 of file TSystem.cxx. â—†Â AddDynamicPath(). void TSystem::AddDynamicPath ; (; const char *Â ; pathname). virtual . Add a new directory to the dynamic path. ; Reimplemented in TWinNTSystem, and TUnixSystem.; Definition at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:34361,Abort,Abort,34361,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['Abort'],['Abort']
Safety,"Open a FITS file whose primary array represents a spectrum (flux vs wavelength) ; Â FITS_tutorial5.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ; Â FITS_tutorial6.COpen a FITS file whose primary array represents a spectrum table (flux vs wavelength) and dump its columns ; Â FITS_tutorial7.COpen a FITS file that contains a catalog of astronomical objects and dump some of its columns ; Â â–ºÂ foam; Â foam_demo.C Demonstrate the TFoam class ; Â foam_demopers.C This simple macro demonstrates persistency of FOAM object ; Â foam_kanwa.C This program can be execute from the command line as folows: ; Â â–ºÂ geom; Â assembly.CGeometry detector assembly example ; Â building.CDrawing a building where Dept ; Â cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ; Â csgdemo.CCombinatorial Solid Geometry example ; Â geodemo.CGUI to draw the geometry shapes ; Â geomAlice.CScript drawing a detector geometry (here ALICE) ; Â geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ; Â geomAtlas.CScript drawing a detector geometry (here ATLAS) ; Â geomBrahms.CScript drawing a detector geometry (here BRAHMS) ; Â geomD0.CScript drawing a detector geometry (here D0) ; Â geometry.CExample of the old geometry package (now obsolete) ; Â iterplugin.cxx; Â lego.CDrawing a figure, made of lego block, using ROOT geometry class ; Â mp3player.CDrawing a mp3 type music player, using ROOT geometry class ; Â na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ; Â na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ; Â na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ; Â parallel_world.CMisaligning geometry generate in many ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:107332,detect,detector,107332,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,2,['detect'],['detector']
Safety,"Option(). virtual void TVirtualProofPlayer::SetDrawFeedbackOption ; (; TDrawFeedback *Â ; f, . Option_t *Â ; optÂ . ). pure virtual . Implemented in TProofPlayer. â—†Â SetExitStatus(). virtual void TVirtualProofPlayer::SetExitStatus ; (; EExitStatusÂ ; ). pure virtual . Implemented in TProofPlayer. â—†Â SetInitTime(). virtual void TVirtualProofPlayer::SetInitTime ; (; ). pure virtual . Implemented in TProofPlayer, and TProofPlayerRemote. â—†Â SetMaxDrawQueries(). virtual void TVirtualProofPlayer::SetMaxDrawQueries ; (; Int_tÂ ; max). pure virtual . Implemented in TProofPlayer. â—†Â SetMerging(). virtual void TVirtualProofPlayer::SetMerging ; (; Bool_tÂ ; on = kTRUE). pure virtual . Implemented in TProofPlayerRemote, and TProofPlayer. â—†Â SetOutputFilePath(). virtual void TVirtualProofPlayer::SetOutputFilePath ; (; const char *Â ; fp). pure virtual . Implemented in TProofPlayer. â—†Â SetStopTimer(). virtual void TVirtualProofPlayer::SetStopTimer ; (; Bool_tÂ ; on = kTRUE, . Bool_tÂ ; abort = kFALSE, . Int_tÂ ; timeout = 0Â . ). pure virtual . Implemented in TProofPlayer. â—†Â StopProcess(). virtual void TVirtualProofPlayer::StopProcess ; (; Bool_tÂ ; abort, . Int_tÂ ; timeout = -1Â . ). pure virtual . Implemented in TProofPlayer, and TProofPlayerRemote. â—†Â StoreFeedback(). virtual void TVirtualProofPlayer::StoreFeedback ; (; TObject *Â ; slave, . TList *Â ; outÂ . ). pure virtual . Implemented in TProofPlayer, TProofPlayerRemote, and TProofPlayerLite. â—†Â StoreOutput(). virtual void TVirtualProofPlayer::StoreOutput ; (; TList *Â ; out). pure virtual . Implemented in TProofPlayer, and TProofPlayerRemote. â—†Â Streamer(). void TVirtualProofPlayer::Streamer ; (; TBuffer &Â ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. â—†Â StreamerNVirtual(). void TVirtualProofPlayer::StreamerNVirtual ; (; TBuffer &Â ; ClassDef_StreamerNVirtual_b). inline . Definition at line 142 of file TVirtualProofPlayer.h. â—†Â UpdateAutoBin(). virtual void TVirtualProofPlayer::UpdateAutoBin ; (; const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualProofPlayer.html:29225,timeout,timeout,29225,doc/master/classTVirtualProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTVirtualProofPlayer.html,1,['timeout'],['timeout']
Safety,"Option(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TEveCluster(); TEveCluster(const TEveCluster&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. UShort_tfDetIdCustom detector id.; Int_tfLabel[3]Labels of particles that contributed hits.; UShort_tfSubdetIdCustom sub-detector id.; TEveVectorfVVertex.; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveMCTrack& operator=(const TEveClust",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveCluster.html:4849,detect,detector,4849,root/html602/TEveCluster.html,https://root.cern,https://root.cern/root/html602/TEveCluster.html,2,['detect'],['detector']
Safety,"P; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgInstance = new MyGenerator;; return fgInstance;; }; void GenerateEvent() { ... }; void ImportParticles(TClonesArray* a, Option_t opt="""") {...}; Int_t ImportParticles(Option_t opt="""") { ... }; Int_t SetParameter(const char* name, Double_t val) { ... }; Double_t GetParameter(const char* name) { ... }; virtual ~MyGenerator() { ... }; protected:; MyGenerator() { ... }; MyGenerator(const MyGenerator& o) { ... }; MyGenerator& operator=(const MyGenerator& o) { ... }; static MyGenerator* fgInstance;; ClassDef(MyGenerator,0);; };. Having multiple objects accessing the same common blocks is not; safe. concrete TGenerator classes can be loaded in scripts and subseqent-; ly used in compiled code:. MyRun.h; class MyRun : public TObject; {; public:; static MyRun* Instance() { ... }; void SetGenerator(TGenerator* g) { fGenerator = g; }; void Run(Int_t n, Option_t* option=""""); {; TFile* file = TFile::Open(""file.root"",""RECREATE"");; TTree* tree = new TTree(""T"",""T"");; TClonesArray* p = new TClonesArray(""TParticles"");; tree->Branch(""particles"", &p);; for (Int_t event = 0; event < n; event++) {; fGenerator->GenerateEvent();; fGenerator->ImportParticles(p,option);; tree->Fill();; }; file->Write();; file->Close();; }. protected:; TGenerator* fGenerator;; ClassDef(MyRun,0);; };. Config.C; void Config(); {; MyRun* run = MyRun::Instance();; run->SetGenerator(MyGenerator::Instance());; }. main.cxx; int; main(int argc, char** argv); {; TApplication app("""", 0, 0);; gSystem->ProcessLine("".x Config.C"");; MyRun::Instance()->Run(10);; return 0;; }. This is especially us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGenerator.html:2598,safe,safe,2598,root/html528/TGenerator.html,https://root.cern,https://root.cern/root/html528/TGenerator.html,6,['safe'],['safe']
Safety,"PNEId = 0;; 492 fKeyPNEId = nullptr;; 493 fValuePNEId = nullptr;; 494 fMultiThread = kFALSE;; 495 fRaytraceMode = 0;; 496 fMaxThreads = 0;; 497 fUsePWNav = kFALSE;; 498 fParallelWorld = nullptr;; 499 ClearThreadsMap();; 500}; 501 ; 502////////////////////////////////////////////////////////////////////////////////; 503/// Destructor; 504 ; 505TGeoManager::~TGeoManager(); 506{; 507 if (gGeoManager != this); 508 gGeoManager = this;; 509 fIsGeomCleaning = kTRUE;; 510 ; 511 if (gROOT->GetListOfFiles()) { // in case this function is called from TROOT destructor; 512 gROOT->GetListOfGeometries()->Remove(this);; 513 gROOT->GetListOfBrowsables()->Remove(this);; 514 }; 515 // TSeqCollection *brlist = gROOT->GetListOfBrowsers();; 516 // TIter next(brlist);; 517 // TBrowser *browser = 0;; 518 // while ((browser=(TBrowser*)next())) browser->RecursiveRemove(this);; 519 ClearThreadsMap();; 520 ClearThreadData();; 521 delete TGeoBuilder::Instance(this);; 522 if (fBits); 523 delete[] fBits;; 524 SafeDelete(fNodes);; 525 SafeDelete(fTopNode);; 526 if (fOverlaps) {; 527 fOverlaps->Delete();; 528 SafeDelete(fOverlaps);; 529 }; 530 if (fRegions) {; 531 fRegions->Delete();; 532 SafeDelete(fRegions);; 533 }; 534 if (fMaterials) {; 535 fMaterials->Delete();; 536 SafeDelete(fMaterials);; 537 }; 538 SafeDelete(fElementTable);; 539 if (fMedia) {; 540 fMedia->Delete();; 541 SafeDelete(fMedia);; 542 }; 543 if (fHashVolumes) {; 544 fHashVolumes->Clear(""nodelete"");; 545 SafeDelete(fHashVolumes);; 546 }; 547 if (fHashGVolumes) {; 548 fHashGVolumes->Clear(""nodelete"");; 549 SafeDelete(fHashGVolumes);; 550 }; 551 if (fHashPNE) {; 552 fHashPNE->Delete();; 553 SafeDelete(fHashPNE);; 554 }; 555 if (fArrayPNE) {; 556 delete fArrayPNE;; 557 }; 558 if (fVolumes) {; 559 fVolumes->Delete();; 560 SafeDelete(fVolumes);; 561 }; 562 if (fShapes) {; 563 fShapes->Delete();; 564 SafeDelete(fShapes);; 565 }; 566 if (fPhysicalNodes) {; 567 fPhysicalNodes->Delete();; 568 SafeDelete(fPhysicalNodes);; 569 }; 570 if (fMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:21438,Safe,SafeDelete,21438,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety,"PROOF master.; The return value is -1 in case of an error and TSelector::GetStatus() in; in case of success. Bool_t MergeOutputFiles(); Merge output in files. void SetSelectorDataMembersFromOutputList(); Set the selector's data members:; find the mapping of data members to otuput list entries in the output list; and apply it. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). Long64_t Finalize(TQueryResult* qr); Finalize the results of a query already processed. Bool_t SendSelector(const char* selector_file); Send the selector file(s) to master or worker nodes. void MergeOutput(); Merge objects in output the lists. void Progress(Long64_t total, Long64_t processed); Progress signal. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Progress signal. void Progress(TProofProgressInfo* pi); Progress signal. void Feedback(TList* objs); Feedback signal. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop process after this event. Int_t AddOutputObject(TObject* obj); Incorporate the received object 'obj' into the output list fOutput.; The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' optimizing the memory; consumption.; Returns -1 in case of error, 1 if the object has been merged into another; one (so that its ownership has not been taken and can be deleted), and 0; otherwise. void RedirectOutput(Bool_t on = kTRUE); Control output redirection to TProof::fLogFileW. void AddOutput(TList* out); Incorporate the content of the received output list 'out' into the final; output list fOutput. The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' limiting the memory; consumption. void NotifyMemory(TObject* obj); Printout the memory record after merging object 'obj'; This record is used by the memory monitor. void SetLastMergingMsg(TObject* obj); Set the message to be notified in case of exception. Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayerRemote.html:17019,abort,abort,17019,root/html528/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html528/TProofPlayerRemote.html,6,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"Parameters (const RooArgSet &observables) const; Â Return all parameter constraint p.d.f.s on parameters listed in constrainedParams. ; Â ; RooArgSet *Â getConstraints (const RooArgSet &observables, RooArgSet const &constrainedParams, RooArgSet &pdfParams) const override; Â Return all parameter constraint p.d.f.s on parameters listed in constrainedParams. ; Â ; Int_tÂ getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const override; Â Query internal generation capabilities of component p.d.f.s and aggregate capabilities into master configuration passed to the generator context. ; Â ; voidÂ initGenerator (Int_t code) override; Â Forward one-time initialization call to component generation initialization methods. ; Â ; TClass *Â IsA () const override; Â ; boolÂ isBinnedDistribution (const RooArgSet &obs) const override; Â If all components that depend on obs are binned that so is the product. ; Â ; boolÂ isDirectGenSafe (const RooAbsArg &arg) const override; Â Forward determination of safety of internal generator code to component p.d.f that would generate the given observable. ; Â ; const RooArgList &Â pdfList () const; Â ; std::list< double > *Â plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const override; Â Forward the plot sampling hint from the p.d.f. that defines the observable obs. ; Â ; voidÂ printMetaArgs (std::ostream &os) const override; Â Customized printing of arguments of a RooProdPdf to more intuitively reflect the contents of the product operator construction. ; Â ; boolÂ redirectServersHook (const RooAbsCollection &, bool, bool, bool) override; Â Implement support for node removal. ; Â ; voidÂ removePdfs (RooAbsCollection const &pdfs); Â Remove some PDFs from the factors of this RooProdPdf. ; Â ; voidÂ selectNormalizationRange (const char *rangeName=nullptr, bool force=false) override; Â Interface function used by test statistics to freeze choice of range for interpretation of conditional product terms. ; Â ; boolÂ selfNormalize",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:6195,safe,safety,6195,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,1,['safe'],['safety']
Safety,"PathName(const char* lib, Bool_t quiet = kFALSE); virtual const char*TSystem::ExpandFileName(const char* fname); static void*FindDynLib(const char* lib); TSystem*TSystem::FindHelper(const char* path, void* dirptr = 0); virtual const char*GetLinkedLibraries(); voidTObject::MakeZombie(); static intReadUtmpFile(); static void*SearchUtmpEntry(int nentries, const char* tty); static const char*TSystem::StripOffProto(const char* path, const char* proto); static Func_tUnixDynFindSymbol(const char* lib, const char* entry); static voidUnixDynListLibs(const char* lib = """"); static voidUnixDynListSymbols(const char* lib, const char* re = """"); static intUnixDynLoad(const char* lib); static voidUnixDynUnload(const char* lib); static intUnixFilestat(const char* path, FileStat_t& buf); static intUnixFSstat(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); static const char*UnixGetdirentry(void* dir); static const char*UnixHomedirectory(const char* user = 0); static voidUnixIgnoreSignal(ESignals sig, Bool_t ignore); static intUnixMakedir(const char* name); static Long64_tUnixNow(); static void*UnixOpendir(const char* name); static intUnixRecv(int sock, void* buf, int len, int flag); static voidUnixResetSignal(ESignals sig); static voidUnixResetSignals(); static intUnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); static intUnixSend(int sock, const void* buf, int len, int flag); static intUnixSetitimer(Long_t ms); static voidUnixSigAlarmInterruptsSyscalls(Bool_t set); static voidUnixSignal(ESignals sig, void* h); static const char*UnixSigname(ESignals sig); static intUnixTcpConnect(const char* hostname, int port, int tcpwindowsize); static intUnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize); static intUnixUnixConnect(int port); static intUnixUnixConnect(const char* path); static intUnixUnixService(int port, int backlog); static intUnixUnixService(const char* sockpath, int backlog); static intUnixWaitchild().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:15680,timeout,timeout,15680,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,2,['timeout'],['timeout']
Safety,"Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t RadiusHypeSq(Double_t z, Bool_t inner) const; Compute r^2 = x^2 + y^2 at a given z coordinate, for either inner or outer hyperbolas. Double_t ZHypeSq(Double_t r, Bool_t inner) const; Compute z^2 at a given r^2, for either inner or outer hyperbolas. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyToHype(const Double_t* point, Bool_t inner, Bool_t in) const; Compute an underestimate of the closest distance from a point to inner or; outer infinite hyperbolas. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetHypeDimensions(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Set dimensions of the hyperboloid. void SetDimensions(Double_t* param); Set dimensions of the hyperboloid starting from an array.; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. void SetPoints(Double_t* points) const; create tube mesh points. void SetPoints(Float_t* points) const; create tube mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHype.html:17814,Safe,SafetyToHype,17814,root/html534/TGeoHype.html,https://root.cern,https://root.cern/root/html534/TGeoHype.html,3,['Safe'],['SafetyToHype']
Safety,"Pick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualProofPlayer(); { }. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). Long64_t Finalize(TQueryResult* qr). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). void HandleGetTreeHeader(TMessage* mess). void HandleRecvHisto(TMessage* mess). void StopProcess(Bool_t abort, Int_t timeout = -1). void AddInput(TObject* inp). void ClearInput(). TObject * GetOutput(const char* name) const. TList * GetOutputList() const. TList * GetInputList() const. TList * GetListOfResults() const. void AddQueryResult(TQueryResult* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualProofPlayer.html:12395,abort,abort,12395,root/html528/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html528/TVirtualProofPlayer.html,6,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"Picture(""cut-disable_t.xpm""));; 2268 }; 2269 }; 2270 if (*itemType & kLTPackType) {; 2271 fScanMode = true;; 2272 ExecuteDraw();; 2273 }; 2274 }; 2275 }; 2276 break;; 2277 case kButton2:; 2278 break;; 2279 case kButton3:; 2280 break;; 2281 default:; 2282 break;; 2283 }; 2284 break;; 2285 case 4:; 2286// std::cout << ""Dragging Item"" << std::endl;; 2287 default:; 2288 break;; 2289 }; 2290 break;; 2291 default:; 2292 break;; 2293 }; 2294 return true;; 2295}; 2296 ; 2297////////////////////////////////////////////////////////////////////////////////; 2298/// Close the viewer.; 2299 ; 2300void TTreeViewer::CloseWindow(); 2301{; 2302 DeleteWindow();; 2303}; 2304 ; 2305////////////////////////////////////////////////////////////////////////////////; 2306/// Execute all user commands.; 2307 ; 2308void TTreeViewer::ExecuteCommand(const char* command, bool fast); 2309{; 2310 // Execute the command, write it to history file and echo it to output; 2311 if (fBarRec->GetState() == kButtonDown) {; 2312 // show the command on the command line; 2313 //printf(""%s\n"", command);; 2314 char comm[2000];; 2315 comm[0] = 0;; 2316 if (strlen(command) > 1999) {; 2317 Warning(""ExecuteCommand"", ""Command too long: aborting."");; 2318 return;; 2319 }; 2320 snprintf(comm,2000, ""%s"", command);; 2321 // print the command to history file; 2322 Gl_histadd(comm);; 2323 }; 2324 // execute it; 2325 if (fast) {; 2326 gROOT->ProcessLineFast(command);; 2327 } else {; 2328 gROOT->ProcessLine(command);; 2329 }; 2330 // make sure that 'draw on double-click' flag is reset; 2331 fVarDraw = false;; 2332}; 2333 ; 2334////////////////////////////////////////////////////////////////////////////////; 2335/// Scan the selected options from option menu.; 2336 ; 2337void TTreeViewer::MapOptions(Long_t parm1); 2338{; 2339 Int_t ind;; 2340 if (parm1 == kOptionsReset) {; 2341 for (ind=kOptionsGeneral; ind<kOptionsGeneral+16; ind++); 2342 fOptionsGen->UnCheckEntry(ind);; 2343 for (ind=kOptions1D; ind<kOptions1D+12; ind++); 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:81616,abort,aborting,81616,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['abort'],['aborting']
Safety,"Player. â—†Â SetDrawFeedbackOption(). virtual void TVirtualProofPlayer::SetDrawFeedbackOption ; (; TDrawFeedback *Â ; f, . Option_t *Â ; optÂ . ). pure virtual . Implemented in TProofPlayer. â—†Â SetExitStatus(). virtual void TVirtualProofPlayer::SetExitStatus ; (; EExitStatusÂ ; ). pure virtual . Implemented in TProofPlayer. â—†Â SetInitTime(). virtual void TVirtualProofPlayer::SetInitTime ; (; ). pure virtual . Implemented in TProofPlayer, and TProofPlayerRemote. â—†Â SetMaxDrawQueries(). virtual void TVirtualProofPlayer::SetMaxDrawQueries ; (; Int_tÂ ; max). pure virtual . Implemented in TProofPlayer. â—†Â SetMerging(). virtual void TVirtualProofPlayer::SetMerging ; (; Bool_tÂ ; on = kTRUE). pure virtual . Implemented in TProofPlayerRemote, and TProofPlayer. â—†Â SetOutputFilePath(). virtual void TVirtualProofPlayer::SetOutputFilePath ; (; const char *Â ; fp). pure virtual . Implemented in TProofPlayer. â—†Â SetStopTimer(). virtual void TVirtualProofPlayer::SetStopTimer ; (; Bool_tÂ ; on = kTRUE, . Bool_tÂ ; abort = kFALSE, . Int_tÂ ; timeout = 0Â . ). pure virtual . Implemented in TProofPlayer. â—†Â StopProcess(). virtual void TVirtualProofPlayer::StopProcess ; (; Bool_tÂ ; abort, . Int_tÂ ; timeout = -1Â . ). pure virtual . Implemented in TProofPlayer, and TProofPlayerRemote. â—†Â StoreFeedback(). virtual void TVirtualProofPlayer::StoreFeedback ; (; TObject *Â ; slave, . TList *Â ; outÂ . ). pure virtual . Implemented in TProofPlayer, TProofPlayerRemote, and TProofPlayerLite. â—†Â StoreOutput(). virtual void TVirtualProofPlayer::StoreOutput ; (; TList *Â ; out). pure virtual . Implemented in TProofPlayer, and TProofPlayerRemote. â—†Â Streamer(). void TVirtualProofPlayer::Streamer ; (; TBuffer &Â ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. â—†Â StreamerNVirtual(). void TVirtualProofPlayer::StreamerNVirtual ; (; TBuffer &Â ; ClassDef_StreamerNVirtual_b). inline . Definition at line 142 of file TVirtualProofPlayer.h. â—†Â UpdateAutoBin(). virtual void TVirtualProofPlayer::Upd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualProofPlayer.html:29199,abort,abort,29199,doc/master/classTVirtualProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTVirtualProofPlayer.html,1,['abort'],['abort']
Safety,"PositionVector3D<T, U>(pxyz.X(), pxyz.Y(), pxyz.Z());; 203 }; 204 ; 205 // ------------------- Equality -----------------; 206 ; 207 /**; 208 Exact equality; 209 */; 210 bool operator==(const Plane3D &rhs) const { return (fA == rhs.fA && fB == rhs.fB && fC == rhs.fC && fD == rhs.fD); }; 211 bool operator!=(const Plane3D &rhs) const { return !(operator==(rhs)); }; 212 ; 213protected:; 214 /**; 215 Normalize the normal (a,b,c) plane components; 216 */; 217 template <typename SCALAR = T, typename std::enable_if<std::is_arithmetic<SCALAR>::value>::type * = nullptr>; 218 void Normalize(); 219 {; 220 // normalize the plane; 221 using std::sqrt;; 222 const SCALAR s = sqrt(fA * fA + fB * fB + fC * fC);; 223 // what to do if s = 0 ?; 224 if (s == SCALAR(0)) {; 225 fD = SCALAR(0);; 226 } else {; 227 const SCALAR w = Scalar(1) / s;; 228 fA *= w;; 229 fB *= w;; 230 fC *= w;; 231 fD *= w;; 232 }; 233 }; 234 ; 235 /**; 236 Normalize the normal (a,b,c) plane components; 237 */; 238 template <typename SCALAR = T, typename std::enable_if<!std::is_arithmetic<SCALAR>::value>::type * = nullptr>; 239 void Normalize(); 240 {; 241 // normalize the plane; 242 using std::sqrt;; 243 SCALAR s = sqrt(fA * fA + fB * fB + fC * fC);; 244 // what to do if s = 0 ?; 245 const auto m = (s == SCALAR(0));; 246 // set zero entries to 1 in the vector to avoid /0 later on; 247 s(m) = SCALAR(1);; 248 fD(m) = SCALAR(0);; 249 const SCALAR w = SCALAR(1) / s;; 250 fA *= w;; 251 fB *= w;; 252 fC *= w;; 253 fD *= w;; 254 }; 255 ; 256private:; 257 // internal method to construct class from a vector and a point; 258 void BuildFromVecAndPoint(const Vector &n, const Point &p); 259 {; 260 // build from a normal vector and a point; 261 fA = n.X();; 262 fB = n.Y();; 263 fC = n.Z();; 264 fD = -n.Dot(p);; 265 Normalize();; 266 }; 267 ; 268 // internal method to construct class from 3 points; 269 void BuildFrom3Points(const Point &p1, const Point &p2, const Point &p3); 270 {; 271 // plane from three points; 272 // normal ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2Plane3D_8h_source.html:8685,avoid,avoid,8685,doc/master/GenVector_2Plane3D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2Plane3D_8h_source.html,1,['avoid'],['avoid']
Safety,"Print = (1ULL << ( 10 )); , kRemoveFriend = (1ULL << ( 11 )); , ; Â Â kSetBranchStatus = (1ULL << ( 12 )). }; Â ; Â Protected Types inherited from TObject; enum Â { kOnlyPrepStep = (1ULL << ( 3 )); }; Â ; Â Protected Member Functions inherited from TChain; voidÂ InvalidateCurrentTree (); Â Set the TTree to be reloaded as soon as possible. ; Â ; voidÂ ReleaseChainProof (); Â ; Â Protected Member Functions inherited from TTree; virtual TBranch *Â BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel); Â Same as TTree::Branch() with added check that addobj matches className. ; Â ; virtual TBranch *Â BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel); Â Same as TTree::Branch but automatic detection of the class name. ; Â ; virtual TBranch *Â BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel); Â ; virtual TBranch *Â BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel); Â Same as TTree::Branch but automatic detection of the class name. ; Â ; virtual TBranch *Â BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel); Â Same as TTree::Branch but automatic detection of the class name. ; Â ; virtual TBranch *Â BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel); Â Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ; Â ; virtual Int_tÂ CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr); Â Check whether or not the address described by the last 3 parameters matches the content of the branch. ; Â ; Long64_tÂ GetCacheAutoSize (bool withDefault=false); Â Used for automatic sizing of the cache. ; Â ; virtual TLeaf *Â GetLeafImpl (const char *branchname, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofChain.html:51860,detect,detection,51860,doc/master/classTProofChain.html,https://root.cern,https://root.cern/doc/master/classTProofChain.html,1,['detect'],['detection']
Safety,"Print();; 1818 }; 1819 }; 1820#endif; 1821 ; 1822 return (TMath::IsNaN(mvaValue)) ? -999. : mvaValue;; 1823}; 1824////////////////////////////////////////////////////////////////////////////////; 1825/// Evaluate the DeepNet on a vector of input values stored in the TMVA Event class; 1826////////////////////////////////////////////////////////////////////////////////; 1827template <typename Architecture_t>; 1828std::vector<Double_t> MethodDL::PredictDeepNet(Long64_t firstEvt, Long64_t lastEvt, size_t batchSize, Bool_t logProgress); 1829{; 1830 ; 1831 // Check whether the model is setup; 1832 if (!fNet || fNet->GetDepth() == 0) {; 1833 Log() << kFATAL << ""The network has not been trained and fNet is not built""; 1834 << Endl;; 1835 }; 1836 ; 1837 // rebuild the networks; 1838 this->SetBatchSize(batchSize);; 1839 size_t inputDepth = this->GetInputDepth();; 1840 size_t inputHeight = this->GetInputHeight();; 1841 size_t inputWidth = this->GetInputWidth();; 1842 size_t batchDepth = this->GetBatchDepth();; 1843 size_t batchHeight = this->GetBatchHeight();; 1844 size_t batchWidth = this->GetBatchWidth();; 1845 ELossFunction J = fNet->GetLossFunction();; 1846 EInitialization I = fNet->GetInitialization();; 1847 ERegularization R = fNet->GetRegularization();; 1848 Double_t weightDecay = fNet->GetWeightDecay();; 1849 ; 1850 using DeepNet_t = TMVA::DNN::TDeepNet<Architecture_t>;; 1851 using Matrix_t = typename Architecture_t::Matrix_t;; 1852 using TensorDataLoader_t = TTensorDataLoader<TMVAInput_t, Architecture_t>;; 1853 ; 1854 // create the deep neural network; 1855 DeepNet_t deepNet(batchSize, inputDepth, inputHeight, inputWidth, batchDepth, batchHeight, batchWidth, J, I, R, weightDecay);; 1856 std::vector<DeepNet_t> nets{};; 1857 fBuildNet = false;; 1858 CreateDeepNet(deepNet,nets);; 1859 ; 1860 // copy weights from the saved fNet to the built DeepNet; 1861 for (size_t i = 0; i < deepNet.GetDepth(); ++i) {; 1862 deepNet.GetLayerAt(i)->CopyParameters(*fNet->GetLayerAt(i));; 18",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:72709,Predict,PredictDeepNet,72709,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['Predict'],['PredictDeepNet']
Safety,"ProcessÂ ; kAbortFileÂ . Definition at line 34 of file TSelector.h. Constructor & Destructor Documentation. â—†Â TSelector() [1/2]. TSelector::TSelector ; (; const TSelector &Â ; ). private . â—†Â TSelector() [2/2]. TSelector::TSelector ; (; ). Default selector ctor. ; Definition at line 89 of file TSelector.cxx. â—†Â ~TSelector(). TSelector::~TSelector ; (; ). override . Selector destructor. ; Definition at line 102 of file TSelector.cxx. Member Function Documentation. â—†Â Abort(). void TSelector::Abort ; (; const char *Â ; why, . EAbortÂ ; what = kAbortProcessÂ . ). virtual . Abort processing. ; If what = kAbortProcess, the Process() loop will be aborted. If what = kAbortFile, the current file in a chain will be aborted and the processing will continue with the next file, if there is no next file then Process() will be aborted. Abort() can also be called from Begin(), SlaveBegin(), Init() and Notify(). After abort the SlaveTerminate() and Terminate() are always called. The abort flag can be checked in these methods using GetAbort(). ; Definition at line 116 of file TSelector.cxx. â—†Â Begin(). virtual void TSelector::Begin ; (; TTree *Â ; ). inlinevirtual . Reimplemented in TSelEvent, TSelVerifyDataSet, TSelEventGen, TSelHandleDataSet, TProofDraw, h1analysisTreeReader, TProofDrawHist, TProofDrawProfile, TProofDrawProfile2D, TSelHist, TSelectorDraw, TSelectorEntries, and h1analysis.; Definition at line 54 of file TSelector.h. â—†Â Class(). static TClass * TSelector::Class ; (; ). static . ReturnsTClass describing this class . â—†Â Class_Name(). static const char * TSelector::Class_Name ; (; ). static . ReturnsName of this class . â—†Â Class_Version(). static constexpr Version_t TSelector::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 79 of file TSelector.h. â—†Â DeclFileName(). static const char * TSelector::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 79 of file TSelector.h. â—†Â Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelector.html:15839,abort,abort,15839,doc/master/classTSelector.html,https://root.cern,https://root.cern/doc/master/classTSelector.html,1,['abort'],['abort']
Safety,"Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome Â» About Project Founders. Rene Brun ; ; Rene, a lifetime developer of ROOT. He joined CERN in 1973. While working with C. Rubbia at the ISR he developped the HBOOK package still in use today. In 1975 he followed Rubbia in the NA4 deep inelastic muon scattering experiment at the SPS where he was in charge of the simulation and reconstruction software and where GEANT1 and GEANT2 were created. In 1981, he joined OPAL at LEP, creating the GEANT3 detector simulation system, also pioneering the introduction of the first workstations like Apollos in Europe. In 1984 he coordinated the development of the PAW (Physics Analysis Workstation) data analysis system. Until 1994 he was in charge of the Application Software group in the computing division. In 1995, at a time when the majority of software gurus had decided to follow a dead-end line, he created the ROOT system while working for the NA49 heavy ion experiment at the SPS. Rene has led the ROOT project from 1995-2010.; ; . Fons Rademakers ; ; Fons received his Ph.D. in particle physics from the Univ. of Amsterdam in 1991 for his work on event displays and data analysis for the DELPHI experiment at CERN's LEP collider. Since then he has worked at CERN and been involved in designing and developing data analysis programs. In 1991 he joined the PAW project where he developed the column wise-ntuples (a column-oriented storage system) and PIAF, a parallel data analysis system. In 1995, while working as Linux evang",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/project-founders.html:2297,detect,detector,2297,d/project-founders.html,https://root.cern,https://root.cern/d/project-founders.html,1,['detect'],['detector']
Safety,"ProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayer::SetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerLocal(Bool_t client = kTRUE); TProofPlayerLocal(const TProofPlayerLocal&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerLocal.html:11377,abort,abort,11377,root/html604/TProofPlayerLocal.html,https://root.cern,https://root.cern/root/html604/TProofPlayerLocal.html,1,['abort'],['abort']
Safety,"ProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayer::SetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerSlave(TSocket* socket = 0); TProofPlayerSlave(TProofPlayerSlave&&); TProofPlayerSlave(const TProofPlayerSlave&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerSlave.html:11233,abort,abort,11233,root/html604/TProofPlayerSlave.html,https://root.cern,https://root.cern/root/html604/TProofPlayerSlave.html,1,['abort'],['abort']
Safety,"ProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayer::SetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerLocal.html:11477,abort,abort,11477,root/html534/TProofPlayerLocal.html,https://root.cern,https://root.cern/root/html534/TProofPlayerLocal.html,2,['abort'],['abort']
Safety,"PyObject*fPySelf! actual python object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupPySelf(); Install the python side identity of the TPySelector. PyObject* CallSelf(const char* method, PyObject* pyobject = 0); Forward <method> to python. TPySelector(TTree* = 0, PyObject* self = 0); Construct a TSelector derived with <self> as the underlying, which is; generally 0 to start out with in the current PROOF framework. ~TPySelector(); Destructor. Only deref if still holding on to Py_None (circular otherwise). Int_t Version() const; Return version number of this selector. First forward; if not overridden, then; yield an obvious ""undefined"" number,. Int_t GetEntry(Long64_t entry, Int_t getall = 0); Boilerplate get entry; same as for generated code; not forwarded. void Init(TTree* tree); Initialize with the current tree to be used; not forwarded (may be called; multiple times, and is called from Begin() and SlaveBegin() ). Bool_t Notify(); Forward call to derived Notify() if available. void Begin(TTree* tree = 0); First function called, and used to setup the python self; forward call. void SlaveBegin(TTree* tree); First function called on worker node, needs to make sure python self is setup,; then store the tree to be used, initialize client, and forward call. Bool_t Process(Long64_t entry); Actual processing; call is forwarded to python self. void SlaveTerminate(); End of client; call is forwarded to python self. void Terminate(); End of job; call is forwarded to python self. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); If no 'why' given, read from python error. TPySelector(TTree* = 0, PyObject* self = 0); ctor/dtor ... cctor and assignment are private in base class. Â» Last changed: Tue Jun 2 16:31:19 2015 Â» Last generated: 2015-06-02 16:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPySelector.html:10075,Abort,Abort,10075,root/html604/TPySelector.html,https://root.cern,https://root.cern/root/html604/TPySelector.html,1,['Abort'],['Abort']
Safety,"RAA general twisted trapezoid.Definition TGTRA.h:27; THYPEAn hyperboloid (not implemented)Definition THYPE.h:28; TPARAA parallelepiped.Definition TPARA.h:30; TPCONA polycone.Definition TPCON.h:33; TPGONA polygon.Definition TPGON.h:30; TTRAPA general trapezoid.Definition TTRAP.h:33; TTRD1A trapezoid with the x dimension varying along z.Definition TTRD1.h:28; TTRD2A trapezoid with both x and y dimensions varying along z.Definition TTRD2.h:29; TTUBEA tube.Definition TTUBE.h:32; TTUBSA segment of a tube.Definition TTUBS.h:29; The figure below shows instances of all these shapes. This figure is generated by the ROOT 3-D viewer. Definition at line 35 of file TShape.h. Public Member Functions; Â TShape (); Â Shape default constructor. ; Â ; Â TShape (const char *name, const char *title, const char *material); Â Shape normal constructor. ; Â ; Â TShape (const TShape &); Â copy constructor ; Â ; Â ~TShape () override; Â Shape default destructor. ; Â ; virtual const TBuffer3D &Â GetBuffer3D (Int_t reqSections) const; Â Stub to avoid forcing implementation at this stage. ; Â ; TMaterial *Â GetMaterial () const; Â ; virtual Int_tÂ GetNumber () const; Â ; Int_tÂ GetVisibility () const; Â ; TClass *Â IsA () const override; Â ; TShape &Â operator= (const TShape &); Â assignment operator ; Â ; voidÂ Paint (Option_t *option="""") override; Â This method is used only when a shape is painted outside a TNode. ; Â ; voidÂ SetName (const char *name) override; Â Set the name of the TNamed. ; Â ; virtual voidÂ SetPoints (Double_t *points) const; Â Set points. ; Â ; virtual voidÂ SetVisibility (Int_t vis); Â ; voidÂ Streamer (TBuffer &) override; Â Stream an object of class TShape. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; voidÂ TransformPoints (Double_t *points, UInt_t NbPnts) const; Â Transform points (LocalToMaster) ; Â ; Â Public Member Functions inherited from TNamed; Â TNamed (); Â ; Â TNamed (const char *name, const char *title); Â ; Â TNamed (const TNamed &named); Â TNamed copy ctor. ; Â ; Â TNamed (const TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTShape.html:1755,avoid,avoid,1755,doc/master/classTShape.html,https://root.cern,https://root.cern/doc/master/classTShape.html,1,['avoid'],['avoid']
Safety,"RAW);; 891 fDRAW->SetToolTipText(""Draw current selection"");; 892 fDRAW->Associate(this);; 893 ; 894 lo = new TGLayoutHints(kLHintsTop | kLHintsLeft, 2,2,4,2);; 895 fWidgets->Add(lo);; 896 fHpb->AddFrame(fDRAW, lo);; 897 ; 898 //--- SPIDER button; 899 fSPIDER = new TGTextButton(fHpb,""SPIDER"");; 900 fSPIDER->SetToolTipText(""Scan current selection using a spider plot"");; 901 fSPIDER->Associate(this);; 902 ; 903 lo = new TGLayoutHints(kLHintsTop | kLHintsLeft, 2,2,4,2);; 904 fWidgets->Add(lo);; 905 fHpb->AddFrame(fSPIDER,lo);; 906 //---connect SPIDER button to ExecuteScan() method; 907 fSPIDER->Connect(""Clicked()"",""TTreeViewer"",this,""ExecuteSpider()"");; 908 ; 909 //--- STOP button (breaks current operation); 910// fPicStop = gClient->GetPicture(""mb_stop_s.xpm"");; 911 fPicStop = gClient->GetPicture(""stop_t.xpm"");; 912 fSTOP = new TGPictureButton(fHpb,fPicStop,kSTOP);; 913 fSTOP->SetToolTipText(""Abort current operation"");; 914 fSTOP->Associate(this);; 915 ; 916 lo = new TGLayoutHints(kLHintsTop | kLHintsLeft, 2,2,4,2);; 917 fWidgets->Add(lo);; 918 fHpb->AddFrame(fSTOP, lo);; 919 ; 920 //--- REFR button (breaks current operation); 921 fPicRefr = gClient->GetPicture(""refresh2.xpm"");; 922 fREFR = new TGPictureButton(fHpb,fPicRefr,kDRAW);; 923 fREFR->SetToolTipText(""Update the tree viewer"");; 924 lo = new TGLayoutHints(kLHintsTop | kLHintsLeft, 2,2,4,2);; 925 fWidgets->Add(lo);; 926 fHpb->AddFrame(fREFR, lo);; 927 //---connect REFR button to DoRefresh() method; 928 fREFR->Connect(""Clicked()"", ""TTreeViewer"", this, ""DoRefresh()"");; 929 ; 930 lo = new TGLayoutHints(kLHintsTop | kLHintsLeft, 2,2,2,2);; 931 fWidgets->Add(lo);; 932 fV1->AddFrame(fHpb, lo);; 933 ; 934 //--- fV2; 935 fV2 = new TGVerticalFrame(fHf, 10, 10);; 936 fListHdr = new TGCompositeFrame(fV2, 10, 10, kSunkenFrame | kFitHeight);; 937 fLbl2 = new TGLabel(fListHdr, ""Current Tree: "");; 938 lo = new TGLayoutHints(kLHintsTop | kLHintsLeft, 3, 0, 0, 0);; 939 fWidgets->Add(lo);; 940 fListHdr->AddFrame(fLbl2, lo);; 941 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:36105,Abort,Abort,36105,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['Abort'],['Abort']
Safety,"RDFHelpers.cxx. â—†Â SaveGraph() [1/2]. template<typename NodeType > . std::string ROOT::RDF::SaveGraph ; (; NodeTypeÂ ; node). Create a graphviz representation of the dataframe computation graph, return it as a string. ; Parameters. [in]nodeany node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to. The output can be displayed with a command akin to dot -Tpng output.dot > output.png && open output.png.; Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are effectively optimized away from the computation graph.; Note that SaveGraph is not thread-safe and must not be called concurrently from different threads. ; Definition at line 120 of file RDFHelpers.hxx. â—†Â SaveGraph() [2/2]. template<typename NodeType > . void ROOT::RDF::SaveGraph ; (; NodeTypeÂ ; node, . const std::string &Â ; outputFileÂ . ). Create a graphviz representation of the dataframe computation graph, write it to the specified file. ; Parameters. [in]nodeany node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to. ; [in]outputFilefile where to save the representation. The output can be displayed with a command akin to dot -Tpng output.dot > output.png && open output.png.; Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are effectively optimized away from the computation graph.; Note that SaveGraph is not thread-safe and must not be called concurrently from different threads. ; Definition at line 139 of file RDFHelpers.hxx. â—†Â splitInEqualRanges(). void ROOT::RDF::splitInEqualRanges ; (; std::vector< std::pair< ULong64_t, ULong64_t > > &Â ; ranges, . intÂ ; nRecords, . unsigned intÂ ; nSlotsÂ . ). Definition at line 519 of file RArrowDS.cxx. ROOTRDF. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:27 (GVA Time) using Doxygen 1.9.8 Â Â ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1RDF.html:16284,safe,safe,16284,doc/master/namespaceROOT_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1RDF.html,1,['safe'],['safe']
Safety,"REATE; Mapped Memory region: 0x40b4c000 - 0x40d95f00 (2.29 MB); Current breakval: 0x40b53000; root [2] .q; $ rm dummy.map; Remember begin of mapped region, i.e. 0x40b4c000. 2) Add to producer program, just before creating the TMapFile:; TMapFile::SetMapAddress(0x40b4c000);. Repeat this if more than one map file is being used. The above procedure allow programs using, e.g., different number of; shared libraries (that cause the default mapping address to be; different) to create shared memory regions in the same location; without overwriting a shared library. The above assumes the consumer; program is larger (i.e. has more shared memory occupied) than the; producer. If this is not true inverse the procedure. void * MapToAddress(); Return the base address at which we would like the next TMapFile's; mapped data to start. For now, we let the system decide (start address 0). There are; a lot of issues to deal with here to make this work reasonably,; including:. - Avoid memory collisions with existing mapped address spaces. - Reclaim address spaces when their mmalloc heaps are unmapped. - When mmalloc heaps are shared between processes they have to be; mapped at the same addresses in each. Once created, a mmalloc heap that is to be mapped back in must be; mapped at the original address. I.E. each TMapFile will expect; to be remapped at it's original address. This becomes a problem if; the desired address is already in use. void operator delete(void* vp); Need special ""operator delete"" in which we close the shared memory.; This has to be done after the dtor chain has been finished. void * GetBreakval() const. TMapFile * WhichMapFile(void* addr). void operator=(const TMapFile& rhs). TObject * Remove(TObject* obj, Bool_t lock). TObject * Remove(const char* name, Bool_t lock). void * GetBaseAddr() const; { return (void *)fBaseAddr; }. TDirectory * GetDirectory() const; {return fDirectory;}. Int_t GetFd() const; { return fFd; }. void * GetMmallocDesc() const; { return fMmallocDe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMapFile.html:14880,Avoid,Avoid,14880,root/html528/TMapFile.html,https://root.cern,https://root.cern/root/html528/TMapFile.html,6,['Avoid'],['Avoid']
Safety,"REDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TTimer; 13\ingroup Base; 14 ; 15Handles synchronous and a-synchronous timer events.; 161. synchronous timer is registered into TSystem and is processed; 17 within the standard ROOT event-loop.; 182. asynchronous timer is passed to the operating system which sends; 19 an external signal to ROOT and thus interrupts its event-loop.; 20 ; 21You can use this class in one of the following ways:; 22 - Sub-class TTimer and override the Notify() method.; 23 - Re-implement the TObject::HandleTimer() method in your class; 24 and pass a pointer to this object to timer, see the SetObject(); 25 method.; 26 - Pass an interpreter command to timer, see SetCommand() method.; 27 - Create a TTimer, connect its Timeout() signal to the; 28 appropriate methods. Then when the time is up it will emit a; 29 Timeout() signal and call connected slots.; 30 ; 31Minimum timeout interval is defined in TSystem::ESysConstants as; 32`kItimerResolution` (currently 10 ms).; 33 ; 34Signal/slots example:; 35~~~{.cpp}; 36 TTimer *timer = new TTimer();; 37 timer->Connect(""Timeout()"", ""myObjectClassName"",; 38 myObject, ""TimerDone()"");; 39 timer->Start(2000, kTRUE); // 2 seconds single-shot; 40~~~; 41To emit the Timeout signal repeatedly with minimum timeout:; 42~~~ {.cpp}; 43 timer->Start(0, kFALSE);; 44~~~; 45*/; 46 ; 47#include ""TTimer.h""; 48#include ""TSystem.h""; 49#include ""TROOT.h""; 50 ; 51ClassImp(TTimer);; 52 ; 53 ; 54class TSingleShotCleaner : public TTimer {; 55private:; 56 TList *fGarbage;; 57public:; 58 TSingleShotCleaner() : TTimer(10, kTRUE) { fGarbage = new TList(); }; 59 virtual ~TSingleShotCleaner() { fGarbage->Delete(); delete fGarbage; }; 60 void TurnOn() override; 61 {; 62 TObject *obj = (TObject *)gTQSender;; 63 fGarbage->Add(obj);; 64 Reset();; 65 if (gSystem); 66 gSystem->AddTimer(this);; 67 }; 68 Bool_t Notify() override; 69 {; 70 fGarbage->Delete();; 71 Reset();; 72 if (gSystem);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8cxx_source.html:1485,timeout,timeout,1485,doc/master/TTimer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html,1,['timeout'],['timeout']
Safety,"ROOT to R. ; TRFunctionImport class; The TRFunctionImport class lets you call R's functions to ROOT's environment; The object associated to this class have a set of overloaded operators to use the object like function. #include<TRInterface.h>; ; using namespace ROOT::R;; void Function(); {; TRInterface &r = TRInterface::Instance();; r.SetVerbose(1);; ////////////////////////////////////////; //defining functions to be used from R//; ////////////////////////////////////////; TRFunctionImport c(""c"");; TRFunctionImport list(""list"");; TRFunctionImport asformula(""as.formula"");; TRFunctionImport nls(""nls"");; TRFunctionImport confint(""confint"");; TRFunctionImport summary(""summary"");; TRFunctionImport print(""print"");; TRFunctionImport plot(""plot"");; TRFunctionImport lines(""lines"");; TRFunctionImport devnew(""dev.new"");; TRFunctionImport devoff(""dev.off"");; TRFunctionImport min(""min"");; TRFunctionImport max(""max"");; TRFunctionImport seq(""seq"");; TRFunctionImport predict(""predict"");; ; r<<""options(device='png')"";//enable plot in png file; ; ////////////////////////; //doing the procedure //; ////////////////////////; TRObject xdata = c(-2,-1.64,-1.33,-0.7,0,0.45,1.2,1.64,2.32,2.9);; TRObject ydata = c(0.699369,0.700462,0.695354,1.03905,1.97389,2.41143,1.91091,0.919576,-0.730975,-1.42001);; ; TRDataFrame data;; data[""xdata""]=xdata;; data[""ydata""]=ydata;; ; //fit = nls(ydata ~ p1*cos(p2*xdata) + p2*sin(p1*xdata), start=list(p1=1,p2=0.2)) <- R code; TRObject fit = nls(asformula(""ydata ~ p1*cos(p2*xdata) + p2*sin(p1*xdata)""),Label[""data""]=data, Label[""start""]=list(Label[""p1""]=1,Label[""p2""]=0.2));; print(summary(fit));; ; print(confint(fit));; ; devnew(""Fitting Regression"");; plot(xdata,ydata);; ; TRObject xgrid=seq(min(xdata),max(xdata),Label[""len""]=10);; lines(xgrid,predict(fit,xgrid),Label[""col""] = ""green"");; devoff();; }; c#define c(i)Definition RSha256.hxx:101; plotwinID h TVirtualViewer3D TVirtualGLPainter char TVirtualGLPainter plotDefinition TGWin32VirtualGLProxy.cxx:53; dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1R_1_1TRFunctionImport.html:1391,predict,predict,1391,doc/master/classROOT_1_1R_1_1TRFunctionImport.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1R_1_1TRFunctionImport.html,2,['predict'],['predict']
Safety,"ROOT Â ; . master. Reference Guide ; . Â . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TTimer Class ReferenceCore ROOT classes Â» Base ROOT classes. ; Handles synchronous and a-synchronous timer events. . synchronous timer is registered into TSystem and is processed within the standard ROOT event-loop.; asynchronous timer is passed to the operating system which sends an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; Sub-class TTimer and override the Notify() method.; Re-implement the TObject::HandleTimer() method in your class and pass a pointer to this object to timer, see the SetObject() method.; Pass an interpreter command to timer, see SetCommand() method.; Create a TTimer, connect its Timeout() signal to the appropriate methods. Then when the time is up it will emit a Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as kItimerResolution (currently 10 ms).; Signal/slots example: TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::Startvirtual void Start(Long_t milliSec=-1, Bool_t singleShot=kFALSE)Starts the timer with a milliSec timeout.Definition TTimer.cxx:213; To emit the Timeout signal repeatedly with minimum timeout: timer->Start(0, kFALSE);; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94. Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTimer.html:1034,Timeout,Timeout,1034,doc/master/classTTimer.html,https://root.cern,https://root.cern/doc/master/classTTimer.html,1,['Timeout'],['Timeout']
Safety,"ROOT_TImplicitMT_IsParBranchProcessingEnabled"");; 451 if (sym); 452 return sym();; 453 else; 454 return kFALSE;; 455#else; 456 return kFALSE;; 457#endif; 458 }; 459 ; 460 ////////////////////////////////////////////////////////////////////////////////; 461 /// Keeps track of the status of ImplicitMT w/o resorting to the load of; 462 /// libImt; 463 static Bool_t &IsImplicitMTEnabledImpl(); 464 {; 465 static Bool_t isImplicitMTEnabled = kFALSE;; 466 return isImplicitMTEnabled;; 467 }; 468 ; 469} // end of Internal sub namespace; 470// back to ROOT namespace; 471 ; 472 TROOT *GetROOT() {; 473 return (*Internal::gGetROOT)();; 474 }; 475 ; 476 TString &GetMacroPath() {; 477 static TString macroPath;; 478 return macroPath;; 479 }; 480 ; 481 // clang-format off; 482 ////////////////////////////////////////////////////////////////////////////////; 483 /// Enables the global mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different thread",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:16908,safe,safe,16908,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['safe'],['safe']
Safety,"RPRETER@ CGI2_INTERPRETERDefinition civetweb.c:1960; INDEX_FILES@ INDEX_FILESDefinition civetweb.c:1991; EXTRA_MIME_TYPES@ EXTRA_MIME_TYPESDefinition civetweb.c:1993; initialize_opensslstatic int initialize_openssl(char *ebuf, size_t ebuf_len)Definition civetweb.c:16034; substitute_index_filestatic int substitute_index_file(struct mg_connection *conn, char *path, size_t path_len, struct mg_file_stat *filestat)Definition civetweb.c:7389; mg_stopvoid mg_stop(struct mg_context *ctx)Definition civetweb.c:19493; STRUCT_FILE_INITIALIZER#define STRUCT_FILE_INITIALIZERDefinition civetweb.c:1882; thread_idx_maxstatic volatile ptrdiff_t thread_idx_maxDefinition civetweb.c:1573; mg_get_user_datavoid * mg_get_user_data(const struct mg_context *ctx)Definition civetweb.c:3159; scan_directorystatic int scan_directory(struct mg_connection *conn, const char *dir, void *data, int(*cb)(struct de *, void *))Definition civetweb.c:9449; push_innerstatic int push_inner(struct mg_context *ctx, FILE *fp, SOCKET sock, SSL *ssl, const char *buf, int len, double timeout)Definition civetweb.c:5970; mg_versionconst char * mg_version(void)Definition civetweb.c:3480; get_randomstatic uint64_t get_random(void)Definition civetweb.c:5879; mg_lock_connectionvoid mg_lock_connection(struct mg_connection *conn)Definition civetweb.c:12306; mg_send_file_bodyint mg_send_file_body(struct mg_connection *conn, const char *path)Definition civetweb.c:10146; mg_cry#define mg_cryDefinition civetweb.c:3476; is_valid_http_methodstatic int is_valid_http_method(const char *method)Definition civetweb.c:10589; url_decode_in_placestatic void url_decode_in_place(char *buf)Definition civetweb.c:6982; civetweb.h; mg_websocket_client_writeint mg_websocket_client_write(struct mg_connection *conn, int opcode, const char *data, size_t data_len); MG_MAX_HEADERS#define MG_MAX_HEADERSDefinition civetweb.h:141; mg_response_header_addint mg_response_header_add(struct mg_connection *conn, const char *header, const char *value, int va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:689655,timeout,timeout,689655,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"RPRETER@ CGI2_INTERPRETERDefinition civetweb.c:1961; INDEX_FILES@ INDEX_FILESDefinition civetweb.c:1992; EXTRA_MIME_TYPES@ EXTRA_MIME_TYPESDefinition civetweb.c:1994; initialize_opensslstatic int initialize_openssl(char *ebuf, size_t ebuf_len)Definition civetweb.c:16035; substitute_index_filestatic int substitute_index_file(struct mg_connection *conn, char *path, size_t path_len, struct mg_file_stat *filestat)Definition civetweb.c:7390; mg_stopvoid mg_stop(struct mg_context *ctx)Definition civetweb.c:19494; STRUCT_FILE_INITIALIZER#define STRUCT_FILE_INITIALIZERDefinition civetweb.c:1883; thread_idx_maxstatic volatile ptrdiff_t thread_idx_maxDefinition civetweb.c:1573; mg_get_user_datavoid * mg_get_user_data(const struct mg_context *ctx)Definition civetweb.c:3160; scan_directorystatic int scan_directory(struct mg_connection *conn, const char *dir, void *data, int(*cb)(struct de *, void *))Definition civetweb.c:9450; push_innerstatic int push_inner(struct mg_context *ctx, FILE *fp, SOCKET sock, SSL *ssl, const char *buf, int len, double timeout)Definition civetweb.c:5971; mg_versionconst char * mg_version(void)Definition civetweb.c:3481; get_randomstatic uint64_t get_random(void)Definition civetweb.c:5880; mg_lock_connectionvoid mg_lock_connection(struct mg_connection *conn)Definition civetweb.c:12307; mg_send_file_bodyint mg_send_file_body(struct mg_connection *conn, const char *path)Definition civetweb.c:10147; mg_cry#define mg_cryDefinition civetweb.c:3477; is_valid_http_methodstatic int is_valid_http_method(const char *method)Definition civetweb.c:10590; url_decode_in_placestatic void url_decode_in_place(char *buf)Definition civetweb.c:6983; civetweb.h; mg_websocket_client_writeint mg_websocket_client_write(struct mg_connection *conn, int opcode, const char *data, size_t data_len); MG_MAX_HEADERS#define MG_MAX_HEADERSDefinition civetweb.h:141; mg_response_header_addint mg_response_header_add(struct mg_connection *conn, const char *header, const char *value, int va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:689688,timeout,timeout,689688,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"RUE in case object contains browsable objects (like containers or lists of other objects). ; Â ; Bool_tÂ IsOwner () const; Â ; Bool_tÂ IsSortable () const override; Â ; R__ALWAYS_INLINE Bool_tÂ IsUsingRWLock () const; Â ; virtual TIterator *Â MakeReverseIterator () const; Â ; Bool_tÂ Notify () override; Â 'Notify' all objects in this collection. ; Â ; TObject *Â operator() (const char *name) const; Â Find an object in this collection by name. ; Â ; voidÂ Paint (Option_t *option="""") override; Â Paint all objects in this collection. ; Â ; voidÂ RemoveAll (); Â ; virtual voidÂ RemoveAll (TCollection *col); Â Remove all objects in collection col from this collection. ; Â ; voidÂ SetCurrentCollection (); Â Set this collection to be the globally accessible collection. ; Â ; voidÂ SetName (const char *name); Â ; virtual voidÂ SetOwner (Bool_t enable=kTRUE); Â Set whether this collection is the owner (enable==true) of its content. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; virtual boolÂ UseRWLock (Bool_t enable=true); Â Set this collection to use a RW lock upon access, making it thread safe. ; Â ; Int_tÂ Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override; Â Write all objects in this collection. ; Â ; Int_tÂ Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override; Â Write all objects in this collection. ; Â ; Â Public Member Functions inherited from TObject; Â TObject (); Â TObject constructor. ; Â ; Â TObject (const TObject &object); Â TObject copy ctor. ; Â ; virtualÂ ~TObject (); Â TObject destructor. ; Â ; voidÂ AbstractMethod (const char *method) const; Â Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ; Â ; virtual voidÂ AppendPad (Option_t *option=""""); Â Append graphics object to current pad. ; Â ; ULong_tÂ CheckedHash (); Â Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ; Â ; virtual const char *Â ClassName () co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofOutputList.html:8154,safe,safe,8154,doc/master/classTProofOutputList.html,https://root.cern,https://root.cern/doc/master/classTProofOutputList.html,1,['safe'],['safe']
Safety,"R__EXTERN TSystem * gSystemDefinition TSystem.h:561; kS_IXOTH@ kS_IXOTHDefinition TSystem.h:110; kS_IXUSR@ kS_IXUSRDefinition TSystem.h:102; kS_IXGRP@ kS_IXGRPDefinition TSystem.h:106; TUrl.h; TVersionCheck.h; TVirtualMutex.h; R__LOCKGUARD2#define R__LOCKGUARD2(mutex)Definition TVirtualMutex.h:96; R__WRITE_LOCKGUARD#define R__WRITE_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:157; R__READ_LOCKGUARD#define R__READ_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:154; ThreadLocalStorage.h; Windows4Root.h; protoconst char * protoDefinition civetweb.c:17535; extensionconst char * extensionDefinition civetweb.c:8025; snprintf#define snprintfDefinition civetweb.c:1540; TApplication::StopIdleingvirtual void StopIdleing()Called when system stops idleing.Definition TApplication.cxx:1907; TApplication::StartIdleingvirtual void StartIdleing()Called when system starts idleing.Definition TApplication.cxx:1896; TCollection::Removevirtual TObject * Remove(TObject *obj)=0; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TCollection.cxx:312; TCollection::Deletevoid Delete(Option_t *option="""") override=0Delete this object.; TEnvRecDefinition TEnv.h:86; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TEnv::GetTableTHashList * GetTable() constDefinition TEnv.h:140; TFileHandlerDefinition TSysEvtHandler.h:65; TInetAddressThis class represents an Internet Protocol (IP) address.Definition TInetAddress.h:36; TIterDefinition TCollection.h:235; TListIterIterator of linked list.Definition TList.h:193; TListIter::NextTObject * Next() overrideReturn next object in the list. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:159471,safe,safe,159471,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['safe'],['safe']
Safety,"Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TStreamerInfo.h""; 13#include ""TStreamerInfoActions.h""; 14#include ""TROOT.h""; 15#include ""TStreamerElement.h""; 16#include ""TVirtualMutex.h""; 17#include ""TInterpreter.h""; 18#include ""TError.h""; 19#include ""TVirtualArray.h""; 20#include ""TBufferFile.h""; 21#include ""TBufferText.h""; 22#include ""TMemberStreamer.h""; 23#include ""TClassEdit.h""; 24#include ""TVirtualCollectionIterators.h""; 25#include ""TProcessID.h""; 26#include ""TFile.h""; 27 ; 28static const Int_t kRegrouped = TStreamerInfo::kOffsetL;; 29 ; 30// More possible optimizations:; 31// Avoid call the virtual version of TBuffer::ReadInt and co.; 32// Merge the Reading of the version and the looking up or the StreamerInfo; 33// Avoid if (bytecnt) inside the CheckByteCount routines and avoid multiple (mostly useless nested calls); 34// Try to avoid if statement on onfile class being set (TBufferFile::ReadClassBuffer).; 35 ; 36using namespace TStreamerInfoActions;; 37 ; 38#ifdef _AIX; 39# define INLINE_TEMPLATE_ARGS; 40#else; 41# define INLINE_TEMPLATE_ARGS inline; 42#endif; 43 ; 44 ; 45namespace TStreamerInfoActions; 46{; 47 bool IsDefaultVector(TVirtualCollectionProxy &proxy); 48 {; 49 const auto props = proxy.GetProperties();; 50 const bool isVector = proxy.GetCollectionType() == ROOT::kSTLvector;; 51 const bool hasDefaultAlloc = !(props & TVirtualCollectionProxy::kCustomAlloc);; 52 const bool isEmulated = props & TVirtualCollectionProxy::kIsEmulated;; 53 ; 54 return isEmulated || (isVector && hasDefaultAlloc);; 55 }; 56 ; 57 template <typename From>; 58 struct WithFactorMarker {; 59 typedef From Value_t;; 60 };; 61 ; 62 template <typename From>; 63 struct NoFactorMarker {; 64 typedef From Value_t;; 65 };; 66 ; 67 struct BitsMarker {; 68 typedef UInt_t Value_t;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:1335,Avoid,Avoid,1335,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,3,"['Avoid', 'avoid']","['Avoid', 'avoid']"
Safety,"Range in x = [ "" << xmin << "" , "" << xmax << "" ]"" << std::endl;; 589#endif; 590 ; 591 TList * funcList = h1->GetListOfFunctions();; 592 if (funcList == nullptr){; 593 Error(""StoreAndDrawFitFunction"",""Function list has not been created - cannot store the fitted function"");; 594 return;; 595 }; 596 ; 597 // delete the function in the list only if; 598 // the function we are fitting is not in that list; 599 // If this is the case we re-use that function object and; 600 // we do not create a new one (if delOldFunction is true); 601 bool reuseOldFunction = false;; 602 if (delOldFunction) {; 603 TIter next(funcList, kIterBackward);; 604 TObject *obj;; 605 while ((obj = next())) {; 606 if (obj->InheritsFrom(TF1::Class())) {; 607 if (obj != f1) {; 608 funcList->Remove(obj);; 609 delete obj;; 610 }; 611 else {; 612 reuseOldFunction = true;; 613 }; 614 }; 615 }; 616 }; 617 ; 618 TF1 *fnew1 = nullptr;; 619 TF2 *fnew2 = nullptr;; 620 TF3 *fnew3 = nullptr;; 621 ; 622 // copy TF1 using TClass to avoid slicing in case of derived classes; 623 if (ndim < 2) {; 624 if (!reuseOldFunction) {; 625 fnew1 = (TF1*)f1->IsA()->New();; 626 R__ASSERT(fnew1);; 627 f1->Copy(*fnew1);; 628 funcList->Add(fnew1);; 629 }; 630 else {; 631 fnew1 = f1;; 632 }; 633 fnew1->SetParent( h1 );; 634 fnew1->SetRange(xmin,xmax);; 635 fnew1->Save(xmin,xmax,0,0,0,0);; 636 if (!drawFunction) fnew1->SetBit(TF1::kNotDraw);; 637 fnew1->AddToGlobalList(false);; 638 } else if (ndim < 3) {; 639 if (!reuseOldFunction) {; 640 fnew2 = (TF2*)f1->IsA()->New();; 641 R__ASSERT(fnew2);; 642 f1->Copy(*fnew2);; 643 funcList->Add(fnew2);; 644 }; 645 else {; 646 fnew2 = dynamic_cast<TF2*>(f1);; 647 R__ASSERT(fnew2);; 648 }; 649 fnew2->SetRange(xmin,ymin,xmax,ymax);; 650 fnew2->SetParent( h1 );; 651 fnew2->Save(xmin,xmax,ymin,ymax,0,0);; 652 if (!drawFunction) fnew2->SetBit(TF1::kNotDraw);; 653 fnew2->AddToGlobalList(false);; 654 } else {; 655 if (!reuseOldFunction) {; 656 fnew3 = (TF3*)f1->IsA()->New();; 657 R__ASSERT(fnew3);; 658 f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitImpl_8cxx_source.html:23207,avoid,avoid,23207,doc/master/HFitImpl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitImpl_8cxx_source.html,1,['avoid'],['avoid']
Safety,"Raw(int sock, void* buffer, int length, int flag); virtual Int_tTSystem::RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*TSystem::RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*TSystem::RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*TSystem::RemoveTimer(TTimer* t); virtual intTSystem::Rename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidTSystem::ResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidTSystem::ResetSignals(); virtual voidTSystem::ResetTimer(TTimer*); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetSystem.html:13559,timeout,timeout,13559,root/html534/TNetSystem.html,https://root.cern,https://root.cern/root/html534/TNetSystem.html,12,['timeout'],['timeout']
Safety,"ReadStreamerInfo(). void TFile::ReadStreamerInfo ; (; ). virtual . Read the list of StreamerInfo from this file. ; The key with name holding the list of TStreamerInfo objects is read. The corresponding TClass objects are updated. Note that this function is not called if the static member fgReadInfo is false. (see TFile::SetReadStreamerInfo) ; Definition at line 3605 of file TFile.cxx. â—†Â Recover(). Int_t TFile::Recover ; (; ). virtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2048 of file TFile.cxx. â—†Â ReOpen(). Int_t TFile::ReOpen ; (; Option_t *Â ; mode). virtual . Reope",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:89291,recover,recovered,89291,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,4,"['recover', 'safe']","['recovered', 'safely']"
Safety,"RebinY(2);; 629 ; 630 Double_t corrRatio = 0.;; 631 Double_t y_mean = h.ProjectionY()->GetMean();; 632 for (Int_t ix=1; ix<=h.GetNbinsX(); ix++) {; 633 corrRatio += (h.Integral(ix,ix,1,h.GetNbinsY())/hi)*pow((GetYMean_binX(h,ix)-y_mean),2);; 634 }; 635 corrRatio /= pow(h.ProjectionY()->GetRMS(),2);; 636 return corrRatio;; 637}; 638 ; 639////////////////////////////////////////////////////////////////////////////////; 640/// Compute the mean in Y for a given bin X of a 2D histogram; 641 ; 642Double_t TMVA::Tools::GetYMean_binX( const TH2& h, Int_t bin_x ); 643{; 644 if (h.Integral(bin_x,bin_x,1,h.GetNbinsY()) == 0.) {return 0;}; 645 Double_t y_bin_mean = 0.;; 646 TH1* py = h.ProjectionY();; 647 for (Int_t y = 1; y <= h.GetNbinsY(); y++){; 648 y_bin_mean += h.GetBinContent(bin_x,y)*py->GetBinCenter(y);; 649 }; 650 y_bin_mean /= h.Integral(bin_x,bin_x,1,h.GetNbinsY());; 651 return y_bin_mean;; 652}; 653 ; 654////////////////////////////////////////////////////////////////////////////////; 655/// Transpose quadratic histogram; 656 ; 657TH2F* TMVA::Tools::TransposeHist( const TH2F& h ); 658{; 659 // sanity check; 660 if (h.GetNbinsX() != h.GetNbinsY()) {; 661 Log() << kFATAL << ""<TransposeHist> cannot transpose non-quadratic histogram"" << Endl;; 662 }; 663 ; 664 TH2F *transposedHisto = new TH2F( h );; 665 for (Int_t ix=1; ix <= h.GetNbinsX(); ix++){; 666 for (Int_t iy=1; iy <= h.GetNbinsY(); iy++){; 667 transposedHisto->SetBinContent(iy,ix,h.GetBinContent(ix,iy));; 668 }; 669 }; 670 ; 671 // copy stats (thanks to Swagato Banerjee for pointing out the missing stats information); 672 Double_t stats_old[7];; 673 Double_t stats_new[7];; 674 ; 675 h.GetStats(stats_old);; 676 stats_new[0] = stats_old[0];; 677 stats_new[1] = stats_old[1];; 678 stats_new[2] = stats_old[4];; 679 stats_new[3] = stats_old[5];; 680 stats_new[4] = stats_old[2];; 681 stats_new[5] = stats_old[3];; 682 stats_new[6] = stats_old[6];; 683 transposedHisto->PutStats(stats_new);; 684 ; 685 return transposedHis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:22845,sanity check,sanity check,22845,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['sanity check'],['sanity check']
Safety,"Reimplemented from TGeoShape.; Definition at line 249 of file TGeoScaledShape.cxx. â—†Â IsCylType(). Bool_t TGeoScaledShape::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 59 of file TGeoScaledShape.h. â—†Â IsReflected(). Bool_t TGeoScaledShape::IsReflected ; (; ); const. overridevirtual . Check if the scale transformation is a reflection. ; Reimplemented from TGeoShape.; Definition at line 257 of file TGeoScaledShape.cxx. â—†Â MakeBuffer3D(). TBuffer3D * TGeoScaledShape::MakeBuffer3D ; (; ); const. overridevirtual . Creates a TBuffer3D describing this shape. ; Coordinates are in local reference frame. ; Reimplemented from TGeoBBox.; Definition at line 266 of file TGeoScaledShape.cxx. â—†Â MakeScaledShape(). TGeoShape * TGeoScaledShape::MakeScaledShape ; (; const char *Â ; name, . TGeoShape *Â ; shape, . TGeoScale *Â ; scaleÂ . ). static . Create a scaled shape starting from a non-scaled one. ; Definition at line 277 of file TGeoScaledShape.cxx. â—†Â Safety(). Double_t TGeoScaledShape::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . computes the closest distance from given point to this shape, according to option. ; The matching point on the shape is stored in spoint. ; Reimplemented from TGeoBBox.; Definition at line 310 of file TGeoScaledShape.cxx. â—†Â Safety_v(). void TGeoScaledShape::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Compute safe distance from each of the points in the input array. ; Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values ; Reimplemented from TGeoBBox.; Definition at line 424 of file TGeoScaledShape.cxx. â—†Â SavePrimitive(). void TGeoScaledShape::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoScaledShape.html:31843,Safe,Safety,31843,doc/master/classTGeoScaledShape.html,https://root.cern,https://root.cern/doc/master/classTGeoScaledShape.html,1,['Safe'],['Safety']
Safety,"Reimplemented from TObject.; Reimplemented in TSelEvent, TSelVerifyDataSet, TSelEventGen, TSelHandleDataSet, TSelectorDraw, and TSelectorEntries.; Definition at line 56 of file TSelector.h. â—†Â operator=(). TSelector & TSelector::operator= ; (; const TSelector &Â ; ). private . â—†Â Process(). bool TSelector::Process ; (; Long64_tÂ ; ). virtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used.; WARNING when a selector is used with a TChain, you must use the pointer to the current TTree to call GetEntry(entry). The entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use: fChain->GetTree()->GetEntry(entry). ; Reimplemented in TSelEvent, TEveSelectorToEventList, ROOT::Experimental::REveSelectorToEventList, TSelVerifyDataSet, TSelEventGen, TSelHandleDataSet, TSelHist, RooProofDriverSelector, TSelectorEntries, h1analysis, h1analysisTreeReader, TProofDraw, and TSelectorDraw.; Definition at line 360 of file TSelector.cxx. â—†Â ProcessCut(). bool TSelector::ProcessCut ; (; Long64_tÂ ; ). virtual . This method is called before processing entry. ; It is the user's responsibility to read the corresponding entry in memory (may be just a partial read). The function returns true if the entry must",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelector.html:21848,Abort,Abort,21848,doc/master/classTSelector.html,https://root.cern,https://root.cern/doc/master/classTSelector.html,1,['Abort'],['Abort']
Safety,"Reimplemented in TGeoConeSeg. â—†Â DistFromInside(). Double_t TGeoCone::DistFromInside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. â—†Â DistFromInside_v(). void TGeoCone::DistFromInside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. â—†Â DistFromInsideS(). static Double_t TGeoCone::DistFromInsideS ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Double_tÂ ; dz, . Double_tÂ ; rmin1, . Double_tÂ ; rmax1, . Double_tÂ ; rmin2, . Double_tÂ ; rmax2Â . ). static . â—†Â DistFromOutside(). Double_t TGeoCone::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. â—†Â DistFromOutside_v(). void TGeoCone::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. â—†Â DistFromOutsideS(). static Double_t TGeoCone::DistFromOutsideS ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Double_tÂ ; dz, . Double_tÂ ; rmin1, . Double_tÂ ; rmax1, . Double_tÂ ; rmin2, . Double_tÂ ; rmax2Â . ). static . â—†Â DistToCone(). static void TGeoCone::DistToCone ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Double_tÂ ; dz, . Double_tÂ ; r1, . Double_tÂ ; r2, . Double_t &Â ; b, . Double_t &Â ; deltaÂ . ). static . â—†Â Divide(). TGeoVolume * TGeoCone::Divide ; (; TGeoVolume *Â ; voldiv, . const char *Â ; divname, . Int_tÂ ; iaxis, . Int_tÂ ; ndiv, . Double_tÂ ; start, . Double_tÂ ; stepÂ . ). overridevirtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCone.html:27270,safe,safe,27270,doc/master/classTGeoCone.html,https://root.cern,https://root.cern/doc/master/classTGeoCone.html,1,['safe'],['safe']
Safety,"ReinitSelector(TQueryResult* qr); virtual voidTProofPlayer::RemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidTProofPlayer::RestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t buf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofPlayerSuperMaster.html:11079,abort,abort,11079,root/html530/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html530/TProofPlayerSuperMaster.html,2,['abort'],['abort']
Safety,"Remove all query result instances referenced 'ref' from the list of results. ; Â ; voidÂ RestorePreviousQuery () override; Â ; Int_tÂ SavePartialResults (Bool_t queryend=kFALSE, Bool_t force=kFALSE) override; Â Save the partial results of this query to a dedicated file under the user data directory. ; Â ; voidÂ SetCurrentQuery (TQueryResult *q) override; Â Set current query and save previous value. ; Â ; voidÂ SetDispatchTimer (Bool_t on=kTRUE) override; Â Enable/disable the timer to dispatch pening events while processing. ; Â ; voidÂ SetDrawFeedbackOption (TDrawFeedback *f, Option_t *opt) override; Â Set draw feedback option. ; Â ; voidÂ SetExitStatus (EExitStatus st) override; Â ; voidÂ SetInitTime () override; Â ; voidÂ SetMaxDrawQueries (Int_t max) override; Â ; voidÂ SetMerging (Bool_t=kTRUE) override; Â ; voidÂ SetOutputFilePath (const char *fp) override; Â ; voidÂ SetProcessing (Bool_t on=kTRUE); Â Set processing bit according to 'on'. ; Â ; voidÂ SetStopTimer (Bool_t on=kTRUE, Bool_t abort=kFALSE, Int_t timeout=0) override; Â Enable/disable the timer to stop/abort processing. ; Â ; virtual voidÂ StopFeedback (); Â Stop feedback (may not be used in this class). ; Â ; voidÂ StopProcess (Bool_t abort, Int_t timeout=-1) override; Â Stop the process after this event. ; Â ; voidÂ StoreFeedback (TObject *slave, TList *out) override; Â Store feedback list (may not be used in this class). ; Â ; voidÂ StoreOutput (TList *out) override; Â Store output list (may not be used in this class). ; Â ; voidÂ Streamer (TBuffer &) override; Â Stream an object of class TObject. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; voidÂ UpdateAutoBin (const char *name, Double_t &xmin, Double_t &xmax, Double_t &ymin, Double_t &ymax, Double_t &zmin, Double_t &zmax) override; Â Update automatic binning parameters for given object ""name"". ; Â ; voidÂ UpdateProgressInfo () override; Â Update fProgressStatus. ; Â ; Â Public Member Functions inherited from TVirtualProofPlayer; Â TVirtualProofPlayer (); Â ; Â ~TVirtualProofPl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:7374,abort,abort,7374,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,3,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"Remove all query result instances referenced 'ref' from the list of results. ; Â ; voidÂ RestorePreviousQuery () override; Â ; Int_tÂ SavePartialResults (Bool_t queryend=kFALSE, Bool_t force=kFALSE) override; Â Save the partial results of this query to a dedicated file under the user data directory. ; Â ; voidÂ SetCurrentQuery (TQueryResult *q) override; Â Set current query and save previous value. ; Â ; voidÂ SetDispatchTimer (Bool_t on=kTRUE) override; Â Enable/disable the timer to dispatch pening events while processing. ; Â ; voidÂ SetDrawFeedbackOption (TDrawFeedback *f, Option_t *opt) override; Â Set draw feedback option. ; Â ; voidÂ SetExitStatus (EExitStatus st) override; Â ; voidÂ SetInitTime () override; Â ; voidÂ SetMaxDrawQueries (Int_t max) override; Â ; voidÂ SetMerging (Bool_t=kTRUE) override; Â ; voidÂ SetOutputFilePath (const char *fp) override; Â ; voidÂ SetProcessing (Bool_t on=kTRUE); Â Set processing bit according to 'on'. ; Â ; voidÂ SetStopTimer (Bool_t on=kTRUE, Bool_t abort=kFALSE, Int_t timeout=0) override; Â Enable/disable the timer to stop/abort processing. ; Â ; voidÂ StopProcess (Bool_t abort, Int_t timeout=-1) override; Â Stop the process after this event. ; Â ; voidÂ StoreFeedback (TObject *slave, TList *out) override; Â Store feedback list (may not be used in this class). ; Â ; voidÂ StoreOutput (TList *out) override; Â Store output list (may not be used in this class). ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; voidÂ UpdateAutoBin (const char *name, Double_t &xmin, Double_t &xmax, Double_t &ymin, Double_t &ymax, Double_t &zmin, Double_t &zmax) override; Â Update automatic binning parameters for given object ""name"". ; Â ; voidÂ UpdateProgressInfo () override; Â Update fProgressStatus. ; Â ; Â Public Member Functions inherited from TVirtualProofPlayer; Â TVirtualProofPlayer (); Â ; Â ~TVirtualProofPlayer () override; Â ; TClass *Â IsA () const override; Â ; voidÂ Streamer (TBuffer &) override; Â Stream an object of class TObject. ; Â ; voidÂ StreamerNVirtual (TBuf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLocal.html:6226,abort,abort,6226,doc/master/classTProofPlayerLocal.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLocal.html,6,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"ResetAll()Reset the navigator.Definition TGeoNavigator.cxx:2708; TGeoNavigator::fBackupStateTGeoCacheState * fBackupStatecurrent point is supposed to be inside this nodeDefinition TGeoNavigator.h:80; TGeoNavigator::GetLevelInt_t GetLevel() constDefinition TGeoNavigator.h:169; TGeoNavigator::IsSamePointBool_t IsSamePoint(Double_t x, Double_t y, Double_t z) constCheck if a new point with given coordinates is the same as the last located one.Definition TGeoNavigator.cxx:2634; TGeoNavigator::fCurrentOverlappingBool_t fCurrentOverlappingflag set when an overlapping cluster is searchedDefinition TGeoNavigator.h:62; TGeoNavigator::IsOnBoundaryBool_t IsOnBoundary() constDefinition TGeoNavigator.h:145; TGeoNavigator::fIsOutsideBool_t fIsOutsideflag that next geometric step will exit current volumeDefinition TGeoNavigator.h:68; TGeoNavigator::CdDownvoid CdDown(Int_t index)Make a daughter of current node current.Definition TGeoNavigator.cxx:313; TGeoNavigator::fIsEnteringBool_t fIsEnteringflag a safe start for point classificationDefinition TGeoNavigator.h:64; TGeoNavigator::GetCurrentPointconst Double_t * GetCurrentPoint() constDefinition TGeoNavigator.h:161; TGeoNavigator::IsStartSafeBool_t IsStartSafe() constDefinition TGeoNavigator.h:135; TGeoNavigator::fForcedNodeTGeoNode * fForcedNodenext node that will be crossedDefinition TGeoNavigator.h:79; TGeoNavigator::GetDivMatrixTGeoHMatrix * GetDivMatrix() constDefinition TGeoNavigator.h:166; TGeoNavigator::MasterToLocalVectvoid MasterToLocalVect(const Double_t *master, Double_t *local) constDefinition TGeoNavigator.h:239; TGeoNavigator::MasterToLocalBombvoid MasterToLocalBomb(const Double_t *master, Double_t *local) constDefinition TGeoNavigator.h:240; TGeoNavigator::GetPathconst char * GetPath() constGet path to the current node in the form /node0/node1/...Definition TGeoNavigator.cxx:2682; TGeoNavigator::IsStepEnteringBool_t IsStepEntering() constDefinition TGeoNavigator.h:142; TGeoNavigator::GetSafeLevelInt_t GetSafeLevel() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:34573,safe,safe,34573,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safe']
Safety,"Result(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualProofPlayer.html:10115,abort,abort,10115,root/html534/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html534/TVirtualProofPlayer.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"Result* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedback * CreateDrawFeedback(TProof* p). void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt). void DeleteDrawFeedback(TDrawFeedback* f). TDSetElement * GetNextPacket(TSlave* slave, TMessage* r). Int_t ReinitSelector(TQueryResult* qr). void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax). Bool_t IsClient() const. EExitStatus GetExitStatus() const. Long64_t GetEventsProcessed() const. void AddEventsProcessed(Long64_t ev). TProofProgressStatus* GetProgressStatus() const. void SetDispatchTimer(Bool_t on = kTRUE). void SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0). Long64_t GetCacheSize(). Int_t GetLearnEntries(). TVirtualPacketizer * GetPacketizer() const; { return 0; }. TVirtualProofPlayer * Create(const char* player, TProof* p, TSocket* s = 0). Â» Author: Fons Rademakers 15/03/07 Â» Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; Â» Last changed: root/proof:$Id: TVirtualProofPlayer.h 36592 2010-11-11 10:43:17Z ganis $ Â» Last generated: 2010-11-11 15:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualProofPlayer.html:14039,abort,abort,14039,root/html528/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html528/TVirtualProofPlayer.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"Result* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedback * CreateDrawFeedback(TProof* p). void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt). void DeleteDrawFeedback(TDrawFeedback* f). TDSetElement * GetNextPacket(TSlave* slave, TMessage* r). Int_t ReinitSelector(TQueryResult* qr). void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax). Bool_t IsClient() const. EExitStatus GetExitStatus() const. Long64_t GetEventsProcessed() const. void AddEventsProcessed(Long64_t ev). TProofProgressStatus* GetProgressStatus() const. void SetDispatchTimer(Bool_t on = kTRUE). void SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0). Long64_t GetCacheSize(). Int_t GetLearnEntries(). TVirtualPacketizer * GetPacketizer() const; { return 0; }. TVirtualProofPlayer * Create(const char* player, TProof* p, TSocket* s = 0). Â» Author: Fons Rademakers 15/03/07 Â» Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; Â» Last changed: root/proof:$Id: TVirtualProofPlayer.h 39171 2011-05-12 16:21:17Z ganis $ Â» Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualProofPlayer.html:14147,abort,abort,14147,root/html530/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html530/TVirtualProofPlayer.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"Result* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedback * CreateDrawFeedback(TProof* p). void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt). void DeleteDrawFeedback(TDrawFeedback* f). TDSetElement * GetNextPacket(TSlave* slave, TMessage* r). Int_t ReinitSelector(TQueryResult* qr). void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax). Bool_t IsClient() const. EExitStatus GetExitStatus() const. Long64_t GetEventsProcessed() const. void AddEventsProcessed(Long64_t ev). TProofProgressStatus* GetProgressStatus() const. void SetDispatchTimer(Bool_t on = kTRUE). void SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0). Long64_t GetCacheSize(). Int_t GetLearnEntries(). TVirtualPacketizer * GetPacketizer() const; { return 0; }. TVirtualProofPlayer * Create(const char* player, TProof* p, TSocket* s = 0). Â» Author: Fons Rademakers 15/03/07 Â» Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; Â» Last changed: root/proof:$Id: TVirtualProofPlayer.h 39171 2011-05-12 16:21:17Z ganis $ Â» Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualProofPlayer.html:14147,abort,abort,14147,root/html532/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"Return true if the underlying data is an integral value. ; Reimplemented in TFormLeafInfoMethod, and TFormLeafInfoReference.; Definition at line 374 of file TFormLeafInfo.cxx. â—†Â IsReference(). virtual bool TFormLeafInfo::IsReference ; (; ); const. inlinevirtual . Reimplemented in TFormLeafInfoReference.; Definition at line 99 of file TFormLeafInfo.h. â—†Â IsString(). bool TFormLeafInfo::IsString ; (; ); const. virtual . Return true if the underlying data is a string. ; Reimplemented in TFormLeafInfoNumerical, TFormLeafInfoMethod, and TFormLeafInfoReference.; Definition at line 351 of file TFormLeafInfo.cxx. â—†Â LoadSizes(). void TFormLeafInfo::LoadSizes ; (; TBranch *Â ; branch). virtual . Load the current array sizes. ; Reimplemented in TFormLeafInfoMultiVarDim, TFormLeafInfoMultiVarDimCollection, and TFormLeafInfoMultiVarDimClones.; Definition at line 467 of file TFormLeafInfo.cxx. â—†Â operator=(). TFormLeafInfo & TFormLeafInfo::operator= ; (; const TFormLeafInfo &Â ; orig). Exception safe assignment operator. ; Definition at line 98 of file TFormLeafInfo.cxx. â—†Â ReadCounterValue(). Int_t TFormLeafInfo::ReadCounterValue ; (; char *Â ; where). virtual . Return the size of the underlying array for the current entry in the TTree. ; Reimplemented in TFormLeafInfoClones, TFormLeafInfoCollection, and TFormLeafInfoReference.; Definition at line 588 of file TFormLeafInfo.cxx. â—†Â ReadTypedValue(). template<typename T > . T TFormLeafInfo::ReadTypedValue ; (; char *Â ; where, . Int_tÂ ; instance = 0Â . ). inline . Definition at line 124 of file TFormLeafInfo.h. â—†Â ReadValue(). virtual Double_t TFormLeafInfo::ReadValue ; (; char *Â ; where, . Int_tÂ ; instance = 0Â . ). inlinevirtual . Reimplemented in TFormLeafInfoDirect, TFormLeafInfoMultiVarDimDirect, TFormLeafInfoCollectionObject, TFormLeafInfoClones, TFormLeafInfoCollection, TFormLeafInfoCollectionSize, TFormLeafInfoPointer, TFormLeafInfoMethod, TFormLeafInfoMultiVarDimCollection, TFormLeafInfoMultiVarDimClones, TFormLeafInfoCast, TFormLea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFormLeafInfo.html:25810,safe,safe,25810,doc/master/classTFormLeafInfo.html,https://root.cern,https://root.cern/doc/master/classTFormLeafInfo.html,1,['safe'],['safe']
Safety,"RooAbsCollection::snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; voidsort(Bool_t reverse = kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact). protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooArgList.html:12132,safe,safeDeleteList,12132,root/html534/RooArgList.html,https://root.cern,https://root.cern/root/html534/RooArgList.html,1,['safe'],['safeDeleteList']
Safety,"RooAbsCollection::snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; voidsort(Bool_t reverse = kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact). protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. static RooPrintable::ContentsOptionRooPrintable::kAddress; static RooPrintable::ContentsOptionRooPrintable::kArgs; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static RooPrintable::ContentsOptionRooPrintable::kClassName; static RooPrintable::ContentsOptionRooPrintable::kCollectionHeader; static RooPrintable::ContentsOptionRooPrintable::kExtras; static TObject::EStatusBitsTObject::kHasUUID; static RooPrintable::StyleOptionRooPrintable::kInline; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooArgList.html:12115,safe,safeDeleteList,12115,root/html602/RooArgList.html,https://root.cern,https://root.cern/root/html602/RooArgList.html,2,['safe'],['safeDeleteList']
Safety,"RooAbsReal.cxx. â—†Â chi2FitTo() [1/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataHist &Â ; data, . const RooCmdArg &Â ; arg1 = {}, . const RooCmdArg &Â ; arg2 = {}, . const RooCmdArg &Â ; arg3 = {}, . const RooCmdArg &Â ; arg4 = {}, . const RooCmdArg &Â ; arg5 = {}, . const RooCmdArg &Â ; arg6 = {}, . const RooCmdArg &Â ; arg7 = {}, . const RooCmdArg &Â ; arg8 = {}Â . ). virtual . Perform a \( \chi^2 \) fit to given histogram. ; By default the fit is executed through the MINUIT commands MIGRAD, HESSE in succession; The following named arguments are supported. Options to control construction of chi2 . Extended(bool flag) Only applicable when fitting a RooAbsPdf. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight. This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events (in RooFit jargon, ""if the pdf can be extended"").; Passing Extended(true) when the the pdf makes no prediction on the expected number of events will result in error messages, and the chi2 will fall back to the total data weight to scale the normalized pdf.; There are cases where the fit must be done in extended mode. This happens for example when you have a RooAddPdf where the coefficients represent component yields. If the fit is not extended, these coefficients will not be well-defined, as the RooAddPdf always normalizes itself. If you pass Extended(false) in such a case, an error will be printed and you'll most likely get garbage results. . Range(const char* name) Fit only data inside range with given name . Range(double lo, double hi) Fit only data inside given range. A range named ""fit"" is created on the fly on all observables. Multiple comma separated range names can be specified. . NumCPU(int num) Parallelize NLL calculation on num CPUs . O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:69793,predict,prediction,69793,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,2,['predict'],['prediction']
Safety,"SE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayerRemote::SetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerLite.html:11365,abort,abort,11365,root/html534/TProofPlayerLite.html,https://root.cern,https://root.cern/root/html534/TProofPlayerLite.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;; iact = 2computes both safe distance and distance to exiting, ignoring the proposed step;; iact > 2computes only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; TGeoShape::DistFromOutsidevirtual Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; This method computes the distance to entering a shape from a given point outside. It acts in the same way as the previous method.; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; TGeoShape::Safetyvirtual Double_t Safety(const Double_t *point, Bool_t in=kTRUE) const =0; This computes the maximum shift of a point in any direction that does not change its inside/outsidestate (does not cross shape boundaries). The state of the point has to be properly supplied.; Double_t *TGeoShape::ComputeNormal(Double_t *point[3],; Double_t *dir[3],Double_t *norm[3]);; TGeoShape::ComputeNormalvirtual void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm)=0; The method above computes the director cosines of normal to the crossed shape surface from a given point towards direction. This is filled into the norm array, supplied by the user. The normal vector is always chosen such that its dot product with the direction is positive defined. Creating Shapes; Shape objects embeds only the minimum set of parameters that are fully describing a valid physical shape. For instance, the half-length, the minimum and maximum radius represent a tube. Shapes are used together with media in order to create volumes, which in their turn are the main componen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Shapes__classes.html:6863,Safe,Safety,6863,doc/master/group__Shapes__classes.html,https://root.cern,https://root.cern/doc/master/group__Shapes__classes.html,3,['Safe'],"['Safety', 'Safetyvirtual']"
Safety,"S_ERR_SSL_WANT_READ); 6252 || (nread == MBEDTLS_ERR_SSL_WANT_WRITE); 6253 || nread == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6254 nread = 0;; 6255 } else {; 6256 fprintf(stderr, ""SSL read failed, error %d\n"", nread);; 6257 return -2;; 6258 }; 6259 } else {; 6260 err = 0;; 6261 }; 6262 ; 6263 } else if (pollres < 0) {; 6264 /* Error */; 6265 return -2;; 6266 } else {; 6267 /* pollres = 0 means timeout */; 6268 nread = 0;; 6269 }; 6270 ; 6271#elif !defined(NO_SSL); 6272 } else if (conn->ssl != NULL) {; 6273 int ssl_pending;; 6274 struct mg_pollfd pfd[1];; 6275 int pollres;; 6276 ; 6277 if ((ssl_pending = SSL_pending(conn->ssl)) > 0) {; 6278 /* We already know there is no more data buffered in conn->buf; 6279 * but there is more available in the SSL layer. So don't poll; 6280 * conn->client.sock yet. */; 6281 if (ssl_pending > len) {; 6282 ssl_pending = len;; 6283 }; 6284 pollres = 1;; 6285 } else {; 6286 pfd[0].fd = conn->client.sock;; 6287 pfd[0].events = POLLIN;; 6288 pollres = mg_poll(pfd,; 6289 1,; 6290 (int)(timeout * 1000.0),; 6291 &(conn->phys_ctx->stop_flag));; 6292 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6293 return -2;; 6294 }; 6295 }; 6296 if (pollres > 0) {; 6297 ERR_clear_error();; 6298 nread =; 6299 SSL_read(conn->ssl, buf, (ssl_pending > 0) ? ssl_pending : len);; 6300 if (nread <= 0) {; 6301 err = SSL_get_error(conn->ssl, nread);; 6302 if ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {; 6303 err = ERRNO;; 6304 } else if ((err == SSL_ERROR_WANT_READ); 6305 || (err == SSL_ERROR_WANT_WRITE)) {; 6306 nread = 0;; 6307 } else {; 6308 /* All errors should return -2 */; 6309 DEBUG_TRACE(""SSL_read() failed, error %d"", err);; 6310 ERR_clear_error();; 6311 return -2;; 6312 }; 6313 ERR_clear_error();; 6314 } else {; 6315 err = 0;; 6316 }; 6317 } else if (pollres < 0) {; 6318 /* Error */; 6319 return -2;; 6320 } else {; 6321 /* pollres = 0 means timeout */; 6322 nread = 0;; 6323 }; 6324#endif; 6325 ; 6326 } else {; 6327 struct mg_pollfd pfd[1];; 6328 i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:183236,timeout,timeout,183236,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"S_ERR_SSL_WANT_READ); 6253 || (nread == MBEDTLS_ERR_SSL_WANT_WRITE); 6254 || nread == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6255 nread = 0;; 6256 } else {; 6257 fprintf(stderr, ""SSL read failed, error %d\n"", nread);; 6258 return -2;; 6259 }; 6260 } else {; 6261 err = 0;; 6262 }; 6263 ; 6264 } else if (pollres < 0) {; 6265 /* Error */; 6266 return -2;; 6267 } else {; 6268 /* pollres = 0 means timeout */; 6269 nread = 0;; 6270 }; 6271 ; 6272#elif !defined(NO_SSL); 6273 } else if (conn->ssl != NULL) {; 6274 int ssl_pending;; 6275 struct mg_pollfd pfd[1];; 6276 int pollres;; 6277 ; 6278 if ((ssl_pending = SSL_pending(conn->ssl)) > 0) {; 6279 /* We already know there is no more data buffered in conn->buf; 6280 * but there is more available in the SSL layer. So don't poll; 6281 * conn->client.sock yet. */; 6282 if (ssl_pending > len) {; 6283 ssl_pending = len;; 6284 }; 6285 pollres = 1;; 6286 } else {; 6287 pfd[0].fd = conn->client.sock;; 6288 pfd[0].events = POLLIN;; 6289 pollres = mg_poll(pfd,; 6290 1,; 6291 (int)(timeout * 1000.0),; 6292 &(conn->phys_ctx->stop_flag));; 6293 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6294 return -2;; 6295 }; 6296 }; 6297 if (pollres > 0) {; 6298 ERR_clear_error();; 6299 nread =; 6300 SSL_read(conn->ssl, buf, (ssl_pending > 0) ? ssl_pending : len);; 6301 if (nread <= 0) {; 6302 err = SSL_get_error(conn->ssl, nread);; 6303 if ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {; 6304 err = ERRNO;; 6305 } else if ((err == SSL_ERROR_WANT_READ); 6306 || (err == SSL_ERROR_WANT_WRITE)) {; 6307 nread = 0;; 6308 } else {; 6309 /* All errors should return -2 */; 6310 DEBUG_TRACE(""SSL_read() failed, error %d"", err);; 6311 ERR_clear_error();; 6312 return -2;; 6313 }; 6314 ERR_clear_error();; 6315 } else {; 6316 err = 0;; 6317 }; 6318 } else if (pollres < 0) {; 6319 /* Error */; 6320 return -2;; 6321 } else {; 6322 /* pollres = 0 means timeout */; 6323 nread = 0;; 6324 }; 6325#endif; 6326 ; 6327 } else {; 6328 struct mg_pollfd pfd[1];; 6329 i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:183268,timeout,timeout,183268,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"S_t> DefineSlot(std::string_view name, F expression, const ColumnNames_t &columns = {}); 471 {; 472 return DefineImpl<F, RDFDetail::ExtraArgsForDefine::Slot>(name, std::move(expression), columns, ""DefineSlot"");; 473 }; 474 // clang-format on; 475 ; 476 // clang-format off; 477 ////////////////////////////////////////////////////////////////////////////; 478 /// \brief Define a new column with a value dependent on the processing slot and the current entry.; 479 /// \param[in] name The name of the defined column.; 480 /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; 481 /// \param[in] columns Names of the columns/branches in input to the producer function (excluding slot and entry).; 482 /// \return the first node of the computation graph for which the new quantity is defined.; 483 ///; 484 /// This alternative implementation of `Define` is meant as a helper in writing entry-specific, thread-safe custom; 485 /// columns. The expression must be a callable of signature R(unsigned int, ULong64_t, T1, T2, ...) where `T1, T2...`; 486 /// are the types of the columns that the expression takes as input. The first parameter is reserved for an unsigned; 487 /// integer representing a ""slot number"". RDataFrame guarantees that different threads will invoke the expression with; 488 /// different slot numbers - slot numbers will range from zero to ROOT::GetThreadPoolSize()-1. The second parameter; 489 /// is reserved for a `ULong64_t` representing the current entry being processed by the current thread.; 490 ///; 491 /// The following two `Define`s are equivalent, although `DefineSlotEntry` is slightly more performant:; 492 /// ~~~{.cpp}; 493 /// int function(unsigned int, ULong64_t, double, double);; 494 /// Define(""x"", function, {""rdfslot_"", ""rdfentry_"", ""column1"", ""column2""}); 495 /// DefineSlotEntry(""x"", function, {""column1"", ""column2""});",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:24689,safe,safe,24689,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['safe'],['safe']
Safety,"S_tutorial2.C ; Â FITS_tutorial3.C ; Â FITS_tutorial4.C ; Â FITS_tutorial5.C ; Â FITS_tutorial6.C ; Â FITS_tutorial7.C ; Â â–ºÂ foam; Â foam_demo.C Demonstrate the TFoam class ; Â foam_demopers.C This simple macro demonstrates persistency of FOAM object ; Â foam_kanwa.C This program can be execute from the command line as folows: ; Â â–ºÂ geom; Â assembly.CGeometry detector assembly example ; Â building.CDrawing a building where Dept ; Â cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ; Â csgdemo.CCombinatorial Solid Geometry example ; Â geo2stp.CExports a geometry in step format ; Â geodemo.CGUI to draw the geometry shapes ; Â geomAlice.CScript drawing a detector geometry (here ALICE) ; Â geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ; Â geomAtlas.CScript drawing a detector geometry (here ATLAS) ; Â geomBrahms.CScript drawing a detector geometry (here BRAHMS) ; Â geomD0.CScript drawing a detector geometry (here D0) ; Â geometry.CExample of the old geometry package (now obsolete) ; Â iterplugin.cxx; Â lego.CDrawing a figure, made of lego block, using ROOT geometry class ; Â mp3player.CDrawing a mp3 type music player, using ROOT geometry class ; Â na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ; Â na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ; Â na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ; Â parallel_world.CMisaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and are correlated ; Â RadioNuclides.CMacro that demonstrates usage of radioactive elements/materials/mixtures with TGeo pac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:111340,detect,detector,111340,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['detect'],['detector']
Safety,"S_tutorial5.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ; Â FITS_tutorial6.COpen a FITS file whose primary array represents a spectrum table (flux vs wavelength) and dump its columns ; Â â–ºÂ foam; Â foam_demo.C Demonstrate the TFoam class ; Â foam_demopers.C This simple macro demonstrates persistency of FOAM object ; Â foam_kanwa.C This program can be execute from the command line as folows: ; Â â–ºÂ geom; Â assembly.CGeometry detector assembly example ; Â building.CDrawing a building where Dept ; Â cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ; Â csgdemo.CCombinatorial Solid Geometry example ; Â geodemo.CGUI to draw the geometry shapes ; Â geomAlice.CScript drawing a detector geometry (here ALICE) ; Â geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ; Â geomAtlas.CScript drawing a detector geometry (here ATLAS) ; Â geomBrahms.CScript drawing a detector geometry (here BRAHMS) ; Â geomD0.CScript drawing a detector geometry (here D0) ; Â geometry.CExample of the old geometry package (now obsolete) ; Â iterplugin.cxx; Â lego.CDrawing a figure, made of lego block, using ROOT geometry class ; Â mp3player.CDrawing a mp3 type music player, using ROOT geometry class ; Â na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ; Â na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ; Â na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ; Â parallel_world.CMisaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and are correlated ; Â RadioNuclides.CMacro that demonstrates usa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:109008,detect,detector,109008,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,2,['detect'],['detector']
Safety,"Segments(int n = 0) { TLockGuard lock(fMutex); fCfg.nsegm = n; }; 343 /** Return of segments for cylindrical shapes, if 0 - default value will be used */; 344 int GetNSegments() const { TLockGuard lock(fMutex); return fCfg.nsegm; }; 345 ; 346 /** Set draw options as string for JSROOT TGeoPainter */; 347 void SetDrawOptions(const std::string &opt = """") { TLockGuard lock(fMutex); fCfg.drawopt = opt; }; 348 /** Returns draw options, used for JSROOT TGeoPainter */; 349 std::string GetDrawOptions() const { TLockGuard lock(fMutex); return fCfg.drawopt; }; 350 ; 351 /** Set JSON compression level for data transfer */; 352 void SetJsonComp(int comp = 0) { TLockGuard lock(fMutex); fJsonComp = comp; }; 353 /** Returns JSON compression level for data transfer */; 354 int GetJsonComp() const { TLockGuard lock(fMutex); return fJsonComp; }; 355 ; 356 /** Set preference of offline operations.; 357 * Server provides more info to client from the begin on to avoid communication */; 358 void SetPreferredOffline(bool on) { TLockGuard lock(fMutex); fPreferredOffline = on; }; 359 /** Is offline operations preferred.; 360 * After get full description, client can do most operations without extra requests */; 361 bool IsPreferredOffline() const { TLockGuard lock(fMutex); return fPreferredOffline; }; 362 ; 363 /** Get top node path */; 364 const std::vector<int>& GetSelectedStack() const { return fSelectedStack; }; 365 ; 366 void Build(TGeoManager *mgr, const std::string &volname = """");; 367 ; 368 void Build(TGeoVolume *vol);; 369 ; 370 /** Number of unique nodes in the geometry */; 371 int GetNumNodes() const { TLockGuard lock(fMutex); return fDesc.size(); }; 372 ; 373 bool IsBuild() const { return GetNumNodes() > 0; }; 374 ; 375 std::string ProduceJson(bool all_nodes = false);; 376 ; 377 bool IsPrincipalEndNode(int nodeid);; 378 ; 379 std::string ProcessBrowserRequest(const std::string &req = """");; 380 ; 381 bool HasDrawData() const;; 382 void ProduceDrawData();; 383 void ProduceSearchData(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8hxx_source.html:14145,avoid,avoid,14145,doc/master/RGeomData_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8hxx_source.html,1,['avoid'],['avoid']
Safety,"Segments(int n = 0) { TLockGuard lock(fMutex); fCfg.nsegm = n; }; 343 /** Return of segments for cylindrical shapes, if 0 - default value will be used */; 344 int GetNSegments() const { TLockGuard lock(fMutex); return fCfg.nsegm; }; 345 ; 346 /** Set draw options as string for JSROOT TGeoPainter */; 347 void SetDrawOptions(const std::string &opt = """") { TLockGuard lock(fMutex); fCfg.drawopt = opt; }; 348 /** Returns draw options, used for JSROOT TGeoPainter */; 349 std::string GetDrawOptions() const { TLockGuard lock(fMutex); return fCfg.drawopt; }; 350 ; 351 /** Set JSON compression level for data transfer */; 352 void SetJsonComp(int comp = 0) { TLockGuard lock(fMutex); fJsonComp = comp; }; 353 /** Returns JSON compression level for data transfer */; 354 int GetJsonComp() const { TLockGuard lock(fMutex); return fJsonComp; }; 355 ; 356 /** Set preference of offline operations.; 357 * Server provides more info to client from the begin on to avoid communication */; 358 void SetPreferredOffline(bool on) { TLockGuard lock(fMutex); fPreferredOffline = on; }; 359 /** Is offline operations preferred.; 360 * After get full description, client can do most operations without extra requests */; 361 bool IsPreferredOffline() const { TLockGuard lock(fMutex); return fPreferredOffline; }; 362 ; 363 ; 364 void Build(TGeoManager *mgr, const std::string &volname = """");; 365 ; 366 void Build(TGeoVolume *vol);; 367 ; 368 /** Number of unique nodes in the geometry */; 369 int GetNumNodes() const { TLockGuard lock(fMutex); return fDesc.size(); }; 370 ; 371 bool IsBuild() const { return GetNumNodes() > 0; }; 372 ; 373 std::string ProduceJson(bool all_nodes = false);; 374 ; 375 bool IsPrincipalEndNode(int nodeid);; 376 ; 377 std::string ProcessBrowserRequest(const std::string &req = """");; 378 ; 379 bool HasDrawData() const;; 380 void ProduceDrawData();; 381 void ProduceSearchData();; 382 std::string GetDrawJson() const { TLockGuard lock(fMutex); return fDrawJson; }; 383 std::string GetSear",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RGeomData_8hxx_source.html:14144,avoid,avoid,14144,doc/v632/RGeomData_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RGeomData_8hxx_source.html,1,['avoid'],['avoid']
Safety,"SelectPointer to selection formula; TStringfSelection; TStatus*fStatus; Long64_tTSelector::fStatusSelector status; TTree*fTree; TTreeDrawArgsParserfTreeDrawArgsParser; TTreeFormula*fVar[4]Pointer to variable formula; Double_tfWeightGlobal weight for fill actions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TProofDraw(); Destructor. void Init(TTree* ); Init the tree. Bool_t Notify(); Called when a new tree is loaded. void Begin(TTree* ); Executed by the client before processing. void SlaveBegin(TTree* ); Executed by each slave before processing. void FillWeight(); Get weight from input list, if any. Bool_t ProcessSingle(Long64_t , Int_t ); Processes a single variable from an entry. Bool_t Process(Long64_t ); Executed for each entry. void SlaveTerminate(void); Executed by each slave after the processing has finished,; before returning the results to the client. void Terminate(void); Executed by the client after getting the processing retults. void ClearFormula(); Delete internal buffers. void SetCanvas(const char* objname); Move to a canvas named <name>_canvas; create the canvas if not existing.; Used to avoid screwing up existing plots when non default names are used; for the final objects. void SetDrawAtt(TObject* o); Set the drawing attributes from the input list. void SetError(const char* sub, const char* mesg); Sets the error status. Bool_t CompileVariables(); Compiles each variable from fTreeDrawArgsParser for the tree fTree.; Return kFALSE if any of the variable is not compilable. void DoFill(Long64_t entry, Double_t w, const Double_t* v). void DefVar(). int Version() const; { return 1; }. Â» Author: Maarten Ballintijn 24/09/2003 Â» Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; Â» Last changed: root/proofplayer:$Id$ Â» Last generated: 2015-06-04 16:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofDraw.html:8381,avoid,avoid,8381,root/html534/TProofDraw.html,https://root.cern,https://root.cern/root/html534/TProofDraw.html,1,['avoid'],['avoid']
Safety,"Send(const TMessage& mess); Send interfaces. Int_t Send(Int_t kind); { return TSocket::Send(kind); }. Int_t Send(Int_t status, Int_t kind); { return TSocket::Send(status, kind); }. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); { return TSocket::Send(mess, kind); }. Int_t SendRaw(const void* buf, Int_t len, ESendRecvOptions opt = kDontBlock). Int_t Recv(TMessage*& mess); Recv interfaces. Int_t Recv(Int_t& status, Int_t& kind); { return TSocket::Recv(status, kind); }. Int_t Recv(char* mess, Int_t max); { return TSocket::Recv(mess, max); }. Int_t Recv(char* mess, Int_t max, Int_t& kind); { return TSocket::Recv(mess, max, kind); }. Int_t RecvRaw(void* buf, Int_t len, ESendRecvOptions opt = kDefault); Interrupts. Int_t GetInterrupt(Bool_t& forward). void SendUrgent(Int_t type, Int_t int1, Int_t int2); Urgent message. void SetInterrupt(Bool_t i = kTRUE); Interrupt the low level socket. Bool_t IsInterrupt(); Set / Check async msg queue waiting status. { R__LOCKGUARD(fAMtx); return fRDInterrupt; }. void SetAWait(Bool_t w = kTRUE); { R__LOCKGUARD(fAMtx); fAWait = w; }. Bool_t IsAWait(); { R__LOCKGUARD(fAMtx); return fAWait; }. Int_t Flush(); Flush the asynchronous queue. Bool_t Ping(const char* ord = 0); Ping the counterpart. void RemoteTouch(); Request remote touch of the admin file associated with this connection. void CtrlC(); Propagate a Ctrl-C. Int_t SetOption(ESockOptions , Int_t ); Standard options cannot be set. { return 0; }. void DisableTimeout(); Disable / Enable read timeout. { fDontTimeout = kTRUE; }. void EnableTimeout(); { fDontTimeout = kFALSE; }. Int_t Reconnect(); Try reconnection after error. Â» Author: G. Ganis Oct 2005 Â» Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; Â» Last changed: root/proofx:$Id: TXSocket.h 38538 2011-03-21 14:13:29Z ganis $ Â» Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXSocket.html:15593,timeout,timeout,15593,root/html530/TXSocket.html,https://root.cern,https://root.cern/root/html530/TXSocket.html,1,['timeout'],['timeout']
Safety,"Send(const TMessage& mess); Send interfaces. Int_t Send(Int_t kind); { return TSocket::Send(kind); }. Int_t Send(Int_t status, Int_t kind); { return TSocket::Send(status, kind); }. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); { return TSocket::Send(mess, kind); }. Int_t SendRaw(const void* buf, Int_t len, ESendRecvOptions opt = kDontBlock). Int_t Recv(TMessage*& mess); Recv interfaces. Int_t Recv(Int_t& status, Int_t& kind); { return TSocket::Recv(status, kind); }. Int_t Recv(char* mess, Int_t max); { return TSocket::Recv(mess, max); }. Int_t Recv(char* mess, Int_t max, Int_t& kind); { return TSocket::Recv(mess, max, kind); }. Int_t RecvRaw(void* buf, Int_t len, ESendRecvOptions opt = kDefault); Interrupts. Int_t GetInterrupt(Bool_t& forward). void SendUrgent(Int_t type, Int_t int1, Int_t int2); Urgent message. void SetInterrupt(Bool_t i = kTRUE); Interrupt the low level socket. Bool_t IsInterrupt(); Set / Check async msg queue waiting status. { R__LOCKGUARD(fAMtx); return fRDInterrupt; }. void SetAWait(Bool_t w = kTRUE); { R__LOCKGUARD(fAMtx); fAWait = w; }. Bool_t IsAWait(); { R__LOCKGUARD(fAMtx); return fAWait; }. Int_t Flush(); Flush the asynchronous queue. Bool_t Ping(const char* ord = 0); Ping the counterpart. void RemoteTouch(); Request remote touch of the admin file associated with this connection. void CtrlC(); Propagate a Ctrl-C. Int_t SetOption(ESockOptions , Int_t ); Standard options cannot be set. { return 0; }. void DisableTimeout(); Disable / Enable read timeout. { fDontTimeout = kTRUE; }. void EnableTimeout(); { fDontTimeout = kFALSE; }. Int_t Reconnect(); Try reconnection after error. Â» Author: G. Ganis Oct 2005 Â» Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; Â» Last changed: root/proofx:$Id: TXSocket.h 38538 2011-03-21 14:13:29Z ganis $ Â» Last generated: 2011-12-02 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXSocket.html:15593,timeout,timeout,15593,root/html532/TXSocket.html,https://root.cern,https://root.cern/root/html532/TXSocket.html,1,['timeout'],['timeout']
Safety,"Set *Â ; nset, . const TNamed *Â ; rangeNameÂ . ); const. protected . Returns the normalization integral value of the coefficient with number coefIdx over normalization set nset in range rangeName. ; Definition at line 577 of file RooAbsAnaConvPdf.cxx. â—†Â getCoefNorm() [3/3]. double RooAbsAnaConvPdf::getCoefNorm ; (; Int_tÂ ; coefIdx, . const RooArgSet *Â ; nset = nullptr, . const char *Â ; rangeName = nullptrÂ . ); const. inline . Definition at line 52 of file RooAbsAnaConvPdf.h. â—†Â IsA(). TClass * RooAbsAnaConvPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in RooBCPEffDecay, RooBCPGenDecay, RooBDecay, RooBMixDecay, RooDecay, and RooNonCPEigenDecay.; Definition at line 120 of file RooAbsAnaConvPdf.h. â—†Â isDirectGenSafe(). bool RooAbsAnaConvPdf::isDirectGenSafe ; (; const RooAbsArg &Â ; arg); const. overridevirtual . Return true if it is safe to generate the convolution observable from the internal generator (this is the case if the chosen resolution model is the truth model) ; Reimplemented from RooAbsPdf.; Definition at line 297 of file RooAbsAnaConvPdf.cxx. â—†Â makeCoefVarList(). void RooAbsAnaConvPdf::makeCoefVarList ; (; RooArgList &Â ; varList); const. protected . Build complete list of coefficient variables. ; Definition at line 604 of file RooAbsAnaConvPdf.cxx. â—†Â parseIntegrationRequest(). RooArgSet * RooAbsAnaConvPdf::parseIntegrationRequest ; (; const RooArgSet &Â ; intSet, . Int_t &Â ; coefCode, . RooArgSet *Â ; analVars = nullptrÂ . ); const. protected . â—†Â printMultiline(). void RooAbsAnaConvPdf::printMultiline ; (; std::ostream &Â ; stream, . Int_tÂ ; contents, . boolÂ ; verbose = false, . TStringÂ ; indent = """"Â . ); const. overridevirtual . Print info about this object to the specified stream. ; In addition to the info from RooAbsPdf::printStream() we add:; Verbose : detailed information on convolution integrals ; Reimplemented from RooPrintable.; Definition at line 645 of file RooAbsAnaCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsAnaConvPdf.html:88966,safe,safe,88966,doc/master/classRooAbsAnaConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsAnaConvPdf.html,1,['safe'],['safe']
Safety,"Set::ERenderMode_e { kRM_AsIs; kRM_Line; kRM_Fill; };; enum TEveElement::ECompoundSelectionColorBits { kCSCBImplySelectAllChildren; kCSCBTakeAnyParentAsMaster; kCSCBApplyMainColorToAllChildren; kCSCBApplyMainColorToMatchingChildren; kCSCBApplyMainTransparencyToAllChildren; kCSCBApplyMainTransparencyToMatchingChildren; };; enum TEveElement::EDestruct { kNone; kStandard; kAnnihilate; };; enum TEveElement::EChangeBits { kCBColorSelection; kCBTransBBox; kCBObjProps; kCBVisibility; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. static const TGPicture*TEveElement::fgListTreeIcons[9]; static const TGPicture*TEveElement::fgRnrIcons[4]. protected:. Bool_tTEveSecondarySelectable::fAlwaysSecSelectAlways do secondary-selection in GL.; Bool_tTEveDigitSet::fAntiFlickMake extra render pass to avoid flickering when quads are too small.; Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); Int_tfBoxSkipNumber of boxes to skip for each drawn box during scene rotation.; TEveBoxSet::EBoxType_efBoxTypeType of rendered box.; UChar_tTEveElement::fCSCBits; void*TEveDigitSet::fCallbackFoo! Additional function to call on secondary-select.; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveDigitSet::fColorColor used for frame (or all digis with single-color).; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Float_tfDefDepthBreadth assigned to third coordinate (C).; Float_tfDefHeightBreadth assigned to second coordinate (B).; Float_tfDefWidthBreadth assigned to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveBoxSet.html:24847,avoid,avoid,24847,root/html532/TEveBoxSet.html,https://root.cern,https://root.cern/root/html532/TEveBoxSet.html,2,['avoid'],['avoid']
Safety,"Set::ERenderMode_e { kRM_AsIs; kRM_Line; kRM_Fill; };; enum TEveElement::ECompoundSelectionColorBits { kCSCBImplySelectAllChildren; kCSCBTakeAnyParentAsMaster; kCSCBApplyMainColorToAllChildren; kCSCBApplyMainColorToMatchingChildren; kCSCBApplyMainTransparencyToAllChildren; kCSCBApplyMainTransparencyToMatchingChildren; };; enum TEveElement::EDestruct { kNone; kStandard; kAnnihilate; };; enum TEveElement::EChangeBits { kCBColorSelection; kCBTransBBox; kCBObjProps; kCBVisibility; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. static const TGPicture*TEveElement::fgListTreeIcons[9]; static const TGPicture*TEveElement::fgRnrIcons[4]. protected:. Bool_tTEveSecondarySelectable::fAlwaysSecSelectAlways do secondary-selection in GL.; Bool_tTEveDigitSet::fAntiFlickMake extra render pass to avoid flickering when quads are too small.; Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); TEveBoxSet::EBoxType_efBoxTypeType of rendered box.; UChar_tTEveElement::fCSCBits; void*TEveDigitSet::fCallbackFoo! Additional function to call on secondary-select.; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveDigitSet::fColorColor used for frame (or all digis with single-color).; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Float_tfDefDepthBreadth assigned to third coordinate (C).; Float_tfDefHeightBreadth assigned to second coordinate (B).; Float_tfDefWidthBreadth assigned to first coordinate (A).; Int_tTEveDigitSet::fDefaultValueDefault signal value.; In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveBoxSet.html:24537,avoid,avoid,24537,root/html528/TEveBoxSet.html,https://root.cern,https://root.cern/root/html528/TEveBoxSet.html,2,['avoid'],['avoid']
Safety,"Set::ERenderMode_e { kRM_AsIs; kRM_Line; kRM_Fill; };; enum TEveElement::ECompoundSelectionColorBits { kCSCBImplySelectAllChildren; kCSCBTakeAnyParentAsMaster; kCSCBApplyMainColorToAllChildren; kCSCBApplyMainColorToMatchingChildren; kCSCBApplyMainTransparencyToAllChildren; kCSCBApplyMainTransparencyToMatchingChildren; };; enum TEveElement::EDestruct { kNone; kStandard; kAnnihilate; };; enum TEveElement::EChangeBits { kCBColorSelection; kCBTransBBox; kCBObjProps; kCBVisibility; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. static const TGPicture*TEveElement::fgListTreeIcons[9]; static const TGPicture*TEveElement::fgRnrIcons[4]. protected:. Bool_tTEveSecondarySelectable::fAlwaysSecSelectAlways do secondary-selection in GL.; Bool_tTEveDigitSet::fAntiFlickMake extra render pass to avoid flickering when quads are too small.; Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); UChar_tTEveElement::fCSCBits; void*TEveDigitSet::fCallbackFoo! Additional function to call on secondary-select.; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveDigitSet::fColorColor used for frame (or all digis with single-color).; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Float_tfDefCoordDefault value for third coordinate (C); Float_tfDefHeightBreadth assigned to second coordinate (B); Float_tfDefWidthBreadth assigned to first coordinate (A); Int_tTEveDigitSet::fDefaultValueDefault signal value.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveQuadSet.html:24711,avoid,avoid,24711,root/html530/TEveQuadSet.html,https://root.cern,https://root.cern/root/html530/TEveQuadSet.html,3,['avoid'],['avoid']
Safety,"SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidTProofPlayerRemote::SetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerLite(TProof* proof = 0); TProofPlayerLite(const TProofPlayerLite&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerLite.html:11303,abort,abort,11303,root/html604/TProofPlayerLite.html,https://root.cern,https://root.cern/root/html604/TProofPlayerLite.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"SetPoints(Float_t* points) const; No mesh for assemblies. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoShapeAssembly(); methods; constructors. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kTRUE;}. Bool_t IsCylType() const; {return kFALSE;}. void NeedsBBoxRecompute(); {fBBoxOK = kFALSE;}. Â» Author: Andrei Gheata 02/06/05 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/geom:$Id$ Â» Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShapeAssembly.html:15453,safe,safe,15453,root/html534/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html534/TGeoShapeAssembly.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"SetPoints(Float_t* points) const; No mesh for assemblies. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoShapeAssembly(); methods; constructors. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kTRUE;}. Bool_t IsCylType() const; {return kFALSE;}. void NeedsBBoxRecompute(); {fBBoxOK = kFALSE;}. Â» Author: Andrei Gheata 02/06/05 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/geom:$Id$ Â» Last generated: 2015-06-02 16:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoShapeAssembly.html:17207,safe,safe,17207,root/html604/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html604/TGeoShapeAssembly.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"SetPoints(Float_t* points) const; No mesh for assemblies. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoShapeAssembly(); methods; constructors. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kTRUE;}. Bool_t IsCylType() const; {return kFALSE;}. void NeedsBBoxRecompute(); {fBBoxOK = kFALSE;}. Â» Author: Andrei Gheata 02/06/05 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/geom:$Id$ Â» Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoShapeAssembly.html:17207,safe,safe,17207,root/html602/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html602/TGeoShapeAssembly.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"SetTitle(title.c_str());; tot_avg_ls[i].SetStats(false);; tot_avg_ls[i].Draw(""COLZ"");; c1->Update();; ; c1->cd((i+1)+NUM_LS);; title = ""Detector View: Avg in LS "" + std::to_string(i);; det_avg_ls[i].SetTitle(title.c_str());; det_avg_ls[i].SetStats(false);; det_avg_ls[i].Draw(""COLZ"");; c1->Update();; ; c1->cd((i+1)+(NUM_LS*2));; title = ""Detector View: Error in LS "" + std::to_string(i);; det_err_ls[i].SetTitle(title.c_str());; det_err_ls[i].SetStats(false);; det_err_ls[i].SetContentToError();; det_err_ls[i].Draw(""COLZ"");; c1->Update();; }; ; std::vector<TProfile2Poly*> tot_avg_v;; std::vector<TProfile2Poly*> det_avg_v;; for (int t = 0; t < NUM_LS; t++){; tot_avg_v.push_back(&tot_avg_ls[t]);; det_avg_v.push_back(&det_avg_ls[t]);; }; ; std::cout << ""[In Progress] Merging"" << std::endl;; ; tot_merge->Merge(tot_avg_v);; c2->cd(1);; tot_merge->SetTitle(""Total average merge"");; tot_merge->Draw(""COLZ"");; ; det_avg_merge->Merge(det_avg_v);; c2->cd(2);; det_avg_merge->SetTitle(""Detector average merge"");; det_avg_merge->SetContentToAverage(); // implicit; det_avg_merge->Draw(""COLZ"");; ; det_err_merge->Merge(det_avg_v);; c2->cd(3);; det_err_merge->SetTitle(""Detector error merge"");; det_err_merge->SetContentToError();; det_err_merge->Draw(""COLZ"");; }; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvas.h; TProfile2D.h; TProfile2Poly.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TRandom.h; TCanvasThe Canvas class.Definition TCanvas.h:23; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TProfile2Poly2D Profile Histogram with Polygonal Bins.Definition TProfile2Poly.h:58; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tprofile2polyRealistic_8C.html:4781,Detect,Detector,4781,doc/master/tprofile2polyRealistic_8C.html,https://root.cern,https://root.cern/doc/master/tprofile2polyRealistic_8C.html,2,['Detect'],['Detector']
Safety,"SetTransformstatic void SetTransform(TGeoMatrix *matrix)Set current transformation matrix that applies to shape.Definition TGeoShape.cxx:582; TGeoShape::DistFromInside_vvirtual void DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *) constDefinition TGeoShape.h:105; TGeoShape::Dividevirtual TGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step)=0; TGeoShape::IsCompositevirtual Bool_t IsComposite() constDefinition TGeoShape.h:130; TGeoShape::InvertShapeBitvoid InvertShapeBit(UInt_t f)Definition TGeoShape.h:169; TGeoShape::ComputeNormal_vvirtual void ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)Definition TGeoShape.h:98; TGeoShape::IsSameWithinTolerancestatic Bool_t IsSameWithinTolerance(Double_t a, Double_t b)Check if two numbers differ with less than a tolerance.Definition TGeoShape.cxx:338; TGeoShape::Safetyvirtual Double_t Safety(const Double_t *point, Bool_t in=kTRUE) const =0; TGeoShape::IsRunTimeShapeBool_t IsRunTimeShape() constDefinition TGeoShape.h:142; TGeoShape::Contains_vvirtual void Contains_v(const Double_t *, Bool_t *, Int_t) constDefinition TGeoShape.h:100; TGeoShape::ClearThreadDatavirtual void ClearThreadData() constDefinition TGeoShape.h:66; TGeoShape::GetPointerNameconst char * GetPointerName() constProvide a pointer name containing uid.Definition TGeoShape.cxx:746; TGeoShape::FillBuffer3Dvirtual void FillBuffer3D(TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) constFill the supplied buffer, with sections in desired frame See TBuffer3D.h for explanation of sections,...Definition TGeoShape.cxx:632; TGeoShape::IsCylTypevirtual Bool_t IsCylType() const =0; TGeoShape::CheckShapevoid CheckShape(Int_t testNo, Int_t nsamples=10000, Option_t *option="""")Test for shape navigation methods.Definition TGeoShape.cxx:211; TGeoShape::EpsMchstatic Double_t EpsMch()static function returning the machine round-off errorDefinition TGeoShape.cx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoShape_8h_source.html:14858,Safe,Safetyvirtual,14858,doc/master/TGeoShape_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html,2,['Safe'],"['Safety', 'Safetyvirtual']"
Safety,"SetUniqueID(UInt_t uid); virtual voidTProof::ShowCache(Bool_t all = kFALSE); voidTProof::ShowData(); voidTProof::ShowDataSet(const char* dataset = """", const char* opt = ""M""); virtual voidTProof::ShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidTProof::ShowDataSets(const char* uri = """", const char* optStr = """"); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidTProof::ShowMissingFiles(TQueryResult* qr = 0); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tTProof::VerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofCondor.html:17504,timeout,timeout,17504,root/html530/TProofCondor.html,https://root.cern,https://root.cern/root/html530/TProofCondor.html,4,['timeout'],['timeout']
Safety,"Shape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTGeoPcon::DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoPcon::DistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&TGeoPcon::Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPgon.html:2283,safe,safe,2283,root/html532/TGeoPgon.html,https://root.cern,https://root.cern/root/html532/TGeoPgon.html,1,['safe'],['safe']
Safety,"ShotCleaner() : TTimer(10, kTRUE) { fGarbage = new TList(); }; 59 virtual ~TSingleShotCleaner() { fGarbage->Delete(); delete fGarbage; }; 60 void TurnOn() override; 61 {; 62 TObject *obj = (TObject *)gTQSender;; 63 fGarbage->Add(obj);; 64 Reset();; 65 if (gSystem); 66 gSystem->AddTimer(this);; 67 }; 68 Bool_t Notify() override; 69 {; 70 fGarbage->Delete();; 71 Reset();; 72 if (gSystem); 73 gSystem->RemoveTimer(this);; 74 return kTRUE;; 75 }; 76};; 77 ; 78////////////////////////////////////////////////////////////////////////////////; 79/// Create timer that times out in ms milliseconds. If milliSec is 0; 80/// then the timeout will be the minimum timeout (see TSystem::ESysConstants,; 81/// i.e. 10 ms). If mode == kTRUE then the timer is synchronous else; 82/// a-synchronous. The default is synchronous. Add a timer to the system; 83/// eventloop by calling TurnOn(). Set command to be executed from Notify(); 84/// or set the object whose HandleTimer() method will be called via Notify(),; 85/// derive from TTimer and override Notify() or connect slots to the; 86/// signals Timeout(), TurnOn() and TurnOff().; 87 ; 88TTimer::TTimer(Long_t ms, Bool_t mode) : fTime(ms); 89{; 90 fObject = nullptr;; 91 fCommand = """";; 92 fSync = mode;; 93 fIntSyscalls = kFALSE;; 94 Reset();; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Create timer that times out in ms milliseconds. If mode == kTRUE then; 99/// the timer is synchronous else a-synchronous. The default is synchronous.; 100/// Add a timer to the system eventloop by calling TurnOn().; 101/// The object's HandleTimer() will be called by Notify().; 102 ; 103TTimer::TTimer(TObject *obj, Long_t ms, Bool_t mode) : fTime(ms); 104{; 105 fObject = obj;; 106 fCommand = """";; 107 fSync = mode;; 108 fIntSyscalls = kFALSE;; 109 Reset();; 110}; 111 ; 112////////////////////////////////////////////////////////////////////////////////; 113/// Create timer that times out in ms milliseconds.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8cxx_source.html:3225,Timeout,Timeout,3225,doc/master/TTimer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html,1,['Timeout'],['Timeout']
Safety,"ShowStreamerInfovirtual void ShowStreamerInfo()Show the StreamerInfo of all classes written to this file.Definition TFile.cxx:3750; TFile::SysSeekvirtual Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence)Interface to system lseek.Definition TFile.cxx:4525; TFile::SysStatvirtual Int_t SysStat(Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime)Return file stat information.Definition TFile.cxx:4543; TFile::GetBytesReadExtravirtual Long64_t GetBytesReadExtra() constDefinition TFile.h:242; TFile::SysOpenvirtual Int_t SysOpen(const char *pathname, Int_t flags, UInt_t mode)Interface to system open. All arguments like in POSIX open().Definition TFile.cxx:4481; TFile::ECacheActionECacheActionTTreeCache flushing semantics.Definition TFile.h:70; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::kDisconnect@ kDisconnectDefinition TFile.h:70; TFile::SetOpenTimeoutstatic UInt_t SetOpenTimeout(UInt_t timeout)Sets open timeout time (in ms). Returns previous timeout value.Definition TFile.cxx:4724; TFile::ReadFreevirtual void ReadFree()Read the FREE linked list.Definition TFile.cxx:1925; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TFile::fgTsSIHashesstatic ROOT::Internal::RConcurrentHashColl fgTsSIHashes!TS Set of hashes built from read streamer infosDefinition TFile.h:120; TFile::fBytesReadExtraLong64_t fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer.Definition TFile.h:77; TFile::fBytesWriteLong64_t fBytesWriteNumber of bytes written to this file.Definition TFile.h:75; TFile::GetArchiveTArchiveFile * GetArchive() constDefinition TFile.h:220; TFile::fIsRootFileBool_t fIsRootFile!True is this is a ROOT file, raw file otherwiseDefinition TFile.h:104; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::DirWriteKeysvirtual void DirWr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:42650,timeout,timeout,42650,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['timeout'],['timeout']
Safety,"SingleKey; kOverwrite; kWriteDelete; };. protected:. Long64_tfCurcurrent entry; TDSet*fDSetdata set over which to iterate; TDirectory*fDirdirectory containing the objects or the TTree; TDSetElement*fElemCurrent Element; Long64_tfElemCurcurrent entry for this element; Long64_tfElemFirstfirst entry to process for this element; Long64_tfElemNumnumber of entries to process for this element; TEntryList*fEntryList! entry list for processing; Long64_tfEntryListPos! current position in the entrylist; TEventList*fEventList! eventList for processing; Int_tfEventListPos! current position in the eventList; TFile*fFileCurrent file; TStringfFilenameName of the current file; Long64_tfFirstfirst entry to process; Long64_tfNumnumber of entries to process; Long64_tfOldBytesReadlast reported number of bytes read; TList*fPacketslist of packets processed packets; TStringfPathPath to current TDirectory; TSelector*fSelselector to be used; Bool_tfStoptermination of run requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TEventIter(); Destructor. void InvalidatePacket(); Invalidated the current packet (if any) by setting the TDSetElement::kCorrupted bit. void StopProcess(Bool_t abort); Set flag to stop the process. TEventIter * Create(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Create and instance of the appropriate iterator. Int_t LoadDir(); Load directory. Long64_t GetCacheSize(). Int_t GetLearnEntries(). Long64_t GetNextEvent(). Int_t GetNextPacket(Long64_t& first, Long64_t& num, TEntryList** enl = 0, TEventList** evl = 0). void PreProcessEvent(Long64_t ). TList * GetPackets(); { return fPackets; }. Â» Author: Maarten Ballintijn 07/01/02 Â» Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; Â» Last changed: root/proofplayer:$Id$ Â» Last generated: 2015-06-04 16:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEventIter.html:6914,abort,abort,6914,root/html534/TEventIter.html,https://root.cern,https://root.cern/root/html534/TEventIter.html,1,['abort'],['abort']
Safety,"SmallVectorTemplateCommon::getFirstEl() is; 503/// well-defined.; 504template <typename T>; 505struct alignas(T) SmallVectorStorage<T, 0> {; 506};; 507 ; 508/// The size of the inline storage of an RVec.; 509/// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); 510/// unless the size of the buffer with 8 elements would be over a certain maximum size.; 511template <typename T>; 512struct RVecInlineStorageSize {; 513private:; 514#ifdef R__HAS_HARDWARE_INTERFERENCE_SIZE; 515 static constexpr std::size_t cacheLineSize = std::hardware_destructive_interference_size;; 516#else; 517 // safe bet: assume the typical 64 bytes; 518 static constexpr std::size_t cacheLineSize = 64;; 519#endif; 520 static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);; 521 static constexpr unsigned maxInlineByteSize = 1024;; 522 ; 523public:; 524 static constexpr unsigned value =; 525 elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8);; 526};; 527 ; 528// A C++14-compatible implementation of std::uninitialized_value_construct; 529template <typename ForwardIt>; 530void UninitializedValueConstruct(ForwardIt first, ForwardIt last); 531{; 532#if __cplusplus < 201703L; 533 for (; first != last; ++first); 534 new (static_cast<void *>(std::addressof(*first))) typename std::iterator_traits<ForwardIt>::value_type();; 535#else; 536 std::uninitialized_value_construct(first, last);; 537#endif; 538}; 539 ; 540/// An unsafe function to reset the buffer for which this RVec is acting as a view.; 541///; 542/// \note This is a low-level method that _must_ be called on RVecs that are already non-owning:; 543/// - it does not put the RVec in ""non-owning mode"" (fCapacity == -1); 544/// - it does not free any owned buffer; 545template <typename T>; 546void ResetView(RVec<T> &v, T* addr, std::size_t sz); 547{; 548 v.fBeginX = addr;; 549 v.fSize = sz;; 550}; 551 ; 552} // namespace VecOp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:19040,safe,safe,19040,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"Socket * TMonitor::Select ; (; ). Return pointer to socket for which an event is waiting. ; Select can be interrupt by a call to Interrupt() (e.g. connected with a Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable in such a case. Return 0 in case of error. ; Definition at line 322 of file TMonitor.cxx. â—†Â Select() [2/3]. TSocket * TMonitor::Select ; (; Long_tÂ ; timeout). Return pointer to socket for which an event is waiting. ; Wait a maximum of timeout milliseconds. If return is due to timeout it returns (TSocket *)-1. Select() can be interrupt by a call to Interrupt() (e.g. connected with a Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable in such a case. Return 0 in case of any other error situation. ; Definition at line 348 of file TMonitor.cxx. â—†Â Select() [3/3]. Int_t TMonitor::Select ; (; TList *Â ; rdready, . TList *Â ; wrready, . Long_tÂ ; timeoutÂ . ). Return numbers of sockets that are ready for reading or writing. ; Wait a maximum of timeout milliseconds. Return 0 if timed-out. Return < 0 in case of error. If rdready and/or wrready are not 0, the lists of sockets with something to read and/or write are also returned. ; Definition at line 377 of file TMonitor.cxx. â—†Â SetInterest(). void TMonitor::SetInterest ; (; TSocket *Â ; sock, . Int_tÂ ; interest = kReadÂ . ). virtual . Set interest mask for socket sock to interest. ; If the socket is not in the active list move it or add it there. If interest=kRead then we want to monitor the socket for read readiness, if interest=kWrite then we monitor the socket for write readiness, if interest=kRead|kWrite then we monitor both read and write readiness. ; Definition at line 180 of file TMonitor.cxx. â—†Â SetReady(). void TMonitor::SetReady ; (; TSocket *Â ; sock). private . Called by TSocketHandler::Notify() to signal which socket is ready to be read or written. ; User should not call this routine. The ready socket will be returned via the Select() user function. The Ready(TSocket *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:22473,timeout,timeout,22473,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['timeout'],['timeout']
Safety,"Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; Â» CORE; Â» META; Â» TIsAProxy. class TIsAProxy: public TVirtualIsAProxy. TClass. TIsAProxy implementation class. Function Members (Methods); public:. virtual~TIsAProxy(); virtual TClass*operator()(const void* obj); virtual voidSetClass(TClass* cl); TIsAProxy(const type_info& typ). protected:. TIsAProxy&operator=(const TIsAProxy&); TIsAProxy(const TIsAProxy&). private:. void*CacheSubType(const type_info*, TClass*); void*FindSubType(const type_info*) const. Data Members; private:. Atomic_t<TClass*>fClassActual TClass; Atomic_t<Bool_t>fInitInitialization flag; Atomic_t<void*>fLastpoints into fSubTypes map for last used values; Char_tfSubTypes[72]map of known sub-types; Atomic_t<UInt_t>fSubTypesReadersnumber of readers of fSubTypes; Atomic_t<Bool_t>fSubTypesWriteLockTakenTrue if there is a writer; const type_info*fTypeActual typeid of the proxy; Bool_tfVirtualFlag if class is virtual. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TIsAProxy(const std::type_info& typ); Standard initializing constructor. ~TIsAProxy(); Standard destructor. void SetClass(TClass* cl); Set class pointer; This method is not thread safe. TClass* operator()(const void* obj); IsA callback. void* FindSubType(const type_info* ) const; See if we have already cached the TClass that correspond to this type_info. void* CacheSubType(const type_info* , TClass* ); Record the TClass found for a type_info, so that we can retrieved it faster. TIsAProxy(const TIsAProxy& ). TIsAProxy& operator=(const TIsAProxy& ). Â» Author: Markus Frank 20/05/2005 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/meta:$Id$ Â» Last generated: 2015-06-30 15:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TIsAProxy.html:1389,safe,safe,1389,root/html602/TIsAProxy.html,https://root.cern,https://root.cern/root/html602/TIsAProxy.html,1,['safe'],['safe']
Safety,"Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; Â» CORE; Â» META; Â» TIsAProxy. class TIsAProxy: public TVirtualIsAProxy. TClass. TIsAProxy implementation class. Function Members (Methods); public:. virtual~TIsAProxy(); virtual TClass*operator()(const void* obj); virtual voidSetClass(TClass* cl); TIsAProxy(const type_info& typ). protected:. TIsAProxy&operator=(const TIsAProxy&); TIsAProxy(const TIsAProxy&). private:. void*CacheSubType(const type_info*, TClass*); void*FindSubType(const type_info*) const. Data Members; private:. Atomic_t<TClass*>fClassActual TClass; Atomic_t<Bool_t>fInitInitialization flag; Atomic_t<void*>fLastpoints into fSubTypes map for last used values; Char_tfSubTypes[72]map of known sub-types; Atomic_t<UInt_t>fSubTypesReadersnumber of readers of fSubTypes; Atomic_t<Bool_t>fSubTypesWriteLockTakenTrue if there is a writer; const type_info*fTypeActual typeid of the proxy; Bool_tfVirtualFlag if class is virtual. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TIsAProxy(const std::type_info& typ); Standard initializing constructor. ~TIsAProxy(); Standard destructor. void SetClass(TClass* cl); Set class pointer; This method is not thread safe. TClass* operator()(const void* obj); IsA callback. void* FindSubType(const type_info* ) const; See if we have already cached the TClass that correspond to this type_info. void* CacheSubType(const type_info* , TClass* ); Record the TClass found for a type_info, so that we can retrieved it faster. TIsAProxy(const TIsAProxy& ). TIsAProxy& operator=(const TIsAProxy& ). Â» Author: Markus Frank 20/05/2005 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/meta:$Id$ Â» Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TIsAProxy.html:1389,safe,safe,1389,root/html604/TIsAProxy.html,https://root.cern,https://root.cern/root/html604/TIsAProxy.html,1,['safe'],['safe']
Safety,"Static method to lock the main thread mutex. Int_t TryLock(); Static method to try to lock the main thread mutex. Int_t UnLock(); Static method to unlock the main thread mutex. void * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method listing the existing threads. void ** Tsd(void* dflt, Int_t k); Static method returning a pointer to thread specific data container; of the calling thread. void Printf(const char *va_(fmt), ...); Static method providing a thread safe printf. Appends a newline. void ErrorHandler(int level, const char* location, const char* fmt, va_list ap) const; Thread specific error handler function.; It calls the user set error handler in the main thread. void DoError(Int_t level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler. User has to specify the class name as; part of the location, just like for the global Info(), Warning() and; Error() functions. Int_t XARequest(const char* xact, Int_t nb, void** ar, Int_t* iret); Static method used to allow commands to be executed by the main thread. void XAction(); Static method called via the thread timer to execute in the main; thread certain commands. This to avoid sophisticated locking and; possible deadlocking. void SetComment(const char* txt = 0). TThread& operator=(const TThread& ). void Delete(Option_t* option = """"); { TObject::Delete(option); }. EPriority GetPriority() const; { return fPriority; }. EState GetState() const; { return fState; }. Long_t GetId() const; { return fId; }. void ps(); { Ps(); }. Â» Author: Fons Rademakers 02/07/97 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/thread:$Id: TThread.h 39262 2011-05-19 09:10:49Z rdm $ Â» Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TThread.html:14796,avoid,avoid,14796,root/html530/TThread.html,https://root.cern,https://root.cern/root/html530/TThread.html,1,['avoid'],['avoid']
Safety,"Statsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?. private:. TList*fActivenodes with unfinished files; Float_tfBaseLocalPreferenceindicates how much more likely the nodes will be; Bool_tfCachePacketSynccontrol synchronization of cache and packet sizes; TList*fFileNodesnodes with files; TSortedList*fFilesToProcessGlobal list of files (TFileStat) to be processed; Bool_tfForceLocalif 1 - eliminate the remote processing; Float_tfFractionOfRemoteFilesfraction of TDSetElements that are on non-workers; Double_tfMaxEntriesRatiomax file entries to avg allowed ratio for cache-to-packet sync; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Long64_tfNEventsOnRemLocnumber of events in currently; Int_tfPacketAsAFractionused to calculate the packet size; TList*fPartitionslist of partitions on nodes; Int_tfStrategy0 means the classic and 1 (default) - the adaptive strategy; Int_tfTryReassignControls attempts to reassign packets (0 == no reassignment); TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPacketizerAdaptive.html:11263,avoid,avoid,11263,root/html530/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html530/TPacketizerAdaptive.html,3,['avoid'],['avoid']
Safety,"StepBool_t fIsNullStepflag that a new point is in the same node as previousDefinition TGeoNavigator.h:71; TGeoNavigator::SetLastSafetyForPointvoid SetLastSafetyForPoint(Double_t safe, const Double_t *point)Definition TGeoNavigator.h:194; TGeoNavigator::CdNodevoid CdNode(Int_t nodeid)Change current path to point to the node having this id.Definition TGeoNavigator.cxx:301; TGeoNavigator::IsCurrentOverlappingBool_t IsCurrentOverlapping() constDefinition TGeoNavigator.h:139; TGeoNavigator::operator=TGeoNavigator & operator=(const TGeoNavigator &)=delete; TGeoNavigator::GetNmanyInt_t GetNmany() constDefinition TGeoNavigator.h:105; TGeoNavigator::GetCacheTGeoNodeCache * GetCache() constDefinition TGeoNavigator.h:243; TGeoNavigator::fNextNodeTGeoNode * fNextNodelast searched nodeDefinition TGeoNavigator.h:78; TGeoNavigator::fCldirCheckedDouble_t fCldirChecked[3]unit vector to current closest shapeDefinition TGeoNavigator.h:48; TGeoNavigator::SetLastSafetyForPointvoid SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z)Definition TGeoNavigator.h:199; TGeoNavigator::fLevelInt_t fLevelthread id for this navigatorDefinition TGeoNavigator.h:55; TGeoNavigator::GetPWSafetyDouble_t GetPWSafety(Double_t cpoint[3], Double_t saf_max)Wrapper for getting the safety from the parallel world.Definition TGeoNavigator.cxx:1656; TGeoNavigator::ResetAllvoid ResetAll()Reset the navigator.Definition TGeoNavigator.cxx:2708; TGeoNavigator::fBackupStateTGeoCacheState * fBackupStatecurrent point is supposed to be inside this nodeDefinition TGeoNavigator.h:80; TGeoNavigator::GetLevelInt_t GetLevel() constDefinition TGeoNavigator.h:169; TGeoNavigator::IsSamePointBool_t IsSamePoint(Double_t x, Double_t y, Double_t z) constCheck if a new point with given coordinates is the same as the last located one.Definition TGeoNavigator.cxx:2634; TGeoNavigator::fCurrentOverlappingBool_t fCurrentOverlappingflag set when an overlapping cluster is searchedDefinition TGeoNavigator.h:62; TGeoNaviga",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:33206,safe,safe,33206,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safe']
Safety,"StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; Â Public Member Functions inherited from TGeoTrap; Â TGeoTrap (); Â ; Â TGeoTrap (const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Â ; Â TGeoTrap (Double_t dz, Double_t theta, Double_t phi); Â ; Â TGeoTrap (Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Â ; Â ~TGeoTrap () override; Â ; Double_tÂ DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; Â ; voidÂ DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; Â ; Double_tÂ DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; Â ; voidÂ DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; Â ; TGeoVolume *Â Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; Â ; Double_tÂ GetAlpha1 () const; Â ; Double_tÂ GetAlpha2 () const; Â ; Double_tÂ GetBl1 () const; Â ; Double_tÂ GetBl2 () const; Â ; Double_tÂ GetH1 () const; Â ; Double_tÂ GetH2 () const; Â ; TGeoShape *Â GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override; Â ; Double_tÂ GetPhi () const; Â ; Double_tÂ GetTheta () const; Â ; Double_tÂ GetTl1 () const; Â ; Double_tÂ GetTl2 () const; Â ; TClass *Â IsA () const override; Â ; Double_tÂ Safety (const Double_t *point, Bool_t in=kTRUE) const override; Â ; voidÂ Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; Â ; voidÂ SavePrimitive (std::ostream &out, Option_t *option="""") override; Â Save a primitive as a C++",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoGtra.html:2988,safe,safe,2988,doc/master/classTGeoGtra.html,https://root.cern,https://root.cern/doc/master/classTGeoGtra.html,1,['safe'],['safe']
Safety,"StreamerNVirtual ; (; TBuffer &Â ; ClassDef_StreamerNVirtual_b). inline . Definition at line 432 of file RooAbsCollection.h. â—†Â structureTag(). TNamed * RooAbsCollection::structureTag ; (; ). inlineprotected . Definition at line 386 of file RooAbsCollection.h. â—†Â takeOwnership(). void RooAbsCollection::takeOwnership ; (; ). inline . Definition at line 356 of file RooAbsCollection.h. â—†Â throwAddTypedException(). void RooAbsCollection::throwAddTypedException ; (; TClass *Â ; klass, . RooAbsArg *Â ; argÂ . ). staticprivate . Definition at line 1651 of file RooAbsCollection.cxx. â—†Â typedStructureTag(). TNamed * RooAbsCollection::typedStructureTag ; (; ). inlineprotected . Definition at line 387 of file RooAbsCollection.h. â—†Â uniqueId(). RooFit::UniqueId< RooAbsCollection > const & RooAbsCollection::uniqueId ; (; ); const. inline . Returns a unique ID that is different for every instantiated RooAbsCollection. ; This ID can be used to check whether two collections are the same object, which is safer than memory address comparisons that might result in false positives when memory is recycled. ; Definition at line 98 of file RooAbsCollection.h. â—†Â useHashMapForFind(). void RooAbsCollection::useHashMapForFind ; (; boolÂ ; flag); const. Parameters. [in]flagSwitch hash map on or off. . Definition at line 1614 of file RooAbsCollection.cxx. Member Data Documentation. â—†Â _allRRV. bool RooAbsCollection::_allRRV = true. protected . All contents are RRV. ; Definition at line 382 of file RooAbsCollection.h. â—†Â _hashAssistedFind. HashAssistedFind* RooAbsCollection::_hashAssistedFind = nullptr. mutableprivate . ! ; Definition at line 423 of file RooAbsCollection.h. â—†Â _list. Storage_t RooAbsCollection::_list. protected . Actual object storage. ; Definition at line 377 of file RooAbsCollection.h. â—†Â _name. TString RooAbsCollection::_name. protected . Our name. ; Definition at line 381 of file RooAbsCollection.h. â—†Â _ownCont. bool RooAbsCollection::_ownCont = false. protected . Flag to identify a list th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCollection.html:61010,safe,safer,61010,doc/master/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/master/classRooAbsCollection.html,1,['safe'],['safer']
Safety,"StreamerNVirtual ; (; TBuffer &Â ; ClassDef_StreamerNVirtual_b). inline . Definition at line 455 of file RooAbsCollection.h. â—†Â structureTag(). TNamed * RooAbsCollection::structureTag ; (; ). inlineprotected . Definition at line 409 of file RooAbsCollection.h. â—†Â takeOwnership(). void RooAbsCollection::takeOwnership ; (; ). inline . Definition at line 379 of file RooAbsCollection.h. â—†Â throwAddTypedException(). void RooAbsCollection::throwAddTypedException ; (; TClass *Â ; klass, . RooAbsArg *Â ; argÂ . ). staticprivate . Definition at line 1638 of file RooAbsCollection.cxx. â—†Â typedStructureTag(). TNamed * RooAbsCollection::typedStructureTag ; (; ). inlineprotected . Definition at line 410 of file RooAbsCollection.h. â—†Â uniqueId(). RooFit::UniqueId< RooAbsCollection > const & RooAbsCollection::uniqueId ; (; ); const. inline . Returns a unique ID that is different for every instantiated RooAbsCollection. ; This ID can be used to check whether two collections are the same object, which is safer than memory address comparisons that might result in false positives when memory is recycled. ; Definition at line 98 of file RooAbsCollection.h. â—†Â useHashMapForFind(). void RooAbsCollection::useHashMapForFind ; (; boolÂ ; flag); const. Parameters. [in]flagSwitch hash map on or off. . Definition at line 1604 of file RooAbsCollection.cxx. Member Data Documentation. â—†Â _allRRV. bool RooAbsCollection::_allRRV = true. protected . All contents are RRV. ; Definition at line 405 of file RooAbsCollection.h. â—†Â _hashAssistedFind. std::unique_ptr<HashAssistedFind> RooAbsCollection::_hashAssistedFind. mutableprivate . ! ; Definition at line 446 of file RooAbsCollection.h. â—†Â _list. Storage_t RooAbsCollection::_list. protected . Actual object storage. ; Definition at line 400 of file RooAbsCollection.h. â—†Â _name. TString RooAbsCollection::_name. protected . Our name. ; Definition at line 404 of file RooAbsCollection.h. â—†Â _ownCont. bool RooAbsCollection::_ownCont = false. protected . Flag to identify a l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsCollection.html:62793,safe,safer,62793,doc/v632/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html,1,['safe'],['safer']
Safety,"String& s1, const TString& s2); { return ReplaceAll(s1.Data(), s1.Length(), s2.Data(), s2.Length()) ; }. TString & ReplaceAll(const TString& s1, const char* s2); { return ReplaceAll(s1.Data(), s1.Length(), s2, s2 ? strlen(s2) : 0); }. TString & ReplaceAll(const char* s1, const TString& s2); { return ReplaceAll(s1, s1 ? strlen(s1) : 0, s2.Data(), s2.Length()); }. TString & ReplaceAll(const char* s1, const char* s2); { return ReplaceAll(s1, s1 ? strlen(s1) : 0, s2, s2 ? strlen(s2) : 0); }. char & operator()(Ssiz_t i); { Cow(); return fData[i]; }. char operator[](Ssiz_t i) const; { AssertElement(i); return fData[i]; }. char operator()(Ssiz_t i) const; { return fData[i]; }. Ssiz_t Length() const; { return fNchars; }. Ssiz_t Capacity() const; { return fCapacity; }. char * Data() const; { return (char*)(this+1); }. Ssiz_t First(char c) const. Ssiz_t First(const char* cs) const. Ssiz_t Last(char c) const. char & operator()(Ssiz_t i). char operator()(Ssiz_t i) const. Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. TString(const char* a1, Ssiz_t n1, const char* a2, Ssiz_t n2); Special concatenation constructor. TStringRef * Pref() const; { return (((TStringRef*) fData) - 1); }. TString(). TString * ReadString(TBuffer& b, const TClass* clReq). Bool_t Gets(FILE* fp, Bool_t chop = kTRUE); C I/O interface. void Puts(FILE* fp). operator const char*() const; Type conversion. { return fData; }. char & operator()(Ssiz_t i). char operator()(Ssiz_t i) const. Ssiz_t Index(const char* s, Ssiz_t i = 0, TString::ECaseCompare cmp = kExact) const. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const. Ssiz_t Index(const TRegexp& pat, Ssiz_t i = 0) const. Ssiz_t Index(const TRegexp& pat, Ssiz_t* ext, Ssiz_t i = 0) const. Bool_t IsWhitespace() const; { return (Length() == CountChar(' ')); }. istream & ReadFile(istream& str). istream & ReadLine(istream& str, Bool_t skipWhite = kTRUE). istream & ReadToDelim(istream& str, char ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TString.html:21623,detect,detecting,21623,root/html528/TString.html,https://root.cern,https://root.cern/root/html528/TString.html,1,['detect'],['detecting']
Safety,"StringTNamed::fTitleobject title; Double_tTGeoTrap::fTl1half length in x at low z and y high edge; Double_tTGeoTrap::fTl2half length in x at high z and y high edge; Double_t*TGeoArb8::fTwist! [4] tangents of twist angles ; Double_tfTwistAngletwist angle in degrees; Double_tTGeoArb8::fXY[8][2]list of vertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtra(); Default ctor. TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor. TGeoGtra(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor providing the name of the shape. ~TGeoGtra(); Destructor. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these has to be computed; in order to fit the mother. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2; param[11] = twist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoGtra.html:16023,safe,safe,16023,root/html534/TGeoGtra.html,https://root.cern,https://root.cern/root/html534/TGeoGtra.html,1,['safe'],['safe']
Safety,"StringView name) constRetrieve real-valued variable (RooRealVar) with given name. A null pointer is returned if not found.Definition RooWorkspace.cxx:1232; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::ComponentsRooCmdArg Components(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:128; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf509_wsinteractiveDefinition rf509_wsinteractive.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf509__wsinteractive_8C.html:7235,safe,safe,7235,doc/master/rf509__wsinteractive_8C.html,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html,1,['safe'],['safe']
Safety,"Style(),fH->GetLineWidth(),0);; 8106 } else {; 8107 for (Int_t id=0;id<=fStack->GetSize();id++) {; 8108 hid = (TH1*)fStack->At((id==0)?id:id-1);; 8109 fLego->SetEdgeAtt(hid->GetLineColor(),hid->GetLineStyle(),hid->GetLineWidth(),id);; 8110 }; 8111 }; 8112 ; 8113 if (Hoption.Lego == 11) {; 8114 nids = 1;; 8115 if (fStack) nids = fStack->GetSize();; 8116 hid = fH;; 8117 for (Int_t id=0;id<=nids;id++) {; 8118 if (id > 0 && fStack) hid = (TH1*)fStack->At(id-1);; 8119 colormain = hid->GetFillColor();; 8120 if (colormain == 1) colormain = 17; //avoid drawing with black; 8121 if (drawShadowsInLego1) colordark = TColor::GetColorDark(colormain);; 8122 else colordark = colormain;; 8123 fLego->SetColorMain(colormain,id);; 8124 fLego->SetColorDark(colordark,id);; 8125 if (id <= 1) fLego->SetColorMain(colormain,-1); // Set Bottom color; 8126 if (id == nids) fLego->SetColorMain(colormain,99); // Set Top color; 8127 }; 8128 }; 8129 ; 8130 // Now ready to draw the lego plot; 8131 Int_t irep = 0;; 8132 ; 8133 TView *view = gPad ? gPad->GetView() : nullptr;; 8134 if (!view) {; 8135 Error(""PaintLego"", ""no TView in current pad"");; 8136 return;; 8137 }; 8138 ; 8139 Double_t thedeg = 90 - gPad->GetTheta();; 8140 Double_t phideg = -90 - gPad->GetPhi();; 8141 Double_t psideg = view->GetPsi();; 8142 view->SetView(phideg, thedeg, psideg, irep);; 8143 ; 8144 fLego->SetLineColor(kBlack); // zgrid color for lego1 & lego2; 8145 fLego->SetFillStyle(fH->GetFillStyle());; 8146 ; 8147 // Set color/style for back box; 8148 fLego->SetFillStyle(gPad->GetFrameFillStyle());; 8149 fLego->SetFillColor(gPad->GetFrameFillColor());; 8150 fLego->TAttFill::Modify();; 8151 ; 8152 Int_t backcolor = gPad->GetFrameFillColor();; 8153 if (Hoption.System != kCARTESIAN) backcolor = 0;; 8154 view->PadRange(backcolor);; 8155 ; 8156 fLego->SetFillStyle(fH->GetFillStyle());; 8157 fLego->SetFillColor(fH->GetFillColor());; 8158 fLego->TAttFill::Modify();; 8159 ; 8160 fLego->DefineGridLevels(fZaxis->GetNdivisions()%100);; 816",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:290885,avoid,avoid,290885,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['avoid'],['avoid']
Safety,"SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidRooArgSet::writeToFile(const char* fileName) const; virtual voidRooArgSet::writeToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidRooAbsProxy::changeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE); Bool_tRooArgSet::checkForDup(const RooAbsArg& arg, Bool_t silent) const; voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; Bool_t_defShapeServer; Bool_t_defValueServer; TIterator*_iter! do not persist; R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSetProxy.html:11948,safe,safeDeleteList,11948,root/html534/RooSetProxy.html,https://root.cern,https://root.cern/root/html534/RooSetProxy.html,1,['safe'],['safeDeleteList']
Safety,"SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidRooArgSet::writeToFile(const char* fileName) const; virtual voidRooArgSet::writeToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidRooAbsProxy::changeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE); Bool_tRooArgSet::checkForDup(const RooAbsArg& arg, Bool_t silent) const; voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. static RooPrintable::ContentsOptionRooPrintable::kAddress; static RooPrintable::ContentsOptionRooPrintable::kArgs; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static RooPrintable::ContentsOptionRooPrintable::kClassName; static RooPrintable::ContentsOptionRooPrintable::kCollectionHeader; static RooPrintable::ContentsOptionRooPrintable::kExtras; static TObject::EStatusBitsTObject::kHasUUID; static RooPrintable::StyleOptionRooPrintable::kInline; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSetProxy.html:11938,safe,safeDeleteList,11938,root/html602/RooSetProxy.html,https://root.cern,https://root.cern/root/html602/RooSetProxy.html,2,['safe'],['safeDeleteList']
Safety,T-10936] - Build fails with cuDNN 8; [ROOT-10942] - [DF] Regression in recognition of nested branch names; [ROOT-10944] - hadd: wrong TH2 sum with x-labels only; [ROOT-10946] - Error messages from RooMomentMorphND; [ROOT-10956] - New jupyroot missing jupyterlab fixes in pyroot_legacy - Causes jsroot to fail in jupyterlab; [ROOT-10962] - Uncaught exceptions from RDataFrame operations exit root prompt.; [ROOT-10963] - [Tree] TLeaf::GetName and TLeaf::GetFullName disagree on leaf name; [ROOT-10964] - README/INSTALL should point to web; [ROOT-10969] - Can not compile ROOT macro on Win10: picking up paths to other SW; [ROOT-10982] - ODR Violation in TMVA; [ROOT-10987] - RooFitâ€™s caching can lead to wrong results when batch computations used.; [ROOT-10993] - ROOT fails in loading nlohmann/json; [ROOT-10994] - TFormula::DoEval and DoEvalVec have a thread safety issue; [ROOT-10995] - Possible data race in TFormula::TFormula() constructor; [ROOT-11000] - rootcling fails for Gaudi classes; [ROOT-11001] - unable to create TChain on ROOT file; [ROOT-11005] - ROOT crashes when creating a TCanvas with gDebug=1; [ROOT-11009] - RDataFrame Silent â€œbugsâ€ with assignment in Filter expressions; [ROOT-11013] - â€œImpossible code pathâ€ in TGenCollectionProxy.cxx when using rootcling; [ROOT-11015] - OpenGL rendering is incorrect for â€œpgon - pgonâ€; [ROOT-10830] - vector<string> behaviour in loops in PyROOT 6.20 vs 6.22; [ROOT-9559] - [DF] Treat indexed Friend trees; [ROOT-10832] - Make TH1::GetCumulative account for underflows and overflows; [ROOT-8013] - equalising roofit tutorials for easier digestion; [ROOT-8142] - Provide corrupt line when XML parsing fails; [ROOT-10022] - [DF] Add support for TBranchObjects (e.g.Â branches containing TH2F); [ROOT-10781] - Performance penalty from RooRealVar not allowing to use hash table on RooLinkedList member; [#6408] - Creating RooDataSet causes SegFault; [#6529] - segfault in RooWorkspace::import; [#6489] - Test Issue; [#6540] - Crash message should p,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:37579,safe,safety,37579,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['safe'],['safety']
Safety,"TBuffer &ClassDef_StreamerNVirtual_b); Â ; Â Public Member Functions inherited from THashList; Â THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0); Â Create a THashList object. ; Â ; Â THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0); Â For backward compatibility only. Use other ctor. ; Â ; virtualÂ ~THashList (); Â Delete a hashlist. ; Â ; Float_tÂ AverageCollisions () const; Â Return the average collision rate. ; Â ; const TList *Â GetListForObject (const char *name) const; Â Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ; Â ; const TList *Â GetListForObject (const TObject *obj) const; Â Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ; Â ; voidÂ Rehash (Int_t newCapacity); Â Rehash the hashlist. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; boolÂ UseRWLock (Bool_t enable=true) override; Â Set this collection to use a RW lock upon access, making it thread safe. ; Â ; Â Public Member Functions inherited from TList; Â TList (); Â ; The argument is ignored Use the default constructorÂ TList ()."") ; Â ; Â TList (TObject *) R__DEPRECATED(6; Â ; virtualÂ ~TList (); Â Delete the list. ; Â ; voidÂ Add (TObject *obj) override; Â ; virtual voidÂ Add (TObject *obj, Option_t *opt); Â ; Bool_tÂ IsAscending (); Â ; TObject *Â Remove (const TObjLinkPtr_t &lnk); Â ; voidÂ RemoveLast () override; Â Remove the last object of the list. ; Â ; virtual voidÂ Sort (Bool_t order=kSortAscending); Â Sort linked list. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; Â Public Member Functions inherited from TSeqCollection; virtualÂ ~TSeqCollection (); Â ; voidÂ Add (TObject *obj) override; Â ; TClass *Â IsA () const override; Â ; virtual Bool_tÂ IsSorted () const; Â ; Int_tÂ LastIndex () const; Â ; Long64_tÂ Merge (TCollection *list); Â Merge this collection with all collections coming in th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnumsWithLock.html:5226,safe,safe,5226,doc/master/classTListOfEnumsWithLock.html,https://root.cern,https://root.cern/doc/master/classTListOfEnumsWithLock.html,1,['safe'],['safe']
Safety,"TBuffer &ClassDef_StreamerNVirtual_b); Â ; Â Public Member Functions inherited from THashList; Â THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0); Â Create a THashList object. ; Â ; Â THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0); Â For backward compatibility only. Use other ctor. ; Â ; virtualÂ ~THashList (); Â Delete a hashlist. ; Â ; Float_tÂ AverageCollisions () const; Â Return the average collision rate. ; Â ; const TList *Â GetListForObject (const char *name) const; Â Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ; Â ; const TList *Â GetListForObject (const TObject *obj) const; Â Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ; Â ; voidÂ Rehash (Int_t newCapacity); Â Rehash the hashlist. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; boolÂ UseRWLock (Bool_t enable=true) override; Â Set this collection to use a RW lock upon access, making it thread safe. ; Â ; Â Public Member Functions inherited from TList; Â TList (); Â ; The argument is ignored Use the default constructorÂ TList ()."") ; Â ; Â TList (TObject *) R__DEPRECATED(6; Â ; virtualÂ ~TList (); Â Delete the list. ; Â ; voidÂ Add (TObject *obj) override; Â ; virtual voidÂ Add (TObject *obj, Option_t *opt); Â ; TObject *Â After (const TObject *obj) const override; Â Returns the object after object obj. ; Â ; TObject *Â At (Int_t idx) const override; Â Returns the object at position idx. Returns 0 if idx is out of range. ; Â ; TObject *Â Before (const TObject *obj) const override; Â Returns the object before object obj. ; Â ; TObject *Â First () const override; Â Return the first object in the list. Returns 0 when list is empty. ; Â ; virtual TObjLink *Â FirstLink () const; Â ; TObject **Â GetObjectRef (const TObject *obj) const override; Â Return address of pointer to obj. ; Â ; Bool_tÂ IsAscending (); Â ; TObject *Â La",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnums.html:4931,safe,safe,4931,doc/master/classTListOfEnums.html,https://root.cern,https://root.cern/doc/master/classTListOfEnums.html,1,['safe'],['safe']
Safety,"TBuffer.; Definition at line 2889 of file TBufferJSON.cxx. â—†Â ReadFastArray() [11/15]. void TBufferJSON::ReadFastArray ; (; ULong64_t *Â ; l, . Int_tÂ ; nÂ . ). finalvirtual . read array of ULong64_t from buffer ; Implements TBuffer.; Definition at line 2921 of file TBufferJSON.cxx. â—†Â ReadFastArray() [12/15]. void TBufferJSON::ReadFastArray ; (; ULong_t *Â ; l, . Int_tÂ ; nÂ . ). finalvirtual . read array of ULong_t from buffer ; Implements TBuffer.; Definition at line 2905 of file TBufferJSON.cxx. â—†Â ReadFastArray() [13/15]. void TBufferJSON::ReadFastArray ; (; UShort_t *Â ; h, . Int_tÂ ; nÂ . ). finalvirtual . read array of UShort_t from buffer ; Implements TBuffer.; Definition at line 2873 of file TBufferJSON.cxx. â—†Â ReadFastArray() [14/15]. void TBufferJSON::ReadFastArray ; (; void **Â ; startp, . const TClass *Â ; cl, . Int_tÂ ; n = 1, . Bool_tÂ ; isPreAlloc = kFALSE, . TMemberStreamer *Â ; s = nullptr, . const TClass *Â ; onFileClass = nullptrÂ . ). finalvirtual . redefined here to avoid warning message from gcc ; Implements TBuffer.; Definition at line 2988 of file TBufferJSON.cxx. â—†Â ReadFastArray() [15/15]. void TBufferJSON::ReadFastArray ; (; void *Â ; start, . const TClass *Â ; cl, . Int_tÂ ; n = 1, . TMemberStreamer *Â ; s = nullptr, . const TClass *Â ; onFileClass = nullptrÂ . ). finalvirtual . Read an array of 'n' objects from the I/O buffer. ; Stores the objects read starting at the address 'start'. The objects in the array are assume to be of class 'cl'. Copied code from TBufferFile ; Implements TBuffer.; Definition at line 2948 of file TBufferJSON.cxx. â—†Â ReadFastArrayString(). void TBufferJSON::ReadFastArrayString ; (; Char_t *Â ; c, . Int_tÂ ; nÂ . ). finalvirtual . read array of Char_t from buffer ; Implements TBuffer.; Definition at line 2849 of file TBufferJSON.cxx. â—†Â ReadFloat(). void TBufferJSON::ReadFloat ; (; Float_t &Â ; f). finalvirtual . Reads Float_t value from buffer. ; Implements TBuffer.; Definition at line 3658 of file TBufferJSON.cxx. â—†Â ReadInt(). void TBufferJSO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:77079,avoid,avoid,77079,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,1,['avoid'],['avoid']
Safety,"TBuffer3D * TGeoShape::MakeBuffer3D ; (; ); const. inlinevirtual . Reimplemented in TGeoBBox, TGeoCone, TGeoConeSeg, TGeoHype, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoSphere, TGeoTessellated, TGeoTorus, TGeoTube, TGeoTubeSeg, TGeoXtru, TGeoVGShape, TEveGeoPolyShape, and ROOT::Experimental::REveGeoPolyShape.; Definition at line 146 of file TGeoShape.h. â—†Â NormalPhi(). void TGeoShape::NormalPhi ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Double_t *Â ; norm, . Double_tÂ ; c1, . Double_tÂ ; s1, . Double_tÂ ; c2, . Double_tÂ ; s2Â . ). static . Static method to compute normal to phi planes. ; Definition at line 464 of file TGeoShape.cxx. â—†Â Paint(). void TGeoShape::Paint ; (; Option_t *Â ; option = """"). overridevirtual . Paint this shape. ; Reimplemented from TObject.; Reimplemented in TGeoVGShape.; Definition at line 784 of file TGeoShape.cxx. â—†Â ResetShapeBit(). void TGeoShape::ResetShapeBit ; (; UInt_tÂ ; f). inline . Definition at line 166 of file TGeoShape.h. â—†Â Safety(). virtual Double_t TGeoShape::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. pure virtual . Implemented in TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. â—†Â Safety_v(). virtual void TGeoShape::Safety_v ; (; const Double_t *Â ; , . const Bool_t *Â ; , . Double_t *Â ; , . Int_tÂ ; Â . ); const. inlinevirtual . Reimplemented in TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoXtru.; Definition at line 151 of file TGeoShape.h. â—†Â SafetyPhi(). Double_t TGeoShape::SafetyPhi ; (; const Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:45585,Safe,Safety,45585,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['Safe'],['Safety']
Safety,"TBufferJSON::fArrayCompact {0}. protected . ! 0 - no array compression, 1 - exclude leading/trailing zeros, 2 - check value repetition ; Definition at line 325 of file TBufferJSON.h. â—†Â fArraySepar. TString TBufferJSON::fArraySepar. protected . ! depending from compression level, "", "" or "","" ; Definition at line 326 of file TBufferJSON.h. â—†Â fCompact. Int_t TBufferJSON::fCompact {0}. protected . ! 0 - no any compression, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all ; Definition at line 322 of file TBufferJSON.h. â—†Â fJsonrCnt. unsigned TBufferJSON::fJsonrCnt {0}. protected . ! counter for all objects, used for referencing ; Definition at line 320 of file TBufferJSON.h. â—†Â fMapAsObject. Bool_t TBufferJSON::fMapAsObject {kFALSE}. protected . ! when true, std::map will be converted into JSON object ; Definition at line 323 of file TBufferJSON.h. â—†Â fNumericLocale. TString TBufferJSON::fNumericLocale. protected . ! stored value of setlocale(LC_NUMERIC), which should be recovered at the end ; Definition at line 327 of file TBufferJSON.h. â—†Â fOutBuffer. TString TBufferJSON::fOutBuffer. protected . ! main output buffer for json code ; Definition at line 317 of file TBufferJSON.h. â—†Â fOutput. TString* TBufferJSON::fOutput {nullptr}. protected . ! current output buffer for json code ; Definition at line 318 of file TBufferJSON.h. â—†Â fSemicolon. TString TBufferJSON::fSemicolon. protected . ! depending from compression level, "" : "" or "":"" ; Definition at line 324 of file TBufferJSON.h. â—†Â fSkipClasses. std::vector<const TClass *> TBufferJSON::fSkipClasses. protected . ! list of classes, which class info is not stored ; Definition at line 330 of file TBufferJSON.h. â—†Â fStack. std::deque<std::unique_ptr<TJSONStackObj> > TBufferJSON::fStack. protected . ! hierarchy of currently streamed element ; Definition at line 321 of file TBufferJSON.h. â—†Â fTypeNameTag. TString TBufferJSON::fTypeNameTag. protected . ! JSON member used for storing class name, when empty - no class n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:101182,recover,recovered,101182,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,1,['recover'],['recovered']
Safety,"TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf302_utilfuncsDefinition rf302_utilfuncs.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_3' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_4' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_1_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_2_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_3_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_4_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf302_utilfuncs.C. tutorialsroofitrf302_utilfuncs.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8 Â Â ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf302__utilfuncs_8C.html:6197,safe,safe,6197,doc/master/rf302__utilfuncs_8C.html,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8C.html,1,['safe'],['safe']
Safety,"TClingUtils.h. â—†Â ExistingTypeCheck_t. typedef bool(* ROOT::TMetaUtils::TClingLookupHelper::ExistingTypeCheck_t) (const std::string &tname, std::string &result). Definition at line 162 of file TClingUtils.h. Constructor & Destructor Documentation. â—†Â TClingLookupHelper(). ROOT::TMetaUtils::TClingLookupHelper::TClingLookupHelper ; (; cling::Interpreter &Â ; interpreter, . TNormalizedCtxt &Â ; normCtxt, . ExistingTypeCheck_tÂ ; existingTypeCheck, . AutoParse_tÂ ; autoParse, . bool *Â ; shuttingDownPtr, . const int *Â ; pgDebug = nullptrÂ . ). Definition at line 523 of file TClingUtils.cxx. â—†Â ~TClingLookupHelper(). virtual ROOT::TMetaUtils::TClingLookupHelper::~TClingLookupHelper ; (; ). inlinevirtual . Definition at line 180 of file TClingUtils.h. Member Function Documentation. â—†Â ExistingTypeCheck(). bool ROOT::TMetaUtils::TClingLookupHelper::ExistingTypeCheck ; (; const std::string &Â ; tname, . std::string &Â ; resultÂ . ). overridevirtual . Helper routine to ry hard to avoid looking up in the Cling database as this could enduce an unwanted autoparsing. ; Implements TClassEdit::TInterpreterLookupHelper.; Definition at line 541 of file TClingUtils.cxx. â—†Â GetPartiallyDesugaredName(). void ROOT::TMetaUtils::TClingLookupHelper::GetPartiallyDesugaredName ; (; std::string &Â ; nameLong). overridevirtual . Implements TClassEdit::TInterpreterLookupHelper.; Definition at line 552 of file TClingUtils.cxx. â—†Â GetPartiallyDesugaredNameWithScopeHandling(). bool ROOT::TMetaUtils::TClingLookupHelper::GetPartiallyDesugaredNameWithScopeHandling ; (; const std::string &Â ; tname, . std::string &Â ; result, . boolÂ ; dropstd = trueÂ . ). overridevirtual . We assume that we have a simple type: [const] typename[*&][const]. ; Implements TClassEdit::TInterpreterLookupHelper.; Definition at line 603 of file TClingUtils.cxx. â—†Â IsAlreadyPartiallyDesugaredName(). bool ROOT::TMetaUtils::TClingLookupHelper::IsAlreadyPartiallyDesugaredName ; (; const std::string &Â ; nondef, . const std::string &Â ; nameLongÂ . ). o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TMetaUtils_1_1TClingLookupHelper.html:3337,avoid,avoid,3337,doc/master/classROOT_1_1TMetaUtils_1_1TClingLookupHelper.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TMetaUtils_1_1TClingLookupHelper.html,1,['avoid'],['avoid']
Safety,"TConfiguration *config); 192 {; 193 char *obj = (char*)addr;; 194 TGenericConfiguration *conf = (TGenericConfiguration*)config;; 195 return ((TStreamerInfo*)conf->fInfo)->ReadBuffer(buf, &obj, &(conf->fCompInfo), /*first*/ 0, /*last*/ 1, /*narr*/ 1, config->fOffset, 2);; 196 }; 197 ; 198 Int_t GenericWriteAction(TBuffer &buf, void *addr, const TConfiguration *config); 199 {; 200 char *obj = (char*)addr;; 201 TGenericConfiguration *conf = (TGenericConfiguration*)config;; 202 return ((TStreamerInfo*)conf->fInfo)->WriteBufferAux(buf, &obj, &(conf->fCompInfo), /*first*/ 0, /*last*/ 1, /*narr*/ 1, config->fOffset, 2);; 203 }; 204 ; 205 template <typename T>; 206 INLINE_TEMPLATE_ARGS Int_t ReadBasicType(TBuffer &buf, void *addr, const TConfiguration *config); 207 {; 208 T *x = (T*)( ((char*)addr) + config->fOffset );; 209 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 210 buf >> *x;; 211 return 0;; 212 }; 213 ; 214 void HandleReferencedTObject(TBuffer &buf, void *addr, const TConfiguration *config) {; 215 TBitsConfiguration *conf = (TBitsConfiguration*)config;; 216 UShort_t pidf;; 217 buf >> pidf;; 218 pidf += buf.GetPidOffset();; 219 TProcessID *pid = buf.ReadProcessID(pidf);; 220 if (pid!=0) {; 221 TObject *obj = (TObject*)( ((char*)addr) + conf->fObjectOffset);; 222 UInt_t gpid = pid->GetUniqueID();; 223 UInt_t uid;; 224 if (gpid>=0xff) {; 225 uid = obj->GetUniqueID() | 0xff000000;; 226 } else {; 227 uid = ( obj->GetUniqueID() & 0xffffff) + (gpid<<24);; 228 }; 229 obj->SetUniqueID(uid);; 230 pid->PutObjectWithID(obj);; 231 }; 232 }; 233 ; 234 template <>; 235 INLINE_TEMPLATE_ARGS Int_t ReadBasicType<BitsMarker>(TBuffer &buf, void *addr, const TConfiguration *config); 236 {; 237 UInt_t *x = (UInt_t*)( ((char*)addr) + config->fOffset );; 238 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 239 // Idea: This code really belongs inside TBuffer[File]; 240 const UInt_t isonheap = *x & TObject::kIsOnHeap; // Record how this instance",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:7695,avoid,avoid,7695,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['avoid'],['avoid']
Safety,"TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;; 2393}; 2394 ; 2395////////////////////////////////////////////////////////////////////////////////; 2396/// Return the size in bytes of the file header.; 2397 ; 2398Int_t TFile::Sizeof() const; 2399{; 2400 return 0;; 2401}; 2402 ; 2403////////////////////////////////////////////////////////////////////////////////; 2404/// Stream a TFile object.; 2405 ; 2406void TFile::Streamer(TBuffer &b); 2407{; 2408 if (b.IsReading()) {; 2409 b.ReadVersion(); //Version_t v = b.ReadVersion();; 2410 } else {; 2411 b.WriteVersion(TFile::IsA());; 2412 }; 2413}; 2414 ; 2415////////////////////////////////////////////////////////////////////////////////; 2416/// Increment statistics for buffer sizes of objects in this file.; 2417 ; 2418void TFile::SumBuffer(Int_t bufsize); 2419{; 2420 fWritten++;; 2421 fSumBuffer += double(bufsize);; 2422 fSum2Buffer += double(bufsize) * double(bufsize); // avoid reaching MAXINT for temporary; 2423}; 2424 ; 2425////////////////////////////////////////////////////////////////////////////////; 2426/// Write memory objects to this file.; 2427///; 2428/// Loop on all objects in memory (including subdirectories).; 2429/// A new key is created in the KEYS linked list for each object.; 2430/// The list of keys is then saved on the file (via WriteKeys); 2431/// as a single data record.; 2432/// For values of opt see TObject::Write().; 2433/// The directory header info is rewritten on the directory header record.; 2434/// The linked list of FREE segments is written.; 2435/// The file header is written (bytes 1->fBEGIN).; 2436 ; 2437Int_t TFile::Write(const char *, Int_t opt, Int_t bufsiz); 2438{; 2439 if (!IsWritable()) {; 2440 if (!TestBit(kWriteError)) {; 2441 // Do not print the warning if we already had a SysError.; 2442 Warning(""Write"", ""file %s not opened in write mode"", GetName());; 2443 }; 2444 return 0;; 2445 }; 2446 ; 2447 if (gDebug) {; 244",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:85872,avoid,avoid,85872,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['avoid'],['avoid']
Safety,"TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }. TCanvas * GetStatsCanvas() const; { return fStatsCanvas; }. TEditQueryFrame * GetQueryEditFrame() const; { return fFD; }. Â» Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 Â» Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; Â» Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ Â» Last generated: 2010-09-23 20:20; This page has b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSessionQueryFrame.html:21550,abort,aborted,21550,root/html528/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html,1,['abort'],['aborted']
Safety,"TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }. TCanvas * GetStatsCanvas() const; { return fStatsCanvas; }. TEditQueryFrame * GetQueryEditFrame() const; { return fFD; }. Â» Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 Â» Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; Â» Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ Â» Last generated: 2011-07-04 15:37; This page has b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSessionQueryFrame.html:21650,abort,aborted,21650,root/html530/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html530/TSessionQueryFrame.html,1,['abort'],['aborted']
Safety,"TGNumberEntryLayout Layout manager for number entry widget; TGNumberFormat Class defining namespace for several enums used by TGNumberEntry; TGObject ROOT GUI base class; TGPack Horizontal or vertical stack of frames.; TGPasswdDialog Dialog for entering passwords; TGPicture Pictures and icons used by the GUI classes; TGPictureButton A picture button widget; TGPicturePool Picture and icon cache; TGPopupMenu Popup menu; TGPosition Position object (x and y are Int_t); TGPrintDialog Print dialog used by TGTextEdit widget; TGProgressBar Progress bar abstract base class; TGQt Interface to Qt GUI; TGRadioButton A radio button widget; TGRecorder GUI class of the event recorder.; TGRectMap Rectangle used in TMap; TGRectangle Rectangle object; TGRedirectOutputGuard Exception safe output redirection; TGRegion Describes a region; TGRegionWithId Region with id, tooltip text and popup menu; TGResourcePool Graphics resource pool; TGRowLayout Row layout manager; TGScrollBar Scrollbar widget; TGScrollBarElement Scrollbar element (head, tail, slider); TGSearchDialog Text search dialog used by TGTextEdit widget; TGSearchType ; TGSelectedPicture Selected looking picture; TGShapedFrame Shaped composite frame; TGShutter Shutter widget; TGShutterItem Shutter widget item; TGSimpleTable A simple table that owns it's interface.; TGSimpleTableInterface Interface to data in a 2D array of Double_t; TGSlider Slider widget abstract base class; TGSpeedo Base class for analog meter widget; TGSplitButton a split button widget; TGSplitFrame Splittable composite frame; TGSplitTool Split frame tool utility; TGSplitter A frame splitter abstract base class; TGStatusBar Status bar widget; TGString Graphics string; TGTRA GTRA shape; TGTab Tab widget; TGTabElement Little tab on tab widget; TGTabLayout Layout manager for TGTab widget; TGTable A table used to visualize data from diffent sources.; TGTableCell A single cell in a TGTable.; TGTableFrame A frame used internally by TGTable.; TGTableHeader Header for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:82635,safe,safe,82635,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,1,['safe'],['safe']
Safety,"TGQt. Meta Library. Added a new mode for TClass::SetCanSplit (2) which indicates that this class and any derived class should not be split.; This included a rework the mechanism checking the base classes. Instead of using InheritsFrom, which lead in some cases, including the case where the class derived from an STL collection, to spurrious autoparsing (to look at the base class of the collection!), we use a custom walk through the tree of base classes that checks their value of fCanSplit.; This also has the side-effect of allowing the extension of the concept â€˜base class that prevent its derived class from being splitâ€™ to any user class. This fixes [ROOT-7972].; Reduce autoparse occasions by autoloading libraries also based on their type_info-derived name, instead of only their normalized name.; Improve TClassEditâ€™s handling of STLâ€™s default allocator, in particular for std::map ROOT-8048. Dictionaries. Add the -noIncludePaths and â€“noIncludePaths to rootcling and genereflex respectively to avoid storing in the dictionaries the include paths passed with the â€œ-Iâ€ switch. ROOT will rely on ROOT_INCLUDE_PATH only at runtime to find headers. I/O. Resolve an issue when space is freed in a large ROOT file and a TDirectory is updated and stored the lower (less than 2GB) freed portion of the file [ROOT-8055]. TTree. Do not automatically setup read cache during TTree::Fill(). This fixes [ROOT-8031]. Fast Cloning. Added a cache specifically for the fast option of the TTreeCloner to significantly reduce the run-time when fast-cloning remote files to address [ROOT-5078].; The new cache can be controlled from the TTreeCloner, TTree::CopyEntries or hadd interfaces.; The new cache is enabled by default.; To update the size of the cache or disable it:; From TTreeCloner use: TTreeCloner::SetCacheSize; From TTree::CopyEntries add to the option string ""cachesize=SIZE""; From hadd, use the command line option -cachesize SIZE; SIZE should be given in number bytes and can be expressed in â€˜h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:38251,avoid,avoid,38251,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['avoid'],['avoid']
Safety,"TGTextViewostream; Â CTGTextViewStreamBuf; Â CTGTileLayout; Â CTGToolBar; Â CTGToolTip; Â CTGTRAA general twisted trapezoid ; Â CTGTransientFrame; Â CTGTreeLBEntry; Â CTGTreeTableTGTreeTable is a TGTable that owns it's own interface ; Â CTGTripleHSlider; Â CTGTripleVSlider; Â CTGuiBldAction; Â CTGuiBldDragManager; Â CTGuiBldEditor; Â CTGuiBldGeometryFrame; Â CTGuiBldHintsButton; Â CTGuiBldHintsEditor; Â CTGuiBldNameFrame; Â CTGuiBuilder; Â CTGuiFactoryThis ABC is a factory for GUI components ; Â CTGUndockedFrame; Â CTGUnknownWindowHandler; Â CTGVButtonGroup; Â CTGVertical3DLine; Â CTGVerticalFrame; Â CTGVerticalLayout; Â CTGVFileSplitter; Â CTGView; Â CTGViewFrame; Â CTGViewPort; Â CTGVProgressBar; Â CTGVScrollBar; Â CTGVSlider; Â CTGVSplitter; Â CTGWidget; Â CTGWin32This class is the basic interface to the Win32 graphics system ; Â CTGWin32GLManager; Â CTGWin32GLManagerProxy; Â CTGWin32InterpreterProxyThis class defines thread-safe interface to a command line interpreter ; Â CTGWin32ProxyBaseProxy classes provide thread-safe interface to global objects ; Â CTGWin32VirtualXProxy; Â CTGWindow; Â CTGX11This class is the basic interface to the X11 (Xlib) graphics system ; Â CTGX11TTFInterface to low level X11 (Xlib) ; Â CTGXYLayout; Â CTGXYLayoutHints; Â CTH1The TH1 histogram class ; Â CTH1C1-D histogram with a byte per channel (see TH1 documentation) ; Â CTH1D1-D histogram with a double per channel (see TH1 documentation)} ; Â CTH1Editor; Â CTH1F1-D histogram with a float per channel (see TH1 documentation)} ; Â CTH1I1-D histogram with an int per channel (see TH1 documentation)} ; Â CTH1KTH1K class supports the nearest K Neighbours method, widely used in cluster analysis ; Â CTH1Merger; Â CTH1S1-D histogram with a short per channel (see TH1 documentation) ; Â CTH2Service class for 2-Dim histogram classes ; Â CTH2C2-D histogram with a byte per channel (see TH1 documentation) ; Â CTH2D2-D histogram with a double per channel (see TH1 documentation)} ; Â CTH2Editor; Â CTH2F2-D histogram with a float per channel (see TH1 documentat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:177603,safe,safe,177603,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,3,['safe'],['safe']
Safety,"TGTextViewostream; Â CTGTextViewStreamBuf; Â CTGTileLayout; Â CTGToolBar; Â CTGToolTip; Â CTGTRAA general twisted trapezoid ; Â CTGTransientFrame; Â CTGTreeLBEntry; Â CTGTreeTableTGTreeTable is a TGTable that owns it's own interface ; Â CTGTripleHSlider; Â CTGTripleVSlider; Â CTGuiBldAction; Â CTGuiBldDragManager; Â CTGuiBldEditor; Â CTGuiBldGeometryFrame; Â CTGuiBldHintsButton; Â CTGuiBldHintsEditor; Â CTGuiBldNameFrame; Â CTGuiBuilder; Â CTGuiFactoryThis ABC is a factory for GUI components ; Â CTGUndockedFrame; Â CTGUnknownWindowHandler; Â CTGVButtonGroup; Â CTGVertical3DLine; Â CTGVerticalFrame; Â CTGVerticalLayout; Â CTGVFileSplitter; Â CTGView; Â CTGViewFrame; Â CTGViewPort; Â CTGVProgressBar; Â CTGVScrollBar; Â CTGVSlider; Â CTGVSplitter; Â CTGWidget; Â CTGWin32This class is the basic interface to the Win32 graphics system ; Â CTGWin32GLManager; Â CTGWin32GLManagerProxy; Â CTGWin32InterpreterProxyThis class defines thread-safe interface to a command line interpreter ; Â CTGWin32ProxyBaseProxy classes provide thread-safe interface to global objects ; Â CTGWin32VirtualXProxy; Â CTGWindow; Â CTGX11This class is the basic interface to the X11 (Xlib) graphics system ; Â CTGX11TTFInterface to low level X11 (Xlib) ; Â CTGXYLayout; Â CTGXYLayoutHints; Â CTH1The TH1 histogram class ; Â CTH1CTomato 1-D histogram with a byte per channel (see TH1 documentation) ; Â CTH1DTomato 1-D histogram with a double per channel (see TH1 documentation)} ; Â CTH1Editor; Â CTH1FTomato 1-D histogram with a float per channel (see TH1 documentation)} ; Â CTH1ITomato 1-D histogram with an int per channel (see TH1 documentation)} ; Â CTH1KTH1K class supports the nearest K Neighbours method, widely used in cluster analysis ; Â CTH1Merger; Â CTH1STomato 1-D histogram with a short per channel (see TH1 documentation) ; Â CTH2Service class for 2-Dim histogram classes ; Â CTH2CTomato 2-D histogram with a byte per channel (see TH1 documentation) ; Â CTH2DTomato 2-D histogram with a double per channel (see TH1 documentation)} ; Â CTH2Editor; Â CTH2FTomato 2-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:160462,safe,safe,160462,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,['safe'],['safe']
Safety,"TGeoArb8::fXY[8][2]list of vertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrap(); Default ctor. TGeoTrap(Double_t dz, Double_t theta, Double_t phi); Constructor providing just a range in Z, theta and phi. TGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Normal constructor. TGeoTrap(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor with name. ~TGeoTrap(); destructor. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trapezoid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trapezoid. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trapezoid shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; are supported. For Z divisions just return the pointer to the volume to be; divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these have to be computed; in order to fit the mother. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrap.html:16032,safe,safe,16032,root/html534/TGeoTrap.html,https://root.cern,https://root.cern/root/html534/TGeoTrap.html,1,['safe'],['safe']
Safety,"TGeoBBox. â—†Â Contains(). Bool_t TGeoEltu::Contains ; (; const Double_t *Â ; point); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Contains_v(). void TGeoEltu::Contains_v ; (; const Double_t *Â ; points, . Bool_t *Â ; inside, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DeclFileName(). static const char * TGeoEltu::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 65 of file TGeoEltu.h. â—†Â DistancetoPrimitive(). Int_t TGeoEltu::DistancetoPrimitive ; (; Int_tÂ ; px, . Int_tÂ ; pyÂ . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoBBox. â—†Â DistFromInside(). Double_t TGeoEltu::DistFromInside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromInside_v(). void TGeoEltu::DistFromInside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside(). Double_t TGeoEltu::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside_v(). void TGeoEltu::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Divide(). TGeoVolume * TGeoEltu::Divide ; (; TGeoVolume *Â ; voldiv, . const char *Â ; divname, . Int_tÂ ; iaxis, . Int_tÂ ; ndiv, . Double_tÂ ; start, . Double_tÂ ; stepÂ . ). overridevirtual . Reimpleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoEltu.html:28489,safe,safe,28489,doc/master/classTGeoEltu.html,https://root.cern,https://root.cern/doc/master/classTGeoEltu.html,1,['safe'],['safe']
Safety,"TGeoBBox. â—†Â Contains(). Bool_t TGeoHype::Contains ; (; const Double_t *Â ; point); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Contains_v(). void TGeoHype::Contains_v ; (; const Double_t *Â ; points, . Bool_t *Â ; inside, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DeclFileName(). static const char * TGeoHype::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 92 of file TGeoHype.h. â—†Â DistancetoPrimitive(). Int_t TGeoHype::DistancetoPrimitive ; (; Int_tÂ ; px, . Int_tÂ ; pyÂ . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoBBox. â—†Â DistFromInside(). Double_t TGeoHype::DistFromInside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromInside_v(). void TGeoHype::DistFromInside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside(). Double_t TGeoHype::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside_v(). void TGeoHype::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistToHype(). Int_t TGeoHype::DistToHype ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Double_t *Â ; s, . Bool_tÂ ; inner, . Bool_tÂ ; inÂ . ); const. â—†Â Divide(). TGeoVolume * TGeoHype::Di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHype.html:29480,safe,safe,29480,doc/master/classTGeoHype.html,https://root.cern,https://root.cern/doc/master/classTGeoHype.html,1,['safe'],['safe']
Safety,"TGeoBBox.; Definition at line 64 of file TGeoParaboloid.h. â—†Â GetRhi(). Double_t TGeoParaboloid::GetRhi ; (; ); const. inline . Definition at line 57 of file TGeoParaboloid.h. â—†Â GetRlo(). Double_t TGeoParaboloid::GetRlo ; (; ); const. inline . Definition at line 56 of file TGeoParaboloid.h. â—†Â InspectShape(). void TGeoParaboloid::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â IsA(). TClass * TGeoParaboloid::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 78 of file TGeoParaboloid.h. â—†Â IsCylType(). Bool_t TGeoParaboloid::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 66 of file TGeoParaboloid.h. â—†Â MakeBuffer3D(). TBuffer3D * TGeoParaboloid::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â operator=(). TGeoParaboloid & TGeoParaboloid::operator= ; (; const TGeoParaboloid &Â ; ). privatedelete . â—†Â Safety(). Double_t TGeoParaboloid::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Safety_v(). void TGeoParaboloid::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â SavePrimitive(). void TGeoParaboloid::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. â—†Â SetDimensions(). void TGeoParaboloid::SetDimensions ; (; Double_t *Â ; param). overridevirtual . Reimplemented from TGeoBBox. â—†Â SetParaboloidDimensions(). void TGeoParaboloid::SetParaboloidDimensions ; (; Double_tÂ ; rlo, . Double_tÂ ; rhi, . Double_tÂ ; dzÂ . ). â—†Â SetPoints() [1/2]. void TGeoParaboloid::SetPoints ; (; Double_t *Â ; points); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â SetPoints() [2/2]. void TGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParaboloid.html:28320,Safe,Safety,28320,doc/master/classTGeoParaboloid.html,https://root.cern,https://root.cern/doc/master/classTGeoParaboloid.html,1,['Safe'],['Safety']
Safety,"TGeoCone(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = dz; param[1] = Rmin1; param[2] = Rmax1; param[3] = Rmin2; param[4] = Rmax2. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Computes capacity of the shape in [length^3]. ~TGeoCone(); destructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute dist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCone.html:14959,safe,safe,14959,root/html534/TGeoCone.html,https://root.cern,https://root.cern/root/html534/TGeoCone.html,3,['safe'],['safe']
Safety,"TGeoCone::GetRmin1 ; (; ); const. inlinevirtual . Definition at line 76 of file TGeoCone.h. â—†Â GetRmin2(). virtual Double_t TGeoCone::GetRmin2 ; (; ); const. inlinevirtual . Definition at line 78 of file TGeoCone.h. â—†Â InspectShape(). void TGeoCone::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. â—†Â IsA(). TClass * TGeoCone::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg.; Definition at line 96 of file TGeoCone.h. â—†Â IsCylType(). Bool_t TGeoCone::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 82 of file TGeoCone.h. â—†Â MakeBuffer3D(). TBuffer3D * TGeoCone::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. â—†Â operator=(). TGeoCone & TGeoCone::operator= ; (; const TGeoCone &Â ; ). protecteddelete . â—†Â Safety(). Double_t TGeoCone::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. â—†Â Safety_v(). void TGeoCone::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. â—†Â SafetyS(). static Double_t TGeoCone::SafetyS ; (; const Double_t *Â ; point, . Bool_tÂ ; in, . Double_tÂ ; dz, . Double_tÂ ; rmin1, . Double_tÂ ; rmax1, . Double_tÂ ; rmin2, . Double_tÂ ; rmax2, . Int_tÂ ; skipz = 0Â . ). static . â—†Â SavePrimitive(). void TGeoCone::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. â—†Â SetConeDimensions(). void TGeoCone::SetConeDimensions ; (; Double_tÂ ; dz, . Double_tÂ ; rmin1, . Double_tÂ ; rmax1, . Double_tÂ ; rmin2, . Double_tÂ ; rmax2Â . ). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCone.html:31415,Safe,Safety,31415,doc/master/classTGeoCone.html,https://root.cern,https://root.cern/doc/master/classTGeoCone.html,1,['Safe'],['Safety']
Safety,"TGeoCone::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg.; Definition at line 96 of file TGeoCone.h. â—†Â IsCylType(). Bool_t TGeoCone::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 82 of file TGeoCone.h. â—†Â MakeBuffer3D(). TBuffer3D * TGeoCone::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. â—†Â operator=(). TGeoCone & TGeoCone::operator= ; (; const TGeoCone &Â ; ). protecteddelete . â—†Â Safety(). Double_t TGeoCone::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. â—†Â Safety_v(). void TGeoCone::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. â—†Â SafetyS(). static Double_t TGeoCone::SafetyS ; (; const Double_t *Â ; point, . Bool_tÂ ; in, . Double_tÂ ; dz, . Double_tÂ ; rmin1, . Double_tÂ ; rmax1, . Double_tÂ ; rmin2, . Double_tÂ ; rmax2, . Int_tÂ ; skipz = 0Â . ). static . â—†Â SavePrimitive(). void TGeoCone::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. â—†Â SetConeDimensions(). void TGeoCone::SetConeDimensions ; (; Double_tÂ ; dz, . Double_tÂ ; rmin1, . Double_tÂ ; rmax1, . Double_tÂ ; rmin2, . Double_tÂ ; rmax2Â . ). â—†Â SetDimensions(). void TGeoCone::SetDimensions ; (; Double_t *Â ; param). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. â—†Â SetPoints() [1/2]. void TGeoCone::SetPoints ; (; Double_t *Â ; points); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. â—†Â SetPoints() [2/2]. void TGeoCone::SetPoints ; (; Float_t *Â ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCone.html:31793,Safe,SafetyS,31793,doc/master/classTGeoCone.html,https://root.cern,https://root.cern/doc/master/classTGeoCone.html,1,['Safe'],['SafetyS']
Safety,"TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); virtual~TGeoSubtraction(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoSubtraction.html:2381,safe,safe,2381,root/html528/TGeoSubtraction.html,https://root.cern,https://root.cern/root/html528/TGeoSubtraction.html,2,['safe'],['safe']
Safety,"TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the current point. TGeoNode * FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); Computes as fStep the distance to next daughter of the current volume.; The point and direction must be converted in the coordinate system of the current volume.; The proposed step limit is fStep. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNode(Bool_t safe_start = kTRUE); Returns deepest node containing current point. TGeoNode * FindNode(Double_t x, Double_t y, Double_t z); Returns deepest node containing current point. Double_t * FindNormalFast(); Computes fast norm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNavigator.html:14533,safe,safety,14533,root/html528/TGeoNavigator.html,https://root.cern,https://root.cern/root/html528/TGeoNavigator.html,12,"['Safe', 'safe']","['Safety', 'safety']"
Safety,"TGeoParallelWorld::StreamerNVirtual ; (; TBuffer &Â ; ClassDef_StreamerNVirtual_b). inline . Definition at line 184 of file TGeoParallelWorld.h. â—†Â TestVoxelGrid(). void TGeoParallelWorld::TestVoxelGrid ; (; ). private . Definition at line 1425 of file TGeoParallelWorld.cxx. â—†Â VoxelSafety(). double TGeoParallelWorld::VoxelSafety ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). private . Compute safety for the parallel world used BVH structure with addiditional on-the-fly 3D grid/voxel caching â€”> essentially an O(1) algorithm !) ; Definition at line 944 of file TGeoParallelWorld.cxx. Member Data Documentation. â—†Â fAccMode. AccelerationMode TGeoParallelWorld::fAccMode = AccelerationMode::kVoxelFinder. protected . to keep the vector of primitive axis aligned bounding boxes ; Definition at line 55 of file TGeoParallelWorld.h. â—†Â fBoundingBoxes. void* TGeoParallelWorld::fBoundingBoxes = nullptr. protected . stores bounding boxes serving a quick safety candidates (to be used with the VoxelGrid and SafetyVoxelInfo) ; Definition at line 54 of file TGeoParallelWorld.h. â—†Â fBVH. void* TGeoParallelWorld::fBVH = nullptr. protected . array of physical nodes ; Definition at line 49 of file TGeoParallelWorld.h. â—†Â fGeoManager. TGeoManager* TGeoParallelWorld::fGeoManager. protected . Definition at line 41 of file TGeoParallelWorld.h. â—†Â fIsClosed. Bool_t TGeoParallelWorld::fIsClosed. protected . Definition at line 44 of file TGeoParallelWorld.h. â—†Â fLastState. TGeoPhysicalNode* TGeoParallelWorld::fLastState. protected . helper volume ; Definition at line 46 of file TGeoParallelWorld.h. â—†Â fPaths. TObjArray* TGeoParallelWorld::fPaths. protected . Definition at line 42 of file TGeoParallelWorld.h. â—†Â fPhysical. TObjArray* TGeoParallelWorld::fPhysical. protected . Last PN touched. ; Definition at line 47 of file TGeoParallelWorld.h. â—†Â fSafetyCandidateStore. std::vector<unsigned int> TGeoParallelWorld::fSafetyCandidateStore {}. protected . A regular 3D cache layer for fast point-based s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:28129,safe,safety,28129,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,2,"['Safe', 'safe']","['SafetyVoxelInfo', 'safety']"
Safety,"TGeoShape::NormalPhi(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tTGeoBBox::Safety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidTGeoBBox::Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTGeoBBox::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFromFaceSet(TGLFaceSet* fs); voidTGeoShape::SetId(Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveGeoPolyShape.html:8671,Safe,Safety,8671,root/html534/TEveGeoPolyShape.html,https://root.cern,https://root.cern/root/html534/TEveGeoPolyShape.html,1,['Safe'],['Safety']
Safety,"TGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1(); dummy ctor. TGeoTrd1(Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(const char* name, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy; param[3] = dz. ~TGeoTrd1(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd1. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd1; Boundary safe algorithm. void GetVisibleCorner(const Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(const Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd1; Boundary safe algorithm. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd1 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Y divisions. For Z divisions just; retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrd1.html:13544,safe,safe,13544,root/html534/TGeoTrd1.html,https://root.cern,https://root.cern/root/html534/TGeoTrd1.html,6,['safe'],['safe']
Safety,"TGeoSphere::DistToSphere ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Double_tÂ ; rsph, . Bool_tÂ ; check = kTRUE, . Bool_tÂ ; firstcross = kTRUEÂ . ); const. â—†Â Divide(). TGeoVolume * TGeoSphere::Divide ; (; TGeoVolume *Â ; voldiv, . const char *Â ; divname, . Int_tÂ ; iaxis, . Int_tÂ ; ndiv, . Double_tÂ ; start, . Double_tÂ ; stepÂ . ). overridevirtual . Reimplemented from TGeoBBox. â—†Â GetAxisName(). const char * TGeoSphere::GetAxisName ; (; Int_tÂ ; iaxis); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â GetAxisRange(). Double_t TGeoSphere::GetAxisRange ; (; Int_tÂ ; iaxis, . Double_t &Â ; xlo, . Double_t &Â ; xhiÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â GetBoundingCylinder(). void TGeoSphere::GetBoundingCylinder ; (; Double_t *Â ; param); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â GetBuffer3D(). const TBuffer3D & TGeoSphere::GetBuffer3D ; (; Int_tÂ ; reqSections, . Bool_tÂ ; localFrameÂ . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoBBox. â—†Â GetByteCount(). Int_t TGeoSphere::GetByteCount ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 65 of file TGeoSphere.h. â—†Â GetMakeRuntimeShape(). TGeoShape * TGeoSphere::GetMakeRuntimeShape ; (; TGeoShape *Â ; , . TGeoMatrix *Â ; Â . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 66 of file TGeoSphere.h. â—†Â GetMeshNumbers(). void TGeoSphere::GetMeshNumbers ; (; Int_t &Â ; nvert, . Int_t &Â ; nsegs, . Int_t &Â ; npolsÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â GetNmeshVertices(). Int_t TGeoSphere::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â GetNumberOfDivisions(). Int_t TGeoSphere::GetNumberOfDivisions ; (; ); const. inline . Definition at line 69 of file TGeoSphere.h. â—†Â GetNz(). Int_t TGeoSphere::GetNz ; (; ); const. inline . Definition at line 71 of file TGeoSphere.h. â—†Â GetPhi1(). Double_t TGeoSphe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSphere.html:27476,avoid,avoid,27476,doc/master/classTGeoSphere.html,https://root.cern,https://root.cern/doc/master/classTGeoSphere.html,1,['avoid'],['avoid']
Safety,"TGeoTube::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg.; Definition at line 91 of file TGeoTube.h. â—†Â IsCylType(). Bool_t TGeoTube::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 77 of file TGeoTube.h. â—†Â MakeBuffer3D(). TBuffer3D * TGeoTube::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. â—†Â operator=(). TGeoTube & TGeoTube::operator= ; (; const TGeoTube &Â ; ). protecteddelete . â—†Â Safety(). Double_t TGeoTube::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. â—†Â Safety_v(). void TGeoTube::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. â—†Â SafetyS(). static Double_t TGeoTube::SafetyS ; (; const Double_t *Â ; point, . Bool_tÂ ; in, . Double_tÂ ; rmin, . Double_tÂ ; rmax, . Double_tÂ ; dz, . Int_tÂ ; skipz = 0Â . ). static . â—†Â SavePrimitive(). void TGeoTube::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. â—†Â SetDimensions(). void TGeoTube::SetDimensions ; (; Double_t *Â ; param). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. â—†Â SetPoints() [1/2]. void TGeoTube::SetPoints ; (; Double_t *Â ; points); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. â—†Â SetPoints() [2/2]. void TGeoTube::SetPoints ; (; Float_t *Â ; points); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. â—†Â SetSegsAndPols(). void TGeoTube::SetSegsAndPols ; (; TBuffer3D &Â ; buff); const. overridevirtual . Reimpl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTube.html:30865,Safe,SafetyS,30865,doc/master/classTGeoTube.html,https://root.cern,https://root.cern/doc/master/classTGeoTube.html,1,['Safe'],['SafetyS']
Safety,"TH2&, Int_t bin_x); TMVA::ToolsTools(). Data Members; public:. TMVA::MsgLogger*fLogger; const TStringfRegexp; TXMLEngine*fXMLEngine; static atomic<TMVA::Tools*>fgTools; static TMVA::Tools::ECitationkBibTeX; static TMVA::Tools::EWelcomeMessagekBlockWelcomeMsg; static TMVA::Tools::ECitationkHtmlLink; static TMVA::Tools::EWelcomeMessagekIsometricWelcomeMsg; static TMVA::Tools::ECitationkLaTeX; static TMVA::Tools::EWelcomeMessagekLeanWelcomeMsg; static TMVA::Tools::EWelcomeMessagekLogoWelcomeMsg; static TMVA::Tools::EWelcomeMessagekOriginalWelcomeMsgBW; static TMVA::Tools::EWelcomeMessagekOriginalWelcomeMsgColor; static TMVA::Tools::ECitationkPlainText; static TMVA::Tools::EWelcomeMessagekSmall1WelcomeMsg; static TMVA::Tools::EWelcomeMessagekSmall2WelcomeMsg; static TMVA::Tools::EWelcomeMessagekStandardWelcomeMsg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMVA::Tools& Instance(). void DestroyInstance(); NOTE: there is no thread safe way to do this so; one must only call this method ones in an executable. Tools(); constructor. ~Tools(); destructor. Double_t NormVariable(Double_t x, Double_t xmin, Double_t xmax); normalise to output range: [-1, 1]. Double_t GetSeparation(TH1* S, TH1* B) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S(x) - B(x))^2/(S(x) + B(x)) dx }. Double_t GetSeparation(const TMVA::PDF& pdfS, const TMVA::PDF& pdfB) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S(x) - B(x))2/(S(x) + B(x)) dx }. void ComputeStat(const vector<TMVA::Event*>& , vector<Float_t>* , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Int_t signalClass, Bool_t norm = kFALSE); sanity check. TMatrixD* GetSQRootMatrix(TMatrixDSym* symMat); square-root of symmetric matrix; of course the resulting sqrtMat is also symmetric, but it's easier to; treat it as a general matrix. const TMatrixD* GetCorrelationMatrix(const TMatrixD* covMat); turns covariance into correlation matr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__Tools.html:5892,safe,safe,5892,root/html602/TMVA__Tools.html,https://root.cern,https://root.cern/root/html602/TMVA__Tools.html,2,['safe'],['safe']
Safety,"TING:; : ; : â›[1mGDPathEveFrac â›[0m: fraction of events in path evaluation; : Increasing this fraction will improve the path; : finding. However, a too high value will give few; : unique events available for error estimation.; : It is recommended to use the default = 0.5.; : â›[1mGDTau â›[0m: cutoff parameter tau; : By default this value is set to -1.0.; : This means that the cut off parameter is; : automatically estimated. In most cases; : this should be fine. However, you may want; : to fix this value if you already know it; : and want to reduce on training time.; : â›[1mGDTauPrec â›[0m: precision of estimated tau; : Increase this precision to find a more; : optimum cut-off parameter.; : â›[1mGDNStep â›[0m: number of steps in path search; : If the number of steps is too small, then; : the program will give a warning message.; : ; : III. WARNING MESSAGES; : ; : â›[1mRisk(i+1)>=Risk(i) in pathâ›[0m; : â›[1mChaotic behaviour of risk evolution.â›[0m; : The error rate was still decreasing at the end; : By construction the Risk should always decrease.; : However, if the training sample is too small or; : the model is overtrained, such warnings can; : occur.; : The warnings can safely be ignored if only a; : few (<3) occur. If more warnings are generated,; : the fitting fails.; : A remedy may be to increase the value; : â›[1mGDValidEveFracâ›[0m to 1.0 (or a larger value).; : In addition, if â›[1mGDPathEveFracâ›[0m is too high; : the same warnings may occur since the events; : used for error estimation are also used for; : path estimation.; : Another possibility is to modify the model - ; : See above on tuning the rule ensemble.; : ; : â›[1mThe error rate was still decreasing at the end of the pathâ›[0m; : Too few steps in path! Increase â›[1mGDNStepsâ›[0m.; : ; : â›[1mReached minimum early in the searchâ›[0m; : Minimum was found early in the fitting. This; : may indicate that the used step size â›[1mGDStepâ›[0m.; : was too large. Reduce it and rerun.; : If the results still are not OK, modify",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:56110,Risk,Risk,56110,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['Risk'],['Risk']
Safety,"TKey() [5/9]. TKey::TKey ; (; const char *Â ; name, . const char *Â ; title, . const TClass *Â ; cl, . Int_tÂ ; nbytes, . TDirectory *Â ; motherDirÂ . ). Create a TKey object with the specified name, title for the given class. ; WARNING: in name avoid special characters like '^','$','.' that are used by the regular expression parser (see TRegexp). ; Definition at line 191 of file TKey.cxx. â—†Â TKey() [6/9]. TKey::TKey ; (; const TString &Â ; name, . const TString &Â ; title, . const TClass *Â ; cl, . Int_tÂ ; nbytes, . TDirectory *Â ; motherDirÂ . ). Create a TKey object with the specified name, title for the given class. ; WARNING: in name avoid special characters like '^','$','.' that are used by the regular expression parser (see TRegexp). ; Definition at line 207 of file TKey.cxx. â—†Â TKey() [7/9]. TKey::TKey ; (; const TObject *Â ; obj, . const char *Â ; name, . Int_tÂ ; bufsize, . TDirectory *Â ; motherDirÂ . ). Create a TKey object for a TObject* and fill output buffer. ; WARNING: in name avoid special characters like '^','$','.' that are used by the regular expression parser (see TRegexp). ; Definition at line 223 of file TKey.cxx. â—†Â TKey() [8/9]. TKey::TKey ; (; const void *Â ; obj, . const TClass *Â ; cl, . const char *Â ; name, . Int_tÂ ; bufsize, . TDirectory *Â ; motherDirÂ . ). Create a TKey object for any object obj of class cl d and fill output buffer. ; WARNING: in name avoid special characters like '^','$','.' that are used by the regular expression parser (see TRegexp). ; Definition at line 298 of file TKey.cxx. â—†Â TKey() [9/9]. TKey::TKey ; (; Long64_tÂ ; pointer, . Int_tÂ ; nbytes, . TDirectory *Â ; motherDir = nullptrÂ . ). Create a TKey object to read keys. ; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile. A TKey object is created to read the keys structure itself. ; Definition at line 175 of file TKey.cxx. â—†Â ~TKey(). TKey::~TKey ; (; ). override . TKey default destructor. ; Definition at line 526 of file TKey.cxx. Member Function Documentation. â—†Â Browse(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKey.html:19011,avoid,avoid,19011,doc/master/classTKey.html,https://root.cern,https://root.cern/doc/master/classTKey.html,1,['avoid'],['avoid']
Safety,"TKey.cxx. â—†Â TKey() [3/9]. TKey::TKey ; (; TDirectory *Â ; motherDir). TKey default constructor. ; Definition at line 99 of file TKey.cxx. â—†Â TKey() [4/9]. TKey::TKey ; (; TDirectory *Â ; motherDir, . const TKey &Â ; orig, . UShort_tÂ ; pidOffsetÂ . ). Copy a TKey from its original directory to the new 'motherDir'. ; Definition at line 111 of file TKey.cxx. â—†Â TKey() [5/9]. TKey::TKey ; (; const char *Â ; name, . const char *Â ; title, . const TClass *Â ; cl, . Int_tÂ ; nbytes, . TDirectory *Â ; motherDirÂ . ). Create a TKey object with the specified name, title for the given class. ; WARNING: in name avoid special characters like '^','$','.' that are used by the regular expression parser (see TRegexp). ; Definition at line 191 of file TKey.cxx. â—†Â TKey() [6/9]. TKey::TKey ; (; const TString &Â ; name, . const TString &Â ; title, . const TClass *Â ; cl, . Int_tÂ ; nbytes, . TDirectory *Â ; motherDirÂ . ). Create a TKey object with the specified name, title for the given class. ; WARNING: in name avoid special characters like '^','$','.' that are used by the regular expression parser (see TRegexp). ; Definition at line 207 of file TKey.cxx. â—†Â TKey() [7/9]. TKey::TKey ; (; const TObject *Â ; obj, . const char *Â ; name, . Int_tÂ ; bufsize, . TDirectory *Â ; motherDirÂ . ). Create a TKey object for a TObject* and fill output buffer. ; WARNING: in name avoid special characters like '^','$','.' that are used by the regular expression parser (see TRegexp). ; Definition at line 223 of file TKey.cxx. â—†Â TKey() [8/9]. TKey::TKey ; (; const void *Â ; obj, . const TClass *Â ; cl, . const char *Â ; name, . Int_tÂ ; bufsize, . TDirectory *Â ; motherDirÂ . ). Create a TKey object for any object obj of class cl d and fill output buffer. ; WARNING: in name avoid special characters like '^','$','.' that are used by the regular expression parser (see TRegexp). ; Definition at line 298 of file TKey.cxx. â—†Â TKey() [9/9]. TKey::TKey ; (; Long64_tÂ ; pointer, . Int_tÂ ; nbytes, . TDirectory *Â ; motherDir = nullptrÂ . ). Cre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKey.html:18656,avoid,avoid,18656,doc/master/classTKey.html,https://root.cern,https://root.cern/doc/master/classTKey.html,1,['avoid'],['avoid']
Safety,"TMVA/MsgLogger.h""; 43#include ""TMVA/Types.h""; 44 ; 45#include ""TObjString.h""; 46#include ""TMath.h""; 47#include ""TString.h""; 48#include ""TTree.h""; 49#include ""TLeaf.h""; 50#include ""TH1.h""; 51#include ""TH2.h""; 52#include ""TList.h""; 53#include ""TSpline.h""; 54#include ""TVector.h""; 55#include ""TMatrixD.h""; 56#include ""TMatrixDSymEigen.h""; 57#include ""TVectorD.h""; 58#include ""TTreeFormula.h""; 59#include ""TXMLEngine.h""; 60#include ""TROOT.h""; 61 ; 62#include <algorithm>; 63#include <cstdlib>; 64#include <iomanip>; 65 ; 66using std::vector, std::setw, std::istream, std::ostream;; 67 ; 68std::atomic<TMVA::Tools*> TMVA::Tools::fgTools{0};; 69 ; 70TMVA::Tools& TMVA::gTools() { return TMVA::Tools::Instance(); }; 71TMVA::Tools& TMVA::Tools::Instance() {; 72 if(!fgTools) {; 73 Tools* tmp = new Tools();; 74 Tools* expected = 0;; 75 if(! fgTools.compare_exchange_strong(expected,tmp)) {; 76 //another thread beat us; 77 delete tmp;; 78 }; 79 }; 80 return *fgTools;; 81}; 82void TMVA::Tools::DestroyInstance() {; 83 //NOTE: there is no thread safe way to do this so; 84 // one must only call this method ones in an executable; 85 if (fgTools != 0) { delete fgTools.load(); fgTools=0; }; 86}; 87 ; 88////////////////////////////////////////////////////////////////////////////////; 89/// constructor; 90 ; 91TMVA::Tools::Tools() :; 92 fRegexp(""$&|!%^&()'<>?= ""),; 93 fLogger(new MsgLogger(""Tools"")),; 94 fXMLEngine(new TXMLEngine()); 95{; 96}; 97 ; 98////////////////////////////////////////////////////////////////////////////////; 99/// destructor; 100 ; 101TMVA::Tools::~Tools(); 102{; 103 delete fLogger;; 104 delete fXMLEngine;; 105}; 106 ; 107////////////////////////////////////////////////////////////////////////////////; 108/// normalise to output range: [-1, 1]; 109 ; 110Double_t TMVA::Tools::NormVariable( Double_t x, Double_t xmin, Double_t xmax ); 111{; 112 return 2*(x - xmin)/(xmax - xmin) - 1.0;; 113}; 114 ; 115/////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:2711,safe,safe,2711,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['safe'],['safe']
Safety,"TMath::Max( (UInt_t)V[ivar].Length(), maxL );; 902 maxL = TMath::Max( (UInt_t)titleVars.Length(), maxL );; 903 ; 904 // column length; 905 UInt_t maxV = 7;; 906 maxV = TMath::Max( (UInt_t)titleValues.Length() + 1, maxL );; 907 ; 908 // full column length; 909 UInt_t clen = maxL + maxV + 3;; 910 ; 911 // bar line; 912 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 913 logger << Endl;; 914 ; 915 // title bar; 916 logger << setw(maxL) << titleVars << "":"";; 917 logger << setw(maxV+1) << titleValues << "":"";; 918 logger << Endl;; 919 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 920 logger << Endl;; 921 ; 922 // the numbers; 923 for (UInt_t irow=0; irow<nvar; irow++) {; 924 logger << setw(maxL) << V[irow] << "":"";; 925 logger << setw(maxV+1) << Form( format.Data(), values[irow] );; 926 logger << Endl;; 927 }; 928 ; 929 // bar line; 930 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 931 logger << Endl;; 932}; 933 ; 934////////////////////////////////////////////////////////////////////////////////; 935/// formatted output of matrix (with labels); 936 ; 937void TMVA::Tools::FormattedOutput( const TMatrixD& M, const std::vector<TString>& V, MsgLogger& logger ); 938{; 939 // sanity check: matrix must be quadratic; 940 UInt_t nvar = V.size();; 941 if ((UInt_t)M.GetNcols() != nvar || (UInt_t)M.GetNrows() != nvar) {; 942 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 943 << M.GetNcols() << "" OR "" << M.GetNrows() << "" != "" << nvar << "" ==> abort"" << Endl;; 944 }; 945 ; 946 // get length of each variable, and maximum length; 947 UInt_t minL = 7;; 948 UInt_t maxL = minL;; 949 std::vector<UInt_t> vLengths;; 950 for (UInt_t ivar=0; ivar<nvar; ivar++) {; 951 vLengths.push_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:32435,sanity check,sanity check,32435,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['sanity check'],['sanity check']
Safety,"TObjArray*TGenCollectionProxy::fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*TGenCollectionProxy::fResizeContainer accessors: resize container; intTGenCollectionProxy::fSTL_typeSTL container type; TGenCollectionProxy::MethodTGenCollectionProxy::fSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >TGenCollectionProxy::fStagedOptimization: Keep staged array once they were created; type_info&TGenCollectionProxy::fTypeinfoType information; TGenCollectionProxy::Value*TGenCollectionProxy::fValDescriptor of the Value_type; intTGenCollectionProxy::fValDiffOffset between two consecutive value_types (memory layout).; intTGenCollectionProxy::fValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*TGenCollectionProxy::fValueDescriptor of the container value type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenCollectionProxy* InitializeEx(); Some hack to avoid const-ness. void ReadItems(int nElements, TBuffer& b); Object input streamer. void WriteItems(int nElements, TBuffer& b); Object output streamer. void Shrink(UInt_t nCurr, UInt_t left, Bool_t force); Shrink the container. void Expand(UInt_t nCurr, UInt_t left); Expand the container. TVirtualCollectionProxy* Generate() const; Virtual copy constructor. TEmulatedCollectionProxy(const TEmulatedCollectionProxy& copy); Copy constructor. TEmulatedCollectionProxy(const char* cl_name); Initializing constructor. virtual ~TEmulatedCollectionProxy(); Standard destructor. void* New() const; Virtual constructor. { return new Cont_t; }. void* New(void* memory) const; Virtual in-place constructor. { return new(memory) Cont_t; }. void* NewArray(Int_t nElements) const; Virtual array constructor. { return new Cont_t[nElements]; }. void* NewArray(Int_t nElements, void* memory) const; Virtual in-place constructor. { return new(memory) Cont_t[nElements]; }. void Destructor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEmulatedCollectionProxy.html:7000,avoid,avoid,7000,root/html528/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html528/TEmulatedCollectionProxy.html,2,['avoid'],['avoid']
Safety,"TObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TEventIterObj&operator=(const TEventIterObj&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTEventIter::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEventIterObj.html:4503,abort,abort,4503,root/html528/TEventIterObj.html,https://root.cern,https://root.cern/root/html528/TEventIterObj.html,1,['abort'],['abort']
Safety,"TObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoParaboloid&operator=(const TGeoParaboloid&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetParaboloidDi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoParaboloid.html:8976,safe,safe,8976,root/html534/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html,1,['safe'],['safe']
Safety,"TObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tTGeoBBox::Safety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidTGeoBBox::Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTGeoBBox::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFromFaceSet(TGLFaceSet* fs); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGeoBBo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveGeoPolyShape.html:8820,Safe,SafetyPhi,8820,root/html602/TEveGeoPolyShape.html,https://root.cern,https://root.cern/root/html602/TEveGeoPolyShape.html,2,['Safe'],['SafetyPhi']
Safety,"TObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVirtualProofPlayer(); TVirtualProofPlayer(const TVirtualProofPlayer&); virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualProofPlayer.html:10107,timeout,timeout,10107,root/html604/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html604/TVirtualProofPlayer.html,1,['timeout'],['timeout']
Safety,"TObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerRemote(TProof* proof = 0); TProofPlayerRemote(const TProofPlayerRemote&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerRemote.html:11343,abort,abort,11343,root/html604/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html604/TProofPlayerRemote.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"TObject::SetUniqueID(UInt_t uid); virtual voidShowCache(Bool_t all = kFALSE); virtual voidShowData(); voidShowDataSet(const char* dataset = """", const char* opt = ""filter:SsCc""); virtual voidShowDataSetCache(const char* dataset = 0); voidShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* optStr = """"); voidShowEnabledPackages(Bool_t all = kFALSE); voidShowFeedback() const; voidShowLog(Int_t qry = -1); voidShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp) const; voidShowMissingFiles(TQueryResult* qr = 0); voidShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidShowParameters(const char* wildcard = ""PROOF_*"") const; voidShowQueries(Option_t* opt = """"); virtual voidShowStagingStatusDataSet(const char* dataset, const char* optStr = ""filter:SsCc""); virtual Int_tTNamed::Sizeof() const; voidStartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTouch(); TProof(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Int_tUploadDataSet(const char*, TList*, const char* = 0, Int_t = 0, TList* = 0); Int_tUploadDataSet(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tUploadDataSetFromFile(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tUploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar, TList* workers = 0); virtual voidTObject::UseCurrentStyle(); Bool_tUseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:17396,timeout,timeout,17396,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,2,['timeout'],['timeout']
Safety,"TObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TEveHit(); TEveHit(const TEveHit&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. UShort_tfDetIdCustom detector id.; Int_tfEvaLabelLabel of primary particle, ancestor of label.; Int_tfLabelLabel of particle that produced the hit.; UShort_tfSubdetIdCustom sub-detector id.; TEveVectorfVHit position.; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveMCTrack& operator=(const TEveHit& ); { *((TParticle*)this) = p; return *this; }. TEveHit(); Float_t charge; probably specifi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveHit.html:4969,detect,detector,4969,root/html602/TEveHit.html,https://root.cern,https://root.cern/root/html602/TEveHit.html,2,['detect'],['detector']
Safety,"TObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidFill(); voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TListTHtml::TFileSysDir::fDirs; TListTHtml::TFileSysDir::fFiles; Int_tTHtml::TFileSysEntry::fLevellevel of directory; TStringTHtml::TFileSysEntry::fNamename of the element; THtml::TFileSysDir*THtml::TFileSysEntry::fParentparent directory. private:. THashTablefEntrieshash map of all filenames without paths; TStringfIgnorePathregexp of path to ignore while building entry tree; TExMapfMapInoinode to TFileSysDir map, to detect softlinks; Int_tfMaxLevelmaximum level of directory nesting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileSysDB(const char* path, const char* ignr, Int_t maxdirlevel); { Fill(); }. TExMap& GetMapIno(); { return fMapIno; }. THashTable& GetEntries(); { return fEntries; }. const TString& GetIgnore() const; { return fIgnorePath; }. Int_t GetMaxLevel() const; { return fMaxLevel; }. void Fill(). TString fInputPath; // directories to look for classes; prepended to Decl/ ImplFileName(). Â» Author: Nenad Buncic 18/10/95 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/html:$Id$ Â» Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THtml__TFileSysDB.html:6466,detect,detect,6466,root/html534/THtml__TFileSysDB.html,https://root.cern,https://root.cern/root/html534/THtml__TFileSysDB.html,1,['detect'],['detect']
Safety,"TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_t_allRRVAll contents are RRV; RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents.; TNamed*_structureTag! Structure tag; TNamed*_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCollection(); Default constructor. RooAbsCollection(const char* name); Empty collection constructor. RooAbsCollection(const RooAbsCollection& other, const char* name = """"); Copy constructor. Note that a copy of a collection is always non-owning,; even the source collection is owning. To create an owning copy of; a collection (owning or not), use the snaphot() method. ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCollection.html:11677,safe,safeDeleteList,11677,root/html602/RooAbsCollection.html,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html,4,['safe'],"['safe', 'safeDeleteList']"
Safety,"TObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); Double_t&TGeoPcon::Phi1(); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); Double_t&TGeoPcon::Rmax(Int_t ipl); Double_t&TGeoPcon::Rmin(Int_t ipl); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToSegment(const Double_t* point, Int_t ipl, Int_t iphi, Bool_t in, Double_t safphi, Double_t safmin = TGeoShape::Big()) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPgon.html:9303,Safe,SafetyPhi,9303,root/html534/TGeoPgon.html,https://root.cern,https://root.cern/root/html534/TGeoPgon.html,1,['Safe'],['SafetyPhi']
Safety,"TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; Bool_tProcessEvents(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTTimer::Remove(); virtual voidTSysEvtHandler::Removed()SIGNAL ; voidTTimer::Reset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTTimer::SetCommand(const char* command); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTTimer::SetInterruptSyscalls(Bool_t set = kTRUE); voidTTimer::SetObject(TObject* object); static voidTObject::SetObjectStat(Bool_t stat); voidTTimer::SetTime(Long_t milliSec); voidTTimer::SetTimerID(UInt_t id = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); static voidTTimer::SingleShot(Int_t milliSec, const char* receiver_class, void* receiver, const char* method); virtual voidTTimer::Start(Long_t milliSec = -1, Bool_t singleShot = kFALSE); virtual voidTTimer::Stop(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTTimer::Timeout()SIGNAL ; virtual voidTTimer::TurnOff()SIGNAL ; virtual voidTTimer::TurnOn()SIGNAL ; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProcessEventTimer.html:8740,Timeout,Timeout,8740,root/html534/TProcessEventTimer.html,https://root.cern,https://root.cern/root/html534/TProcessEventTimer.html,1,['Timeout'],['Timeout']
Safety,"TProof::ShowDataSet(const char* dataset = """", const char* opt = ""filter:SsCc""); virtual voidTProof::ShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidTProof::ShowDataSets(const char* uri = """", const char* optStr = """"); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp) const; voidTProof::ShowMissingFiles(TQueryResult* qr = 0); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual voidTProof::ShowStagingStatusDataSet(const char* dataset, const char* optStr = ""filter:SsCc""); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); TProofCondor(const TProofCondor&); TProofCondor(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Int_tTProof::UploadDataSet(const char*, TList*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadDataSet(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadDataSetFromFile(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar, TList* workers = 0); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tTProof::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofCondor.html:19023,abort,abort,19023,root/html602/TProofCondor.html,https://root.cern,https://root.cern/root/html602/TProofCondor.html,2,['abort'],['abort']
Safety,"TProof::ShowDataSet(const char* dataset = """", const char* opt = ""filter:SsCc""); virtual voidTProof::ShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidTProof::ShowDataSets(const char* uri = """", const char* optStr = """"); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp) const; voidTProof::ShowMissingFiles(TQueryResult* qr = 0); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual voidTProof::ShowStagingStatusDataSet(const char* dataset, const char* optStr = ""filter:SsCc""); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); TProofSuperMaster(const TProofSuperMaster&); TProofSuperMaster(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Int_tTProof::UploadDataSet(const char*, TList*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadDataSet(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadDataSetFromFile(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar, TList* workers = 0); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofSuperMaster.html:18858,abort,abort,18858,root/html602/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html602/TProofSuperMaster.html,2,['abort'],['abort']
Safety,"TProofPlayer::RemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidTProofPlayer::RestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayerSuperMaster.html:10973,timeout,timeout,10973,root/html528/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html528/TProofPlayerSuperMaster.html,3,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"TQueryResult* qr); virtual voidTProofPlayer::RemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidTProofPlayer::RestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofPlayerSuperMaster.html:11101,timeout,timeout,11101,root/html530/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html530/TProofPlayerSuperMaster.html,6,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"TQueryResult; TStatus*fSelStatus! status of query in progress; TSelector*fSelector! the latest selector; TClass*fSelectorClass! class of the latest selector; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TTimer*fStopTimerTimer associated with a stop request; TMutex*fStopTimerMtxTo protect the stop timer; Long64_tfTotalEventsnumber of events requested; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static THashList*fgDrawInputParsList of input parameters to be kept on drawing actions. private:. TList*fAutoBinsMap of min/max values by name for slaves. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofPlayer(TProof* proof = 0); Default ctor. ~TProofPlayer(); Destructor. void SetProcessing(Bool_t on = kTRUE); Set processing bit according to 'on'. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop the process after this event. If timeout is positive, start; a timer firing after timeout seconds to hard-stop time-expensive; events. void SetDispatchTimer(Bool_t on = kTRUE); Enable/disable the timer to dispatch pening events while processing. void SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); Enable/disable the timer to stop/abort processing.; The 'timeout' is in seconds. void AddQueryResult(TQueryResult* q); Add query result to the list, making sure that there are no; duplicates. void RemoveQueryResult(const char* ref); Remove all query result instances referenced 'ref' from; the list of results. TQueryResult * GetQueryResult(const char* ref); Get query result instances referenced 'ref' from; the list of results. void SetCurrentQuery(TQueryResult* q); Set current query and save previous value. void AddInput(TObject* inp); Add object to input list. void ClearInput(); Clear input list. TObject * GetOutput(const char* name) const; Get output object by name. TList * GetOutputList() const; Get output list. Int_t ReinitSelector(TQueryResul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayer.html:14165,timeout,timeout,14165,root/html528/TProofPlayer.html,https://root.cern,https://root.cern/root/html528/TProofPlayer.html,6,['timeout'],['timeout']
Safety,"TRUE then; the timer is synchronous else a-synchronous. The default is synchronous.; Add a timer to the system eventloop by calling TurnOn().; The interpreter will execute command from Notify(). Bool_t CheckTimer(const TTime& now); Check if timer timed out. Bool_t Notify(); Notify when timer times out. The timer is always reset. To stop; the timer call TurnOff(). Make sure to call Reset() also in derived; Notify() so timers will keep working repeatedly. void Reset(); Reset the timer. void SetCommand(const char* command); Set the interpreter command to be executed at time out. Removes the; object to be notified (if it was set). void SetObject(TObject* object); Set the object to be notified at time out. Removes the command to; be executed (if it was set). void SetInterruptSyscalls(Bool_t set = kTRUE); When the argument is true the a-synchronous timer (SIGALRM) signal; handler is set so that interrupted syscalls will not be restarted; by the kernel. This is typically used in case one wants to put a; timeout on an I/O operation. By default interrupted syscalls will; be restarted. void Start(Long_t milliSec = -1, Bool_t singleShot = kFALSE); Starts the timer with a milliSec timeout. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTimer.html:13528,timeout,timeout,13528,root/html534/TTimer.html,https://root.cern,https://root.cern/root/html534/TTimer.html,3,['timeout'],['timeout']
Safety,"TRUE); virtual Int_tTProofPlayer::ReinitSelector(TQueryResult* qr); virtual voidTProofPlayer::RemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidTProofPlayer::RestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayerRemote.html:10666,abort,abort,10666,root/html528/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html528/TProofPlayerRemote.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"TSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TTimer; 13#define ROOT_TTimer; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TTimer //; 19// //; 20// Handles synchronous and a-synchronous timer events. You can use //; 21// this class in one of the following ways: //; 22// - Sub-class TTimer and override the Notify() method. //; 23// - Re-implement the TObject::HandleTimer() method in your class //; 24// and pass a pointer to this object to timer, see the SetObject() //; 25// method. //; 26// - Pass an interpreter command to timer, see SetCommand() method. //; 27// - Create a TTimer, connect its Timeout() signal to the //; 28// appropriate methods. Then when the time is up it will emit a //; 29// Timeout() signal and call connected slots. //; 30// //; 31// Minimum timeout interval is defined in TSystem::ESysConstants as //; 32// kItimerResolution (currently 10 ms). //; 33// //; 34// Signal/slots example: //; 35// TTimer *timer = new TTimer(); //; 36// timer->Connect(""Timeout()"", ""myObjectClassName"", //; 37// myObject, ""TimerDone()""); //; 38// timer->Start(2000, kTRUE); // 2 seconds single-shot //; 39// //; 40// // Timeout signal is emitted repeadetly with minimum timeout //; 41// // timer->Start(0, kFALSE); //; 42// //; 43//////////////////////////////////////////////////////////////////////////; 44 ; 45#include ""TSysEvtHandler.h""; 46#include ""TTime.h""; 47#include ""TString.h""; 48 ; 49 ; 50 ; 51class TTimer : public TSysEvtHandler {; 52 ; 53protected:; 54 TTime fTime; // time out time in ms; 55 TTime fAbsTime; // absolute time out time in ms; 56 Bool_t fTimeout; // true if timer has timed out; 57 Bool_t fSync; // true if synchrounous timer; 58 Bool_t fIntSyscalls; // true is a-synchronous timer is to interrupt system calls; 59 UInt_t fTimeID; // the system ID of this timer (for WIN32",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8h_source.html:1413,timeout,timeout,1413,doc/master/TTimer_8h_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8h_source.html,1,['timeout'],['timeout']
Safety,"TSelectorEntries.h. â—†Â Notify(). bool TSelectorEntries::Notify ; (; ). overridevirtual . This function is called at the first entry of a new tree in a chain. ; Reimplemented from TSelector.; Definition at line 136 of file TSelectorEntries.cxx. â—†Â Process(). bool TSelectorEntries::Process ; (; Long64_tÂ ; entry). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either TSelectorEntries::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used. ; Reimplemented from TSelector.; Definition at line 161 of file TSelectorEntries.cxx. â—†Â SetObject(). void TSelectorEntries::SetObject ; (; TObject *Â ; obj). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 54 of file TSelectorEntries.h. â—†Â SetOption(). void TSelectorEntries::SetOption ; (; const char *Â ; option). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 53 of file TSelectorEntries.h. â—†Â SetSelection(). void TSelectorEntries::SetSelection ; (; const char *Â ; selection). virtual . Set the selection expression. ; Definition at line 198 of file TSelectorEntries.cxx. â—†Â SlaveBegin(). void TSelectorEntries::SlaveBegin ; (; TTree *Â ; tree). overridevirtual . The SlaveBegin() function is called after the Begin() function. ; When running with PROOF SlaveBegin() is called on each slave server. The tree argument is depr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelectorEntries.html:18280,Abort,Abort,18280,doc/master/classTSelectorEntries.html,https://root.cern,https://root.cern/doc/master/classTSelectorEntries.html,1,['Abort'],['Abort']
Safety,"TSocket copy ctor. ; Â ; Â TSocket (Int_t descriptor); Â Create a socket. ; Â ; Â TSocket (Int_t descriptor, const char *sockpath); Â Create a socket. ; Â ; Â TSocket (TInetAddress address, const char *service, Int_t tcpwindowsize=-1); Â Create a socket. ; Â ; Â TSocket (TInetAddress address, Int_t port, Int_t tcpwindowsize=-1); Â Create a socket. ; Â ; virtualÂ ~TSocket (); Â ; UInt_tÂ GetBytesRecv () const; Â ; UInt_tÂ GetBytesSent () const; Â ; Int_tÂ GetCompressionAlgorithm () const; Â ; Int_tÂ GetCompressionLevel () const; Â ; Int_tÂ GetCompressionSettings () const; Â ; Int_tÂ GetErrorCode () const; Â Returns error code. ; Â ; TInetAddressÂ GetInetAddress () const; Â ; TTimeStampÂ GetLastUsage (); Â ; virtual Int_tÂ GetLocalPort (); Â Return the local port # to which the socket is bound. ; Â ; Int_tÂ GetPort () const; Â ; Int_tÂ GetRemoteProtocol () const; Â ; TSecContext *Â GetSecContext () const; Â ; const char *Â GetService () const; Â ; Int_tÂ GetServType () const; Â ; Int_tÂ GetTcpWindowSize () const; Â ; const char *Â GetUrl () const; Â ; TClass *Â IsA () const override; Â ; virtual Bool_tÂ IsAuthenticated () const; Â ; virtual Int_tÂ Reconnect (); Â ; virtual Int_tÂ Select (Int_t interest=kRead, Long_t timeout=-1); Â Waits for this socket to change status. ; Â ; virtual Int_tÂ SendObject (const TObject *obj, Int_t kind=kMESS_OBJECT); Â Send an object. ; Â ; voidÂ SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal); Â See comments for function SetCompressionSettings. ; Â ; voidÂ SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin); Â See comments for function SetCompressionSettings. ; Â ; voidÂ SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault); Â Used to specify the compression level and algorithm: settings = 100 * algorithm + level. ; Â ; voidÂ SetRemoteProtocol (Int_t rproto); Â ; voidÂ SetSecContext (TSecContext *ctx); Â ; voidÂ SetService (const char *service); Â ; voidÂ SetServType (Int_t st); Â ; voidÂ SetUrl (const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPSocket.html:4379,timeout,timeout,4379,doc/master/classTPSocket.html,https://root.cern,https://root.cern/doc/master/classTPSocket.html,1,['timeout'],['timeout']
Safety,"TStatistic object filled with the input columns. |; 140| StdDev() | Return the unbiased standard deviation of the processed column values. |; 141| Sum() | Return the sum of the values in the column. If the type of the column is inferred, the return type is `double`, the type of the column otherwise. |; 142| Take() | Extract a column from the dataset as a collection of values, e.g. a `std::vector<float>` for a column of type `float`. |; 143 ; 144| **Instant action** | **Description** |; 145|---------------------|-----------------|; 146| Foreach() | Execute a user-defined function on each entry. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled. |; 147| ForeachSlot() | Same as Foreach(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Foreach() actions when using RDataFrame after ROOT::EnableImplicitMT(). ForeachSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; 148| Snapshot() | Write the processed dataset to disk, in a new TTree and TFile. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. Snapshot() can be made *lazy* setting the appropriate flag in the snapshot options.|; 149 ; 150 ; 151### Queries; 152 ; 153These operations do not modify the dataframe or book computations but simply return information on the RDataFrame object.; 154 ; 155| **Operation** | **Description** |; 156|---------------------|-----------------|; 157| Describe() | Get useful information describing the dataframe, e.g. columns and their types. |; 158| GetColumnNames() | Get the names of all the available columns of the dataset. |; 159| GetColumnType() | Return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:10876,safe,safe,10876,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety,"TStatistic object filled with the input columns. |; 144| StdDev() | Return the unbiased standard deviation of the processed column values. |; 145| Sum() | Return the sum of the values in the column. If the type of the column is inferred, the return type is `double`, the type of the column otherwise. |; 146| Take() | Extract a column from the dataset as a collection of values, e.g. a `std::vector<float>` for a column of type `float`. |; 147 ; 148| **Instant action** | **Description** |; 149|---------------------|-----------------|; 150| Foreach() | Execute a user-defined function on each entry. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled. |; 151| ForeachSlot() | Same as Foreach(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Foreach() actions when using RDataFrame after ROOT::EnableImplicitMT(). ForeachSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; 152| Snapshot() | Write the processed dataset to disk, in a new TTree and TFile. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. Snapshot() can be made *lazy* setting the appropriate flag in the snapshot options.|; 153 ; 154 ; 155### Queries; 156 ; 157These operations do not modify the dataframe or book computations but simply return information on the RDataFrame object.; 158 ; 159| **Operation** | **Description** |; 160|---------------------|-----------------|; 161| Describe() | Get useful information describing the dataframe, e.g. columns and their types. |; 162| GetColumnNames() | Get the names of all the available columns of the dataset. |; 163| GetColumnType() | Return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:11318,safe,safe,11318,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety,"TStopwatchfWaitTimetime wating to prefetch a buffer (in usec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFilePrefetch(TFile* ); Constructor. ~TFilePrefetch(); Destructor. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t CheckCachePath(const char* ); Validate the input file cache path. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). Â» Author: Elvin Sindrilaru 19/05/2011 Â» Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; Â» Last changed: root/io:$Id: TFilePrefetch.h 39675 2011-06-10 16:19:12Z pcanal $ Â» Last g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFilePrefetch.html:7314,Safe,Safe,7314,root/html530/TFilePrefetch.html,https://root.cern,https://root.cern/root/html530/TFilePrefetch.html,1,['Safe'],['Safe']
Safety,"TStopwatchfWaitTimetime wating to prefetch a buffer (in usec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFilePrefetch(TFile* ); Constructor. ~TFilePrefetch(); Destructor. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t CheckCachePath(const char* ); Validate the input file cache path. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). TMutex* GetMutexSynch() const; { return fMutexSynch; }. Â» Author: Elvin Sindrilaru 19/05/2011 Â» Copyright (C) 1995-2011, Rene Brun and Fons Rademake",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFilePrefetch.html:7442,Safe,Safe,7442,root/html532/TFilePrefetch.html,https://root.cern,https://root.cern/root/html532/TFilePrefetch.html,1,['Safe'],['Safe']
Safety,"TString& s2); { return ReplaceAll(s1.Data(), s1.Length(), s2.Data(), s2.Length()) ; }. TString & ReplaceAll(const TString& s1, const char* s2); { return ReplaceAll(s1.Data(), s1.Length(), s2, s2 ? strlen(s2) : 0); }. TString & ReplaceAll(const char* s1, const TString& s2); { return ReplaceAll(s1, s1 ? strlen(s1) : 0, s2.Data(), s2.Length()); }. TString & ReplaceAll(const char* s1, const char* s2); { return ReplaceAll(s1, s1 ? strlen(s1) : 0, s2, s2 ? strlen(s2) : 0); }. TString & Swap(TString& other); Swap the contents of other and this without reallocation. char & operator()(Ssiz_t i); { return GetPointer()[i]; }. char operator()(Ssiz_t i) const; { return GetPointer()[i]; }. char & operator[](Ssiz_t i); { AssertElement(i); return GetPointer()[i]; }. char operator[](Ssiz_t i) const; { AssertElement(i); return GetPointer()[i]; }. char & operator()(Ssiz_t i). char operator()(Ssiz_t i) const. const char * Data() const. Ssiz_t Length() const; { return fExtent; }. Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. Ssiz_t Align(Ssiz_t s); { return (s + (kAlignment-1)) & ~(kAlignment-1); }. Ssiz_t Recommend(Ssiz_t s); { return (s < kMinCap ? kMinCap : Align(s+1)) - 1; }. Bool_t IsLong() const; { return Bool_t(fRep.fShort.fSize & kShortMask); }. void SetShortSize(Ssiz_t s); { fRep.fShort.fSize = (unsigned char)(s << 1); }. Ssiz_t GetShortSize() const; { return fRep.fShort.fSize >> 1; }. void SetLongSize(Ssiz_t s); { fRep.fLong.fSize = s; }. Ssiz_t GetLongSize() const; { return fRep.fLong.fSize; }. void SetSize(Ssiz_t s); { IsLong() ? SetLongSize(s) : SetShortSize(s); }. void SetLongCap(Ssiz_t s); { fRep.fLong.fCap = kLongMask | s; }. Ssiz_t GetLongCap() const; { return fRep.fLong.fCap & ~kLongMask; }. void SetLongPointer(char* p); { fRep.fLong.fData = p; }. char * GetLongPointer(); { return fRep.fLong.fData; }. const char * GetLongPointer() const; { return fRep.fLong.fData; }. char * GetShortPointer(); { return fRep.fShort.fData; }. const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TString.html:25867,detect,detecting,25867,root/html602/TString.html,https://root.cern,https://root.cern/root/html602/TString.html,1,['detect'],['detecting']
Safety,"TString(GetName()) + "" efficiency of B vs S"", fNbins, 0.0, 1.0 );; 1369 fEffBvsSLocal->SetDirectory(nullptr); // it's local; 1370 for (Int_t ibin=1; ibin<=fNbins; ibin++) fEffBvsSLocal->SetBinContent( ibin, -0.1 ); // Init; 1371 ; 1372 fCutMin = new Double_t*[GetNvar()];; 1373 fCutMax = new Double_t*[GetNvar()];; 1374 for (UInt_t i=0;i<GetNvar();i++) {; 1375 fCutMin[i] = new Double_t[fNbins];; 1376 fCutMax[i] = new Double_t[fNbins];; 1377 }; 1378 ; 1379 // read efficiencies and cuts; 1380 Int_t tmpbin;; 1381 Float_t tmpeffS, tmpeffB;; 1382 void* ch = gTools().GetChild(wghtnode,""Bin"");; 1383 while (ch) {; 1384 // if (strcmp(gTools().GetName(ch),""Bin"") !=0) {; 1385 // ch = gTools().GetNextChild(ch);; 1386 // continue;; 1387 // }; 1388 ; 1389 gTools().ReadAttr( ch, ""ibin"", tmpbin );; 1390 gTools().ReadAttr( ch, ""effS"", tmpeffS );; 1391 gTools().ReadAttr( ch, ""effB"", tmpeffB );; 1392 ; 1393 // sanity check; 1394 if (tmpbin-1 >= fNbins || tmpbin-1 < 0) {; 1395 Log() << kFATAL << ""Mismatch in bins: "" << tmpbin-1 << "" >= "" << fNbins << Endl;; 1396 }; 1397 ; 1398 fEffBvsSLocal->SetBinContent( tmpbin, tmpeffB );; 1399 void* ct = gTools().GetChild(ch);; 1400 for (UInt_t ivar=0; ivar<GetNvar(); ivar++) {; 1401 gTools().ReadAttr( ct, TString::Format( ""cutMin_%i"", ivar ), fCutMin[ivar][tmpbin-1] );; 1402 gTools().ReadAttr( ct, TString::Format( ""cutMax_%i"", ivar ), fCutMax[ivar][tmpbin-1] );; 1403 }; 1404 ch = gTools().GetNextChild(ch, ""Bin"");; 1405 }; 1406}; 1407 ; 1408////////////////////////////////////////////////////////////////////////////////; 1409/// write histograms and PDFs to file for monitoring purposes; 1410 ; 1411void TMVA::MethodCuts::WriteMonitoringHistosToFile( void ) const; 1412{; 1413 Log() << kINFO << ""Write monitoring histograms to file: "" << BaseDir()->GetPath() << Endl;; 1414 ; 1415 fEffBvsSLocal->Write();; 1416 ; 1417 // save reference histograms to file; 1418 if (fEffMethod == kUsePDFs) {; 1419 for (UInt_t ivar=0; ivar<GetNvar(); ivar++) {; 1420 (*fVarHist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:53321,sanity check,sanity check,53321,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['sanity check'],['sanity check']
Safety,"TSystem::RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*TSystem::RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*TSystem::RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*TSystem::RemoveTimer(TTimer* t); virtual intTSystem::Rename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidTSystem::ResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidTSystem::ResetSignals(); virtual voidTSystem::ResetTimer(TTimer*); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetSystem.html:13623,timeout,timeout,13623,root/html534/TNetSystem.html,https://root.cern,https://root.cern/root/html534/TNetSystem.html,12,['timeout'],['timeout']
Safety,"TSystem::ResetErrno ; (; ). static . Static function resetting system error number. ; Definition at line 284 of file TSystem.cxx. â—†Â ResetSignal(). void TSystem::ResetSignal ; (; ESignalsÂ ; sig, . Bool_tÂ ; reset = kTRUEÂ . ). virtual . If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 576 of file TSystem.cxx. â—†Â ResetSignals(). void TSystem::ResetSignals ; (; ). virtual . Reset signals handlers to previous behaviour. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 584 of file TSystem.cxx. â—†Â ResetTimer(). virtual void TSystem::ResetTimer ; (; TTimer *Â ; ). inlinevirtual . Reimplemented in TUnixSystem.; Definition at line 396 of file TSystem.h. â—†Â Run(). void TSystem::Run ; (; ). virtual . System event loop. ; Definition at line 343 of file TSystem.cxx. â—†Â Select() [1/2]. Int_t TSystem::Select ; (; TFileHandler *Â ; fh, . Long_tÂ ; timeoutÂ . ). virtual . Select on active file descriptors (called by TMonitor). ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 453 of file TSystem.cxx. â—†Â Select() [2/2]. Int_t TSystem::Select ; (; TList *Â ; active, . Long_tÂ ; timeoutÂ . ). virtual . Select on active file descriptors (called by TMonitor). ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 445 of file TSystem.cxx. â—†Â SendBuf(). int TSystem::SendBuf ; (; intÂ ; sock, . const void *Â ; buffer, . intÂ ; lengthÂ . ). virtual . Send a buffer headed by a length indicator. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 2427 of file TSystem.cxx. â—†Â SendRaw(). int TSystem::SendRaw ; (; intÂ ; sock, . const void *Â ; buffer, . intÂ ; length, . intÂ ; flagÂ . ). virtual . Send exactly length bytes from buffer. ; Use opt to send out-of-band data (see TSocket). ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 2409 of file TSystem.cxx. â—†Â SetAclicMode(). void TSys",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:81606,timeout,timeout,81606,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['timeout'],['timeout']
Safety,"TTimer*fStopTimerTimer associated with a stop request; TMutex*fStopTimerMtxTo protect the stop timer; Long64_tfTotalEventsnumber of events requested; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static THashList*fgDrawInputParsList of input parameters to be kept on drawing actions. private:. TList*fAutoBinsMap of min/max values by name for slaves. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofPlayer(TProof* proof = 0); Default ctor. ~TProofPlayer(); Destructor. void SetProcessing(Bool_t on = kTRUE); Set processing bit according to 'on'. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop the process after this event. If timeout is positive, start; a timer firing after timeout seconds to hard-stop time-expensive; events. void SetDispatchTimer(Bool_t on = kTRUE); Enable/disable the timer to dispatch pening events while processing. void SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); Enable/disable the timer to stop/abort processing.; The 'timeout' is in seconds. void AddQueryResult(TQueryResult* q); Add query result to the list, making sure that there are no; duplicates. void RemoveQueryResult(const char* ref); Remove all query result instances referenced 'ref' from; the list of results. TQueryResult * GetQueryResult(const char* ref); Get query result instances referenced 'ref' from; the list of results. void SetCurrentQuery(TQueryResult* q); Set current query and save previous value. void AddInput(TObject* inp); Add object to input list. void ClearInput(); Clear input list. TObject * GetOutput(const char* name) const; Get output object by name. TList * GetOutputList() const; Get output list. Int_t ReinitSelector(TQueryResult* qr); Reinitialize fSelector using the selector files in the query result.; Needed when Finalize is called after a Process execution for the same; selector name. Int_t AddOutputObject(TObject* obj); Incorporate output object (m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayer.html:14422,abort,abort,14422,root/html528/TProofPlayer.html,https://root.cern,https://root.cern/root/html528/TProofPlayer.html,18,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; f#define f(i)Definition RSha256.hxx:104; nentriesint nentriesDefinition THbookFile.cxx:91; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Reading a subset of all branches; In the Process function we read a subset of the branches. Only the branches used in the first entry will be put in the cache TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=200UL;; auto efirst = 0;; auto elast = efirst+nentries;; auto cachesize = 10000000U; // 10 MBytes; TTreeCache::SetLearnEntries(1); //<<<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:6893,avoid,avoid,6893,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,['avoid'],['avoid']
Safety,"TUnixSystemTUnixSystem()Definition TUnixSystem.cxx:575; TUnixSystem::AddDynamicPathvoid AddDynamicPath(const char *lib) overrideAdd a new directory to the dynamic path.Definition TUnixSystem.cxx:4725; TUnixSystem::SetDynamicPathvoid SetDynamicPath(const char *lib) overrideSet the dynamic path to a new value.Definition TUnixSystem.cxx:4748; TUnixSystem::ClosePipeint ClosePipe(FILE *pipe) overrideClose the pipe.Definition TUnixSystem.cxx:2171; TUnixSystem::GetHomeDirectorystd::string GetHomeDirectory(const char *userName=nullptr) const overrideReturn the user's home directory.Definition TUnixSystem.cxx:1491; TUnixSystem::SelectInt_t Select(TList *active, Long_t timeout) overrideSelect on file descriptors.Definition TUnixSystem.cxx:1202; TUnixSystem::Unsetenvvoid Unsetenv(const char *name) overrideUnset environment variable.Definition TUnixSystem.cxx:2145; TUnixSystem::~TUnixSystemvirtual ~TUnixSystem()Reset to original state.Definition TUnixSystem.cxx:581; TUnixSystem::Abortvoid Abort(int code=0) overrideAbort the application.Definition TUnixSystem.cxx:2202; TUnixSystem::Syslogvoid Syslog(ELogLevel level, const char *mess) overrideSend mess to syslog daemon.Definition TUnixSystem.cxx:2654; TUnixSystem::GetGroupInfoUserGroup_t * GetGroupInfo(Int_t gid) overrideReturns all group info in the UserGroup_t structure.Definition TUnixSystem.cxx:2099; TUnixSystem::GetUidInt_t GetUid(const char *user=nullptr) overrideReturns the user's id. If user = 0, returns current user's id.Definition TUnixSystem.cxx:2005; TUnixSystem::ExpandPathNameBool_t ExpandPathName(TString &patbuf) overrideExpand a pathname getting rid of special shell characters like ~.Definition TUnixSystem.cxx:1749; TUnixSystem::Openlogvoid Openlog(const char *name, Int_t options, ELogFacility facility) overrideOpen connection to system log daemon.Definition TUnixSystem.cxx:2616; TUnixSystem::AcceptConnectionint AcceptConnection(int sock) overrideAccept a connection.Definition TUnixSystem.cxx:3276; TUnixSystem::Now",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:206997,Abort,Abortvoid,206997,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,4,['Abort'],"['Abort', 'Abortvoid']"
Safety,"TWinNTSystem.cxx. â—†Â Init(). Bool_t TWinNTSystem::Init ; (; ). overridevirtual . Initialize WinNT system interface. ; Reimplemented from TSystem.; Definition at line 1076 of file TWinNTSystem.cxx. â—†Â InitUsersGroups(). Bool_t TWinNTSystem::InitUsersGroups ; (; ). private . Collect local users and groups accounts information. ; Definition at line 3162 of file TWinNTSystem.cxx. â—†Â IsA(). TClass * TWinNTSystem::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TSystem.; Definition at line 254 of file TWinNTSystem.h. â—†Â IsAbsoluteFileName(). Bool_t TWinNTSystem::IsAbsoluteFileName ; (; const char *Â ; dir). overridevirtual . Return true if dir is an absolute pathname. ; Reimplemented from TSystem.; Definition at line 2500 of file TWinNTSystem.cxx. â—†Â IsPathLocal(). Bool_t TWinNTSystem::IsPathLocal ; (; const char *Â ; path). overridevirtual . Returns TRUE if the url in 'path' points to the local file system. ; This is used to avoid going through the NIC card for local operations. ; Reimplemented from TSystem.; Definition at line 2584 of file TWinNTSystem.cxx. â—†Â Link(). int TWinNTSystem::Link ; (; const char *Â ; from, . const char *Â ; toÂ . ). overridevirtual . Create a link from file1 to file2. ; Reimplemented from TSystem.; Definition at line 2768 of file TWinNTSystem.cxx. â—†Â Load(). int TWinNTSystem::Load ; (; const char *Â ; module, . const char *Â ; entry = """", . Bool_tÂ ; system = kFALSEÂ . ). overridevirtual . Load a shared library. ; Returns 0 on successful loading, 1 in case lib was already loaded and -1 in case lib does not exist or in case of error. ; Reimplemented from TSystem.; Definition at line 4141 of file TWinNTSystem.cxx. â—†Â LookupSID(). Long_t TWinNTSystem::LookupSID ; (; const char *Â ; lpszAccountName, . intÂ ; what, . int &Â ; groupIdx, . int &Â ; memberIdxÂ . ). private . Take the name and look up a SID so that we can get full domain/user information. ; Definition at line 3310 of file TWinNTSystem.cxx. â—†Â MakeDirect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:60967,avoid,avoid,60967,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['avoid'],['avoid']
Safety,"TargetDir = NULL); construction from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); Cuts can only handle classification with 2 classes. void Init( void ); default initialisation called by all constructors. ~MethodCuts( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; Method <string> Minimisation method; available values are: MC Monte Carlo <default>; GA Genetic Algorithm; SA Simulated annealing. EffMethod <string> Efficiency selection method; available values are: EffSel <default>; EffPDF. VarProp <string> Property of variable 1 for the MC method (taking precedence over the; globale setting. The same values as for the global option are available. Variables 1..10 can be; set this way. CutRangeMin/Max <float> user-defined ranges in which cuts are varied. void ProcessOptions(); process user options; sanity check, do not allow the input variables to be normalised, because this; only creates problems when interpreting the cuts. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); cut evaluation: returns 1.0 if event passed, 0.0 otherwise. void PrintCuts(Double_t effS) const; print cuts. Double_t GetCuts(Double_t effS, Double_t* cutMin, Double_t* cutMax) const; retrieve cut values for given signal efficiency; assume vector of correct size !!. Double_t GetCuts(Double_t effS, vector<Double_t>& cutMin, vector<Double_t>& cutMax) const; retrieve cut values for given signal efficiency. void Train( void ); training method: here the cuts are optimised for the training sample. void TestClassification(); nothing to test. Double_t EstimatorFunction(Int_t ievt1, Int_t ievt2); for full event scan. Double_t EstimatorFunction(vector<Double_t>& ); returns estimator for ""cut fitness"" used by GA. Double_t ComputeEstimator(vector<Double_t>& ); returns estimator for ""cut fitness"" used by GA; there are two requirements:; 1) the sign",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCuts.html:21666,sanity check,sanity check,21666,root/html528/TMVA__MethodCuts.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCuts.html,4,['sanity check'],['sanity check']
Safety,"TensorBatch();; 1930 auto inputTensor = batch.GetInput();; 1931 ; 1932 auto xInput = batch.GetInput();; 1933 // make the prediction; 1934 deepNet.Prediction(yHat, xInput, fOutputFunction);; 1935 for (size_t i = 0; i < batchSize; ++i) {; 1936 double value = yHat(i,0);; 1937 mvaValues[ievt + i] = (TMath::IsNaN(value)) ? -999. : value;; 1938 }; 1939 }; 1940 else {; 1941 // case of remaining events: compute prediction by single event !; 1942 for (Long64_t i = ievt; i < lastEvt; ++i) {; 1943 Data()->SetCurrentEvent(i);; 1944 mvaValues[i] = GetMvaValue();; 1945 }; 1946 }; 1947 }; 1948 ; 1949 if (logProgress) {; 1950 Log() << kINFO; 1951 << ""Elapsed time for evaluation of "" << nEvents << "" events: ""; 1952 << timer.GetElapsedTime() << "" "" << Endl;; 1953 }; 1954 ; 1955 return mvaValues;; 1956}; 1957 ; 1958//////////////////////////////////////////////////////////////////////////; 1959/// Get the regression output values for a single event; 1960//////////////////////////////////////////////////////////////////////////; 1961const std::vector<Float_t> & TMVA::MethodDL::GetRegressionValues(); 1962{; 1963 ; 1964 FillInputTensor ();; 1965 ; 1966 // perform the network prediction; 1967 fNet->Prediction(*fYHat, fXInput, fOutputFunction);; 1968 ; 1969 size_t nTargets = DataInfo().GetNTargets();; 1970 R__ASSERT(nTargets == fYHat->GetNcols());; 1971 ; 1972 std::vector<Float_t> output(nTargets);; 1973 for (size_t i = 0; i < nTargets; i++); 1974 output[i] = (*fYHat)(0, i);; 1975 ; 1976 // ned to transform back output values; 1977 if (fRegressionReturnVal == NULL); 1978 fRegressionReturnVal = new std::vector<Float_t>(nTargets);; 1979 R__ASSERT(fRegressionReturnVal->size() == nTargets);; 1980 ; 1981 // N.B. one should cache here temporary event class; 1982 Event *evT = new Event(*GetEvent());; 1983 for (size_t i = 0; i < nTargets; ++i) {; 1984 evT->SetTarget(i, output[i]);; 1985 }; 1986 const Event *evT2 = GetTransformationHandler().InverseTransform(evT);; 1987 for (size_t i = 0; i < nTarg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:78184,predict,prediction,78184,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,2,"['Predict', 'predict']","['Prediction', 'prediction']"
Safety,"The same prior is used ; for all the TEfficiency objects.; . Example:; If you use cuts to select electrons which can originate from two different; processes, you can determine the selection efficiency for each process. The; overall selection efficiency is then the combined efficiency. The weights to be used in the ; combination should be the probability that an; electron comes from the corresponding process.; . VI. Further operations; VI.1 Information about the internal histograms; The methods GetPassedHistogram and GetTotalHistogram; return a constant pointer to the internal histograms. They can be used to; obtain information about the internal histograms (e.g. the binning, number of passed / total events in a bin, mean values...).; One can obtain a clone of the internal histograms by calling GetCopyPassedHisto or GetCopyTotalHisto.; The returned histograms are completely independent from the current; TEfficiency object. By default, they are not attached to a directory to; avoid the duplication of data and the user is responsible for deleting them.; . Example:; //open a root file which contains a TEfficiency object; TFile* pFile = new TFile(""myfile.root"",""update"");; ; //get TEfficiency object with name ""my_eff""; TEfficiency* pEff = (TEfficiency*)pFile->Get(""my_eff"");; ; //get clone of total histogram; TH1* clone = pEff->GetCopyTotalHisto();; ; //change clone...; //save changes of clone directly; clone->Write();; //or append it to the current directoy and write the file; //clone->SetDirectory(gDirectory);; //pFile->Wrtie();; ; //delete histogram object; delete clone;; clone = 0;; . It is also possible to set the internal total or passed histogram by using the; methods SetPassedHistogram or; SetTotalHistogram.; In order to ensure the validity of the TEfficiency object, the consistency of the; new histogram and the stored histogram is checked. It sometimes might be; impossible to change the histograms in a consistent way. Therefore one can force; the replacement by pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEfficiency.html:17012,avoid,avoid,17012,root/html528/TEfficiency.html,https://root.cern,https://root.cern/root/html528/TEfficiency.html,3,['avoid'],['avoid']
Safety,"This allows to; set and fix parameter values, and set step sizes directly. Restricting the fit range. The fit range can be restricted through; fit->SetRangeX(first bin #, last bin #);; and freed using; fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. Obtaining fit results. The fit is carried out through; Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. TFractionFitter(); TFractionFitter(TH1* data, TObjArray* MCs); virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFractionFitter.html:4335,predict,prediction,4335,root/html528/TFractionFitter.html,https://root.cern,https://root.cern/root/html528/TFractionFitter.html,1,['predict'],['prediction']
Safety,"This fixes the issue described at ROOT-7846.; Code Cleanups.; Several definition where moved from the global or ROOT namespace to the ROOT::Internal namespace as they are not intended to be used outside of ROOT, including: gROOTLocal and related functions, TSchemaHelper, TSchemaMatch, TSchemaType, RStl, ROOT::TROOTAllocator, TSchemaRuleProcessor, TStdBitsetHelper, TInitBehavior, TDefaultInitBehavior, DefineBehavior, THnBaseBrowsable, THnBaseBinIter, GenericShowMembers, TOperatorNewHelper and BranchProxy implementations classes.; Several definition where moved from the global or ROOT namespace to the ROOT::Details namespace as they are intended to be used in â€˜expertâ€™ level code and have a lower level of backward compatibility requirement. This includes TCollectionProxyInfo, TSchemaRuleSet.; Interpreter; ROOT can now dump the context of STL collections, for instance map<string,int>. A few ROOT types print their content, too.; Fixed the handling of the current directory in #include of system headers, avoid problem with local files named new or vector.; Fixed the issue with the ROOT special variable where the objects were read from the file at each and every access by caching those object. See ROOT-7830 for example.; This release contains several bug fixes and improvements, notably in unloading and performance. NOTE: The GCC 5 ABI is not supported yet, due to a lack of support in clang. I/O Libraries; hadd; We extended the hadd options to allow more control on the compression settings use for the output file. In particular the new option -fk allows for a copy of the input files with no decompressions/recompression of the TTree baskets even if they do not match the requested compression setting.; New options:. -ff allows to force the compression setting to match the one from the first input; -fk[0-209] allows to keep all the basket compressed as is and to compress the meta data with the given compression setting or the compression setting of the first input file.; -a opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:7074,avoid,avoid,7074,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['avoid'],['avoid']
Safety,This tutorial shows how to express the concept of ranges when working with the TDataFrame ; Â tdf007_snapshot.C This tutorial shows how to write out datasets in ROOT formatusing the TDataFrame ; Â tdf007_snapshot.py This tutorial shows how to write out datasets in ROOT formatusing the TDataFrame ; Â tdf008_createDataSetFromScratch.C This tutorial shows how to create a dataset from scratch with TDataFrame ; Â tdf101_h1Analysis.C This tutorial illustrates how to express the H1 analysis with a TDataFrame ; Â â–ºÂ eve; Â alice_esd.CComplex example showing ALICE ESD track visualization ; Â alice_esd_html_summary.CHtml table and event summary for alice_esd.C ; Â alice_esd_split.CComplex example showing ALICE ESD visualization in several views ; Â alice_vsd.CComplex example showing ALICE VSD visualization ; Â annotation.CDemonstrates usage of TGLAnnotation class ; Â arrow.CDemonstrates usage of TEveArrow class ; Â arrow_standalone.CHow to use EVE without the standard window ; Â assembly.CGeometry detector assembly example ; Â box.CDemonstrates usage of TEveBox class ; Â boxset.CDemonstrates usage of TEveBoxSet class ; Â boxset_cones.CDemonstrates usage of 'cone' mode in TEveBoxSet class ; Â calo_detail.CCalorimeter detailed view by using TEveCaloDataVec as data-source ; Â calorimeters.CDemonstrates usage of EVE calorimetry classes ; Â camera_restore.C; Â compound.CDemonstrates usage of EVE compound objects - class TEveCompound ; Â csgdemo.CCombinatorial Solid Geometry example ; Â geom_alias.CDemonstates usage of geometry aliases - merge ALICE ITS with ATLAS MUON ; Â geom_alice_its.CShows geometry of ALICE ITS ; Â geom_alice_tpc.CShows geometry of ALICE TPC ; Â geom_atlas.CShows ATLAS geometry ; Â geom_atlas_playback.CPlays back event-recording of a root session running geom_atlas.C tutorial ; Â geom_cms.CShows CMS geometry ; Â geom_cms_playback.CPlays back event-recording of a root session running geom_cms.C tutorial ; Â geom_cms_stereo.CShows CMS geometry in stereo mode ; Â geom_default.CDemonstrates usag,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:101491,detect,detector,101491,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['detect'],['detector']
Safety,"Timer&) = delete;; 66 ; 67public:; 68 TTimer(Long_t milliSec = 0, Bool_t mode = kTRUE);; 69 TTimer(TObject *obj, Long_t milliSec, Bool_t mode = kTRUE);; 70 TTimer(const char *command, Long_t milliSec, Bool_t mode = kTRUE);; 71 virtual ~TTimer() { Remove(); }; 72 ; 73 Bool_t CheckTimer(const TTime &now);; 74 const char *GetCommand() const { return fCommand.Data(); }; 75 TObject *GetObject() { return fObject; }; 76 TTime GetTime() const { return fTime; }; 77 UInt_t GetTimerID() { return fTimeID;}; 78 TTime GetAbsTime() const { return fAbsTime; }; 79 Bool_t HasTimedOut() const { return fTimeout; }; 80 Bool_t IsSync() const { return fSync; }; 81 Bool_t IsAsync() const { return !fSync; }; 82 Bool_t IsInterruptingSyscalls() const { return fIntSyscalls; }; 83 Bool_t IsRunning();; 84 Bool_t Notify() override;; 85 void Add() override { TurnOn(); }; 86 void Remove() override { TurnOff(); }; 87 void Reset();; 88 void SetCommand(const char *command);; 89 void SetObject(TObject *object);; 90 void SetInterruptSyscalls(Bool_t set = kTRUE);; 91 void SetTime(Long_t milliSec) { fTime = milliSec; }; 92 void SetTimerID(UInt_t id = 0) { fTimeID = id; }; 93 virtual void Start(Long_t milliSec = -1, Bool_t singleShot = kFALSE);; 94 virtual void Stop() { TurnOff(); }; 95 virtual void TurnOn(); //*SIGNAL*; 96 virtual void TurnOff(); //*SIGNAL*; 97 virtual void Timeout() { Emit(""Timeout()""); } //*SIGNAL*; 98 ; 99 static void SingleShot(Int_t milliSec, const char *receiver_class,; 100 void *receiver, const char *method);; 101 ; 102 ClassDefOverride(TTimer,0) //Handle timer event; 103};; 104 ; 105#endif; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Long_tlong Long_tDefinition RtypesCore.h:54; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; idOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8h_source.html:4008,Timeout,Timeout,4008,doc/master/TTimer_8h_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8h_source.html,2,['Timeout'],['Timeout']
Safety,"TreeDrawArgsParser for the tree fTree. ; Â ; virtual voidÂ DefVar ()=0; Â ; virtual voidÂ DoFill (Long64_t entry, Double_t w, const Double_t *v)=0; Â ; voidÂ FillWeight (); Â Get weight from input list, if any. ; Â ; virtual Bool_tÂ ProcessSingle (Long64_t, Int_t); Â Processes a single variable from an entry. ; Â ; voidÂ SetCanvas (const char *objname); Â Move to a canvas named <name>_canvas; create the canvas if not existing. ; Â ; voidÂ SetDrawAtt (TObject *o); Â Set the drawing attributes from the input list. ; Â ; voidÂ SetError (const char *sub, const char *mesg); Â Sets the error status. ; Â ; Â Protected Member Functions inherited from TObject; virtual voidÂ DoError (int level, const char *location, const char *fmt, va_list va) const; Â Interface to ErrorHandler (protected). ; Â ; voidÂ MakeZombie (); Â . Protected Attributes; Int_tÂ fDimension; Â ; TStringÂ fInitialExp; Â ; TTreeFormulaManager *Â fManager; Â ; Int_tÂ fMultiplicity; Â ; Bool_tÂ fObjEval; Â ; TTreeFormula *Â fSelect; Â ; TStringÂ fSelection; Â ; TStatus *Â fStatus; Â ; TTree *Â fTree; Â ; TTreeDrawArgsParserÂ fTreeDrawArgsParser; Â ; TTreeFormula *Â fVar [4]; Â ; Double_tÂ fWeight; Â ; Â Protected Attributes inherited from TSelector; EAbortÂ fAbort; Â Abort status. ; Â ; TList *Â fInput; Â List of objects available during processing. ; Â ; TObject *Â fObject; Â ! Current object if processing object (vs. TTree) ; Â ; TStringÂ fOption; Â Option given to TTree::Process. ; Â ; TSelectorList *Â fOutput; Â ! List of objects created during processing ; Â ; Long64_tÂ fStatus; Â Selector status. ; Â . Friends; classÂ TProofPlayer; Â . Additional Inherited Members; Â Public Types inherited from TSelector; enum Â EAbort { kContinue; , kAbortProcess; , kAbortFile; }; Â ; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; Â Â kBitMask = 0x00ffffff. }; Â ; enum Â { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; Â ; enum Â EDepre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDraw.html:12822,Abort,Abort,12822,doc/master/classTProofDraw.html,https://root.cern,https://root.cern/doc/master/classTProofDraw.html,1,['Abort'],['Abort']
Safety,"UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoScaledShape(); Default constructor. TGeoScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); Constructor. TGeoScaledShape(TGeoShape* shape, TGeoScale* scale); Constructor. ~TGeoScaledShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3]. void ComputeBBox(); Compute bounding box of the scaled shape. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; Test if point is inside the scaled shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the scaled shape. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the scaled shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Bool_t IsAssembly() const; Returns true ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoScaledShape.html:13198,safe,safe,13198,root/html534/TGeoScaledShape.html,https://root.cern,https://root.cern/root/html534/TGeoScaledShape.html,3,['safe'],['safe']
Safety,"UNCTION_MAY_BE_UNUSED; 5351static int; 5352dlclose(void *handle); 5353{; 5354 int result;; 5355 ; 5356 if (FreeLibrary((HMODULE)handle) != 0) {; 5357 result = 0;; 5358 } else {; 5359 result = -1;; 5360 }; 5361 ; 5362 return result;; 5363}; 5364 ; 5365 ; 5366#if defined(GCC_DIAGNOSTIC); 5367/* Enable unused function warning again */; 5368#pragma GCC diagnostic pop; 5369#endif; 5370 ; 5371#endif; 5372 ; 5373 ; 5374#if !defined(NO_CGI); 5375#define SIGKILL (0); 5376 ; 5377 ; 5378static int; 5379kill(pid_t pid, int sig_num); 5380{; 5381 (void)TerminateProcess((HANDLE)pid, (UINT)sig_num);; 5382 (void)CloseHandle((HANDLE)pid);; 5383 return 0;; 5384}; 5385 ; 5386 ; 5387#if !defined(WNOHANG); 5388#define WNOHANG (1); 5389#endif; 5390 ; 5391 ; 5392static pid_t; 5393waitpid(pid_t pid, int *status, int flags); 5394{; 5395 DWORD timeout = INFINITE;; 5396 DWORD waitres;; 5397 ; 5398 (void)status; /* Currently not used by any client here */; 5399 ; 5400 if ((flags | WNOHANG) == WNOHANG) {; 5401 timeout = 0;; 5402 }; 5403 ; 5404 waitres = WaitForSingleObject((HANDLE)pid, timeout);; 5405 if (waitres == WAIT_OBJECT_0) {; 5406 return pid;; 5407 }; 5408 if (waitres == WAIT_TIMEOUT) {; 5409 return 0;; 5410 }; 5411 return (pid_t)-1;; 5412}; 5413 ; 5414 ; 5415static void; 5416trim_trailing_whitespaces(char *s); 5417{; 5418 char *e = s + strlen(s);; 5419 while ((e > s) && isspace((unsigned char)e[-1])) {; 5420 *(--e) = '\0';; 5421 }; 5422}; 5423 ; 5424 ; 5425static pid_t; 5426spawn_process(struct mg_connection *conn,; 5427 const char *prog,; 5428 char *envblk,; 5429 char *envp[],; 5430 int fdin[2],; 5431 int fdout[2],; 5432 int fderr[2],; 5433 const char *dir,; 5434 unsigned char cgi_config_idx); 5435{; 5436 HANDLE me;; 5437 char *interp;; 5438 char *interp_arg = 0;; 5439 char full_dir[UTF8_PATH_MAX], cmdline[UTF8_PATH_MAX], buf[UTF8_PATH_MAX];; 5440 int truncated;; 5441 struct mg_file file = STRUCT_FILE_INITIALIZER;; 5442 STARTUPINFOA si;; 5443 PROCESS_INFORMATION pi = {0};; 5444 ; 5445 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:159814,timeout,timeout,159814,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"UNCTION_MAY_BE_UNUSED; 5352static int; 5353dlclose(void *handle); 5354{; 5355 int result;; 5356 ; 5357 if (FreeLibrary((HMODULE)handle) != 0) {; 5358 result = 0;; 5359 } else {; 5360 result = -1;; 5361 }; 5362 ; 5363 return result;; 5364}; 5365 ; 5366 ; 5367#if defined(GCC_DIAGNOSTIC); 5368/* Enable unused function warning again */; 5369#pragma GCC diagnostic pop; 5370#endif; 5371 ; 5372#endif; 5373 ; 5374 ; 5375#if !defined(NO_CGI); 5376#define SIGKILL (0); 5377 ; 5378 ; 5379static int; 5380kill(pid_t pid, int sig_num); 5381{; 5382 (void)TerminateProcess((HANDLE)pid, (UINT)sig_num);; 5383 (void)CloseHandle((HANDLE)pid);; 5384 return 0;; 5385}; 5386 ; 5387 ; 5388#if !defined(WNOHANG); 5389#define WNOHANG (1); 5390#endif; 5391 ; 5392 ; 5393static pid_t; 5394waitpid(pid_t pid, int *status, int flags); 5395{; 5396 DWORD timeout = INFINITE;; 5397 DWORD waitres;; 5398 ; 5399 (void)status; /* Currently not used by any client here */; 5400 ; 5401 if ((flags | WNOHANG) == WNOHANG) {; 5402 timeout = 0;; 5403 }; 5404 ; 5405 waitres = WaitForSingleObject((HANDLE)pid, timeout);; 5406 if (waitres == WAIT_OBJECT_0) {; 5407 return pid;; 5408 }; 5409 if (waitres == WAIT_TIMEOUT) {; 5410 return 0;; 5411 }; 5412 return (pid_t)-1;; 5413}; 5414 ; 5415 ; 5416static void; 5417trim_trailing_whitespaces(char *s); 5418{; 5419 char *e = s + strlen(s);; 5420 while ((e > s) && isspace((unsigned char)e[-1])) {; 5421 *(--e) = '\0';; 5422 }; 5423}; 5424 ; 5425 ; 5426static pid_t; 5427spawn_process(struct mg_connection *conn,; 5428 const char *prog,; 5429 char *envblk,; 5430 char *envp[],; 5431 int fdin[2],; 5432 int fdout[2],; 5433 int fderr[2],; 5434 const char *dir,; 5435 unsigned char cgi_config_idx); 5436{; 5437 HANDLE me;; 5438 char *interp;; 5439 char *interp_arg = 0;; 5440 char full_dir[UTF8_PATH_MAX], cmdline[UTF8_PATH_MAX], buf[UTF8_PATH_MAX];; 5441 int truncated;; 5442 struct mg_file file = STRUCT_FILE_INITIALIZER;; 5443 STARTUPINFOA si;; 5444 PROCESS_INFORMATION pi = {0};; 5445 ; 5446 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:159846,timeout,timeout,159846,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"UseSuffixes() const; configuration of SQL. { return fUseSuffixes; }. Int_t GetArrayLimit() const; { return fArrayLimit; }. void SkipArrayLimit(); { SetArrayLimit(-1); }. const char* GetTablesType() const; { return fTablesType.Data(); }. Int_t GetUseTransactions() const; { return fUseTransactions; }. Int_t GetUseIndexes() const; { return fUseIndexes; }. Int_t GetQuerisCounter() const; { return fQuerisCounter; }. void DrawMap(const char* = ""*"", Option_t* = """"); {}. void FillBuffer(char*& ); {}. void Flush(); {}. Long64_t GetEND() const; { return 0; }. Int_t GetErrno() const; { return 0; }. void ResetErrno() const; {}. Int_t GetNfree() const; { return 0; }. Int_t GetNbytesInfo() const; {return 0; }. Int_t GetNbytesFree() const; {return 0; }. Long64_t GetSeekFree() const; {return 0; }. Long64_t GetSeekInfo() const; {return 0; }. Long64_t GetSize() const; { return 0; }. void MakeFree(Long64_t , Long64_t ); {}. void MakeProject(const char* , const char* = ""*"", Option_t* = ""new""); {}. void Map(); {}. void Paint(Option_t* = """"); {}. void Print(Option_t* = """") const; {}. Bool_t ReadBuffer(char* , Int_t ); { return kFALSE; }. Bool_t ReadBuffer(char* , Long64_t , Int_t ); { return kFALSE; }. void ReadFree(); {}. Int_t Recover(); { return 0; }. void Seek(Long64_t , TFile::ERelativeTo = kBeg); {}. void SetEND(Long64_t ); {}. Int_t Sizeof() const; { return 0; }. void UseCache(Int_t = 10, Int_t = 0); {}. Bool_t WriteBuffer(const char* , Int_t ); { return kFALSE; }. Int_t Write(const char* = 0, Int_t = 0, Int_t = 0); { return 0; }. Int_t Write(const char* = 0, Int_t = 0, Int_t = 0) const; { return 0; }. void WriteFree(); {}. Â» Author: Sergey Linev 20/11/2005 Â» Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; Â» Last changed: root/sql:$Id: TSQLFile.h 34444 2010-07-16 02:17:39Z pcanal $ Â» Last generated: 2011-07-04 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:48951,Recover,Recover,48951,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,1,['Recover'],['Recover']
Safety,"UseSuffixes() const; configuration of SQL. { return fUseSuffixes; }. Int_t GetArrayLimit() const; { return fArrayLimit; }. void SkipArrayLimit(); { SetArrayLimit(-1); }. const char* GetTablesType() const; { return fTablesType.Data(); }. Int_t GetUseTransactions() const; { return fUseTransactions; }. Int_t GetUseIndexes() const; { return fUseIndexes; }. Int_t GetQuerisCounter() const; { return fQuerisCounter; }. void DrawMap(const char* = ""*"", Option_t* = """"); {}. void FillBuffer(char*& ); {}. void Flush(); {}. Long64_t GetEND() const; { return 0; }. Int_t GetErrno() const; { return 0; }. void ResetErrno() const; {}. Int_t GetNfree() const; { return 0; }. Int_t GetNbytesInfo() const; {return 0; }. Int_t GetNbytesFree() const; {return 0; }. Long64_t GetSeekFree() const; {return 0; }. Long64_t GetSeekInfo() const; {return 0; }. Long64_t GetSize() const; { return 0; }. void MakeFree(Long64_t , Long64_t ); {}. void MakeProject(const char* , const char* = ""*"", Option_t* = ""new""); {}. void Map(); {}. void Paint(Option_t* = """"); {}. void Print(Option_t* = """") const; {}. Bool_t ReadBuffer(char* , Int_t ); { return kFALSE; }. Bool_t ReadBuffer(char* , Long64_t , Int_t ); { return kFALSE; }. void ReadFree(); {}. Int_t Recover(); { return 0; }. void Seek(Long64_t , TFile::ERelativeTo = kBeg); {}. void SetEND(Long64_t ); {}. Int_t Sizeof() const; { return 0; }. void UseCache(Int_t = 10, Int_t = 0); {}. Bool_t WriteBuffer(const char* , Int_t ); { return kFALSE; }. Int_t Write(const char* = 0, Int_t = 0, Int_t = 0); { return 0; }. Int_t Write(const char* = 0, Int_t = 0, Int_t = 0) const; { return 0; }. void WriteFree(); {}. Â» Author: Sergey Linev 20/11/2005 Â» Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; Â» Last changed: root/sql:$Id: TSQLFile.h 34444 2010-07-16 02:17:39Z pcanal $ Â» Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSQLFile.html:49407,Recover,Recover,49407,root/html532/TSQLFile.html,https://root.cern,https://root.cern/root/html532/TSQLFile.html,1,['Recover'],['Recover']
Safety,"VA::PDEFoamCell* ); Internal subprogram used by Create.; It initializes content of the newly allocated active cell. void Explore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of kTRUE and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. If fNmin > 0 then the total number of (training) events found in; the cell during the exploration is stored in the cell. This; information is used withing PeekMax() to avoid splitting cells; which contain less than fNmin events. void DTExplore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create. It explores newly defined; cell with according to the decision tree logic. The separation; set by the 'fDTSeparation' option is used (see also; GetSeparation()). The optimal division point for eventual future cell division is; determined/recorded. Note that links to parents and initial; volume = 1/2 parent has to be already defined prior to calling; this routine. Note, that according to the decision tree logic, a cell is only; split, if the number of (unweighted) events in each dautghter; cell is greater than fNmin. Float_t GetSeparation(Float_t s, Float_t b); Calculate the separation depending on 'fDTSeparation' for the; given number of signal and background events 's', 'b'. Note,; that if (s+b) < 0 or s < 0 or b < 0 than the return value is 0. void Varedu(Double_t* , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Create.; In determines the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__PDEFoam.html:13561,avoid,avoid,13561,root/html528/TMVA__PDEFoam.html,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoam.html,1,['avoid'],['avoid']
Safety,"VA::PDEFoamCell* ); Internal subprogram used by Create.; It initializes content of the newly allocated active cell. void Explore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of kTRUE and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. If fNmin > 0 then the total number of (training) events found in; the cell during the exploration is stored in the cell. This; information is used withing PeekMax() to avoid splitting cells; which contain less than fNmin events. void Varedu(Double_t* , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Create.; In determines the best edge candidate and the position of the cell division plane; in case of the variance reduction for future cell division,; using results of the MC exploration run stored in fHistEdg. void MakeAlpha(); Internal subrogram used by Create.; Provides random vector Alpha 0< Alpha(i) < 1. Long_t PeekMax(); Internal subprogram used by Create. It finds cell with maximal; driver integral for the purpose of the division. This function; is overridden by the PDEFoam Class to apply cuts on the number; of events in the cell (fNmin) and the cell tree depth; (GetMaxDepth() > 0) during cell buildup. Int_t Divide(TMVA::PDEFoamCell* ); Internal subrogram used by Create.; It divides cell iCell into two daughter cells.; The iCell is retained and tagged as inactive, daughter cells are appended; at the end of the buffer.; New vertex is added ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoam.html:13149,avoid,avoid,13149,root/html530/TMVA__PDEFoam.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoam.html,3,['avoid'],['avoid']
Safety,"VA::PDEFoamCell* ); Internal subprogram used by Create.; It initializes content of the newly allocated active cell. void Explore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of kTRUE and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. If fNmin > 0 then the total number of (training) events found in; the cell during the exploration is stored in the cell. This; information is used withing PeekMax() to avoid splitting cells; which contain less than fNmin events. void Varedu(Double_t[] , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Create.; In determines the best edge candidate and the position of the cell division plane; in case of the variance reduction for future cell division,; using results of the MC exploration run stored in fHistEdg. void MakeAlpha(); Internal subrogram used by Create.; Provides random vector Alpha 0< Alpha(i) < 1. Long_t PeekMax(); Internal subprogram used by Create. It finds cell with maximal; driver integral for the purpose of the division. This function; is overridden by the PDEFoam Class to apply cuts on the number; of events in the cell (fNmin) and the cell tree depth; (GetMaxDepth() > 0) during cell buildup. Int_t Divide(TMVA::PDEFoamCell* ); Internal subrogram used by Create.; It divides cell iCell into two daughter cells.; The iCell is retained and tagged as inactive, daughter cells are appended; at the end of the buffer.; New vertex is added",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDEFoam.html:13600,avoid,avoid,13600,root/html602/TMVA__PDEFoam.html,https://root.cern,https://root.cern/root/html602/TMVA__PDEFoam.html,2,['avoid'],['avoid']
Safety,"Varargs.h""; 39#include ""snprintf.h""; 40#include ""TObject.h""; 41#include ""TBuffer.h""; 42#include ""TClass.h""; 43#include ""TGuiFactory.h""; 44#include ""TMethod.h""; 45#include ""TROOT.h""; 46#include ""TError.h""; 47#include ""TObjectTable.h""; 48#include ""TVirtualPad.h""; 49#include ""TInterpreter.h""; 50#include ""TMemberInspector.h""; 51#include ""TRefTable.h""; 52#include ""TProcessID.h""; 53 ; 54Longptr_t TObject::fgDtorOnly = 0;; 55Bool_t TObject::fgObjectStat = kTRUE;; 56 ; 57ClassImp(TObject);; 58 ; 59#if defined(__clang__) || defined (__GNUC__); 60# define ATTRIBUTE_NO_SANITIZE_ADDRESS __attribute__((no_sanitize_address)); 61#else; 62# define ATTRIBUTE_NO_SANITIZE_ADDRESS; 63#endif; 64 ; 65namespace ROOT {; 66namespace Internal {; 67 ; 68// Return true if delete changes/poisons/taints the memory.; 69//; 70// Detect whether operator delete taints the memory. If it does, we can not rely; 71// on TestBit(kNotDeleted) to check if the memory has been deleted (but in case,; 72// like TClonesArray, where we know the destructor will be called but not operator; 73// delete, we can still use it to detect the cases where the destructor was called.; 74 ; 75ATTRIBUTE_NO_SANITIZE_ADDRESS; 76bool DeleteChangesMemoryImpl(); 77{; 78 static constexpr UInt_t kGoldenUUID = 0x00000021;; 79 static constexpr UInt_t kGoldenbits = 0x03000000;; 80 ; 81 TObject *o = new TObject;; 82 o->SetUniqueID(kGoldenUUID);; 83 UInt_t *o_fuid = &(o->fUniqueID);; 84 UInt_t *o_fbits = &(o->fBits);; 85 ; 86 if (*o_fuid != kGoldenUUID) {; 87 Error(""CheckingDeleteSideEffects"",; 88 ""fUniqueID is not as expected, we got 0x%.8x instead of 0x%.8x"",; 89 *o_fuid, kGoldenUUID);; 90 }; 91 if (*o_fbits != kGoldenbits) {; 92 Error(""CheckingDeleteSideEffects"",; 93 ""fBits is not as expected, we got 0x%.8x instead of 0x%.8x"",; 94 *o_fbits, kGoldenbits);; 95 }; 96 if (gDebug >= 9) {; 97 unsigned char *oc = reinterpret_cast<unsigned char *>(o); // for address calculations; 98 unsigned char references[sizeof(TObject)];; 99 memcpy(referen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:2538,detect,detect,2538,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,1,['detect'],['detect']
Safety,"Volume(). Int_t TGeoManager::ReplaceVolume ; (; TGeoVolume *Â ; vorig, . TGeoVolume *Â ; vnewÂ . ). Replaces all occurrences of VORIG with VNEW in the geometry tree. ; The volume VORIG is not replaced from the list of volumes, but all node referencing it will reference VNEW instead. Returns number of occurrences changed. ; Definition at line 1125 of file TGeoManager.cxx. â—†Â ResetState(). void TGeoManager::ResetState ; (; ). Reset current state flags. ; Definition at line 2774 of file TGeoManager.cxx. â—†Â ResetUserData(). void TGeoManager::ResetUserData ; (; ). Sets all pointers TGeoVolume::fField to NULL. ; User data becomes decoupled from geometry. Deletion has to be managed by users. ; Definition at line 3097 of file TGeoManager.cxx. â—†Â RestoreMasterVolume(). void TGeoManager::RestoreMasterVolume ; (; ). Restore the master volume of the geometry. ; Definition at line 3118 of file TGeoManager.cxx. â—†Â Safety(). Double_t TGeoManager::Safety ; (; Bool_tÂ ; inside = kFALSE). Compute safe distance from the current point. ; This represent the distance from POINT to the closest boundary. ; Definition at line 2300 of file TGeoManager.cxx. â—†Â SamplePoints(). TGeoNode * TGeoManager::SamplePoints ; (; Int_tÂ ; npoints, . Double_t &Â ; dist, . Double_tÂ ; epsil = 1E-5, . const char *Â ; g3path = """"Â . ). shoot npoints randomly in a box of 1E-5 around current point. ; return minimum distance to points outside ; Definition at line 3647 of file TGeoManager.cxx. â—†Â SaveAttributes(). void TGeoManager::SaveAttributes ; (; const char *Â ; filename = ""tgeoatt.C""). Save current attributes in a macro. ; Definition at line 2658 of file TGeoManager.cxx. â—†Â SearchNode(). TGeoNode * TGeoManager::SearchNode ; (; Bool_tÂ ; downwards = kFALSE, . const TGeoNode *Â ; skipnode = nullptrÂ . ). Returns the deepest node containing fPoint, which must be set a priori. ; Definition at line 2716 of file TGeoManager.cxx. â—†Â SelectTrackingMedia(). void TGeoManager::SelectTrackingMedia ; (; ). Define different tracking media. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:130865,safe,safe,130865,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['safe'],['safe']
Safety,"We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would only reduce the available training; : information. However, if the performance on the training sample is ; : found to be significantly better than the one found with the inde-; : pendent test sample, caution is needed. The results for these samples ; : are printed to standard output at the end of each training job.; : ; : â›[1m--- Performance tuning via configuration options:â›[0m; : ; : The hidden layer architecture for all ANNs is defined by the option; : ""HiddenLayers=N+1,N,..."", where here the first hidden layer has N+1; : neurons and the second N neurons (and so on), and where N is the number ; : of input variables. Excessive numbers of hidden layers should be avoided,; : in favour of more neurons in the first hidden layer.; : ; : The number of cycles should be above 500. As said, if the number of; : adjustable weights is small compared to the training sample size,; : using a large number of training samples should not lead to overtraining.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : â›[1m================================================================â›[0m; : ; TFHandler_MLPBNN : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.089214 0.20183 [ -1.0000 1.0000 ]; : myvar2: -0.090751 0.29609 [ -1.0000 1.0000 ]; : var3: 0.059878 0.21436 [ -1.0000 1.0000 ]; : var4: 0.11587 0.24261 [ -1.0000 1.0000 ]; : -----------------------------------------------------------; : Training Network; : ; : Finalizing handling of Regulator terms, trainE=0.713219 testE=0.724617; : Done with handling of Regulator terms; : Elapsed time for training with 2000 events: 2.56 sec ; MLPBNN : [data",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:44025,avoid,avoided,44025,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['avoid'],['avoided']
Safety,"WebDisplayHandle (const std::string &url); Â constructor ; Â ; virtualÂ ~RWebDisplayHandle ()=default; Â required virtual destructor for correct cleanup at the end ; Â ; const std::string &Â GetContent () const; Â get content ; Â ; const std::string &Â GetUrl () const; Â returns url of start web display ; Â ; voidÂ SetContent (const std::string &cont); Â set content ; Â . Static Public Member Functions; static voidÂ AddCreator (); Â ; Â Static Public Member Functions inherited from ROOT::RWebDisplayHandle; static boolÂ CanProduceImages (const std::string &browser=""""); Â Returns true if image production for specified browser kind is supported If browser not specified - use currently configured browser or try to test existing web browsers. ; Â ; static std::unique_ptr< RWebDisplayHandle >Â Display (const RWebDisplayArgs &args); Â Create web display. ; Â ; static boolÂ DisplayUrl (const std::string &url); Â Display provided url in configured web browser. ; Â ; static std::stringÂ GetImageFormat (const std::string &fname); Â Detect image format There is special handling of "".screenshot.pdf"" and "".screenshot.png"" extensions Creation of such files relies on headless browser functionality and fully supported only by Chrome browser. ; Â ; static boolÂ NeedHttpServer (const RWebDisplayArgs &args); Â Check if http server required for display. ; Â ; static boolÂ ProduceImage (const std::string &fname, const std::string &json, int width=800, int height=600, const char *batch_file=nullptr); Â Produce image file using JSON data as source Invokes JSROOT drawing functionality in headless browser - Google Chrome or Mozilla Firefox. ; Â ; static boolÂ ProduceImages (const std::string &fname, const std::vector< std::string > &jsons, const std::vector< int > &widths, const std::vector< int > &heights, const char *batch_file=nullptr); Â Produce image file(s) using JSON data as source Invokes JSROOT drawing functionality in headless browser - Google Chrome or Mozilla Firefox. ; Â ; static boolÂ ProduceImages (const std::vecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RQt5WebDisplayHandle.html:1698,Detect,Detect,1698,doc/master/classROOT_1_1RQt5WebDisplayHandle.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RQt5WebDisplayHandle.html,2,['Detect'],['Detect']
Safety,"Write array of UShort_t to buffer. void WriteFastArray(const Int_t *i, Int_t n); Write array of Int_t to buffer. void WriteFastArray(const UInt_t *i, Int_t n); Write array of UInt_t to buffer. void WriteFastArray(const Long_t *l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t *l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t *l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t *l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t *f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t *d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void *obj, const type_info &typeinfo, const TClass* /* onFileClass */ ); steram object to/from buffer. void StreamObject(void *obj, const char *className, const TClass* /* onFileClass */ ); steram object to/from buffer. void StreamObject(TObject* obj); steram object to/from buffer. void StreamObject(void *obj, const TClass *cl, const TClass* /* onfileClass */ ); steram object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t val",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferXML.html:38346,avoid,avoid,38346,root/html526/TBufferXML.html,https://root.cern,https://root.cern/root/html526/TBufferXML.html,1,['avoid'],['avoid']
Safety,"Write array of UShort_t to buffer. void WriteFastArray(const Int_t* i, Int_t n); Write array of Int_t to buffer. void WriteFastArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(TObject* obj); steram object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); steram object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferXML.html:40277,avoid,avoid,40277,root/html528/TBufferXML.html,https://root.cern,https://root.cern/root/html528/TBufferXML.html,6,['avoid'],['avoid']
Safety,"Write array of UShort_t to buffer. void WriteFastArray(const Int_t* i, Int_t n); Write array of Int_t to buffer. void WriteFastArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(TObject* obj); stream object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); stream object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferJSON.html:35703,avoid,avoid,35703,root/html534/TBufferJSON.html,https://root.cern,https://root.cern/root/html534/TBufferJSON.html,3,['avoid'],['avoid']
Safety,"X"",""one histogram is empty"");; 2243 return 0.0;; 2244 }; 2245 ; 2246 if ( comparisonWW && ( sumw1 <= 0.0 && sumw2 <= 0.0 ) ){; 2247 Error(""Chi2TestX"",""Hist1 and Hist2 have both all zero errors\n"");; 2248 return 0.0;; 2249 }; 2250 ; 2251 //THE TEST; 2252 Int_t m = 0, n = 0;; 2253 ; 2254 //Experiment - experiment comparison; 2255 if (comparisonUU) {; 2256 Double_t sum = sum1 + sum2;; 2257 for (Int_t i = i_start; i <= i_end; ++i) {; 2258 for (Int_t j = j_start; j <= j_end; ++j) {; 2259 for (Int_t k = k_start; k <= k_end; ++k) {; 2260 ; 2261 Int_t bin = GetBin(i, j, k);; 2262 ; 2263 Double_t cnt1 = RetrieveBinContent(bin);; 2264 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2265 ; 2266 if (scaledHistogram) {; 2267 // scale bin value to effective bin entries; 2268 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2269 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2270 ; 2271 if (e1sq > 0) cnt1 = TMath::Floor(cnt1 * cnt1 / e1sq + 0.5); // avoid rounding errors; 2272 else cnt1 = 0;; 2273 ; 2274 if (e2sq > 0) cnt2 = TMath::Floor(cnt2 * cnt2 / e2sq + 0.5); // avoid rounding errors; 2275 else cnt2 = 0;; 2276 }; 2277 ; 2278 if (Int_t(cnt1) == 0 && Int_t(cnt2) == 0) --ndf; // no data means one degree of freedom less; 2279 else {; 2280 ; 2281 Double_t cntsum = cnt1 + cnt2;; 2282 Double_t nexp1 = cntsum * sum1 / sum;; 2283 //Double_t nexp2 = binsum*sum2/sum;; 2284 ; 2285 if (res) res[i - i_start] = (cnt1 - nexp1) / TMath::Sqrt(nexp1);; 2286 ; 2287 if (cnt1 < 1) ++m;; 2288 if (cnt2 < 1) ++n;; 2289 ; 2290 //Habermann correction for residuals; 2291 Double_t correc = (1. - sum1 / sum) * (1. - cntsum / sum);; 2292 if (res) res[i - i_start] /= TMath::Sqrt(correc);; 2293 ; 2294 Double_t delta = sum2 * cnt1 - sum1 * cnt2;; 2295 chi2 += delta * delta / cntsum;; 2296 }; 2297 }; 2298 }; 2299 }; 2300 chi2 /= sum1 * sum2;; 2301 ; 2302 // flag error only when of the two histogram is zero; 2303 if (m) {; 2304 igood += 1;; 2305 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:91542,avoid,avoid,91542,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['avoid'],['avoid']
Safety,"XNGSystem*fSystemUsed to access filesystem interface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetXNGFileStager(const char* url = """"); Constructor. param url: the URL of the entry-point server. ~TNetXNGFileStager(); Destructor. Bool_t IsStaged(const char* path); Check if a file is staged. param path: the URL of the file. Int_t Locate(const char* path, TString& endpath); Get actual endpoint URL. param path: the entry-point URL; param endpath: the actual endpoint URL; returns: 0 in the case of success and 1 if any error occurred. Int_t LocateCollection(TFileCollection* fc, Bool_t addDummyUrl = kFALSE); Bulk locate request for a collection of files. param fc: collection of files to be located; param addDummyUrl: append a dummy noop URL if the file is not staged or; redirector == endpoint; returns: < 0 in case of errors, number of files processed; otherwise. Bool_t Matches(const char* s); Returns kTRUE if stager 's' is compatible with current stager. Avoids; multiple instantiations of the potentially the same TNetXNGFileStager. Bool_t Stage(const char* path, Option_t* opt = 0); Issue a stage request for a single file. param path: the path of the file to stage; param opt: defines 'option' and 'priority' for 'Prepare': the format is; opt = ""option=o priority=p"". Bool_t Stage(TCollection* pathlist, Option_t* opt = 0); Issue stage requests for multiple files. param pathlist: list of paths of files to stage; param opt: defines 'option' and 'priority' for 'Prepare': the; format is opt = ""option=o priority=p"". UChar_t ParseStagePriority(Option_t* opt); Get a staging priority value from an option string. TNetXNGFileStager(const char* url = """"). Bool_t IsValid() const; { return (fSystem ? kTRUE : kFALSE); }. Â» Last changed: root/netxng:$Id$ Â» Last generated: 2015-03-14 16:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetXNGFileStager.html:7265,Avoid,Avoids,7265,root/html534/TNetXNGFileStager.html,https://root.cern,https://root.cern/root/html534/TNetXNGFileStager.html,1,['Avoid'],['Avoids']
Safety,"XNGSystem*fSystemUsed to access filesystem interface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetXNGFileStager(const char* url = """"); Constructor. param url: the URL of the entry-point server. ~TNetXNGFileStager(); Destructor. Bool_t IsStaged(const char* path); Check if a file is staged. param path: the URL of the file. Int_t Locate(const char* path, TString& endpath); Get actual endpoint URL. param path: the entry-point URL; param endpath: the actual endpoint URL; returns: 0 in the case of success and 1 if any error occurred. Int_t LocateCollection(TFileCollection* fc, Bool_t addDummyUrl = kFALSE); Bulk locate request for a collection of files. param fc: collection of files to be located; param addDummyUrl: append a dummy noop URL if the file is not staged or; redirector == endpoint; returns: < 0 in case of errors, number of files processed; otherwise. Bool_t Matches(const char* s); Returns kTRUE if stager 's' is compatible with current stager. Avoids; multiple instantiations of the potentially the same TNetXNGFileStager. Bool_t Stage(const char* path, Option_t* opt = 0); Issue a stage request for a single file. param path: the path of the file to stage; param opt: defines 'option' and 'priority' for 'Prepare': the format is; opt = ""option=o priority=p"". Bool_t Stage(TCollection* pathlist, Option_t* opt = 0); Issue stage requests for multiple files. param pathlist: list of paths of files to stage; param opt: defines 'option' and 'priority' for 'Prepare': the; format is opt = ""option=o priority=p"". UChar_t ParseStagePriority(Option_t* opt); Get a staging priority value from an option string. TNetXNGFileStager(const char* url = """"). Bool_t IsValid() const; { return (fSystem ? kTRUE : kFALSE); }. Â» Last changed: root/netxng:$Id$ Â» Last generated: 2015-06-02 16:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TNetXNGFileStager.html:7726,Avoid,Avoids,7726,root/html604/TNetXNGFileStager.html,https://root.cern,https://root.cern/root/html604/TNetXNGFileStager.html,1,['Avoid'],['Avoids']
Safety,"XNGSystem*fSystemUsed to access filesystem interface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetXNGFileStager(const char* url = """"); Constructor. param url: the URL of the entry-point server. ~TNetXNGFileStager(); Destructor. Bool_t IsStaged(const char* path); Check if a file is staged. param path: the URL of the file. Int_t Locate(const char* path, TString& endpath); Get actual endpoint URL. param path: the entry-point URL; param endpath: the actual endpoint URL; returns: 0 in the case of success and 1 if any error occurred. Int_t LocateCollection(TFileCollection* fc, Bool_t addDummyUrl = kFALSE); Bulk locate request for a collection of files. param fc: collection of files to be located; param addDummyUrl: append a dummy noop URL if the file is not staged or; redirector == endpoint; returns: < 0 in case of errors, number of files processed; otherwise. Bool_t Matches(const char* s); Returns kTRUE if stager 's' is compatible with current stager. Avoids; multiple instantiations of the potentially the same TNetXNGFileStager. Bool_t Stage(const char* path, Option_t* opt = 0); Issue a stage request for a single file. param path: the path of the file to stage; param opt: defines 'option' and 'priority' for 'Prepare': the format is; opt = ""option=o priority=p"". Bool_t Stage(TCollection* pathlist, Option_t* opt = 0); Issue stage requests for multiple files. param pathlist: list of paths of files to stage; param opt: defines 'option' and 'priority' for 'Prepare': the; format is opt = ""option=o priority=p"". UChar_t ParseStagePriority(Option_t* opt); Get a staging priority value from an option string. TNetXNGFileStager(const char* url = """"). Bool_t IsValid() const; { return (fSystem ? kTRUE : kFALSE); }. Â» Last changed: root/netxng:$Id$ Â» Last generated: 2015-06-30 15:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetXNGFileStager.html:7726,Avoid,Avoids,7726,root/html602/TNetXNGFileStager.html,https://root.cern,https://root.cern/root/html602/TNetXNGFileStager.html,1,['Avoid'],['Avoids']
Safety,"XXRecordDecl *cxxRcd =; 3235 llvm::dyn_cast_or_null<clang::CXXRecordDecl>(annotatedRcd.GetRecordDecl())) {; 3236 autoParseKey = """";; 3237 visitedDecls.clear();; 3238 std::list<std::string> headers(RecordDecl2Headers(*cxxRcd, interp, visitedDecls));; 3239 // remove duplicates, also if not subsequent; 3240 buffer.clear();; 3241 headers.remove_if([&buffer](const std::string & s) {; 3242 return !buffer.insert(s).second;; 3243 });; 3244 GetMostExternalEnclosingClassName(*cxxRcd, autoParseKey, interp);; 3245 if (autoParseKey.empty()) autoParseKey = annotatedRcd.GetNormalizedName();; 3246 if (IsGoodForAutoParseMap(*cxxRcd)){; 3247 headersDeclsMap[autoParseKey] = headers;; 3248 headersDeclsMap[annotatedRcd.GetRequestedName()] = headers;; 3249 } else {; 3250 ROOT::TMetaUtils::Info(nullptr, ""Class %s is not included in the set of autoparse keys.\n"", autoParseKey.c_str());; 3251 }; 3252 ; 3253 // Propagate to the classes map only if this is not a template.; 3254 // The header is then used as autoload key and we want to avoid duplicates.; 3255 if (!llvm::isa<clang::ClassTemplateSpecializationDecl>(cxxRcd)){; 3256 headersClassesMap[autoParseKey] = headersDeclsMap[autoParseKey];; 3257 headersClassesMap[annotatedRcd.GetRequestedName()] = headersDeclsMap[annotatedRcd.GetRequestedName()];; 3258 }; 3259 }; 3260 }; 3261 ; 3262 // The same for the typedefs:; 3263 for (auto & tDef : tDefDecls) {; 3264 if (clang::CXXRecordDecl *cxxRcd = tDef->getUnderlyingType()->getAsCXXRecordDecl()) {; 3265 autoParseKey = """";; 3266 visitedDecls.clear();; 3267 std::list<std::string> headers(RecordDecl2Headers(*cxxRcd, interp, visitedDecls));; 3268 headers.push_back(ROOT::TMetaUtils::GetFileName(*tDef, interp));; 3269 // remove duplicates, also if not subsequent; 3270 buffer.clear();; 3271 headers.remove_if([&buffer](const std::string & s) {; 3272 return !buffer.insert(s).second;; 3273 });; 3274 GetMostExternalEnclosingClassNameFromDecl(*tDef, autoParseKey, interp);; 3275 if (autoParseKey.empty()) autoPa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:129416,avoid,avoid,129416,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['avoid'],['avoid']
Safety,"Xmin);; 1324 hobj->SetMaximum(fXmax);; 1325 } else {; 1326 hobj->SetMinimum();; 1327 hobj->SetMaximum();; 1328 hobj->ResetBit(TH1::kIsZoomed);; 1329 }; 1330 } else {; 1331 hobj->GetXaxis()->SetRange(0,0);; 1332 }; 1333 }; 1334 ; 1335 gPad->UnZoomed();; 1336}; 1337 ; 1338////////////////////////////////////////////////////////////////////////////////; 1339/// Zoom out by a factor of 'factor' (default =2); 1340/// uses previous zoom factor by default; 1341/// Keep center defined by 'offset' fixed; 1342/// ie. -1 at left of current range, 0 in center, +1 at right; 1343 ; 1344void TAxis::ZoomOut(Double_t factor, Double_t offset); 1345{; 1346 ; 1347 if (factor <= 0) factor = 2;; 1348 Double_t center = (GetFirst()*(1-offset) + GetLast()*(1+offset))/2.;; 1349 Int_t first = int(TMath::Floor(center+(GetFirst()-center)*factor + 0.4999999));; 1350 Int_t last = int(TMath::Floor(center+(GetLast() -center)*factor + 0.5000001));; 1351 if (first==GetFirst() && last==GetLast()) { first--; last++; }; 1352 SetRange(first,last);; 1353}; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Long_tlong Long_tDefinition RtypesCore.h:54; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TAxisModLab.h; TAxis.h; TBuffer.h; TDatime.h; TError.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TAxis_8cxx_source.html:45630,Safe,SafeDelete,45630,doc/master/TAxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html,2,['Safe'],['SafeDelete']
Safety,"Z divisions. For radialdivision; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyS(Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz = 0); Static method to compute the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetTubsDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); Set dimensions of the tube segment. void SetDimensions(Double_t* param); Set dimensions of the tube segment starting from a list. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n random points located on the line segments of the shape mesh.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation is implemented. void SetPoints(Double_t* points) const; Create tube s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTubeSeg.html:16692,Safe,Safety,16692,root/html528/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html528/TGeoTubeSeg.html,3,['Safe'],['Safety']
Safety,"Zombie. protected:. intfHighBin; intfLowBin; doublefLumiError; doublefNomLumi; map<string,double>fParamValues; vector<string>fSystToFix. private:. stringfObsName; vector<string>fObsNameVec; vector<string>fPreprocessFunctions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HistoToWorkspaceFactoryFast(); {}. ~HistoToWorkspaceFactoryFast(). HistoToWorkspaceFactoryFast(RooStats::HistFactory::Measurement& Meas). void ConfigureWorkspaceForMeasurement(const string& ModelName, RooWorkspace* ws_single, RooStats::HistFactory::Measurement& measurement). RooWorkspace* MakeSingleChannelModel(RooStats::HistFactory::Measurement& measurement, RooStats::HistFactory::Channel& channel). RooWorkspace* MakeCombinedModel(RooStats::HistFactory::Measurement& measurement). void ProcessExpectedHisto(TH1* hist, RooWorkspace* proto, string prefix, string productPrefix, string systTerm). void AddMultiVarGaussConstraint(RooWorkspace* proto, string prefix, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins. void LinInterpWithConstraint(RooWorkspace* proto, TH1* nominal, vector<RooStats::HistFactory::HistoSys> , string prefix, string productPrefix, string systTerm, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins; require dimension >=1 or <=3. { fObsNameVec.push_back(fObsName); }. string AddNormFactor(RooWorkspace* proto, string& channel, string& sigmaEpsilon, RooStats::HistFactory::Sample& sample, bool doRatio). void AddConstraintTerms(RooWorkspace* proto, RooStats::HistFactory::Measurement& measurement, string prefix, string interpName, vector<RooStats::HistFactory::OverallSys>& systList, vector<string>& likelihoodTermNames, vector<string>& totSystTermNames); add variables for all the relative overall uncert",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html:9912,predict,predictions,9912,root/html604/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,https://root.cern,https://root.cern/root/html604/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,1,['predict'],['predictions']
Safety,"Zombie. protected:. intfHighBin; intfLowBin; doublefLumiError; doublefNomLumi; map<string,double>fParamValues; vector<string>fSystToFix. private:. stringfObsName; vector<string>fObsNameVec; vector<string>fPreprocessFunctions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HistoToWorkspaceFactoryFast(); {}. ~HistoToWorkspaceFactoryFast(). HistoToWorkspaceFactoryFast(RooStats::HistFactory::Measurement& Meas). void ConfigureWorkspaceForMeasurement(const string& ModelName, RooWorkspace* ws_single, RooStats::HistFactory::Measurement& measurement). RooWorkspace* MakeSingleChannelModel(RooStats::HistFactory::Measurement& measurement, RooStats::HistFactory::Channel& channel). RooWorkspace* MakeCombinedModel(RooStats::HistFactory::Measurement& measurement). void ProcessExpectedHisto(TH1* hist, RooWorkspace* proto, string prefix, string productPrefix, string systTerm). void AddMultiVarGaussConstraint(RooWorkspace* proto, string prefix, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins. void LinInterpWithConstraint(RooWorkspace* proto, TH1* nominal, vector<RooStats::HistFactory::HistoSys> , string prefix, string productPrefix, string systTerm, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins; require dimension >=1 or <=3. { fObsNameVec.push_back(fObsName); }. string AddNormFactor(RooWorkspace* proto, string& channel, string& sigmaEpsilon, RooStats::HistFactory::Sample& sample, bool doRatio). void AddEfficiencyTerms(RooWorkspace* proto, string prefix, string interpName, vector<RooStats::HistFactory::OverallSys>& systList, vector<string>& likelihoodTermNames, vector<string>& totSystTermNames); add variables for all the relative overall uncertainties we expect; range is set using defined mac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html:9863,predict,predictions,9863,root/html602/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,1,['predict'],['predictions']
Safety,"[1/4]. Int_t TProof::Collect ; (; const TSlave *Â ; sl, . Long_tÂ ; timeout = -1, . Int_tÂ ; endtype = -1, . Bool_tÂ ; deactonfail = kFALSEÂ . ). private . Collect responses from slave sl. ; Returns the number of slaves that responded (=1). If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2669 of file TProof.cxx. â—†Â Collect() [2/4]. Int_t TProof::Collect ; (; ESlavesÂ ; list = kActive, . Long_tÂ ; timeout = -1, . Int_tÂ ; endtype = -1, . Bool_tÂ ; deactonfail = kFALSEÂ . ). protected . Collect responses from the slave servers. ; Returns the number of slaves that responded. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2727 of file TProof.cxx. â—†Â Collect() [3/4]. Int_t TProof::Collect ; (; TList *Â ; slaves, . Long_tÂ ; timeout = -1, . Int_tÂ ; endtype = -1, . Bool_tÂ ; deactonfail = kFALSEÂ . ). protected . Collect responses from the slave servers. ; Returns the number of slaves that responded. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2696 of file TProof.cxx. â—†Â Collect() [4/4]. Int_t TProof::Collect ; (; TMonitor *Â ; mon, . Long_tÂ ; timeout = -1, . Int_tÂ ; endtype = -1, . Bool_tÂ ; deactonfail = kFALSEÂ . ). private . Collect responses from the slave servers. ; Returns the number of messages received. Can be 0 if there are no active slaves. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. Collect also stops its execution from time to time to check for new workers in Dynamic Startup mode. ; Definition at line 2756 of file TProof.cxx. â—†Â CollectInpu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:77921,timeout,timeout,77921,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['timeout'],['timeout']
Safety,"[1]=4.000000+-1.000000; par[2]=0.999884+-0.000125; par[3]=2.000070+-0.000123; par[4]=2.999910+-0.000127; par[5]=0.199920+-0.000130; chisquare=145.602523231220914; ; #include ""TLinearFitter.h""; #include ""TF1.h""; #include ""TRandom.h""; ; void fitLinear2(); {; int n=100;; int i;; TRandom randNum;; TLinearFitter *lf=new TLinearFitter(5);; ; //The predefined ""hypN"" functions are the fastest to fit; lf->SetFormula(""hyp5"");; ; double *x=new double[n*10*5];; double *y=new double[n*10];; double *e=new double[n*10];; ; //Create the points and put them into the fitter; for (i=0; i<n; i++){; x[0 + i*5] = randNum.Uniform(-10, 10);; x[1 + i*5] = randNum.Uniform(-10, 10);; x[2 + i*5] = randNum.Uniform(-10, 10);; x[3 + i*5] = randNum.Uniform(-10, 10);; x[4 + i*5] = randNum.Uniform(-10, 10);; e[i] = 0.01;; y[i] = 4*x[0+i*5] + x[1+i*5] + 2*x[2+i*5] + 3*x[3+i*5] + 0.2*x[4+i*5] + randNum.Gaus()*e[i];; }; ; //To avoid copying the data into the fitter, the following function can be used:; lf->AssignData(n, 5, x, y, e);; //A different way to put the points into the fitter would be to use; //the AddPoint function for each point. This way the points are copied and stored; //inside the fitter; ; //Perform the fitting and look at the results; lf->Eval();; TVectorD params;; TVectorD errors;; lf->GetParameters(params);; lf->GetErrors(errors);; for (int i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; double chisquare=lf->GetChisquare();; printf(""chisquare=%f\n"", chisquare);; ; ; //Now suppose you want to add some more points and see if the parameters will change; for (i=n; i<n*2; i++) {; x[0+i*5] = randNum.Uniform(-10, 10);; x[1+i*5] = randNum.Uniform(-10, 10);; x[2+i*5] = randNum.Uniform(-10, 10);; x[3+i*5] = randNum.Uniform(-10, 10);; x[4+i*5] = randNum.Uniform(-10, 10);; e[i] = 0.01;; y[i] = 4*x[0+i*5] + x[1+i*5] + 2*x[2+i*5] + 3*x[3+i*5] + 0.2*x[4+i*5] + randNum.Gaus()*e[i];; }; ; //Assign the data the same way as before; lf->AssignData(n*2, 5, x, y, e);; lf->Eval();; lf-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/fitLinear2_8C.html:1987,avoid,avoid,1987,doc/master/fitLinear2_8C.html,https://root.cern,https://root.cern/doc/master/fitLinear2_8C.html,1,['avoid'],['avoid']
Safety,"\a SmallVectorTemplateCommon::getFirstEl() is; 503/// well-defined.; 504template <typename T>; 505struct alignas(T) SmallVectorStorage<T, 0> {; 506};; 507 ; 508/// The size of the inline storage of an RVec.; 509/// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); 510/// unless the size of the buffer with 8 elements would be over a certain maximum size.; 511template <typename T>; 512struct RVecInlineStorageSize {; 513private:; 514#ifdef R__HAS_HARDWARE_INTERFERENCE_SIZE; 515 constexpr std::size_t cacheLineSize = std::hardware_destructive_interference_size;; 516#else; 517 // safe bet: assume the typical 64 bytes; 518 static constexpr std::size_t cacheLineSize = 64;; 519#endif; 520 static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);; 521 static constexpr unsigned maxInlineByteSize = 1024;; 522 ; 523public:; 524 static constexpr unsigned value =; 525 elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8);; 526};; 527 ; 528// A C++14-compatible implementation of std::uninitialized_value_construct; 529template <typename ForwardIt>; 530void UninitializedValueConstruct(ForwardIt first, ForwardIt last); 531{; 532#if __cplusplus < 201703L; 533 for (; first != last; ++first); 534 new (static_cast<void *>(std::addressof(*first))) typename std::iterator_traits<ForwardIt>::value_type();; 535#else; 536 std::uninitialized_value_construct(first, last);; 537#endif; 538}; 539 ; 540/// An unsafe function to reset the buffer for which this RVec is acting as a view.; 541///; 542/// \note This is a low-level method that _must_ be called on RVecs that are already non-owning:; 543/// - it does not put the RVec in ""non-owning mode"" (fCapacity == -1); 544/// - it does not free any owned buffer; 545template <typename T>; 546void ResetView(RVec<T> &v, T* addr, std::size_t sz); 547{; 548 v.fBeginX = addr;; 549 v.fSize = sz;; 550}; 551 ; 552} // namespace VecOps; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RVec_8hxx_source.html:19032,safe,safe,19032,doc/v632/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RVec_8hxx_source.html,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"\cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; Before ROOT 6.24, RooFit always passed the highest function value that was encountered during the minimisation to the minimiser. If a parameter is far in a disallowed region, the minimiser has to blindly test various values of the parameters. It might find the correct values by chance, but often be unable to recover from bad starting values. Here, we use a model with such bad values.; Starting with ROOT 6.24, the minimiser receives more information. For example, when a PDF is negative, the magnitude of the ""undershoot"" is passed to the minimiser. The minimiser can use this to compute a gradient, which will eventually lead it out of the disallowed region. The steepness of this gradient can be chosen using RooFit::RecoverFromUndefinedRegions(double). A value of zero is equivalent to RooFit before ROOT 6.24. Positive values activate the recovery. Values between 1. and 10. were found to be a good default. If no argument is passed, RooFit uses 10.; ; #include <RooRealVar.h>; #include <RooPolynomial.h>; #include <RooPlot.h>; #include <RooDataSet.h>; #include <RooGlobalFunc.h>; #include <RooFitResult.h>; #include <RooMsgService.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; void rf612_recoverFromInvalidParameters() {; ; // Create a fit model:; // The polynomial is notoriously unstable, because it can quickly go negative.; // Since PDFs need to be positive, one often ends up with an unstable fit model.; RooRealVar x(""x"", ""x"", -15, 15);; RooRealVar a1(""a1"", ""a1"", -0.5, -10., 20.);; RooRealVar a2(""a2"", ""a2"", 0.2, -10., 20.);; RooRealVar a3(""a3"", ""a3"", 0.01);; RooPolynomial pdf(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, RooArgSet(a1, a2, a3));; ; // Create toy data with all-posit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:1531,Recover,RecoverFromUndefinedRegions,1531,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,1,['Recover'],['RecoverFromUndefinedRegions']
Safety,"\n"", executableFileName, filein.c_str());; 4129 return 1;; 4130 }; 4131 fclose(fp);; 4132 }; 4133 ; 4134 if (IsImplementationName(gOptDictionaryFileName)) {; 4135 FILE *fp;; 4136 if (!gOptIgnoreExistingDict && (fp = fopen(gOptDictionaryFileName.c_str(), ""r"")) != nullptr) {; 4137 fclose(fp);; 4138 if (!gOptForce) {; 4139 ROOT::TMetaUtils::Error(nullptr, ""%s: output file %s already exists\n"", executableFileName, gOptDictionaryFileName.c_str());; 4140 return 1;; 4141 }; 4142 }; 4143 ; 4144 // remove possible pathname to get the dictionary name; 4145 if (gOptDictionaryFileName.size() > (PATH_MAX - 1)) {; 4146 ROOT::TMetaUtils::Error(nullptr, ""rootcling: dictionary name too long (more than %d characters): %s\n"",; 4147 (PATH_MAX - 1), gOptDictionaryFileName.c_str());; 4148 return 1;; 4149 }; 4150 ; 4151 dictname = llvm::sys::path::filename(gOptDictionaryFileName).str();; 4152 }; 4153 ; 4154 if (gOptForce && dictname.empty()) {; 4155 ROOT::TMetaUtils::Error(nullptr, ""Inconsistent set of arguments detected: overwrite of dictionary file forced but no filename specified.\n"");; 4156 llvm::cl::PrintHelpMessage();; 4157 return 1;; 4158 }; 4159 ; 4160 std::vector<std::string> clingArgs;; 4161 clingArgs.push_back(executableFileName);; 4162 clingArgs.push_back(""-iquote."");; 4163 ; 4164 bool dictSelection = !gOptNoDictSelection;; 4165 ; 4166 // Collect the diagnostic pragmas linked to the usage of -W; 4167 // Workaround for ROOT-5656; 4168 std::list<std::string> diagnosticPragmas = {""#pragma clang diagnostic ignored \""-Wdeprecated-declarations\""""};; 4169 ; 4170 if (gOptFailOnWarnings) {; 4171 using namespace ROOT::TMetaUtils;; 4172 // If warnings are disabled with the current verbosity settings, lower; 4173 // it so that the user sees the warning that caused the failure.; 4174 if (GetErrorIgnoreLevel() > kWarning); 4175 GetErrorIgnoreLevel() = kWarning;; 4176 GetWarningsAreErrors() = true;; 4177 }; 4178 ; 4179 if (gOptISysRoot != ""-"") {; 4180 if (gOptISysRoot.empty()) {; 4181 ROOT::T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:168376,detect,detected,168376,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['detect'],['detected']
Safety,"] = -1;; 341 }; 342 ; 343 DeclareOptionRef( fCutRangeMin, GetNvar(), ""CutRangeMin"", ""Minimum of allowed cut range (set per variable)"" );; 344 DeclareOptionRef( fCutRangeMax, GetNvar(), ""CutRangeMax"", ""Maximum of allowed cut range (set per variable)"" );; 345 ; 346 fAllVarsI = new TString[GetNvar()];; 347 ; 348 for (UInt_t i=0; i<GetNvar(); i++) fAllVarsI[i] = ""NotEnforced"";; 349 ; 350 DeclareOptionRef(fAllVarsI, GetNvar(), ""VarProp"", ""Categorisation of cuts"");; 351 AddPreDefVal(TString(""NotEnforced""));; 352 AddPreDefVal(TString(""FMax""));; 353 AddPreDefVal(TString(""FMin""));; 354 AddPreDefVal(TString(""FSmart""));; 355}; 356 ; 357////////////////////////////////////////////////////////////////////////////////; 358/// process user options.; 359///; 360/// sanity check, do not allow the input variables to be normalised, because this; 361/// only creates problems when interpreting the cuts; 362 ; 363void TMVA::MethodCuts::ProcessOptions(); 364{; 365 if (IsNormalised()) {; 366 Log() << kWARNING << ""Normalisation of the input variables for cut optimisation is not"" << Endl;; 367 Log() << kWARNING << ""supported because this provides intransparent cut values, and no"" << Endl;; 368 Log() << kWARNING << ""improvement in the performance of the algorithm."" << Endl;; 369 Log() << kWARNING << ""Please remove \""Normalise\"" option from booking option string"" << Endl;; 370 Log() << kWARNING << ""==> Will reset normalisation flag to \""False\"""" << Endl;; 371 SetNormalised( kFALSE );; 372 }; 373 ; 374 if (IgnoreEventsWithNegWeightsInTraining()) {; 375 Log() << kFATAL << ""Mechanism to ignore events with negative weights in training not yet available for method: ""; 376 << GetMethodTypeName(); 377 << "" --> Please remove \""IgnoreNegWeightsInTraining\"" option from booking string.""; 378 << Endl;; 379 }; 380 ; 381 if (fFitMethodS == ""MC"" ) fFitMethod = kUseMonteCarlo;; 382 else if (fFitMethodS == ""MCEvents"") fFitMethod = kUseMonteCarloEvents;; 383 else if (fFitMethodS == ""GA"" ) fFitMethod = kUseGenet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:12687,sanity check,sanity check,12687,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['sanity check'],['sanity check']
Safety,"] = y1 // Y position of first plane; param[4] = scale1 // scale factor for first plane. param[4*(nz-1]+1] = zn; param[4*(nz-1)+2] = xn; param[4*(nz-1)+3] = yn; param[4*(nz-1)+4] = scalen. TGeoXtru(const TGeoXtru& ); copy constructor. TGeoXtru& operator=(const TGeoXtru& ); assignment operator. ~TGeoXtru(); destructor. Double_t Capacity() const; Compute capacity [length^3] of this shape. void ComputeBBox(); compute bounding box of the pcon. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistToPlane(Double_t* point, Double_t* dir, Int_t iz, Int_t ivert, Double_t stepmax, Bool_t in) const; Compute distance to a Xtru lateral surface. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone; locate Z segment. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; Warning(""DistFromOutside"", ""not implemented"");. Bool_t DefinePolygon(Int_t nvert, const Double_t* xv, const Double_t* yv); Creates the polygon representing the blueprint of any Xtru section.; nvert = number of vertices >2; xv[nvert] = array of X vertex positions; yv[nvert] = array of Y vertex positions; *NOTE* should be called before DefineSection or ctor with 'param'. void DefineSection(Int_t snum, Double_t z, Double_t x0 = 0., Double_t y0 = 0., Double_t scale = 1.); defines z position of a section plane, rmin and rmax at this z. Double_t GetZ(Int_t ipl) const; Return the Z coordinate for segment ipl. void GetPlaneNormal(const Double_t* vert, Double_t* norm) const; Returns normal vector t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoXtru.html:15540,safe,safe,15540,root/html532/TGeoXtru.html,https://root.cern,https://root.cern/root/html532/TGeoXtru.html,1,['safe'],['safe']
Safety,"] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortfAbortabort status; TList*fInputlist of objects available during processing; TObject*fObjectcurrent object if processing object (vs. TTree); TStringfOptionoption given to TTree::Process; TSelectorList*fOutputlist of objects created during processing; Long64_tfStatusselector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (either TSelectorDraw, TProofDraw or deriving from them). TSelector(const TSele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSelector.html:9361,abort,abort,9361,root/html528/TSelector.html,https://root.cern,https://root.cern/root/html528/TSelector.html,3,['abort'],['abort']
Safety,"](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoPgon&operator=(const TGeoPgon&); virtual voidTGeoShape::Paint(Option_t* option = """"); Double_t&TGeoPcon::Phi1(); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); Double_t&TGeoPcon::Rmax(Int_t ipl); Double_t&TGeoPcon::Rmin(Int_t ipl); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToSegment(const Double_t* point, Int_t ipl, Int_t iphi, Bool_t in, Double_t safphi, Double_t safmin = TGeoShape::Big()) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidSetNedges(Int_t ne); static voidTObject::SetObjectStat(Bool_t stat); virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPgon.html:9202,Safe,SafetySeg,9202,root/html602/TGeoPgon.html,https://root.cern,https://root.cern/root/html602/TGeoPgon.html,2,['Safe'],['SafetySeg']
Safety,"]; 17.5.4 Transformation of a TLorentzVector; To apply TLorentzRotation to TLorentzVector you can use either the VectorMultiplication() method or the * operator. You can also use the Transform() function and the *=operator of the class TLorentzVector.; TLorentzVector v;; TLorentzRotation l;; ...; v = l.VectorMultiplication(v);; v = l * v;; v.Transform(l);; v *= l; // v = l*v; 17.5.5 Physics Vector Example; The test file $ROOTSYS/test/TestVectors.cxx is an example of using physics vectors. The vector classes are not loaded by default, and to run it, you will need to load libPhysics.so first:; root[] .L $ROOTSYS/lib/libPhysics.so; root[] .x TestVectors.cxx; To load the physics vector library in a ROOT application use:; gSystem->Load(""libPhysics"");; The example $ROOTSYS/test/TestVectors.cxx does not return much, especially if all went well, but when you look at the code you will find examples for many calls.; 18 The Geometry Package. The new ROOT geometry package is a tool for building, browsing, navigating and visualizing detector geometries. The code works standalone with respect to any tracking Monte-Carlo engine; therefore, it does not contain any constraints related to physics. However, the navigation features provided by the package are designed to optimize particle transport through complex geometries, working in correlation with simulation packages such as GEANT3, GEANT4 and FLUKA.; 18.1 Quick Start: Creating the â€œworldâ€; This chapter will provide a detailed description on how to build valid geometries as well as the ways to optimize them. There are several components gluing together the geometrical model, but for the time being let us get used with the most basic concepts.; The basic bricks for building-up the model are called volumes.These represent the un-positioned pieces of the geometry puzzle. The difference is just that the relationship between the pieces is not defined by neighbors, but by containment. In other words, volumes are put one inside another ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:874836,detect,detector,874836,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detector']
Safety,"];; 16957 int n;; 16958#endif; 16959 struct linger linger;; 16960 int error_code = 0;; 16961 int linger_timeout = -2;; 16962 socklen_t opt_len = sizeof(error_code);; 16963 ; 16964 if (!conn) {; 16965 return;; 16966 }; 16967 ; 16968 /* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:; 16969 * ""Note that enabling a nonzero timeout on a nonblocking socket; 16970 * is not recommended."", so set it to blocking now */; 16971 set_blocking_mode(conn->client.sock);; 16972 ; 16973 /* Send FIN to the client */; 16974 shutdown(conn->client.sock, SHUTDOWN_WR);; 16975 ; 16976 ; 16977#if defined(_WIN32); 16978 /* Read and discard pending incoming data. If we do not do that and; 16979 * close; 16980 * the socket, the data in the send buffer may be discarded. This; 16981 * behaviour is seen on Windows, when client keeps sending data; 16982 * when server decides to close the connection; then when client; 16983 * does recv() it gets no data back. */; 16984 do {; 16985 n = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);; 16986 } while (n > 0);; 16987#endif; 16988 ; 16989 if (conn->dom_ctx->config[LINGER_TIMEOUT]) {; 16990 linger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);; 16991 }; 16992 ; 16993 /* Set linger option according to configuration */; 16994 if (linger_timeout >= 0) {; 16995 /* Set linger option to avoid socket hanging out after close. This; 16996 * prevent ephemeral port exhaust problem under high QPS. */; 16997 linger.l_onoff = 1;; 16998 ; 16999#if defined(_MSC_VER); 17000#pragma warning(push); 17001#pragma warning(disable : 4244); 17002#endif; 17003#if defined(GCC_DIAGNOSTIC); 17004#pragma GCC diagnostic push; 17005#pragma GCC diagnostic ignored ""-Wconversion""; 17006#endif; 17007 /* Data type of linger structure elements may differ,; 17008 * so we don't know what cast we need here.; 17009 * Disable type conversion warnings. */; 17010 ; 17011 linger.l_linger = (linger_timeout + 999) / 1000;; 17012 ; 17013#if defined(GCC_DIAGNOSTI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:504348,Timeout,Timeout,504348,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['Timeout'],['Timeout']
Safety,"];; 16958 int n;; 16959#endif; 16960 struct linger linger;; 16961 int error_code = 0;; 16962 int linger_timeout = -2;; 16963 socklen_t opt_len = sizeof(error_code);; 16964 ; 16965 if (!conn) {; 16966 return;; 16967 }; 16968 ; 16969 /* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:; 16970 * ""Note that enabling a nonzero timeout on a nonblocking socket; 16971 * is not recommended."", so set it to blocking now */; 16972 set_blocking_mode(conn->client.sock);; 16973 ; 16974 /* Send FIN to the client */; 16975 shutdown(conn->client.sock, SHUTDOWN_WR);; 16976 ; 16977 ; 16978#if defined(_WIN32); 16979 /* Read and discard pending incoming data. If we do not do that and; 16980 * close; 16981 * the socket, the data in the send buffer may be discarded. This; 16982 * behaviour is seen on Windows, when client keeps sending data; 16983 * when server decides to close the connection; then when client; 16984 * does recv() it gets no data back. */; 16985 do {; 16986 n = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);; 16987 } while (n > 0);; 16988#endif; 16989 ; 16990 if (conn->dom_ctx->config[LINGER_TIMEOUT]) {; 16991 linger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);; 16992 }; 16993 ; 16994 /* Set linger option according to configuration */; 16995 if (linger_timeout >= 0) {; 16996 /* Set linger option to avoid socket hanging out after close. This; 16997 * prevent ephemeral port exhaust problem under high QPS. */; 16998 linger.l_onoff = 1;; 16999 ; 17000#if defined(_MSC_VER); 17001#pragma warning(push); 17002#pragma warning(disable : 4244); 17003#endif; 17004#if defined(GCC_DIAGNOSTIC); 17005#pragma GCC diagnostic push; 17006#pragma GCC diagnostic ignored ""-Wconversion""; 17007#endif; 17008 /* Data type of linger structure elements may differ,; 17009 * so we don't know what cast we need here.; 17010 * Disable type conversion warnings. */; 17011 ; 17012 linger.l_linger = (linger_timeout + 999) / 1000;; 17013 ; 17014#if defined(GCC_DIAGNOSTI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:504381,Timeout,Timeout,504381,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['Timeout'],['Timeout']
Safety,"^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1171/// \f]; 1172/// where k is the double precision, ai are coefficients used in; 1173/// central difference formulas; 1174/// interpolation error is decreased by making the step size h smaller.; 1175///; 1176/// \author Anna Kreshuk; 1177 ; 1178Double_t TF1::Derivative2(Double_t x, Double_t *params, Double_t eps) const; 1179{; 1180 if (GetNdim() > 1) {; 1181 Warning(""Derivative2"", ""Function dimension is larger than one"");; 1182 }; 1183 ; 1184 ROOT::Math::RichardsonDerivator rd;; 1185 double xmin, xmax;; 1186 GetRange(xmin, xmax);; 1187 // this is not optimal (should be used the average x instead of the range); 1188 double h = eps * std::abs(xmax - xmin);; 1189 if (h <= 0) h = 0.001;; 1190 double der = 0;; 1191 if (params) {; 1192 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1193 wtf.SetParameters(params);; 1194 der = rd.Derivative2(wtf, x, h);; 1195 } else {; 1196 // no need to set parameters used a non-parametric wrapper to avoid allocating; 1197 // an array with parameter values; 1198 ROOT::Math::WrappedFunction<const TF1 & > wf(*this);; 1199 der = rd.Derivative2(wf, x, h);; 1200 }; 1201 ; 1202 gErrorTF1 = rd.Error();; 1203 ; 1204 return der;; 1205}; 1206 ; 1207 ; 1208////////////////////////////////////////////////////////////////////////////////; 1209/// Returns the third derivative of the function at point x,; 1210/// computed by Richardson's extrapolation method (use 2 derivative estimates; 1211/// to compute a third, more accurate estimation); 1212/// first, derivatives with steps h and h/2 are computed by central difference formulas; 1213/// \f[; 1214/// D(h) = \frac{f(x+2h) - 2f(x+h) + 2f(x-h) - f(x-2h)}{2h^{3}}; 1215/// \f]; 1216/// the final estimate; 1217/// \f[; 1218/// D = \frac{4D(h/2) - D(h)}{3}; 1219/// \f]; 1220/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1221///; 1222/// if the argument params is null, the current function parameters are used,; 1223/// otherwise the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:42966,avoid,avoid,42966,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['avoid'],['avoid']
Safety,"^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1236/// \f]; 1237/// where k is the double precision, ai are coefficients used in; 1238/// central difference formulas; 1239/// interpolation error is decreased by making the step size h smaller.; 1240///; 1241/// \author Anna Kreshuk; 1242 ; 1243Double_t TF1::Derivative3(Double_t x, Double_t *params, Double_t eps) const; 1244{; 1245 if (GetNdim() > 1) {; 1246 Warning(""Derivative3"", ""Function dimension is larger than one"");; 1247 }; 1248 ; 1249 ROOT::Math::RichardsonDerivator rd;; 1250 double xmin, xmax;; 1251 GetRange(xmin, xmax);; 1252 // this is not optimal (should be used the average x instead of the range); 1253 double h = eps * std::abs(xmax - xmin);; 1254 if (h <= 0) h = 0.001;; 1255 double der = 0;; 1256 if (params) {; 1257 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1258 wtf.SetParameters(params);; 1259 der = rd.Derivative3(wtf, x, h);; 1260 } else {; 1261 // no need to set parameters used a non-parametric wrapper to avoid allocating; 1262 // an array with parameter values; 1263 ROOT::Math::WrappedFunction<const TF1 & > wf(*this);; 1264 der = rd.Derivative3(wf, x, h);; 1265 }; 1266 ; 1267 gErrorTF1 = rd.Error();; 1268 return der;; 1269 ; 1270}; 1271 ; 1272 ; 1273////////////////////////////////////////////////////////////////////////////////; 1274/// Static function returning the error of the last call to the of Derivative's; 1275/// functions; 1276 ; 1277Double_t TF1::DerivativeError(); 1278{; 1279 return gErrorTF1;; 1280}; 1281 ; 1282 ; 1283////////////////////////////////////////////////////////////////////////////////; 1284/// Compute distance from point px,py to a function.; 1285///; 1286/// Compute the closest distance of approach from point px,py to this; 1287/// function. The distance is computed in pixels units.; 1288///; 1289/// Note that px is called with a negative value when the TF1 is in; 1290/// TGraph or TH1 list of functions. In this case there is no point; 1291/// looking at the histogram axi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:45590,avoid,avoid,45590,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['avoid'],['avoid']
Safety,"_ARG3(VirtualX,ChangeActivePointerGrab,Window_t,win,UInt_t,mask,Cursor_t,cur,1); 247VOID_METHOD_ARG5(VirtualX,ConvertSelection,Window_t,win,Atom_t&,sel,Atom_t&,target,Atom_t&,prop,Time_t&,stamp,1); 248RETURN_METHOD_ARG2(VirtualX,Bool_t,SetSelectionOwner,Window_t,win,Atom_t&,prop); 249VOID_METHOD_ARG6(VirtualX,ChangeProperties,Window_t,id,Atom_t,property,Atom_t,type,Int_t,format,UChar_t*,data,Int_t,len,1); 250VOID_METHOD_ARG2(VirtualX,SetDNDAware,Window_t,id,Atom_t*,typelist,1); 251VOID_METHOD_ARG3(VirtualX,SetTypeList,Window_t,win,Atom_t,prop,Atom_t*,typelist,1);; 252RETURN_METHOD_ARG6(VirtualX,Window_t,FindRWindow,Window_t,win,Window_t,dragwin,Window_t,input,int,x,int,y,int,maxd);; 253RETURN_METHOD_ARG2(VirtualX,Bool_t,IsDNDAware,Window_t,win,Atom_t*,typelist);; 254 ; 255//VOID_METHOD_ARG1(VirtualX,CreateOpenGLContext,Int_t,wid,1); 256//VOID_METHOD_ARG1(VirtualX,DeleteOpenGLContext,Int_t,wid,1); 257//VOID_METHOD_ARG1(VirtualX,RemoveWindow,ULongptr_t,qwid,1); 258//RETURN_METHOD_ARG1(VirtualX,ExecCommand,UInt_t,TGWin32Command*,code); 259//RETURN_METHOD_ARG3(VirtualX,Int_t,AddWindow,ULongptr_t,qwid,UInt_t,w,UInt_t,h); 260 ; 261//////////////////////// some non-standard methods /////////////////////////////; 262////////////////////////////////////////////////////////////////////////////////; 263///; 264 ; 265void TGWin32VirtualXProxy::CloseDisplay(); 266{; 267 if (gDebug) printf(""CloseDisplay\n"");; 268 fgRealObject->CloseDisplay();; 269}; 270 ; 271////////////////////////////////////////////////////////////////////////////////; 272/// might be thread unsafe (?); 273 ; 274Window_t TGWin32VirtualXProxy::GetParent(Window_t id) const; 275{; 276 return (Window_t)gdk_window_get_parent((GdkWindow *) id);; 277}; 278 ; 279////////////////////////////////////////////////////////////////////////////////; 280/// Convert the keycode from the event structure to a key symbol (according; 281/// to the modifiers specified in the event structure and the current; 282/// keyboard mapping).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html:19187,unsafe,unsafe,19187,doc/master/TGWin32VirtualXProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html,1,['unsafe'],['unsafe']
Safety,"_NUMBER io; 222 */; 223 ; 224/*; 225 * Funktionen; 226 *; 227 * int num_sput( n, s, l); 228 * rsa_NUMBER *n;; 229 * char s[l];; 230 * schreibt *n als Hex-Zahl in s; 231 *; 232 * int num_fput( n, f ); 233 * rsa_NUMBER *n;; 234 * FILE *f;; 235 * schreibt *n als Hex-Zahl in File f; 236 *; 237 * int num_sget( n, s ); 238 * rsa_NUMBER *n;; 239 * char *s;; 240 * liest Hex-Zahl s in *n ein; 241 *; 242 * int num_fget( n, f ); 243 * rsa_NUMBER *n;; 244 * FILE *f;; 245 * liest eine Hex-Zahl von f in *n ein; 246 *; 247 */; 248 ; 249 ; 250static const char *gHEX=""0123456789ABCDEF"";; 251static const char *ghex=""0123456789abcdef"";; 252 ; 253static rsa_NUMBER gbits[9];; 254static rsa_NUMBER gint16[16];; 255 ; 256static int ginit = 0;; 257 ; 258void num_init(); 259{; 260 int i;; 261 ; 262 if (ginit) return;; 263 ; 264 a_assign( &gbits[0], &a_one );; 265 for ( i=1; i<9; i++); 266 a_add( &gbits[i-1], &gbits[i-1], &gbits[i] );; 267 ; 268 a_assign( &gint16[0], &a_one );; 269 for ( i=1; i<16; i++); 270 a_add( &gint16[i-1], &a_one, &gint16[i] );; 271 ; 272 ginit = 1;; 273}; 274 ; 275 ; 276int rsa_num_sput(rsa_NUMBER *n, char *s, int l); 277{; 278#if rsa_MAXINT == ( (1 << rsa_MAXBIT) - 1 ); 279 rsa_INT *p;; 280 int bi,ab,i;; 281 long b;; 282 int first = 1;; 283 ; 284 bi = rsa_MAXBIT * n->n_len;; 285 ab = 4 - (bi + 3) % 4 -1;; 286 p = &n->n_part[n->n_len -1];; 287 ; 288 if ( (bi+3) / 4 >= l ); 289 return(EOF);; 290 ; 291 b = 0;; 292 while (bi) {; 293 b <<= (rsa_MAXBIT);; 294 b |= (unsigned long)*p--;; 295 bi -= rsa_MAXBIT;; 296 ab += rsa_MAXBIT;; 297 while (ab >= 4) {; 298 i = (b >> (ab - 4));; 299 b &= ( 1L << (ab - 4)) -1L;; 300 ab -= 4;; 301 ; 302 if (first && !i); 303 continue;; 304 first = 0;; 305 *s++ = gHEX[ i ];; 306 }; 307 }; 308 if (b); 309 abort();; 310 *s = '\0';; 311 ; 312 return (0);; 313#else; 314 rsa_NUMBER r,q;; 315 int i,b,p,len,low,high;; 316 char *np;; 317 ; 318 if (! ginit); 319 num_init();; 320 ; 321 a_assign( &q, n);; 322 len = l;; 323 np = s + l;; 324 ; 325 for (; q.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rsalib_8cxx_source.html:7485,abort,abort,7485,doc/master/rsalib_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rsalib_8cxx_source.html,1,['abort'],['abort']
Safety,"__SOLARIS); 30#include <strings.h>; 31#endif; 32#include <cstdlib>; 33#include <cstdio>; 34#include <sstream>; 35#include <fstream>; 36#include <iostream>; 37 ; 38#include ""Varargs.h""; 39#include ""snprintf.h""; 40#include ""TObject.h""; 41#include ""TBuffer.h""; 42#include ""TClass.h""; 43#include ""TGuiFactory.h""; 44#include ""TMethod.h""; 45#include ""TROOT.h""; 46#include ""TError.h""; 47#include ""TObjectTable.h""; 48#include ""TVirtualPad.h""; 49#include ""TInterpreter.h""; 50#include ""TMemberInspector.h""; 51#include ""TRefTable.h""; 52#include ""TProcessID.h""; 53 ; 54Longptr_t TObject::fgDtorOnly = 0;; 55Bool_t TObject::fgObjectStat = kTRUE;; 56 ; 57ClassImp(TObject);; 58 ; 59#if defined(__clang__) || defined (__GNUC__); 60# define ATTRIBUTE_NO_SANITIZE_ADDRESS __attribute__((no_sanitize_address)); 61#else; 62# define ATTRIBUTE_NO_SANITIZE_ADDRESS; 63#endif; 64 ; 65namespace ROOT {; 66namespace Internal {; 67 ; 68// Return true if delete changes/poisons/taints the memory.; 69//; 70// Detect whether operator delete taints the memory. If it does, we can not rely; 71// on TestBit(kNotDeleted) to check if the memory has been deleted (but in case,; 72// like TClonesArray, where we know the destructor will be called but not operator; 73// delete, we can still use it to detect the cases where the destructor was called.; 74 ; 75ATTRIBUTE_NO_SANITIZE_ADDRESS; 76bool DeleteChangesMemoryImpl(); 77{; 78 static constexpr UInt_t kGoldenUUID = 0x00000021;; 79 static constexpr UInt_t kGoldenbits = 0x03000000;; 80 ; 81 TObject *o = new TObject;; 82 o->SetUniqueID(kGoldenUUID);; 83 UInt_t *o_fuid = &(o->fUniqueID);; 84 UInt_t *o_fbits = &(o->fBits);; 85 ; 86 if (*o_fuid != kGoldenUUID) {; 87 Error(""CheckingDeleteSideEffects"",; 88 ""fUniqueID is not as expected, we got 0x%.8x instead of 0x%.8x"",; 89 *o_fuid, kGoldenUUID);; 90 }; 91 if (*o_fbits != kGoldenbits) {; 92 Error(""CheckingDeleteSideEffects"",; 93 ""fBits is not as expected, we got 0x%.8x instead of 0x%.8x"",; 94 *o_fbits, kGoldenbits);; 95 }; 96 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:2253,Detect,Detect,2253,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,1,['Detect'],['Detect']
Safety,"___________________________; 2198// coverity[PASS_BY_VALUE]; 2199RooPlot* RooAbsReal::plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue& asymCat, PlotOpt o) const; 2200 ; 2201{; 2202 // Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))); 2203 //; 2204 // Plot asymmetry of ourselves, defined as; 2205 //; 2206 // asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ); 2207 //; 2208 // on frame. If frame contains a histogram, all dimensions of the plotted; 2209 // asymmetry function that occur in the previously plotted dataset are projected via partial integration.; 2210 // Otherwise no projections are performed,; 2211 //; 2212 // The asymmetry function can be multiplied with an optional scale factor. The default projection; 2213 // behaviour can be overridden by supplying an optional set of dependents to project.; 2214 ; 2215 // Sanity checks; 2216 if (plotSanityChecks(frame)) return frame ;; 2217 ; 2218 // ProjDataVars is either all projData observables, or the user indicated subset of it; 2219 RooArgSet projDataVars ;; 2220 if (o.projData) {; 2221 if (o.projDataSet) {; 2222 std::unique_ptr<RooArgSet> tmp{o.projData->get()->selectCommon(*o.projDataSet)};; 2223 projDataVars.add(*tmp) ;; 2224 } else {; 2225 projDataVars.add(*o.projData->get()) ;; 2226 }; 2227 }; 2228 ; 2229 // Must depend on asymCat; 2230 if (!dependsOn(asymCat)) {; 2231 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2232 << "") function doesn't depend on asymmetry category "" << asymCat.GetName() << std::endl ;; 2233 return frame ;; 2234 }; 2235 ; 2236 // asymCat must be a signCat; 2237 if (!asymCat.isSignType()) {; 2238 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2239 << "") asymmetry category must have 2 or 3 states with index values -1,0,1"" << std::endl ;; 2240 return frame ;; 2241 }; 2242 ; 2243 // Make list of variables to be projected; 2244 RooArgSet projectedVars ;; 2245 RooArgSet sliceSet ;; 2246 if (o.pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:97567,Sanity check,Sanity checks,97567,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['Sanity check'],['Sanity checks']
Safety,"_b). inline . Definition at line 79 of file TSelector.h. â—†Â Terminate(). virtual void TSelector::Terminate ; (; voidÂ ; ). inlinevirtual . Reimplemented in TSelEvent, TSelVerifyDataSet, TSelEventGen, TSelHandleDataSet, TSelHist, TProofDraw, TProofDrawHist, TProofDrawEventList, TProofDrawEntryList, TProofDrawProfile, TProofDrawProfile2D, TProofDrawGraph, TProofDrawPolyMarker3D, TProofDrawListOfGraphs, TProofDrawListOfPolyMarkers3D, TSelectorDraw, TSelectorEntries, h1analysis, and h1analysisTreeReader.; Definition at line 71 of file TSelector.h. â—†Â Version(). virtual int TSelector::Version ; (; ); const. inlinevirtual . Reimplemented in TSelEvent, TEveSelectorToEventList, ROOT::Experimental::REveSelectorToEventList, TSelVerifyDataSet, TSelEventGen, TSelHandleDataSet, TSelHist, TProofDraw, RooProofDriverSelector, TSelectorEntries, h1analysis, and h1analysisTreeReader.; Definition at line 52 of file TSelector.h. Member Data Documentation. â—†Â fAbort. EAbort TSelector::fAbort. protected . Abort status. ; Definition at line 38 of file TSelector.h. â—†Â fInput. TList* TSelector::fInput. protected . List of objects available during processing. ; Definition at line 41 of file TSelector.h. â—†Â fObject. TObject* TSelector::fObject. protected . ! Current object if processing object (vs. TTree) ; Definition at line 40 of file TSelector.h. â—†Â fOption. TString TSelector::fOption. protected . Option given to TTree::Process. ; Definition at line 39 of file TSelector.h. â—†Â fOutput. TSelectorList* TSelector::fOutput. protected . ! List of objects created during processing ; Definition at line 42 of file TSelector.h. â—†Â fStatus. Long64_t TSelector::fStatus. protected . Selector status. ; Definition at line 37 of file TSelector.h. Libraries for TSelector:. [legend]; The documentation for this class was generated from the following files:; tree/tree/inc/TSelector.h; tree/tree/src/TSelector.cxx. TSelector. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:26 (GVA Time) using Doxygen 1.9.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelector.html:27285,Abort,Abort,27285,doc/master/classTSelector.html,https://root.cern,https://root.cern/doc/master/classTSelector.html,1,['Abort'],['Abort']
Safety,"_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;; 144 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 145 ; 146 ClassDefOverride(TGeoTrap, 1) // G3 TRAP shape; 147};; 148 ; 149class TGeoGtra : public TGeoTrap {; 150protected:; 151 // data members; 152 Double_t fTwistAngle; // twist angle in degrees; 153public:; 154 // constructors; 155 TGeoGtra();; 156 TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1,; 157 Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 158 TGeoGtra(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1,; 159 Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 160 // destructor; 161 ~TGeoGtra() override;; 162 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 163 Double_t *safe = nullptr) const override;; 164 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 165 Double_t *step) const override;; 166 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 167 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 168 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 169 Double_t *step) const override;; 170 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 171 Double_t GetTwistAngle() const { return fTwistAngle; }; 172 Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const override;; 173 void Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;; 174 void SetDimensions(Double_t *param) override;; 175 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 176 ; 177 ClassDefOverride(TGeoGtra, 1) // G3 GT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:8594,safe,safe,8594,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,1,['safe'],['safe']
Safety,"_t >::IsTraining ; (; ); const. inline . Definition at line 346 of file DeepNet.h. â—†Â Loss() [1/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Loss ; (; const Matrix_t &Â ; groundTruth, . const Matrix_t &Â ; weights, . boolÂ ; includeRegularization = trueÂ . ); const. Function for evaluating the loss, based on the activations stored in the last layer. ; Definition at line 1263 of file DeepNet.h. â—†Â Loss() [2/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Loss ; (; Tensor_t &Â ; input, . const Matrix_t &Â ; groundTruth, . const Matrix_t &Â ; weights, . boolÂ ; inTraining = false, . boolÂ ; includeRegularization = trueÂ . ). Function for evaluating the loss, based on the propagation of the given input. ; Definition at line 1279 of file DeepNet.h. â—†Â Prediction() [1/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t &Â ; predictions, . EOutputFunctionÂ ; fÂ . ); const. Prediction based on activations stored in the last layer. ; Definition at line 1303 of file DeepNet.h. â—†Â Prediction() [2/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t &Â ; predictions, . Tensor_t &Â ; input, . EOutputFunctionÂ ; fÂ . ). Prediction for the given inputs, based on what network learned. ; Definition at line 1311 of file DeepNet.h. â—†Â Print(). template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Print. Print the Deep Net Info. ; Definition at line 1321 of file DeepNet.h. â—†Â RegularizationTerm(). template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::RegularizationTerm. Function for computing the regularizaton term to be added to the loss function . Definition at line 1289 of file DeepNet.h. â—†Â ResetTrai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDeepNet.html:24549,Predict,Prediction,24549,doc/master/classTMVA_1_1DNN_1_1TDeepNet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDeepNet.html,2,"['Predict', 'predict']","['Prediction', 'predictions']"
Safety,"_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::Auto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:34608,recover,recovered,34608,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,6,['recover'],['recovered']
Safety,"_t TSQLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.; Definition at line 240 of file TSQLFile.h. â—†Â ReOpen(). Int_t TSQLFile::ReOpen ; (; Option_t *Â ; mode). finalvirtual . Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ; Reimplemented from TFile.; Definition at line 719 of file TSQLFile.cxx. â—†Â RequestSQLClassInfo() [1/2]. TSQLClassInfo * TSQLFile::RequestSQLClassInfo ; (; const char *Â ; clnam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:85377,recover,recovered,85377,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['recover'],['recovered']
Safety,"_t TXMLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.; Definition at line 86 of file TXMLFile.h. â—†Â ReOpen(). Int_t TXMLFile::ReOpen ; (; Option_t *Â ; mode). finalvirtual . Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ; Reimplemented from TFile.; Definition at line 372 of file TXMLFile.cxx. â—†Â ResetErrno(). void TXMLFile::ResetErrno ; (; ); const. inlinefinalvirtual . Method resetting the errn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:67428,recover,recovered,67428,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['recover'],['recovered']
Safety,"_t buf[3];; 697 strncpy(buf,&text[i],2);; 698 if (strncmp(buf,""^{"",2)==0) {; 699 if (opPower==-1 && nBrackets==0 && nCroch==0) opPower=i;; 700 if (i>3) {; 701 Char_t buf1[5];; 702 strncpy(buf1,&text[i-4],4);; 703 if (strncmp(buf1,""#int"",4)==0) {; 704 abovePlace = 1;; 705 if (i>4 && opCloseCurly==-2) opCloseCurly=i-5;; 706 }; 707 if (strncmp(buf1,""#sum"",4)==0) {; 708 abovePlace = 2;; 709 if (i>4 && opCloseCurly==-2) opCloseCurly=i-5;; 710 }; 711 }; 712 }; 713 if (strncmp(buf,""_{"",2)==0) {; 714 if (opUnder==-1 && nBrackets==0 && nCroch==0) opUnder=i;; 715 if (i>3) {; 716 Char_t buf2[5];; 717 strncpy(buf2,&text[i-4],4);; 718 if (strncmp(buf2,""#int"",4)==0) {; 719 abovePlace = 1;; 720 if (i>4 && opCloseCurly==-2) opCloseCurly=i-5;; 721 }; 722 if (strncmp(buf2,""#sum"",4)==0) {; 723 abovePlace = 2;; 724 if (i>4 && opCloseCurly==-2) opCloseCurly=i-5;; 725 }; 726 }; 727 }; 728 if (strncmp(buf,""]{"",2)==0); 729 if (opSquareCurly==-1 && nBrackets==0 && nCroch==0) opSquareCurly=i;; 730 }; 731 // detect other operators; 732 if (text[i]=='\\' || (text[i]=='#' && !opFound && nBrackets==0 && nCroch==0)) {; 733 ; 734 if (length>i+10) {; 735 Char_t buf[11];; 736 strncpy(buf,&text[i+1],10);; 737 if (strncmp(buf,""splitline{"",10)==0) {; 738 opSplitLine=i; opFound = kTRUE;; 739 if (i>0 && opCloseCurly==-2) opCloseCurly=i-1;; 740 continue;; 741 }; 742 }; 743 if (length>i+9) {; 744 Char_t buf[10];; 745 strncpy(buf,&text[i+1],9);; 746 if (!opBackslash && strncmp(buf,""backslash"",9)==0) {; 747 opBackslash=1; opFound = kTRUE;; 748 if (i>0 && opCloseCurly==-2) opCloseCurly=i-1;; 749 continue;; 750 }; 751 }; 752 if (length>i+8) {; 753 Char_t buf[9];; 754 strncpy(buf,&text[i+1],8);; 755 if (!opParallel && strncmp(buf,""parallel"",8)==0) {; 756 opParallel=1; opFound = kTRUE;; 757 if (i>0 && opCloseCurly==-2) opCloseCurly=i-1;; 758 continue;; 759 }; 760 }; 761 if (length>i+6) {; 762 Char_t buf[7];; 763 strncpy(buf,&text[i+1],6);; 764 if (strncmp(buf,""lower["",6)==0 || strncmp(buf,""lower{"",6)==0) {; 765 o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLatex_8cxx_source.html:27120,detect,detect,27120,doc/master/TLatex_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html,1,['detect'],['detect']
Safety,"_t entry) override; Â The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; Â ; voidÂ SetInputList (TList *input) override; Â ; voidÂ SetObject (TObject *obj) override; Â ; voidÂ SetOption (const char *option) override; Â ; voidÂ SlaveBegin (TTree *tree) override; Â The SlaveBegin() function is called after the Begin() function. ; Â ; voidÂ SlaveTerminate () override; Â The SlaveTerminate() function is called after all entries or objects have been processed. ; Â ; voidÂ Streamer (TBuffer &) override; Â Stream an object of class TObject. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; voidÂ Terminate () override; Â The Terminate() function is the last function to be called during a query. ; Â ; Int_tÂ Version () const override; Â ; Â Public Member Functions inherited from TSelector; Â TSelector (); Â Default selector ctor. ; Â ; Â ~TSelector () override; Â Selector destructor. ; Â ; virtual voidÂ Abort (const char *why, EAbort what=kAbortProcess); Â Abort processing. ; Â ; virtual EAbortÂ GetAbort () const; Â ; virtual Int_tÂ GetEntry (Long64_t, Int_t=0); Â ; virtual TList *Â GetInputList () const; Â ; const char *Â GetOption () const override; Â ; virtual Long64_tÂ GetStatus () const; Â ; virtual voidÂ ImportOutput (TList *output); Â Imports the content of 'output' in the internal output list. ; Â ; virtual boolÂ ProcessCut (Long64_t); Â This method is called before processing entry. ; Â ; virtual voidÂ ProcessFill (Long64_t); Â This method is called for all selected entries. ; Â ; virtual voidÂ ResetAbort (); Â ; virtual voidÂ SetStatus (Long64_t status); Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; Â Public Member Functions inherited from TObject; Â TObject (); Â TObject constructor. ; Â ; Â TObject (const TObject &object); Â TObject copy ctor. ; Â ; virtualÂ ~TObject (); Â TObject destructor. ; Â ; voidÂ AbstractMethod (const char *method) const; Â Use this method to implement an ""abstract"" method that you don't",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelEventGen.html:2197,Abort,Abort,2197,doc/master/classTSelEventGen.html,https://root.cern,https://root.cern/doc/master/classTSelEventGen.html,2,['Abort'],['Abort']
Safety,"_t entry) override; Â The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; Â ; voidÂ SetInputList (TList *input) override; Â ; voidÂ SetObject (TObject *obj) override; Â ; voidÂ SetOption (const char *option) override; Â ; voidÂ SlaveBegin (TTree *tree) override; Â The SlaveBegin() function is called after the Begin() function. ; Â ; voidÂ SlaveTerminate () override; Â The SlaveTerminate() function is called after all entries or objects have been processed. ; Â ; voidÂ Streamer (TBuffer &) override; Â Stream an object of class TObject. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; voidÂ Terminate () override; Â The Terminate() function is the last function to be called during a query. ; Â ; Int_tÂ Version () const override; Â ; Â Public Member Functions inherited from TSelector; Â TSelector (); Â Default selector ctor. ; Â ; Â ~TSelector () override; Â Selector destructor. ; Â ; virtual voidÂ Abort (const char *why, EAbort what=kAbortProcess); Â Abort processing. ; Â ; virtual EAbortÂ GetAbort () const; Â ; virtual Int_tÂ GetEntry (Long64_t, Int_t=0); Â ; virtual TList *Â GetInputList () const; Â ; const char *Â GetOption () const override; Â ; virtual Long64_tÂ GetStatus () const; Â ; virtual voidÂ ImportOutput (TList *output); Â Imports the content of 'output' in the internal output list. ; Â ; virtual voidÂ Init (TTree *); Â ; boolÂ Notify () override; Â This method must be overridden to handle object notification (the base implementation is no-op). ; Â ; virtual boolÂ ProcessCut (Long64_t); Â This method is called before processing entry. ; Â ; virtual voidÂ ProcessFill (Long64_t); Â This method is called for all selected entries. ; Â ; virtual voidÂ ResetAbort (); Â ; virtual voidÂ SetStatus (Long64_t status); Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; Â Public Member Functions inherited from TObject; Â TObject (); Â TObject constructor. ; Â ; Â TObject (const TObject &object); Â TObject copy ctor. ; Â ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelHist.html:1742,Abort,Abort,1742,doc/master/classTSelHist.html,https://root.cern,https://root.cern/doc/master/classTSelHist.html,2,['Abort'],['Abort']
Safety,"_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970. Return value wait of MyCondition.TimedWait should be 0, if MyCondition.Signal() was received, and should be nonzero, if timeout was reached. The conditions example shows how three threaded functions are synchronized using TCondition: a ROOT script condstart.C starts the threads, which are defined in a shared library (conditions.cxx, conditions.h).; 23.2.4.3 Xlib Connections; Usually Xlib is not thread safe. This means that calls to the X could fail, when it receives X-messages from different threads. The actual result depends strongly on which version of Xlib has been installed on your system. The only thing we can do here within ROOT is calling a special function XInitThreads()(which is part of the Xlib), which should (!) prepare the Xlib for the usage with threads.; To avoid further problems within ROOT some redefinition of the gPad pointer was done (thatâ€™s the main reason for the recompilation). When a thread creates a TCanvas, this object is actually created in the main thread; this should be transparent to the user. Actions on the canvas are controlled via a function, which returns a pointer to either thread specific data (TSD) or the main thread pointer. This mechanism works currently only for gPad, gDirectory, gFile and will be implemented soon for other global Objects as e.g.Â gVirtualX.; 23.2.4.4 Canceling a TThread; Canceling of a thread is a rather dangerous action. In TThread canceling is forbidden by default. The user can change this default by calling TThread::SetCancelOn(). There are two cancellation modes: deferred and asynchronous.; 23.2.4.5 Deferred; Set by TThread::SetCancelDeferred() (default): When the user knows safe places in their code where a thread can be canceled without risk for the rest of the system, they can define these points by invoking TThread::CancelPoint(). Then, if a thread is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1110820,avoid,avoid,1110820,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety,"_t procTime, Float_t evtrti, Float_t mbrti)SIGNAL ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tReinitSelector(TQueryResult* qr); virtual voidRemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidSetProcessing(Bool_t on = kTRUE); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopFeedback(); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofPlayer.html:10178,abort,abort,10178,root/html530/TProofPlayer.html,https://root.cern,https://root.cern/root/html530/TProofPlayer.html,8,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"_t stepmax, Bool_t compsafe); 2737{; 2738 return GetCurrentNavigator()->FindNextBoundaryAndStep(stepmax, compsafe);; 2739}; 2740 ; 2741////////////////////////////////////////////////////////////////////////////////; 2742/// Find distance to next boundary and store it in fStep. Returns node to which this; 2743/// boundary belongs. If PATH is specified, compute only distance to the node to which; 2744/// PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; 2745/// than this value. STEPMAX represent the step to be made imposed by other reasons than; 2746/// geometry (usually physics processes). Therefore in this case this method provides the; 2747/// answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; 2748/// fStep with a big number.; 2749/// In case frombdr=kTRUE, the isotropic safety is set to zero.; 2750///; 2751/// Note : safety distance for the current point is computed ONLY in case STEPMAX is; 2752/// specified, otherwise users have to call explicitly TGeoManager::Safety() if; 2753/// they want this computed for the current point.; 2754 ; 2755TGeoNode *TGeoManager::FindNextBoundary(Double_t stepmax, const char *path, Bool_t frombdr); 2756{; 2757 // convert current point and direction to local reference; 2758 return GetCurrentNavigator()->FindNextBoundary(stepmax, path, frombdr);; 2759}; 2760 ; 2761////////////////////////////////////////////////////////////////////////////////; 2762/// Computes as fStep the distance to next daughter of the current volume.; 2763/// The point and direction must be converted in the coordinate system of the current volume.; 2764/// The proposed step limit is fStep.; 2765 ; 2766TGeoNode *TGeoManager::FindNextDaughterBoundary(Double_t *point, Double_t *dir, Int_t &idaughter, Bool_t compmatrix); 2767{; 2768 return GetCurrentNavigator()->FindNextDaughterBoundary(point, dir, idaughter, compmatrix);; 2769}; 2770 ; 2771////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:98352,safe,safety,98352,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,2,"['Safe', 'safe']","['Safety', 'safety']"
Safety,"_t wbuf[UTF16_PATH_MAX];; 5344 (void)flags;; 5345 path_to_unicode(NULL, dll_name, wbuf, ARRAY_SIZE(wbuf));; 5346 return LoadLibraryW(wbuf);; 5347}; 5348 ; 5349 ; 5350FUNCTION_MAY_BE_UNUSED; 5351static int; 5352dlclose(void *handle); 5353{; 5354 int result;; 5355 ; 5356 if (FreeLibrary((HMODULE)handle) != 0) {; 5357 result = 0;; 5358 } else {; 5359 result = -1;; 5360 }; 5361 ; 5362 return result;; 5363}; 5364 ; 5365 ; 5366#if defined(GCC_DIAGNOSTIC); 5367/* Enable unused function warning again */; 5368#pragma GCC diagnostic pop; 5369#endif; 5370 ; 5371#endif; 5372 ; 5373 ; 5374#if !defined(NO_CGI); 5375#define SIGKILL (0); 5376 ; 5377 ; 5378static int; 5379kill(pid_t pid, int sig_num); 5380{; 5381 (void)TerminateProcess((HANDLE)pid, (UINT)sig_num);; 5382 (void)CloseHandle((HANDLE)pid);; 5383 return 0;; 5384}; 5385 ; 5386 ; 5387#if !defined(WNOHANG); 5388#define WNOHANG (1); 5389#endif; 5390 ; 5391 ; 5392static pid_t; 5393waitpid(pid_t pid, int *status, int flags); 5394{; 5395 DWORD timeout = INFINITE;; 5396 DWORD waitres;; 5397 ; 5398 (void)status; /* Currently not used by any client here */; 5399 ; 5400 if ((flags | WNOHANG) == WNOHANG) {; 5401 timeout = 0;; 5402 }; 5403 ; 5404 waitres = WaitForSingleObject((HANDLE)pid, timeout);; 5405 if (waitres == WAIT_OBJECT_0) {; 5406 return pid;; 5407 }; 5408 if (waitres == WAIT_TIMEOUT) {; 5409 return 0;; 5410 }; 5411 return (pid_t)-1;; 5412}; 5413 ; 5414 ; 5415static void; 5416trim_trailing_whitespaces(char *s); 5417{; 5418 char *e = s + strlen(s);; 5419 while ((e > s) && isspace((unsigned char)e[-1])) {; 5420 *(--e) = '\0';; 5421 }; 5422}; 5423 ; 5424 ; 5425static pid_t; 5426spawn_process(struct mg_connection *conn,; 5427 const char *prog,; 5428 char *envblk,; 5429 char *envp[],; 5430 int fdin[2],; 5431 int fdout[2],; 5432 int fderr[2],; 5433 const char *dir,; 5434 unsigned char cgi_config_idx); 5435{; 5436 HANDLE me;; 5437 char *interp;; 5438 char *interp_arg = 0;; 5439 char full_dir[UTF8_PATH_MAX], cmdline[UTF8_PATH_MAX],",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:159647,timeout,timeout,159647,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"_t wbuf[UTF16_PATH_MAX];; 5345 (void)flags;; 5346 path_to_unicode(NULL, dll_name, wbuf, ARRAY_SIZE(wbuf));; 5347 return LoadLibraryW(wbuf);; 5348}; 5349 ; 5350 ; 5351FUNCTION_MAY_BE_UNUSED; 5352static int; 5353dlclose(void *handle); 5354{; 5355 int result;; 5356 ; 5357 if (FreeLibrary((HMODULE)handle) != 0) {; 5358 result = 0;; 5359 } else {; 5360 result = -1;; 5361 }; 5362 ; 5363 return result;; 5364}; 5365 ; 5366 ; 5367#if defined(GCC_DIAGNOSTIC); 5368/* Enable unused function warning again */; 5369#pragma GCC diagnostic pop; 5370#endif; 5371 ; 5372#endif; 5373 ; 5374 ; 5375#if !defined(NO_CGI); 5376#define SIGKILL (0); 5377 ; 5378 ; 5379static int; 5380kill(pid_t pid, int sig_num); 5381{; 5382 (void)TerminateProcess((HANDLE)pid, (UINT)sig_num);; 5383 (void)CloseHandle((HANDLE)pid);; 5384 return 0;; 5385}; 5386 ; 5387 ; 5388#if !defined(WNOHANG); 5389#define WNOHANG (1); 5390#endif; 5391 ; 5392 ; 5393static pid_t; 5394waitpid(pid_t pid, int *status, int flags); 5395{; 5396 DWORD timeout = INFINITE;; 5397 DWORD waitres;; 5398 ; 5399 (void)status; /* Currently not used by any client here */; 5400 ; 5401 if ((flags | WNOHANG) == WNOHANG) {; 5402 timeout = 0;; 5403 }; 5404 ; 5405 waitres = WaitForSingleObject((HANDLE)pid, timeout);; 5406 if (waitres == WAIT_OBJECT_0) {; 5407 return pid;; 5408 }; 5409 if (waitres == WAIT_TIMEOUT) {; 5410 return 0;; 5411 }; 5412 return (pid_t)-1;; 5413}; 5414 ; 5415 ; 5416static void; 5417trim_trailing_whitespaces(char *s); 5418{; 5419 char *e = s + strlen(s);; 5420 while ((e > s) && isspace((unsigned char)e[-1])) {; 5421 *(--e) = '\0';; 5422 }; 5423}; 5424 ; 5425 ; 5426static pid_t; 5427spawn_process(struct mg_connection *conn,; 5428 const char *prog,; 5429 char *envblk,; 5430 char *envp[],; 5431 int fdin[2],; 5432 int fdout[2],; 5433 int fderr[2],; 5434 const char *dir,; 5435 unsigned char cgi_config_idx); 5436{; 5437 HANDLE me;; 5438 char *interp;; 5439 char *interp_arg = 0;; 5440 char full_dir[UTF8_PATH_MAX], cmdline[UTF8_PATH_MAX],",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:159679,timeout,timeout,159679,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3,; 138 Double_t x4, Double_t y4);; 139 static Bool_t IsInPhiRange(const Double_t *point, Double_t phi1, Double_t phi2);; 140 virtual Bool_t IsReflected() const { return kFALSE; }; 141 virtual Bool_t IsVecGeom() const { return kFALSE; }; 142 Bool_t IsRunTimeShape() const { return TestShapeBit(kGeoRunTimeShape); }; 143 Bool_t IsValid() const { return !TestShapeBit(kGeoInvalidShape); }; 144 virtual Bool_t IsValidBox() const = 0;; 145 virtual void InspectShape() const = 0;; 146 virtual TBuffer3D *MakeBuffer3D() const { return nullptr; }; 147 static void NormalPhi(const Double_t *point, const Double_t *dir, Double_t *norm, Double_t c1, Double_t s1,; 148 Double_t c2, Double_t s2);; 149 void Paint(Option_t *option = """") override;; 150 virtual Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const = 0;; 151 virtual void Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t) const {}; 152 static Double_t SafetyPhi(const Double_t *point, Bool_t in, Double_t phi1, Double_t phi2);; 153 static Double_t SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer);; 154 virtual void SetDimensions(Double_t *param) = 0;; 155 void SetId(Int_t id) { fShapeId = id; }; 156 virtual void SetPoints(Double_t *points) const = 0;; 157 virtual void SetPoints(Float_t *points) const = 0;; 158 virtual void SetSegsAndPols(TBuffer3D &buff) const = 0;; 159 void SetRuntime(Bool_t flag = kTRUE) { SetShapeBit(kGeoRunTimeShape, flag); }; 160 Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const;; 161 virtual void Sizeof3D() const = 0;; 162 ; 163 //----- bit manipulation; 164 void SetShapeBit(UInt_t f, Bool_t set);; 165 void SetShapeBit(UInt_t f) { fShapeBits |= f & kBitMask32; }; 166 void ResetShapeBit(UInt_t f) { fShapeBits &= ~(f & kBitMask32); }; 167 Bool_t TestShapeBit(UInt_t f) const { return (Bool_t)((fShapeBits & f) != 0); }; 168 Int_t TestShapeBits(UInt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoShape_8h_source.html:6993,Safe,SafetyPhi,6993,doc/master/TGeoShape_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html,1,['Safe'],['SafetyPhi']
Safety,"_t y4);; 139 static Bool_t IsInPhiRange(const Double_t *point, Double_t phi1, Double_t phi2);; 140 virtual Bool_t IsReflected() const { return kFALSE; }; 141 virtual Bool_t IsVecGeom() const { return kFALSE; }; 142 Bool_t IsRunTimeShape() const { return TestShapeBit(kGeoRunTimeShape); }; 143 Bool_t IsValid() const { return !TestShapeBit(kGeoInvalidShape); }; 144 virtual Bool_t IsValidBox() const = 0;; 145 virtual void InspectShape() const = 0;; 146 virtual TBuffer3D *MakeBuffer3D() const { return nullptr; }; 147 static void NormalPhi(const Double_t *point, const Double_t *dir, Double_t *norm, Double_t c1, Double_t s1,; 148 Double_t c2, Double_t s2);; 149 void Paint(Option_t *option = """") override;; 150 virtual Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const = 0;; 151 virtual void Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t) const {}; 152 static Double_t SafetyPhi(const Double_t *point, Bool_t in, Double_t phi1, Double_t phi2);; 153 static Double_t SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer);; 154 virtual void SetDimensions(Double_t *param) = 0;; 155 void SetId(Int_t id) { fShapeId = id; }; 156 virtual void SetPoints(Double_t *points) const = 0;; 157 virtual void SetPoints(Float_t *points) const = 0;; 158 virtual void SetSegsAndPols(TBuffer3D &buff) const = 0;; 159 void SetRuntime(Bool_t flag = kTRUE) { SetShapeBit(kGeoRunTimeShape, flag); }; 160 Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const;; 161 virtual void Sizeof3D() const = 0;; 162 ; 163 //----- bit manipulation; 164 void SetShapeBit(UInt_t f, Bool_t set);; 165 void SetShapeBit(UInt_t f) { fShapeBits |= f & kBitMask32; }; 166 void ResetShapeBit(UInt_t f) { fShapeBits &= ~(f & kBitMask32); }; 167 Bool_t TestShapeBit(UInt_t f) const { return (Bool_t)((fShapeBits & f) != 0); }; 168 Int_t TestShapeBits(UInt_t f) const { return (Int_t)(fShapeBits & f); }; 169 void InvertShapeBit(UInt_t f) { fShapeBits ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoShape_8h_source.html:7089,Safe,SafetySeg,7089,doc/master/TGeoShape_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html,1,['Safe'],['SafetySeg']
Safety,"_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); Double_tTGeoArb8::SafetyToFace(Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoArb8::SetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidTGeoArb8::SetPlaneVertices(Double_t zpl, Double_t* vertices) const; virtual voidTGeoArb8::SetPoints(Double_t* points) const; virtual voidTGeoArb8::SetPoints(Float_t* points) const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTrap.html:9416,Safe,SafetyToFace,9416,root/html528/TGeoTrap.html,https://root.cern,https://root.cern/root/html528/TGeoTrap.html,1,['Safe'],['SafetyToFace']
Safety,"_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; Double_tDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTorus.html:2201,safe,safe,2201,root/html530/TGeoTorus.html,https://root.cern,https://root.cern/root/html530/TGeoTorus.html,1,['safe'],['safe']
Safety,"_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Double_tDistToParaboloid(Double_t* point, Double_t* dir, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoParaboloid.html:2590,safe,safe,2590,root/html532/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html532/TGeoParaboloid.html,1,['safe'],['safe']
Safety,"_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoSphere.html:2376,safe,safe,2376,root/html532/TGeoSphere.html,https://root.cern,https://root.cern/root/html532/TGeoSphere.html,1,['safe'],['safe']
Safety,"_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoHalfSpace.html:2153,safe,safe,2153,root/html532/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html532/TGeoHalfSpace.html,3,['safe'],['safe']
Safety,"_t, bool isDynamic>; 78class TypedIter {; 79 ; 80public:; 81 TypedIter(WrappedIterator_t const &iter) : fIter{iter} {}; 82 ; 83 TypedIter &operator++(); 84 {; 85 ++fIter;; 86 return *this;; 87 }; 88 TypedIter operator++(int); 89 {; 90 TypedIter tmp(*this);; 91 operator++();; 92 return tmp;; 93 }; 94 bool operator==(const TypedIter &rhs) const { return fIter == rhs.fIter; }; 95 bool operator!=(const TypedIter &rhs) const { return fIter != rhs.fIter; }; 96 ; 97 void swap(TypedIter &other) { fIter.swap(other.fIter); }; 98 ; 99 // We want to know at compile time whether dynamic_cast or static_cast is; 100 // used. First of all to avoid overhead, but also to avoid a compiler; 101 // error when using dynamic_cast on a non-polymorphic class. In C++17,; 102 // this can be done easily with `if constexpr`, but for the older; 103 // standards we have to use a more verbose alternative. Both ways are; 104 // explicitely implemented for different standards, so that when the; 105 // minimum C++ standard for ROOT is raised to C++17 it's easy to remember; 106 // that we can avoid much boilerplate code in this file.; 107#if (__cplusplus < 201700L); 108 T operator*() { return ROOT::Internal::RCast<T, isDynamic>::cast(*fIter); }; 109#else; 110 T operator*(); 111 {; 112 if constexpr (isDynamic) {; 113 return dynamic_cast<T>(*fIter);; 114 } else {; 115 if constexpr (std::is_polymorphic<RBaseType<T>>::value) {; 116 assert(dynamic_cast<T>(*fIter));; 117 }; 118 return static_cast<T>(*fIter);; 119 }; 120 }; 121#endif; 122 ; 123private:; 124 WrappedIterator_t fIter;; 125};; 126 ; 127} // namespace Internal; 128 ; 129/// Wraps any collection that can be used in range-based loops and applies; 130/// `static_cast<T>` or `dynamic_cast<T>` to each element.; 131/// \tparam T The new type to convert to.; 132/// \tparam isDynamic If `true`, `dynamic_cast` is used, otherwise `static_cast` is used.; 133/// \tparam Range_t The type of the input range, which should be usually a reference type to avoid cop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RRangeCast_8hxx_source.html:3203,avoid,avoid,3203,doc/master/RRangeCast_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html,2,['avoid'],['avoid']
Safety,"_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; static Bool_tContains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoBBox.html:3593,safe,safe,3593,root/html530/TGeoBBox.html,https://root.cern,https://root.cern/root/html530/TGeoBBox.html,1,['safe'],['safe']
Safety,"_tDepth() const; Bool_tDone() const; Int_tExtraFolderLevel(); Bool_tGoInside(TRootSnifferScanRec& super, TObject* obj, const char* obj_name = 0); virtual TClass*IsA() const; Bool_tIsReadyForResult() const; voidMakeItemName(const char* objname, TString& itemname); TRootSnifferScanRec&operator=(const TRootSnifferScanRec&); voidSetField(const char* name, const char* value, Bool_t with_quotes = kTRUE); Bool_tSetResult(void* obj, TClass* cl, TDataMember* member = 0, Int_t chlds = -1); voidSetRootClass(TClass* cl); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TRootSnifferScanRec(); TRootSnifferScanRec(const TRootSnifferScanRec&). Data Members; public:. TListfItemsNames! list of created items names, need to avoid duplication; Bool_thas_more! indicates that potentially there are more items can be found; Int_tlvl! current level of hierarchy; UInt_tmask! defines operation kind; Int_tnum_childs! number of childs; Int_tnum_fields! number of fields; TRootSnifferScanRec*parent! pointer on parent record; const char*searchpath! current path searched; TStringstarted_node! name of node stared; TRootSnifferStore*store! object to store results. Class Charts. Inheritance Chart:. TRootSnifferScanRec. Function documentation; TRootSnifferScanRec(); constructor. ~TRootSnifferScanRec(); destructor. void SetField(const char* name, const char* value, Bool_t with_quotes = kTRUE); record field for current element. void BeforeNextChild(); indicates that new child for current element will be started. void MakeItemName(const char* objname, TString& itemname); constructs item name from object name; if special symbols like '/', '#', ':', '&', '?' are used in object name; they will be replaced with '_'.; To avoid item name duplication, additional id number can be appended. void CreateNode(const char* _node_name); creates new node with specified name; if special symbols like ""[]&<>"" are used, node name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRootSnifferScanRec.html:1467,avoid,avoid,1467,root/html602/TRootSnifferScanRec.html,https://root.cern,https://root.cern/root/html602/TRootSnifferScanRec.html,1,['avoid'],['avoid']
Safety,"_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerRemote.html:11427,abort,abort,11427,root/html534/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html534/TProofPlayerRemote.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"_tTSelector::fStatusSelector status; TTree*fTree; TTreeDrawArgsParserfTreeDrawArgsParser; TTreeFormula*fVar[4]Pointer to variable formula; Double_tfWeightGlobal weight for fill actions; static TProofDraw::(anonymous)kWarn. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofDraw(); Constructor. ~TProofDraw(); Destructor. void Init(TTree* ); Init the tree. Bool_t Notify(); Called when a new tree is loaded. void Begin(TTree* ); Executed by the client before processing. void SlaveBegin(TTree* ); Executed by each slave before processing. void FillWeight(); Get weight from input list, if any. Bool_t ProcessSingle(Long64_t , Int_t ); Processes a single variable from an entry. Bool_t Process(Long64_t ); Executed for each entry. void SlaveTerminate(void); Executed by each slave after the processing has finished,; before returning the results to the client. void Terminate(void); Executed by the client after getting the processing retults. void ClearFormula(); Delete internal buffers. void SetCanvas(const char* objname); Move to a canvas named <name>_canvas; create the canvas if not existing.; Used to avoid screwing up existing plots when non default names are used; for the final objects. void SetDrawAtt(TObject* o); Set the drawing attributes from the input list. void SetError(const char* sub, const char* mesg); Sets the error status. Bool_t CompileVariables(); Compiles each variable from fTreeDrawArgsParser for the tree fTree.; Return kFALSE if any of the variable is not compilable. void DoFill(Long64_t entry, Double_t w, const Double_t* v). void DefVar(). TProofDraw(). int Version() const; { return 1; }. Â» Author: Maarten Ballintijn 24/09/2003 Â» Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; Â» Last changed: root/proofplayer:$Id$ Â» Last generated: 2015-06-03 17:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofDraw.html:9002,avoid,avoid,9002,root/html604/TProofDraw.html,https://root.cern,https://root.cern/root/html604/TProofDraw.html,1,['avoid'],['avoid']
Safety,"_tTSelector::fStatusSelector status; TTree*fTree; TTreeDrawArgsParserfTreeDrawArgsParser; TTreeFormula*fVar[4]Pointer to variable formula; Double_tfWeightGlobal weight for fill actions; static TProofDraw::(anonymous)kWarn. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofDraw(); Constructor. ~TProofDraw(); Destructor. void Init(TTree* ); Init the tree. Bool_t Notify(); Called when a new tree is loaded. void Begin(TTree* ); Executed by the client before processing. void SlaveBegin(TTree* ); Executed by each slave before processing. void FillWeight(); Get weight from input list, if any. Bool_t ProcessSingle(Long64_t , Int_t ); Processes a single variable from an entry. Bool_t Process(Long64_t ); Executed for each entry. void SlaveTerminate(void); Executed by each slave after the processing has finished,; before returning the results to the client. void Terminate(void); Executed by the client after getting the processing retults. void ClearFormula(); Delete internal buffers. void SetCanvas(const char* objname); Move to a canvas named <name>_canvas; create the canvas if not existing.; Used to avoid screwing up existing plots when non default names are used; for the final objects. void SetDrawAtt(TObject* o); Set the drawing attributes from the input list. void SetError(const char* sub, const char* mesg); Sets the error status. Bool_t CompileVariables(); Compiles each variable from fTreeDrawArgsParser for the tree fTree.; Return kFALSE if any of the variable is not compilable. void DoFill(Long64_t entry, Double_t w, const Double_t* v). void DefVar(). TProofDraw(). int Version() const; { return 1; }. Â» Author: Maarten Ballintijn 24/09/2003 Â» Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; Â» Last changed: root/proofplayer:$Id$ Â» Last generated: 2015-06-30 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofDraw.html:9002,avoid,avoid,9002,root/html602/TProofDraw.html,https://root.cern,https://root.cern/root/html602/TProofDraw.html,1,['avoid'],['avoid']
Safety,"_timeout + 999) / 1000;; 17012 ; 17013#if defined(GCC_DIAGNOSTIC); 17014#pragma GCC diagnostic pop; 17015#endif; 17016#if defined(_MSC_VER); 17017#pragma warning(pop); 17018#endif; 17019 ; 17020 } else {; 17021 linger.l_onoff = 0;; 17022 linger.l_linger = 0;; 17023 }; 17024 ; 17025 if (linger_timeout < -1) {; 17026 /* Default: don't configure any linger */; 17027 } else if (getsockopt(conn->client.sock,; 17028 SOL_SOCKET,; 17029 SO_ERROR,; 17030#if defined(_WIN32) /* WinSock uses different data type here */; 17031 (char *)&error_code,; 17032#else; 17033 &error_code,; 17034#endif; 17035 &opt_len); 17036 != 0) {; 17037 /* Cannot determine if socket is already closed. This should; 17038 * not occur and never did in a test. Log an error message; 17039 * and continue. */; 17040 mg_cry_internal(conn,; 17041 ""%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s"",; 17042 __func__,; 17043 strerror(ERRNO));; 17044#if defined(_WIN32); 17045 } else if (error_code == WSAECONNRESET) {; 17046#else; 17047 } else if (error_code == ECONNRESET) {; 17048#endif; 17049 /* Socket already closed by client/peer, close socket without linger; 17050 */; 17051 } else {; 17052 ; 17053 /* Set linger timeout */; 17054 if (setsockopt(conn->client.sock,; 17055 SOL_SOCKET,; 17056 SO_LINGER,; 17057 (char *)&linger,; 17058 sizeof(linger)); 17059 != 0) {; 17060 mg_cry_internal(; 17061 conn,; 17062 ""%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s"",; 17063 __func__,; 17064 linger.l_onoff,; 17065 linger.l_linger,; 17066 strerror(ERRNO));; 17067 }; 17068 }; 17069 ; 17070 /* Now we know that our FIN is ACK-ed, safe to close */; 17071 closesocket(conn->client.sock);; 17072 conn->client.sock = INVALID_SOCKET;; 17073}; 17074#endif; 17075 ; 17076 ; 17077static void; 17078close_connection(struct mg_connection *conn); 17079{; 17080#if defined(USE_SERVER_STATS); 17081 conn->conn_state = 6; /* to close */; 17082#endif; 17083 ; 17084#if defined(USE_LUA) && defined(USE_WEBSOCKET); 17085 if (conn->lua_websocket_state) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:506441,timeout,timeout,506441,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"_timeout + 999) / 1000;; 17013 ; 17014#if defined(GCC_DIAGNOSTIC); 17015#pragma GCC diagnostic pop; 17016#endif; 17017#if defined(_MSC_VER); 17018#pragma warning(pop); 17019#endif; 17020 ; 17021 } else {; 17022 linger.l_onoff = 0;; 17023 linger.l_linger = 0;; 17024 }; 17025 ; 17026 if (linger_timeout < -1) {; 17027 /* Default: don't configure any linger */; 17028 } else if (getsockopt(conn->client.sock,; 17029 SOL_SOCKET,; 17030 SO_ERROR,; 17031#if defined(_WIN32) /* WinSock uses different data type here */; 17032 (char *)&error_code,; 17033#else; 17034 &error_code,; 17035#endif; 17036 &opt_len); 17037 != 0) {; 17038 /* Cannot determine if socket is already closed. This should; 17039 * not occur and never did in a test. Log an error message; 17040 * and continue. */; 17041 mg_cry_internal(conn,; 17042 ""%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s"",; 17043 __func__,; 17044 strerror(ERRNO));; 17045#if defined(_WIN32); 17046 } else if (error_code == WSAECONNRESET) {; 17047#else; 17048 } else if (error_code == ECONNRESET) {; 17049#endif; 17050 /* Socket already closed by client/peer, close socket without linger; 17051 */; 17052 } else {; 17053 ; 17054 /* Set linger timeout */; 17055 if (setsockopt(conn->client.sock,; 17056 SOL_SOCKET,; 17057 SO_LINGER,; 17058 (char *)&linger,; 17059 sizeof(linger)); 17060 != 0) {; 17061 mg_cry_internal(; 17062 conn,; 17063 ""%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s"",; 17064 __func__,; 17065 linger.l_onoff,; 17066 linger.l_linger,; 17067 strerror(ERRNO));; 17068 }; 17069 }; 17070 ; 17071 /* Now we know that our FIN is ACK-ed, safe to close */; 17072 closesocket(conn->client.sock);; 17073 conn->client.sock = INVALID_SOCKET;; 17074}; 17075#endif; 17076 ; 17077 ; 17078static void; 17079close_connection(struct mg_connection *conn); 17080{; 17081#if defined(USE_SERVER_STATS); 17082 conn->conn_state = 6; /* to close */; 17083#endif; 17084 ; 17085#if defined(USE_LUA) && defined(USE_WEBSOCKET); 17086 if (conn->lua_websocket_state) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:506474,timeout,timeout,506474,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"_tÂ ; rdotn, . Double_tÂ ; radius, . Double_t &Â ; b, . Double_t &Â ; deltaÂ . ). static . â—†Â Divide(). TGeoVolume * TGeoTube::Divide ; (; TGeoVolume *Â ; voldiv, . const char *Â ; divname, . Int_tÂ ; iaxis, . Int_tÂ ; ndiv, . Double_tÂ ; start, . Double_tÂ ; stepÂ . ). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. â—†Â GetAxisName(). const char * TGeoTube::GetAxisName ; (; Int_tÂ ; iaxis); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â GetAxisRange(). Double_t TGeoTube::GetAxisRange ; (; Int_tÂ ; iaxis, . Double_t &Â ; xlo, . Double_t &Â ; xhiÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. â—†Â GetBoundingCylinder(). void TGeoTube::GetBoundingCylinder ; (; Double_t *Â ; param); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. â—†Â GetBuffer3D(). const TBuffer3D & TGeoTube::GetBuffer3D ; (; Int_tÂ ; reqSections, . Bool_tÂ ; localFrameÂ . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. â—†Â GetByteCount(). Int_t TGeoTube::GetByteCount ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg.; Definition at line 67 of file TGeoTube.h. â—†Â GetDz(). virtual Double_t TGeoTube::GetDz ; (; ); const. inlinevirtual . Definition at line 74 of file TGeoTube.h. â—†Â GetMakeRuntimeShape(). TGeoShape * TGeoTube::GetMakeRuntimeShape ; (; TGeoShape *Â ; mother, . TGeoMatrix *Â ; matÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. â—†Â GetMeshNumbers(). void TGeoTube::GetMeshNumbers ; (; Int_t &Â ; nvert, . Int_t &Â ; nsegs, . Int_t &Â ; npolsÂ . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. â—†Â GetNmeshVertices(). Int_t TGeoTube::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. â—†Â GetPointsOnSegments(). Bool_t TGeoTube::GetP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTube.html:28206,avoid,avoid,28206,doc/master/classTGeoTube.html,https://root.cern,https://root.cern/doc/master/classTGeoTube.html,1,['avoid'],['avoid']
Safety,"_tÂ ; yupÂ . ). protected . Constructor for variable bin size (along X axis) 2-D histograms using an input array of type double. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsxnumber of bins ; [in]xbinsarray of low-edges for each bin. This is an array of type double and size nbinsx+1 ; [in]nbinsynumber of bins along the Y axis ; [in]ylowlow edge of the Y axis first bin ; [in]yupupper edge of the Y axis last bin (not included in last bin) . Definition at line 126 of file TH2.cxx. â—†Â TH2() [4/7]. TH2::TH2 ; (; const char *Â ; name, . const char *Â ; title, . Int_tÂ ; nbinsx, . Double_tÂ ; xlow, . Double_tÂ ; xup, . Int_tÂ ; nbinsy, . const Double_t *Â ; ybinsÂ . ). protected . Constructor for Double_t variable bin size (along Y axis) 2-D histograms. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsxnumber of bins along the X axis ; [in]xlowlow edge of the X axis first bin ; [in]xupupper edge of the X axis last bin (not included in last bin) ; [in]nbinsynumber of bins ; [in]ybinsarray of low-edges for each bin. This is an array of type double and size nbinsy+1 . Definition at line 154 of file TH2.cxx. â—†Â TH2() [5/7]. TH2::TH2 ; (; const char *Â ; name, . const char *Â ; title, . Int_tÂ ; nbinsx, . const Double_t *Â ; xbins, . Int_tÂ ; nbinsy, . const Double_t *Â ; ybinsÂ . ). protected . Constructor for Double_t variable bin size 2-D histograms. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:59169,avoid,avoid,59169,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,1,['avoid'],['avoid']
Safety,"_tÂ CompileVariables (); Â Compiles each variable from fTreeDrawArgsParser for the tree fTree. ; Â ; voidÂ FillWeight (); Â Get weight from input list, if any. ; Â ; virtual Bool_tÂ ProcessSingle (Long64_t, Int_t); Â Processes a single variable from an entry. ; Â ; voidÂ SetCanvas (const char *objname); Â Move to a canvas named <name>_canvas; create the canvas if not existing. ; Â ; voidÂ SetDrawAtt (TObject *o); Â Set the drawing attributes from the input list. ; Â ; voidÂ SetError (const char *sub, const char *mesg); Â Sets the error status. ; Â ; Â Protected Member Functions inherited from TObject; virtual voidÂ DoError (int level, const char *location, const char *fmt, va_list va) const; Â Interface to ErrorHandler (protected). ; Â ; voidÂ MakeZombie (); Â . Protected Attributes; TEventList *Â fElist; Â ; TList *Â fEventLists; Â ; Â Protected Attributes inherited from TProofDraw; Int_tÂ fDimension; Â ; TStringÂ fInitialExp; Â ; TTreeFormulaManager *Â fManager; Â ; Int_tÂ fMultiplicity; Â ; Bool_tÂ fObjEval; Â ; TTreeFormula *Â fSelect; Â ; TStringÂ fSelection; Â ; TStatus *Â fStatus; Â ; TTree *Â fTree; Â ; TTreeDrawArgsParserÂ fTreeDrawArgsParser; Â ; TTreeFormula *Â fVar [4]; Â ; Double_tÂ fWeight; Â ; Â Protected Attributes inherited from TSelector; EAbortÂ fAbort; Â Abort status. ; Â ; TList *Â fInput; Â List of objects available during processing. ; Â ; TObject *Â fObject; Â ! Current object if processing object (vs. TTree) ; Â ; TStringÂ fOption; Â Option given to TTree::Process. ; Â ; TSelectorList *Â fOutput; Â ! List of objects created during processing ; Â ; Long64_tÂ fStatus; Â Selector status. ; Â . Additional Inherited Members; Â Public Types inherited from TSelector; enum Â EAbort { kContinue; , kAbortProcess; , kAbortFile; }; Â ; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; Â Â kBitMask = 0x00ffffff. }; Â ; enum Â { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawEventList.html:13076,Abort,Abort,13076,doc/master/classTProofDrawEventList.html,https://root.cern,https://root.cern/doc/master/classTProofDrawEventList.html,1,['Abort'],['Abort']
Safety,"_tÂ CompileVariables (); Â Compiles each variable from fTreeDrawArgsParser for the tree fTree. ; Â ; voidÂ FillWeight (); Â Get weight from input list, if any. ; Â ; virtual Bool_tÂ ProcessSingle (Long64_t, Int_t); Â Processes a single variable from an entry. ; Â ; voidÂ SetCanvas (const char *objname); Â Move to a canvas named <name>_canvas; create the canvas if not existing. ; Â ; voidÂ SetDrawAtt (TObject *o); Â Set the drawing attributes from the input list. ; Â ; voidÂ SetError (const char *sub, const char *mesg); Â Sets the error status. ; Â ; Â Protected Member Functions inherited from TObject; virtual voidÂ DoError (int level, const char *location, const char *fmt, va_list va) const; Â Interface to ErrorHandler (protected). ; Â ; voidÂ MakeZombie (); Â . Protected Attributes; TProofVectorContainer< Point3D_t > *Â fPoints; Â ; Â Protected Attributes inherited from TProofDraw; Int_tÂ fDimension; Â ; TStringÂ fInitialExp; Â ; TTreeFormulaManager *Â fManager; Â ; Int_tÂ fMultiplicity; Â ; Bool_tÂ fObjEval; Â ; TTreeFormula *Â fSelect; Â ; TStringÂ fSelection; Â ; TStatus *Â fStatus; Â ; TTree *Â fTree; Â ; TTreeDrawArgsParserÂ fTreeDrawArgsParser; Â ; TTreeFormula *Â fVar [4]; Â ; Double_tÂ fWeight; Â ; Â Protected Attributes inherited from TSelector; EAbortÂ fAbort; Â Abort status. ; Â ; TList *Â fInput; Â List of objects available during processing. ; Â ; TObject *Â fObject; Â ! Current object if processing object (vs. TTree) ; Â ; TStringÂ fOption; Â Option given to TTree::Process. ; Â ; TSelectorList *Â fOutput; Â ! List of objects created during processing ; Â ; Long64_tÂ fStatus; Â Selector status. ; Â . Additional Inherited Members; Â Public Types inherited from TSelector; enum Â EAbort { kContinue; , kAbortProcess; , kAbortFile; }; Â ; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; Â Â kBitMask = 0x00ffffff. }; Â ; enum Â { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawListOfGraphs.html:13156,Abort,Abort,13156,doc/master/classTProofDrawListOfGraphs.html,https://root.cern,https://root.cern/doc/master/classTProofDrawListOfGraphs.html,1,['Abort'],['Abort']
Safety,"_tÂ CompileVariables (); Â Compiles each variable from fTreeDrawArgsParser for the tree fTree. ; Â ; voidÂ FillWeight (); Â Get weight from input list, if any. ; Â ; virtual Bool_tÂ ProcessSingle (Long64_t, Int_t); Â Processes a single variable from an entry. ; Â ; voidÂ SetCanvas (const char *objname); Â Move to a canvas named <name>_canvas; create the canvas if not existing. ; Â ; voidÂ SetDrawAtt (TObject *o); Â Set the drawing attributes from the input list. ; Â ; voidÂ SetError (const char *sub, const char *mesg); Â Sets the error status. ; Â ; Â Protected Member Functions inherited from TObject; virtual voidÂ DoError (int level, const char *location, const char *fmt, va_list va) const; Â Interface to ErrorHandler (protected). ; Â ; voidÂ MakeZombie (); Â . Protected Attributes; TProofVectorContainer< Point4D_t > *Â fPoints; Â ; Â Protected Attributes inherited from TProofDraw; Int_tÂ fDimension; Â ; TStringÂ fInitialExp; Â ; TTreeFormulaManager *Â fManager; Â ; Int_tÂ fMultiplicity; Â ; Bool_tÂ fObjEval; Â ; TTreeFormula *Â fSelect; Â ; TStringÂ fSelection; Â ; TStatus *Â fStatus; Â ; TTree *Â fTree; Â ; TTreeDrawArgsParserÂ fTreeDrawArgsParser; Â ; TTreeFormula *Â fVar [4]; Â ; Double_tÂ fWeight; Â ; Â Protected Attributes inherited from TSelector; EAbortÂ fAbort; Â Abort status. ; Â ; TList *Â fInput; Â List of objects available during processing. ; Â ; TObject *Â fObject; Â ! Current object if processing object (vs. TTree) ; Â ; TStringÂ fOption; Â Option given to TTree::Process. ; Â ; TSelectorList *Â fOutput; Â ! List of objects created during processing ; Â ; Long64_tÂ fStatus; Â Selector status. ; Â . Additional Inherited Members; Â Public Types inherited from TSelector; enum Â EAbort { kContinue; , kAbortProcess; , kAbortFile; }; Â ; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; Â Â kBitMask = 0x00ffffff. }; Â ; enum Â { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawListOfPolyMarkers3D.html:13177,Abort,Abort,13177,doc/master/classTProofDrawListOfPolyMarkers3D.html,https://root.cern,https://root.cern/doc/master/classTProofDrawListOfPolyMarkers3D.html,1,['Abort'],['Abort']
Safety,"_tÂ Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr); Â Disconnects signal in object sender from slot_method in object receiver. ; Â . Protected Member Functions; TStringÂ GetJobAd (); Â Get job Ad. ; Â ; Bool_tÂ StartSlaves (Bool_t) override; Â Setup Condor workers using dynamic information. ; Â ; Â Protected Member Functions inherited from TProof; Â TProof (); Â Protected constructor to be used by classes deriving from TProof (they have to call Init themselves and override StartSlaves appropriately). ; Â ; Int_tÂ AddWorkers (TList *wrks); Â Works on the master node only. ; Â ; Int_tÂ AssertPath (const char *path, Bool_t writable); Â Make sure that 'path' exists; if 'writable' is kTRUE, make also sure that the path is writable. ; Â ; Int_tÂ Collect (ESlaves list=kActive, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE); Â Collect responses from the slave servers. ; Â ; Int_tÂ Collect (TList *slaves, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE); Â Collect responses from the slave servers. ; Â ; TSlave *Â CreateSlave (const char *url, const char *ord, Int_t perf, const char *image, const char *workdir); Â Create a new TSlave of type TSlave::kSlave. ; Â ; TSlave *Â CreateSubmaster (const char *url, const char *ord, const char *image, const char *msd, Int_t nwk=1); Â Create a new TSlave of type TSlave::kMaster. ; Â ; TList *Â GetEnabledPackages () const; Â ; TList *Â GetListOfActiveSlaves () const; Â ; TVirtualProofPlayer *Â GetPlayer () const; Â ; TPluginHandler *Â GetProgressDialog () const; Â ; Int_tÂ GetSandbox (TString &sb, Bool_t assert=kFALSE, const char *rc=0); Â Set the sandbox path from ' Proof.Sandbox' or the alternative var 'rc'. ; Â ; voidÂ HandleLibIncPath (const char *what, Bool_t add, const char *dirs); Â Handle lib, inc search paths modification request. ; Â ; Int_tÂ HandleOutputOptions (TString &opt, TString &target, Int_t action); Â Extract from opt information about output handling settings. ; Â ; Int_tÂ In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofCondor.html:35731,timeout,timeout,35731,doc/master/classTProofCondor.html,https://root.cern,https://root.cern/doc/master/classTProofCondor.html,1,['timeout'],['timeout']
Safety,"_tÂ IsArchive () const; Â ; Bool_tÂ IsBinary () const; Â ; Bool_tÂ IsRaw () const; Â ; voidÂ ls (Option_t *option="""") const override; Â List file contents. ; Â ; virtual voidÂ MakeFree (Long64_t first, Long64_t last); Â Mark unused bytes on the file. ; Â ; virtual voidÂ MakeProject (const char *dirname, const char *classes=""*"", Option_t *option=""new""); Â Generate source code necessary to access the objects stored in the file. ; Â ; virtual voidÂ Map (); Â ; virtual voidÂ Map (Option_t *opt); Â List the contents of a file sequentially. ; Â ; virtual Bool_tÂ MustFlush () const; Â ; voidÂ Paint (Option_t *option="""") override; Â Paint all objects in the file. ; Â ; virtual Bool_tÂ ReadBufferAsync (Long64_t offs, Int_t len); Â ; virtual voidÂ ReadFree (); Â Read the FREE linked list. ; Â ; virtual TProcessID *Â ReadProcessID (UShort_t pidf); Â The TProcessID with number pidf is read from this file. ; Â ; virtual voidÂ ReadStreamerInfo (); Â Read the list of StreamerInfo from this file. ; Â ; virtual Int_tÂ Recover (); Â Attempt to recover file if not correctly closed. ; Â ; virtual voidÂ ResetErrno () const; Â Method resetting the errno. ; Â ; virtual voidÂ SetCacheRead (TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect); Â Set a pointer to the read cache. ; Â ; virtual voidÂ SetCacheWrite (TFileCacheWrite *cache); Â Set a pointer to the write cache. ; Â ; virtual voidÂ SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal); Â See comments for function SetCompressionSettings. ; Â ; virtual voidÂ SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin); Â See comments for function SetCompressionSettings. ; Â ; virtual voidÂ SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault); Â Used to specify the compression level and algorithm. ; Â ; virtual voidÂ SetEND (Long64_t last); Â ; virtual voidÂ SetOffset (Long64_t offset, ERelativeTo pos=kBeg); Â Set position from where to start reading. ; Â ; virtual voidÂ Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:7796,Recover,Recover,7796,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,2,"['Recover', 'recover']","['Recover', 'recover']"
Safety,"_tÂ IsRunning (); Â This function checks if the timer is running within gSystem (Has been started and did not finish yet). ; Â ; Bool_tÂ IsSync () const; Â ; Bool_tÂ Notify () override; Â Notify when timer times out. ; Â ; voidÂ Remove () override; Â ; voidÂ Reset (); Â Reset the timer. ; Â ; voidÂ SetCommand (const char *command); Â Set the interpreter command to be executed at time out. ; Â ; voidÂ SetInterruptSyscalls (Bool_t set=kTRUE); Â When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ; Â ; voidÂ SetObject (TObject *object); Â Set the object to be notified at time out. ; Â ; voidÂ SetTime (Long_t milliSec); Â ; voidÂ SetTimerID (UInt_t id=0); Â ; virtual voidÂ Start (Long_t milliSec=-1, Bool_t singleShot=kFALSE); Â Starts the timer with a milliSec timeout. ; Â ; voidÂ Streamer (TBuffer &) override; Â Stream an object of class TObject. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; virtual voidÂ Timeout (); Â ; virtual voidÂ TurnOff (); Â Remove timer from system timer list. ; Â ; virtual voidÂ TurnOn (); Â Add the timer to the system timer list. ; Â ; Â Public Member Functions inherited from TSysEvtHandler; Â TSysEvtHandler (); Â ; virtualÂ ~TSysEvtHandler (); Â ; voidÂ Activate (); Â Activate a system event handler. ; Â ; virtual voidÂ Activated (); Â ; virtual voidÂ Added (); Â ; voidÂ DeActivate (); Â De-activate a system event handler. ; Â ; virtual voidÂ DeActivated (); Â ; Bool_tÂ IsActive () const; Â ; virtual voidÂ Notified (); Â ; virtual voidÂ Removed (); Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; Â Public Member Functions inherited from TObject; Â TObject (); Â TObject constructor. ; Â ; Â TObject (const TObject &object); Â TObject copy ctor. ; Â ; virtualÂ ~TObject (); Â TObject destructor. ; Â ; voidÂ AbstractMethod (const char *method) const; Â Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ; Â ; virtual voidÂ AppendPad (Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLRedrawTimer.html:2429,Timeout,Timeout,2429,doc/master/classTGLRedrawTimer.html,https://root.cern,https://root.cern/doc/master/classTGLRedrawTimer.html,1,['Timeout'],['Timeout']
Safety,"a BLAS implementation and it was successfully ""; 1291 ""detected by CMake as well that the imt CMake flag is set."" << Endl;; 1292#endif // DNNCPU; 1293}; 1294 ; 1295////////////////////////////////////////////////////////////////////////////////; 1296 ; 1297Double_t TMVA::MethodDNN::GetMvaValue( Double_t* /*errLower*/, Double_t* /*errUpper*/ ); 1298{; 1299 size_t nVariables = GetEvent()->GetNVariables();; 1300 Matrix_t X(1, nVariables);; 1301 Matrix_t YHat(1, 1);; 1302 ; 1303 const std::vector<Float_t>& inputValues = GetEvent()->GetValues();; 1304 for (size_t i = 0; i < nVariables; i++) {; 1305 X(0,i) = inputValues[i];; 1306 }; 1307 ; 1308 fNet.Prediction(YHat, X, fOutputFunction);; 1309 return YHat(0,0);; 1310}; 1311 ; 1312////////////////////////////////////////////////////////////////////////////////; 1313 ; 1314const std::vector<Float_t> & TMVA::MethodDNN::GetRegressionValues(); 1315{; 1316 size_t nVariables = GetEvent()->GetNVariables();; 1317 Matrix_t X(1, nVariables);; 1318 ; 1319 const Event *ev = GetEvent();; 1320 const std::vector<Float_t>& inputValues = ev->GetValues();; 1321 for (size_t i = 0; i < nVariables; i++) {; 1322 X(0,i) = inputValues[i];; 1323 }; 1324 ; 1325 size_t nTargets = std::max(1u, ev->GetNTargets());; 1326 Matrix_t YHat(1, nTargets);; 1327 std::vector<Float_t> output(nTargets);; 1328 auto net = fNet.CreateClone(1);; 1329 net.Prediction(YHat, X, fOutputFunction);; 1330 ; 1331 for (size_t i = 0; i < nTargets; i++); 1332 output[i] = YHat(0, i);; 1333 ; 1334 if (fRegressionReturnVal == NULL) {; 1335 fRegressionReturnVal = new std::vector<Float_t>();; 1336 }; 1337 fRegressionReturnVal->clear();; 1338 ; 1339 Event * evT = new Event(*ev);; 1340 for (size_t i = 0; i < nTargets; ++i) {; 1341 evT->SetTarget(i, output[i]);; 1342 }; 1343 ; 1344 const Event* evT2 = GetTransformationHandler().InverseTransform(evT);; 1345 for (size_t i = 0; i < nTargets; ++i) {; 1346 fRegressionReturnVal->push_back(evT2->GetTarget(i));; 1347 }; 1348 delete evT;; 1349 ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:47158,Predict,Prediction,47158,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['Predict'],['Prediction']
Safety,"a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}. Â» Last changed: root/fumili:$Id$ Â» Last generated: 2015-03-13 19:24; This page has been automatically",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFumili.html:24280,predict,predict,24280,root/html534/TFumili.html,https://root.cern,https://root.cern/root/html534/TFumili.html,1,['predict'],['predict']
Safety,"a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}. Â» Last changed: root/fumili:$Id$ Â» Last generated: 2015-06-02 15:48; This page has been automatically",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFumili.html:24793,predict,predict,24793,root/html604/TFumili.html,https://root.cern,https://root.cern/root/html604/TFumili.html,1,['predict'],['predict']
Safety,"a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}. Â» Last changed: root/fumili:$Id$ Â» Last generated: 2015-06-30 14:49; This page has been automatically",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFumili.html:24793,predict,predict,24793,root/html602/TFumili.html,https://root.cern,https://root.cern/root/html602/TFumili.html,1,['predict'],['predict']
Safety,"a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}. Â» Last changed: root/fumili:$Id: TFumili.h 20882 2007-11-19 11:31:26Z rdm $ Â» Last generated: 2010-09",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFumili.html:24228,predict,predict,24228,root/html528/TFumili.html,https://root.cern,https://root.cern/root/html528/TFumili.html,1,['predict'],['predict']
Safety,"a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}. Â» Last changed: root/fumili:$Id: TFumili.h 20882 2007-11-19 11:31:26Z rdm $ Â» Last generated: 2011-07",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFumili.html:24297,predict,predict,24297,root/html530/TFumili.html,https://root.cern,https://root.cern/root/html530/TFumili.html,1,['predict'],['predict']
Safety,"a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}. Â» Last changed: root/fumili:$Id: TFumili.h 40814 2011-09-06 13:55:49Z moneta $ Â» Last generated: 2011",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFumili.html:24261,predict,predict,24261,root/html532/TFumili.html,https://root.cern,https://root.cern/root/html532/TFumili.html,1,['predict'],['predict']
Safety,"a TObjArray*; 1763/// - if splitlevel = 1, one top level branch is created for each element; 1764/// of the TObjArray.; 1765/// - if splitlevel = 2, one top level branch is created for each array element.; 1766/// if, in turn, one of the array elements is a TCollection, one top level; 1767/// branch will be created for each element of this collection.; 1768///; 1769/// In case a collection element is a TClonesArray, the special Tree constructor; 1770/// for TClonesArray is called.; 1771/// The collection itself cannot be a TClonesArray.; 1772///; 1773/// The function returns the total number of branches created.; 1774///; 1775/// If name is given, all branch names will be prefixed with name_.; 1776///; 1777/// IMPORTANT NOTE1: This function should not be called with splitlevel < 1.; 1778///; 1779/// IMPORTANT NOTE2: The branches created by this function will have names; 1780/// corresponding to the collection or object names. It is important; 1781/// to give names to collections to avoid misleading branch names or; 1782/// identical branch names. By default collections have a name equal to; 1783/// the corresponding class name, e.g. the default name for a TList is ""TList"".; 1784///; 1785/// And in general, in case two or more master branches contain subbranches; 1786/// with identical names, one must add a ""."" (dot) character at the end; 1787/// of the master branch name. This will force the name of the subbranches; 1788/// to be of the form `master.subbranch` instead of simply `subbranch`.; 1789/// This situation happens when the top level object; 1790/// has two or more members referencing the same class.; 1791/// For example, if a Tree has two branches B1 and B2 corresponding; 1792/// to objects of the same class MyClass, one can do:; 1793/// ~~~ {.cpp}; 1794/// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; 1795/// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; 1796/// ~~~; 1797/// if MyClass has 3 members a,b,c, the two instructions above will generate; 1798/// subbranche",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:69837,avoid,avoid,69837,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['avoid'],['avoid']
Safety,"a TTimer subclass has to be; 240/// placed on another list, override TurnOn() to add the timer to the correct; 241/// list.; 242 ; 243void TTimer::TurnOn(); 244{; 245 // might have been set in a previous Start(); 246 Disconnect(this, ""Timeout()"", this, ""TurnOff()"");; 247 ; 248 if (gSystem) {; 249 gSystem->AddTimer(this);; 250 Emit(""TurnOn()"");; 251 }; 252}; 253 ; 254////////////////////////////////////////////////////////////////////////////////; 255/// This static function calls a slot after a given time interval.; 256/// Created internal timer will be deleted after that.; 257 ; 258void TTimer::SingleShot(Int_t milliSec, const char *receiver_class,; 259 void *receiver, const char *method); 260{; 261 TTimer *singleShotTimer = new TTimer(milliSec);; 262 TQObject::Connect(singleShotTimer, ""Timeout()"",; 263 receiver_class, receiver, method);; 264 ; 265 static TSingleShotCleaner singleShotCleaner; // single shot timer cleaner; 266 ; 267 // gSingleShotCleaner will delete singleShotTimer a; 268 // short period after Timeout() signal is emitted; 269 TQObject::Connect(singleShotTimer, ""Timeout()"",; 270 ""TTimer"", &singleShotCleaner, ""TurnOn()"");; 271 ; 272 singleShotTimer->Start(milliSec, kTRUE);; 273}; 274 ; 275////////////////////////////////////////////////////////////////////////////////; 276/// This function checks if the timer is running within gSystem; 277/// (Has been started and did not finish yet).; 278 ; 279bool TTimer::IsRunning(); 280{; 281 if (gSystem && gSystem->GetListOfTimers()); 282 return gSystem->GetListOfTimers()->IndexOf(this) != -1;; 283 return false;; 284}; Long_tlong Long_tDefinition RtypesCore.h:54; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; modeOption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; gTQSenderR__EXTERN void * gTQSenderDefinition TQObject.h:46; TROOT.h; gROOT#define gROOTDefinition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8cxx_source.html:9197,Timeout,Timeout,9197,doc/master/TTimer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html,3,['Timeout'],['Timeout']
Safety,"a certain algorithm, you may want to try another algorithm and compare the results. One solution is to add a new branch, fill it, and save the tree. The code below adds a simple branch to an existing tree. Note that the kOverwrite option in the Write method overwrites the existing tree. If it is not specified, two copies of the tree headers are saved.; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the tree; }; Adding a branch is often not possible because the tree is in a read-only file and you do not have permission to save the modified tree with the new branch. Even if you do have the permission, you risk loosing the original tree with an unsuccessful attempt to save the modification. Since trees are usually large, adding a branch could extend it over the 2GB limit. In this case, the attempt to write the tree fails, and the original data is may also be corrupted. In addition, adding a branch to a tree enlarges the tree and increases the amount of memory needed to read an entry, and therefore decreases the performance. For these reasons, ROOT offers the concept of friends for trees (and chains). We encourage you to use TTree::AddFriend rather than adding a branch manually.; 12.16.2 TTree::AddFriend; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way it is much like adding another branch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The TTree (tree) below has two friends (ft1 and ft2) and now has access to the variables a,b,c,i,j,k,l and m. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:569109,risk,risk,569109,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['risk'],['risk']
Safety,"a dummy name for the contained object type. When a particular container was needed, copy the code and then do a global search and replace for the contained class. C++ has a built in template scheme that effectively does just this. For example:; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; This is an array container with a 10-element array of pointers to T, it could hold up to 10 T objects. This array is flawed because it is static and hard-coded, it should be dynamic. However, the important point is that the template statement indicates that T is a template, or parameterized class. If we need an ArrayContainer for Track objects, it can be created by:; ArrayContainer<Track> MyTrackArrayContainer;; C++ takes the parameter list and substitutes Track for T throughout the definition of the class ArrayContainer, then compiles the code so generated, effectively doing the same we could do by hand, but with a lot less effort.; This produces code that is type safe, but does have different drawbacks:. Templates make code harder to read.; At the time of writing this documentation, some compilers can be very slow when dealing with templates.; It does not solve the problem when a container has to hold a heterogeneous set of objects.; The system can end up generating a great deal of code; each container/object combination has its own code, a phenomenon that is sometimes referred to as code bloat.; The Standard Template Library (STL) is part on ANSI C++, and includes a set of template containers. 17 Physics Vectors; The physics vector classes describe vectors in three and four dimensions and their rotation algorithms. The classes were ported to root from CLHEP see:; http://www.cern.ch/clhep/manual/UserGuide/Vector/vector.html; 17.1 The Physics Vector Classes; In order to use the physics vector classes you will have to load the Physics library:; gSystem.Load(""libPhysics.so"");; There are four classes in this package. They are:; TVector3 is a general th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:857014,safe,safe,857014,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety,"a fields always private. Or protected, if you want to grant an inherited class direct access.; Inline; Add trivial get or setters directly in the class definition. This improves reading time since one does not have to look for it somewhere else. Add more complex inlines (longer than one line) at the bottom of the .h file. Creating separate .icc files increases the build time, the complexity of the build system and, more importantly, increases the number of files one possibly has to scan to find a piece of code.; Declaration Order; In the class definition we first declare all private data members, followed by the private static members, the private methods and the private static methods. Then the protected members and methods and finally the public methods (no public data members). We put private members first since that is the language default and it gives the developer a quick view on what data members are used in a class.; Avoid raw C types; Avoid the use of raw C types like int, long, float, double when using data that might be written to disk. For example, the sizes of int and long are machine dependent. On 32 bit machines ints and longs are 32 bits, but on 64 bit processors an int can be either 32 or 64 bits and a long 64 bits, depending on the processor. For portability reasons and consistent numerical results use the typedefs provided by ROOT's Rtypes.h for the basic raw C types. E.g.: Double_t, Float_t, Int_t etc.; Exception handling; Don't let every method throw an exception when a simple error return code is often enough.; Namespaces; In ROOT 5 all classes are in the ROOT namespace. Some packages will be in a sub-namespace, e.g. ROOT::Reflex. For backward compatibility with the previous versions of ROOT, where all classes were in the global namespace, we have by default using namespace ROOT; in all headers. However, this can be turned off by defining the USE_ROOT_NAMESPACE macro.; Using comments to document the code; ROOT chose Doxygen for its code documen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/coding-conventions.html:4054,Avoid,Avoid,4054,d/coding-conventions.html,https://root.cern,https://root.cern/d/coding-conventions.html,2,['Avoid'],['Avoid']
Safety,"a for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the formula given as a parameter.; Max$(formula): return the maximum (within one TTree entry) of the value of the; elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition): return the minimum (maximum) (within one TTree entry); of the value of the elements of the formula given as a parameter; if they match the condition. If not element match the condition, the result is zero. To avoid the; the result is zero. To avoid the consequent peak a zero, use the; pattern:; tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match; for the condition. Alt$(primary,alternate) : return the value of ""primary"" if it is available; for the current iteration otherwise return the value of ""alternate"".; For example, with arr1[3] and arr2[2]; tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flatened/linearilized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:73898,avoid,avoid,73898,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,4,['avoid'],['avoid']
Safety,"a for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the formula given as a parameter.; Max$(formula): return the maximum (within one TTree entry) of the value of the; elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition): return the minimum (maximum) (within one TTree entry); of the value of the elements of the formula given as a parameter; if they match the condition. If not element match the condition, the result is zero. To avoid the; the result is zero. To avoid the consequent peak a zero, use the; pattern:; tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match; for the condition. Alt$(primary,alternate) : return the value of ""primary"" if it is available; for the current iteration otherwise return the value of ""alternate"".; For example, with arr1[3] and arr2[2]; tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr[0]+arr2[0] ; arr[1]+arr2[1] and arr[1]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:30080,avoid,avoid,30080,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,2,['avoid'],['avoid']
Safety,"a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside). - returns director cosines of normal to the crossed shape surface from a; given point towards a direction. One has to specify if the point is inside; or outside shape. According to this, the normal will be outwards or inwards; shape respectively. Normal components are statically stored by shape class,; so it has to be copied after retreival in a different array. Dividing shapes. Shapes can generally be divided along a given axis. Supported axis are; X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis.; The general rule is that that divisions are possible on whatever axis that; produces still known shapes as slices. The division of shapes should not be; performed by TGeoShape::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShape.html:5132,Safe,Safety,5132,root/html528/TGeoShape.html,https://root.cern,https://root.cern/root/html528/TGeoShape.html,3,['Safe'],['Safety']
Safety,"a milliSec timeout.Definition TTimer.cxx:213; TTimer::TurnOnvirtual void TurnOn()Add the timer to the system timer list.Definition TTimer.cxx:243; TTimer::SetCommandvoid SetCommand(const char *command)Set the interpreter command to be executed at time out.Definition TTimer.cxx:176; TTimer::fCommandTString fCommandDefinition TTimer.h:61; TTimer::SetInterruptSyscallsvoid SetInterruptSyscalls(Bool_t set=kTRUE)When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted...Definition TTimer.cxx:199; TTimer::fTimeTTime fTimeDefinition TTimer.h:54; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; TTimer::CheckTimerBool_t CheckTimer(const TTime &now)Check if timer timed out.Definition TTimer.cxx:130; TTimer::SetObjectvoid SetObject(TObject *object)Set the object to be notified at time out.Definition TTimer.cxx:186; TTimer::SingleShotstatic void SingleShot(Int_t milliSec, const char *receiver_class, void *receiver, const char *method)This static function calls a slot after a given time interval.Definition TTimer.cxx:258; TTimer::fObjectTObject * fObjectDefinition TTimer.h:60; TTimer::SetTimevoid SetTime(Long_t milliSec)Definition TTimer.h:91; TTimer::fAbsTimeTTime fAbsTimeDefinition TTimer.h:55; TTimer::fTimeoutBool_t fTimeoutDefinition TTimer.h:56; TTimer::TTimerTTimer(const TTimer &)=delete; TTimer::NotifyBool_t Notify() overrideNotify when timer times out.Definition TTimer.cxx:145; TTimer::fSyncBool_t fSyncDefinition TTimer.h:57; TTimer::IsRunningBool_t IsRunning()This function checks if the timer is running within gSystem (Has been started and did not finish yet)...Definition TTimer.cxx:279; TTimer::fIntSyscallsBool_t fIntSyscallsDefinition TTimer.h:58; TTimer::Timeoutvirtual void Timeout()Definition TTimer.h:97; bool; int; object; ROOT::GetROOTTROOT * GetROOT()Definition TROOT.cxx:472. corebasesrcTTimer.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:08 (GVA Time) using Doxygen 1.9.8 Â Â ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8cxx_source.html:14900,Timeout,Timeoutvirtual,14900,doc/master/TTimer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html,2,['Timeout'],"['Timeout', 'Timeoutvirtual']"
Safety,"a multi-variate Gaussian on the parameters of the fitted pdf ; Â ; file Â rf608_fitresultaspdf.py; Â  Likelihood and minimization: representing the parabolic approximation of the fit as a multi-variate Gaussian on the parameters of the fitted pdf ; Â ; file Â rf609_xychi2fit.C; Â  Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,err(Y) values (and optionally err(X) values) ; Â ; file Â rf609_xychi2fit.py; Â  Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,err(Y) values (and optionally err(X) values) ; Â ; file Â rf610_visualerror.C; Â  Likelihood and minimization: visualization of errors from a covariance matrix ; Â ; file Â rf610_visualerror.py; Â  Likelihood and minimization: visualization of errors from a covariance matrix ; Â ; file Â rf611_weightedfits.C; Â  Likelihood and minimization: Parameter uncertainties for weighted unbinned ML fits ; Â ; file Â rf612_recoverFromInvalidParameters.C; Â  Likelihood and minimization: Recover from regions where the function is not defined. ; Â ; file Â rf612_recoverFromInvalidParameters.py; Â  Likelihood and minimization: Recover from regions where the function is not defined. ; Â ; file Â rf613_global_observables.C; Â  This tutorial explains the concept of global observables in RooFit, and showcases how their values can be stored either in the model or in the dataset. ; Â ; file Â rf613_global_observables.py; Â  This tutorial explains the concept of global observables in RooFit, and showcases how their values can be stored either in the model or in the dataset. ; Â ; file Â rf614_binned_fit_problems.C; Â  A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. ; Â ; file Â rf614_binned_fit_problems.py; Â  A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. ; Â ; file Â rf615_simulation_based_inference.py; Â  Use Simulation Based Inference (SBI) in RooFit. ; Â ; file Â rf616_morphin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__roofit.html:18288,Recover,Recover,18288,doc/master/group__tutorial__roofit.html,https://root.cern,https://root.cern/doc/master/group__tutorial__roofit.html,1,['Recover'],['Recover']
Safety,"a system (OS or GUI) related error occurred.Definition TError.cxx:196; GetErrorSystemMsgHandlerRefstatic ROOT::Internal::ErrorSystemMsgHandlerFunc_t & GetErrorSystemMsgHandlerRef()Definition TError.cxx:41; AbstractMethodvoid AbstractMethod(const char *method)This function can be used in abstract base classes in case one does not want to make the class a ""rea...Definition TError.cxx:159; ErrorHandlervoid ErrorHandler(Int_t level, const char *location, const char *fmt, std::va_list ap)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Warningvoid Warning(const char *location, const char *fmt,...)Use this function in warning situations.Definition TError.cxx:229; MayNotUsevoid MayNotUse(const char *method)This function can be used in classes that should override a certain function, but in the inherited cl...Definition TError.cxx:168; Fatalvoid Fatal(const char *location, const char *fmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36; Obsoletevoid Obsolete(const char *function, const char *asOfVers, const char *removedFromVers)Use this function to declare a function obsolete.Definition TError.cxx:177; SetErrorHandlerErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; ErrorHandlerFunc_tvoid(* ErrorHandlerFunc_t)(int level, Bool_t abort, const char *location, const char *msg)Definition TError.h:71; kBreakconstexpr Int_t kBreakDefinition TError.h:48; kInfoconstexpr Int_t kInfoDefinition TError.h:45; gErr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8cxx_source.html:10468,abort,abort,10468,doc/master/TError_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html,1,['abort'],['abort']
Safety,"a(openingBracketPos + 1, closingBracketPos - openingBracketPos - 1);; 1197 dim = varList.CountChar(',') + 1;; 1198 variables.resize(dim);; 1199 Int_t Nvar = 0;; 1200 TString varName = """";; 1201 for (Int_t i = 0; i < varList.Length(); ++i) {; 1202 if (IsFunctionNameChar(varList[i])) {; 1203 varName.Append(varList[i]);; 1204 }; 1205 if (varList[i] == ',') {; 1206 variables[Nvar] = varName;; 1207 varName = """";; 1208 Nvar++;; 1209 }; 1210 }; 1211 if (varName != """") // we will miss last variable; 1212 {; 1213 variables[Nvar] = varName;; 1214 }; 1215 }; 1216 // check if dimension obtained from [...] is compatible with what is defined in existing pre-defined functions; 1217 // std::cout << "" Found dim = "" << dim << "" and function dimension is "" << funDim << std::endl;; 1218 if (dim != funDim) {; 1219 pair<TString, Int_t> key = make_pair(funName, dim);; 1220 if (functions.find(key) == functions.end()) {; 1221 Error(""PreProcessFormula"", ""Dimension of function %s is detected to be of dimension %d and is not ""; 1222 ""compatible with existing pre-defined function which has dim %d"",; 1223 funName.Data(), dim, funDim);; 1224 return;; 1225 }; 1226 // skip the particular function found - we might find later on the corresponding pre-defined function; 1227 funPos = formula.Index(funName, lastFunPos);; 1228 continue;; 1229 }; 1230 // look now for the (..) brackets to get the parameter counter (e.g. gaus(0) + gaus(3) ); 1231 // need to start for a position; 1232 Int_t openingParenthesisPos = (closingBracketPos == kNPOS) ? openingBracketPos : closingBracketPos + 1;; 1233 bool defaultCounter = (openingParenthesisPos > formula.Length() || formula[openingParenthesisPos] != '(');; 1234 ; 1235 // Int_t openingParenthesisPos = formula.Index('(',funPos);; 1236 // Bool_t defaultCounter = (openingParenthesisPos == kNPOS);; 1237 Int_t counter;; 1238 if (defaultCounter) {; 1239 counter = 0;; 1240 } else {; 1241 // Check whether this is just a number in parentheses. If not, leave; 1242 // it to `Han",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:45814,detect,detected,45814,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['detect'],['detected']
Safety,"a.h. â—†Â GetY(). Double_t TGeoPara::GetY ; (; ); const. inline . Definition at line 67 of file TGeoPara.h. â—†Â GetZ(). Double_t TGeoPara::GetZ ; (; ); const. inline . Definition at line 68 of file TGeoPara.h. â—†Â InspectShape(). void TGeoPara::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â IsA(). TClass * TGeoPara::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 85 of file TGeoPara.h. â—†Â IsCylType(). Bool_t TGeoPara::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 76 of file TGeoPara.h. â—†Â operator=(). TGeoPara & TGeoPara::operator= ; (; const TGeoPara &Â ; ). protecteddelete . â—†Â Safety(). Double_t TGeoPara::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Safety_v(). void TGeoPara::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â SavePrimitive(). void TGeoPara::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. â—†Â SetDimensions(). void TGeoPara::SetDimensions ; (; Double_t *Â ; param). overridevirtual . Reimplemented from TGeoBBox. â—†Â SetPoints() [1/2]. void TGeoPara::SetPoints ; (; Double_t *Â ; points); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â SetPoints() [2/2]. void TGeoPara::SetPoints ; (; Float_t *Â ; points); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Sizeof3D(). void TGeoPara::Sizeof3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Streamer(). void TGeoPara::Streamer ; (; TBuffer &Â ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGeoBBox. â—†Â StreamerNVirtual(). void TGeoPara::StreamerNVirtual ; (; TBuffer &Â ; Clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPara.html:28479,safe,safe,28479,doc/master/classTGeoPara.html,https://root.cern,https://root.cern/doc/master/classTGeoPara.html,1,['safe'],['safe']
Safety,"a; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect.; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 527 of file TROOT.cxx. â—†Â EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:26336,safe,safe,26336,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['safe'],['safe']
Safety,"a_16x16.root"";; ; bool fileExist = !gSystem->AccessPathName(inputFileName);; ; // if file does not exists create it; if (!fileExist) {; MakeImagesTree(nevts, 16, 16);; }; ; bool useTMVACNN = (opt.size() > 0) ? opt[0] : false;; bool useKerasCNN = (opt.size() > 1) ? opt[1] : false;; bool useTMVADNN = (opt.size() > 2) ? opt[2] : false;; bool useTMVABDT = (opt.size() > 3) ? opt[3] : false;; bool usePyTorchCNN = (opt.size() > 4) ? opt[4] : false;; #ifndef R__HAS_TMVACPU; #ifndef R__HAS_TMVAGPU; Warning(""TMVA_CNN_Classification"",; ""TMVA is not build with GPU or CPU multi-thread support. Cannot use TMVA Deep Learning for CNN"");; useTMVACNN = false;; #endif; #endif; ; bool writeOutputFile = true;; ; #ifdef R__USE_IMT; int num_threads = 4; // use by default 4 threads if value is not set before; // switch off MT in OpenBLAS to avoid conflict with tbb; gSystem->Setenv(""OMP_NUM_THREADS"", ""1"");; ; // do enable MT running; if (num_threads >= 0) {; ROOT::EnableImplicitMT(num_threads);; }; #endif; ; TMVA::Tools::Instance();; ; ; std::cout << ""Running with nthreads = "" << ROOT::GetThreadPoolSize() << std::endl;; ; #ifdef R__HAS_PYMVA; gSystem->Setenv(""KERAS_BACKEND"", ""tensorflow"");; // for using Keras; TMVA::PyMethodBase::PyInitialize();; #else; useKerasCNN = false;; usePyTorchCNN = false;; #endif; ; TFile *outputFile = nullptr;; if (writeOutputFile); outputFile = TFile::Open(""TMVA_CNN_ClassificationOutput.root"", ""RECREATE"");; ; /***; ## Create TMVA Factory; ; Create the Factory class. Later you can choose the methods; whose performance you'd like to investigate.; ; The factory is the major TMVA object you have to interact with. Here is the list of parameters you need to pass; ; - The first argument is the base of the name of all the output; weight files in the directory weight/ that will be created with the; method parameters; ; - The second argument is the output file for the training results; ; - The third argument is a string option defining some general configuration for the TM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:48644,avoid,avoid,48644,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['avoid'],['avoid']
Safety,"abel to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. RooAbsCategory(); Constructors, assignment etc. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; coverity[PASS_BY_VALUE]. RooCatType evaluate() const. Â» Last changed: Tue Jun 2 15:26:57 2015 Â» Last generated: 2015-06-02 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsCategory.html:28371,safe,safe,28371,root/html604/RooAbsCategory.html,https://root.cern,https://root.cern/root/html604/RooAbsCategory.html,1,['safe'],['safe']
Safety,"able ""ObjectsTable"".; In this there are following columns:; ""key:id"" - key identifier to which belong object; ""obj:id"" - object identifier; ""Class"" - object class name; ""Version"" - object class version; Data in each ""ObjectsTable"" row uniqly identify, in which table; and which column object is stored. In normal situation all class data should be sorted columnwise.; Up to now following member are supported:; 1) Basic data types; Here is everything clear. Column SQL type will be as much as possible; close to the original type of value.; 2) Fixed array of basic data types; In this case n columns like fArr[0], fArr[1] and so on will be created.; If there is multidimensional array, names will be fArr2[1][2][1] and so on; 3) Parent class; In this case version of parent class is stored and; data of parent class will be stored with the same obj:id in corrspondent table.; There is a special case, when parent store nothing (this is for instance TQObject).; In that case just -1 is written to avoid any extra checks if table exist or not.; 4) Object as data member.; In that case object is saved in normal way to data base and column; will contain id of this object.; 5) Pointer on object; Same as before. In case if object was already stored, just its id; will be placed in the column. For NULL pointer 0 is used.; 6) TString; Now column with limited width like VARCAHR(255) in MySQL is used.; Later this will be improved to support maximum possible strings; 7) Anything else.; Data will be converted to raw format and saved in _streamer_ table.; Each row supplied with obj:id and row:id, where row:id indicates; data, corresponding to this particular data member, and column; will contain this raw:id. All conversion to SQL statements are done with help of TSQLStructure class.; This is special hierarchical structure wich internally is very similar; to XML structures. TBufferSQL2 creates these structures, when object; data is streamed by ROOT and only afterwards all SQL statements will be pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:2124,avoid,avoid,2124,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,5,['avoid'],['avoid']
Safety,"able (flux vs wavelength) and dump its columns ; Â FITS_tutorial7.COpen a FITS file that contains a catalog of astronomical objects and dump some of its columns ; Â â–ºÂ foam; Â foam_demo.C Demonstrate the TFoam class ; Â foam_demopers.C This simple macro demonstrates persistency of FOAM object ; Â foam_kanwa.C This program can be execute from the command line as folows: ; Â â–ºÂ geom; Â assembly.CGeometry detector assembly example ; Â building.CDrawing a building where Dept ; Â cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ; Â csgdemo.CCombinatorial Solid Geometry example ; Â geodemo.CGUI to draw the geometry shapes ; Â geomAlice.CScript drawing a detector geometry (here ALICE) ; Â geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ; Â geomAtlas.CScript drawing a detector geometry (here ATLAS) ; Â geomBrahms.CScript drawing a detector geometry (here BRAHMS) ; Â geomD0.CScript drawing a detector geometry (here D0) ; Â geometry.CExample of the old geometry package (now obsolete) ; Â iterplugin.cxx; Â lego.CDrawing a figure, made of lego block, using ROOT geometry class ; Â mp3player.CDrawing a mp3 type music player, using ROOT geometry class ; Â na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ; Â na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ; Â na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ; Â parallel_world.CMisaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and are correlated ; Â RadioNuclides.CMacro that demonstrates usage of radioactive elements/materials/mixtures with TGeo pac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:107594,detect,detector,107594,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,2,['detect'],['detector']
Safety,"able rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. void SetSimpleArray(Int_t arraySize, Int_t firstRow, Int_t numberRows); Set some common parameteres for the ""simple"" arrays. ~TTableSorter(); to be documented. Int_t BSearch(valuetype value). Int_t SelectSearch(valuetype value). Int_t BSearch(const void* value) const; to be documented. Int_t GetIndex(UInt_t sortedIndex) const; returns the original index of the row by its sorted index. Int_t CountKey(const void* key, Int_t firstIndx = 0, Bool_t bSearch = kTRUE, Int_t* firstRow = 0) const. CountKey counts the number of rows with the key value equal ""key"". key - it is a POINTER to the key value; fistIndx - the first index within sorted array to star search; = 0 by default; bSearch = kTRUE - binary search (by default) is used otherwise linear one. Int_t CountKeys() const. Counts the number of different key values. Bool_t FillIndexArray(). File the array of the pointers and check whether; the original table has been sorted to avoid an extra job. Return: kTRUE - the table has been sorted; kFALSE - otherwise. Int_t FindFirstKey(const void* key) const. Looks for the first index of the ""key""; within SORTED table AFTER sorting. Returns: = -1 if the ""key"" was not found. Note: This method has no sense for; ==== the float and double key. To get the index within the original; unsorted table the GetIndex() method; may be used like this:; GetIndex(FindFirstKey(key)). const char * GetTableName() const; to be documented. const char * GetTableTitle() const; to be documented. const char * GetTableType() const; to be documented. TTable * GetTable() const; to be documented. void SetSearchMethod(); Select search function at once. void QSort(); Call the standard C run-time library ""qsort"" function. void LearnTable(). LearnTable() allows the TTableSorter to learn the structure of the; tables used to fill the ntuple.; table - the name of the table; buildTree - if kTRUE, then add TBranches to t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTableSorter.html:18361,avoid,avoid,18361,root/html528/TTableSorter.html,https://root.cern,https://root.cern/root/html528/TTableSorter.html,6,['avoid'],['avoid']
Safety,"about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. It is not simple to activate the cache; by default (except case1 below) because there are many possible configurations.; In some applications you know a priori the list of branches to read.; In other applications the analysis loop calls several layers of user functions; where it is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:4002,predict,predict,4002,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,3,['predict'],['predict']
Safety,"access via dCache. ; Â ; Â ~TDCacheSystem () override; Â ; Bool_tÂ AccessPathName (const char *path, EAccessMode mode) override; Â Returns FALSE if one can access a file using the specified access mode. ; Â ; voidÂ FreeDirectory (void *dirp) override; Â Close a directory. ; Â ; const char *Â GetDirEntry (void *dirp) override; Â Get a directory entry. ; Â ; Int_tÂ GetPathInfo (const char *path, FileStat_t &buf) override; Â Get info about a file. ; Â ; TClass *Â IsA () const override; Â ; Int_tÂ MakeDirectory (const char *name) override; Â Create a directory. ; Â ; void *Â OpenDirectory (const char *name) override; Â Open a directory. ; Â ; voidÂ Streamer (TBuffer &) override; Â Stream an object of class TObject. ; Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; Â Public Member Functions inherited from TSystem; Â TSystem (const char *name=""Generic"", const char *title=""Generic System""); Â Create a new OS interface. ; Â ; virtualÂ ~TSystem (); Â Delete the OS interface. ; Â ; virtual voidÂ Abort (int code=0); Â Abort the application. ; Â ; virtual intÂ AcceptConnection (int sock); Â Accept a connection. ; Â ; virtual voidÂ AddDynamicPath (const char *pathname); Â Add a new directory to the dynamic path. ; Â ; virtual voidÂ AddFileHandler (TFileHandler *fh); Â Add a file handler to the list of system file handlers. ; Â ; virtual voidÂ AddIncludePath (const char *includePath); Â Add a directory to the already set include path. ; Â ; virtual voidÂ AddLinkedLibs (const char *linkedLib); Â Add linkedLib to already set linked libs. ; Â ; virtual voidÂ AddSignalHandler (TSignalHandler *sh); Â Add a signal handler to list of system signal handlers. ; Â ; virtual voidÂ AddStdExceptionHandler (TStdExceptionHandler *eh); Â Add an exception handler to list of system exception handlers. ; Â ; virtual voidÂ AddTimer (TTimer *t); Â Add timer to list of system timers. ; Â ; virtual intÂ AnnounceTcpService (int port, Bool_t reuse, int backlog, int tcpwindowsize=-1); Â Announce TCP/IP service. ; Â ; virtual intÂ AnnounceUdpServic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheSystem.html:1429,Abort,Abort,1429,doc/master/classTDCacheSystem.html,https://root.cern,https://root.cern/doc/master/classTDCacheSystem.html,2,['Abort'],['Abort']
Safety,"ace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. â—†Â Safety_v(). virtual void TGeoShape::Safety_v ; (; const Double_t *Â ; , . const Bool_t *Â ; , . Double_t *Â ; , . Int_tÂ ; Â . ); const. inlinevirtual . Reimplemented in TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoXtru.; Definition at line 151 of file TGeoShape.h. â—†Â SafetyPhi(). Double_t TGeoShape::SafetyPhi ; (; const Double_t *Â ; point, . Bool_tÂ ; in, . Double_tÂ ; phi1, . Double_tÂ ; phi2Â . ). static . Static method to compute safety w.r.t a phi corner defined by cosines/sines of the angles phi1, phi2. ; Definition at line 494 of file TGeoShape.cxx. â—†Â SafetySeg(). Double_t TGeoShape::SafetySeg ; (; Double_tÂ ; r, . Double_tÂ ; z, . Double_tÂ ; r1, . Double_tÂ ; z1, . Double_tÂ ; r2, . Double_tÂ ; z2, . Bool_tÂ ; outerÂ . ). static . Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2) ; Definition at line 528 of file TGeoShape.cxx. â—†Â SetDimensions(). virtual void TGeoShape::SetDimensions ; (; Double_t *Â ; param). pure virtual . Implemented in TGeoCompositeShape, TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. â—†Â SetId(). void TGeoShape::SetId ; (; Int_tÂ ; id). inline . Definition at line 155 of file TGeoShape.h. â—†Â SetOnBoundary(). void TGeoShape::SetOnBoundary ; (; Bool_tÂ ; ). inlineprotected . Definition at line 76 of file TGeoShape.h. â—†Â SetPoints() [1/2]. virtual void TGeoShape::SetPoints ; (; Double_t *Â ; points); const. pure",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:46824,Safe,SafetySeg,46824,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['Safe'],['SafetySeg']
Safety,"acheAction action=kDisconnect)TFilevirtual; SetCacheWrite(TFileCacheWrite *cache)TFilevirtual; SetCompressionAlgorithm(Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal)TFilevirtual; SetCompressionLevel(Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin)TFilevirtual; SetCompressionSettings(Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault)TFilevirtual; SetDrawOption(Option_t *option="""")TObjectvirtual; SetDtorOnly(void *obj)TObjectstatic; SetEND(Long64_t last)TFileinlinevirtual; SetFileBytesRead(Long64_t bytes=0)TFilestatic; SetFileBytesWritten(Long64_t bytes=0)TFilestatic; SetFileReadCalls(Int_t readcalls=0)TFilestatic; SetModified() overrideTDirectoryFileinlinevirtual; SetMother(TObject *mother)TDirectoryinlinevirtual; SetName(const char *newname) overrideTDirectoryvirtual; SetNameTitle(const char *name, const char *title)TNamedvirtual; SetObjectStat(Bool_t stat)TObjectstatic; SetOffset(Long64_t offset, ERelativeTo pos=kBeg)TFilevirtual; SetOnlyStaged(Bool_t onlystaged)TFilestatic; SetOpenTimeout(UInt_t timeout)TFilestatic; SetOption(Option_t *option="">"")TFileinlinevirtual; SetReadaheadSize(Int_t bufsize=256000)TFilestatic; SetReadCalls(Int_t readcalls=0)TFileinlinevirtual; SetReadStreamerInfo(Bool_t readinfo=kTRUE)TFilestatic; SetSeekDir(Long64_t v) overrideTDirectoryFileinlinevirtual; SetTitle(const char *title="""")TNamedvirtual; SetTRefAction(TObject *ref, TObject *parent) overrideTDirectoryFilevirtual; SetUniqueID(UInt_t uid)TObjectvirtual; SetWritable(Bool_t writable=kTRUE) overrideTDirectoryFilevirtual; SharedGDirectory_t typedefTDirectoryprotected; ShowStreamerInfo()TFilevirtual; ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval=0)TFilestatic; Sizeof() const overrideTFilevirtual; Streamer(TBuffer &) overrideTFilevirtual; StreamerNVirtual(TBuffer &ClassDef_StreamerNVirtual_b)TFileinline; SumBuffer(Int_t bufsize)TFile; SysClose(Int_t fd)TFileprotectedvirtual; SysError(const char *method, const char *msgfmt,.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFile-members.html:17995,timeout,timeout,17995,doc/master/classTFile-members.html,https://root.cern,https://root.cern/doc/master/classTFile-members.html,1,['timeout'],['timeout']
Safety,"acity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Computes capacity of the shape in [length^3]. ~TGeoCone(); destructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCone.html:13853,safe,safe,13853,root/html528/TGeoCone.html,https://root.cern,https://root.cern/root/html528/TGeoCone.html,6,['safe'],['safe']
Safety,"ad *th = new TThread(UserFun,UserArgs);; When called from the interpreter, this gives the name â€œUserFunâ€ to the thread. This name can be used to retrieve the thread later. However, when called from compiled code, this method does not give any name to the thread. So give a name to the thread in compiled use:; root[] TThread *th = new TThread(""MyThread"", UserFun, UserArgs);; You can pass arguments to the thread function using the UserArgs-pointer. When you want to start a method of a class as a thread, you have to give the pointer to the class instance as UserArgs. Running. root[] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; With the mhs3 example, you should be able to see a canvas with two pads on it. Both pads keep histograms updated and filled by three different threads. With the CalcPi example, you should be able to see two threads calculating Pi with the given number of intervals as precision.; 23.2.4 TThread in More Details; Cling is not thread safe yet, and it will block the execution of the threads until it has finished executing.; 23.2.4.1 Asynchronous Actions; Different threads can work simultaneously with the same object. Some actions can be dangerous. For example, when two threads create a histogram object, ROOT allocates memory and puts them to the same collection. If it happens at the same time, the results are undetermined. To avoid this problem, the user has to synchronize these actions with:; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; The code between Lock() and UnLock() will be performed uninterrupted. No other threads can perform actions or access objects/collections while it is being executed. The methods TThread::Lock()and TThread::UnLock() internally use a global TMutex instance for locking.; The user may also define their own TMutex MyMutex instance and may locally protect their asynchronous actions by calling MyMutex.Lock() and MyMutex.UnLock().; 23.2.4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1107080,safe,safe,1107080,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safe']
Safety,"ad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*GetLeftMatrix() const; TGeoShape*GetLeftShape() const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoBoolNode.html:2480,safe,safe,2480,root/html532/TGeoBoolNode.html,https://root.cern,https://root.cern/root/html532/TGeoBoolNode.html,1,['safe'],['safe']
Safety,"ad(const char *name)TObjectvirtual; RecursiveRemove(TObject *obj)TObjectvirtual; RecvBuf(int sock, void *buffer, int length)TSystemvirtual; RecvRaw(int sock, void *buffer, int length, int flag)TSystemvirtual; RedirectOutput(const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr)TSystemvirtual; RemoveFileHandler(TFileHandler *fh)TSystemvirtual; RemoveOnExit(TObject *obj)TSystem; RemoveSignalHandler(TSignalHandler *sh)TSystemvirtual; RemoveStdExceptionHandler(TStdExceptionHandler *eh)TSystemvirtual; RemoveTimer(TTimer *t)TSystemvirtual; Rename(const char *from, const char *to)TSystemvirtual; ResetBit(UInt_t f)TObjectinline; ResetErrno()TSystemstatic; ResetSignal(ESignals sig, Bool_t reset=kTRUE)TSystemvirtual; ResetSignals()TSystemvirtual; ResetTimer(TTimer *)TSysteminlinevirtual; Run()TSystemvirtual; SaveAs(const char *filename="""", Option_t *option="""") constTObjectvirtual; SavePrimitive(std::ostream &out, Option_t *option="""")TObjectvirtual; Select(TList *active, Long_t timeout)TSystemvirtual; Select(TFileHandler *fh, Long_t timeout)TSystemvirtual; SendBuf(int sock, const void *buffer, int length)TSystemvirtual; SendRaw(int sock, const void *buffer, int length, int flag)TSystemvirtual; SetAclicMode(EAclicMode mode)TSystemvirtual; SetBit(UInt_t f, Bool_t set)TObject; SetBit(UInt_t f)TObjectinline; SetBuildDir(const char *build_dir, Bool_t isflat=kFALSE)TSystemvirtual; SetDisplay()TSystemvirtual; SetDrawOption(Option_t *option="""")TObjectvirtual; SetDtorOnly(void *obj)TObjectstatic; SetDynamicPath(const char *pathname)TSystemvirtual; Setenv(const char *name, const char *value)TSystemvirtual; SetErrorStr(const char *errstr)TSystem; SetFlagsDebug(const char *)TSystemvirtual; SetFlagsOpt(const char *)TSystemvirtual; SetFPEMask(Int_t mask=kDefaultMask)TSystemvirtual; SetIncludePath(const char *includePath)TSystemvirtual; SetLinkdefSuffix(const char *suffix)TSystemvirtual; SetLinkedLibs(const char *linkedLibs)TSystemvirtual; SetMakeExe(const char *directives)TSys",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem-members.html:13502,timeout,timeout,13502,doc/master/classTSystem-members.html,https://root.cern,https://root.cern/doc/master/classTSystem-members.html,1,['timeout'],['timeout']
Safety,"ad(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual intRecvBuf(int sock, void* buffer, int length); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidRemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* t); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetTimer(TTimer*); virtual voidRun(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidSetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* pathname); virtual voidSetenv(const char* name, const char* value); voidSetErrorStr(const char* errstr); virtual voidSetFlagsDebug(const char*); virtual voidSetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidSetIncludePath(const char* includePath); virtual voidSetLinkdefSuffix(const char* suffix); virtual voidSetLinkedLibs(const char* linkedLibs); virtual voidSetMakeExe(const char* directives",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSystem.html:10870,timeout,timeout,10870,root/html530/TSystem.html,https://root.cern,https://root.cern/root/html530/TSystem.html,2,['timeout'],['timeout']
Safety,"adData() const; Needed just for cleanup. void CreateThreadData(Int_t nthreads); Needed just for cleanup. TGeoCompositeShape(); Default constructor. TGeoCompositeShape(const char* name, const char* expression); Default constructor. TGeoCompositeShape(const char* expression); Default constructor. TGeoCompositeShape(const char* name, TGeoBoolNode* node); Constructor with a Boolean node. ~TGeoCompositeShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3] by sampling with 1% error. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Computes normal vector in POINT to the composite shape. Bool_t Contains(const Double_t* point) const; Tests if point is inside the shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to this composite shape.; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to outside of this composite shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. void MakeNode(const char* expression); Make a booleann node according to the top level boolean operation of expression.; Propagates signal to branches until expression is fully decomposed.; printf(""Making node for : %s\n"", expression);. Bool_t Paint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCompositeShape.html:19375,safe,safe,19375,root/html534/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html,3,['safe'],['safe']
Safety,"adFunctionMultiNumGradFunction class to wrap a normal function in a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) ; Â CMultPolicyMatrix-matrix multiplication policy ; Â CNullTypeFunc1D; Â COneDimMultiFunctionAdapterOneDimMultiFunctionAdapter class to wrap a multidimensional function in one dimensional one ; Â COneDimParamFunctionAdapterOneDimParamFunctionAdapter class to wrap a multi-dim parameteric function in one dimensional one ; Â CParamFunctionBase template class for all Parametric Functions ; Â CParamFunctionBaseClass defining the signature for multi-dim parametric functions ; Â CParamFunctorParam Functor class for Multidimensional functions ; Â â–ºCParamFunctorHandlerParamFunctor Handler class is responsible for wrapping any other functor and pointer to free C functions ; Â CFuncEvaluator; Â CFuncEvaluator< F * >; Â CFuncEvaluator< F *const >; Â CParamMemFunHandlerParamFunctor Handler to Wrap pointers to member functions ; Â CPlaceExpr; Â CPlaceExpr< T, D1, D2, D3, D4, A, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >; Â CPlaceExpr< T, D1, D2, D3, D4, A, MatRepSym< T, D1 >, MatRepSym< T, D3 > >; Â CPlaceMatrixStructure to deal when a submatrix is placed in a matrix ; Â CPlaceMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >; Â CPlaceMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepSym< T, D3 > >; Â CPlainParameters; Â CPlusEqualsEvaluate the expression performing a += operation Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) ; Â CPlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >Specialization for symmetrix += general : NOT Allowed operation ; Â CPlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices Evaluate the expression performing a += operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:46749,avoid,avoid,46749,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['avoid'],['avoid']
Safety,"address where the data ends.. When a file is closed, it writes a linked list of keys at the end of the file. This is what we see in the third to the last entry. In our example, the list of keys is stored in 732 bytes beginning at byte# 8244.; 20010404/092347 At:8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; The second to last entry is a list of free segments. In our case, this starts 8976 and is not very long, only 53 bytes, since we have not deleted any objects. The last entry is the address of the last byte in the file.; 11.1.6 File Recovery; A file may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:440518,recover,recovery,440518,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['recover', 'redund']","['recovery', 'redundant']"
Safety,"ader viewVC source. Sections:; class description; function members; data members; class charts. ROOT; Â» GEOM; Â» GEOM; Â» TGeoVolume. class TGeoVolume: public TNamed, public TGeoAtt, public TAttLine, public TAttFill, public TAtt3D. TGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly - the volume classes. Volumes are the basic objects used in building the geometrical hierarchy.; They represent unpositioned objects but store all information about the; placement of the other volumes they may contain. Therefore a volume can; be replicated several times in the geometry. In order to create a volume, one; has to put together a shape and a medium which are already defined. Volumes; have to be named by users at creation time. Every different name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:1154,avoid,avoid,1154,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,3,['avoid'],['avoid']
Safety,"aderArrayExtracts array data from a TTree ; Â CIterator_t; Â CTTreeReaderValueExtracts data from a TTree ; Â CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ; Â CTTreeRowClass defining interface to a row of a TTree query result ; Â CTTreeSQLImplement TTree for a SQL backend ; Â CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ; Â CTTreeViewA helper class that encapsulates a file and a tree ; Â CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ; Â CTTUBEA tube ; Â CTTUBSA segment of a tube ; Â CTTVLVContainerThis class represent the list view container for the ; Â CTTVLVEntryThis class represent entries that goes into the TreeViewer listview container ; Â CTTVRecordI/O classes for TreeViewer session handling ; Â CTTVSessionI/O classes for TreeViewer session handling ; Â CTUDPSocket; Â CTUnfoldAn algorithm to unfold distributions from detector to truth level ; Â CTUnfoldBinningBinning schemes for use with the unfolding algorithm TUnfoldDensity ; Â CTUnfoldBinningXMLXML interfate to binning schemes, for use with the unfolding algorithm TUnfoldDensity ; Â CTUnfoldDensityAn algorithm to unfold distributions from detector to truth level ; Â CTUnfoldSysAn algorithm to unfold distributions from detector to truth level, with background subtraction and propagation of systematic uncertainties ; Â CTUnixSystem; Â CTUnuranTUnuran class ; Â CTUnuranBaseDistTUnuranBaseDist, base class for Unuran distribution classees such as TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension) ; Â CTUnuranContDistTUnuranContDist class describing one dimensional continuous distribution ; Â CTUnuranDiscrDistTUnuranDiscrDist class for one dimensional discrete distribution ; Â CTUnuranEmpDistTUnuranEmpDist class for describing empiral distributions ; Â CTUnuranMultiContDistTUnuranMultiContDist class describing multi dimensional continuous d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:202340,detect,detector,202340,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['detect'],['detector']
Safety,"ading; 1897 else if (st == 1) {; 1898 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1899 SetOffset(off + len);; 1900 return 1;; 1901 }; 1902 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1903 Seek(off);; 1904 } else {; 1905 // if write cache is active check if data still in write cache; 1906 if (fWritable && fCacheWrite) {; 1907 if (fCacheWrite->ReadBuffer(buf, off, len) == 0) {; 1908 SetOffset(off + len);; 1909 return 1;; 1910 }; 1911 // fOffset might have been changed via TFileCacheWrite::ReadBuffer(), reset it; 1912 SetOffset(off);; 1913 }; 1914 }; 1915 ; 1916 return 0;; 1917}; 1918 ; 1919////////////////////////////////////////////////////////////////////////////////; 1920/// Read the FREE linked list.; 1921///; 1922/// Every file has a linked list (fFree) of free segments.; 1923/// This linked list has been written on the file via WriteFree; 1924/// as a single data record.; 1925 ; 1926void TFile::ReadFree(); 1927{; 1928 // Avoid problem with file corruption.; 1929 if (fNbytesFree < 0 || fNbytesFree > fEND) {; 1930 fNbytesFree = 0;; 1931 return;; 1932 }; 1933 TKey *headerfree = new TKey(fSeekFree, fNbytesFree, this);; 1934 headerfree->ReadFile();; 1935 char *buffer = headerfree->GetBuffer();; 1936 headerfree->ReadKeyBuffer(buffer);; 1937 buffer = headerfree->GetBuffer();; 1938 while (1) {; 1939 TFree *afree = new TFree();; 1940 afree->ReadBuffer(buffer);; 1941 fFree->Add(afree);; 1942 if (afree->GetLast() > fEND) break;; 1943 }; 1944 delete headerfree;; 1945}; 1946 ; 1947////////////////////////////////////////////////////////////////////////////////; 1948/// The TProcessID with number pidf is read from this file.; 1949///; 1950/// If the object is not already entered in the gROOT list, it is added.; 1951 ; 1952TProcessID *TFile::ReadProcessID(UShort_t pidf); 1953{; 1954 TProcessID *pid = nullptr;; 1955 TObjArray *pids = GetListOfProcessIDs();; 1956 if (pidf < pids->GetSize()) pid = (TProcessID *)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:69161,Avoid,Avoid,69161,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['Avoid'],['Avoid']
Safety,"adlener, DESY,; Lorenzo Moneta, CERN/EP-SFT,; Alja Mrak Tadel, UCSD/CMS,; Axel Naumann, CERN/EP-SFT,; Dante Niewenhuis, VU Amsterdam; Luis Antonio Obis Aparicio, University of Zaragoza, Ianna Osborne, Princeton University,; Vincenzo Eduardo Padulano, CERN/EP-SFT,; Danilo Piparo, CERN/EP-SFT,; Fons Rademakers, CERN/IT,; Jonas Rembser, CERN/EP-SFT,; Andrea Rizzi, University of Pisa,; Andre Sailer, CERN/EP-SFT,; Garima Singh, ETH,; Juraj Smiesko, CERN/RCS-PRJ-FC, Pavlo Svirin, National Technical University of Ukraine,; Maciej Szymanski, Argonne,; Christian Tacke, Darmstadt University,; Matevz Tadel, UCSD/CMS,; Alvaro Tolosa Delgado, CERN/RCS-PRJ-FC,; Devajith Valaparambil Sreeramaswamy, CERN/EP-SFT,; Peter Van Gemmeren, Argonne,; Vassil Vassilev, Princeton/CMS,; Wouter Verkerke, NIKHEF/ATLAS, Stefan Wunsch; Deprecation and Removal. The RooFit legacy iterators are deprecated and will be removed in ROOT 6.34 (see section â€œRooFit librariesâ€); Some memory-unsafe RooFit interfaces were removed; Some redundant RooDataSet constructors are deprecated and will be removed in ROOT 6.34. Please use the RooDataSet constructors that take RooFit command arguments instead; ROOT does not longer support Python 2. The minimum required Python version to build ROOT is 3.8.; Support for wildcard imports like from ROOT import * is dropped from PyROOT; Support for external (ie. non-builtin) libAfterImage is now deprecated and it will be removed in next release 6.34.; The TList::TList(TObject*) constructor is deprecated and will be removed in ROOT 6.34; The deprecated TProofOutputList::TProofOutputList(TObject *o) constructor was removed. Core Libraries; The Cling interpreter now relies on LLVM version 16.; I/O Libraries; hadd respects compression settings; Fixed a bug that was previously changing the compression settings to a single digit number instead of the full value (by default 101).; TTree Libraries; Add files from subdirectories with TChain::Add globbing; It is now possible to add file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:3560,unsafe,unsafe,3560,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,2,"['redund', 'unsafe']","['redundant', 'unsafe']"
Safety,"ag(const char* st); static voidTSlave::SetTXSlaveHook(TSlave_t xslavehook); virtual voidTObject::SetUniqueID(UInt_t uid); virtual Int_tSetupServ(Int_t stype, const char* conffile); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTouch(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidFlushSocket(); virtual voidInterrupt(Int_t type); voidTObject::MakeZombie(); virtual Int_tPing(); virtual TObjString*SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); virtual Int_tSendGroupPriority(const char* grp, Int_t priority); virtual voidSetAlias(const char* alias); voidTSlave::SetSocket(TSocket* s); virtual voidTSlave::SetStatus(Int_t st); virtual voidStopProcess(Bool_t abort, Int_t timeout). private:. static Int_tGetProofdProtocol(TSocket* s); voidInit(const char* host, Int_t stype); voidParseBuffer(). Data Members; public:. enum TSlave::ESlaveType { kMaster; kSlave; };; enum TSlave::ESlaveStatus { kInvalid; kActive; kInactive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info obtained from slave); TStringTSlave::fGroupslave's",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXSlave.html:6707,abort,abort,6707,root/html530/TXSlave.html,https://root.cern,https://root.cern/root/html530/TXSlave.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"ageCollection();; 216 static void GarbageCollect(TObject *obj);; 217 static void EmptyGarbageCollection();; 218 ; 219 TIter begin() const;; 220 TIter end() const;; 221 ; 222 ClassDefOverride(TCollection,3) //Collection abstract base class; 223};; 224 ; 225 ; 226//////////////////////////////////////////////////////////////////////////; 227// //; 228// TIter //; 229// //; 230// Iterator wrapper. Type of iterator used depends on type of //; 231// collection. //; 232// //; 233//////////////////////////////////////////////////////////////////////////; 234 ; 235class TIter {; 236 ; 237private:; 238 TIterator *fIterator{nullptr}; //collection iterator; 239 ; 240protected:; 241 TIter() : fIterator(nullptr) { }; 242 ; 243public:; 244 TIter(const TCollection *col, Bool_t dir = kIterForward); 245 : fIterator(col ? col->MakeIterator(dir) : nullptr) { }; 246 TIter(TIterator *it) : fIterator(it) { }; 247 TIter(const TIter &iter);; 248 TIter &operator=(const TIter &rhs);; 249 virtual ~TIter() { SafeDelete(fIterator); }; 250 TObject *operator()() { return Next(); }; 251 TObject *Next() { return fIterator ? fIterator->Next() : nullptr; }; 252 const TCollection *GetCollection() const { return fIterator ? fIterator->GetCollection() : nullptr; }; 253 Option_t *GetOption() const { return fIterator ? fIterator->GetOption() : """"; }; 254 void Reset() { if (fIterator) fIterator->Reset(); }; 255 TIter &operator++() { Next(); return *this; }; 256 Bool_t operator==(const TIter &aIter) const {; 257 if (fIterator == nullptr); 258 return aIter.fIterator == nullptr || **aIter.fIterator == nullptr;; 259 if (aIter.fIterator == nullptr); 260 return fIterator == nullptr || **fIterator == nullptr;; 261 return *fIterator == *aIter.fIterator;; 262 }; 263 Bool_t operator!=(const TIter &aIter) const {; 264 return !(*this == aIter);; 265 }; 266 TIter &operator=(TIterator *iter); 267 {; 268 if (fIterator); 269 delete fIterator;; 270 fIterator = iter;; 271 return *this;; 272 }; 273 TObject *operator*() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h_source.html:9580,Safe,SafeDelete,9580,doc/master/TCollection_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html,1,['Safe'],['SafeDelete']
Safety,"ager->GetNsegments()+1;; Int_t numPoints = n*4;; Int_t numSegs = n*8;; Int_t numPolys = n*4-2;. painter->AddSize3D(numPoints, numSegs, numPolys);. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 48;}. TGeoTubeSeg(); constructors. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. Â» Author: Andrei Gheata 24/10/01 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/base:$Id$ Â» Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeSeg.html:21507,safe,safe,21507,root/html534/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"ager->GetNsegments()+1;; Int_t numPoints = n*4;; Int_t numSegs = n*8;; Int_t numPolys = n*4-2;. painter->AddSize3D(numPoints, numSegs, numPolys);. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 48;}. TGeoTubeSeg(); constructors. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. Â» Author: Andrei Gheata 24/10/01 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/base:$Id$ Â» Last generated: 2015-06-02 16:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoTubeSeg.html:23259,safe,safe,23259,root/html604/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html604/TGeoTubeSeg.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"ager->GetNsegments()+1;; Int_t numPoints = n*4;; Int_t numSegs = n*8;; Int_t numPolys = n*4-2;. painter->AddSize3D(numPoints, numSegs, numPolys);. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 48;}. TGeoTubeSeg(); constructors. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. Â» Author: Andrei Gheata 24/10/01 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/base:$Id$ Â» Last generated: 2015-06-30 15:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTubeSeg.html:23259,safe,safe,23259,root/html602/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html602/TGeoTubeSeg.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"ain thread mutex. void * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method listing the existing threads. void ** Tsd(void* dflt, Int_t k); Static method returning a pointer to thread specific data container; of the calling thread.; k should be between 0 and kMaxUserThreadSlot for user application.; (and between kMaxUserThreadSlot and kMaxThreadSlot for ROOT libraries).; See ROOT::EThreadSlotReservation. void Printf(const char *va_(fmt), ...); Static method providing a thread safe printf. Appends a newline. void ErrorHandler(int level, const char* location, const char* fmt, va_list ap) const; Thread specific error handler function.; It calls the user set error handler in the main thread. void DoError(Int_t level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler. User has to specify the class name as; part of the location, just like for the global Info(), Warning() and; Error() functions. Int_t XARequest(const char* xact, Int_t nb, void** ar, Int_t* iret); Static method used to allow commands to be executed by the main thread. void XAction(); Static method called via the thread timer to execute in the main; thread certain commands. This to avoid sophisticated locking and; possible deadlocking. void SetComment(const char* txt = 0). TThread(const TThread& ). TThread& operator=(const TThread& ). void Delete(Option_t* option = """"); { TObject::Delete(option); }. EPriority GetPriority() const; { return fPriority; }. EState GetState() const; { return fState; }. Long_t GetId() const; { return fId; }. void ps(); { Ps(); }. Â» Author: Fons Rademakers 02/07/97 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/thread:$Id$ Â» Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TThread.html:15849,avoid,avoid,15849,root/html604/TThread.html,https://root.cern,https://root.cern/root/html604/TThread.html,1,['avoid'],['avoid']
Safety,"ain thread mutex. void * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method listing the existing threads. void ** Tsd(void* dflt, Int_t k); Static method returning a pointer to thread specific data container; of the calling thread.; k should be between 0 and kMaxUserThreadSlot for user application.; (and between kMaxUserThreadSlot and kMaxThreadSlot for ROOT libraries).; See ROOT::EThreadSlotReservation. void Printf(const char *va_(fmt), ...); Static method providing a thread safe printf. Appends a newline. void ErrorHandler(int level, const char* location, const char* fmt, va_list ap) const; Thread specific error handler function.; It calls the user set error handler in the main thread. void DoError(Int_t level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler. User has to specify the class name as; part of the location, just like for the global Info(), Warning() and; Error() functions. Int_t XARequest(const char* xact, Int_t nb, void** ar, Int_t* iret); Static method used to allow commands to be executed by the main thread. void XAction(); Static method called via the thread timer to execute in the main; thread certain commands. This to avoid sophisticated locking and; possible deadlocking. void SetComment(const char* txt = 0). TThread(const TThread& ). TThread& operator=(const TThread& ). void Delete(Option_t* option = """"); { TObject::Delete(option); }. EPriority GetPriority() const; { return fPriority; }. EState GetState() const; { return fState; }. Long_t GetId() const; { return fId; }. void ps(); { Ps(); }. Â» Author: Fons Rademakers 02/07/97 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/thread:$Id$ Â» Last generated: 2015-06-30 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TThread.html:15849,avoid,avoid,15849,root/html602/TThread.html,https://root.cern,https://root.cern/root/html602/TThread.html,1,['avoid'],['avoid']
Safety,"ain) ; Â ; virtual voidÂ RemoveExternalFriend (TFriendElement *); Â Removes external friend. ; Â ; virtual voidÂ RemoveFriend (TTree *); Â Remove a friend from the list of friends. ; Â ; virtual voidÂ Reset (Option_t *option=""""); Â Reset baskets, buffers and entries count in all branches and leaves. ; Â ; virtual voidÂ ResetAfterMerge (TFileMergeInfo *); Â Resets the state of this TTree after a merge (keep the customization but forget the data). ; Â ; virtual Long64_tÂ Scan (const char *varexp="""", const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0); Â Loop over tree entries and print entries passing selection. ; Â ; virtual boolÂ SetAlias (const char *aliasName, const char *aliasFormula); Â Set a tree variable alias. ; Â ; virtual voidÂ SetAutoFlush (Long64_t autof=-30000000); Â This function may be called at the start of a program to change the default value for fAutoFlush. ; Â ; virtual voidÂ SetAutoSave (Long64_t autos=-300000000); Â In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point. ; Â ; virtual voidÂ SetBasketSize (const char *bname, Int_t buffsize=16000); Â Set a branch's basket size. ; Â ; template<class T > ; Int_tÂ SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr); Â ; template<class T > ; Int_tÂ SetBranchAddress (const char *bname, T *add, TBranch **ptr=nullptr); Â ; virtual Int_tÂ SetBranchAddress (const char *bname, void *add, TBranch **ptr, TClass *realClass, EDataType datatype, bool isptr); Â Verify the validity of the type of addr before calling SetBranchAddress. ; Â ; virtual Int_tÂ SetBranchAddress (const char *bname, void *add, TBranch **ptr=nullptr); Â Change branch address, dealing with clone trees properly. ; Â ; virtual Int_tÂ SetBranchAddress (const char *bname, void *add, TClass *realClass, EDataType datatype, bool isptr); Â Verify the validity of the type of addr before calling SetBranchAddress. ; Â ; virtual voidÂ SetBranchStatus (const char *bname, bool s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNtuple.html:20015,recover,recover,20015,doc/master/classTNtuple.html,https://root.cern,https://root.cern/doc/master/classTNtuple.html,2,['recover'],['recover']
Safety,"ains(). Bool_t TGeoConeSeg::Contains ; (; const Double_t *Â ; point); const. overridevirtual . Reimplemented from TGeoCone. â—†Â Contains_v(). void TGeoConeSeg::Contains_v ; (; const Double_t *Â ; points, . Bool_t *Â ; inside, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoCone. â—†Â DeclFileName(). static const char * TGeoConeSeg::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 183 of file TGeoCone.h. â—†Â DistancetoPrimitive(). Int_t TGeoConeSeg::DistancetoPrimitive ; (; Int_tÂ ; px, . Int_tÂ ; pyÂ . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoCone. â—†Â DistFromInside(). Double_t TGeoConeSeg::DistFromInside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoCone. â—†Â DistFromInside_v(). void TGeoConeSeg::DistFromInside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoCone. â—†Â DistFromInsideS(). static Double_t TGeoConeSeg::DistFromInsideS ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Double_tÂ ; dz, . Double_tÂ ; rmin1, . Double_tÂ ; rmax1, . Double_tÂ ; rmin2, . Double_tÂ ; rmax2, . Double_tÂ ; c1, . Double_tÂ ; s1, . Double_tÂ ; c2, . Double_tÂ ; s2, . Double_tÂ ; cm, . Double_tÂ ; sm, . Double_tÂ ; cdfiÂ . ). static . â—†Â DistFromOutside(). Double_t TGeoConeSeg::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoCone. â—†Â DistFromOutside_v(). void TGeoConeSeg::DistFromOutside_v ; (; const Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoConeSeg.html:28940,safe,safe,28940,doc/master/classTGeoConeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoConeSeg.html,1,['safe'],['safe']
Safety,"ains(). Bool_t TGeoTubeSeg::Contains ; (; const Double_t *Â ; point); const. overridevirtual . Reimplemented from TGeoTube. â—†Â Contains_v(). void TGeoTubeSeg::Contains_v ; (; const Double_t *Â ; points, . Bool_t *Â ; inside, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoTube. â—†Â DeclFileName(). static const char * TGeoTubeSeg::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 170 of file TGeoTube.h. â—†Â DistancetoPrimitive(). Int_t TGeoTubeSeg::DistancetoPrimitive ; (; Int_tÂ ; px, . Int_tÂ ; pyÂ . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoTube. â—†Â DistFromInside(). Double_t TGeoTubeSeg::DistFromInside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoTube. â—†Â DistFromInside_v(). void TGeoTubeSeg::DistFromInside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoTube. â—†Â DistFromInsideS(). static Double_t TGeoTubeSeg::DistFromInsideS ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Double_tÂ ; rmin, . Double_tÂ ; rmax, . Double_tÂ ; dz, . Double_tÂ ; c1, . Double_tÂ ; s1, . Double_tÂ ; c2, . Double_tÂ ; s2, . Double_tÂ ; cm, . Double_tÂ ; sm, . Double_tÂ ; cdfiÂ . ). static . â—†Â DistFromOutside(). Double_t TGeoTubeSeg::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoTube. â—†Â DistFromOutside_v(). void TGeoTubeSeg::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTubeSeg.html:27840,safe,safe,27840,doc/master/classTGeoTubeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoTubeSeg.html,1,['safe'],['safe']
Safety,"ains_v ; (; const Double_t *Â ; points, . Bool_t *Â ; inside, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DeclFileName(). static const char * TGeoPara::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 85 of file TGeoPara.h. â—†Â DistFromInside(). Double_t TGeoPara::DistFromInside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromInside_v(). void TGeoPara::DistFromInside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside(). Double_t TGeoPara::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside_v(). void TGeoPara::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Divide(). TGeoVolume * TGeoPara::Divide ; (; TGeoVolume *Â ; voldiv, . const char *Â ; divname, . Int_tÂ ; iaxis, . Int_tÂ ; ndiv, . Double_tÂ ; start, . Double_tÂ ; stepÂ . ). overridevirtual . Reimplemented from TGeoBBox. â—†Â GetAlpha(). Double_t TGeoPara::GetAlpha ; (; ); const. inline . Definition at line 69 of file TGeoPara.h. â—†Â GetAxisRange(). Double_t TGeoPara::GetAxisRange ; (; Int_tÂ ; iaxis, . Double_t &Â ; xlo, . Double_t &Â ; xhiÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â GetBoundingCylinder(). void TGeoPara::GetBoundingCylinder ; (; Double_t *Â ; param); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â GetByteCount(). Int_t TGeoPara::GetByteCount ; (; ); co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPara.html:25194,safe,safe,25194,doc/master/classTGeoPara.html,https://root.cern,https://root.cern/doc/master/classTGeoPara.html,1,['safe'],['safe']
Safety,"ains_v ; (; const Double_t *Â ; points, . Bool_t *Â ; inside, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DeclFileName(). static const char * TGeoTrd1::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 78 of file TGeoTrd1.h. â—†Â DistFromInside(). Double_t TGeoTrd1::DistFromInside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromInside_v(). void TGeoTrd1::DistFromInside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside(). Double_t TGeoTrd1::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside_v(). void TGeoTrd1::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Divide(). TGeoVolume * TGeoTrd1::Divide ; (; TGeoVolume *Â ; voldiv, . const char *Â ; divname, . Int_tÂ ; iaxis, . Int_tÂ ; ndiv, . Double_tÂ ; start, . Double_tÂ ; stepÂ . ). overridevirtual . Reimplemented from TGeoBBox. â—†Â GetAxisRange(). Double_t TGeoTrd1::GetAxisRange ; (; Int_tÂ ; iaxis, . Double_t &Â ; xlo, . Double_t &Â ; xhiÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â GetBoundingCylinder(). void TGeoTrd1::GetBoundingCylinder ; (; Double_t *Â ; param); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â GetByteCount(). Int_t TGeoTrd1::GetByteCount ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 57 of file TGeoTrd1.h. â—†Â GetDx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd1.html:24953,safe,safe,24953,doc/master/classTGeoTrd1.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd1.html,1,['safe'],['safe']
Safety,"ains_v ; (; const Double_t *Â ; points, . Bool_t *Â ; inside, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DeclFileName(). static const char * TGeoTrd2::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 80 of file TGeoTrd2.h. â—†Â DistFromInside(). Double_t TGeoTrd2::DistFromInside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromInside_v(). void TGeoTrd2::DistFromInside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside(). Double_t TGeoTrd2::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside_v(). void TGeoTrd2::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Divide(). TGeoVolume * TGeoTrd2::Divide ; (; TGeoVolume *Â ; voldiv, . const char *Â ; divname, . Int_tÂ ; iaxis, . Int_tÂ ; ndiv, . Double_tÂ ; start, . Double_tÂ ; stepÂ . ). overridevirtual . Reimplemented from TGeoBBox. â—†Â GetAxisRange(). Double_t TGeoTrd2::GetAxisRange ; (; Int_tÂ ; iaxis, . Double_t &Â ; xlo, . Double_t &Â ; xhiÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â GetBoundingCylinder(). void TGeoTrd2::GetBoundingCylinder ; (; Double_t *Â ; param); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â GetByteCount(). Int_t TGeoTrd2::GetByteCount ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 58 of file TGeoTrd2.h. â—†Â GetDx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd2.html:25070,safe,safe,25070,doc/master/classTGeoTrd2.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd2.html,1,['safe'],['safe']
Safety,"aint(Option_t* option); Paint method. TGeoSubtraction(); Default constructor. TGeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. Â» Author: Andrei Gheata 30/05/02 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: :$Id: TGeoBoolNode.h 41234 2011-10-06 15:48:52Z agheata $ Â» Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoSubtraction.html:9227,safe,safe,9227,root/html532/TGeoSubtraction.html,https://root.cern,https://root.cern/root/html532/TGeoSubtraction.html,3,"['Safe', 'safe']","['Safety', 'safe', 'safety']"
Safety,"ak;; 2829 case TStreamerInfo::kULong: return TConfiguredAction( Looper::template ReadBasicType<ULong_t>, new TConfiguration(info,i,compinfo,offset) ); break;; 2830 case TStreamerInfo::kULong64: return TConfiguredAction( Looper::template ReadBasicType<ULong64_t>, new TConfiguration(info,i,compinfo,offset) ); break;; 2831 case TStreamerInfo::kBits: return TConfiguredAction( Looper::template ReadAction<TStreamerInfoActions::ReadBasicType<BitsMarker> > , new TBitsConfiguration(info,i,compinfo,offset) ); break;; 2832 case TStreamerInfo::kFloat16: {; 2833 if (element->GetFactor() != 0) {; 2834 return TConfiguredAction( Looper::template ReadAction<ReadBasicType_WithFactor<float> >, new TConfWithFactor(info,i,compinfo,offset,element->GetFactor(),element->GetXmin()) );; 2835 } else {; 2836 Int_t nbits = (Int_t)element->GetXmin();; 2837 if (!nbits) nbits = 12;; 2838 return TConfiguredAction( Looper::template ReadAction<ReadBasicType_NoFactor<float> >, new TConfNoFactor(info,i,compinfo,offset,nbits) );; 2839 }; 2840 break;; 2841 }; 2842 case TStreamerInfo::kDouble32: {; 2843 if (element->GetFactor() != 0) {; 2844 return TConfiguredAction( Looper::template ReadAction<ReadBasicType_WithFactor<double> >, new TConfWithFactor(info,i,compinfo,offset,element->GetFactor(),element->GetXmin()) );; 2845 } else {; 2846 Int_t nbits = (Int_t)element->GetXmin();; 2847 if (!nbits) {; 2848 return TConfiguredAction( Looper::template ReadAction<ConvertBasicType<float,double>::Action >, new TConfiguration(info,i,compinfo,offset) );; 2849 } else {; 2850 return TConfiguredAction( Looper::template ReadAction<ReadBasicType_NoFactor<double> >, new TConfNoFactor(info,i,compinfo,offset,nbits) );; 2851 }; 2852 }; 2853 break;; 2854 }; 2855 case TStreamerInfo::kTNamed: return TConfiguredAction( Looper::template ReadAction<ReadTNamed >, new TConfiguration(info,i,compinfo,offset) ); break;; 2856 // Idea: We should calculate the CanIgnoreTObjectStreamer here and avoid calling the; 2857 // Streamer alltogether.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:122536,avoid,avoid,122536,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ake this embedded canvas the current one. void cd(int subpadnumber); [slot] to make this embedded canvas / pad the current one. void Disconnect(); [slot] Disconnect the Qt widget from TCanvas object before deleting; to avoid the dead lock; one has to set CanvasID = 0 to disconnect things properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void RefreshCB(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent* ); Map the Qt mouse press button event to the ROOT TCanvas events; Mouse events occur when a mouse button is pressed or released inside; a widget or when the mouse cursor is moved. void mouseMoveEvent(QMouseEvent* ); Map the Qt mouse move pointer event to the ROOT TCanvas events; kMouseMotion = 51,; kButton1Motion = 21, kButton2Motion = 22, kButton3Motion = 23, kKeyPress = 24. void mouseReleaseEvent(QMouseEvent* ); Map the Qt mouse button release event to the ROOT TCanvas events; kButton1Up = 11, kButton2Up = 12, kButton3Up = 13. void mouseDoubleClickEvent(QMouseEvent* ); Map the Qt mouse double click button event to the ROOT TCanvas events; kButton1Double = 61, kButton2Double = 62, kButton3Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQtWidget.html:25746,avoid,avoid,25746,root/html602/TQtWidget.html,https://root.cern,https://root.cern/root/html602/TQtWidget.html,2,['avoid'],['avoid']
Safety,"al (TBuffer &ClassDef_StreamerNVirtual_b); Â . Static Public Member Functions; static TClass *Â Class (); Â ; static const char *Â Class_Name (); Â ; static constexpr Version_tÂ Class_Version (); Â ; static const char *Â DeclFileName (); Â ; Â Static Public Member Functions inherited from TF2; static TClass *Â Class (); Â ; static const char *Â Class_Name (); Â ; static constexpr Version_tÂ Class_Version (); Â ; static const char *Â DeclFileName (); Â ; Â Static Public Member Functions inherited from TF1; static voidÂ AbsValue (Bool_t reject=kTRUE); Â Static function: set the fgAbsValue flag. ; Â ; static voidÂ CalcGaussLegendreSamplingPoints (Int_t num, Double_t *x, Double_t *w, Double_t eps=3.0e-11); Â Type safe interface (static method) The number of sampling points are taken from the TGraph. ; Â ; static TClass *Â Class (); Â ; static const char *Â Class_Name (); Â ; static constexpr Version_tÂ Class_Version (); Â ; static const char *Â DeclFileName (); Â ; static Bool_tÂ DefaultAddToGlobalList (Bool_t on=kTRUE); Â Static method to add/avoid to add automatically functions to the global list (gROOT->GetListOfFunctions() ) After having called this static method, all the functions created afterwards will follow the desired behaviour. ; Â ; static Double_tÂ DerivativeError (); Â Static function returning the error of the last call to the of Derivative's functions. ; Â ; static TF1 *Â GetCurrent (); Â Static function returning the current function being processed. ; Â ; static voidÂ InitStandardFunctions (); Â Create the basic function objects. ; Â ; static Bool_tÂ RejectedPoint (); Â See TF1::RejectPoint above. ; Â ; static voidÂ RejectPoint (Bool_t reject=kTRUE); Â Static function to set the global flag to reject points the fgRejectPoint global flag is tested by all fit functions if TRUE the point is not included in the fit. ; Â ; static voidÂ SetCurrent (TF1 *f1); Â Static function setting the current function. ; Â ; Â Static Public Member Functions inherited from TNamed; static TClass *Â Class (); Â ; static const char ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF3.html:42782,avoid,avoid,42782,doc/master/classTF3.html,https://root.cern,https://root.cern/doc/master/classTF3.html,1,['avoid'],['avoid']
Safety,"al . Definition at line 131 of file TAuthenticate.h. Member Function Documentation. â—†Â Authenticate(). Bool_t TAuthenticate::Authenticate ; (; ). Authenticate to remote rootd or proofd server. ; Return kTRUE if authentication succeeded. ; Definition at line 369 of file TAuthenticate.cxx. â—†Â AuthError(). void TAuthenticate::AuthError ; (; const char *Â ; where, . Int_tÂ ; errorÂ . ). static . Print error string depending on error code. ; Definition at line 1261 of file TAuthenticate.cxx. â—†Â AuthExists(). Int_t TAuthenticate::AuthExists ; (; TStringÂ ; username, . Int_tÂ ; method, . const char *Â ; options, . Int_t *Â ; message, . Int_t *Â ; rflag, . CheckSecCtx_tÂ ; checksecctxÂ . ). Check if we have a valid established sec context in memory Retrieves relevant info and negotiates with server. ; options = ""Opt,strlen(username),username.Data()"" message = kROOTD_USER, ... ; Definition at line 2276 of file TAuthenticate.cxx. â—†Â CatchTimeOut(). void TAuthenticate::CatchTimeOut ; (; ). Called in connection with a timer timeout. ; Definition at line 353 of file TAuthenticate.cxx. â—†Â CheckHost(). Bool_t TAuthenticate::CheckHost ; (; const char *Â ; Host, . const char *Â ; hostÂ . ). staticprivate . Check if 'host' matches 'href': this means either equal or ""containing"" it, even with wild cards * in the first field (in the case 'href' is a name, ie not IP address) Returns kTRUE if the two matches. ; Definition at line 1440 of file TAuthenticate.cxx. â—†Â CheckNetrc() [1/2]. Bool_t TAuthenticate::CheckNetrc ; (; TString &Â ; user, . TString &Â ; passwdÂ . ). Try to get user name and passwd from the ~/.rootnetrc or ~/.netrc files. ; For more info see the version with 4 arguments. This version is maintained for backward compatability reasons. ; Definition at line 878 of file TAuthenticate.cxx. â—†Â CheckNetrc() [2/2]. Bool_t TAuthenticate::CheckNetrc ; (; TString &Â ; user, . TString &Â ; passwd, . Bool_t &Â ; pwhash, . Bool_tÂ ; srppwdÂ . ). Try to get user name and passwd from the ~/.rootnetrc or ~/.netrc fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:22269,timeout,timeout,22269,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['timeout'],['timeout']
Safety,"al . ReturnsTClass describing current object ; Reimplemented from TFileStager.; Definition at line 48 of file TNetFileStager.h. â—†Â IsStaged(). Bool_t TNetFileStager::IsStaged ; (; const char *Â ; path). overridevirtual . Check if the file defined by 'path' is ready to be used. ; Reimplemented from TFileStager.; Definition at line 50 of file TNetFileStager.cxx. â—†Â IsValid(). Bool_t TNetFileStager::IsValid ; (; ); const. inlineoverridevirtual . Reimplemented from TFileStager.; Definition at line 44 of file TNetFileStager.h. â—†Â Locate(). Int_t TNetFileStager::Locate ; (; const char *Â ; path, . TString &Â ; endpathÂ . ). overridevirtual . Get actual end-point url for a path Returns 0 in case of success and 1 if any error occured. ; Reimplemented from TFileStager.; Definition at line 101 of file TNetFileStager.cxx. â—†Â Matches(). Bool_t TNetFileStager::Matches ; (; const char *Â ; s). overridevirtual . Returns kTRUE if stager 's' is compatible with current stager. ; Avoids multiple instantiations of the potentially the same TNetSystem. ; Reimplemented from TFileStager.; Definition at line 125 of file TNetFileStager.cxx. â—†Â Print(). void TNetFileStager::Print ; (; Option_t *Â ; option = """"); const. overridevirtual . Print basic info about this stager. ; Reimplemented from TNamed.; Definition at line 92 of file TNetFileStager.cxx. â—†Â Streamer(). void TNetFileStager::Streamer ; (; TBuffer &Â ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileStager. â—†Â StreamerNVirtual(). void TNetFileStager::StreamerNVirtual ; (; TBuffer &Â ; ClassDef_StreamerNVirtual_b). inline . Definition at line 48 of file TNetFileStager.h. Member Data Documentation. â—†Â fPrefix. TString TNetFileStager::fPrefix. private . Definition at line 31 of file TNetFileStager.h. â—†Â fSystem. TNetSystem* TNetFileStager::fSystem. private . Definition at line 32 of file TNetFileStager.h. Libraries for TNetFileStager:. [legend]; The documentation for this class was generated from the following files",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFileStager.html:15134,Avoid,Avoids,15134,doc/master/classTNetFileStager.html,https://root.cern,https://root.cern/doc/master/classTNetFileStager.html,1,['Avoid'],['Avoids']
Safety,"al . See documentation of TDirectoryFile::Get(const char *namecycle) ; Reimplemented from TDirectory.; Definition at line 82 of file TDirectoryFile.h. â—†Â Get() [2/2]. TObject * TDirectoryFile::Get ; (; const char *Â ; namecycle). overridevirtual . Return pointer to object identified by namecycle. ; Properties:; namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. Examples: . Pattern Explanation . foo get object named foo in memory if object is not in memory, try with highest cycle from file . foo;1 get cycle 1 of foo on file . The retrieved object should in principle derive from TObject. If not, the function TDirectoryFile::Get<T> should be called. However, this function will still work for a non-TObject, provided that the calling application cast the return type to the correct type (which is the actual type of the object). The Get<T> Method; The method Get<T> offers better protection and avoids the need for any cast: auto objPtr = directory->Get<MyClass>(""some object"");; if (objPtr) { ... the object exist and inherits from MyClass ... }. Very important note about inheritance; In case the class of this object derives from TObject but not as a first inheritance, one must use dynamic_cast<>().; Example 1 - Normal case:; class MyClass : public TObject, public AnotherClass; then on return, one can adopt a C style cast: auto objPtr = (MyClass*)directory->Get(""some object of MyClass"");; Example 2 - Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do: auto objPtr = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));; Of course, dynamic_cast<> can also be used in the example 1. ; Reimplemented from TDirectory.; Definition at line 937 of file TDirectoryFile.cxx. â—†Â GetBufferSize(). Int_t TDirectoryFile::GetBufferSize ; (; ); const. overridevirtual . Return the buffer size to create new TKeys. ; If the stored fBufferSize is null, the value ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDirectoryFile.html:34241,avoid,avoids,34241,doc/master/classTDirectoryFile.html,https://root.cern,https://root.cern/doc/master/classTDirectoryFile.html,1,['avoid'],['avoids']
Safety,"al Bool_tÂ CompileVariables (); Â Compiles each variable from fTreeDrawArgsParser for the tree fTree. ; Â ; voidÂ FillWeight (); Â Get weight from input list, if any. ; Â ; virtual Bool_tÂ ProcessSingle (Long64_t, Int_t); Â Processes a single variable from an entry. ; Â ; voidÂ SetCanvas (const char *objname); Â Move to a canvas named <name>_canvas; create the canvas if not existing. ; Â ; voidÂ SetDrawAtt (TObject *o); Â Set the drawing attributes from the input list. ; Â ; voidÂ SetError (const char *sub, const char *mesg); Â Sets the error status. ; Â ; Â Protected Member Functions inherited from TObject; virtual voidÂ DoError (int level, const char *location, const char *fmt, va_list va) const; Â Interface to ErrorHandler (protected). ; Â ; voidÂ MakeZombie (); Â . Protected Attributes; TPolyMarker3D *Â fPolyMarker3D; Â ; Â Protected Attributes inherited from TProofDraw; Int_tÂ fDimension; Â ; TStringÂ fInitialExp; Â ; TTreeFormulaManager *Â fManager; Â ; Int_tÂ fMultiplicity; Â ; Bool_tÂ fObjEval; Â ; TTreeFormula *Â fSelect; Â ; TStringÂ fSelection; Â ; TStatus *Â fStatus; Â ; TTree *Â fTree; Â ; TTreeDrawArgsParserÂ fTreeDrawArgsParser; Â ; TTreeFormula *Â fVar [4]; Â ; Double_tÂ fWeight; Â ; Â Protected Attributes inherited from TSelector; EAbortÂ fAbort; Â Abort status. ; Â ; TList *Â fInput; Â List of objects available during processing. ; Â ; TObject *Â fObject; Â ! Current object if processing object (vs. TTree) ; Â ; TStringÂ fOption; Â Option given to TTree::Process. ; Â ; TSelectorList *Â fOutput; Â ! List of objects created during processing ; Â ; Long64_tÂ fStatus; Â Selector status. ; Â . Additional Inherited Members; Â Public Types inherited from TSelector; enum Â EAbort { kContinue; , kAbortProcess; , kAbortFile; }; Â ; Â Public Types inherited from TObject; enum Â { ; Â Â kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ; Â Â kBitMask = 0x00ffffff. }; Â ; enum Â { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); }; Â ; en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawPolyMarker3D.html:13112,Abort,Abort,13112,doc/master/classTProofDrawPolyMarker3D.html,https://root.cern,https://root.cern/doc/master/classTProofDrawPolyMarker3D.html,1,['Abort'],['Abort']
Safety,"al voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Double_tDistToParaboloid(Double_t* point, Double_t* dir, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoParaboloid.html:2449,safe,safe,2449,root/html532/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html532/TGeoParaboloid.html,1,['safe'],['safe']
Safety,"al voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoSphere.html:2235,safe,safe,2235,root/html532/TGeoSphere.html,https://root.cern,https://root.cern/root/html532/TGeoSphere.html,1,['safe'],['safe']
Safety,"al voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoHalfSpace.html:2012,safe,safe,2012,root/html532/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html532/TGeoHalfSpace.html,2,['safe'],['safe']
Safety,"al"". ; Â ; static Bool_tÂ Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr); Â Disconnects signal in object sender from slot_method in object receiver. ; Â . Protected Member Functions; TVirtualProofPlayer *Â MakePlayer (const char *player=0, TSocket *s=0) override; Â Construct a TProofPlayer object. ; Â ; Bool_tÂ StartSlaves (Bool_t) override; Â Start up PROOF submasters. ; Â ; voidÂ ValidateDSet (TDSet *dset) override; Â Validate a TDSet. ; Â ; Â Protected Member Functions inherited from TProof; Â TProof (); Â Protected constructor to be used by classes deriving from TProof (they have to call Init themselves and override StartSlaves appropriately). ; Â ; Int_tÂ AddWorkers (TList *wrks); Â Works on the master node only. ; Â ; Int_tÂ AssertPath (const char *path, Bool_t writable); Â Make sure that 'path' exists; if 'writable' is kTRUE, make also sure that the path is writable. ; Â ; Int_tÂ Collect (ESlaves list=kActive, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE); Â Collect responses from the slave servers. ; Â ; Int_tÂ Collect (TList *slaves, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE); Â Collect responses from the slave servers. ; Â ; TSlave *Â CreateSlave (const char *url, const char *ord, Int_t perf, const char *image, const char *workdir); Â Create a new TSlave of type TSlave::kSlave. ; Â ; TSlave *Â CreateSubmaster (const char *url, const char *ord, const char *image, const char *msd, Int_t nwk=1); Â Create a new TSlave of type TSlave::kMaster. ; Â ; TList *Â GetEnabledPackages () const; Â ; TList *Â GetListOfActiveSlaves () const; Â ; TVirtualProofPlayer *Â GetPlayer () const; Â ; TPluginHandler *Â GetProgressDialog () const; Â ; Int_tÂ GetSandbox (TString &sb, Bool_t assert=kFALSE, const char *rc=0); Â Set the sandbox path from ' Proof.Sandbox' or the alternative var 'rc'. ; Â ; voidÂ HandleLibIncPath (const char *what, Bool_t add, const char *dirs); Â Handle lib, inc search paths modification request. ; Â ; I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofSuperMaster.html:35454,timeout,timeout,35454,doc/master/classTProofSuperMaster.html,https://root.cern,https://root.cern/doc/master/classTProofSuperMaster.html,1,['timeout'],['timeout']
Safety,"alPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TMap*fAssignedPackMap {worker,packetizer} of lat assignement; TVirtualPacketizer*fCurrentPacketizer being currently processed; TList*fPacketizersPacketizers to be processed; TIter*fPacketizersIterIterator on fPacketizers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerMulti(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerMulti(); Destructor. TDSetElement * GetNextPacket(TSlave* wrk, TMessage* r); Get next packet from the current packetizer.; If the current packetizer is done, move to next.; Retun null when all packetizers are done. TVirtualPacketizer * CreatePacketizer(TDSet* dset, TList* wrks, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Create a packetizer for dataset 'dset'; Return null on failure. TPacketizerMulti(). TPacketizerMulti(const TPacketizerMulti& ). void operator=(const TPacketizerMulti& ). Int_t GetEstEntriesProcessed(Float_t f, Long64_t& ent, Long64_t& bytes, Long64_t& calls). Float_t GetCurrentRate(Bool_t& all). void StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE). void MarkBad(TSlave* wrk, TProofProgressStatus* st, TList** missing); { if (fCurrent) fCurrent->MarkBad(wrk, st, missing); return; }. Int_t AddProcessed(TSlave* wrk, TProofProgressStatus* st, Double_t lat, TList** missing). Int_t GetActiveWorkers(); { if (fCurrent) return fCurrent->GetActiveWorkers(); return 0; }. Â» Author: G. Ganis Jan 2010 Â» Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; Â» Last changed: Tue Jun 30 15:23:59 2015 Â» Last generated: 2015-06-30 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizerMulti.html:11406,abort,abort,11406,root/html602/TPacketizerMulti.html,https://root.cern,https://root.cern/root/html602/TPacketizerMulti.html,1,['abort'],['abort']
Safety,"alcAverageResponse() note that 0 offset is used ; Definition at line 1491 of file RuleFitParams.cxx. â—†Â ErrorRateBin(). Double_t TMVA::RuleFitParams::ErrorRateBin ; (; ). protected . Estimates the error rate with the current set of parameters It uses a binary estimate of (y-F*(x)) (y-F*(x)) = (Num of events where sign(F)!=sign(y))/Neve y = {+1 if event is signal, -1 otherwise} â€” NOT USED â€”. ; Definition at line 1008 of file RuleFitParams.cxx. â—†Â ErrorRateReg(). Double_t TMVA::RuleFitParams::ErrorRateReg ; (; ). protected . Estimates the error rate with the current set of parameters This code is pretty messy at the moment. ; Cleanup is needed. â€“ NOT USED â€” ; Definition at line 964 of file RuleFitParams.cxx. â—†Â ErrorRateRoc(). Double_t TMVA::RuleFitParams::ErrorRateRoc ; (; ). protected . Estimates the error rate with the current set of parameters. ; It calculates the area under the bkg rejection vs signal efficiency curve. The value returned is 1-area. This works but is less efficient than calculating the Risk using RiskPerf(). ; Definition at line 1107 of file RuleFitParams.cxx. â—†Â ErrorRateRocRaw(). Double_t TMVA::RuleFitParams::ErrorRateRocRaw ; (; std::vector< Double_t > &Â ; sFsig, . std::vector< Double_t > &Â ; sFbkgÂ . ). protected . Estimates the error rate with the current set of parameters. ; It calculates the area under the bkg rejection vs signal efficiency curve. The value returned is 1-area. ; Definition at line 1042 of file RuleFitParams.cxx. â—†Â ErrorRateRocTst(). void TMVA::RuleFitParams::ErrorRateRocTst ; (; ). protected . Estimates the error rate with the current set of parameters. ; It calculates the area under the bkg rejection vs signal efficiency curve. The value returned is 1-area.; See comment under ErrorRateRoc(). ; Definition at line 1155 of file RuleFitParams.cxx. â—†Â EvaluateAverage(). void TMVA::RuleFitParams::EvaluateAverage ; (; UInt_tÂ ; ind1, . UInt_tÂ ; ind2, . std::vector< Double_t > &Â ; avsel, . std::vector< Double_t > &Â ; avrulÂ . ). protected ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:10709,Risk,Risk,10709,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,2,['Risk'],"['Risk', 'RiskPerf']"
Safety,"aleFactor=1.0, scaleType=ROOT.RooAbsReal.RelativeExpected),; ); ; # Print structure of composite pdf; model.Print(""t""); ; ; # Method 2 - Construct extended components first; # ---------------------------------------------------------------------; ; # Associated nsig/nbkg as expected number of events with sig/bkg; esig = ROOT.RooExtendPdf(""esig"", ""extended signal pdf"", sig, nsig); ebkg = ROOT.RooExtendPdf(""ebkg"", ""extended background pdf"", bkg, nbkg); ; # Sum extended components without coefs; # -------------------------------------------------------------------------; ; # Construct sum of two extended pdf (no coefficients required); model2 = ROOT.RooAddPdf(""model2"", ""(g1+g2)+a"", [ebkg, esig]); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf202_extendedmlfit"", ""rf202_extendedmlfit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); ; c.SaveAs(""rf202_extendedmlfit.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf202__extendedmlfit_8py.html:3853,safe,safe,3853,doc/master/rf202__extendedmlfit_8py.html,https://root.cern,https://root.cern/doc/master/rf202__extendedmlfit_8py.html,1,['safe'],['safe']
Safety,"algorithm implementations ; Â ; TGeoParallelWorld &Â operator= (const TGeoParallelWorld &)=delete; Â ; Â Protected Member Functions inherited from TObject; virtual voidÂ DoError (int level, const char *location, const char *fmt, va_list va) const; Â Interface to ErrorHandler (protected). ; Â ; voidÂ MakeZombie (); Â . Protected Attributes; AccelerationModeÂ fAccMode = AccelerationMode::kVoxelFinder; Â to keep the vector of primitive axis aligned bounding boxes ; Â ; void *Â fBoundingBoxes = nullptr; Â stores bounding boxes serving a quick safety candidates (to be used with the VoxelGrid and SafetyVoxelInfo) ; Â ; void *Â fBVH = nullptr; Â array of physical nodes ; Â ; TGeoManager *Â fGeoManager; Â ; Bool_tÂ fIsClosed; Â ; TGeoPhysicalNode *Â fLastState; Â helper volume ; Â ; TObjArray *Â fPaths; Â ; TObjArray *Â fPhysical; Â Last PN touched. ; Â ; std::vector< unsigned int >Â fSafetyCandidateStore {}; Â A regular 3D cache layer for fast point-based safety lookups. ; Â ; TGeoVoxelGrid< SafetyVoxelInfo > *Â fSafetyVoxelCache; Â BVH helper structure for safety and navigation. ; Â ; Bool_tÂ fUseOverlaps; Â ; TGeoVolume *Â fVolume; Â Closed flag. ; Â ; Â Protected Attributes inherited from TNamed; TStringÂ fName; Â ; TStringÂ fTitle; Â . Private Member Functions; TGeoPhysicalNode *Â FindNextBoundaryBVH (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30); Â Same functionality as TGeoNavigator::FindNextDaughterBoundary for the parallel world. ; Â ; TGeoPhysicalNode *Â FindNextBoundaryLoop (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30); Â Same functionality as TGeoNavigator::FindNextDaughterBoundary for the parallel world in a trivial loop version (for debugging) ; Â ; TGeoPhysicalNode *Â FindNextBoundaryOrig (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30); Â Same functionality as TGeoNavigator::FindNextDaughterBoundary for the parallel world. ; Â ; TGeoPhysicalNode *Â FindNodeBVH (Double_t point[3]); Â Finds physical node containing the point. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:14244,Safe,SafetyVoxelInfo,14244,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,2,"['Safe', 'safe']","['SafetyVoxelInfo', 'safety']"
Safety,"alignment happened. ; Definition at line 198 of file TGeoParallelWorld.cxx. â—†Â ResetOverlaps(). void TGeoParallelWorld::ResetOverlaps ; (; ); const. Reset overlapflag for all volumes in geometry. ; Definition at line 154 of file TGeoParallelWorld.cxx. â—†Â Safety(). Double_t TGeoParallelWorld::Safety ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). inline . Definition at line 118 of file TGeoParallelWorld.h. â—†Â SafetyBVH(). double TGeoParallelWorld::SafetyBVH ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). private . Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ; Definition at line 1027 of file TGeoParallelWorld.cxx. â—†Â SafetyLoop(). Double_t TGeoParallelWorld::SafetyLoop ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). private . Compute safety for the parallel world (trivial loop version for comparison/debugging) ; Definition at line 1207 of file TGeoParallelWorld.cxx. â—†Â SafetyOrig(). Double_t TGeoParallelWorld::SafetyOrig ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). private . Compute safety for the parallel world (original version based on TGeoVoxelFinder) ; Definition at line 1145 of file TGeoParallelWorld.cxx. â—†Â SetAccelerationMode(). void TGeoParallelWorld::SetAccelerationMode ; (; AccelerationMode const &Â ; mode). inline . Definition at line 95 of file TGeoParallelWorld.h. â—†Â SetUseOverlaps(). void TGeoParallelWorld::SetUseOverlaps ; (; Bool_tÂ ; flag). inline . Definition at line 80 of file TGeoParallelWorld.h. â—†Â Streamer(). void TGeoParallelWorld::Streamer ; (; TBuffer &Â ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. â—†Â StreamerNVirtual(). void TGeoParallelWorld::StreamerNVirtual ; (; TBuffer &Â ; ClassDef_StreamerNVirtual_b). inline . Definition at line 184 of file TGeoParallelWorld.h. â—†Â TestVoxelGrid(). void TGeoParallelWorld::TestVoxelGrid ; (; ). private . Definition at line 1425 of file TGeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:26419,Safe,SafetyOrig,26419,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['Safe'],['SafetyOrig']
Safety,"ality conditions and 50 equality conditions .; Enough said about quadratic programming, let's return to our example . Suppose, after a long day of doing physics, you have a look at your investments and realize that an early retirement is not possible, given the returns of your stocks . So what now ? ROOT to the rescue ...; In 1990 Harry Markowitz was awarded the Nobel prize for economics: "" his work provided new tools; for weighing the risks and rewards of different investments and for valuing corporate stocks and bonds"" . In plain English, he developed the tools to balance greed and fear, we want the maximum return with the minimum amount of risk. Our stock portfolio should be at the ""Efficient Frontier"". To quantify better the risk we are willing to take, we define a utility function \( U(x) \). It describes as a function of our total assets \( x \), our ""satisfaction"" . A common choice is \( 1-exp(-k*x) \) (the reason for the exponent will be clear later) . The parameter \( k \) is the risk-aversion factor . For small values of \( k \) the satisfaction is small for small values of \( x \); by increasing \( x \) the satisfaction can still be increased significantly . For large values of \( k \), \( U(x) \) increases rapidly to 1, there is no increase in satisfaction for additional dollars earned .; In summary :; small \( k \) ==> risk-loving investor; large \( k \) ==> risk-averse investor. Suppose we have for nrStocks the historical daily returns \( r = closing_price(n) - closing_price(n-1) \). Define a vector \( x \) of length of \( nrStocks \), which contains the fraction of our money invested in each stock . We can calculate the average daily return \( z \) of our portfolio and its variance using the portfolio covariance Covar :; \( z = r^T x \) and \( var = x^T Covar x \); Assuming that the daily returns have a Normal distribution, \( N(x) \), so will \( z \) with mean \( r^T x \) and variance \( x^T Covar x \); The expected value of the utility function is :",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:2634,risk,risk-aversion,2634,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,1,['risk'],['risk-aversion']
Safety,"alize the gradients in the net to zero. ; Â ; LayerIterator_tÂ LayersBegin (); Â Iterator to the first layer of the net. ; Â ; LayerIterator_tÂ LayersEnd (); Â Iterator to the last layer of the net. ; Â ; Scalar_tÂ Loss (const Matrix_t &Y, const Matrix_t &weights, bool includeRegularization=true) const; Â Evaluate the loss function of the net using the activations that are currently stored in the output layer. ; Â ; Scalar_tÂ Loss (Matrix_t &X, const Matrix_t &Y, const Matrix_t &weights, bool applyDropout=false, bool includeRegularization=true); Â Propagate the input batch X through the net and evaluate the error function for the resulting activations of the output layer. ; Â ; voidÂ Prediction (Matrix_t &Y_hat, EOutputFunction f) const; Â Compute the neural network prediction obtained from applying the output function f to the activation of the last layer in the network. ; Â ; voidÂ Prediction (Matrix_t &Y_hat, Matrix_t &X, EOutputFunction f); Â Compute the neural network prediction obtained from forwarding the batch X through the neural network and applying the output function f to the activation of the last layer in the network. ; Â ; voidÂ Print (); Â ; voidÂ SetBatchSize (size_t batchSize); Â ; voidÂ SetDropoutProbabilities (const std::vector< Double_t > &probabilities); Â ; voidÂ SetInputWidth (size_t inputWidth); Â ; voidÂ SetLossFunction (ELossFunction J); Â ; voidÂ SetRegularization (ERegularization R); Â ; voidÂ SetWeightDecay (Scalar_t weightDecay); Â . Private Attributes; size_tÂ fBatchSize; Â Batch size for training and evaluation of the Network. ; Â ; Matrix_tÂ fDummy; Â Empty matrix for last step in back propagation. ; Â ; size_tÂ fInputWidth; Â Number of features in a single input event. ; Â ; ELossFunctionÂ fJ; Â The loss function of the network. ; Â ; std::vector< Layer_t >Â fLayers; Â Layers in the network. ; Â ; ERegularizationÂ fR; Â The regularization used for the network. ; Â ; Scalar_tÂ fWeightDecay; Â The weight decay factor. ; Â . #include <TMVA/DNN/Net.h>; Member Typedef Documentation. â—†Â Laye",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TNet.html:4272,Predict,Prediction,4272,doc/master/classTMVA_1_1DNN_1_1TNet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TNet.html,2,"['Predict', 'predict']","['Prediction', 'prediction']"
Safety,"alized to some positive value. A thread may ask to wait on a semaphore in which case the thread blocks until the value of the semaphore is positive. At that time the semaphore count is decremented and the thread continues. When a thread releases semaphore, the semaphore count is incremented. Counting semaphores are useful for coordinating access to a limited pool of some resource.; Readers/Writer Lock - a multiple-reader, single-writer lock is one that allows simultaneous read access by many threads while restricting write access to only one thread at a time. When any thread holds the lock for reading, other threads can also acquire the lock reading. If one thread holds the lock for writing, or is waiting to acquire the lock for writing, other threads must wait to acquire the lock for either reading or writing.; Use a condition variable in conjunction with a mutex lock to automatically block threads until a particular condition is true.; Multithread Safe Levels - a possible classification scheme to describe thread-safety of libraries:. All public and protected functions are reentrant. The library provides protection against multiple threads trying to modify static and global data used within a library. The developer must explicitly lock access to objects shared between threads. No other thread can write to a locked object unless it is unlocked. The developer needs to lock local objects. The spirit, if not the letter of this definition, requires the user of the library only to be familiar with the semantic content of the objects in use. Locking access to objects that are being shared due to extra-semantic details of implementation (for example, copy-on-write) should remain the responsibility of the library.; All public and protected functions are reentrant. The library provides protection against multiple threads trying to modify static and global data used within the library. The preferred way of providing this protection is to use mutex locks. The library also locks",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1123024,Safe,Safe,1123024,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['Safe', 'safe']","['Safe', 'safety']"
Safety,"all required tasks in its local reference system. Note that the manager class handles global queries related to geometry. However, shape-related queries might be sometimes useful:; Bool_t TGeoShape::Contains(Double_t *point[3]);; The method above returns kTRUE if the point *point is actually inside the shape. The point has to be defined in the local shape reference. For instance, for a box having DX,DY and DZhalf-lengths a point will be considered inside if:; -DX <= point[0] <= DX; -DY <= point[1] <= DY; -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; The method computes the distance to exiting a shape from a given point inside, along a given direction. This direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact = 0computes only safe distance and fill it at the location given by SAFE;; iact = 1a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;; iact = 2computes both safe distance and distance to exiting, ignoring the proposed step;; iact > 2computes only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; This method computes the distance to entering a shape from a given point outside. It acts in the same way as the previous method.; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; This computes the maximum shift of a point in any direction that does not change its inside/outsidestate (does not cross shape boundaries). The state of the point has to be properly supplied.; Double_t *TGeoShape::ComputeNor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:922661,safe,safe,922661,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['SAFE', 'safe']","['SAFE', 'safe']"
Safety,"all=0)Read all leaves of entry and return total number of bytes read.Definition TBranch.cxx:1706; TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TF1::GetHistogramvirtual TH1 * GetHistogram() constReturn a pointer to the histogram used to visualise the function Note that this histogram is managed ...Definition TF1.cxx:1584; TF1::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF1.cxx:1333; TF1::SetParametervirtual void SetParameter(Int_t param, Double_t value)Definition TF1.h:667; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TGondzioSolverDerived class of TQpSolverBase implementing Gondzio-correction version of Mehrotra's original predict...Definition TGondzioSolver.h:57; TGondzioSolver::SolveInt_t Solve(TQpDataBase *prob, TQpVar *iterate, TQpResidual *resid) overrideSolve the quadratic programming problem as formulated through prob, store the final solution in itera...Definition TGondzioSolver.cxx:129; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::SetBarOffsetvirtual void SetBarOffset(Float_t offset=0.25)Set the bar offset as fraction of the bin width for drawing mode ""B"".Definition TH1.h:364; TH1::SetXTitlevirtual void SetXTitle(const char *title)Definition TH1.h:419; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-11",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:16182,predict,predict,16182,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,1,['predict'],['predict']
Safety,"allelWorld.cxx. â—†Â SetAccelerationMode(). void TGeoParallelWorld::SetAccelerationMode ; (; AccelerationMode const &Â ; mode). inline . Definition at line 95 of file TGeoParallelWorld.h. â—†Â SetUseOverlaps(). void TGeoParallelWorld::SetUseOverlaps ; (; Bool_tÂ ; flag). inline . Definition at line 80 of file TGeoParallelWorld.h. â—†Â Streamer(). void TGeoParallelWorld::Streamer ; (; TBuffer &Â ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. â—†Â StreamerNVirtual(). void TGeoParallelWorld::StreamerNVirtual ; (; TBuffer &Â ; ClassDef_StreamerNVirtual_b). inline . Definition at line 184 of file TGeoParallelWorld.h. â—†Â TestVoxelGrid(). void TGeoParallelWorld::TestVoxelGrid ; (; ). private . Definition at line 1425 of file TGeoParallelWorld.cxx. â—†Â VoxelSafety(). double TGeoParallelWorld::VoxelSafety ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). private . Compute safety for the parallel world used BVH structure with addiditional on-the-fly 3D grid/voxel caching â€”> essentially an O(1) algorithm !) ; Definition at line 944 of file TGeoParallelWorld.cxx. Member Data Documentation. â—†Â fAccMode. AccelerationMode TGeoParallelWorld::fAccMode = AccelerationMode::kVoxelFinder. protected . to keep the vector of primitive axis aligned bounding boxes ; Definition at line 55 of file TGeoParallelWorld.h. â—†Â fBoundingBoxes. void* TGeoParallelWorld::fBoundingBoxes = nullptr. protected . stores bounding boxes serving a quick safety candidates (to be used with the VoxelGrid and SafetyVoxelInfo) ; Definition at line 54 of file TGeoParallelWorld.h. â—†Â fBVH. void* TGeoParallelWorld::fBVH = nullptr. protected . array of physical nodes ; Definition at line 49 of file TGeoParallelWorld.h. â—†Â fGeoManager. TGeoManager* TGeoParallelWorld::fGeoManager. protected . Definition at line 41 of file TGeoParallelWorld.h. â—†Â fIsClosed. Bool_t TGeoParallelWorld::fIsClosed. protected . Definition at line 44 of file TGeoParallelWorld.h. â—†Â fLastState. TGeoPhysicalNode* TGeoPa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:27575,safe,safety,27575,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['safe'],['safety']
Safety,"alls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnixSystem.html:23536,timeout,timeout,23536,root/html602/TUnixSystem.html,https://root.cern,https://root.cern/root/html602/TUnixSystem.html,2,['timeout'],['timeout']
Safety,"alls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:23152,timeout,timeout,23152,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,1,['timeout'],['timeout']
Safety,"alls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if childs have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:22814,timeout,timeout,22814,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,3,['timeout'],['timeout']
Safety,"already retrieved. If ""L"" is specified, ""A"" is ignored. ""F"" show all details available about queries ""H"" print help menu Default """" ; Definition at line 2165 of file TProof.cxx. â—†Â ShowStagingStatusDataSet(). void TProof::ShowStagingStatusDataSet ; (; const char *Â ; dataset, . const char *Â ; optStr = ""filter:SsCc""Â . ). virtual . Like GetStagingStatusDataSet, but displays results immediately. ; Definition at line 11116 of file TProof.cxx. â—†Â SlaveStartupThread(). static void * TProof::SlaveStartupThread ; (; void *Â ; arg). staticprotected . â—†Â StartSlaves(). Bool_t TProof::StartSlaves ; (; Bool_tÂ ; attach = kFALSE). protectedvirtual . Start up PROOF slaves. ; Reimplemented in TProofCondor, and TProofSuperMaster.; Definition at line 1660 of file TProof.cxx. â—†Â StartupMessage(). void TProof::StartupMessage ; (; const char *Â ; msg, . Bool_tÂ ; status, . Int_tÂ ; done, . Int_tÂ ; totalÂ . ). Send startup message. ; Definition at line 9312 of file TProof.cxx. â—†Â StopProcess(). void TProof::StopProcess ; (; Bool_tÂ ; abort, . Int_tÂ ; timeout = -1Â . ). Send STOPPROCESS message to master and workers. ; Definition at line 6224 of file TProof.cxx. â—†Â Streamer(). void TProof::Streamer ; (; TBuffer &Â ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TNamed.; Reimplemented in TProofCondor, TProofLite, and TProofSuperMaster. â—†Â StreamerNVirtual(). void TProof::StreamerNVirtual ; (; TBuffer &Â ; ClassDef_StreamerNVirtual_b). inline . Definition at line 1073 of file TProof.h. â—†Â SystemCmd(). void TProof::SystemCmd ; (; const char *Â ; cmd, . Int_tÂ ; fdoutÂ . ). staticprotected . Exec system command 'cmd'. If fdout > -1, append the output to fdout. ; Definition at line 7735 of file TProof.cxx. â—†Â TerminateWorker() [1/2]. void TProof::TerminateWorker ; (; const char *Â ; ord). private . Ask an active worker 'ord' to terminate, i.e. to shutdown. ; Definition at line 4720 of file TProof.cxx. â—†Â TerminateWorker() [2/2]. void TProof::TerminateWorker ; (; TSlave *Â ; wrk). pri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:152737,abort,abort,152737,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['abort'],['abort']
Safety,"als sig, Bool_t ignore = kTRUE); If ignr is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescript",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:22613,timeout,timeout,22613,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,1,['timeout'],['timeout']
Safety,"als Â» TMVA tutorials. Detailed Description; This macro provides an example of using a trained model with Keras and make inference using SOFIE with the RSofieReader class This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model ; Execute in this order: root TMVA_Higgs_Classification.C; root TMVA_SOFIE_RSofieReader.C; TMVA_Higgs_ClassificationDefinition TMVA_Higgs_Classification.py:1; ; using namespace TMVA::Experimental;; ; void TMVA_SOFIE_RSofieReader(){; ; RSofieReader model(""Higgs_trained_model.h5"");; // for debugging; //RSofieReader model(""Higgs_trained_model.h5"", {}, true);; ; // the input shape for this model is a tensor with shape (1,7); ; std::vector<float> input = {0.1,0.2,0.3,0.4,0.5,0.6,0.7};; ; // predict model on a single event (takes a std::vector<float>); ; auto output = model.Compute(input);; ; std::cout << ""Event prediction = "" << output[0] << std::endl;; ; // predict model now on a input file using RDataFrame; ; std::string inputFileName = ""Higgs_data.root"";; std::string inputFile = ""http://root.cern.ch/files/"" + inputFileName;; ; ; ROOT::RDataFrame df1(""sig_tree"", inputFile);; ; auto h1 = df1.Define(""DNN_Values"", Compute<7, float>(model),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Define(""y"",""DNN_Values[0]""); .Histo1D({""h_sig"", """", 100, 0, 1}, ""y"");; ; ROOT::RDataFrame df2(""bkg_tree"", inputFile);; auto h2 = df2.Define(""DNN_Values"", Compute<7, float>(model),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Define(""y"",""DNN_Values[0]""); .Histo1D({""h_bkg"", """", 100, 0, 1}, ""y"");; ; h1->SetLineColor(kRed);; h2->SetLineColor(kBlue);; ; auto c1 = new TCanvas();; gStyle->SetOptStat(0);; ; h2->DrawClone();; h1->DrawClone(""SAME"");; c1->BuildLegend();; ; }; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__RSofieReader_8C.html:1141,predict,prediction,1141,doc/master/TMVA__SOFIE__RSofieReader_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RSofieReader_8C.html,2,['predict'],"['predict', 'prediction']"
Safety,"alty(). Double_t TMVA::RuleFitParams::Penalty ; (; ); const. This is the ""lasso"" penalty To be used for regression. ; â€” NOT USED â€” ; Definition at line 356 of file RuleFitParams.cxx. â—†Â Risk() [1/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_tÂ ; ind1, . UInt_tÂ ; ind2, . Double_tÂ ; neffÂ . ); const. risk assessment ; Definition at line 314 of file RuleFitParams.cxx. â—†Â Risk() [2/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_tÂ ; ind1, . UInt_tÂ ; ind2, . Double_tÂ ; neff, . UInt_tÂ ; itauÂ . ); const. risk assessment for tau model <itau> ; Definition at line 334 of file RuleFitParams.cxx. â—†Â RiskPath(). Double_t TMVA::RuleFitParams::RiskPath ; (; ); const. inline . Definition at line 108 of file RuleFitParams.h. â—†Â RiskPerf() [1/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; ); const. inline . Definition at line 109 of file RuleFitParams.h. â—†Â RiskPerf() [2/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; UInt_tÂ ; itau); const. inline . Definition at line 110 of file RuleFitParams.h. â—†Â RiskPerfTst(). UInt_t TMVA::RuleFitParams::RiskPerfTst ; (; ). Estimates the error rate with the current set of parameters. ; using the <Perf> subsample. Return the tau index giving the lowest error ; Definition at line 1201 of file RuleFitParams.cxx. â—†Â SetGDErrScale(). void TMVA::RuleFitParams::SetGDErrScale ; (; Double_tÂ ; s). inline . Definition at line 85 of file RuleFitParams.h. â—†Â SetGDNPathSteps(). void TMVA::RuleFitParams::SetGDNPathSteps ; (; Int_tÂ ; np). inline . Definition at line 65 of file RuleFitParams.h. â—†Â SetGDPathStep(). void TMVA::RuleFitParams::SetGDPathStep ; (; Double_tÂ ; s). inline . Definition at line 68 of file RuleFitParams.h. â—†Â SetGDTau(). void TMVA::RuleFitParams::SetGDTau ; (; Double_tÂ ; t). inline . Definition at line 82 of file RuleFitParams.h. â—†Â SetGDTauPrec(). void TMVA::RuleFitParams::SetGDTauPrec ; (; Double_tÂ ; p). inline . Definition at line 86 of file RuleFitParams.h. â—†Â SetGDTauRange(). void TMVA::RuleFitParams::SetGDTauRange ; (; Double_tÂ ; t0, . Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:17261,Risk,RiskPerfTst,17261,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['Risk'],['RiskPerfTst']
Safety,"alÂ . ); const. virtual . Convert a vector from mother reference to local reference system. ; Definition at line 576 of file TGeoNode.cxx. â—†Â MayOverlap(). Bool_t TGeoNode::MayOverlap ; (; Int_tÂ ; iother); const. Check the overlab between the bounding box of the node overlaps with the one the brother with index IOTHER. ; Definition at line 555 of file TGeoNode.cxx. â—†Â operator=(). TGeoNode & TGeoNode::operator= ; (; const TGeoNode &Â ; ). privatedelete . â—†Â Paint(). void TGeoNode::Paint ; (; Option_t *Â ; option = """"). overridevirtual . Paint this node and its content according to visualization settings. ; Reimplemented from TObject.; Definition at line 605 of file TGeoNode.cxx. â—†Â PrintCandidates(). void TGeoNode::PrintCandidates ; (; ); const. print daughters candidates for containing current point ; Definition at line 616 of file TGeoNode.cxx. â—†Â PrintOverlaps(). void TGeoNode::PrintOverlaps ; (; ); const. print possible overlapping nodes ; Definition at line 667 of file TGeoNode.cxx. â—†Â Safety(). Double_t TGeoNode::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. computes the closest distance from given point to this shape ; Definition at line 684 of file TGeoNode.cxx. â—†Â SaveAttributes(). void TGeoNode::SaveAttributes ; (; std::ostream &Â ; out). save attributes for this node ; Definition at line 439 of file TGeoNode.cxx. â—†Â SetAllInvisible(). void TGeoNode::SetAllInvisible ; (; ). inline . Definition at line 124 of file TGeoNode.h. â—†Â SetCloned(). void TGeoNode::SetCloned ; (; Bool_tÂ ; flag = kTRUE). inline . Definition at line 119 of file TGeoNode.h. â—†Â SetCurrentPoint(). void TGeoNode::SetCurrentPoint ; (; Double_tÂ ; x, . Double_tÂ ; y, . Double_tÂ ; zÂ . ). inline . Definition at line 116 of file TGeoNode.h. â—†Â SetFWExtension(). void TGeoNode::SetFWExtension ; (; TGeoExtension *Â ; ext). Connect framework defined extension to the node. ; The node ""grabs"" a copy, so the original object can be released by the producer. Release the previously connected ext",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNode.html:32917,Safe,Safety,32917,doc/master/classTGeoNode.html,https://root.cern,https://root.cern/doc/master/classTGeoNode.html,1,['Safe'],['Safety']
Safety,"am[in] xbins array of low-edges for each bin.; 121/// This is an array of type double and size nbinsx+1; 122/// \param[in] nbinsy number of bins along the Y axis; 123/// \param[in] ylow low edge of the Y axis first bin; 124/// \param[in] yup upper edge of the Y axis last bin (not included in last bin); 125 ; 126TH2::TH2(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 127 ,Int_t nbinsy,Double_t ylow,Double_t yup); 128 :TH1(name,title,nbinsx,xbins); 129{; 130 fDimension = 2;; 131 fScalefactor = 1;; 132 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 133 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 134 fYaxis.Set(nbinsy,ylow,yup);; 135 fNcells = fNcells*(nbinsy+2); // fNCells is set in the TH1 constructor; 136}; 137 ; 138 ; 139////////////////////////////////////////////////////////////////////////////////; 140/// Constructor for Double_t variable bin size (along Y axis) 2-D histograms.; 141///; 142/// \param[in] name name of histogram (avoid blanks); 143/// \param[in] title histogram title.; 144/// If title is of the form `stringt;stringx;stringy;stringz`; 145/// the histogram title is set to `stringt`,; 146/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 147/// \param[in] nbinsx number of bins along the X axis; 148/// \param[in] xlow low edge of the X axis first bin; 149/// \param[in] xup upper edge of the X axis last bin (not included in last bin); 150/// \param[in] nbinsy number of bins; 151/// \param[in] ybins array of low-edges for each bin.; 152/// This is an array of type double and size nbinsy+1; 153 ; 154TH2::TH2(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 155 ,Int_t nbinsy,const Double_t *ybins); 156 :TH1(name,title,nbinsx,xlow,xup); 157{; 158 fDimension = 2;; 159 fScalefactor = 1;; 160 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 161 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 162 if (ybins) fYaxis.Set(nbinsy,ybins);; 163 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:6399,avoid,avoid,6399,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ame = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. Int_t setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Setter function without integration set. Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. void insertObjectHook(RooAbsCacheElement& ); Interface function to perform post-insert operations on cached object. template <> void RooCacheManager<RooAbsCacheElement> ShowMembers(TMemberInspector& insp, char* parent); needed to avoid 'specialization after instantiation' problem in gcc. Â» Last changed: Mon Dec 7 13:47:00 2009 Â» Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCacheManager_RooAbsCacheElement_.html:5238,avoid,avoid,5238,root/html526/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html526/RooCacheManager_RooAbsCacheElement_.html,1,['avoid'],['avoid']
Safety,"ame space prefix operator to access the workspace contents; #; # d = w.model.generate(w.x,1000); # r = w.model.fitTo(*d); ; # use normal workspace methods; model = w[""model""]; x = w[""x""]; ; d = model.generate({x}, 1000); r = model.fitTo(d, PrintLevel=-1); ; # old syntax to access the variable x; # frame = w.x.frame(); ; frame = x.frame(); d.plotOn(frame); ; # OLD syntax to omit x.; # NB: The 'w.' prefix can be omitted if namespace w is imported in local namespace; # in the usual C++ way; #; # using namespace w; # model.plotOn(frame); # model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # correct syntax; bkg = w[""bkg""]; model.plotOn(frame); model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf509_wsinteractive"", ""rf509_wsinteractive"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf509_wsinteractive.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:Object",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf509__wsinteractive_8py.html:3323,safe,safe,3323,doc/master/rf509__wsinteractive_8py.html,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html,1,['safe'],['safe']
Safety,"ame); static void*FindDynLib(const char* lib); TSystem*TSystem::FindHelper(const char* path, void* dirptr = 0); virtual const char*GetLinkedLibraries(); voidTObject::MakeZombie(); static intReadUtmpFile(); static void*SearchUtmpEntry(int nentries, const char* tty); static const char*TSystem::StripOffProto(const char* path, const char* proto); static Func_tUnixDynFindSymbol(const char* lib, const char* entry); static voidUnixDynListLibs(const char* lib = """"); static voidUnixDynListSymbols(const char* lib, const char* re = """"); static intUnixDynLoad(const char* lib); static voidUnixDynUnload(const char* lib); static intUnixFilestat(const char* path, FileStat_t& buf); static intUnixFSstat(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); static const char*UnixGetdirentry(void* dir); static const char*UnixHomedirectory(const char* user = 0); static voidUnixIgnoreSignal(ESignals sig, Bool_t ignore); static intUnixMakedir(const char* name); static Long64_tUnixNow(); static void*UnixOpendir(const char* name); static intUnixRecv(int sock, void* buf, int len, int flag); static voidUnixResetSignal(ESignals sig); static voidUnixResetSignals(); static intUnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); static intUnixSend(int sock, const void* buf, int len, int flag); static intUnixSetitimer(Long_t ms); static voidUnixSigAlarmInterruptsSyscalls(Bool_t set); static voidUnixSignal(ESignals sig, void* h); static const char*UnixSigname(ESignals sig); static intUnixTcpConnect(const char* hostname, int port, int tcpwindowsize); static intUnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize); static intUnixUdpConnect(const char* hostname, int port); static intUnixUdpService(int port, int backlog); static intUnixUnixConnect(int port); static intUnixUnixConnect(const char* path); static intUnixUnixService(int port, int backlog); static intUnixUnixService(const char* sockpath, int backlog); static intUnixWaitchild().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TUnixSystem.html:15863,timeout,timeout,15863,root/html532/TUnixSystem.html,https://root.cern,https://root.cern/root/html532/TUnixSystem.html,1,['timeout'],['timeout']
Safety,"ame, . char *Â ; dst, . size_tÂ ; dst_sizeÂ . ). Definition at line 7158 of file civetweb.c. â—†Â mg_get_current_time_ns(). static uint64_t mg_get_current_time_ns ; (; voidÂ ; ). static . Definition at line 1668 of file civetweb.c. â—†Â mg_get_header(). const char * mg_get_header ; (; const struct mg_connection *Â ; conn, . const char *Â ; nameÂ . ). Definition at line 3801 of file civetweb.c. â—†Â mg_get_option(). const char * mg_get_option ; (; const struct mg_context *Â ; ctx, . const char *Â ; nameÂ . ). Definition at line 3137 of file civetweb.c. â—†Â mg_get_request_info(). const struct mg_request_info * mg_get_request_info ; (; const struct mg_connection *Â ; conn). Definition at line 3487 of file civetweb.c. â—†Â mg_get_request_link(). int mg_get_request_link ; (; const struct mg_connection *Â ; conn, . char *Â ; buf, . size_tÂ ; buflenÂ . ). Definition at line 3688 of file civetweb.c. â—†Â mg_get_response(). int mg_get_response ; (; struct mg_connection *Â ; conn, . char *Â ; ebuf, . size_tÂ ; ebuf_len, . intÂ ; timeoutÂ . ). Definition at line 17979 of file civetweb.c. â—†Â mg_get_response_code_text(). const char * mg_get_response_code_text ; (; const struct mg_connection *Â ; conn, . intÂ ; response_codeÂ . ). Definition at line 4151 of file civetweb.c. â—†Â mg_get_response_info(). const struct mg_response_info * mg_get_response_info ; (; const struct mg_connection *Â ; conn). Definition at line 3527 of file civetweb.c. â—†Â mg_get_server_ports(). int mg_get_server_ports ; (; const struct mg_context *Â ; ctx, . intÂ ; size, . struct mg_server_port *Â ; portsÂ . ). Definition at line 3212 of file civetweb.c. â—†Â mg_get_system_info(). int mg_get_system_info ; (; char *Â ; buffer, . intÂ ; buflenÂ . ). Definition at line 20578 of file civetweb.c. â—†Â mg_get_thread_pointer(). void * mg_get_thread_pointer ; (; const struct mg_connection *Â ; conn). Definition at line 3173 of file civetweb.c. â—†Â mg_get_user_connection_data(). void * mg_get_user_connection_data ; (; const struct mg_connection *Â ; conn). Definition at line 320",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c.html:64928,timeout,timeout,64928,doc/master/civetweb_8c.html,https://root.cern,https://root.cern/doc/master/civetweb_8c.html,1,['timeout'],['timeout']
Safety,"ame, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this torus shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; Create a shape fitting the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetTorusDimensions(Double_t r, Double_t rmin, Double_t rmax, Double_t phi1, Double_t dphi); Set torus dimensions. void SetDimensions(Double_t* param); Set torus dimensions starting from a list. void SetPoints(Double_t* points) const; Create torus mesh points. void SetPoints(Float_t* points) const; Create torus mesh points. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if (!painter) return;; Int_t n = gGeoManager->GetNsegments()+1;; Int_t numPoints = n*(n-1);; Int_t numSegs = (2*n-1)*(n-1);; Int_t numPolys = (n-1)*(n-1);. Bool_t hasrmin = (fRmin>0)?kTRUE:kFALSE;; Bool_t hasphi = (fDphi<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTorus.html:15742,Safe,Safety,15742,root/html534/TGeoTorus.html,https://root.cern,https://root.cern/root/html534/TGeoTorus.html,3,['Safe'],['Safety']
Safety,"amed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoBBox::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoBBox::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static TEveGeoPolyShape*Construct(TGeoCompositeShape* cshp, Int_t n_seg); virtual Bool_tTGeoBBox::Contains(Double_t* point) const; static Bool_tTGeoBBox::Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTGeoBBox::DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoBBox::DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual Double_tTGeoBBox::DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoBBox::DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*TGeoBBox::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveGeoPolyShape.html:1959,safe,safe,1959,root/html532/TEveGeoPolyShape.html,https://root.cern,https://root.cern/root/html532/TEveGeoPolyShape.html,1,['safe'],['safe']
Safety,"amed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTProof::ShowCache(Bool_t all = kFALSE); voidTProof::ShowData(); voidTProof::ShowDataSet(const char* dataset = """", const char* opt = ""M""); virtual voidTProof::ShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidTProof::ShowDataSets(const char* uri = """", const char* optStr = """"); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tTProof::VerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofCondor.html:17305,abort,abort,17305,root/html528/TProofCondor.html,https://root.cern,https://root.cern/root/html528/TProofCondor.html,2,['abort'],['abort']
Safety,"amerInfo) ; Definition at line 3605 of file TFile.cxx. â—†Â Recover(). Int_t TFile::Recover ; (; ). virtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2048 of file TFile.cxx. â—†Â ReOpen(). Int_t TFile::ReOpen ; (; Option_t *Â ; mode). virtual . Reopen a file with a different access mode. ; For example, it is possible to change from READ to UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the mode argument can be either ""READ"" or ""UPDATE"". The method returns 0 in case the mode was successfully modified, 1 in case the mode did not change (was already as requested or w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:89661,recover,recovered,89661,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['recover'],['recovered']
Safety,"amerNVirtual(). void TThread::StreamerNVirtual ; (; TBuffer &Â ; ClassDef_StreamerNVirtual_b). inline . Definition at line 180 of file TThread.h. â—†Â TryLock(). Int_t TThread::TryLock ; (; ). static . Static method to try to lock the main thread mutex. ; Definition at line 780 of file TThread.cxx. â—†Â Tsd(). void ** TThread::Tsd ; (; void *Â ; dflt, . Int_tÂ ; kÂ . ). static . Static method returning a pointer to thread specific data container of the calling thread. ; k should be between 0 and kMaxUserThreadSlot for user application. (and between kMaxUserThreadSlot and kMaxThreadSlot for ROOT libraries). See ROOT::EThreadSlotReservation ; Definition at line 894 of file TThread.cxx. â—†Â UnLock(). Int_t TThread::UnLock ; (; ). static . Static method to unlock the main thread mutex. ; Definition at line 788 of file TThread.cxx. â—†Â XAction(). void TThread::XAction ; (; ). static . Static method called via the thread timer to execute in the main thread certain commands. ; This to avoid sophisticated locking and possible deadlocking. ; Definition at line 1073 of file TThread.cxx. â—†Â XARequest(). Int_t TThread::XARequest ; (; const char *Â ; xact, . Int_tÂ ; nb, . void **Â ; ar, . Int_t *Â ; iretÂ . ). staticprivate . Static method used to allow commands to be executed by the main thread. ; Definition at line 1023 of file TThread.cxx. Friends And Related Symbol Documentation. â—†Â TJoinHelper. friend class TJoinHelper. friend . Definition at line 48 of file TThread.h. â—†Â TPosixThread. friend class TPosixThread. friend . Definition at line 43 of file TThread.h. â—†Â TThreadCleaner. friend class TThreadCleaner. friend . Definition at line 45 of file TThread.h. â—†Â TThreadImp. friend class TThreadImp. friend . Definition at line 42 of file TThread.h. â—†Â TThreadTearDownGuard. friend class TThreadTearDownGuard. friend . Definition at line 47 of file TThread.h. â—†Â TThreadTimer. friend class TThreadTimer. friend . Definition at line 44 of file TThread.h. â—†Â TWin32Thread. friend class TWin32Thread. friend . D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTThread.html:30747,avoid,avoid,30747,doc/master/classTThread.html,https://root.cern,https://root.cern/doc/master/classTThread.html,1,['avoid'],['avoid']
Safety,"ametricGradFunction:; public ROOT::Math::IParametricGradFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoParameterDerivative(const double* x, const double* p,; unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; 13.7.4 Wrapper Functions; To facilitate the user to insert their own type of function in the needed function interface, helper classes, wrapping the user interface in the ROOT::Math function interfaces are provided. this will avoid the user to re-implement dedicated function classes, following the code example shown in the previous paragraphs.; There is one possible wrapper for every interface explained in the previous section. The following table indicates the wrapper for the most basic ones:. Interface; Function Wrapper. ROOT::Math::IBaseFunctionOneDim; ROOT::Math::Functor1D. ROOT::Math::IGradientFunctionOneDim; ROOT::Math::GradFunctor1D. ROOT::Math::IBaseFunctionMultiDim; ROOT::Math::Functor. ROOT::Math::IGradientFunctionMultiDim; ROOT::Math::GradFunctor. Thee functor wrapper are defined in the header file Math/Functor.h.; 13.7.4.1 Wrapping One Dimensional Functions; The ROOT::Math::Functor1D is used to wrap one-dimensional functions It can wrap all the following types: * A free C function of type double ()(double ). * Any C++ callable object implementation double operator()( double ). * A class member function with the correct signature like double Foo::Eval(double ). In this case one pass the object pointer and a pointer to the member function (&Foo::Eval",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:693895,avoid,avoid,693895,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety,"ams::Penalty ; (; ); const. This is the ""lasso"" penalty To be used for regression. ; â€” NOT USED â€” ; Definition at line 356 of file RuleFitParams.cxx. â—†Â Risk() [1/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_tÂ ; ind1, . UInt_tÂ ; ind2, . Double_tÂ ; neffÂ . ); const. risk assessment ; Definition at line 314 of file RuleFitParams.cxx. â—†Â Risk() [2/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_tÂ ; ind1, . UInt_tÂ ; ind2, . Double_tÂ ; neff, . UInt_tÂ ; itauÂ . ); const. risk assessment for tau model <itau> ; Definition at line 334 of file RuleFitParams.cxx. â—†Â RiskPath(). Double_t TMVA::RuleFitParams::RiskPath ; (; ); const. inline . Definition at line 108 of file RuleFitParams.h. â—†Â RiskPerf() [1/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; ); const. inline . Definition at line 109 of file RuleFitParams.h. â—†Â RiskPerf() [2/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; UInt_tÂ ; itau); const. inline . Definition at line 110 of file RuleFitParams.h. â—†Â RiskPerfTst(). UInt_t TMVA::RuleFitParams::RiskPerfTst ; (; ). Estimates the error rate with the current set of parameters. ; using the <Perf> subsample. Return the tau index giving the lowest error ; Definition at line 1201 of file RuleFitParams.cxx. â—†Â SetGDErrScale(). void TMVA::RuleFitParams::SetGDErrScale ; (; Double_tÂ ; s). inline . Definition at line 85 of file RuleFitParams.h. â—†Â SetGDNPathSteps(). void TMVA::RuleFitParams::SetGDNPathSteps ; (; Int_tÂ ; np). inline . Definition at line 65 of file RuleFitParams.h. â—†Â SetGDPathStep(). void TMVA::RuleFitParams::SetGDPathStep ; (; Double_tÂ ; s). inline . Definition at line 68 of file RuleFitParams.h. â—†Â SetGDTau(). void TMVA::RuleFitParams::SetGDTau ; (; Double_tÂ ; t). inline . Definition at line 82 of file RuleFitParams.h. â—†Â SetGDTauPrec(). void TMVA::RuleFitParams::SetGDTauPrec ; (; Double_tÂ ; p). inline . Definition at line 86 of file RuleFitParams.h. â—†Â SetGDTauRange(). void TMVA::RuleFitParams::SetGDTauRange ; (; Double_tÂ ; t0, . Double_tÂ ; t1Â . ). inline . Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:17304,Risk,RiskPerfTst,17304,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['Risk'],['RiskPerfTst']
Safety,"an be joined onto other RNTuples. More...; Â ; class Â ROOT::Experimental::RNTupleInspector; Â Inspect on-disk and storage-related information of an RNTuple. More...; Â ; class Â ROOT::Experimental::Internal::RNTupleMerger; Â Given a set of RPageSources merge them into an RPageSink, optionally changing their compression. More...; Â ; class Â ROOT::Experimental::Detail::RNTupleMetrics; Â A collection of Counter objects with a name, a unit, and a description. More...; Â ; class Â ROOT::Experimental::RNTupleModel; Â The RNTupleModel encapulates the schema of an ntuple. More...; Â ; class Â ROOT::Experimental::Internal::RNTupleModelChangeset; Â The incremental changes to a RNTupleModel More...; Â ; class Â ROOT::Experimental::RNTupleParallelWriter; Â A writer to fill an RNTuple from multiple contexts. More...; Â ; class Â ROOT::Experimental::Detail::RNTuplePerfCounter; Â A performance counter with a name and a unit, which can be activated on demand. More...; Â ; class Â ROOT::Experimental::Detail::RNTuplePlainCounter; Â A non thread-safe integral performance counter. More...; Â ; class Â ROOT::Experimental::RNTupleProcessor; Â Interface for iterating over entries of RNTuples and vertically concatenated RNTuples (chains). More...; Â ; class Â ROOT::Experimental::RNTupleReader; Â An RNTuple that is used to read data from storage. More...; Â ; class Â ROOT::Experimental::RNTupleReadOptions; Â Common user-tunable settings for reading ntuples. More...; Â ; class Â ROOT::Experimental::Internal::RNTupleSerializer; Â A helper class for serializing and deserialization of the RNTuple binary format. More...; Â ; class Â ROOT::Experimental::Detail::RNTupleTickCounter< BaseCounterT >; Â An either thread-safe or non thread safe counter for CPU ticks. More...; Â ; class Â ROOT::Experimental::Detail::RNTupleTimer< WallTimeT, CpuTimeT >; Â Record wall time and CPU time between construction and destruction. More...; Â ; class Â ROOT::Experimental::RNTupleView< T >; Â An RNTupleView for a known type. More...; Â ; class Â ROOT::Experime",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__NTuple.html:9709,safe,safe,9709,doc/master/group__NTuple.html,https://root.cern,https://root.cern/doc/master/group__NTuple.html,1,['safe'],['safe']
Safety,"an be used to force a log scale (option = ""log""), linear (option = ""lin"") or automatic if empty. ; Definition at line 2081 of file TF1.cxx. â—†Â Copy(). void TF1::Copy ; (; TObject &Â ; obj); const. overridevirtual . Copy this F1 to a new F1. ; Note that the cached integral with its related arrays are not copied (they are also set as transient data members) ; Reimplemented from TObject.; Reimplemented in TF12, TF2, and TF3.; Definition at line 1005 of file TF1.cxx. â—†Â CreateHistogram(). virtual TH1 * TF1::CreateHistogram ; (; ). inlinevirtual . Reimplemented in TF2, and TF3.; Definition at line 477 of file TF1.h. â—†Â DeclFileName(). static const char * TF1::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 755 of file TF1.h. â—†Â DefaultAddToGlobalList(). Bool_t TF1::DefaultAddToGlobalList ; (; Bool_tÂ ; on = kTRUE). static . Static method to add/avoid to add automatically functions to the global list (gROOT->GetListOfFunctions() ) After having called this static method, all the functions created afterwards will follow the desired behaviour. ; By default the functions are added automatically It returns the previous status (true if the functions are added automatically) ; Definition at line 838 of file TF1.cxx. â—†Â DefineNSUMTerm(). void TF1::DefineNSUMTerm ; (; TObjArray *Â ; newFuncs, . TObjArray *Â ; coeffNames, . TString &Â ; fullFormula, . TString &Â ; formula, . intÂ ; termStart, . intÂ ; termEnd, . Double_tÂ ; xmin, . Double_tÂ ; xmaxÂ . ). private . Helper functions for NSUM parsing. ; Definition at line 883 of file TF1.cxx. â—†Â Derivative(). Double_t TF1::Derivative ; (; Double_tÂ ; x, . Double_t *Â ; params = nullptr, . Double_tÂ ; eps = 0.001Â . ); const. virtual . Returns the first derivative of the function at point x, computed by Richardson's extrapolation method (use 2 derivative estimates to compute a third, more accurate estimation) first, derivatives with steps h and h/2 are computed by central difference formulas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:61192,avoid,avoid,61192,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['avoid'],['avoid']
Safety,"an object in this collection by name. ; Â ; voidÂ Paint (Option_t *option="""") override; Â Paint all objects in this collection. ; Â ; virtual voidÂ Print (Option_t *option, const char *wildcard, Int_t recurse=1) const; Â Print the collection header and its elements that match the wildcard. ; Â ; virtual voidÂ Print (Option_t *option, Int_t recurse) const; Â Print the collection header and its elements. ; Â ; virtual voidÂ Print (Option_t *option, TPRegexp &regexp, Int_t recurse=1) const; Â Print the collection header and its elements that match the regexp. ; Â ; voidÂ Print (Option_t *option="""") const override; Â Default print for collections, calls Print(option, 1). ; Â ; voidÂ RemoveAll (); Â ; virtual voidÂ RemoveAll (TCollection *col); Â Remove all objects in collection col from this collection. ; Â ; voidÂ SetCurrentCollection (); Â Set this collection to be the globally accessible collection. ; Â ; voidÂ SetName (const char *name); Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; virtual boolÂ UseRWLock (Bool_t enable=true); Â Set this collection to use a RW lock upon access, making it thread safe. ; Â ; Int_tÂ Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override; Â Write all objects in this collection. ; Â ; Int_tÂ Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override; Â Write all objects in this collection. ; Â ; Â Public Member Functions inherited from TObject; Â TObject (); Â TObject constructor. ; Â ; Â TObject (const TObject &object); Â TObject copy ctor. ; Â ; virtualÂ ~TObject (); Â TObject destructor. ; Â ; voidÂ AbstractMethod (const char *method) const; Â Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ; Â ; virtual voidÂ AppendPad (Option_t *option=""""); Â Append graphics object to current pad. ; Â ; ULong_tÂ CheckedHash (); Â Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ; Â ; virtual const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:16850,safe,safe,16850,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['safe'],['safe']
Safety,"anOperator ; (; ); const. inlineoverridevirtual . Implements TGeoBoolNode.; Definition at line 193 of file TGeoBoolNode.h. â—†Â GetNpoints(). Int_t TGeoSubtraction::GetNpoints ; (; ). overridevirtual . Returns number of vertices for the composite shape described by this subtraction. ; Implements TGeoBoolNode.; Definition at line 1135 of file TGeoBoolNode.cxx. â—†Â IsA(). TClass * TGeoSubtraction::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBoolNode.; Definition at line 203 of file TGeoBoolNode.h. â—†Â MakeClone(). TGeoBoolNode * TGeoSubtraction::MakeClone ; (; ); const. overridevirtual . Make a clone of this. Pointers are preserved. ; Implements TGeoBoolNode.; Definition at line 875 of file TGeoBoolNode.cxx. â—†Â Paint(). void TGeoSubtraction::Paint ; (; Option_t *Â ; option). overridevirtual . Paint method. ; Reimplemented from TGeoBoolNode.; Definition at line 883 of file TGeoBoolNode.cxx. â—†Â Safety(). Double_t TGeoSubtraction::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Compute safety distance for a union node;. ; Implements TGeoBoolNode.; Definition at line 1177 of file TGeoBoolNode.cxx. â—†Â SavePrimitive(). void TGeoSubtraction::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBoolNode.; Definition at line 1201 of file TGeoBoolNode.cxx. â—†Â Sizeof3D(). void TGeoSubtraction::Sizeof3D ; (; ); const. overridevirtual . Register 3D size of this shape. ; Reimplemented from TGeoBoolNode.; Definition at line 1220 of file TGeoBoolNode.cxx. â—†Â Streamer(). void TGeoSubtraction::Streamer ; (; TBuffer &Â ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGeoBoolNode. â—†Â StreamerNVirtual(). void TGeoSubtraction::StreamerNVirtual ; (; TBuffer &Â ; ClassDef_StreamerNVirtual_b). inline . Definition at line 203 of file TGeoBoolNode.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSubtraction.html:18323,Safe,Safety,18323,doc/master/classTGeoSubtraction.html,https://root.cern,https://root.cern/doc/master/classTGeoSubtraction.html,1,['Safe'],['Safety']
Safety,"anager class. Bool_t MakeBranch(const char* expr, Bool_t left); Expands the boolean expression either on left or right branch, creating; component elements (composite shapes and boolean nodes). Returns true on success. void Paint(Option_t* option); Special schema for feeding the 3D buffers to the painter client. void RegisterMatrices(); Register all matrices of the boolean node and descendents. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; Fill buffer with shape vertices. void SetPoints(Float_t* points) const; Fill buffer with shape vertices. void Sizeof3D() const; Register size of this 3D object. ThreadData_t& GetThreadData() const. TGeoBoolNode& operator=(const TGeoBoolNode& ). void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); methods. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm). Bool_t Contains(Double_t* point) const. Int_t DistanceToPrimitive(Int_t px, Int_t py). Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const. EGeoBoolType GetBooleanOperator() const. Int_t GetNpoints(). TGeoMatrix * GetLeftMatrix() const; {return fLeftMat;}. TGeoMatrix * GetRightMatrix() const; {return fRightMat;}. TGeoShape * GetLeftShape() const; {return fLeft;}. TGeoShape * GetRightShape() const; {return fRight;}. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; {return kGeoUnion;}. Â» Author: Andrei Gheata 30/05/02 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: :$Id: TGeoBoolNode.h 41234 2011-10-06 15:48:52Z agheata $ Â» Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoBoolNode.html:9049,safe,safe,9049,root/html532/TGeoBoolNode.html,https://root.cern,https://root.cern/root/html532/TGeoBoolNode.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"anager::FindNode(x,y,z) beforehand The method computing the distance to next boundary is:. TGeoNode *TGeoManager::FindNextBoundary(stepmax, path); The output node returned by the method is the object which shape boundary will be crossed first. The distance to the next crossing can be retrieved after the call:; Double_t TGeoManager::GetStep(). The main input parameter is stepmax, which act as a trigger for different features. The absolute value of this parameter represents the step value proposed by the user. The algorithm will never try o search for boundaries further than this distance. In case no boundary is found the returned node will be the current one and the computed step to boundary will be equal to abs (stepmax) having the meaning ""step approved"". The default value for stepmax is TGeoShape::Big with the meaning that boundaries are looked for without limitation. Finding the distance to the next crossed boundary; According the values of the input parameters the method will perform additional optional tasks:; |stepmax| < TGeoShape::Big(); The safe distance in the current volume is also computed. Moving the particle from its current location with this distance in any direction is safe in the sense that will never change the current state.; stepmax < 0; The global matrix for the object that will have the next crossed boundary is also computed. This can be retrieved for masterlocal point or vector conversions: TGeoManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; path 0; In case a path to a given physical object is specified, the distance to its bounda",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:131067,safe,safe,131067,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['safe'],['safe']
Safety,"ance=0); Â returns the address of the value pointed to by the TFormLeafInfo. ; Â ; virtual void *Â GetValuePointer (TLeaf *leaf, Int_t instance=0); Â returns the address of the value pointed to by the serie of TFormLeafInfo. ; Â ; virtual Int_tÂ GetVarDim (); Â Return the index of the dimension which varies for each elements of an enclosing array (typically a TClonesArray) ; Â ; virtual Int_tÂ GetVirtVarDim (); Â Return the virtual index (for this expression) of the dimension which varies for each elements of an enclosing array (typically a TClonesArray) ; Â ; virtual boolÂ HasCounter () const; Â Return true if any of underlying data has a array size counter. ; Â ; virtual boolÂ IsInteger () const; Â Return true if the underlying data is an integral value. ; Â ; virtual boolÂ IsReference () const; Â ; virtual boolÂ IsString () const; Â Return true if the underlying data is a string. ; Â ; virtual voidÂ LoadSizes (TBranch *branch); Â Load the current array sizes. ; Â ; TFormLeafInfo &Â operator= (const TFormLeafInfo &orig); Â Exception safe assignment operator. ; Â ; virtual Int_tÂ ReadCounterValue (char *where); Â Return the size of the underlying array for the current entry in the TTree. ; Â ; template<typename T > ; TÂ ReadTypedValue (char *where, Int_t instance=0); Â ; virtual Double_tÂ ReadValue (char *where, Int_t instance=0); Â ; template<typename T > ; TÂ ReadValueImpl (char *where, Int_t instance=0); Â Read the value at the given memory location. ; Â ; virtual Long64_tÂ ReadValueLong64 (char *where, Int_t instance=0); Â ; virtual LongDouble_tÂ ReadValueLongDouble (char *where, Int_t instance=0); Â ; virtual voidÂ SetBranch (TBranch *br); Â ; virtual voidÂ SetPrimaryIndex (Int_t index); Â Set the primary index value. ; Â ; virtual voidÂ SetSecondaryIndex (Int_t index); Â Set the primary index value. ; Â ; virtual voidÂ SetSize (Int_t index, Int_t val); Â Set the current size of the arrays. ; Â ; voidÂ Swap (TFormLeafInfo &other); Â ; virtual boolÂ Update (); Â We reloading all cached information in case the underlyi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFormLeafInfo.html:5238,safe,safe,5238,doc/master/classTFormLeafInfo.html,https://root.cern,https://root.cern/doc/master/classTFormLeafInfo.html,1,['safe'],['safe']
Safety,"and TGeoGtra.; Definition at line 93 of file TGeoArb8.h. â—†Â IsCylType(). Bool_t TGeoArb8::IsCylType ; (; ); const. inlineoverridevirtual . Implements TGeoShape.; Definition at line 73 of file TGeoArb8.h. â—†Â IsSamePoint(). static Bool_t TGeoArb8::IsSamePoint ; (; const Double_t *Â ; p1, . const Double_t *Â ; p2Â . ). inlinestatic . Definition at line 74 of file TGeoArb8.h. â—†Â IsTwisted(). Bool_t TGeoArb8::IsTwisted ; (; ); const. inline . Definition at line 80 of file TGeoArb8.h. â—†Â operator=(). TGeoArb8 & TGeoArb8::operator= ; (; const TGeoArb8 &Â ; ). protecteddelete . â—†Â Safety(). Double_t TGeoArb8::Safety ; (; const Double_t *Â ; point, . Bool_tÂ ; in = kTRUEÂ . ); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoTrap, and TGeoGtra. â—†Â Safety_v(). void TGeoArb8::Safety_v ; (; const Double_t *Â ; points, . const Bool_t *Â ; inside, . Double_t *Â ; safe, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoShape.; Reimplemented in TGeoTrap, and TGeoGtra. â—†Â SafetyToFace(). Double_t TGeoArb8::SafetyToFace ; (; const Double_t *Â ; point, . Int_tÂ ; iseg, . Bool_tÂ ; inÂ . ); const. â—†Â SavePrimitive(). void TGeoArb8::SavePrimitive ; (; std::ostream &Â ; out, . Option_t *Â ; option = """"Â . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TObject.; Reimplemented in TGeoTrap, and TGeoGtra. â—†Â SetDimensions(). void TGeoArb8::SetDimensions ; (; Double_t *Â ; param). overridevirtual . Implements TGeoShape.; Reimplemented in TGeoTrap, and TGeoGtra. â—†Â SetDz(). void TGeoArb8::SetDz ; (; Double_tÂ ; dz). inline . Definition at line 88 of file TGeoArb8.h. â—†Â SetPlaneVertices(). void TGeoArb8::SetPlaneVertices ; (; Double_tÂ ; zpl, . Double_t *Â ; verticesÂ . ); const. â—†Â SetPoints() [1/2]. void TGeoArb8::SetPoints ; (; Double_t *Â ; points); const. overridevirtual . Implements TGeoShape. â—†Â SetPoints() [2/2]. void TGeoArb8::SetPoints ; (; Float_t *Â ; points); const. overridevirtual . Implements TGeoShape. â—†Â SetVertex(). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:31958,Safe,SafetyToFace,31958,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,1,['Safe'],['SafetyToFace']
Safety,"and TTreeCacheUnzip.; Definition at line 326 of file TFileCacheRead.cxx. â—†Â ReadBuffer(). Int_t TFileCacheRead::ReadBuffer ; (; char *Â ; buf, . Long64_tÂ ; pos, . Int_tÂ ; lenÂ . ). virtual . Read buffer at position pos. ; If pos is in the list of prefetched blocks read from fBuffer, otherwise need to make a normal read from file. Returns -1 in case of read error, 0 in case not in cache, 1 in case read from cache. ; Reimplemented in TTreeCache.; Definition at line 364 of file TFileCacheRead.cxx. â—†Â ReadBufferExt(). Int_t TFileCacheRead::ReadBufferExt ; (; char *Â ; buf, . Long64_tÂ ; pos, . Int_tÂ ; len, . Int_t &Â ; locÂ . ). virtual . Reimplemented in TTreeCacheUnzip.; Definition at line 382 of file TFileCacheRead.cxx. â—†Â ReadBufferExtNormal(). Int_t TFileCacheRead::ReadBufferExtNormal ; (; char *Â ; buf, . Long64_tÂ ; pos, . Int_tÂ ; len, . Int_t &Â ; locÂ . ). virtual . Base function for ReadBuffer. ; Also gives out the position of the block in the internal buffer. This helps TTreeCacheUnzip to avoid doing twice the binary search. ; Definition at line 454 of file TFileCacheRead.cxx. â—†Â ReadBufferExtPrefetch(). Int_t TFileCacheRead::ReadBufferExtPrefetch ; (; char *Â ; buf, . Long64_tÂ ; pos, . Int_tÂ ; len, . Int_t &Â ; locÂ . ). virtual . prefetch the first block ; Definition at line 394 of file TFileCacheRead.cxx. â—†Â SecondPrefetch(). void TFileCacheRead::SecondPrefetch ; (; Long64_tÂ ; pos, . Int_tÂ ; lenÂ . ). virtual . Definition at line 259 of file TFileCacheRead.cxx. â—†Â SecondSort(). void TFileCacheRead::SecondSort ; (; ). virtual . Sort buffers to be prefetched in increasing order of positions. ; Merge consecutive blocks if necessary. ; Definition at line 630 of file TFileCacheRead.cxx. â—†Â SetBufferSize(). Int_t TFileCacheRead::SetBufferSize ; (; Long64_tÂ ; buffersize). virtual . Sets the buffer size. ; If the current prefetch list is too large to fit in the new buffer some or all of the prefetch blocks are dropped. The requested buffersize must be greater than zero. It will be auto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCacheRead.html:22549,avoid,avoid,22549,doc/master/classTFileCacheRead.html,https://root.cern,https://root.cern/doc/master/classTFileCacheRead.html,1,['avoid'],['avoid']
Safety,"and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the normal for a given shape.; Sample points inside the shape. Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz); Randomly shoot nrays from point (startx,starty,startz) and plot intersections; with surfaces for current top node. TGeoNode * SamplePoints(Int_t npo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoChecker.html:15926,safe,safety,15926,root/html530/TGeoChecker.html,https://root.cern,https://root.cern/root/html530/TGeoChecker.html,2,['safe'],['safety']
Safety,"and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the normal for a given shape.; Sample points inside the shape. Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char* target_vol = 0, Bool_t check_norm = kFALSE); Randomly shoot nrays from point (startx,starty,startz) and plot intersections; with surfaces",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoChecker.html:16045,safe,safety,16045,root/html534/TGeoChecker.html,https://root.cern,https://root.cern/root/html534/TGeoChecker.html,3,['safe'],['safety']
Safety,"and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the current point. TGeoNode * FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); Computes as fStep the distance to next daughter of the current volume.; The point and direction must be converted in the coordinate system of the current volume.; The proposed step limit is fStep. void ResetState(); Reset current state flags. TGeoNode * FindNode(Bool_t safe_start = kTRUE); Returns deepest node containing current point. TGeoNode * FindNode(Double_t x, Double_t y, Double_t z); Returns deepest node containing current point. Double_t * FindNormalFast(); Computes fast normal to next crossed boundary, assuming that the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:51561,safe,safe,51561,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,6,['safe'],['safe']
Safety,"and maximum radius. TGeoTube(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = Rmin; param[1] = Rmax; param[2] = dz. ~TGeoTube(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTube.html:14927,safe,safe,14927,root/html534/TGeoTube.html,https://root.cern,https://root.cern/root/html534/TGeoTube.html,3,['safe'],['safe']
Safety,"and other objects written after the setting is changed. In case the file does not exist or is not a valid ROOT file, it is made a Zombie. One can detect this situation with a code like: TFile f(""file.root"");; if (f.IsZombie()) {; std::cout << ""Error opening file"" << std::endl;; exit(-1);; }; f#define f(i)Definition RSha256.hxx:104; If you open a file instead with TFile::Open(""file.root"") use rather the following code as a nullptr is returned. TFile* f = TFile::Open(""file.root"");; if (!f) {; std::cout << ""Error opening file"" << std::endl;; exit(-1);; }; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; When opening the file, the system checks the validity of this directory. If something wrong is detected, an automatic Recovery is performed. In this case, the file is scanned sequentially reading all logical blocks and attempting to rebuild a correct directory (see TFile::Recover). One can disable the automatic recovery procedure when reading one or more files by setting the environment variable ""TFile.Recover: 0"" in the system.rootrc file.; A bit TFile::kReproducible can be enabled specifying the ""reproducible"" url option when creating the file: TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; Unlike regular TFiles, the content of such file has reproducible binary content when writing exactly same data. This achieved by writing pre-defined values for creation and modification date of TKey/TDirectory objects and null value for TUUID objects inside TFile. As drawback, TRef objects stored in such file cannot be read correctly.; In case the name of the file is not reproducible either (in case of creating temporary filenames) a value can be passed to the reproducible option to replace the name stored in the file. TFile *f = TFile::Open(""tmpname.root?reproducible=fixednam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:52347,Recover,Recover,52347,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['Recover'],['Recover']
Safety,"and; 18513 * conn->phys_ctx must be valid).; 18514 */; 18515static void; 18516process_new_connection(struct mg_connection *conn); 18517{; 18518 struct mg_request_info *ri = &conn->request_info;; 18519 int keep_alive, discard_len;; 18520 char ebuf[100];; 18521 const char *hostend;; 18522 int reqerr, uri_type;; 18523 ; 18524#if defined(USE_SERVER_STATS); 18525 ptrdiff_t mcon = mg_atomic_inc(&(conn->phys_ctx->active_connections));; 18526 mg_atomic_add(&(conn->phys_ctx->total_connections), 1);; 18527 mg_atomic_max(&(conn->phys_ctx->max_active_connections), mcon);; 18528#endif; 18529 ; 18530 DEBUG_TRACE(""Start processing connection from %s"",; 18531 conn->request_info.remote_addr);; 18532 ; 18533 /* Loop over multiple requests sent using the same connection; 18534 * (while ""keep alive""). */; 18535 do {; 18536 DEBUG_TRACE(""calling get_request (%i times for this connection)"",; 18537 conn->handled_requests + 1);; 18538 ; 18539#if defined(USE_SERVER_STATS); 18540 conn->conn_state = 3; /* ready */; 18541#endif; 18542 ; 18543 if (!get_request(conn, ebuf, sizeof(ebuf), &reqerr)) {; 18544 /* The request sent by the client could not be understood by; 18545 * the server, or it was incomplete or a timeout. Send an; 18546 * error message and close the connection. */; 18547 if (reqerr > 0) {; 18548 DEBUG_ASSERT(ebuf[0] != '\0');; 18549 mg_send_http_error(conn, reqerr, ""%s"", ebuf);; 18550 }; 18551 ; 18552 } else if (strcmp(ri->http_version, ""1.0""); 18553 && strcmp(ri->http_version, ""1.1"")) {; 18554 /* HTTP/2 is not allowed here */; 18555 mg_snprintf(conn,; 18556 NULL, /* No truncation check for ebuf */; 18557 ebuf,; 18558 sizeof(ebuf),; 18559 ""Bad HTTP version: [%s]"",; 18560 ri->http_version);; 18561 mg_send_http_error(conn, 505, ""%s"", ebuf);; 18562 }; 18563 ; 18564 if (ebuf[0] == '\0') {; 18565 uri_type = get_uri_type(conn->request_info.request_uri);; 18566 switch (uri_type) {; 18567 case 1:; 18568 /* Asterisk */; 18569 conn->request_info.local_uri_raw = 0;; 18570 /* TODO: Deal with '",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:550293,timeout,timeout,550293,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"and; 18514 * conn->phys_ctx must be valid).; 18515 */; 18516static void; 18517process_new_connection(struct mg_connection *conn); 18518{; 18519 struct mg_request_info *ri = &conn->request_info;; 18520 int keep_alive, discard_len;; 18521 char ebuf[100];; 18522 const char *hostend;; 18523 int reqerr, uri_type;; 18524 ; 18525#if defined(USE_SERVER_STATS); 18526 ptrdiff_t mcon = mg_atomic_inc(&(conn->phys_ctx->active_connections));; 18527 mg_atomic_add(&(conn->phys_ctx->total_connections), 1);; 18528 mg_atomic_max(&(conn->phys_ctx->max_active_connections), mcon);; 18529#endif; 18530 ; 18531 DEBUG_TRACE(""Start processing connection from %s"",; 18532 conn->request_info.remote_addr);; 18533 ; 18534 /* Loop over multiple requests sent using the same connection; 18535 * (while ""keep alive""). */; 18536 do {; 18537 DEBUG_TRACE(""calling get_request (%i times for this connection)"",; 18538 conn->handled_requests + 1);; 18539 ; 18540#if defined(USE_SERVER_STATS); 18541 conn->conn_state = 3; /* ready */; 18542#endif; 18543 ; 18544 if (!get_request(conn, ebuf, sizeof(ebuf), &reqerr)) {; 18545 /* The request sent by the client could not be understood by; 18546 * the server, or it was incomplete or a timeout. Send an; 18547 * error message and close the connection. */; 18548 if (reqerr > 0) {; 18549 DEBUG_ASSERT(ebuf[0] != '\0');; 18550 mg_send_http_error(conn, reqerr, ""%s"", ebuf);; 18551 }; 18552 ; 18553 } else if (strcmp(ri->http_version, ""1.0""); 18554 && strcmp(ri->http_version, ""1.1"")) {; 18555 /* HTTP/2 is not allowed here */; 18556 mg_snprintf(conn,; 18557 NULL, /* No truncation check for ebuf */; 18558 ebuf,; 18559 sizeof(ebuf),; 18560 ""Bad HTTP version: [%s]"",; 18561 ri->http_version);; 18562 mg_send_http_error(conn, 505, ""%s"", ebuf);; 18563 }; 18564 ; 18565 if (ebuf[0] == '\0') {; 18566 uri_type = get_uri_type(conn->request_info.request_uri);; 18567 switch (uri_type) {; 18568 case 1:; 18569 /* Asterisk */; 18570 conn->request_info.local_uri_raw = 0;; 18571 /* TODO: Deal with '",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:550326,timeout,timeout,550326,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,andler (protected). ; Â ; voidÂ MakeZombie (); Â . Protected Attributes; ROOT::R::TRFunctionImportÂ asfactor; Â ; ROOT::R::TRFunctionImportÂ C50; Â ; ROOT::R::TRFunctionImportÂ C50Control; Â ; UInt_tÂ fControlBands; Â ; Double_tÂ fControlCF; Â ; Bool_tÂ fControlEarlyStopping; Â ; Bool_tÂ fControlFuzzyThreshold; Â ; UInt_tÂ fControlMinCases; Â ; Bool_tÂ fControlNoGlobalPruning; Â ; Double_tÂ fControlSample; Â ; Int_tÂ fControlSeed; Â ; Bool_tÂ fControlSubset; Â ; Bool_tÂ fControlWinnow; Â ; ROOT::R::TRObject *Â fModel; Â ; ROOT::R::TRObjectÂ fModelControl; Â ; UInt_tÂ fMvaCounter; Â ; UInt_tÂ fNTrials; Â ; Bool_tÂ fRules; Â ; std::vector< TString >Â ListOfVariables; Â ; ROOT::R::TRFunctionImportÂ predict; Â ; Â Protected Attributes inherited from TMVA::RMethodBase; ROOT::R::TRDataFrameÂ fDfSpectators; Â ; ROOT::R::TRDataFrameÂ fDfTest; Â ; ROOT::R::TRDataFrameÂ fDfTrain; Â ; std::vector< std::string >Â fFactorTest; Â ; std::vector< std::string >Â fFactorTrain; Â ; TVectorDÂ fWeightTest; Â ; TVectorDÂ fWeightTrain; Â ; ROOT::R::TRInterface &Â r; Â ; Â Protected Attributes inherited from TMVA::MethodBase; Types::EAnalysisTypeÂ fAnalysisType; Â ; UInt_tÂ fBackgroundClass; Â ; boolÂ fExitFromTraining = false; Â ; std::vector< TString > *Â fInputVars; Â ; IPythonInteractive *Â fInteractive = nullptr; Â temporary dataset used when evaluating on a different data (used by MethodCategory::GetMvaValues) ; Â ; UInt_tÂ fIPyCurrentIter = 0; Â ; UInt_tÂ fIPyMaxIter = 0; Â ; std::vector< Float_t > *Â fMulticlassReturnVal; Â ; Int_tÂ fNbins; Â ; Int_tÂ fNbinsH; Â ; Int_tÂ fNbinsMVAoutput; Â ; Ranking *Â fRanking; Â ; std::vector< Float_t > *Â fRegressionReturnVal; Â ; Results *Â fResults; Â ; UInt_tÂ fSignalClass; Â ; DataSet *Â fTmpData = nullptr; Â temporary event when testing on a different DataSet than the own one ; Â ; const Event *Â fTmpEvent; Â ; Â Protected Attributes inherited from TMVA::Configurable; MsgLogger *Â fLogger; Â ! message logger ; Â ; Â Protected Attributes inherited from TNamed; TStringÂ fName; Â ; TStringÂ fTitle; Â . Static Protected Attributes; static Bool_tÂ IsM,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodC50.html:24743,predict,predict,24743,doc/master/classTMVA_1_1MethodC50.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodC50.html,1,['predict'],['predict']
Safety,"andler *eh);; 385 virtual TSeqCollection *GetListOfStdExceptionHandlers() const { return fStdExceptionHandler; }; 386 ; 387 //---- Floating Point Exceptions Control; 388 virtual Int_t GetFPEMask();; 389 virtual Int_t SetFPEMask(Int_t mask = kDefaultMask);; 390 ; 391 //---- Time & Date; 392 virtual TTime Now();; 393 virtual TList *GetListOfTimers() const { return fTimers; }; 394 virtual void AddTimer(TTimer *t);; 395 virtual TTimer *RemoveTimer(TTimer *t);; 396 virtual void ResetTimer(TTimer *) { }; 397 virtual Long_t NextTimeOut(Bool_t mode);; 398 virtual void Sleep(UInt_t milliSec);; 399 ; 400 //---- Processes; 401 virtual Int_t Exec(const char *shellcmd);; 402 virtual FILE *OpenPipe(const char *command, const char *mode);; 403 virtual int ClosePipe(FILE *pipe);; 404 virtual TString GetFromPipe(const char *command);; 405 virtual int GetPid();; 406 virtual void StackTrace();; 407 ; 408 [[ noreturn ]] virtual void Exit(int code, Bool_t mode = kTRUE);; 409 [[ noreturn ]] virtual void Abort(int code = 0);; 410 ; 411 //---- Directories; 412 virtual int MakeDirectory(const char *name);; 413 virtual void *OpenDirectory(const char *name);; 414 virtual void FreeDirectory(void *dirp);; 415 virtual const char *GetDirEntry(void *dirp);; 416 virtual void *GetDirPtr() const { return nullptr; }; 417 virtual Bool_t ChangeDirectory(const char *path);; 418 virtual const char *WorkingDirectory();; 419 virtual std::string GetWorkingDirectory() const;; 420 virtual const char *HomeDirectory(const char *userName = nullptr);; 421 virtual std::string GetHomeDirectory(const char *userName = nullptr) const;; 422 virtual int mkdir(const char *name, Bool_t recursive = kFALSE);; 423 Bool_t cd(const char *path) { return ChangeDirectory(path); }; 424 const char *pwd() { return WorkingDirectory(); }; 425 virtual const char *TempDirectory() const;; 426 virtual FILE *TempFileName(TString &base, const char *dir = nullptr, const char *suffix = nullptr);; 427 ; 428 //---- Paths & Files; 429 virtual con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:17320,Abort,Abort,17320,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['Abort'],['Abort']
Safety,"andler(TStdExceptionHandler* eh); Add an exception handler to list of system exception handlers. Only adds; the handler if it is not already in the list of exception handlers. TStdExceptionHandler * RemoveStdExceptionHandler(TStdExceptionHandler* eh); Remove an exception handler from list of exception handlers. Returns; the handler or 0 if the handler was not in the list of exception handlers. Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* command, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. TString GetFromPipe(const char* command); Execute command and return output in TString. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. TSystem * FindHelper(const char* path, void* dirptr = 0); Create helper TSystem to handle file and directory operations that; might be special for remote file access, like via rfiod or rootd. Bool_t ConsistentWith(const char* path, void* dirptr = 0); Check consistency of this helper with the one required; by 'path' or 'dirptr'. int MakeDirectory(const char* name); Make a directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * OpenDirectory(const char* name); Open a directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Free a directory. const char * GetDirEntry(void* dirp); Get a directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:22421,Abort,Abort,22421,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,12,['Abort'],['Abort']
Safety,"andom,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); Deprecated function. Use next function instead. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); Create one branch for each element in the collection. Each entry in the collection becomes a top level branch if the; corresponding class is not a collection. If it is a collection, the entry; in the collection becomes in turn top level branches, etc.; The splitlevel is decreased by 1 every time a new collection is found.; For example if list is a TObjArray*; - if splitlevel = 1, one top level branch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:43149,detect,detection,43149,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,4,['detect'],['detection']
Safety,"andom,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); Deprecated function. Use next function instead. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); Create one branch for each element in the collection. Each entry in the collection becomes a top level branch if the; corresponding class is not a collection. If it is a collection, the entry; in the collection becomes in turn top level branches, etc.; The splitlevel is decreased by 1 everytime a new collection is found.; For example if list is a TObjArray*; - if splitlevel = 1, one top level branch ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:41003,detect,detection,41003,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['detect'],['detection']
Safety,"anf(celmnt[ifld-1],""%lf"",&plist[llist-1]);; 1779 }; 1780 }; 1781// end loop over numeric fields; 1782L900:; 1783 if (lnc <= 0) lnc = 1;; 1784 comand = command;; 1785}; 1786 ; 1787////////////////////////////////////////////////////////////////////////////////; 1788/// Find point where MNEVAL=AMIN+UP; 1789///; 1790/// Find point where MNEVAL=AMIN+UP, along the line through; 1791/// XMIDCR,YMIDCR with direction XDIRCR,YDIRCR, where X and Y; 1792/// are parameters KE1CR and KE2CR. If KE2CR=0 (from MINOS),; 1793/// only KE1CR is varied. From MNCONT, both are varied.; 1794/// Crossing point is at; 1795///; 1796/// (U(KE1),U(KE2)) = (XMID,YMID) + AOPT*(XDIR,YDIR); 1797 ; 1798void TMinuit::mncros(Double_t &aopt, Int_t &iercr); 1799{; 1800 /* Local variables */; 1801 Double_t alsb[3], flsb[3], bmin, bmax, zmid, sdev, zdir, zlim;; 1802 Double_t coeff[3], aleft, aulim, fdist, adist, aminsv;; 1803 Double_t anext, fnext, slope, s1, s2, x1, x2, ecarmn, ecarmx;; 1804 Double_t determ, rt, smalla, aright, aim, tla, tlf, dfda,ecart;; 1805 Int_t iout=0, i, ileft, ierev, maxlk, ibest, ik, it;; 1806 Int_t noless, iworst=0, iright, itoohi, kex, ipt;; 1807 Bool_t ldebug;; 1808 const char *chsign;; 1809 x2 = 0;; 1810 ; 1811 ldebug = fIdbg[6] >= 1;; 1812 aminsv = fAmin;; 1813// convergence when F is within TLF of AIM and next prediction; 1814// of AOPT is within TLA of previous value of AOPT; 1815 aim = fAmin + fUp;; 1816 tlf = fUp*.01;; 1817 tla = .01;; 1818 fXpt[0] = 0;; 1819 fYpt[0] = aim;; 1820 fChpt[0] = ' ';; 1821 ipt = 1;; 1822 if (fKe2cr == 0) {; 1823 fXpt[1] = -1;; 1824 fYpt[1] = fAmin;; 1825 fChpt[1] = '.';; 1826 ipt = 2;; 1827 }; 1828// find the largest allowed A; 1829 aulim = 100;; 1830 for (ik = 1; ik <= 2; ++ik) {; 1831 if (ik == 1) {; 1832 kex = fKe1cr;; 1833 zmid = fXmidcr;; 1834 zdir = fXdircr;; 1835 } else {; 1836 if (fKe2cr == 0) continue;; 1837 kex = fKe2cr;; 1838 zmid = fYmidcr;; 1839 zdir = fYdircr;; 1840 }; 1841 if (fNvarl[kex-1] <= 1) continue;; 1842 if (zdir == 0) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:61347,predict,prediction,61347,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['predict'],['prediction']
Safety,"angleXYFixedDim; static TEveQuadSet::EQuadType_ekQT_RectangleXYFixedDimZ; static TEveQuadSet::EQuadType_ekQT_RectangleXYFixedZ; static TEveQuadSet::EQuadType_ekQT_RectangleXZ; static TEveQuadSet::EQuadType_ekQT_RectangleXZFixedDimY; static TEveQuadSet::EQuadType_ekQT_RectangleXZFixedY; static TEveQuadSet::EQuadType_ekQT_RectangleYZ; static TEveQuadSet::EQuadType_ekQT_RectangleYZFixedDimX; static TEveQuadSet::EQuadType_ekQT_RectangleYZFixedX; static TEveQuadSet::EQuadType_ekQT_Rectangle_End; static TEveQuadSet::EQuadType_ekQT_Undef; static TEveDigitSet::ERenderMode_eTEveDigitSet::kRM_AsIs; static TEveDigitSet::ERenderMode_eTEveDigitSet::kRM_Fill; static TEveDigitSet::ERenderMode_eTEveDigitSet::kRM_Line; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTEveSecondarySelectable::fAlwaysSecSelectAlways do secondary-selection in GL.; Bool_tTEveDigitSet::fAntiFlickMake extra render pass to avoid flickering when quads are too small.; Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); UChar_tTEveElement::fCSCBits; TEveDigitSet::Callback_fooTEveDigitSet::fCallbackFoo! Additional function to call on secondary-select.; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; TEveElement::List_tTEveElement::fChildrenList of children.; Color_tTEveDigitSet::fColorColor used for frame (or all digis with single-color).; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Float_tfDefCoordDefault value for third coordinate (C); Float_tfDefHeightBreadth assigned to second coordinate (B); Float_tfDefWidthBreadth assigned to first coordinate (A); Int_tTEveDigitSet::fDefaultValueDefault signal value.; Int_tTEveElement::fDenyDestroy! Deny-d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveQuadSet.html:25945,avoid,avoid,25945,root/html602/TEveQuadSet.html,https://root.cern,https://root.cern/root/html602/TEveQuadSet.html,2,['avoid'],['avoid']
Safety,"annotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. stringfFileNamePrefix; intfHighBin; intfLowBin; doublefLumiError; doublefNomLumi; TFile*fOut_f; stringstreamfResultsPrefixStr; stringfRowTitle; vector<string>fSystToFix; FILE*pFile. private:. stringfObsName; vector<std::string>fObsNameVec; vector<string>fPreprocessFunctions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HistoToWorkspaceFactoryFast(); {}. ~HistoToWorkspaceFactoryFast(). HistoToWorkspaceFactoryFast(string , string , vector<string> , double = 200, double = 20, int = 0, int = 6, TFile* = 0). string FilePrefixStr(string ). void ProcessExpectedHisto(TH1* hist, RooWorkspace* proto, string prefix, string productPrefix, string systTerm, double low, double high, int lowBin, int highBin). void AddMultiVarGaussConstraint(RooWorkspace* proto, string prefix, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins. void LinInterpWithConstraint(RooWorkspace* proto, TH1* nominal, vector<TH1*> lowHist, vector<TH1*> highHist, vector<string> sourceName, string prefix, string productPrefix, string systTerm, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins; require dimension >=1 or <=3. { fObsNameVec.push_back(fObsName); }. string AddNormFactor(RooWorkspace* , string& , string& , RooStats::HistFactory::EstimateSummary& , bool ). void AddEfficiencyTerms(RooWorkspace* proto, string prefix, string interpName, map<string,pair<double,double> > systMap, vector<string>& likelihoodTermNames, vector<string>& totSystTermNames); add variables for all the relative overall uncertainties we expect; range is set u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html:9104,predict,predictions,9104,root/html532/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,https://root.cern,https://root.cern/root/html532/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,1,['predict'],['predictions']
Safety,"ansp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements. void RenderSelOpaqueForHighlight(TGLRnrCtx& rnrCtx); Render selected opaque elements for highlight. void RenderSelTranspForHighlight(TGLRnrCtx& rnrCtx); Render selected transparent elements for highlight. void RenderHighlight(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec). void PostDraw(TGLRnrCtx& rnrCtx); Called after the rendering is finished.; In debug mode draw statistcs is dumped.; Parent's PostDraw is called for GL cleanup. void RenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); Do full rendering of scene. First draw the opaques, then the transparents. For each we do; the number of passes required by draw mode and clipping setup. void RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLScene.html:10631,timeout,timeout,10631,root/html534/TGLScene.html,https://root.cern,https://root.cern/root/html534/TGLScene.html,3,['timeout'],['timeout']
Safety,"ant to support this special case; 5447 // Int_t n = TMath::Min(axis->GetNbins(), labels->GetSize());; 5448 ; 5449 // support only cases where each bin has a labels (should be when axis is alphanumeric); 5450 Int_t n = labels->GetSize();; 5451 if (n != axis->GetNbins()) {; 5452 // check if labels are all consecutive and starts from the first bin; 5453 // in that case the current code will work fine; 5454 Int_t firstLabelBin = axis->GetNbins()+1;; 5455 Int_t lastLabelBin = -1;; 5456 for (Int_t i = 0; i < n; ++i) {; 5457 Int_t bin = labels->At(i)->GetUniqueID();; 5458 if (bin < firstLabelBin) firstLabelBin = bin;; 5459 if (bin > lastLabelBin) lastLabelBin = bin;; 5460 }; 5461 if (firstLabelBin != 1 || lastLabelBin-firstLabelBin +1 != n) {; 5462 Error(""LabelsOption"", ""%s of Histogram %s contains bins without labels. Sorting will not work correctly - return"",; 5463 axis->GetName(), GetName());; 5464 return;; 5465 }; 5466 // case where label bins are consecutive starting from first bin will work; 5467 // calling before a TH1::LabelsDeflate() will avoid this error message; 5468 Warning(""LabelsOption"", ""axis %s of Histogram %s has extra following bins without labels. Sorting will work only for first label bins"",; 5469 axis->GetName(), GetName());; 5470 }; 5471 std::vector<Int_t> a(n);; 5472 std::vector<Int_t> b(n);; 5473 ; 5474 ; 5475 Int_t i, j, k;; 5476 std::vector<Double_t> cont;; 5477 std::vector<Double_t> errors2;; 5478 THashList *labold = new THashList(labels->GetSize(), 1);; 5479 TIter nextold(labels);; 5480 TObject *obj = nullptr;; 5481 labold->AddAll(labels);; 5482 labels->Clear();; 5483 ; 5484 // delete buffer if it is there since bins will be reordered.; 5485 if (fBuffer); 5486 BufferEmpty(1);; 5487 ; 5488 if (sort > 0) {; 5489 //---sort by values of bins; 5490 if (GetDimension() == 1) {; 5491 cont.resize(n);; 5492 if (fSumw2.fN); 5493 errors2.resize(n);; 5494 for (i = 0; i < n; i++) {; 5495 cont[i] = RetrieveBinContent(i + 1);; 5496 if (!errors2.empty()); 5497 e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:219196,avoid,avoid,219196,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['avoid'],['avoid']
Safety,"anti-clockwise. Double_t GetTwist(Int_t iseg) const; Get twist for segment I in range [0,3]. Double_t GetClosestEdge(const Double_t* point, Double_t* vert, Int_t& isegment) const; Get index of the edge of the quadrilater represented by vert closest to point.; If [P1,P2] is the closest segment and P is the point, the function returns the fraction of the; projection of (P1P) over (P1P2). If projection of P is not in range [P1,P2] return -1. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; Test if point is inside this shape.; first check Z range. Double_t DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; Computes distance to plane ipl :; ipl=0 : points 0,4,1,5; ipl=1 : points 1,5,2,6; ipl=2 : points 2,6,3,7; ipl=3 : points 3,7,0,4. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Computes distance from outside point to surface of the shape. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide this shape along one axis. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get shape range on a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2; --- first compute rmin/rmax. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this arb8. Returns 0 if successfull. void GetPlaneNormal(Double_t* p1, Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoArb8.html:15598,safe,safe,15598,root/html534/TGeoArb8.html,https://root.cern,https://root.cern/root/html534/TGeoArb8.html,3,['safe'],['safe']
Safety,"any variable contained in the data set; The option string is currently not used ; Definition at line 2144 of file RooAbsData.cxx. â—†Â table() [2/2]. Roo1DTable * RooAbsData::table ; (; const RooArgSet &Â ; catSet, . const char *Â ; cuts = """", . const char *Â ; opts = """"Â . ); const. virtual . Construct table for product of categories in catSet. ; Definition at line 757 of file RooAbsData.cxx. â—†Â tree(). const TTree * RooAbsData::tree ; (; ); const. Return a pointer to the TTree which stores the data. ; Returns a nullpointer if vector-based storage is used. The RooAbsData remains owner of the tree. GetClonedTree() can be used to get a tree even if the internal storage does not use one. ; Definition at line 2417 of file RooAbsData.cxx. â—†Â uniqueId(). RooFit::UniqueId< RooAbsData > const & RooAbsData::uniqueId ; (; ); const. inline . Returns a unique ID that is different for every instantiated RooAbsData object. ; This ID can be used whether two RooAbsData are the same object, which is safer than memory address comparisons that might result in false positives when memory is reused. ; Definition at line 308 of file RooAbsData.h. â—†Â weight(). virtual double RooAbsData::weight ; (; ); const. pure virtual . Implemented in RooDataHist, and RooDataSet. â—†Â weightError() [1/2]. virtual void RooAbsData::weightError ; (; double &Â ; lo, . double &Â ; hi, . ErrorTypeÂ ; = PoissonÂ . ); const. inlinevirtual . Return the asymmetric errors on the current weight. ; See also weightError(ErrorType) const for symmetric error. Parameters. [out]loLow error. ; [out]hiHigh error. . Reimplemented in RooDataHist, and RooDataSet.; Definition at line 122 of file RooAbsData.h. â—†Â weightError() [2/2]. virtual double RooAbsData::weightError ; (; ErrorTypeÂ ; = Poisson); const. inlinevirtual . Return the symmetric error on the current weight. ; See also weightError(double&,double&,ErrorType) const for asymmetric errors. ; Reimplemented in RooDataHist, and RooDataSet.; Definition at line 112 of file RooAbsData.h. â—†Â ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:76534,safe,safer,76534,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['safe'],['safer']
Safety,"ap, 2 * oldCap)) : ms - 1;; 1229 return cap;; 1230}; 1231 ; 1232////////////////////////////////////////////////////////////////////////////////; 1233/// Clear string without changing its capacity.; 1234 ; 1235void TString::Clear(); 1236{; 1237 Clobber(Capacity());; 1238}; 1239 ; 1240////////////////////////////////////////////////////////////////////////////////; 1241/// Clear string and make sure it has a capacity of nc.; 1242/// \warning If nc > MaxSize(), then Fatal() is raised, and only MaxSize(); 1243/// elements are allocated if Fatal does not abort; 1244/// \return Resulting allocated capacity (after clamping, if needed); 1245 ; 1246Ssiz_t TString::Clobber(Ssiz_t nc); 1247{; 1248 if (nc > MaxSize()) {; 1249 Fatal(""TString::Clobber"", ""capacity too large (%d, max = %d)"", nc, MaxSize());; 1250 // In the rare case where Fatal does not abort, we erase, clamp and continue; 1251 UnLink();; 1252 Zero();; 1253 nc = MaxSize(); // Clamping after deleting to avoid corruption; 1254 }; 1255 ; 1256 if (nc < kMinCap) {; 1257 UnLink();; 1258 Zero();; 1259 } else {; 1260 char *data = GetLongPointer();; 1261 Ssiz_t cap = Recommend(nc);; 1262 if (cap != Capacity()) {; 1263 data = new char[cap+1];; 1264 UnLink();; 1265 SetLongCap(cap+1);; 1266 SetLongPointer(data);; 1267 }; 1268 SetLongSize(0);; 1269 data[0] = 0;; 1270 }; 1271 return nc;; 1272}; 1273 ; 1274////////////////////////////////////////////////////////////////////////////////; 1275/// Make self a distinct copy with capacity of at least tot, where tot cannot; 1276/// be smaller than the current length. Preserve previous contents.; 1277/// \warning If tot > MaxSize(), then Fatal() is raised and only MaxSize() elements are allocated; 1278 ; 1279void TString::Clone(Ssiz_t tot); 1280{; 1281 Ssiz_t len = Length();; 1282 if (len >= tot) return;; 1283 ; 1284 if (tot > MaxSize()) {; 1285 Fatal(""TString::Clone"", ""tot too large (%d, max = %d)"", tot, MaxSize());; 1286 tot = MaxSize();; 1287 }; 1288 ; 1289 Ssiz_t capac = Capacity()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:38010,abort,abort,38010,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,3,"['abort', 'avoid']","['abort', 'avoid']"
Safety,"ap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie; FILE*pFile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HistoToWorkspaceFactory(). ~HistoToWorkspaceFactory(). HistoToWorkspaceFactory(string , string , vector<string> , double = 200, double = 20, int = 0, int = 6, TFile* = 0). string FilePrefixStr(string ). void ProcessExpectedHisto(TH1* hist, RooWorkspace* proto, string prefix, string productPrefix, string systTerm, double low, double high, int lowBin, int highBin). void AddMultiVarGaussConstraint(RooWorkspace* proto, string prefix, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins. void LinInterpWithConstraint(RooWorkspace* proto, TH1* nominal, vector<TH1*> lowHist, vector<TH1*> highHist, vector<string> sourceName, string prefix, string productPrefix, string systTerm, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins; make list of abstract parameters that interpolate in space of variations; range is set using defined macro (see top of the page). string AddNormFactor(RooWorkspace* , string& , string& , RooStats::HistFactory::EstimateSummary& , bool ). void AddEfficiencyTerms(RooWorkspace* proto, string prefix, string interpName, map<string,pair<double,double> > systMap, vector<string>& likelihoodTermNames, vector<string>& totSystTermNames); add variables for al",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__HistoToWorkspaceFactory.html:9006,predict,predictions,9006,root/html602/RooStats__HistFactory__HistoToWorkspaceFactory.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__HistoToWorkspaceFactory.html,2,['predict'],['predictions']
Safety,"ap;; 210 va_start(ap, fmt);; 211 ErrorHandler(kBreak, location, fmt, ap);; 212 va_end(ap);; 213}; 214 ; 215////////////////////////////////////////////////////////////////////////////////; 216/// Use this function for informational messages.; 217 ; 218void Info(const char *location, const char *fmt, ...); 219{; 220 std::va_list ap;; 221 va_start(ap, fmt);; 222 ErrorHandler(kInfo, location, fmt, ap);; 223 va_end(ap);; 224}; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// Use this function in warning situations.; 228 ; 229void Warning(const char *location, const char *fmt, ...); 230{; 231 std::va_list ap;; 232 va_start(ap, fmt);; 233 ErrorHandler(kWarning, location, fmt, ap);; 234 va_end(ap);; 235}; 236 ; 237////////////////////////////////////////////////////////////////////////////////; 238/// Use this function in case of a fatal error. It will abort the program.; 239 ; 240/// @warning Fatal() *will* not abort the program if `gErrorIgnoreLevel > kFatal`; 241/// - but for all reasonable settings it *will* abort.; 242// So let's be reasonable wrt Coverity:; 243// coverity[+kill]; 244void Fatal(const char *location, const char *fmt, ...); 245{; 246 std::va_list ap;; 247 va_start(ap, fmt);; 248 ErrorHandler(kFatal, location, fmt, ap);; 249 va_end(ap);; 250}; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gErrorAbortLevelInt_t gErrorAbortLevelDefinition TError.cxx:32; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35; Errorvoid Error(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Breakvoid Break(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:207; GetErrorHandlerErrorHandlerFunc_t GetErrorHandler()Retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8cxx_source.html:8077,abort,abort,8077,doc/master/TError_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html,2,['abort'],['abort']
Safety,"ape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2(); dummy ctor. TGeoTrd2(Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy1; param[3] = dy2; param[4] = dz. ~TGeoTrd2(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd2. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd2; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd2; Boundary safe algorithm. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd2 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTrd2.html:12555,safe,safe,12555,root/html528/TGeoTrd2.html,https://root.cern,https://root.cern/root/html528/TGeoTrd2.html,6,['safe'],['safe']
Safety,"ape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Double_tDistToParaboloid(Double_t* point, Double_t* dir, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoParaboloid.html:2542,safe,safe,2542,root/html530/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html530/TGeoParaboloid.html,1,['safe'],['safe']
Safety,"ape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoSphere.html:2328,safe,safe,2328,root/html530/TGeoSphere.html,https://root.cern,https://root.cern/root/html530/TGeoSphere.html,1,['safe'],['safe']
Safety,"ape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoCompositeShape.html:8020,safe,safe,8020,root/html530/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html530/TGeoCompositeShape.html,4,['safe'],['safe']
Safety,"ape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidDefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPcon.html:2106,safe,safe,2106,root/html532/TGeoPcon.html,https://root.cern,https://root.cern/root/html532/TGeoPcon.html,1,['safe'],['safe']
Safety,"apping ; (; ); const. inline . Definition at line 139 of file TGeoNavigator.h. â—†Â IsEntering(). Bool_t TGeoNavigator::IsEntering ; (; ); const. inline . Definition at line 140 of file TGeoNavigator.h. â—†Â IsExiting(). Bool_t TGeoNavigator::IsExiting ; (; ); const. inline . Definition at line 141 of file TGeoNavigator.h. â—†Â IsNullStep(). Bool_t TGeoNavigator::IsNullStep ; (; ); const. inline . Definition at line 146 of file TGeoNavigator.h. â—†Â IsOnBoundary(). Bool_t TGeoNavigator::IsOnBoundary ; (; ); const. inline . Definition at line 145 of file TGeoNavigator.h. â—†Â IsOutside(). Bool_t TGeoNavigator::IsOutside ; (; ); const. inline . Definition at line 144 of file TGeoNavigator.h. â—†Â IsPWSafetyCaching(). static Bool_t TGeoNavigator::IsPWSafetyCaching ; (; ). inlinestatic . Definition at line 232 of file TGeoNavigator.h. â—†Â IsSafeStep(). Bool_t TGeoNavigator::IsSafeStep ; (; Double_tÂ ; proposed, . Double_t &Â ; newsafetyÂ . ); const. In case a previous safety value was computed, check if the safety region is still safe for the current point and proposed step. ; Return value changed only if proposed distance is safe. ; Definition at line 2609 of file TGeoNavigator.cxx. â—†Â IsSameLocation() [1/2]. Bool_t TGeoNavigator::IsSameLocation ; (; ); const. inline . Definition at line 133 of file TGeoNavigator.h. â—†Â IsSameLocation() [2/2]. Bool_t TGeoNavigator::IsSameLocation ; (; Double_tÂ ; x, . Double_tÂ ; y, . Double_tÂ ; z, . Bool_tÂ ; change = kFALSEÂ . ). Checks if point (x,y,z) is still in the current node. ; check if this is an overlapping node ; Definition at line 2446 of file TGeoNavigator.cxx. â—†Â IsSamePoint(). Bool_t TGeoNavigator::IsSamePoint ; (; Double_tÂ ; x, . Double_tÂ ; y, . Double_tÂ ; zÂ . ); const. Check if a new point with given coordinates is the same as the last located one. ; Definition at line 2634 of file TGeoNavigator.cxx. â—†Â IsStartSafe(). Bool_t TGeoNavigator::IsStartSafe ; (; ); const. inline . Definition at line 135 of file TGeoNavigator.h. â—†Â IsStepEntering(). Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:37485,safe,safety,37485,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,3,['safe'],"['safe', 'safety']"
Safety,"apshot with deepCloning option is a set; # of cloned objects, all their clone (recursive) server; # dependencies, together form a self-consistent; # set that is free of external dependencies; ; sclone3 = s3.snapshot(True); ; # Set printing; # ------------------------; ; # Inline printing only show list of names of contained objects; print(""sclone = "", sclone); ; # Plain print shows the same, by name of the set; sclone.Print(); ; # Standard printing shows one line for each item with the items name, name; # and value; sclone.Print(""s""); ; # Verbose printing adds each items arguments, and 'extras' as defined by; # the object; sclone.Print(""v""); ; # Using RooArgLists; # ---------------------------------; ; # List constructors exists with up to 9 initial arguments; l = ROOT.RooArgList(a, b, c, d); ; # Lists have an explicit order and allow multiple arguments with the same; # name; l.add(ROOT.RooArgList(a, b, c, d)); ; # Access by index is provided; arg4 = l.at(4); [#0] WARNING:InputArguments -- The parameter 'b' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; RooArgSet::sclone = (a,b,c,d,e,g); 1) RooRealVar:: a = 1; 2) RooRealVar:: b = 2; 3) RooRealVar:: c = 3 +/- 0.5; 4) RooRealVar:: d = 4; 5) RooCategory:: e = sig(idx = 0); ; 6) RooGaussian:: g = 0.882497; 1) 0x7b39df0 RooRealVar:: a = 1 C L(-10 - 10) ""a""; 2) 0x7b3a1e0 RooRealVar:: b = 2 C L(-10 - 10) ""b""; 3) 0x7b13900 RooRealVar:: c = 3 +/- 0.5 L(-10 - 10) ""c""; 4) 0x7aa7d60 RooRealVar:: d = 4 L(-10 - 10) ""d""; 5) 0x7e8fbd0 RooCategory:: e = sig(idx = 0); ""e""; 6) 0x7ea8d00 RooGaussian:: g[ x=x mean=a sigma=b ] = 0.882497 ""g""; sclone = { @0x7eaa940, @0x7eaa948, @0x7eaa950, @0x7eaa958, @0x7eaa960, @0x7eaa968 }; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf508_listsetmanip.py. tutorialsroofitrf508_listsetmanip.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8 Â Â ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf508__listsetmanip_8py.html:3821,safe,safe,3821,doc/master/rf508__listsetmanip_8py.html,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8py.html,1,['safe'],['safe']
Safety,"ar () const override; Â Return the number of Parameters. ; Â ; MultiDimParamFunctionAdapter &Â operator= (const MultiDimParamFunctionAdapter &rhs); Â Assignment operator. ; Â ; const double *Â Parameters () const override; Â Access the parameter values. ; Â ; voidÂ SetParameters (const double *p) override; Â Set the parameter values. ; Â ; Â Public Member Functions inherited from ROOT::Math::IParametricFunctionMultiDimTempl< double >; doubleÂ operator() (const double *x) const; Â ; doubleÂ operator() (const double *x, const double *p) const; Â Evaluate function at a point x and for given parameters p. ; Â ; Â Public Member Functions inherited from ROOT::Math::IBaseFunctionMultiDimTempl< T >; virtualÂ ~IBaseFunctionMultiDimTempl ()=default; Â ; virtual boolÂ HasGradient () const; Â ; TÂ operator() (const T *x) const; Â Evaluate the function at a point x[]. ; Â ; Â Public Member Functions inherited from ROOT::Math::IBaseParam; virtualÂ ~IBaseParam (); Â Virtual Destructor (no operations) ; Â ; virtual std::stringÂ ParameterName (unsigned int i) const; Â Return the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default name (""Par_0, Par_1, ..."") ; Â . Private Member Functions; doubleÂ DoEvalPar (const double *x, const double *p) const override; Â needed by the interface ; Â . Private Attributes; IParamFunction *Â fFunc; Â ; boolÂ fOwn; Â . #include <Math/MultiDimParamFunctionAdapter.h>. Inheritance diagram for ROOT::Math::MultiDimParamFunctionAdapter:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. â—†Â BaseFunc. typedef IParamMultiFunction::BaseFunc ROOT::Math::MultiDimParamFunctionAdapter::BaseFunc. Definition at line 45 of file MultiDimParamFunctionAdapter.h. Constructor & Destructor Documentation. â—†Â MultiDimParamFunctionAdapter() [1/3]. ROOT::Math::MultiDimParamFunctionAdapter::MultiDimParamFunctionAdapter ; (; const IParamFunction &Â ; f). inline . Constructor from a parametric one dim function in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1MultiDimParamFunctionAdapter.html:3311,avoid,avoid,3311,doc/master/classROOT_1_1Math_1_1MultiDimParamFunctionAdapter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1MultiDimParamFunctionAdapter.html,1,['avoid'],['avoid']
Safety,"ar * GetSessionDir() const; { return fSessionDir; }. const char * GetPackageDir() const; { return fPackageDir; }. const char * GetDataDir() const; { return fDataDir; }. Int_t GetProtocol() const; { return fProtocol; }. const char * GetOrdinal() const; { return fOrdinal; }. Int_t GetGroupId() const; { return fGroupId; }. Int_t GetGroupSize() const; { return fGroupSize; }. Int_t GetLogLevel() const; { return fLogLevel; }. TSocket * GetSocket() const; { return fSocket; }. Float_t GetRealTime() const; { return fRealTime; }. Float_t GetCpuTime() const; { return fCpuTime; }. Int_t GetQuerySeqNum() const; { return fQuerySeqNum; }. Int_t GetTotSessions() const; { return fTotSessions; }. Int_t GetActSessions() const; { return fActSessions; }. Float_t GetEffSessions() const; { return fEffSessions; }. TList * GetEnabledPackages() const; { return fEnabledPackages; }. Int_t GetInflateFactor() const; { return fInflateFactor; }. Long64_t GetMsgSizeHWM() const; { return fMsgSizeHWM; }. const char * GetPrefix() const; { return fPrefix; }. TProofLockPath * GetCacheLock(); { return fCacheLock; }. EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE). void HandleTermination(); { Terminate(0); }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsEndMaster() const; { return fEndMaster; }. Bool_t IsMaster() const; { return fMasterServ; }. Bool_t IsTopMaster() const; { return fOrdinal == ""0""; }. void ReleaseWorker(const char* ); { }. void DisableTimeout(); Disable / Enable read timeout. { }. void EnableTimeout(); { }. void LogToMaster(Bool_t on = kTRUE); Log control. { fSendLogToMaster = on; }. Â» Author: Fons Rademakers 16/02/97 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: root/proof:$Id: TProofServ.h 36592 2010-11-11 10:43:17Z ganis $ Â» Last generated: 2010-12-10 14:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:32893,timeout,timeout,32893,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,1,['timeout'],['timeout']
Safety,"ar *&s) final; Â Reads a char* string. ; Â ; TClass *Â ReadClass (const TClass *cl=nullptr, UInt_t *objTag=nullptr) final; Â suppressed function of TBuffer ; Â ; voidÂ ReadDouble (Double_t &d) final; Â Reads Double_t value from buffer. ; Â ; voidÂ ReadFastArray (Bool_t *b, Int_t n) final; Â read array of Bool_t from buffer ; Â ; voidÂ ReadFastArray (Char_t *c, Int_t n) final; Â read array of Char_t from buffer ; Â ; voidÂ ReadFastArray (Double_t *d, Int_t n) final; Â read array of Double_t from buffer ; Â ; voidÂ ReadFastArray (Float_t *f, Int_t n) final; Â read array of Float_t from buffer ; Â ; voidÂ ReadFastArray (Int_t *i, Int_t n) final; Â read array of Int_t from buffer ; Â ; voidÂ ReadFastArray (Long64_t *l, Int_t n) final; Â read array of Long64_t from buffer ; Â ; voidÂ ReadFastArray (Long_t *l, Int_t n) final; Â read array of Long_t from buffer ; Â ; voidÂ ReadFastArray (Short_t *h, Int_t n) final; Â read array of Short_t from buffer ; Â ; voidÂ ReadFastArray (UChar_t *c, Int_t n) final; Â read array of UChar_t from buffer ; Â ; voidÂ ReadFastArray (UInt_t *i, Int_t n) final; Â read array of UInt_t from buffer ; Â ; voidÂ ReadFastArray (ULong64_t *l, Int_t n) final; Â read array of ULong64_t from buffer ; Â ; voidÂ ReadFastArray (ULong_t *l, Int_t n) final; Â read array of ULong_t from buffer ; Â ; voidÂ ReadFastArray (UShort_t *h, Int_t n) final; Â read array of UShort_t from buffer ; Â ; voidÂ ReadFastArray (void **startp, const TClass *cl, Int_t n=1, Bool_t isPreAlloc=kFALSE, TMemberStreamer *s=nullptr, const TClass *onFileClass=nullptr) final; Â redefined here to avoid warning message from gcc ; Â ; voidÂ ReadFastArray (void *start, const TClass *cl, Int_t n=1, TMemberStreamer *s=nullptr, const TClass *onFileClass=nullptr) final; Â Read an array of 'n' objects from the I/O buffer. ; Â ; voidÂ ReadFastArrayString (Char_t *c, Int_t n) final; Â read array of Char_t from buffer ; Â ; voidÂ ReadFloat (Float_t &f) final; Â Reads Float_t value from buffer. ; Â ; voidÂ ReadInt (Int_t &i) final; Â Reads Int_t value from b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:9385,avoid,avoid,9385,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,1,['avoid'],['avoid']
Safety,"ar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Â» Last changed: root/mathcore:$Id: PxPyPzM4D.h 30568 2009-10-06 07:17:59Z moneta $ Â» Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html:8618,avoid,avoid,8618,root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html,1,['avoid'],['avoid']
Safety,"ar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Â» Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ Â» Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__PxPyPzM4D_Double32_t_.html:8618,avoid,avoid,8618,root/html528/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__PxPyPzM4D_Double32_t_.html,1,['avoid'],['avoid']
Safety,"ar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Â» Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ Â» Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_Double32_t_.html:8620,avoid,avoid,8620,root/html530/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_Double32_t_.html,1,['avoid'],['avoid']
Safety,"ar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Â» Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ Â» Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html:8620,avoid,avoid,8620,root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,1,['avoid'],['avoid']
Safety,"ar* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMD5.html:2313,avoid,avoids,2313,root/html528/TMD5.html,https://root.cern,https://root.cern/root/html528/TMD5.html,3,['avoid'],['avoids']
Safety,"ar* filename = """", Option_t* option = """") constMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerRemote(TProof* proof = 0); TProofPlayerRemote(const TProofPlayerRemote&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerRemote.html:11103,abort,abort,11103,root/html602/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html602/TProofPlayerRemote.html,1,['abort'],['abort']
Safety,"ar* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidEnableTimeout(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static voidFilterLocalroot(TString& path, const char* url = ""root://dum/""); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFlushLogFile(); TObject*Get(const char* namecycle); Int_tGetActSessions() const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofServ.html:4056,abort,abort,4056,root/html602/TProofServ.html,https://root.cern,https://root.cern/root/html602/TProofServ.html,2,['abort'],['abort']
Safety,"ar* rfile, TList* wrks); Int_tBroadcastFile(const char* file, Int_t opt, const char* rfile = 0, TProof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TProof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TList* workers); Int_tBroadcastObject(const TObject* obj, Int_t kind, TList* slaves); Int_tBroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT, TProof::ESlaves list = kActive); Int_tBroadcastRaw(const void* buffer, Int_t length, TList* slaves); Int_tBroadcastRaw(const void* buffer, Int_t length, TProof::ESlaves list = kActive); Int_tBuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll); Int_tBuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0); Bool_tCheckFile(const char* file, TSlave* sl, Long_t modtime, Int_t cpopt = (kCp|kCpBin)); voidCleanGDirectory(TList* ol); voidClearDataProgress(Int_t r, Int_t t); Int_tCollect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Bool_tCreateMerger(TSlave* sl, Int_t port); voidDeActivateAsyncInput(); Int_tDisablePackage(const char* package); Int_tDisablePackageOnClient(const char* package); Int_tDisablePackages(); Int_tExec(const char* cmd, TProof::ESlaves list, Bool_t plusMaster); voidFinalizationDone(); Int_tFindNextFreeMerger(); TSlave*FindSlave(TSocket* s) const; virtual voidFindUniqueSlaves(); Int_tGetActiveMergersCount(); static TList*GetDataSetSrvMaps(const TString& srvmaps); TList*GetListOfBadSlaves() const; TList*GetListOfInactiveSlaves() const; TList*GetListOfSlaves() const; TList*GetListOfUniqueSlaves() const; Int_tGetNumberOfActiveSlaves() const; Int_tGetNumberOfBadSlaves() const; Int_tGetNumberOfInactiveSlaves() const; Int_tGetNumberOfSlaves() const; Int_tGetN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProof.html:21279,timeout,timeout,21279,root/html530/TProof.html,https://root.cern,https://root.cern/root/html530/TProof.html,2,['timeout'],['timeout']
Safety,"ar* rfile, TList* wrks); Int_tBroadcastFile(const char* file, Int_t opt, const char* rfile = 0, TProof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TProof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TList* workers); Int_tBroadcastObject(const TObject* obj, Int_t kind, TList* slaves); Int_tBroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT, TProof::ESlaves list = kActive); Int_tBroadcastRaw(const void* buffer, Int_t length, TList* slaves); Int_tBroadcastRaw(const void* buffer, Int_t length, TProof::ESlaves list = kActive); Int_tBuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll); Int_tBuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0); Bool_tCheckFile(const char* file, TSlave* sl, Long_t modtime, Int_t cpopt = (kCp|kCpBin)); voidCleanGDirectory(TList* ol); voidClearDataProgress(Int_t r, Int_t t); Int_tCollect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Bool_tCreateMerger(TSlave* sl, Int_t port); voidDeActivateAsyncInput(); Int_tDisablePackage(const char* package); Int_tDisablePackageOnClient(const char* package); Int_tDisablePackages(); Int_tExec(const char* cmd, TProof::ESlaves list, Bool_t plusMaster); voidFinalizationDone(); Int_tFindNextFreeMerger(); TSlave*FindSlave(TSocket* s) const; voidFindUniqueSlaves(); Int_tGetActiveMergersCount(); static TList*GetDataSetSrvMaps(const TString& srvmaps); TList*GetListOfBadSlaves() const; TList*GetListOfInactiveSlaves() const; TList*GetListOfSlaves() const; TList*GetListOfUniqueSlaves() const; Int_tGetNumberOfActiveSlaves() const; Int_tGetNumberOfBadSlaves() const; Int_tGetNumberOfInactiveSlaves() const; Int_tGetNumberOfSlaves() const; Int_tGetNumberOfU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:21134,timeout,timeout,21134,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,1,['timeout'],['timeout']
Safety,"ar*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoBoolNode::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidTGeoBoolNode::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoIntersection.html:2651,safe,safe,2651,root/html534/TGeoIntersection.html,https://root.cern,https://root.cern/root/html534/TGeoIntersection.html,9,['safe'],['safe']
Safety,"ar6, const RooAbsArg& var7, const RooAbsArg& var8, const char* name = """"); Constructor for set containing 8 initial objects. RooArgList(const RooAbsArg& var1, const RooAbsArg& var2, const RooAbsArg& var3, const RooAbsArg& var4, const RooAbsArg& var5, const RooAbsArg& var6, const RooAbsArg& var7, const RooAbsArg& var8, const RooAbsArg& var9, const char* name = """"); Constructor for set containing 9 initial objects. RooArgList(const TCollection& tcoll, const char* name); Constructor from a root TCollection. Elements in the collection that; do not inherit from RooAbsArg will be skipped. A warning message; will be printed for every skipped item. RooArgList(const RooArgList& other, const char *name); Copy constructor. Note that a copy of a list is always non-owning,; even the source list is owning. To create an owning copy of; a list (owning or not), use the snaphot() method. ~RooArgList(); Destructor. RooAbsArg& operator[](Int_t idx) const; Array operator. Element in slot 'idx' must already exist, otherwise; code will abort. When used as lvalue in assignment operations, the element contained in; the list will not be changed, only the value of the existing element!. void writeToStream(ostream& os, Bool_t compact); Write the contents of the argset in ASCII form to given stream. All elements will be printed on a single line separated by a single; white space. The contents of each element is written by the arguments'; writeToStream() function. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read the contents of the argset in ASCII form from given stream. A single line is read, and all elements are assumed to be separated; by white space. The value of each argument is read by the arguments; readFromStream function. TObject* clone(const char* newname) const; { return new RooArgList(*this,newname); }. TObject* create(const char* newname) const; { return new RooArgList(newname); }. RooArgList& operator=(const RooArgList& other); { RooAbsCollection::o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooArgList.html:15055,abort,abort,15055,root/html526/RooArgList.html,https://root.cern,https://root.cern/root/html526/RooArgList.html,1,['abort'],['abort']
Safety,"ar:: x = 5 L(0 - 10) ""x""; 1) 0x847fc10 RooRealVar:: a0 = 0.5 L(0 - 1) ""a0""; 2) 0x84f2330 RooRealVar:: a1 = 0.2 L(0 - 1) ""a1""; 3) 0x87f3060 RooRealVar:: alpha = -1 C L(-INF - +INF) ""alpha""; 4) 0x8782390 RooRealVar:: bkg1frac = 0.2 L(0 - 1) ""fraction of component 1 in background""; 5) 0x8926120 RooRealVar:: bkgfrac = 0.5 L(0 - 1) ""fraction of background""; 6) 0x82654f0 RooRealVar:: mean = 5 C L(-INF - +INF) ""mean of gaussians""; 7) 0x7ef2000 RooRealVar:: sigma = 0.5 C L(-INF - +INF) ""width of gaussians""; RooArgSet::parameters = (a0,a1,alpha,bkg1frac,bkgfrac,mean,sigma); 1) 0x8a01230 RooAddPdf:: model[ bkgfrac * bkg + [%] * sig ] = 0.582695/1 ""g1+g2+a""; 2) 0x898ff20 RooAddPdf:: bkg[ bkg1frac * bkg1 + [%] * bkg2 ] = 0.16539/1 ""Signal""; 3) 0x891da50 RooChebychev:: bkg1[ x=x coefficients=(a0,a1) ] = 0.8 ""Background 1""; 4) 0x8948240 RooExponential:: bkg2[ x=x c=alpha ] = 0.00673795 ""Background 2""; 5) 0x8554880 RooGaussian:: sig[ x=x mean=mean sigma=sigma ] = 1 ""Signal component 1""; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooCustomizer::build(model): tree node sig will be replaced by sigsum; [#1] INFO:ObjectHandling -- RooCustomizer::build(model) Branch node RooAddPdf::model cloned: depends on a replaced parameter; [#1] INFO:ObjectHandling -- RooCustomizer::build(model) Branch node sig is already replaced; 0x8e664a0 RooAddPdf::model_cust = 0.582695/1 [Auto,Clean] ; 0x898ff20/V- RooAddPdf::bkg = 0.16539/1 [Auto,Clean] ; 0x891da50/V- RooChebychev::bkg1 = 0.8 [Auto,Dirty] ; 0x8241e40/V- RooRealVar::x = 5; 0x847fc10/V- RooRealVar::a0 = 0.5; 0x84f2330/V- RooRealVar::a1 = 0.2; 0x8782390/V- RooRealVar::bkg1frac = 0.2; 0x8948240/V- RooExponential::bkg2 = 0.00673795 [Auto,Dirty] ; 0x8241e40/V- RooRealVar::x = 5; 0x87f3060/V- RooRealVar::alpha = -1; 0x8926120/V- RooRealVar::bkgfrac = 0.5; 0x8cd8990/V- RooAddPdf::sigsum = 1/1 [Auto,Clea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf207__comptools_8py.html:5441,safe,safe,5441,doc/master/rf207__comptools_8py.html,https://root.cern,https://root.cern/doc/master/rf207__comptools_8py.html,1,['safe'],['safe']
Safety,"araboloid::Contains ; (; const Double_t *Â ; point); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â Contains_v(). void TGeoParaboloid::Contains_v ; (; const Double_t *Â ; points, . Bool_t *Â ; inside, . Int_tÂ ; vecsizeÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DeclFileName(). static const char * TGeoParaboloid::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 78 of file TGeoParaboloid.h. â—†Â DistancetoPrimitive(). Int_t TGeoParaboloid::DistancetoPrimitive ; (; Int_tÂ ; px, . Int_tÂ ; pyÂ . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoBBox. â—†Â DistFromInside(). Double_t TGeoParaboloid::DistFromInside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromInside_v(). void TGeoParaboloid::DistFromInside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside(). Double_t TGeoParaboloid::DistFromOutside ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Int_tÂ ; iact = 1, . Double_tÂ ; step = TGeoShape::Big(), . Double_t *Â ; safe = nullptrÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistFromOutside_v(). void TGeoParaboloid::DistFromOutside_v ; (; const Double_t *Â ; points, . const Double_t *Â ; dirs, . Double_t *Â ; dists, . Int_tÂ ; vecsize, . Double_t *Â ; stepÂ . ); const. overridevirtual . Reimplemented from TGeoBBox. â—†Â DistToParaboloid(). Double_t TGeoParaboloid::DistToParaboloid ; (; const Double_t *Â ; point, . const Double_t *Â ; dir, . Bool_tÂ ; inÂ . ); const. â—†Â Divide(). TGeoVolume * TGeoParab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParaboloid.html:25001,safe,safe,25001,doc/master/classTGeoParaboloid.html,https://root.cern,https://root.cern/doc/master/classTGeoParaboloid.html,1,['safe'],['safe']
Safety,"arallelWorld &Â ; ). protecteddelete . â—†Â PrintBVH(). void TGeoParallelWorld::PrintBVH ; (; ); const. Prints the BVH. ; Definition at line 374 of file TGeoParallelWorld.cxx. â—†Â PrintDetectedOverlaps(). Int_t TGeoParallelWorld::PrintDetectedOverlaps ; (; ); const. Print the overlaps which were detected during real tracking. ; Definition at line 135 of file TGeoParallelWorld.cxx. â—†Â RefreshPhysicalNodes(). void TGeoParallelWorld::RefreshPhysicalNodes ; (; ). Refresh the node pointers and re-voxelize. ; To be called mandatory in case re-alignment happened. ; Definition at line 198 of file TGeoParallelWorld.cxx. â—†Â ResetOverlaps(). void TGeoParallelWorld::ResetOverlaps ; (; ); const. Reset overlapflag for all volumes in geometry. ; Definition at line 154 of file TGeoParallelWorld.cxx. â—†Â Safety(). Double_t TGeoParallelWorld::Safety ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). inline . Definition at line 118 of file TGeoParallelWorld.h. â—†Â SafetyBVH(). double TGeoParallelWorld::SafetyBVH ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). private . Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ; Definition at line 1027 of file TGeoParallelWorld.cxx. â—†Â SafetyLoop(). Double_t TGeoParallelWorld::SafetyLoop ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). private . Compute safety for the parallel world (trivial loop version for comparison/debugging) ; Definition at line 1207 of file TGeoParallelWorld.cxx. â—†Â SafetyOrig(). Double_t TGeoParallelWorld::SafetyOrig ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). private . Compute safety for the parallel world (original version based on TGeoVoxelFinder) ; Definition at line 1145 of file TGeoParallelWorld.cxx. â—†Â SetAccelerationMode(). void TGeoParallelWorld::SetAccelerationMode ; (; AccelerationMode const &Â ; mode). inline . Definition at line 95 of file TGeoParallelWorld.h. â—†Â SetUseOverlaps(). void TGeoParallelWor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:25883,Safe,SafetyBVH,25883,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['Safe'],['SafetyBVH']
Safety,"arallelWorld::operator= ; (; const TGeoParallelWorld &Â ; ). protecteddelete . â—†Â PrintBVH(). void TGeoParallelWorld::PrintBVH ; (; ); const. Prints the BVH. ; Definition at line 374 of file TGeoParallelWorld.cxx. â—†Â PrintDetectedOverlaps(). Int_t TGeoParallelWorld::PrintDetectedOverlaps ; (; ); const. Print the overlaps which were detected during real tracking. ; Definition at line 135 of file TGeoParallelWorld.cxx. â—†Â RefreshPhysicalNodes(). void TGeoParallelWorld::RefreshPhysicalNodes ; (; ). Refresh the node pointers and re-voxelize. ; To be called mandatory in case re-alignment happened. ; Definition at line 198 of file TGeoParallelWorld.cxx. â—†Â ResetOverlaps(). void TGeoParallelWorld::ResetOverlaps ; (; ); const. Reset overlapflag for all volumes in geometry. ; Definition at line 154 of file TGeoParallelWorld.cxx. â—†Â Safety(). Double_t TGeoParallelWorld::Safety ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). inline . Definition at line 118 of file TGeoParallelWorld.h. â—†Â SafetyBVH(). double TGeoParallelWorld::SafetyBVH ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). private . Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ; Definition at line 1027 of file TGeoParallelWorld.cxx. â—†Â SafetyLoop(). Double_t TGeoParallelWorld::SafetyLoop ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). private . Compute safety for the parallel world (trivial loop version for comparison/debugging) ; Definition at line 1207 of file TGeoParallelWorld.cxx. â—†Â SafetyOrig(). Double_t TGeoParallelWorld::SafetyOrig ; (; Double_tÂ ; point[3], . Double_tÂ ; safmax = 1.E30Â . ). private . Compute safety for the parallel world (original version based on TGeoVoxelFinder) ; Definition at line 1145 of file TGeoParallelWorld.cxx. â—†Â SetAccelerationMode(). void TGeoParallelWorld::SetAccelerationMode ; (; AccelerationMode const &Â ; mode). inline . Definition at line 95 of file TGeoParallelWorld.h. â—†",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:25844,Safe,SafetyBVH,25844,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['Safe'],['SafetyBVH']
Safety,"aramMultiFunctionTempl<T>. Definition at line 83 of file Fitter.h. â—†Â MinuitFCN_t. typedef void(* ROOT::Fit::Fitter::MinuitFCN_t) (int &npar, double *gin, double &f, double *u, int flag). fit using user provided FCN with Minuit-like interface If npar = 0 it is assumed that the parameters are specified in the parameter settings created before For the options same consideration as in the previous method ; Definition at line 339 of file Fitter.h. Constructor & Destructor Documentation. â—†Â Fitter() [1/3]. ROOT::Fit::Fitter::Fitter ; (; ). inline . Default constructor. ; Definition at line 102 of file Fitter.h. â—†Â Fitter() [2/3]. ROOT::Fit::Fitter::Fitter ; (; const std::shared_ptr< FitResult > &Â ; result). Constructor from a result. ; Definition at line 51 of file Fitter.cxx. â—†Â ~Fitter(). virtual ROOT::Fit::Fitter::~Fitter ; (; ). inlinevirtual . Destructor. ; Make it virtual in case users derive from Fitter class to extend it by adding new methods. This is needed to avoid a warning seen when doing from Python (see ROOT issue #12391 ). Note that the Fitter class does not provide virtual functions to be re-implemented by derived classes. ; Definition at line 117 of file Fitter.h. â—†Â Fitter() [3/3]. ROOT::Fit::Fitter::Fitter ; (; const Fitter &Â ; ). delete . Copy constructor (disabled, class is not copyable) . Member Function Documentation. â—†Â ApplyWeightCorrection(). bool ROOT::Fit::Fitter::ApplyWeightCorrection ; (; const ROOT::Math::IMultiGenFunction &Â ; loglw2, . boolÂ ; minimizeW2L = falseÂ . ). apply correction in the error matrix for the weights for likelihood fits This method can be called only after a fit. ; The passed function (loglw2) is a log-likelihood function implemented using the sum of weight squared When using FitConfig.SetWeightCorrection() this correction is applied automatically when doing a likelihood fit (binned or unbinned) ; Definition at line 886 of file Fitter.cxx. â—†Â CalculateHessErrors(). bool ROOT::Fit::Fitter::CalculateHessErrors ; (; ). perform an ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html:16478,avoid,avoid,16478,doc/master/classROOT_1_1Fit_1_1Fitter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html,1,['avoid'],['avoid']
Safety,"aram[1] = Rmin; param[2] = Rmax; param[3] = Phi1; param[4] = Dphi. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the torus. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside the torus.; check phi range. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each vertex. Double_t Daxis(Double_t* pt, Double_t* dir, Double_t t) const; Computes distance to axis of the torus from point pt + t*dir;. Double_t DDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Computes derivative w.r.t. t of the distance to axis of the torus from point pt + t*dir;. Double_t DDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Second derivative of distance to torus axis w.r.t t. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the torus. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the torus. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this torus shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; Create a shape fitting the mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTorus.html:13199,safe,safe,13199,root/html528/TGeoTorus.html,https://root.cern,https://root.cern/root/html528/TGeoTorus.html,3,['safe'],['safe']
Safety,"aram[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. void InspectShape() const; Inspect the PGON parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Rpg(Double_t z, Int_t ipl, Bool_t inner, Double_t& a, Double_t& b) const; Computes projected pgon radius (inner or outer) corresponding to a given Z; value. Fills corresponding coefficients of:; Rpg(z) = a + b*z; Note: ipl must be in range [0,fNz-2]. Double_t Rproj(Double_t z, const Double_t* point, const Double_t* dir, Double_t cphi, Double_t sphi, Double_t& a, Double_t& b) const; Computes projected distance at a given Z for a given ray inside a given sector; and fills coefficients:; Rproj = a + b*z. Double_t SafetyToSegment(const Double_t* point, Int_t ipl, Int_t iphi, Bool_t in, Double_t safphi, Double_t safmin = TGeoShape::Big()) const; Compute safety from POINT to segment between planes ipl, ipl+1 within safmin. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set PGON dimensions starting from an array. void SetPoints(Double_t* points) const; create polygone mesh points. void SetPoints(Float_t* points) const; create polygone mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPgon.html:19962,Safe,SafetyToSegment,19962,root/html534/TGeoPgon.html,https://root.cern,https://root.cern/root/html534/TGeoPgon.html,6,"['Safe', 'safe']","['SafetyToSegment', 'safety']"
Safety,"aram[in] name name of histogram (avoid blanks); 711/// \param[in] title histogram title.; 712/// If title is of the form `stringt;stringx;stringy;stringz`; 713/// the histogram title is set to `stringt`,; 714/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 715/// \param[in] nbins number of bins; 716/// \param[in] xbins array of low-edges for each bin.; 717/// This is an array of type float and size nbins+1; 718 ; 719TH1::TH1(const char *name,const char *title,Int_t nbins,const Float_t *xbins); 720 :TNamed(name,title); 721{; 722 Build();; 723 if (nbins <= 0) {Warning(""TH1"",""nbins is <=0 - set to nbins = 1""); nbins = 1; }; 724 if (xbins) fXaxis.Set(nbins,xbins);; 725 else fXaxis.Set(nbins,0,1);; 726 fNcells = fXaxis.GetNbins()+2;; 727}; 728 ; 729////////////////////////////////////////////////////////////////////////////////; 730/// Constructor for variable bin size histograms using an input array of type double.; 731///; 732/// \param[in] name name of histogram (avoid blanks); 733/// \param[in] title histogram title.; 734/// If title is of the form `stringt;stringx;stringy;stringz`; 735/// the histogram title is set to `stringt`,; 736/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 737/// \param[in] nbins number of bins; 738/// \param[in] xbins array of low-edges for each bin.; 739/// This is an array of type double and size nbins+1; 740 ; 741TH1::TH1(const char *name,const char *title,Int_t nbins,const Double_t *xbins); 742 :TNamed(name,title); 743{; 744 Build();; 745 if (nbins <= 0) {Warning(""TH1"",""nbins is <=0 - set to nbins = 1""); nbins = 1; }; 746 if (xbins) fXaxis.Set(nbins,xbins);; 747 else fXaxis.Set(nbins,0,1);; 748 fNcells = fXaxis.GetNbins()+2;; 749}; 750 ; 751////////////////////////////////////////////////////////////////////////////////; 752/// Static function: cannot be inlined on Windows/NT.; 753 ; 754Bool_t TH1::AddDirectoryStatus(); 755{; 756 return fgAddDirectory;; 757}; 758 ; 759////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:30384,avoid,avoid,30384,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['avoid'],['avoid']
Safety,"arameterDerivative(double x, const double* p, unsigned int ipar) const. Data Members; private:. TF1*fFuncpointer to ROOT function; boolfLinearflag for linear functions; vector<double>fParamscached vector with parameter values; boolfPolynomialflag for polynomial functions; doublefX[1]! cached vector for x value (needed for TF1::EvalPar signature); static doublefgEpsepsilon used in derivative calculation h ~ eps |x|. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; WrappedTF1(TF1& f); constructor from a TF1 function pointer. WrappedTF1(TF1& f); copy constructor. void ParameterGradient(double x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. double DoDerivative(double x) const; return the function derivatives w.r.t. x. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const; evaluate the derivative of the function with respect to the parameters; IMPORTANT NOTE: TF1::GradientPar returns 0 for fixed parameters to avoid computing useless derivatives; BUT the TLinearFitter wants to have the derivatives also for fixed parameters.; so in case of fLinear (or fPolynomial) a non-zero value will be returned for fixed parameters. void SetDerivPrecision(double eps); { fgEps = eps; }. double GetDerivPrecision(); { return fgEps; }. virtual ~WrappedTF1(). Destructor (no operations). TF1 Function pointer is not owned. {}. ROOT::Math::IGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cachen inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__WrappedTF1.html:4396,avoid,avoid,4396,root/html602/ROOT__Math__WrappedTF1.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__WrappedTF1.html,1,['avoid'],['avoid']
Safety,"arameters. The order; is the following : Rmin, Rmax, Phi1, Phi2; --- first compute rmin/rmax. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this arb8. Returns 0 if successfull. void GetPlaneNormal(Double_t* p1, Double_t* p2, Double_t* p3, Double_t* norm); Computes normal to plane defined by P1, P2 and P3. Bool_t GetPointsOnFacet(Int_t , Int_t , Double_t* ) const; Fills array with n random points located on the surface of indexed facet.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation succeeded.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t InsidePolygon(Double_t x, Double_t y, Double_t* pts); Finds if a point in XY plane is inside the polygon defines by PTS. void InspectShape() const; Prints shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. Double_t SafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; Estimate safety to lateral plane defined by segment iseg in range [0,3]; Might be negative: plane seen only from inside. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPlaneVertices(Double_t zpl, Double_t* vertices) const; Computes intersection points between plane at zpl and non-horizontal edges. void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = x0; param[2] = y0. void SetPoints(Double_t* points) const; Creates arb8 mesh points. void SetPoints(Float_t* points) const; Creates arb8 mesh points. void SetVertex(Int_t vnum, Double_t x, Double_t y); Set values for a given vertex. void Sizeof3D() const; Fill size of this 3-D object. void Streamer(TBuffer& ); Stream an object of class TGeoManager. void Contains_v(const Double_t* p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoArb8.html:17188,Safe,Safety,17188,root/html534/TGeoArb8.html,https://root.cern,https://root.cern/root/html534/TGeoArb8.html,3,['Safe'],['Safety']
Safety,"arate names for the wrapper classes in the cases of: [done]; 15 clones/non clones; 16 split/non split; 17 split levels; 18 ; 19 Have a solution for passing top+"".""+middle to the parents classes [probably done .. need testing]; 20 ; 21 Have a solution for the return by references of abstract classes [not done]; 22 ; 23 Have object inside ClonesArray properly treated! [done]; 24 Why is there 2 TRef proxy classes? [done]; 25 ; 26 check why some inheritance are TObjProxy and not TPx_; 27 ; 28 Be smart enough to avoid issue about having 2 classes one unrolled and one non unrolled!; 29 ; 30 When using in interpreted mode understand why the reloading reloads the calling script and then crashes :(; 31 ; 32 CINT does not properly call the custom operators when doing return fNtrack.; 33 ; 34 CINT does not handle fMatrix[2][1] well.; 35 ; 36 The user's function in script.h are not exposed by ACLiC.; 37 ; 38 Review the method to avoid the useless refreshing of the generated file; 39 - for most efficiency it would require a different name for each tree; 40*/; 41 ; 42#include ""TTreeProxyGenerator.h""; 43 ; 44#include ""TFriendProxyDescriptor.h""; 45#include ""TBranchProxyDescriptor.h""; 46#include ""TBranchProxyClassDescriptor.h""; 47 ; 48#include ""TList.h""; 49#include ""Varargs.h""; 50#include <cstdio>; 51 ; 52class TTree;; 53class TBranch;; 54class TStreamerElement;; 55 ; 56#include ""TClass.h""; 57#include ""TClassEdit.h""; 58#include ""TClonesArray.h""; 59#include ""TError.h""; 60#include ""TROOT.h""; 61#include ""TObjString.h""; 62 ; 63#include ""TTreeFormula.h""; 64#include ""TFormLeafInfo.h""; 65 ; 66#include ""TBranchElement.h""; 67#include ""TChain.h""; 68#include ""TFile.h""; 69#include ""TFriendElement.h""; 70#include ""TLeaf.h""; 71#include ""TLeafC.h""; 72#include ""TTree.h""; 73#include ""TVirtualStreamerInfo.h""; 74#include ""TStreamerElement.h""; 75#include ""TSystem.h""; 76#include ""TLeafObject.h""; 77#include ""TVirtualCollectionProxy.h""; 78 ; 79void Debug(Int_t level, const char *va_(fmt), ...); 80{; 81 // ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:1624,avoid,avoid,1624,doc/master/TTreeProxyGenerator_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html,1,['avoid'],['avoid']
Safety,"arch. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; Â» MATH; Â» MATHCORE; Â» ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods); Â Â Â Â Â This is an abstract class, constructors will not be documented.; Â Â Â Â Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). Â» Author: L. Moneta Tue Nov 14 14:20:07 2006 Â» Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; Â» Last changed: root/mathcore:$Id: IParamFunction.h 27272 2009-01-28 09:03:03Z moneta $ Â» Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IBaseParam.html:1661,avoid,avoid,1661,root/html526/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,"arch. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; Â» MATH; Â» MATHCORE; Â» ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods); Â Â Â Â Â This is an abstract class, constructors will not be documented.; Â Â Â Â Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). Â» Author: L. Moneta Tue Nov 14 14:20:07 2006 Â» Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; Â» Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ Â» Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IBaseParam.html:1661,avoid,avoid,1661,root/html528/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IBaseParam.html,1,['avoid'],['avoid']
Safety,"arded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFumili.html:23622,predict,predict,23622,root/html528/TFumili.html,https://root.cern,https://root.cern/root/html528/TFumili.html,6,['predict'],['predict']
Safety,"are designed to optimize particle transport through complex geometries, working in correlation with simulation packages such as GEANT3, GEANT4 and FLUKA. Quick Start: Creating the world; Example 1: Creating the World; Example 2: A Geometrical Hierarchy Look and Feel. Selecting the System of Units in ROOT; Geometry Creation; The Volume Hierarchy; Creating and Positioning Volumes; Making Volumes; Example of Volume Creation; Positioned Volumes (Nodes); Virtual Containers and Assemblies of Volumes; Examples of Volume Positioning; Overlapping Volumes; Replicating Volumes; Volume Families; Dividing Volumes; Volume Assemblies. Geometrical Transformations; Matrix Creation Example; Rule for Creation of Transformations; Available Geometrical Transformations. Ownership of Geometry Objects. Navigation and Tracking; TGeoNavigator Class; Initializing the Starting Point; Initializing the Direction; Initializing the State; Checking the Current State; Saving and Restoring the Current State; Navigation Queries; Finding If Current State Is Changed For a New Point; Finding the Distance to the Next Boundary; Computing the Safe Radius; Making a Step; The Normal Vector to the Next Crossed Surface at Crossing Point. Creating and Visualizing Tracks. Checking the Geometry; The Overlap Checker; Graphical Checking Methods. The Drawing Package; Drawing Volumes and Hierarchies of Volumes; Visualization Settings and Attributes; Colors and Line Styles; Visibility Settings. Ray Tracing; Clipping Ray-traced Images. Representing Misalignments of the Ideal Geometry; Physical Nodes. Geometry I/O; GDML. Navigation Algorithms; Finding the State Corresponding to a Location (x,y,z); Finding the Distance to Next Crossed Boundary; Output Values. Geometry Graphical User Interface; Editing a Geometry; The Geometry Manager Editor; Editing Existing Objects; Creation of New Objects; Editing Volumes; How to Create a Valid Geometry with Geometry Editors. Quick Start: Creating the ""world""; This chapter will provide ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:1571,Safe,Safe,1571,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['Safe'],['Safe']
Safety,"are handled by the manager class.; However, shape-related queries might be sometimes usefull. A) Bool_t TGeoShape::Contains(const Double_t *point[3]); - this method returns true if POINT is actually inside the shape. The point; has to be defined in the local shape reference. For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(const Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside). - returns director cosines of normal to the crossed sha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShape.html:4490,safe,safe,4490,root/html534/TGeoShape.html,https://root.cern,https://root.cern/root/html534/TGeoShape.html,3,['safe'],['safe']
Safety,"are(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; static Bool_tContains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoBBox.html:3821,safe,safe,3821,root/html528/TGeoBBox.html,https://root.cern,https://root.cern/root/html528/TGeoBBox.html,3,['safe'],['safe']
Safety,"ariable, UInt_t *variableMap, UInt_t &nVars); Â ; virtual DecisionTreeNode *Â GetRoot () const; Â ; Double_tÂ GetSumWeights (const EventConstList *validationSample) const; Â calculate the normalization factor for a pruning validation sample ; Â ; Int_tÂ GetTreeID (); Â ; std::vector< Double_t >Â GetVariableImportance (); Â Return the relative variable importance, normalized to all variables together having the importance 1. ; Â ; Double_tÂ GetVariableImportance (UInt_t ivar); Â returns the relative importance of variable ivar ; Â ; virtual TClass *Â IsA () const; Â ; voidÂ PruneNode (TMVA::DecisionTreeNode *node); Â prune away the subtree below the node ; Â ; voidÂ PruneNodeInPlace (TMVA::DecisionTreeNode *node); Â prune a node temporarily (without actually deleting its descendants which allows testing the pruned tree quality for many different pruning stages without ""touching"" the tree. ; Â ; Double_tÂ PruneTree (const EventConstList *validationSample=nullptr); Â prune (get rid of internal nodes) the Decision tree to avoid overtraining several different pruning methods can be applied as selected by the variable ""fPruneMethod"". ; Â ; voidÂ SetAnalysisType (Types::EAnalysisType t); Â ; voidÂ SetMinLinCorrForFisher (Double_t min); Â ; voidÂ SetNodePurityLimit (Double_t p); Â ; voidÂ SetNVars (Int_t n); Â ; voidÂ SetParentTreeInNodes (Node *n=nullptr); Â descend a tree to find all its leaf nodes, fill max depth reached in the tree at the same time. ; Â ; voidÂ SetPruneMethod (EPruneMethod m=kCostComplexityPruning); Â ; voidÂ SetPruneStrength (Double_t p); Â ; voidÂ SetTreeID (Int_t treeID); Â ; voidÂ SetUseExclusiveVars (Bool_t t=kTRUE); Â ; voidÂ SetUseFisherCuts (Bool_t t=kTRUE); Â ; virtual voidÂ Streamer (TBuffer &); Â ; voidÂ StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b); Â ; Double_tÂ TestPrunedTreeQuality (const DecisionTreeNode *dt=nullptr, Int_t mode=0) const; Â return the misclassification rate of a pruned tree a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at any node, hence t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html:6519,avoid,avoid,6519,doc/master/classTMVA_1_1DecisionTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html,1,['avoid'],['avoid']
Safety,"aries. Function documentation; void Paint(Option_t* option); Paint method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. Â» Author: Andrei Gheata 30/05/02 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: :$Id: TGeoBoolNode.h 41234 2011-10-06 15:48:52Z agheata $ Â» Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoUnion.html:9154,safe,safe,9154,root/html532/TGeoUnion.html,https://root.cern,https://root.cern/root/html532/TGeoUnion.html,3,"['Safe', 'safe']","['Safety', 'safe', 'safety']"
Safety,"as R__DEPRECATED(6,04, ""Not threadsafe; use TFoo::Bar()."") */; 504#define R__DEPRECATED(MAJOR, MINOR, REASON) \; 505 _R__JOIN3_(_R__DEPRECATED_,MAJOR,MINOR)(""will be removed in ROOT v"" #MAJOR ""."" #MINOR "": "" REASON); 506 ; 507/* Mechanisms to advise users to avoid legacy functions and classes that will not be removed */; 508#if defined R__SUGGEST_NEW_INTERFACE; 509# define R__SUGGEST_ALTERNATIVE(ALTERNATIVE) \; 510 _R__DEPRECATED_LATER(""There is a superior alternative: "" ALTERNATIVE); 511#else; 512# define R__SUGGEST_ALTERNATIVE(ALTERNATIVE); 513#endif; 514 ; 515#define R__ALWAYS_SUGGEST_ALTERNATIVE(ALTERNATIVE) \; 516 _R__DEPRECATED_LATER(""There is a superior alternative: "" ALTERNATIVE); 517 ; 518 ; 519 ; 520/*---- misc ------------------------------------------------------------------*/; 521 ; 522#ifdef R__GNU; 523# define SafeDelete(p) { if (p) { delete p; p = nullptr; } }; 524#else; 525# define SafeDelete(p) { delete p; p = nullptr; }; 526#endif; 527 ; 528#ifdef __FAST_MATH__; 529#define R__FAST_MATH; 530#endif; 531 ; 532#if (__GNUC__ >= 7); 533#define R__DO_PRAGMA(x) _Pragma (#x); 534# define R__INTENTIONALLY_UNINIT_BEGIN \; 535 R__DO_PRAGMA(GCC diagnostic push) \; 536 R__DO_PRAGMA(GCC diagnostic ignored ""-Wmaybe-uninitialized"") \; 537 R__DO_PRAGMA(GCC diagnostic ignored ""-Wuninitialized""); 538# define R__INTENTIONALLY_UNINIT_END \; 539 R__DO_PRAGMA(GCC diagnostic pop); 540#else; 541# define R__INTENTIONALLY_UNINIT_BEGIN; 542# define R__INTENTIONALLY_UNINIT_END; 543 ; 544#endif; 545 ; 546#ifdef R__HAS_ATTRIBUTE_ALWAYS_INLINE; 547#define R__ALWAYS_INLINE inline __attribute__((always_inline)); 548#else; 549#if defined(_MSC_VER); 550#define R__ALWAYS_INLINE __forceinline; 551#else; 552#define R__ALWAYS_INLINE inline; 553#endif; 554#endif; 555 ; 556// See also https://nemequ.github.io/hedley/api-reference.html#HEDLEY_NEVER_INLINE; 557// for other platforms.; 558#ifdef R__HAS_ATTRIBUTE_NOINLINE; 559#define R__NEVER_INLINE inline __attribute__((noinline)); 560#else; 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RConfig_8hxx_source.html:13991,avoid,avoid,13991,doc/master/RConfig_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RConfig_8hxx_source.html,3,"['Safe', 'avoid']","['SafeDelete', 'avoid']"
Safety,"as not been implemented yet. ""; 237 ""Please use Architecture=CPU or Architecture=CPU for the ""; 238 ""time being. See the TMVA Users' Guide for instructions ""; 239 ""if you encounter problems.""; 240 << Endl;; 241 // use instead GPU; 242 Log() << kINFO << ""We will try using the GPU-CUDA architecture if available"" << Endl;; 243 fArchitectureString = ""GPU"";; 244 }; 245 ; 246 // the architecture can now be set at runtime as an option; 247 ; 248 ; 249 if (fArchitectureString == ""GPU"" || fArchitectureString == ""CUDNN"") {; 250#ifdef R__HAS_TMVAGPU; 251 Log() << kINFO << ""Will now use the GPU architecture !"" << Endl;; 252#else // case TMVA does not support GPU; 253 Log() << kERROR << ""CUDA backend not enabled. Please make sure ""; 254 ""you have CUDA installed and it was successfully ""; 255 ""detected by CMAKE by using -Dtmva-gpu=On ""; 256 << Endl;; 257 fArchitectureString = ""CPU"";; 258 Log() << kINFO << ""Will now use instead the CPU architecture !"" << Endl;; 259#endif; 260 }; 261 ; 262 if (fArchitectureString == ""CPU"") {; 263#ifdef R__HAS_TMVACPU // TMVA has CPU BLAS and IMT support; 264 Log() << kINFO << ""Will now use the CPU architecture with BLAS and IMT support !"" << Endl;; 265#else // TMVA has no CPU BLAS or IMT support; 266 Log() << kINFO << ""Multi-core CPU backend not enabled. For better performances, make sure ""; 267 ""you have a BLAS implementation and it was successfully ""; 268 ""detected by CMake as well that the imt CMake flag is set.""; 269 << Endl;; 270 Log() << kINFO << ""Will use anyway the CPU architecture but with slower performance"" << Endl;; 271#endif; 272 }; 273 ; 274 // Input Layout; 275 ParseInputLayout();; 276 ParseBatchLayout();; 277 ; 278 // Loss function and output.; 279 fOutputFunction = EOutputFunction::kSigmoid;; 280 if (fAnalysisType == Types::kClassification) {; 281 if (fErrorStrategy == ""SUMOFSQUARES"") {; 282 fLossFunction = ELossFunction::kMeanSquaredError;; 283 }; 284 if (fErrorStrategy == ""CROSSENTROPY"") {; 285 fLossFunction = ELossFunction::kCros",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:9421,detect,detected,9421,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['detect'],['detected']
Safety,"asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); Double_t&TGeoPcon::Phi1(); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); Double_t&TGeoPcon::Rmax(Int_t ipl); Double_t&TGeoPcon::Rmin(Int_t ipl); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToSegment(const Double_t* point, Int_t ipl, Int_t iphi, Bool_t in, Double_t safphi, Double_t safmin = TGeoShape::Big()) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPgon.html:9249,safe,safe,9249,root/html534/TGeoPgon.html,https://root.cern,https://root.cern/root/html534/TGeoPgon.html,1,['safe'],['safe']
Safety,"asUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. const TH2D*fAdetDetector response matrix; TH2D*fBcovcovariance matrix of measured distribution (data); const TH1D*fBdatmeasured distribution (data); const TH1D*fBinireconstructed distribution (MC); TH1D*fDHist! Distribution of d (for checking regularization); Int_tfDdim! Derivative for curvature matrix; Int_tfKReg! Regularisation parameter; Bool_tfMatToyMode! Internal switch for evaluation of statistical uncertainties from response matrix; Int_tfNdim! Truth and reconstructed dimensions; Bool_tfNormalize! Normalize unfolded spectrum to 1; TH1D*fSVHist! Distribution of singular values; Bool_tfToyMode! Internal switch for covariance matrix propagation; TH1D*fToyhisto! Toy MC histogram; TH2D*fToymat! Toy MC detector response matrix; const TH1D*fXinitruth distribution (MC); TH2D*fXinv! Computed inverse of covariance matrix; TH2D*fXtau! Computed regularized covariance matrix. Class Charts. Inheritance Chart:. TObject. â†; TSVDUnfold. Function documentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Alternative constructor; User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. TSVDUnfold(const TH1D* bdat, TH2D* Bcov, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor; Initialisation of TSVDUnfold; User provides data and MC test spectra, as w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSVDUnfold.html:10299,detect,detector,10299,root/html602/TSVDUnfold.html,https://root.cern,https://root.cern/root/html602/TSVDUnfold.html,2,['detect'],['detector']
Safety,"ase* method, Double_t aux = 0); evaluates the MVA. const std::vector< Float_t >& EvaluateRegression(const TString& methodTag, Double_t aux = 0); evaluates MVA for given set of input variables. const std::vector< Float_t >& EvaluateRegression(TMVA::MethodBase* method, Double_t aux = 0); evaluates the regression MVA. Float_t EvaluateRegression(UInt_t tgtNumber, const TString& methodTag, Double_t aux = 0); evaluates the regression MVA. const std::vector< Float_t >& EvaluateMulticlass(const TString& methodTag, Double_t aux = 0); evaluates MVA for given set of input variables. const std::vector< Float_t >& EvaluateMulticlass(TMVA::MethodBase* method, Double_t aux = 0); evaluates the multiclass MVA. Float_t EvaluateMulticlass(UInt_t clsNumber, const TString& methodTag, Double_t aux = 0); evaluates the multiclass MVA. TMVA::IMethod* FindMVA(const TString& methodTag); return pointer to method with tag ""methodTag"". TMVA::MethodCuts* FindCutsMVA(const TString& methodTag); special function for Cuts to avoid dynamic_casts in ROOT macros,; which are not properly handled by CINT. Double_t GetProba(const TString& methodTag, Double_t ap_sig = 0.5, Double_t mvaVal = -9999999); evaluates probability of MVA for given set of input variables. Double_t GetRarity(const TString& methodTag, Double_t mvaVal = -9999999); evaluates the MVA's rarity. void DecodeVarNames( const std::string& varNames ); decodes ""name1:name2:..."" form. void DecodeVarNames(const TString& varNames); decodes ""name1:name2:..."" form. Double_t GetMVAError() const; returns error on MVA response for given event; NOTE: must be called AFTER ""EvaluateMVA(...)"" call !. { return fMvaEventError; }. Double_t GetMVAErrorLower() const; { return fMvaEventError; }. Double_t GetMVAErrorUpper() const; { return fMvaEventErrorUpper; }. const char* GetName() const; accessors. { return ""Reader""; }. Bool_t Verbose( void ); { return fVerbose; }. void SetVerbose(Bool_t v); { fVerbose = v; }. const DataSetInfo& DataInfo() const; { return fData",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__Reader.html:14028,avoid,avoid,14028,root/html528/TMVA__Reader.html,https://root.cern,https://root.cern/root/html528/TMVA__Reader.html,3,['avoid'],['avoid']
Safety,"aseFunctionMultiDimTempl< T >; typedef TÂ BackendType; Â ; typedef IBaseFunctionMultiDimTempl< T >Â BaseFunc; Â . Public Member Functions; TÂ operator() (const T *x) const; Â ; TÂ operator() (const T *x, const double *p) const; Â Evaluate function at a point x and for given parameters p. ; Â ; Â Public Member Functions inherited from ROOT::Math::IBaseFunctionMultiDimTempl< T >; virtualÂ ~IBaseFunctionMultiDimTempl ()=default; Â ; virtual IBaseFunctionMultiDimTempl< T > *Â Clone () const =0; Â Clone a function. ; Â ; virtual boolÂ HasGradient () const; Â ; virtual unsigned intÂ NDim () const =0; Â Retrieve the dimension of the function. ; Â ; TÂ operator() (const T *x) const; Â Evaluate the function at a point x[]. ; Â ; Â Public Member Functions inherited from ROOT::Math::IBaseParam; virtualÂ ~IBaseParam (); Â Virtual Destructor (no operations) ; Â ; virtual unsigned intÂ NPar () const =0; Â Return the number of Parameters. ; Â ; virtual std::stringÂ ParameterName (unsigned int i) const; Â Return the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default name (""Par_0, Par_1, ..."") ; Â ; virtual const double *Â Parameters () const =0; Â Access the parameter values. ; Â ; virtual voidÂ SetParameters (const double *p)=0; Â Set the parameter values. ; Â . Private Member Functions; virtual TÂ DoEval (const T *x) const; Â Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. ; Â ; virtual TÂ DoEvalPar (const T *x, const double *p) const =0; Â Implementation of the evaluation function using the x values and the parameters. ; Â . #include <Math/IParamFunction.h>. Inheritance diagram for ROOT::Math::IParametricFunctionMultiDimTempl< T >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. â—†Â BaseFunc. template<class T > . typedef IBaseFunctionMultiDimTempl<T> ROOT::Math::IParametricFunctionMultiDimTempl< T >::BaseFunc. Definition at line 111 of file IParamFunction.h. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricFunctionMultiDimTempl.html:2032,avoid,avoid,2032,doc/master/classROOT_1_1Math_1_1IParametricFunctionMultiDimTempl.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricFunctionMultiDimTempl.html,1,['avoid'],['avoid']
Safety,"askets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect.; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 527 of file TROOT.cxx. â—†Â EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:24444,safe,safe,24444,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,1,['safe'],['safe']
Safety,"askets, buffers and entries count in all branches and leaves. ; Â ; virtual voidÂ ResetAfterMerge (TFileMergeInfo *); Â Resets the state of this TTree after a merge (keep the customization but forget the data). ; Â ; virtual voidÂ ResetBranchAddress (TBranch *); Â Tell all of our branches to set their addresses to zero. ; Â ; virtual voidÂ ResetBranchAddresses (); Â Tell all of our branches to drop their current objects and allocate new ones. ; Â ; virtual Long64_tÂ Scan (const char *varexp="""", const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0); Â Loop over tree entries and print entries passing selection. ; Â ; virtual boolÂ SetAlias (const char *aliasName, const char *aliasFormula); Â Set a tree variable alias. ; Â ; virtual voidÂ SetAutoFlush (Long64_t autof=-30000000); Â This function may be called at the start of a program to change the default value for fAutoFlush. ; Â ; virtual voidÂ SetAutoSave (Long64_t autos=-300000000); Â In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point. ; Â ; virtual voidÂ SetBasketSize (const char *bname, Int_t buffsize=16000); Â Set a branch's basket size. ; Â ; template<class T > ; Int_tÂ SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr); Â ; template<class T > ; Int_tÂ SetBranchAddress (const char *bname, T *add, TBranch **ptr=nullptr); Â ; virtual Int_tÂ SetBranchAddress (const char *bname, void *add, TBranch **ptr, TClass *realClass, EDataType datatype, bool isptr); Â Verify the validity of the type of addr before calling SetBranchAddress. ; Â ; virtual Int_tÂ SetBranchAddress (const char *bname, void *add, TBranch **ptr=nullptr); Â Change branch address, dealing with clone trees properly. ; Â ; virtual Int_tÂ SetBranchAddress (const char *bname, void *add, TClass *realClass, EDataType datatype, bool isptr); Â Verify the validity of the type of addr before calling SetBranchAddress. ; Â ; virtual voidÂ SetBranchStatus (const char *bname, bool s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHbookTree.html:20117,recover,recover,20117,doc/master/classTHbookTree.html,https://root.cern,https://root.cern/doc/master/classTHbookTree.html,4,['recover'],['recover']
Safety,"ass = 0, . Double_tÂ ; span = 0, . Bool_tÂ ; isPeriodic = kFALSE, . Double_t *Â ; w = nullptrÂ . ). Smooth data with Super smoother. ; Smooth the (x, y) values by Friedman's `â€˜super smootherâ€™'.; Parameters. [in]gringraph for smoothing ; [in]optionspecific options ; [in]spanthe fraction of the observations in the span of the running lines smoother, or 0 to choose this by leave-one-out cross-validation. ; [in]basscontrols the smoothness of the fitted curve. Values of up to 10 indicate increasing smoothness. ; [in]isPeriodicif TRUE, the x values are assumed to be in [0, 1] and of period 1. ; [in]wcase weights. Details:; supsmu is a running lines smoother which chooses between three spans for the lines. The running lines smoothers are symmetric, with k/2 data points each side of the predicted point, and values of k as 0.5 * n, 0.2 * n and 0.05 * n, where n is the number of data points. If span is specified, a single smoother with span span * n is used.; The best of the three smoothers is chosen by cross-validation for each prediction. The best spans are then smoothed by a running lines smoother and the final prediction chosen by linear interpolation.; The FORTRAN code says: `â€˜For small samples (n < 40) or if there are substantial serial correlations between observations close in x - value, then a prespecified fixed span smoother (span > 0) should be used. Reasonable span values are 0.2 to 0.4.â€™'; References:; Friedman, J. H. (1984) SMART User's Guide. Laboratory for Computational Statistics, Stanford University Technical Report No. 1.; Friedman, J. H. (1984) A variable span scatterplot smoother. Laboratory for Computational Statistics, Stanford University Technical Report No. 5. . Definition at line 479 of file TGraphSmooth.cxx. â—†Â Streamer(). void TGraphSmooth::Streamer ; (; TBuffer &Â ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. â—†Â StreamerNVirtual(). void TGraphSmooth::StreamerNVirtual ; (; TBuffer &Â ; ClassDef_StreamerNVirtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphSmooth.html:26374,predict,prediction,26374,doc/master/classTGraphSmooth.html,https://root.cern,https://root.cern/doc/master/classTGraphSmooth.html,1,['predict'],['prediction']
Safety,"ass Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFilePrefetch(TFile* ); Constructor. ~TFilePrefetch(); Destructor. void WaitFinishPrefetch(); Killing the async prefetching thread. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file; When prefetching is enabled we also need to:; - make sure the async thread is not doing any work; - clear all blocks from prefetching and read list; - reset the file pointer. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). TCondition* GetCondNewBlock() const; { return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFilePrefetch.html:7634,Safe,Safe,7634,root/html534/TFilePrefetch.html,https://root.cern,https://root.cern/root/html534/TFilePrefetch.html,3,['Safe'],['Safe']
Safety,"ass ROOT::Math::RanluxppEngine< p >Implementation of the RANLUX++ generator. ; RANLUX++ is an LCG equivalent of RANLUX using 576 bit numbers.; The idea of the generator (such as the initialization method) and the algorithm for the modulo operation are described in A. Sibidanov, A revision of the subtract-with-borrow random numbergenerators, Computer Physics Communications*, 221(2017), 299-303, preprint https://arxiv.org/pdf/1705.03123.pdf; The code is loosely based on the Assembly implementation by A. Sibidanov available at https://github.com/sibidanov/ranluxpp/.; Compared to the original generator, this implementation contains a fix to ensure that the modulo operation of the LCG always returns the smallest value congruent to the modulus (based on notes by M. LÃ¼scher). Also, the generator converts the LCG state back to RANLUX numbers (implementation based on notes by M. LÃ¼scher). This avoids a bias in the generated numbers because the upper bits of the LCG state, that is smaller than the modulus \( m = 2^{576} - 2^{240} + 1 \) (not a power of 2!), have a higher probability of being 0 than 1. And finally, this implementation draws 48 random bits for each generated floating point number (instead of 52 bits as in the original generator) to maintain the theoretical properties from understanding the original transition function of RANLUX as a chaotic dynamical system. ; Definition at line 27 of file RanluxppEngine.h. Public Member Functions; Â RanluxppEngine (uint64_t seed=314159265); Â ; Â ~RanluxppEngine () override; Â ; uint64_tÂ IntRndm (); Â Generate a random integer value with 48 bits. ; Â ; doubleÂ operator() (); Â Generate a double-precision random number (non-virtual method) ; Â ; doubleÂ Rndm () override; Â Generate a double-precision random number with 48 bits of randomness. ; Â ; voidÂ SetSeed (uint64_t seed); Â Initialize and seed the state of the generator. ; Â ; voidÂ Skip (uint64_t n); Â Skip n random numbers without generating them. ; Â ; Â Public Member Functions inherited",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1RanluxppEngine.html:1274,avoid,avoids,1274,doc/master/classROOT_1_1Math_1_1RanluxppEngine.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1RanluxppEngine.html,1,['avoid'],['avoids']
Safety,"ass. Bool_t MakeBranch(const char* expr, Bool_t left); Expands the boolean expression either on left or right branch, creating; component elements (composite shapes and boolean nodes). Returns true on success. void Paint(Option_t* option); Special schema for feeding the 3D buffers to the painter client. void RegisterMatrices(); Register all matrices of the boolean node and descendents. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; Fill buffer with shape vertices. void SetPoints(Float_t* points) const; Fill buffer with shape vertices. void Sizeof3D() const; Register size of this 3D object. TGeoBoolNode& operator=(const TGeoBoolNode& ). void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); methods. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm). Bool_t Contains(Double_t* point) const. Int_t DistanceToPrimitive(Int_t px, Int_t py). Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const. EGeoBoolType GetBooleanOperator() const. Int_t GetNpoints(). TGeoMatrix * GetLeftMatrix() const; {return fLeftMat;}. TGeoMatrix * GetRightMatrix() const; {return fRightMat;}. TGeoShape * GetLeftShape() const; {return fLeft;}. TGeoShape * GetRightShape() const; {return fRight;}. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const. void SetSelected(Int_t sel); {fSelected = sel;}. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; {return kGeoUnion;}. Â» Author: Andrei Gheata 30/05/02 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ Â» Last generated: 2010-12-10 11:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoBoolNode.html:8666,safe,safe,8666,root/html528/TGeoBoolNode.html,https://root.cern,https://root.cern/root/html528/TGeoBoolNode.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"ass. Bool_t MakeBranch(const char* expr, Bool_t left); Expands the boolean expression either on left or right branch, creating; component elements (composite shapes and boolean nodes). Returns true on success. void Paint(Option_t* option); Special schema for feeding the 3D buffers to the painter client. void RegisterMatrices(); Register all matrices of the boolean node and descendents. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; Fill buffer with shape vertices. void SetPoints(Float_t* points) const; Fill buffer with shape vertices. void Sizeof3D() const; Register size of this 3D object. TGeoBoolNode& operator=(const TGeoBoolNode& ). void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); methods. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm). Bool_t Contains(Double_t* point) const. Int_t DistanceToPrimitive(Int_t px, Int_t py). Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const. EGeoBoolType GetBooleanOperator() const. Int_t GetNpoints(). TGeoMatrix * GetLeftMatrix() const; {return fLeftMat;}. TGeoMatrix * GetRightMatrix() const; {return fRightMat;}. TGeoShape * GetLeftShape() const; {return fLeft;}. TGeoShape * GetRightShape() const; {return fRight;}. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const. void SetSelected(Int_t sel); {fSelected = sel;}. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; {return kGeoUnion;}. Â» Author: Andrei Gheata 30/05/02 Â» Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; Â» Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ Â» Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoBoolNode.html:8766,safe,safe,8766,root/html530/TGeoBoolNode.html,https://root.cern,https://root.cern/root/html530/TGeoBoolNode.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"ass. Later in this section is an example that compares disk space, memory usage, and I/O times of C++ pointers and TRefs. In general, a TRef is faster than C++ but the advantage of a C++ pointer is that it is already C++.; 11.4.1 Streaming C++ Pointers; When ROOT encounters a pointer data member it calls the Streamer of the object and labels it with a unique object identifier. The object identifier is unique for one I/O operation. If there is another pointer to the object in the same I/O operation, the first object is referenced i.e.Â it is not saved again. When reading the file, the object is rebuilt and the references recalculated. Streaming object pointers. In this way, the network of pointers and their objects is rebuilt and ready to use the same way it was used before it was persistent. If the pointer hold the address of an object which in embedded in another object (as opposed to being pointed to by a pointer), the object will be duplicate at read time. To avoid this, make the pointer a transient data member.; 11.4.2 Motivation for the TRef Class; If the object is split into several files or into several branches of one or more TTrees, standard C++ pointers cannot be used because each I/O operation will write the referenced objects, and multiple copies will exist. In addition, if the pointer is read before the referenced object, it is null and may cause a run time system error. To address these limitations, ROOT offers the TRef class.; TRef allows referencing an object in a different branch and/or in a different file. TRef also supports the complex situation where a TFile is updated multiple times on the same machine or a different machine. When a TRef is read before its referenced object, it is null. As soon as the referenced object is read, the TRef points to it. In addition, one can specify an action to be taken by TRef in the case it is read before its reference object (seeâ€œAction on Demandâ€ below).; 11.4.3 Using TRef; A TRef is a lightweight object pointing",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:479631,avoid,avoid,479631,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety,"ass. Swiches perspective or orthographic camera.; TEveLine An arbitrary polyline with fixed line and marker attributes.; TEveLineEditor Editor for TEveLine class.; TEveLineGL GL-renderer for TEveLine class.; TEveLineProjected Projected replica of a TEveLine.; TEveListTreeItem Special llist-tree-item for Eve.; TEveMCRecCrossRef Cross-reference of sim/rec data per particle (also used in VSD).; TEveMCTrack Monte Carlo track (also used in VSD).; TEveMacro TMacro wrapper (attempting to fix issues with different macro loading and execution schemes).; TEveMagField Abstract interface to magnetic field; TEveMagFieldConst Interface to constant magnetic field.; TEveMagFieldDuo Interface to magnetic field with two different values depending of radius.; TEveManager Eve application manager.; TEveManager::TExceptionHandler Exception handler for Eve exceptions.; TEvePad Internal TEveUtil pad class (sub-class of TPad) overriding handling of updates and 3D-viewers.; TEvePadHolder Exception-safe wrapper for temporary setting of gPad variable.; TEveParamList Eve element to store generic configuration information.; TEveParamList::BoolConfig_t ; TEveParamList::FloatConfig_t ; TEveParamList::IntConfig_t ; TEveParamListEditor GUI editor for TEveParamList.; TEvePathMark Special-point on track: position/momentum reference, daughter creation or decay (also used in VSD).; TEvePointSelector TSelector for direct extraction of point-like data from a Tree.; TEvePointSelectorConsumer Virtual base for classes that can be filled from TTree data via the TEvePointSelector class.; TEvePointSet Set of 3D points with same marker attributes; optionally each point can be assigned an external TRef or a number of integer indices.; TEvePointSetArray Array of TEvePointSet's filled via a common point-source; range of displayed TEvePointSet's can be controlled, based on a separating quantity provided on fill-time by a user.; TEvePointSetArrayEditor Editor for TEvePointSetArray class.; TEvePointSetProjected Projec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:59246,safe,safe,59246,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['safe'],['safe']
Safety,"ast<TDirectoryFile*>(tobj);; 982 dir->SetName(GetName());; 983 dir->SetTitle(GetTitle());; 984 dir->SetMother(fMotherDir);; 985 fMotherDir->Append(dir);; 986 }; 987 ; 988 // Append the object to the directory if requested:; 989 {; 990 ROOT::DirAutoAdd_t addfunc = cl->GetDirectoryAutoAdd();; 991 if (addfunc) {; 992 addfunc(pobj, fMotherDir);; 993 }; 994 }; 995 ; 996 return tobj;; 997}; 998 ; 999////////////////////////////////////////////////////////////////////////////////; 1000/// To read an object (non deriving from TObject) from the file.; 1001///; 1002/// If expectedClass is not null, we checked that that actual class of the; 1003/// object stored is suitable to be stored in a pointer pointing to an object; 1004/// of class 'expectedClass'. We also adjust the value of the returned address; 1005/// so that it is suitable to be cast (C-Style); 1006/// a pointer pointing to an object of class 'expectedClass'.; 1007///; 1008/// So for example if the class Bottom inherits from Top and the object; 1009/// stored is of type Bottom you can safely do:; 1010/// ~~~{.cpp}; 1011/// auto TopClass = TClass::GetClass(""Top"");; 1012/// auto ptr = (Top*) key->ReadObjectAny( TopClass );; 1013/// if (ptr==0) printError(""the object stored in the key is not of the expected type\n"");; 1014/// ~~~; 1015/// The object associated to this key is read from the file into memory.; 1016/// Once the key structure is read (via Streamer) the class identifier; 1017/// of the object is known.; 1018/// Using the class identifier we find the TClass object for this class.; 1019/// A TClass object contains a full description (i.e. dictionary) of the; 1020/// associated class. In particular the TClass object can create a new; 1021/// object of the class type it describes. This new object now calls its; 1022/// Streamer function to rebuilt itself.; 1023 ; 1024void *TKey::ReadObjectAny(const TClass* expectedClass); 1025{; 1026 TBufferFile bufferRef(TBuffer::kRead, fObjlen+fKeylen);; 1027 if (!bufferRef.B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:35859,safe,safely,35859,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,1,['safe'],['safely']
Safety,"astObject (const TObject *obj, Int_t kind=kMESS_OBJECT, ESlaves list=kActive); Â Broadcast an object to all slaves in the specified list. ; Â ; Int_tÂ BroadcastRaw (const void *buffer, Int_t length, ESlaves list=kActive); Â Broadcast a raw buffer of specified length to all slaves in the specified list. ; Â ; Int_tÂ BroadcastRaw (const void *buffer, Int_t length, TList *slaves); Â Broadcast a raw buffer of specified length to all slaves in the specified list. ; Â ; Int_tÂ BuildPackage (const char *package, EBuildPackageOpt opt=kBuildAll, Int_t chkveropt=TPackMgr::kCheckROOT, TList *workers=0); Â Build specified package. ; Â ; Bool_tÂ CheckFile (const char *file, TSlave *sl, Long_t modtime, Int_t cpopt=(kCp|kCpBin)); Â Check if a file needs to be send to the slave. ; Â ; voidÂ CleanGDirectory (TList *ol); Â Remove links to objects in list 'ol' from gDirectory. ; Â ; voidÂ ClearDataProgress (Int_t r, Int_t t); Â Progress bar for clear data. ; Â ; Int_tÂ Collect (const TSlave *sl, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE); Â Collect responses from slave sl. ; Â ; Int_tÂ Collect (TMonitor *mon, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE); Â Collect responses from the slave servers. ; Â ; Int_tÂ CollectInputFrom (TSocket *s, Int_t endtype=-1, Bool_t deactonfail=kFALSE); Â Collect and analyze available input from socket s. ; Â ; Bool_tÂ CreateMerger (TSlave *sl, Int_t port); Â Create a new merger. ; Â ; voidÂ DeActivateAsyncInput (); Â De-activate a-sync input handler. ; Â ; Int_tÂ DisablePackage (const char *package); Â Remove a specific package. ; Â ; Int_tÂ DisablePackages (); Â Remove all packages. ; Â ; Int_tÂ Exec (const char *cmd, ESlaves list, Bool_t plusMaster); Â Send command to be executed on the PROOF master and/or slaves. ; Â ; voidÂ FinalizationDone (); Â ; Int_tÂ FindNextFreeMerger (); Â Return a merger, which is both active and still accepts some workers to be assigned to it. ; Â ; TSlave *Â FindSlave (TSocket *s) const; Â Find slave that has TSocket s. Returns 0 in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:47749,timeout,timeout,47749,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['timeout'],['timeout']
Safety,aster. Reference Guide ; . Â . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; ROOT::Math::BaseIntegratorOptions Class ReferenceabstractMath Â» MathCore | Math Â» MathMore Â» Numerical Algorithms Â» Numerical Integration. ; Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. ; Definition at line 35 of file IntegratorOptions.h. Public Member Functions; Â BaseIntegratorOptions (const BaseIntegratorOptions &opt); Â ; virtualÂ ~BaseIntegratorOptions (); Â protected constructor to avoid user creating this class ; Â ; doubleÂ AbsTolerance () const; Â non-static methods for retrieving options ; Â ; IOptions *Â ExtraOptions () const; Â return extra options ; Â ; virtual std::stringÂ Integrator () const =0; Â name of 1D integrator ; Â ; BaseIntegratorOptions &Â operator= (const BaseIntegratorOptions &opt); Â assignment operators ; Â ; doubleÂ RelTolerance () const; Â absolute tolerance ; Â ; voidÂ SetAbsTolerance (double tol); Â non-static methods for setting options ; Â ; voidÂ SetExtraOptions (const IOptions &opt); Â set extra options (in this case pointer is cloned) ; Â ; voidÂ SetRelTolerance (double tol); Â set the relative tolerance ; Â ; voidÂ SetWKSize (unsigned int size); Â set workspace size ; Â ; unsigned intÂ WKSize () const; Â size of the workspace ; Â . Protected Member Functions; Â BaseIntegratorOptions (); Â protected constructor to avoid user creating this class ; Â ; voidÂ ClearExtra (); Â . Protected Attributes; doubleÂ fAbsTolerance; Â absolute tolerance ; Â ; ROOT::Math::IOptions *Â fExtraOptions; Â ; intÂ fIntegType; Â Integrator type (value converted from enum) ; Â ; unsigned intÂ fNCalls; Â (max) function calls ; Â ; doubleÂ fRelTolerance; Â relative tolerance ; Â ; unsigned intÂ fWKSize; Â workspace size ; Â . #include <Math/IntegratorOptions.h>. Inheritance diagram for ROOT::Math::BaseIntegrator,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html:764,avoid,avoid,764,doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html,1,['avoid'],['avoid']
Safety,"at abstracts out the histogram's PRECISION ; Â â–ºCTSchemaRuleSet; Â CTMatches; Â â–ºNFitNamespace for the fitting classes ; Â CBasicFCNBasicFCN class: base class for the objective functions used in the fits It has a reference to the data and th emodel function used in the fit ; Â CBinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y values and error on coordinates The dimension of the coordinate is free There are 4 different options: ; Â CBinPointObsolete class, no more in use ; Â CChi2FCNChi2FCN class for binnned fits using the least square methods ; Â CDataOptionsDataOptions : simple structure holding the options on how the data are filled ; Â CDataRangeClass describing the range in the coordinates it supports multiple range in a coordinate ; Â CDataVectorClass holding the fit data points ; Â CDataWrapperClass maintaining a pointer to external data Using this class avoids copying the data when performing a fit NOTE: this class is not thread-safe and should not be used in parallel fits ; Â CDummyDeleter; Â CFcnAdapter; Â CFitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::ParameterSettings class ; Â CFitDataBase class for all the fit data types ; Â CFitResultClass containg the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values ; Â CFitterFitter class, entry point for performing all type of fits ; Â CLogLikelihoodFCNLogLikelihoodFCN class for likelihood fits ; Â CParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/retrieve values, step sizes, limits and fix the parameters ; Â CPoissonLikelihoodFCNClass evaluating the log likelihood for binned Poisson likelihood fits it is template to distinguish gradient and non-gradient case ; Â CSparseData;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:12131,safe,safe,12131,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['safe'],['safe']
Safety,"at line 1632 of file TUnixSystem.cxx. â—†Â ResetSignal(). void TUnixSystem::ResetSignal ; (; ESignalsÂ ; sig, . Bool_tÂ ; reset = kTRUEÂ . ). overridevirtual . If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour. ; Reimplemented from TSystem.; Definition at line 875 of file TUnixSystem.cxx. â—†Â ResetSignals(). void TUnixSystem::ResetSignals ; (; ). overridevirtual . Reset signals handlers to previous behaviour. ; Reimplemented from TSystem.; Definition at line 886 of file TUnixSystem.cxx. â—†Â ResetTimer(). void TUnixSystem::ResetTimer ; (; TTimer *Â ; ti). overridevirtual . Reset a-sync timer. ; Reimplemented from TSystem.; Definition at line 3033 of file TUnixSystem.cxx. â—†Â Select() [1/2]. Int_t TUnixSystem::Select ; (; TFileHandler *Â ; h, . Long_tÂ ; toÂ . ). overridevirtual . Select on the file descriptor related to file handler h. ; The timeout to is in millisec. Returns the number of ready descriptors, or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR the errno has been reset and the method can be called again. Returns -4 in case the file handler is 0 or does not have a file descriptor >= 0. ; Reimplemented from TSystem.; Definition at line 1250 of file TUnixSystem.cxx. â—†Â Select() [2/2]. Int_t TUnixSystem::Select ; (; TList *Â ; act, . Long_tÂ ; toÂ . ). overridevirtual . Select on file descriptors. ; The timeout to is in millisec. Returns the number of ready descriptors, or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR the errno has been reset and the method can be called again. Returns -4 in case the list did not contain any file handlers or file handlers with file descriptor >= 0. ; Reimplemented from TSystem.; Definition at line 1202 of file TUnixSystem.cxx. â—†Â SendBuf(). int TUnixSystem::SendBuf ; (; intÂ ; sock, . const void *Â ; buf, . intÂ ; lengthÂ . ). overridevirtual . Send a buffer headed by a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:65209,timeout,timeout,65209,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['timeout'],['timeout']
Safety,"at line 321 of file TClingUtils.h. Enumeration Type Documentation. â—†Â DataMemberInfo__ValidArrayIndex_error_code. enum ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex_error_code. EnumeratorVALIDÂ ; NOT_INTÂ ; NOT_DEFÂ ; IS_PRIVATEÂ ; UNKNOWNÂ . Definition at line 118 of file TClingUtils.h. â—†Â EIOCtorCategory. enum class ROOT::TMetaUtils::EIOCtorCategory : short. strong . EnumeratorkAbsentÂ ; kDefaultÂ ; kIOPtrTypeÂ ; kIORefTypeÂ . Definition at line 359 of file TClingUtils.h. Function Documentation. â—†Â AddDefaultParameters(). clang::QualType ROOT::TMetaUtils::AddDefaultParameters ; (; clang::QualTypeÂ ; instanceType, . const cling::Interpreter &Â ; interpreter, . const TNormalizedCtxt &Â ; normCtxtÂ . ). Add any unspecified template parameters to the class template instance, mentioned anywhere in the type. ; Note: this does not strip any typedef but could be merged with cling::utils::Transform::GetPartiallyDesugaredType if we can safely replace TClassEdit::IsStd with a test on the declaring scope and if we can resolve the fact that the added parameter do not take into account possible use/dependences on Double32_t and if we decide that adding the default is the right long term solution or not. Whether it is or not depend on the I/O on whether the default template argument might change or not and whether they (should) affect the on disk layout (for STL containers, we do know they do not). ; Definition at line 2852 of file TClingUtils.cxx. â—†Â BeginsWith(). bool ROOT::TMetaUtils::BeginsWith ; (; const std::string &Â ; theString, . const std::string &Â ; theSubstringÂ . ). Definition at line 5088 of file TClingUtils.cxx. â—†Â CheckConstructor(). ROOT::TMetaUtils::EIOCtorCategory ROOT::TMetaUtils::CheckConstructor ; (; const clang::CXXRecordDecl *Â ; cl, . const RConstructorType &Â ; ioctortype, . const cling::Interpreter &Â ; interpÂ . ). Check if class has constructor of provided type - either default or with single argument. ; Definition at line 1079 of file TClingUtils.cxx. â—†Â CheckDefaultCons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1TMetaUtils.html:19901,safe,safely,19901,doc/v632/namespaceROOT_1_1TMetaUtils.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1TMetaUtils.html,1,['safe'],['safely']
